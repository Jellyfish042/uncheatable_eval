[
    "//  MIT License\n//\n//  Copyright (c) 2023 \u6709\u4e2a\u5c0f\u5c0f\u675c\n//\n//  Created by \u6709\u4e2a\u5c0f\u5c0f\u675c\n//\n\n#include \"../ktm/ktm.h\"\n\nint main(int argc, char* argv[])\n{\n    std::cout << \"mat_mul_vec test:\" << std::endl;\n    ktm::fmat3x2 mt1 = { { 1, 2}, { 1, 2 }, {3, 4} };\n    ktm::fvec3 v1 = { 2, 2, 2};\n\n    std::cout << mt1 << std::endl;\n    std::cout << v1 << std::endl;\n    std::cout << mt1 * v1 << std::endl;\n\n    std::cout << \"vec_mul_mat test:\" << std::endl;\n    ktm::fmat3x2 mt2 = { { 3, 2}, { 1, 2 }, {3, 4} };\n    ktm::fvec2 v2 = { 2, 1 };\n\n    std::cout << mt2 << std::endl;\n    std::cout << v2 << std::endl;\n    std::cout << v2 * mt2 << std::endl;\n\n    std::cout << \"mat_mul_mat test:\" << std::endl; \n    ktm::fmat3x2 mt3 = { { 3, 2}, { 1, 2 }, {3, 4} };\n    ktm::fmat2x3 mt4 = { {3, 3, 3}, { 1, 1, 1}};\n    std::cout << mt3 << std::endl;\n    std::cout << mt4 << std::endl;\n    std::cout << mt3 * mt4 << std::endl;\n\n    std::cout << \"add test:\" << std::endl; \n    ktm::fmat4x3 mt5 = { {3, 3, 3}, { 1, 1, 1}, { 2, 3, 3}, { }};\n    std::cout << mt5 << std::endl;\n    std::cout << mt5 + mt5 << std::endl;\n\n    std::cout << \"equal test:\" << std::endl; \n    ktm::fmat4x3 mt6 = mt5; \n    std::cout << (mt5 == mt6) << \",\" << (mt5 == ktm::fmat4x3()) << std::endl;\n\n    std::cout << \"transpose test:\" << std::endl; \n    ktm::fmat3x3 mt7_1 = { { 2, -1, 207 }, {-1, 2, -1}, { 20, -1, 2 } };\n    std::cout << mt7_1 << std::endl;\n    std::cout << ktm::transpose(mt7_1) << std::endl; \n    ktm::fmat2x2 mt7_2 = { { 2, -1 }, { 50, 20 } };\n    std::cout << mt7_2 << std::endl;\n    std::cout << ktm::transpose(mt7_2) << std::endl; \n\n    std::cout << \"determinant test:\" << std::endl;  \n    ktm::fmat4x4 mt8 = { {2, -1, 9, 9}, {-1, 2, -1, -8}, { 20, -1, 2, 2}, { 1, 3, 2, 77 }};\n    ktm::smat4x4 smt8 = { {2, -1, 9, 9}, {-1, 2, -1, -8}, { 20, -1, 2, 2}, { 1, 3, 2, 77 }};\n    std::cout << ktm::determinant(mt8) << \"\\n\" << ktm::determinant(smt8) << std::endl;\n\n    std::cout << \"inverse test:\" << std::endl;  \n    ktm::fmat4x4 mt9 = { {2, -1, 9, 9}, {-1, 2, -1, -8}, { 20, -1, 2, 2}, { 1, 3, 2, 77 }};\n    std::cout << ktm::inverse(mt9) * mt9 * mt8 << std::endl;\n\n    std::cout << \"factor lu test:\" << std::endl;\n    auto lu = ktm::factor_lu(mt8);\n    std::cout << std::get<0>(lu) << \"\\n\" << std::get<1>(lu) << \"\\n\" << std::get<0>(lu) * std::get<1>(lu) << std::endl;\n\n    std::cout << \"factor qr test:\" << std::endl;\n    auto qr = ktm::factor_qr(mt8);\n    std::cout << std::get<0>(qr) << \"\\n\" << std::get<1>(qr) << \"\\n\" << std::get<0>(qr) * std::get<1>(qr) << std::endl;\n\n    std::cout << \"factor svd test:\" << std::endl;\n    auto usv = ktm::factor_svd(mt8);\n    std::cout << std::get<0>(usv) << \"\\n\" << std::get<1>(usv) << \"\\n\" << std::get<2>(usv) \n        << \"\\n\" << std::get<0>(usv) * std::get<1>(usv) * std::get<2>(usv) << std::endl; \n\n    return 0;\n}",
    "#include \"OSK.h\"\n\ntypedef BOOL(WINAPI* DwmGetDxSharedSurface_td) (\n\t__in HWND hwnd,\n\t__out_opt HANDLE* p1,\n\t__out_opt LUID* p2,\n\t__out_opt ULONG* p3,\n\t__out_opt ULONG* p4,\n\t__out_opt ULONGLONG* p5);\n\nDwmGetDxSharedSurface_td DwmGetSharedSurface = ((DwmGetDxSharedSurface_td)GetProcAddress(GetModuleHandle(TEXT(\"USER32\")), \"DwmGetDxSharedSurface\"));\n\n\n\nPROCESSENTRY32W OSK::FindProcess(std::wstring toFind)\n{\n\tPROCESSENTRY32W entry;\n\tentry.dwSize = sizeof(PROCESSENTRY32W);\n\n\tHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (snapshot == INVALID_HANDLE_VALUE)\n\t\treturn PROCESSENTRY32W();\n\tif (!Process32FirstW(snapshot, &entry))\n\t\treturn PROCESSENTRY32W();\n\n\tdo\n\t{\n\t\tstd::wstring fileName(entry.szExeFile);\n\t\tif (fileName == toFind)\n\t\t{\n\t\t\tCloseHandle(snapshot);\n\t\t\treturn entry;\n\t\t}\n\t} while (Process32NextW(snapshot, &entry));\n\tCloseHandle(snapshot);\n\treturn PROCESSENTRY32W();\n}\n\nvoid OSK::ToggleOSK()\n{\n\tINPUT input[6];\n\tZeroMemory(input, sizeof(INPUT) * 6);\n\tinput[0].type = INPUT_KEYBOARD;\n\tinput[0].ki.wVk = VK_LCONTROL;\n\tinput[0].ki.dwFlags = 0;\n\tinput[1].type = INPUT_KEYBOARD;\n\tinput[1].ki.wVk = VK_LWIN;\n\tinput[1].ki.dwFlags = 0;\n\tinput[2].type = INPUT_KEYBOARD;\n\tinput[2].ki.wVk = VkKeyScan('O');\n\tinput[2].ki.dwFlags = 0;\n\n\tinput[3].type = INPUT_KEYBOARD;\n\tinput[3].ki.wVk = VkKeyScan('O');\n\tinput[3].ki.dwFlags = KEYEVENTF_KEYUP;\n\tinput[4].type = INPUT_KEYBOARD;\n\tinput[4].ki.wVk = VK_LWIN;\n\tinput[4].ki.dwFlags = KEYEVENTF_KEYUP;\n\tinput[5].type = INPUT_KEYBOARD;\n\tinput[5].ki.wVk = VK_LCONTROL;\n\tinput[5].ki.dwFlags = KEYEVENTF_KEYUP;\n\tSendInput(6, input, sizeof(INPUT));\n}\n\nvoid OSK::CreateOSKTexture9(IDirect3DDevice9* device, stBasicTexture9* oskTexture)\n{\n\t//----\n\t// Creates the given texture to be a copy of the onscreen keyboard\n\t//----\n\tif (oskSharedTexture9.pTexture) { oskSharedTexture9.Release(); }\n\tif (oskTexture->pTexture) { oskTexture->Release(); }\n\n\tif (oskLayout.hwnd)\n\t{\n\t\t//----\n\t\t// Get the position of the keyboard and get the very top left point of the keyboard window\n\t\t// to remove the top bar and border\n\t\t//----\n\t\tRECT rectFull;\n\t\tGetWindowRect(oskLayout.hwnd, &rectFull);\n\t\tPOINT sizeFull = { rectFull.right - rectFull.left, rectFull.bottom - rectFull.top };\n\n\t\t//----\n\t\t// Get the actual client size of the keyboard\n\t\t//----\n\t\tRECT rectBody;\n\t\tGetClientRect(oskLayout.hwnd, &rectBody);\n\t\tPOINT sizeBody = { rectBody.right - rectBody.left, rectBody.bottom - rectBody.top };\n\n\n\t\tPOINT point = { rectFull.left, rectFull.top };\n\t\tScreenToClient(oskLayout.hwnd, &point);\n\t\tdisplayRect.left = std::abs(point.x);\n\t\tdisplayRect.top = std::abs(point.y);\n\t\tdisplayRect.right = sizeBody.x;\n\t\tdisplayRect.bottom = sizeBody.y;\n\n\n\t\toskSharedTexture9.SetWidthHeight(sizeFull.x, sizeFull.y);\n\t\tif (oskSharedTexture9.Create(device, false, true, false, true))\n\t\t{\n\t\t\toskLayout.width = sizeBody.x;\n\t\t\toskLayout.height = sizeBody.y;\n\n\t\t\toskTexture->SetWidthHeight(oskLayout.width, oskLayout.height);\n\t\t\toskTexture->Create(device, false, true, false, false);\n\t\t\t\n\t\t\toskLayout.haveLayout = true;\n\t\t}\n\t}\n}\n\nvoid OSK::CopyOSKTexture9(IDirect3DDevice9* device, stBasicTexture9* oskTexture)\n{\n\t//----\n\t// Copy the on screen keyboard to the given texture\n\t//----\n\tif (oskLayout.hwnd)\n\t{\n\t\tLUID adapter = LUID();\n\t\tULONG pFmtWindow = 0;\n\t\tULONG pPresentFlags = 0;\n\t\tULONGLONG pWin32kUpdateId = 0;\n\t\tHANDLE toskSurface;\n\n\t\tDwmGetSharedSurface(oskLayout.hwnd, &toskSurface, &adapter, &pFmtWindow, &pPresentFlags, &pWin32kUpdateId);\n\t\tif (toskSurface != oskSharedTexture9.pSharedHandle)\n\t\t{\n\t\t\toskSharedTexture9.pSharedHandle = toskSurface;\n\t\t\tCreateOSKTexture9(device, oskTexture);\n\t\t}\n\n\t\t//devCon->CopyResource(oskTexture->pTexture, oskSharedTexture.pTexture);\n\t\t//D3D11_BOX oskTextureCutout = { static_cast<unsigned int>(displayRect.left), static_cast<unsigned int>(displayRect.top), 0, static_cast<unsigned int>(displayRect.left + displayRect.right),static_cast<unsigned int>(displayRect.top + displayRect.bottom), 1 };\n\n\t\tRECT size{ displayRect.left, displayRect.top, displayRect.left + displayRect.right, displayRect.top + displayRect.bottom };\n\t\tHRESULT result = device->StretchRect(oskSharedTexture9.pShaderResource, &size, oskTexture->pShaderResource, NULL, D3DTEXF_NONE);\n\t\tint a = 1;\n\t}\n}\n\nbool OSK::LoadOSK9(IDirect3DDevice9* device, stBasicTexture9* oskTexture, RECT position)\n{\n\t//----\n\t// Find the on screen keyboard, if it isnt loaded, load it and wait for it to be found\n\t// otherwise resize it and create the texture\n\t//----\n\tis9 = true;\n\n\tbool haveFoundKeyboard = false;\n\tint haveFoundKeyboardCount = 100;\n\n\tPROCESSENTRY32W osk = FindProcess(L\"osk.exe\");\n\tif (osk.th32ProcessID != 0)\n\t{\n\t\thaveFoundKeyboard = true;\n\t}\n\telse if (osk.th32ProcessID == 0)\n\t{\n\t\tToggleOSK();\n\t\twhile (!haveFoundKeyboard && haveFoundKeyboardCount > 0)\n\t\t{\n\t\t\tosk = FindProcess(L\"osk.exe\");\n\t\t\tif (osk.th32ProcessID != 0)\n\t\t\t\thaveFoundKeyboard = true;\n\t\t\thaveFoundKeyboardCount--;\n\t\t}\n\t}\n\n\tif (haveFoundKeyboard)\n\t{\n\t\toskLayout.hwnd = FindWindowA(\"OSKMainClass\", NULL);\n\t\t",
    "#include <array>\n#include \"cpu.hpp\"\n\n#include \"unit/munit.hpp\"\n#include \"unit/iunit.hpp\"\n#include \"unit/bunit.hpp\"\n#include \"unit/lxunit.hpp\"\n#include \"unit/funit.hpp\"\n\n\nstd::array<HandleFn, 3> Ia64Bundle::Handle(Ia64Cpu *cpu) {\n    std::array<HandleFn, 3> out {};\n\n    Ia64Format format0 {this, 0}; \n    Ia64Format format1 {this, 1}; \n    Ia64Format format2 {this, 2};\n\n    switch(_template) {\n        case Ia64BundleTemplate::MII_0: \n        case Ia64BundleTemplate::MII_1: \n        case Ia64BundleTemplate::MII_2: \n        case Ia64BundleTemplate::MII_3: {\n            debugprintf(\"bundle MII %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = IUnit::Handle(&format1, cpu);\n            out[2] = IUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MLX_4:\n        case Ia64BundleTemplate::MLX_5: {\n            debugprintf(\"bundle MLX %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = nullptr; // indicator for lxunit\n            out[2] = LXUnit::Handle(&format1, &format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MMI_8: \n        case Ia64BundleTemplate::MMI_9: \n        case Ia64BundleTemplate::MMI_A:\n        case Ia64BundleTemplate::MMI_B: {\n            debugprintf(\"bundle MMI %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = MUnit::Handle(&format1, cpu);\n            out[2] = IUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MFI_C:\n        case Ia64BundleTemplate::MFI_D: {\n            debugprintf(\"bundle MFI %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = FUnit::Handle(&format1, cpu);\n            out[2] = IUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MMF_E:\n        case Ia64BundleTemplate::MMF_F: {\n            debugprintf(\"bundle MMF %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = MUnit::Handle(&format1, cpu);\n            out[2] = FUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MIB_10:\n        case Ia64BundleTemplate::MIB_11: {\n            debugprintf(\"bundle MIB %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = IUnit::Handle(&format1, cpu);\n            out[2] = BUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MBB_12: \n        case Ia64BundleTemplate::MBB_13: {\n            debugprintf(\"bundle MBB %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = BUnit::Handle(&format1, cpu);\n            out[2] = BUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::BBB_16:\n        case Ia64BundleTemplate::BBB_17: {\n            debugprintf(\"bundle BBB %x\\n\", _template);\n            out[0] = BUnit::Handle(&format0, cpu);\n            out[1] = BUnit::Handle(&format1, cpu);\n            out[2] = BUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MMB_18:\n        case Ia64BundleTemplate::MMB_19: {\n            debugprintf(\"bundle MMB %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = MUnit::Handle(&format1, cpu);\n            out[2] = BUnit::Handle(&format2, cpu);\n            break;\n        }\n        case Ia64BundleTemplate::MFB_1C:\n        case Ia64BundleTemplate::MFB_1D: {\n            debugprintf(\"bundle MFB %x\\n\", _template);\n            out[0] = MUnit::Handle(&format0, cpu);\n            out[1] = FUnit::Handle(&format1, cpu);\n            out[2] = BUnit::Handle(&format2, cpu);\n            break;\n        }\n        default: {\n            fprintf(stderr, \"bad bundle %x!!\\n\", _template);\n            exit(1);\n        }\n    }\n    return out;\n}\n",
    "#include \"yolov8face.h\"\n#include \"face68landmarks.h\"\n#include \"facerecognizer.h\"\n#include \"faceswap.h\"\n#include \"faceenhancer.h\"\n\nusing namespace cv;\nusing namespace std;\n\nint main()\n{\n\tstring source_path = \"/project/faceswap-cpp/images/5.jpg\";\n\tstring target_path = \"/project/faceswap-cpp/images/target.jpg\";\n    \n\t////\u56fe\u7247\u8def\u5f84\u548connx\u6587\u4ef6\u7684\u8def\u5f84\uff0c\u8981\u786e\u4fdd\u5199\u6b63\u786e\uff0c\u624d\u80fd\u4f7f\u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\u7684\n\tYolov8Face detect_face_net(\"/project/faceswap-cpp/weights/yoloface_8n.onnx\");\n\tFace68Landmarks detect_68landmarks_net(\"/project/faceswap-cpp/weights/2dfan4.onnx\");\n\tFaceEmbdding face_embedding_net(\"/project/faceswap-cpp/weights/arcface_w600k_r50.onnx\");\n\tSwapFace swap_face_net(\"/project/faceswap-cpp/weights/inswapper_128.onnx\");\n\tFaceEnhance enhance_face_net(\"/project/faceswap-cpp/weights/gfpgan_1.4.onnx\");\n\n\tMat source_img = imread(source_path);\n\tMat target_img = imread(target_path);\n\n    vector<Bbox> boxes;\n\tdetect_face_net.detect(source_img, boxes);\n\tint position = 0; ////\u4e00\u5f20\u56fe\u7247\u91cc\u53ef\u80fd\u6709\u591a\u4e2a\u4eba\u8138\uff0c\u8fd9\u91cc\u53ea\u8003\u86511\u4e2a\u4eba\u8138\u7684\u60c5\u51b5\n\tvector<Point2f> face_landmark_5of68;\n\tvector<Point2f> face68landmarks = detect_68landmarks_net.detect(source_img, boxes[position], face_landmark_5of68);\n\tvector<float> source_face_embedding = face_embedding_net.detect(source_img, face_landmark_5of68);\n\n\tdetect_face_net.detect(target_img, boxes);\n\tposition = 0; ////\u4e00\u5f20\u56fe\u7247\u91cc\u53ef\u80fd\u6709\u591a\u4e2a\u4eba\u8138\uff0c\u8fd9\u91cc\u53ea\u8003\u86511\u4e2a\u4eba\u8138\u7684\u60c5\u51b5\n\tvector<Point2f> target_landmark_5;\n\tdetect_68landmarks_net.detect(target_img, boxes[position], target_landmark_5);\n\n\tMat swapimg = swap_face_net.process(target_img, source_face_embedding, target_landmark_5);\n\tMat resultimg = enhance_face_net.process(swapimg, target_landmark_5);\n\t\n\timwrite(\"resultimg.jpg\", resultimg);\n\n\t/*static const string kWinName = \"Deep learning face swap use onnxruntime\";\n\tnamedWindow(kWinName, WINDOW_NORMAL);\n\timshow(kWinName, resultimg);\n\twaitKey(0);\n\tdestroyAllWindows();*/\n}",
    "#include \"LEDController.h\"\n#include <queue>\n\nstatic Preferences preferences;\n\n// Information about the default program values\nconst uint8_t DEFAULT_BRIGHTNESS = 150;\nconst uint16_t DEFAULT_TEMPERATURE = 4500;\n\n// Information about the colours the LEDs will flash when setting a mode\nconst CRGB MODE_BRIGHTNESS_COLOUR = CRGB(0, 0, 255); // blue\nconst CRGB MODE_TEMPERATURE_COLOUR = CRGB(255, 0, 255); // purple\nconst CRGB MODE_DIRECTION_COLOUR = CRGB(0, 255, 0); // green\nconst uint16_t MODE_FLASH_DURATION = 500; // 0.5s\n\n// Event Operation\nenum EventOperations{BrightnessOperation = 1, TemperatureOperation = 2, DirectionOperation = 3, PowerOperation = 4};\n\nstatic CRGB LEDs[LED_COUNT];\n\n// Define a struct to represent an event\nstruct LEDEvent {\n    EventOperations name;\n    uint16_t parameter;\n\n    LEDEvent(EventOperations name, int parameter)\n            : name(name), parameter(parameter) {}\n};\n\nstd::queue<LEDEvent> LedEvents;\n\nvoid LEDController::Process(){\n    // Process the event queue\n    while (!LedEvents.empty()) {\n        LEDEvent ev = LedEvents.front(); // Get the operation at the front of the queue\n        LedEvents.pop(); // Remove the operation from the queue\n\n        switch (ev.name){\n            case BrightnessOperation:\n                BrightnessEvent(ev.parameter);\n                break;\n            case TemperatureOperation:\n                TemperatureEvent(ev.parameter);\n                break;\n\n            case DirectionOperation:\n                DirectionEvent(ev.parameter);\n                break;\n\n            case PowerOperation:\n                PowerEvent(ev.parameter);\n                break;\n            default:\n                break;\n        }\n    }\n}\n\nvoid LEDController::begin(){\n    // Set variable values\n    // LED Variables\n\n    currentDirection = 0;\n\n    // Initialize the LED ring\n    CFastLED::addLeds<CHIPSET, LED_PIN, GRB>(LEDs, LED_COUNT);\n\n    // Retrieve variables\n    preferences.begin(\"storage\", false);\n    currentBrightness = preferences.getUChar(\"brightness\", DEFAULT_BRIGHTNESS);\n    uint16_t retrievedTemperature = preferences.getUShort(\"temperature\", DEFAULT_TEMPERATURE);\n    preferences.end();\n\n    TRACELN(\"Loaded State\")\n    TRACE(\"Brightness: \")\n    TRACE(currentBrightness)\n    TRACE(\"\\nTemperature: \")\n    TRACE(retrievedTemperature)\n    TRACE(\"\\n\\n\")\n\n    if (retrievedTemperature >= 1000 && retrievedTemperature <= 12000){\n        currentTemperature = retrievedTemperature;\n    }\n    else{\n        currentTemperature = DEFAULT_TEMPERATURE;\n    }\n\n    currentMode = ModeBrightness;\n    setTemperature(currentTemperature);\n    setBrightness(currentBrightness);\n}\n\nvoid LEDController::TemperatureEvent(uint16_t kelvin) {\n\n    TRACELN(\"Temperature: \")\n    TRACE(kelvin)\n    TRACE(\"\\n\")\n    // Sets kelvin temperature value between 700 and 12000\n    if (kelvin < 700 || kelvin > 12000) {\n        return;\n    }\n\n    uint16_t temp;\n    temp = uint16_t(kelvin / 100.0);\n    int red, green, blue;\n    // Calculate Red\n    if (temp <= 66) {\n        red = 255;\n    } else {\n        red = temp - 60;\n        red = int(329.698727446 * (pow(red, -0.1332047592)));\n        red = std::min(std::max(red, 0), 255);\n    }\n\n    // Calculate Green\n    if (temp <= 66) {\n        green = temp;\n        green =  int(99.4708025861 * log(green) - 161.1195681661);\n        green = std::min(std::max(int(green), 0), 255);\n    } else {\n        green = temp - 60;\n        green =  int(288.1221695283 * (pow(green, -0.0755148492)));\n        green = std::min(std::max(green, 0), 255);\n    }\n\n    // Calculate Blue\n    if (temp >= 66) {\n        blue = 255;\n    } else if (temp <= 19) {\n        blue = 0;\n    } else {\n        blue = temp - 10;\n        blue = int(138.5177312231 * log(blue) - 305.0447927307);\n        blue = std::min(std::max(blue, 0), 255);\n    }\n\n    for(auto & led : LEDs) {\n        // let's set an led value\n        led = CRGB(red, green, blue);\n    }\n\n    currentTemperature = kelvin;\n    FastLED.show();\n    saveState();\n}\nvoid LEDController::BrightnessEvent(uint16_t brightness){\n    TRACE(\"Brightness: \")\n    TRACE(brightness)\n    TRACE(\"\\n\")\n    if (brightness >= 0 && brightness <= 255) {\n        FastLED.setBrightness(brightness);\n        FastLED.show();\n        currentBrightness = brightness;\n        saveState();\n    }\n}\n\nvoid LEDController::DirectionEvent(uint16_t direction) {\n    // direction value 0 to 26\n    TRACE(\"Direction: \")\n    TRACE(direction)\n    TRACE(\"\\n\")\n\n    uint8_t position;\n\n    if (direction == 0){ // turn on all LEDs\n        for(auto & LED : LEDs) {\n            LED = CRGB(255,255,255);\n        }\n    }\n    else{\n        // turn off all LEDs\n        for(auto & LED : LEDs) {\n            // let's set an led value\n            LED = CRGB(0,0,0);\n        }\n\n        // turn on 5 inner LEDs\n        for(uint8_t i = 0; i < 5; i++) {\n            // let's set an led value\n            position = i + direction;\n            if (position >= 26) position = position - 26;\n            LEDs[position] = CRGB(255,255,2",
    "#define GLEW_STATIC\r\n#include <GL/glew.h>\r\n#include <GLFW/glfw3.h>\r\n#pragma comment(lib,\"../API/GLFW/glfw3.lib\")\r\n#pragma comment(lib,\"../API/GLEW/glew32s.lib\")\r\n#pragma comment(lib,\"Opengl32.lib\")\r\n#include <iostream>\r\n#include <string>\r\n\r\n#include \"imgui.h\"\r\n#include \"imgui_impl_glfw.h\"\r\n#include \"imgui_impl_opengl3.h\"\r\n#include \"GUI.h\"\r\n\r\nGLFWwindow* Windows;\r\n\r\nint main()\r\n{\r\n\tglfwInit();\r\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\r\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\r\n\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\r\n\r\n\tWindows = glfwCreateWindow(900, 800, \"HalfPeople-Imgui\", NULL, NULL);\r\n\r\n\tglfwMakeContextCurrent(Windows);\r\n\tglfwSwapInterval(0);\r\n\r\n\tIMGUI_CHECKVERSION();\r\n\tImGui::CreateContext(NULL);\r\n\tImGuiIO& io = ImGui::GetIO(); (void)io;\r\n\tio.Fonts->AddFontFromFileTTF(\"kaiu.ttf\", 18, NULL, io.Fonts->GetGlyphRangesChineseFull());\r\n\r\n\tio.ConfigFlags |= ImGuiConfigFlags_DockingEnable;\r\n\tio.ConfigFlags |= ImGuiViewportFlags_NoDecoration;\r\n\tio.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;\r\n\tio.ConfigFlags |= ImGuiCol_DockingEmptyBg;\r\n\r\n\tImGui::StyleColorsDark();\r\n\tImGuiStyle& style = ImGui::GetStyle();\r\n\r\n\tImVec4* colors = style.Colors;\r\n\tcolors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.16f, 0.17f, 1.00f);\r\n\tcolors[ImGuiCol_FrameBgHovered] = ImVec4(0.37f, 0.36f, 0.36f, 102.00f);\r\n\tcolors[ImGuiCol_FrameBgActive] = ImVec4(0.10f, 0.10f, 0.10f, 171.00f);\r\n\tcolors[ImGuiCol_TitleBgActive] = ImVec4(0.20f, 0.20f, 0.20f, 255.00f);\r\n\tcolors[ImGuiCol_CheckMark] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);\r\n\tcolors[ImGuiCol_SliderGrab] = ImVec4(0.64f, 0.64f, 0.64f, 1.00f);\r\n\tcolors[ImGuiCol_SliderGrabActive] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);\r\n\tcolors[ImGuiCol_Button] = ImVec4(0.22f, 0.22f, 0.22f, 0.40f);\r\n\tcolors[ImGuiCol_ButtonHovered] = ImVec4(0.29f, 0.29f, 0.29f, 1.00f);\r\n\tcolors[ImGuiCol_ButtonActive] = ImVec4(0.13f, 0.13f, 0.13f, 1.00f);\r\n\tcolors[ImGuiCol_Header] = ImVec4(0.45f, 0.45f, 0.45f, 0.31f);\r\n\tcolors[ImGuiCol_HeaderHovered] = ImVec4(0.55f, 0.55f, 0.55f, 0.80f);\r\n\tcolors[ImGuiCol_HeaderActive] = ImVec4(0.09f, 0.09f, 0.09f, 1.00f);\r\n\tcolors[ImGuiCol_ResizeGrip] = ImVec4(1.00f, 1.00f, 1.00f, 0.20f);\r\n\tcolors[ImGuiCol_ResizeGripHovered] = ImVec4(0.46f, 0.46f, 0.46f, 0.67f);\r\n\tcolors[ImGuiCol_ResizeGripActive] = ImVec4(0.17f, 0.17f, 0.17f, 0.95f);\r\n\tcolors[ImGuiCol_SeparatorActive] = ImVec4(0.42f, 0.42f, 0.42f, 1.00f);\r\n\tcolors[ImGuiCol_SeparatorHovered] = ImVec4(0.50f, 0.50f, 0.50f, 0.78f);\r\n\tcolors[ImGuiCol_TabHovered] = ImVec4(0.45f, 0.45f, 0.45f, 0.80f);\r\n\tcolors[ImGuiCol_TabActive] = ImVec4(0.28f, 0.28f, 0.28f, 1.00f);\r\n\tcolors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.19f, 0.19f, 0.19f, 1.00f);\r\n\tcolors[ImGuiCol_DockingPreview] = ImVec4(0.51f, 0.51f, 0.51f, 0.70f);\r\n\tcolors[ImGuiCol_Tab] = ImVec4(0.21f, 0.21f, 0.21f, 0.86f);\r\n\tcolors[ImGuiCol_TabUnfocused] = ImVec4(0.15f, 0.15f, 0.15f, 0.97f);\r\n\tcolors[ImGuiCol_NavHighlight] = ImVec4(1.00f, 0.40f, 0.13f, 1.00f);\r\n\tcolors[ImGuiCol_TextSelectedBg] = ImVec4(0.45f, 1.00f, 0.85f, 0.35f);\r\n\r\n\tstyle.WindowRounding = 4;\r\n\tstyle.FrameRounding = 4;\r\n\tstyle.GrabRounding = 3;\r\n\tstyle.ScrollbarSize = 7;\r\n\tstyle.ScrollbarRounding = 0;\r\n\r\n\tImGui_ImplGlfw_InitForOpenGL(Windows, true);\r\n\tImGui_ImplOpenGL3_Init(\"#version 330\");\r\n\r\n\twhile (!glfwWindowShouldClose(Windows))\r\n\t{\r\n\t\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\t\tImGui_ImplOpenGL3_NewFrame();\r\n\t\tImGui_ImplGlfw_NewFrame();\r\n\t\tImGui::NewFrame();\r\n\t\tImGui::DockSpaceOverViewport();\r\n\r\n\t\tDrawGUI();\r\n\r\n\t\tImGui::ShowDemoWindow();\r\n\r\n\t\tImGui::Render();\r\n\t\tImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\r\n\r\n\t\tif (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)\r\n\t\t{\r\n\t\t\tGLFWwindow* backup_current_context = glfwGetCurrentContext();\r\n\t\t\tImGui::UpdatePlatformWindows();\r\n\t\t\tImGui::RenderPlatformWindowsDefault();\r\n\t\t\tglfwMakeContextCurrent(backup_current_context);\r\n\t\t}\r\n\r\n\t\tglfwSwapBuffers(Windows);\r\n\t\tglfwPollEvents();\r\n\t}\r\n}",
    "// Copyright \u00a9 2024 Yury Popov (@djphoenix).\n\n#include \"ctc_loss/ctc_loss.h\"\n\n#ifdef _METAL_\n#include \"mlx/backend/metal/device.h\"\n#include \"mlx/backend/metal/utils.h\"\n#endif\n\nnamespace mlx::core {\n\n#define assert_contiguous(a) \\\n  if (a.strides()[a.ndim()-1] != 1) throw std::runtime_error(#a \" should be contiguous on last dimension\")\n\n#ifdef _METAL_\n\nstatic const std::string lib_name = \"mlx_ctc\";\n\ntemplate<typename ...As>\nstatic inline void dispatch_kernel(\n  const Stream &s,\n  const std::string &kname,\n  MTL::Size grid_size,\n  std::initializer_list<const array> inputs,\n  std::initializer_list<array> outputs,\n  As ...args\n) {\n  auto& d = metal::device(s.device);\n  d.register_library(lib_name, metal::get_colocated_mtllib_path);\n\n  auto& compute_encoder = d.get_command_encoder(s.index);\n  auto kernel = d.get_kernel(kname, lib_name);\n  compute_encoder->setComputePipelineState(kernel);\n\n  size_t idx = 0;\n  for (auto a : inputs ) compute_encoder.set_input_array (a, idx++);\n  for (auto a : outputs) compute_encoder.set_output_array(a, idx++);\n  (compute_encoder->setBytes(&args, sizeof(As), idx++), ...);\n\n  size_t num_th = kernel->maxTotalThreadsPerThreadgroup();\n  MTL::Size group_size;\n  group_size.width  = std::min<size_t>(grid_size.width , num_th);\n  num_th = std::max<size_t>(1, num_th / group_size.width);\n  group_size.height = std::min<size_t>(grid_size.height, num_th);\n  num_th = std::max<size_t>(1, num_th / group_size.height);\n  group_size.depth  = std::min<size_t>(grid_size.depth , num_th);\n\n  compute_encoder->dispatchThreads(grid_size, group_size);\n}\n\nstatic inline void dispatch_fill_z(const Stream &s, array &a) {\n  dispatch_kernel(\n    s, \"ctc_loss_fill_z_\" + type_to_name(a),\n    MTL::Size(a.data_size(), 1, 1),\n    {}, { a }\n  );\n}\n\nvoid CTCLoss::eval_gpu(const std::vector<array>& inputs, std::vector<array>& outarr) {\n  auto& log_probs      = inputs[0];\n  auto& targets        = inputs[1];\n  auto& input_lengths  = inputs[2];\n  auto& target_lengths = inputs[3];\n  auto& loss           = outarr[0];\n  auto& log_alpha      = outarr[1];\n\n  size_t batch_size     = log_probs.shape()[1];\n  size_t max_target_len = targets.shape()[1];\n\n  log_alpha.set_data(allocator::malloc_or_wait(log_alpha.nbytes()));\n  loss.set_data(allocator::malloc_or_wait(loss.nbytes()));\n\n  assert_contiguous(log_probs);\n  assert_contiguous(targets);\n  assert_contiguous(input_lengths);\n  assert_contiguous(target_lengths);\n  assert_contiguous(loss);\n  assert_contiguous(log_alpha);\n\n  size_t logp_stride_T = log_probs.strides()[0];\n  size_t logp_stride_B = log_probs.strides()[1];\n  size_t  tgt_stride_B = targets  .strides()[0];\n  size_t loga_stride_T = log_alpha.strides()[0];\n  size_t loga_stride_B = log_alpha.strides()[1];\n  \n  std::string data_type = type_to_name(log_probs);\n  std::string indx_type = type_to_name(targets);\n\n  dispatch_kernel(\n    stream(),\n    \"ctc_loss_alpha_\" + data_type + \"_\" + indx_type,\n    MTL::Size(max_target_len + 1, batch_size, 1),\n    {\n      log_probs,\n      targets,\n      target_lengths,\n      input_lengths,\n    },\n    { log_alpha },\n    blank_,\n    tgt_stride_B,\n    loga_stride_T, loga_stride_B,\n    logp_stride_T, logp_stride_B\n  );\n\n  dispatch_kernel(\n    stream(),\n    \"ctc_loss_final_\" + data_type + \"_\" + indx_type,\n    MTL::Size(batch_size, 1, 1),\n    {\n      target_lengths,\n      input_lengths,\n      log_alpha,\n    },\n    { loss },\n    loga_stride_T, loga_stride_B\n  );\n}\n\nvoid CTCLossVJP::eval_gpu(const std::vector<array>& inputs, std::vector<array>& outarr) {\n  auto& s = stream();\n  auto& d = metal::device(s.device);\n  d.register_library(lib_name, metal::get_colocated_mtllib_path);\n\n  auto& log_probs      = inputs[0];\n  auto& targets        = inputs[1];\n  auto& input_lengths  = inputs[2];\n  auto& target_lengths = inputs[3];\n  auto& log_alpha      = inputs[4];\n  auto& nll            = inputs[5];\n  auto& ctg            = inputs[6];\n  auto& grad           = outarr[0];\n\n  array log_beta (log_alpha.shape(), log_alpha.dtype(), nullptr, {});\n\n  size_t max_input_length = log_probs.shape()[0];\n  size_t batch_size       = log_probs.shape()[1];\n  size_t max_target_len   = targets  .shape()[1];\n  size_t num_channels     = log_probs.shape()[2];\n\n  grad.set_data(allocator::malloc_or_wait(grad.nbytes()));\n  log_beta.set_data(allocator::malloc_or_wait(log_beta.nbytes()));\n\n  assert_contiguous(log_probs);\n  assert_contiguous(targets);\n  assert_contiguous(input_lengths);\n  assert_contiguous(target_lengths);\n  assert_contiguous(log_alpha);\n  assert_contiguous(nll);\n  assert_contiguous(ctg);\n  assert_contiguous(grad);\n  assert_contiguous(log_beta);\n\n  size_t logp_stride_T = log_probs.strides()[0];\n  size_t logp_stride_B = log_probs.strides()[1];\n  size_t  tgt_stride_B = targets  .strides()[0];\n  size_t loga_stride_T = log_alpha.strides()[0];\n  size_t loga_stride_B = log_alpha.strides()[1];\n  size_t logb_stride_T = log_beta .strides()[0];\n  size_t logb_stride_B = log_beta .strides()[1];\n  size_t grad_stride_T = grad.strides()[0];\n ",
    "#include \"interacttab.hpp\"\n#include \"ui_interacttab.h\"\n#include \"Include/helper/colortext.hpp\"\n#include \"Include/command/command.h\"\n#include \"QFont\"\n#include \"QKeyEvent\"\n#include \"global.hpp\"\n\n\n\nconst int PrintConsoleShell =1;\nconst int PrintConsoleSendTask =2;\nconst int PrintConsoleWarning =3;\nconst int PrintConsoleSuccessful =4;\n\ninteractTab::interactTab(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::interactTab)\n{\n    ui->setupUi(this);\n    MainCommands=new command();\n    QFont font(\"Consolas\", 11);\n    this->ui->interactTextEdit->setFont(font);\n    for (const auto& command : CommandList) {\n        CommandCompleterList.append(command.CommandString);\n        if(command.CommandString!=\"help\"){\n            CommandCompleterList.append(\"help \"+command.CommandString);\n        }\n    }\n    ui->InteractLineEdit->installEventFilter(this);\n    commandHistoryIndex = 0;\n    // Create a new completer using the filtered commands\n    QCompleter *completer = new QCompleter(CommandCompleterList, this);\n\n    // Set the completion mode to PopupCompletion\n    completer->setCaseSensitivity(Qt::CaseInsensitive);\n    completer->setCompletionMode(QCompleter::InlineCompletion);\n\n//    // Set the completer to the line edit\n    ui->InteractLineEdit->setCompleter(completer);\n\n\n\n}\n\ninteractTab::~interactTab()\n{\n    delete ui;\n}\nbool interactTab::eventFilter(QObject *obj, QEvent *event) {\n    if (obj == ui->InteractLineEdit && event->type() == QEvent::KeyPress) {\n        QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);\n        switch (keyEvent->key()) {\n            case Qt::Key_Tab:\n                qDebug(\"tab clicked\");\n                handleTabKey();\n                return true;\n            case Qt::Key_Up:\n            qDebug(\"Key_Up clicked\");\n                handleUpKey();\n                return true;\n            case Qt::Key_Down:\n            qDebug(\"DownKey clicked\");\n                handleDownKey();\n                return true;\n            default:\n                break;\n        }\n    }\n    // Call base class method for unhandled events\n    return QWidget::eventFilter(obj, event);\n}\n\nvoid interactTab::handleTabKey() {\n    // Check if the line edit has a completer\n    if (ui->InteractLineEdit->completer()) {\n        QString completedString = ui->InteractLineEdit->completer()->currentCompletion();\n        if (!completedString.isEmpty()) {\n            ui->InteractLineEdit->setText(completedString);\n            // move the cursor to the end of the line edit\n            ui->InteractLineEdit->setCursorPosition(ui->InteractLineEdit->text().length());\n        }\n    }\n}\n\n\nvoid interactTab::handleUpKey() {\n    // Navigate back through the command history, if possible.\n    if (commandHistoryIndex > 0) {\n        commandHistoryIndex--;\n        ui->InteractLineEdit->setText(commandHistory.at(commandHistoryIndex));\n    }\n\n}\n\nvoid interactTab::handleDownKey() {\n    // Navigate forward through the command history, if there's a next item.\n    if (commandHistoryIndex < commandHistory.size()) {\n        // Increment first to navigate to the next command.\n        commandHistoryIndex++;\n\n        // Check if the new index points to a valid command in the history.\n        if (commandHistoryIndex < commandHistory.size()) {\n            ui->InteractLineEdit->setText(commandHistory.at(commandHistoryIndex));\n        }\n        else {\n            // If the index is beyond the last command, clear the line edit.\n            ui->InteractLineEdit->clear();\n        }\n    }\n    // No else part needed here as all conditions are covered.\n}\n\nvoid interactTab::addCommand(const QString &command) {\n    // Add the command to the history.\n    commandHistory.append(command);\n    // Update the index to point to the \"end\" of the history, ready for a new command.\n    commandHistoryIndex = commandHistory.size();\n\n}\n\nvoid interactTab::SetLableInfo(const QString Text){\n    ui->SessionInfoLable->setText(Text);\n\n\n}\n\n\nvoid interactTab::AppendCompleter(const QString &text)\n{\n\n    addCommand(text);\n}\n\nvoid interactTab::setfoc()\n{\n    this->ui->InteractLineEdit->setFocus();\n}\n\n\nvoid interactTab::SetDispatchInfo(TargetInfo *Target)\n{\n\n    MainCommands->Target=Target;\n    MainCommands->TabInteract=Target->UITabInteract;\n\n}\n\nvoid interactTab::PrintConsole( const QString &text ) const\n{\n\n        auto TaskMessage = ColorText::Cyan( ColorText::Cyan( text.toHtmlEscaped() ));\n        ui->interactTextEdit->append(TaskMessage);\n\n}\n\n\n\n\n\nQString interactTab::TaskInfo( bool Show, QString TaskID, const QString &text ) const\n{\n    if ( TaskID == nullptr ){\n        TaskID = gen_random( 3 ).c_str();\n    }\n\n    if ( ! Show )\n    {\n        auto TaskMessage = ColorText::Cyan( \"[INFO]\" ) + \" \"+ ColorText::Comment( \"[\" + TaskID + \"]\" ) + \" \" + ColorText::Cyan( text.toHtmlEscaped() );\n        ui->interactTextEdit->append(TaskMessage);\n    }\n    return TaskID;\n}\n\n\n\nvoid interactTab::TaskResult( bool Show, QString TaskID, const QString &text,int Type )\n{\n\n\n\n    switch (Type) {\n        case PrintCo",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n * SPDX-FileCopyrightText: Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n *\n * Copyright (c) 2019-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Edited by Marcos Luciano\n * https://www.github.com/marcoslucianops\n */\n\n#include \"yolov5Plugins.hpp\"\n#include \"NvInferPlugin.h\"\n#include <cassert>\n#include <iostream>\n#include <memory>\n#define NANCHORS 3\n#define NFEATURES 3\n\nnamespace\n{\n    template <typename T>\n    void write(char *&buffer, const T &val)\n    {\n        *reinterpret_cast<T *>(buffer) = val;\n        buffer += sizeof(T);\n    }\n\n    template <typename T>\n    void read(const char *&buffer, T &val)\n    {\n        val = *reinterpret_cast<const T *>(buffer);\n        buffer += sizeof(T);\n    }\n}\n\n//->\u9759\u6001\u53d8\u91cf\u58f0\u660e\nPluginFieldCollection YoloLayerPluginCreator::mFC{};\nstd::vector<PluginField> YoloLayerPluginCreator::mPluginAttributes;\n\nYoloLayerPluginCreator::YoloLayerPluginCreator() noexcept\n{\n    //->\u4eceONNX\u83b7\u53d6\u53c2\u6570\n    mPluginAttributes.emplace_back(PluginField(\"max_stride\", nullptr, PluginFieldType::kINT32, 1));\n    mPluginAttributes.emplace_back(PluginField(\"num_classes\", nullptr, PluginFieldType::kINT32, 1));\n    mPluginAttributes.emplace_back(PluginField(\"anchors\", nullptr, PluginFieldType::kFLOAT32, NFEATURES * NANCHORS * 2));\n    mPluginAttributes.emplace_back(PluginField(\"prenms_score_threshold\", nullptr, PluginFieldType::kFLOAT32, 1));\n\n    mFC.nbFields = mPluginAttributes.size();  //->PluginField\u7684\u6570\u91cf\n    mFC.fields = mPluginAttributes.data();    //->\u6307\u5411PluginField vector\u6570\u7ec4\u7684\u6307\u9488\n}\n\nYoloLayerPluginCreator::~YoloLayerPluginCreator() noexcept {}   //->\u4e00\u822c\u4e0d\u505a\u4efb\u4f55\u64cd\u4f5c\n\nconst char* YoloLayerPluginCreator::getPluginName() const noexcept { \n    return YOLOLAYER_PLUGIN_NAME;             //->\u83b7\u53d6\u63d2\u4ef6\u540d\u5b57\n}\n\nconst char* YoloLayerPluginCreator::getPluginVersion() const noexcept { \n    return YOLOLAYER_PLUGIN_VERSION;          //->\u83b7\u53d6\u63d2\u4ef6\u7248\u672c\n}\n\nconst PluginFieldCollection* YoloLayerPluginCreator::getFieldNames() noexcept {\n    return &mFC;\n}\n\nconst char* YoloLayerPluginCreator::getPluginNamespace() const noexcept {\n    return mNamespace.c_str();\n}\n\n\nIPluginV2DynamicExt* YoloLayerPluginCreator::createPlugin(const char *name, const PluginFieldCollection *fc) noexcept {\n    /******** \u4ecefc\u83b7\u53d6\u53c2\u6570\uff0c\u5b9e\u4f8b\u5316\u4e00\u4e2aplugin *********/\n    const PluginField *fields = fc->fields;\n    int max_stride = 0;\n    int num_classes = 0;\n    std::vector<float> anchors;\n    float score_threshold = 0.0;\n\n    for (int i = 0; i < fc->nbFields; ++i) {                                    //->\u6839\u636e\u540d\u5b57\u89e3\u6790\u53c2\u6570\n        const char *attrName = fields[i].name;                                  //->\u83b7\u53d6\u540d\u5b57\n        if (!strcmp(attrName, \"max_stride\")) {\n            assert(fields[i].type == PluginFieldType::kINT32);                  //->\u65ad\u8a00\u7c7b\u578b\n            max_stride = *(static_cast<const int*>(fields[i].data));            //->\u53d8\u91cf\u8d4b\u503c\n        }\n        if (!strcmp(attrName, \"num_classes\")) {\n            assert(fields[i].type == PluginFieldType::kINT32);\n            num_classes = *(static_cast<const int*>(fields[i].data));\n        }\n        if (!strcmp(attrName, \"anchors\")) {\n            assert(fields[i].type == PluginFieldType::kFLOAT32);\n            const auto anchors_ptr = static_cast<const float*>(fields[i].data);\n            anchors.assign(anchors_ptr, anchors_ptr + NFEATURES * NANCHORS * 2);\n        }\n        if (!strcmp(attrName, \"prenms_score_threshold\")) {\n            assert(fields[i].type == PluginFieldType::kFLOAT32);\n            score_threshold = *(static_cast<const float *>(fields[i].data));\n        }\n    }\n    return new YoloLayer(max_stride, num_classes, anchors, score_threshold);    //->\u5b9e\u4f8b\u5316plugin\n}\n\nIPluginV2DynamicExt* YoloLayerPluginCreator::deserializePlugin(const char *name, const void *serialData, size_t serialLength) noexcept {\n    std::cout << \"Deserialize yoloLayer plugin: \" << name << std::endl;\n    return new YoloLayer(serialData, serialLength);\n}\n\nvoid YoloLayerPluginCreator::setPluginNamespace(co",
    "#include <iostream>\n\n#include \"tests.hpp\"\n\n#include <sophus/velocities.hpp>\n\nnamespace Sophus {\nnamespace experimental {\n\ntemplate <class Scalar>\nbool tests_linear_velocities() {\n  bool passed = true;\n  std::vector<SE3<Scalar>, Eigen::aligned_allocator<SE3<Scalar>>> bar_Ts_baz;\n\n  for (size_t i = 0; i < 10; ++i) {\n    bar_Ts_baz.push_back(SE3<Scalar>::rotX(i * 0.001) *\n                         SE3<Scalar>::rotY(i * 0.001) *\n                         SE3<Scalar>::transX(0.01 * i));\n  }\n\n  SE3<Scalar> foo_T_bar =\n      SE3<Scalar>::rotX(0.5) * SE3<Scalar>::rotZ(0.2) * SE3<Scalar>::transY(2);\n\n  std::vector<SE3<Scalar>, Eigen::aligned_allocator<SE3<Scalar>>> foo_Ts_baz;\n  for (auto const& bar_T_baz : bar_Ts_baz) {\n    foo_Ts_baz.push_back(foo_T_bar * bar_T_baz);\n  }\n\n  auto gen_linear_vels =\n      [](std::vector<SE3<Scalar>, Eigen::aligned_allocator<SE3<Scalar>>> const&\n             a_Ts_b) {\n        std::vector<Vector3<Scalar>, Eigen::aligned_allocator<Vector3<Scalar>>>\n            linearVels_a;\n        for (size_t i = 0; i < a_Ts_b.size() - 1; ++i) {\n          linearVels_a.push_back(a_Ts_b[i + 1].translation() -\n                                 a_Ts_b[i].translation());\n        }\n        return linearVels_a;\n      };\n\n  // linear velocities in frame bar\n  std::vector<Vector3<Scalar>, Eigen::aligned_allocator<Vector3<Scalar>>>\n      linearVels_bar = gen_linear_vels(bar_Ts_baz);\n  // linear velocities in frame foo\n  std::vector<Vector3<Scalar>, Eigen::aligned_allocator<Vector3<Scalar>>>\n      linearVels_foo = gen_linear_vels(foo_Ts_baz);\n\n  for (size_t i = 0; i < linearVels_bar.size(); ++i) {\n    SOPHUS_TEST_APPROX(passed, linearVels_foo[i],\n                       transformVelocity(foo_T_bar, linearVels_bar[i]),\n                       sqrt(Constants<Scalar>::epsilon()));\n  }\n  return passed;\n}\n\ntemplate <class Scalar>\nbool tests_rotational_velocities() {\n  bool passed = true;\n\n  SE3<Scalar> foo_T_bar =\n      SE3<Scalar>::rotX(0.5) * SE3<Scalar>::rotZ(0.2) * SE3<Scalar>::transY(2);\n\n  // One parameter subgroup of SE3, motion through space given time t.\n  auto bar_T_baz = [](Scalar t) -> SE3<Scalar> {\n    return SE3<Scalar>::rotX(t * Scalar(0.01)) *\n           SE3<Scalar>::rotY(t * Scalar(0.0001)) *\n           SE3<Scalar>::transX(t * Scalar(0.0001));\n  };\n\n  std::vector<Scalar> ts = {Scalar(0), Scalar(0.3), Scalar(1)};\n\n  Scalar h = Constants<Scalar>::epsilon();\n  for (Scalar t : ts) {\n    // finite difference approximiation of instantanious velocity in frame bar\n    Vector3<Scalar> rotVel_in_frame_bar =\n        finiteDifferenceRotationalVelocity<Scalar>(bar_T_baz, t, h);\n\n    // finite difference approximiation of instantanious velocity in frame foo\n    Vector3<Scalar> rotVel_in_frame_foo =\n        finiteDifferenceRotationalVelocity<Scalar>(\n            [&foo_T_bar, bar_T_baz](Scalar t) -> SE3<Scalar> {\n              return foo_T_bar * bar_T_baz(t);\n            },\n            t, h);\n\n    Vector3<Scalar> rotVel_in_frame_bar2 =\n        transformVelocity(foo_T_bar.inverse(), rotVel_in_frame_foo);\n    SOPHUS_TEST_APPROX(\n        passed, rotVel_in_frame_bar, rotVel_in_frame_bar2,\n        // not too tight threshold, because of finit difference approximation\n        std::sqrt(Constants<Scalar>::epsilon()));\n\n    // The rotational velocities rotVel_in_frame_foo and rotVel_in_frame_bar\n    // should not be equal since they are in different frames (foo != bar).\n    SOPHUS_TEST_NOT_APPROX(passed, rotVel_in_frame_foo, rotVel_in_frame_bar,\n                           Scalar(1e-3));\n\n    // Expect same result when using adjoint instead since:\n    //  vee(bar_R_foo * hat(vel_foo) * bar_R_foo^T = bar_R_foo 8 vel_foo.\n    SOPHUS_TEST_APPROX(\n        passed, transformVelocity(foo_T_bar.inverse(), rotVel_in_frame_foo),\n        SO3<Scalar>::vee(foo_T_bar.so3().inverse().matrix() *\n                         SO3<Scalar>::hat(rotVel_in_frame_foo) *\n                         foo_T_bar.so3().matrix()),\n        Constants<Scalar>::epsilon());\n  }\n  return passed;\n}\n\nint test_velocities() {\n  using std::cerr;\n  using std::endl;\n\n  cerr << \"Test Velocities\" << endl << endl;\n  cerr << \"Double tests: \" << endl;\n  bool passed = tests_linear_velocities<double>();\n  passed &= tests_rotational_velocities<double>();\n  processTestResult(passed);\n\n  cerr << \"Float tests: \" << endl;\n  passed = tests_linear_velocities<float>();\n  passed &= tests_rotational_velocities<float>();\n  processTestResult(passed);\n\n  return 0;\n}\n}  // namespace experimental\n}  // namespace Sophus\n\nint main() { return Sophus::experimental::test_velocities(); }\n",
    "#include \"memaddr.h\"\n\n//-----------------------------------------------------------------------------\n// Purpose: ResolveRelativeAddress wrapper\n// Input  : opcodeOffset - \n//\t\t\tnextInstructionOffset - \n// Output : CMemory\n//-----------------------------------------------------------------------------\nCMemory CMemory::FollowNearCall(const ptrdiff_t opcodeOffset, const ptrdiff_t nextInstructionOffset)\n{\n\treturn ResolveRelativeAddress(opcodeOffset, nextInstructionOffset);\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: ResolveRelativeAddressSelf wrapper\n// Input  : opcodeOffset - \n//\t\t\tnextInstructionOffset - \n// Output : CMemory\n//-----------------------------------------------------------------------------\nCMemory CMemory::FollowNearCallSelf(const ptrdiff_t opcodeOffset, const ptrdiff_t nextInstructionOffset)\n{\n\treturn ResolveRelativeAddressSelf(opcodeOffset, nextInstructionOffset);\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: resolves the relative pointer to offset\n// Input  : registerOffset - \n//\t\t\tnextInstructionOffset - \n// Output : CMemory\n//-----------------------------------------------------------------------------\nCMemory CMemory::ResolveRelativeAddress(const ptrdiff_t registerOffset, const ptrdiff_t nextInstructionOffset)\n{\n\t// Skip register.\n\tconst uintptr_t skipRegister = ptr + registerOffset;\n\n\t// Get 4-byte long relative Address.\n\tconst int32_t relativeAddress = *reinterpret_cast<int32_t*>(skipRegister);\n\n\t// Get location of next instruction.\n\tconst uintptr_t nextInstruction = ptr + nextInstructionOffset;\n\n\t// Get function location via adding relative Address to next instruction.\n\treturn CMemory(nextInstruction + relativeAddress);\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: resolves the relative pointer to offset from current address\n// Input  : registerOffset - \n//\t\t\tnextInstructionOffset - \n// Output : CMemory\n//-----------------------------------------------------------------------------\nCMemory CMemory::ResolveRelativeAddressSelf(const ptrdiff_t registerOffset, const ptrdiff_t nextInstructionOffset)\n{\n\t// Skip register.\n\tconst uintptr_t skipRegister = ptr + registerOffset;\n\n\t// Get 4-byte long relative Address.\n\tconst int32_t relativeAddress = *reinterpret_cast<int32_t*>(skipRegister);\n\n\t// Get location of next instruction.\n\tconst uintptr_t nextInstruction = ptr + nextInstructionOffset;\n\n\t// Get function location via adding relative Address to next instruction.\n\tptr = nextInstruction + relativeAddress;\n\treturn *this;\n}\n",
    "#include \"Acceptor.h\"\n#include <stdio.h>\n#include \"Channel.h\"\n#include \"Server.h\"\n#include \"Socket.h\"\n\nAcceptor::Acceptor(EventLoop *_loop) : loop(_loop), sock(nullptr), acceptChannel(nullptr) {\n  sock = new Socket();\n  InetAddress *addr = new InetAddress(\"127.0.0.1\", 8888);\n  sock->bind(addr);\n  // acceptor\u4f7f\u7528\u963b\u585e\u5f0fIO\u6bd4\u8f83\u597d\uff0c\u56e0\u4e3aacceptor\u53ea\u8d1f\u8d23\u63a5\u6536\u65b0\u8fde\u63a5\uff0c\u4e0d\u8d1f\u8d23\u8bfb\u5199\u6570\u636e\n  // sock->setnonblocking();\n  sock->listen();\n  acceptChannel = new Channel(loop, sock->getFd());\n  std::function<void()> cb = std::bind(&Acceptor::acceptConnection, this);\n  acceptChannel->setReadCallback(cb);\n  acceptChannel->enableRead();\n  delete addr;\n}\n\nAcceptor::~Acceptor() {\n  delete sock;\n  delete acceptChannel;\n}\n\nvoid Acceptor::acceptConnection() {\n  // 1. acceptor\u63a5\u6536\u65b0\u8fde\u63a5\uff0c\u6253\u5370\n  InetAddress *clnt_addr = new InetAddress();\n  Socket *clnt_sock = new Socket(sock->accept(clnt_addr));\n  printf(\"new client fd %d! IP: %s Port: %d\\n\", clnt_sock->getFd(), inet_ntoa(clnt_addr->getAddr().sin_addr),\n         ntohs(clnt_addr->getAddr().sin_port));\n  clnt_sock->setnonblocking();\n  // 2. \u56de\u8c03\u51fd\u6570\u8f6c\u56deserver\uff0c\u7531server\u7ef4\u62a4new Connection\n  newConnectionCallback(clnt_sock);\n  delete clnt_addr;\n}\n\nvoid Acceptor::setNewConnectionCallback(std::function<void(Socket *)> _cb) { newConnectionCallback = _cb; }",
    "/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied \nwarranty. In no event will the authors be held liable for any \ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any \npurpose, including commercial applications, and to alter it and \nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must \nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and \nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source \ndistribution.\n*/\n\n#include <ctype.h>\n#include <stddef.h>\n\n#include \"tinyxml.h\"\n\n//#define DEBUG_PARSER\n#if defined( DEBUG_PARSER )\n#\tif defined( DEBUG ) && defined( _MSC_VER )\n#\t\tinclude <windows.h>\n#\t\tdefine TIXML_LOG OutputDebugString\n#\telse\n#\t\tdefine TIXML_LOG printf\n#\tendif\n#endif\n\n// Note tha \"PutString\" hardcodes the same list. This\n// is less flexible than it appears. Changing the entries\n// or order will break putstring.\t\nTiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = \n{\n\t{ \"&amp;\",  5, '&' },\n\t{ \"&lt;\",   4, '<' },\n\t{ \"&gt;\",   4, '>' },\n\t{ \"&quot;\", 6, '\\\"' },\n\t{ \"&apos;\", 6, '\\'' }\n};\n\n// Bunch of unicode info at:\n//\t\thttp://www.unicode.org/faq/utf_bom.html\n// Including the basic of this table, which determines the #bytes in the\n// sequence from the lead byte. 1 placed for invalid sequences --\n// although the result will be junk, pass it through as much as possible.\n// Beware of the non-characters in UTF-8:\t\n//\t\t\t\tef bb bf (Microsoft \"lead bytes\")\n//\t\t\t\tef bf be\n//\t\t\t\tef bf bf \n\nconst unsigned char TIXML_UTF_LEAD_0 = 0xefU;\nconst unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\nconst unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\n\nconst int TiXmlBase::utf8ByteTable[256] = \n{\n\t//\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\ta\tb\tc\td\te\tf\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x00\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x10\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x20\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x30\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x40\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x50\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x60\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x70\tEnd of ASCII range\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x80 0x80 to 0xc1 invalid\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x90 \n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0xa0 \n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0xb0 \n\t\t1,\t1,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t// 0xc0 0xc2 to 0xdf 2 byte\n\t\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t// 0xd0\n\t\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t// 0xe0 0xe0 to 0xef 3 byte\n\t\t4,\t4,\t4,\t4,\t4,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1\t// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid\n};\n\n\nvoid TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )\n{\n\tconst unsigned long BYTE_MASK = 0xBF;\n\tconst unsigned long BYTE_MARK = 0x80;\n\tconst unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n\n\tif (input < 0x80) \n\t\t*length = 1;\n\telse if ( input < 0x800 )\n\t\t*length = 2;\n\telse if ( input < 0x10000 )\n\t\t*length = 3;\n\telse if ( input < 0x200000 )\n\t\t*length = 4;\n\telse\n\t\t{ *length = 0; return; }\t// This code won't covert this correctly anyway.\n\n\toutput += *length;\n\n\t// Scary scary fall throughs.\n\tswitch (*length) \n\t{\n\t\tcase 4:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 3:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 2:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 1:\n\t\t\t--output; \n\t\t\t*output = (char)(input | FIRST_BYTE_MARK[*length]);\n\t}\n}\n\n\n/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )\n{\n\t// This will only work for low-ascii, everything else is assumed to be a valid\n\t// letter. I'm not sure this is the best approach, but it is quite tricky trying\n\t// to figure out alhabetical vs. not across encoding. So take a very \n\t// conservative approach.\n\n//\tif ( encoding == TIXML_ENCODING_UTF8 )\n//\t{\n\t\tif ( anyByte < 127 )\n\t\t\treturn isalpha( anyByte );\n\t\telse\n\t\t\treturn 1;\t// What else to do? The unicode set is huge...get the english ones right.\n//\t}\n//\telse\n//\t{\n//\t\treturn isalpha( anyByte );\n//\t}\n}\n\n\n/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )\n{\n\t// This will only work for low-ascii, everything else is assumed to be a valid\n\t// letter. I'm not sure this is the best approach, ",
    "// Copyright 2014 Citra Emulator Project\n// Licensed under GPLv2 or any later version\n// Refer to the license.txt file included.\n\n#include <algorithm>\n#include <cstring>\n#include <memory>\n#include \"core/arm/dyncom/arm_dyncom.h\"\n#include \"core/arm/dyncom/arm_dyncom_interpreter.h\"\n#include \"core/arm/dyncom/arm_dyncom_trans.h\"\n#include \"core/arm/skyeye_common/armstate.h\"\n#include \"core/core.h\"\n#include \"core/core_timing.h\"\n\nnamespace Core {\n\nARM_DynCom::ARM_DynCom(Core::System& system_, Memory::MemorySystem& memory,\n                       PrivilegeMode initial_mode, u32 id,\n                       std::shared_ptr<Core::Timing::Timer> timer)\n    : ARM_Interface(id, timer), system(system_) {\n    state = std::make_unique<ARMul_State>(system, memory, initial_mode);\n}\n\nARM_DynCom::~ARM_DynCom() {}\n\nvoid ARM_DynCom::Run() {\n    ExecuteInstructions(std::max<s64>(timer->GetDowncount(), 0));\n}\n\nvoid ARM_DynCom::Step() {\n    ExecuteInstructions(1);\n}\n\nvoid ARM_DynCom::ClearInstructionCache() {\n    state->instruction_cache.clear();\n    trans_cache_buf_top = 0;\n}\n\nvoid ARM_DynCom::InvalidateCacheRange(u32, std::size_t) {\n    ClearInstructionCache();\n}\n\nvoid ARM_DynCom::SetPageTable(const std::shared_ptr<Memory::PageTable>& page_table) {\n    ClearInstructionCache();\n}\n\nstd::shared_ptr<Memory::PageTable> ARM_DynCom::GetPageTable() const {\n    return nullptr;\n}\n\nvoid ARM_DynCom::SetPC(u32 pc) {\n    state->Reg[15] = pc;\n}\n\nu32 ARM_DynCom::GetPC() const {\n    return state->Reg[15];\n}\n\nu32 ARM_DynCom::GetReg(int index) const {\n    return state->Reg[index];\n}\n\nvoid ARM_DynCom::SetReg(int index, u32 value) {\n    state->Reg[index] = value;\n}\n\nu32 ARM_DynCom::GetVFPReg(int index) const {\n    return state->ExtReg[index];\n}\n\nvoid ARM_DynCom::SetVFPReg(int index, u32 value) {\n    state->ExtReg[index] = value;\n}\n\nu32 ARM_DynCom::GetVFPSystemReg(VFPSystemRegister reg) const {\n    return state->VFP[reg];\n}\n\nvoid ARM_DynCom::SetVFPSystemReg(VFPSystemRegister reg, u32 value) {\n    state->VFP[reg] = value;\n}\n\nu32 ARM_DynCom::GetCPSR() const {\n    return state->Cpsr;\n}\n\nvoid ARM_DynCom::SetCPSR(u32 cpsr) {\n    state->Cpsr = cpsr;\n}\n\nu32 ARM_DynCom::GetCP15Register(CP15Register reg) const {\n    return state->CP15[reg];\n}\n\nvoid ARM_DynCom::SetCP15Register(CP15Register reg, u32 value) {\n    state->CP15[reg] = value;\n}\n\nvoid ARM_DynCom::ExecuteInstructions(u64 num_instructions) {\n    state->NumInstrsToExecute = num_instructions;\n    const u32 ticks_executed = InterpreterMainLoop(state.get());\n    if (timer) {\n        timer->AddTicks(ticks_executed);\n    }\n    state->ServeBreak();\n}\n\nvoid ARM_DynCom::SaveContext(ThreadContext& ctx) {\n    ctx.cpu_registers = state->Reg;\n    ctx.cpsr = state->Cpsr;\n    ctx.fpu_registers = state->ExtReg;\n    ctx.fpscr = state->VFP[VFP_FPSCR];\n    ctx.fpexc = state->VFP[VFP_FPEXC];\n}\n\nvoid ARM_DynCom::LoadContext(const ThreadContext& ctx) {\n    state->Reg = ctx.cpu_registers;\n    state->Cpsr = ctx.cpsr;\n    state->ExtReg = ctx.fpu_registers;\n    state->VFP[VFP_FPSCR] = ctx.fpscr;\n    state->VFP[VFP_FPEXC] = ctx.fpexc;\n}\n\nvoid ARM_DynCom::PrepareReschedule() {\n    state->NumInstrsToExecute = 0;\n}\n\n} // namespace Core\n",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n\nclass Book {\npublic:\n    Book(int id, const string& name, const ::string& author, int year) :\n        bookID(id), bookName(name), author(author), yearPublished(year) {}\n\n    int getBookID() const { return bookID; }\n    string getBookName() const { return bookName; }\n    string getAuthor() const { return author; }\n    int getYearPublished() const { return yearPublished; }\n\n    void setBookName(const string& name) { bookName = name; }\n    void setAuthor(const string& authorName) { author = authorName; }\n    void setYearPublished(int year) { yearPublished = year; }\n\n    void displayBookInfo() const {\n        cout << \"Book ID: \" << bookID << endl;\n        cout << \"Book Name: \" << bookName << endl;\n        cout << \"Author: \" << author << endl;\n        cout << \"Year Published: \" << yearPublished << endl;\n    }\n\nprivate:\n    int bookID;\n    string bookName;\n    string author;\n    int yearPublished;\n};\n\nclass Library {\npublic:\n    Library(const string& filename) : fileName(filename) {\n        loadBooksFromFile();\n    }\n    ~Library() {\n        saveBooksToFile();\n    }\n\n    void addBook() {\n        int id, year;\n        string name, author;\n\n        cout << \"Enter Book ID: \";\n        cin >> id;\n        cin.ignore();\n        cout << \"Enter Book Name: \";\n        getline(cin, name);\n        cout << \"Enter Author: \";\n        getline(cin, author);\n        cout << \"Enter Year Published: \";\n        cin >> year;\n\n        books.push_back(Book(id, name, author, year));\n        cout << \"Book added successfully!\\n\";\n    }\n\n    void displayAllBooks() {\n        if (books.empty()) {\n            cout << \"No books in the library.\\n\";\n            return;\n        }\n        for (const auto& book : books) {\n            book.displayBookInfo();\n            cout << endl;\n        }\n    }\n\n    void searchBook() {\n        cout << \"Enter book name or author to search: \";\n        string term;\n        cin.ignore();\n        getline(cin, term);\n\n        auto indices = searchBooks(term);\n        if (indices.empty()) {\n            cout << \"No books found.\\n\";\n            return;\n        }\n        for (int index : indices) {\n            books[index].displayBookInfo();\n            cout << endl;\n        }\n    }\n\n    void deleteBook() {\n        cout << \"Enter book ID to delete: \";\n        int id;\n        cin >> id;\n        int index = searchBook(id);\n        if (index == -1) {\n            cout << \"Book not found!\\n\";\n            return;\n        }\n        books.erase(books.begin() + index);\n        cout << \"Book deleted successfully!\\n\";\n    }\n\nprivate:\n    vector<Book> books;\n    string fileName;\n\n    void saveBooksToFile() {\n        ofstream file(fileName);\n        if (!file) {\n            cerr << \"Failed to open file for writing.\\n\";\n            return;\n        }\n        for (const auto& book : books) {\n            file << book.getBookID() << ',' << book.getBookName() << ','\n                 << book.getAuthor() << ',' << book.getYearPublished() << '\\n';\n        }\n        file.close();\n    }\n\n    void loadBooksFromFile() {\n        ifstream file(fileName);\n        if (!file) {\n            cerr << \"Failed to open file for reading.\\n\";\n            return;\n        }\n        string line, name, author;\n        int id, year;\n        while (getline(file, line)) {\n            istringstream iss(line);\n            getline(iss, name, ',');\n            getline(iss, author, ',');\n            iss >> id >> year;\n            books.emplace_back(id, name, author, year);\n        }\n        file.close();\n    }\n\n    int searchBook(int bookID) {\n        for (size_t i = 0; i < books.size(); ++i) {\n            if (books[i].getBookID() == bookID) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    vector<int> searchBooks(const string& term) {\n        vector<int> indices;\n        for (size_t i = 0; i < books.size(); ++i) {\n            if (books[i].getBookName().find(term) != string::npos ||\n                books[i].getAuthor().find(term) != string::npos) {\n                indices.push_back(i);\n            }\n        }\n        return indices;\n    }\n};\n\nint main() {\n    Library myLibrary(\"library.txt\");\n    int choice;\n\n    do {\n        cout << \"\\n1. Add Book\\n\";\n        cout << \"2. Display All Books\\n\";\n        cout << \"3. Search for a Book\\n\";\n        cout << \"4. Delete a Book\\n\";\n        cout << \"5. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                myLibrary.addBook();\n                break;\n            case 2:\n                myLibrary.displayAllBooks();\n                break;\n            case 3:\n                myLibrary.searchBook();\n                break;\n            case 4:\n                myLibrary.deleteBook();\n                break;\n            case 5:\n                cout << \"Exiting program.\\n\";\n                break;\n            default:\n   ",
    "\r\n#include \"language/generics.hpp\"\r\n#include \"errors/internal_errors.hpp\"\r\n#include <regex>\r\n#include <optional>\r\n#include <iostream>\r\n\r\n[[nodiscard]] std::string CustomType::function_retrieval_match_string(\r\n    const std::vector<std::string>& template_generics_names\r\n) const {\r\n    std::string transformed_typename = type_name;\r\n    const auto begin = template_generics_names.begin();\r\n    const auto end =  template_generics_names.end();\r\n    if (std::find(begin, end, type_name) != end){\r\n        transformed_typename = \"[^ ,\\t]+\";\r\n    }\r\n    if (instanciated_generics.empty()) return transformed_typename;\r\n    std::string serialized_base_type = transformed_typename + \"<\";\r\n    for (const TypeSignature& generic : instanciated_generics){\r\n        serialized_base_type += generic.function_retrieval_match_string(template_generics_names);\r\n        serialized_base_type +=  + \",\";\r\n    }\r\n    serialized_base_type.back() = '>';\r\n    return serialized_base_type;\r\n}\r\n\r\n[[nodiscard]] std::string PointerType::function_retrieval_match_string(\r\n    const std::vector<std::string>& template_generics_names) const {\r\n        return \"#\" + pointed_type.function_retrieval_match_string(template_generics_names);\r\n}\r\n\r\n[[nodiscard]] std::string ArrayType::function_retrieval_match_string(\r\n    const std::vector<std::string>& template_generics_names) const {\r\n        return \"Array<\" + std::to_string(array_length) + \",\" +\r\n            stored_type.function_retrieval_match_string(template_generics_names) + \">\";\r\n}\r\n\r\n[[nodiscard]] std::string SliceType::function_retrieval_match_string(\r\n    const std::vector<std::string>& template_generics_names) const {\r\n        return \"Slice<\" + stored_type.function_retrieval_match_string(template_generics_names) + \">\";\r\n}\r\n\r\n[[nodiscard]] std::string PrimitiveType::function_retrieval_match_string(\r\n    const std::vector<std::string>& template_generics_names\r\n) const {\r\n    return type_name;\r\n}",
    "#include \"Ant.h\"\n#include <iostream>\n\ndouble pow(double base, int exponent)\n{\n    double res = 1;\n    for (int i = 0; i < exponent; i++)\n    {\n        res *= base;\n    }\n    return res;\n}\n\nAnt::Ant(int deadline, int numberOfLibraries)\n    : m_signedIn(numberOfLibraries), m_deadline(deadline)\n{\n    m_totalValue = 0;\n}\n\nint Ant::mutate(std::vector<Library> &libraries, int deadline, bool localSearch)\n{\n\t// if localSearch == true, then we only mutate neighbors\n    int bestValue = totalValue(libraries, deadline);\n    int iterations = 0;\n\n    for (int i = 0; (i < (localSearch ? m_path.size() - 1 : 1000)) && iterations < (localSearch ? 10 : 50); i++)\n    {\n        int idx1, idx2;\n        if (localSearch)\n        {\n            idx1 = i;\n            idx2 = i + 1;\n            std::swap(m_path[idx1], m_path[idx2]);\n        }\n        else\n        {\n            idx1 = rand() % m_path.size();\n            idx2 = rand() % m_path.size();\n            std::swap(m_path[idx1], m_path[idx2]);\n        }\n\n        int total = totalValue(libraries, deadline);\n\n        if (total > bestValue)\n        {\n            bestValue = total;\n            ++iterations;\n            i = 0;\n        }\n        else\n        {\n            std::swap(m_path[idx1], m_path[idx2]);\n        }\n    }\n    totalValue(libraries, deadline);\n    return bestValue;\n}\n\nint Ant::totalValue(std::vector<Library> &libraries, int deadline)\n{\n    int total{};\n    std::unordered_set<int> scanned;\n    for (auto &lib : m_path)\n    {\n        int numOfScanned = libraries[lib].getNumberOfBooksScanned(deadline);\n        deadline -= libraries[lib].getSignUpTime();\n        int scannedFromThisLib{};\n        for (auto &[bookIdx, bookValue] : libraries[lib].getAllBooks())\n        {\n            if (!scanned.count(bookIdx))\n            {\n                scanned.insert(bookIdx);\n                total += bookValue;\n                if (++scannedFromThisLib >= numOfScanned)\n                    break;\n            }\n        }\n    }\n    m_totalValue = total;\n    return m_totalValue;\n}\n\nvoid Ant::calculatePheromonesDeltas(std::vector<Library> &libraries, int bestValue, int deadline)\n{\n    int totalValue = getTotalValue();\n    for (int i = 0; i < m_path.size() - 1; i++)\n    {\n        deltaPheromones[std::make_pair(i, m_path[i])] += (1 / (1 + (double)(bestValue - totalValue) /\n                                                                                 std::min(totalValue, bestValue)));\n    }\n    std::unordered_set<int> scanned;\n    for (auto &lib : m_path)\n    {\n        int numOfScanned = libraries[lib].getNumberOfBooksScanned(deadline);\n        deadline -= libraries[lib].getSignUpTime();\n        int scannedFromThisLib{};\n        for (auto &[bookIdx, bookValue] : libraries[lib].getAllBooks())\n        {\n            if (!scanned.count(bookIdx))\n            {\n                scanned.insert(bookIdx);\n                bookDeltaPheromones[bookIdx] += (1 / (1 + (double)(bestValue - totalValue) / std::min(bestValue, totalValue))) / 1000;\n                if (++scannedFromThisLib >= numOfScanned)\n                    break;\n            }\n        }\n    }\n}\n\nvoid Ant::clear(int deadline)\n{\n    m_deadline = deadline;\n    for (auto &it : m_signedIn)\n        it = false;\n    m_path.clear();\n    m_totalValue = 0;\n    deltaPheromones.clear();\n    for (auto &it : bookDeltaPheromones)\n        it = 0;\n}\n\nstd::map<std::pair<int, int>, std::pair<double, int>> Ant::pheromones;\nstd::map<std::pair<int, int>, double> Ant::deltaPheromones;\n\nstd::vector<std::pair<double, int>> Ant::bookPheromones;\nstd::vector<double> Ant::bookDeltaPheromones;\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mappp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n// \u5b9a\u4e49\u4e00\u4e2av3\u7684\u5411\u91cf\nstruct Vector3 {\n    /* data */\n    float x, y, z;\n\n    /* function */\n    Vector3(float x_, float y_, float z_)\n        : x(x_), y(y_), z(z_) {}\n    Vector3 operator-(const Vector3& v3);\n    Vector3 operator+(const Vector3& v3);\n    float& operator[](int index);\n};\n\nVector3 Vector3::operator-(const Vector3& v3) {\n    return Vector3(\n        this->x - v3.x,\n        this->y - v3.y,\n        this->z - v3.z);\n}\n\nVector3 Vector3::operator+(const Vector3& v3) {\n    return Vector3(\n        this->x + v3.x,\n        this->y + v3.y,\n        this->z + v3.z);\n}\n\nfloat& Vector3::operator[](int index) {\n    if (index == 0)\n        return x;\n    else if (index == 1)\n        return y;\n    else if (index == 2)\n        return z;\n    else {\n        throw std::out_of_range(\"Index out of range in Vector3::operator[]. Index should be 0, 1, 2.\");\n    }\n}\n\n// \u5b9a\u4e49\u4e00\u4e2aAABB\u5305\u56f4\u76d2\nstruct AABB {\n    /* data */\n    Vector3 min, max;\n\n    /* function */\n    AABB(const Vector3& min_, const Vector3& max_)\n        : min(min_), max(max_) {}\n};\n\n// \u5b9a\u4e49\u4e00\u4e2a\u4e09\u89d2\u5f62\u7ed3\u6784\nstruct Triangle {\n    /* data */\n    Vector3 vertices[3];\n\n    /* function */\n    AABB boundingBox() const {\n        Vector3 min(\n            std::min({vertices[0].x, vertices[1].x, vertices[2].x}),\n            std::min({vertices[0].y, vertices[1].y, vertices[2].y}),\n            std::min({vertices[0].z, vertices[1].z, vertices[2].z}));\n        Vector3 max(\n            std::max({vertices[0].x, vertices[1].x, vertices[2].x}),\n            std::max({vertices[0].y, vertices[1].y, vertices[2].y}),\n            std::max({vertices[0].z, vertices[1].z, vertices[2].z}));\n        return AABB(min, max);\n    }\n};\n\n// \u5b9a\u4e49BVH\u7ed3\u70b9\nstruct BVHNode {\n    /* data */\n    AABB boundingBox;\n    BVHNode* leftChild;\n    BVHNode* rightChild;\n    std::vector<Triangle> triangles;\n\n    /* function */\n    BVHNode(const AABB& bbox)\n        : boundingBox(bbox), leftChild(nullptr), rightChild(nullptr) {}\n};\n\n// \u6784\u5efaBVH\nBVHNode* buildBVH(std::vector<Triangle>& triangles) {\n    // \u7a7a\u4e09\u89d2\u5224\u65ad\n    if (triangles.empty())\n        return nullptr;\n\n    // \u8ba1\u7b97\u5305\u56f4\u76d2\n    AABB bbox = triangles[0].boundingBox();\n    for (auto tri : triangles) {\n        AABB triBox = tri.boundingBox();\n        bbox.min = Vector3(\n            std::min(bbox.min.x, triBox.min.x),\n            std::min(bbox.min.y, triBox.min.y),\n            std::min(bbox.min.z, triBox.min.z));\n        bbox.max = Vector3(\n            std::max(bbox.max.x, triBox.max.x),\n            std::max(bbox.max.y, triBox.max.y),\n            std::max(bbox.max.z, triBox.max.z));\n    }\n\n    // \u5982\u679c\u4e09\u89d2\u5f62\u6570\u91cf\u5c0f\u4e8e\u7b49\u4e8e1\uff0c \u5219\u521b\u5efa\u53f6\u5b50\u7ed3\u70b9\n    if (triangles.size() <= 1) {\n        BVHNode* leaf = new BVHNode(bbox);\n        leaf->triangles = std::move(triangles);\n        return leaf;\n    }\n\n    // \u627e\u5230\u6700\u957f\u7684\u8fb9\n    Vector3 extent = bbox.max - bbox.min;\n    int longestAxis = (extent.x > extent.y && extent.x > extent.z) ? 0 : (extent.y > extent.z) ? 1\n                                                                                               : 2;\n    float splitPosition = (bbox.min[longestAxis] + bbox.max[longestAxis]) * 0.5f;\n\n    // \u5206\u5272\u4e09\u89d2\u5f62\n    std::vector<Triangle> leftTriangles, rightTriangles;\n    for (auto tri : triangles) {\n        AABB triBox = tri.boundingBox();\n        float triCenter = (triBox.min[longestAxis] + triBox.max[longestAxis]) * 0.5f;\n\n        if (triCenter <= splitPosition) {\n            leftTriangles.push_back(tri);\n        } else {\n            rightTriangles.push_back(tri);\n        }\n    }\n\n    // \u9012\u5f52\u6784\u5efa\u5de6\u53f3\u5b50\u6811\n    BVHNode* node = new BVHNode(bbox);\n    node->leftChild = buildBVH(leftTriangles);\n    node->rightChild = buildBVH(rightTriangles);\n    return node;\n}\n\n// \u663e\u793a\u4e09\u89d2\u5f62\u548c\u5305\u56f4\u76d2\u4fe1\u606f\nvoid displayTriangle(const Triangle& tri) {\n    std::cout << \"Triangle vertices:\" << std::endl;\n    for (int i = 0; i < 3; ++i) {\n        std::cout << \"  Vertex \" << i << \": (\" << tri.vertices[i].x << \", \" << tri.vertices[i].y << \", \" << tri.vertices[i].z << \")\" << std::endl;\n    }\n    AABB bbox = tri.boundingBox();\n    std::cout << \"Bounding box: \" << std::endl;\n    std::cout << \"  Min: (\" << bbox.min.x << \", \" << bbox.min.y << \", \" << bbox.min.z << \")\" << std::endl;\n    std::cout << \"  Max: (\" << bbox.max.x << \", \" << bbox.max.y << \", \" << bbox.max.z << \")\" << std::endl;\n}\n\n// \u663e\u793aBVH\u8282\u70b9\u548c\u5305\u56f4\u76d2\u4fe1\u606f\nvoid displayBVHNode(BVHNode* node, int depth = 0) {\n    if (node == nullptr)\n        return;\n    std::cout << \"BVHNode at depth \" << depth << \":\" << std::endl;\n    std::cout << \"Bounding box: \" << std::endl;\n    std::cout << \"  Min: (\" << node->boundingBox.min.x << \", \" << node->boundingBox.min.y << \", \" << node->boundingBox.min.z << \")\" << std::endl;\n    std::cout << \"  Max: (\" << node->boundingBox.max.x << \", \" << node->boundingBox.max.y << \", \" << node->boundingBox.max.z << \")\" << std::endl;\n    std::cout << \"Number of triangles: \" << node->triangles.size() << std::endl;\n    if (node->leftChild != nullptr || node->rightChild != nullptr) {\n        std::cout << \"Left child:\" << std::endl;\n  ",
    "#include \"enums.cpp\"\n#include \"login.cpp\"\n#include \"register.cpp\"\n#include \"Printing.hpp\"\n#include \"function.hpp\"\n\nbool exists(std::string filename);\nstd::string input_name(std::string filename);\n\nint main()\n{\n\n\tbool loggedIn = false;\n\tbool loggedInEmployee = false;\n\tbool loggedInUser = false;\n\tVersion();\n\n\tdo\n\t{\n\t\tMainMenu();\n\t\tstd::string userInput;\n\t\tstd::getline(std::cin, userInput);\n\t\tSelection selection = Hash(userInput);\n\n\t\tswitch (selection)\n\t\t{\n\t\tcase Selection::LOGINEMPLOYEE:\n\t\t\tif (!exists(\"Employee.txt\"))\n\t\t\t{\n\t\t\t\tstd::cout << \"please register first\\n\";\n\t\t\t\tRegisterEmployee();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tloggedIn = isLoggedInEmployee();\n\t\t\t\tloggedInEmployee = true;\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Selection::REGISTEREMPLOYEE:\n\t\t\tRegisterEmployee();\n\t\t\tbreak;\n\t\tcase Selection::LOGINUSER:\n\t\t\tif (!exists(\"User.txt\"))\n\t\t\t{\n\t\t\t\tstd::cout << \"please register first\\n\";\n\t\t\t\tRegisterUser();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tloggedIn = isLoggedInUser();\n\t\t\t\tloggedInUser = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Selection::REGISTERUSER:\n\t\t\tRegisterUser();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tError();\n\t\t}\n\t} while (!loggedIn);\n\n\tif (loggedInEmployee)\n\t{\n\t\tstd::string name = input_name(\"Employee.txt\");\n\t\twhile (loggedInEmployee)\n\t\t{\n\t\t\tstd::cout << \"welcome \" << name << \"\\nplease write .Help if you want help in menu\\n\";\n\t\t\tstd::string userInput;\n\t\t\tstd::getline(std::cin, userInput);\n\t\t\tEmployeeSelection mainselection = Employeehash(userInput);\n\t\t\tswitch (mainselection)\n\t\t\t{\n\t\t\tcase EmployeeSelection::HELP:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintHelpEmployee();\n\t\t\t\tbreak;\n\t\t\tcase EmployeeSelection::ROOMTYPE:\n\t\t\t\tTypeOfRooms();\n\t\t\t\tbreak;\n\t\t\tcase EmployeeSelection::ROOMNUMBER:\n\t\t\t\tRoomsNumber();\n\t\t\t\tbreak;\n\t\t\tcase EmployeeSelection::ROOMPRICE:\n\t\t\t\tRoomPrice();\n\t\t\t\tbreak;\n\t\t\tcase EmployeeSelection::REMOVEROOM:\n\t\t\t\tRemoveRoom();\n\t\t\t\tbreak;\n\t\t\tcase EmployeeSelection::GOTOUSER:\n\t\t\t\tloggedInUser = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tError();\n\t\t\t}\n\t\t\tif (loggedInUser)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsystem(\"cls\");\n\n\tif (loggedInUser)\n\t{\n\t\tstd::string name = input_name(\"User.txt\");\n\t\tstd::cout << \"welcome \" << name << \"\\nplease write .Help if you want help in menu\\n\";\n\t\twhile (loggedInUser)\n\t\t{\n\t\t\tstd::string userInput;\n\t\t\tstd::getline(std::cin, userInput);\n\t\t\tUserSelection mainselection = Userhash(userInput);\n\t\t\tswitch (mainselection)\n\t\t\t{\n\t\t\tcase UserSelection::HELP:\n\t\t\t\tprintHelpUser();\n\t\t\t\tbreak;\n\t\t\tcase UserSelection::ROOMSEARCH:\n\t\t\t\tRoomSearch();\n\t\t\t\tbreak;\n\t\t\tcase UserSelection::ROOMBOOK:\n\t\t\t\tRoomBook();\n\t\t\t\tbreak;\n\t\t\tcase UserSelection::ROOMCANCLE:\n\t\t\t\tcancleRoom();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tError();\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool exists(std::string filename)\n{\n\tstd::ifstream file(filename);\n\treturn file.good();\n}\n\nstd::string input_name(std::string filename)\n{\n\tstd::string name;\n\tstd::ifstream input(filename);\n\tinput >> name;\n\tinput.close();\n\treturn name;\n}",
    "#include <dwmapi.h>\r\n#include \"main.h\"\r\n\r\n//declarar DLLs\r\nHHOOK hhk = NULL;\r\nHINSTANCE hInst = NULL;\r\n\r\nvoid _PoL(HWND hwnd, const char* Option)\r\n{\r\n        //politica de renderizado y transisiones\r\n    if (strcmp(Option, \"Enable\") == 0)\r\n    {\r\n        DWMNCRENDERINGPOLICY rNCRP = DWMNCRP_ENABLED;\r\n        BOOL tpol = FALSE;\r\n        DwmSetWindowAttribute(hwnd, DWMWA_NCRENDERING_POLICY, &rNCRP, sizeof(rNCRP));\r\n        DwmSetWindowAttribute(hwnd, DWMWA_TRANSITIONS_FORCEDISABLED, &tpol, sizeof(tpol));\r\n    }\r\n    else if (strcmp(Option, \"Disable\") == 0)\r\n    {\r\n        DWMNCRENDERINGPOLICY NCRP = DWMNCRP_DISABLED;\r\n        BOOL lpol = TRUE;\r\n        DwmSetWindowAttribute(hwnd, DWMWA_NCRENDERING_POLICY, &NCRP, sizeof(NCRP));\r\n        DwmSetWindowAttribute(hwnd, DWMWA_TRANSITIONS_FORCEDISABLED, &lpol, sizeof(lpol));\r\n    }\r\n}\r\n\r\n//definir gancho\r\nLRESULT CALLBACK GetWinProc(int cCode, WPARAM wParam, LPARAM lParam) {\r\n    if (cCode == HSHELL_WINDOWCREATED) {\r\n        HWND hwnd = (HWND)wParam;\r\n\r\n    //Deshabilitar renderizado y transiciones\r\n    _PoL(hwnd, \"Disable\");\r\n\r\n    //exclude explorer\r\n    WCHAR className[32]; // WCHAR en lugar de TCHAR para manejar cadenas amplias\r\n    GetClassNameW(hwnd, className, sizeof(className)/sizeof(className[0])); // Usar GetClassNameW para obtener el nombre de clase\r\n\r\n    // Compara el nombre de clase con el de la ventana de Explorer\r\n    if (wcscmp(className, L\"CabinetWClass\") == 0) { // Usar wcscmp para comparar cadenas amplias\r\n        _PoL(hwnd, \"Enable\"); // Habilitar la pol\u00edtica\r\n    }\r\n    }\r\n    // Llama al siguiente gancho en la cadena\r\n    return CallNextHookEx(hhk, cCode, wParam, lParam);\r\n}\r\n\r\n\r\n\r\nextern \"C\" DLL_EXPORT BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\r\n{\r\n    switch (fdwReason)\r\n    {\r\n        case DLL_PROCESS_ATTACH:\r\n            // attach from process\r\n            hInst = (HINSTANCE) hinstDLL;\r\n            break;\r\n\r\n        case DLL_PROCESS_DETACH:\r\n            // detach from process\r\n            break;\r\n\r\n        case DLL_THREAD_ATTACH:\r\n            // attach to thread\r\n            break;\r\n\r\n        case DLL_THREAD_DETACH:\r\n            // detach from thread\r\n            break;\r\n    }\r\n    return TRUE; // succesful\r\n}\r\n\r\nvoid SetHook()\r\n{\r\n    //instalar gancho\r\n    hhk = SetWindowsHookEx(WH_SHELL, (HOOKPROC)GetWinProc, hInst, 0);\r\n}\r\n\r\nvoid RemoveHook()\r\n{\r\n    //remover gancho\r\n    UnhookWindowsHookEx(hhk);\r\n}\r\n\r\n\r\n",
    "#include \"misc.hpp\"\n#include \"../../menu/menu.hpp\"\n#include \"../../includes/imgui/imgui.h\"\n#include \"../../includes/imgui/imgui_internal.h\"\n#include \"../../features/visuals/visuals.hpp\"\n#include \"../../features/notifications/notifications.hpp\"\n#include \"../../sdk/sdk.hpp\"\n#include \"../../sdk/steam/steamclientpublic.h\"\n\nvoid features::misc::fix_mouse_delta(c_usercmd* cmd)\n{\n\tif (!c::misc::mousefix)\n\t{\n\t\treturn;\n\t}\n\n\tstatic vec3_t delta_viewangles{ };\n\tvec3_t delta = cmd->view_angles - delta_viewangles;\n\tdelta.clamp();\n\n\tstatic convar* sensitivity = interfaces::console->get_convar(\"sensitivity\");\n\n\tif (!sensitivity)\n\t{\n\t\treturn;\n\t}\n\n\tif (delta.x != 0.f) \n\t{\n\t\tstatic convar* m_pitch = interfaces::console->get_convar(\"m_pitch\");\n\n\t\tif (!m_pitch)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint final_dy = static_cast<int>((delta.x / m_pitch->get_float()) / sensitivity->get_float());\n\n\t\tif (final_dy <= 32767) \n\t\t{\n\t\t\tif (final_dy >= -32768) \n\t\t\t{\n\t\t\t\tif (final_dy >= 1 || final_dy < 0)\n\t\t\t\t{\n\t\t\t\t\tif (final_dy <= -1 || final_dy > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal_dy = final_dy;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal_dy = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tfinal_dy = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfinal_dy = 32768;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tfinal_dy = 32767;\n\t\t}\n\n\t\tcmd->mouse_dy = static_cast<short>(final_dy);\n\t}\n\n\tif (delta.y != 0.f) \n\t{\n\t\tstatic convar* m_yaw = interfaces::console->get_convar(\"m_yaw\");\n\n\t\tif (!m_yaw)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint final_dx = static_cast<int>((delta.y / m_yaw->get_float()) / sensitivity->get_float());\n\n\t\tif (final_dx <= 32767) \n\t\t{\n\t\t\tif (final_dx >= -32768) \n\t\t\t{\n\t\t\t\tif (final_dx >= 1 || final_dx < 0) \n\t\t\t\t{\n\t\t\t\t\tif (final_dx <= -1 || final_dx > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal_dx = final_dx;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal_dx = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tfinal_dx = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tfinal_dx = 32768;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tfinal_dx = 32767;\n\t\t}\n\n\t\tcmd->mouse_dx = static_cast<short>(final_dx);\n\t}\n\n\tdelta_viewangles = cmd->view_angles;\n}\n\nstd::deque<std::pair<vec3_t, vec3_t>> checkpoints;\n\nint current_checkpoint = 0;\nfloat press_delay = 0.0f;\n\nvoid features::misc::checkpoint_system()\n{\n\tif (!c::misc::practice)\n\t{\n\t\tcheckpoints.clear();\n\t\tcurrent_checkpoint = 0;\n\t\tpress_delay = 0.0f;\n\t\treturn;\n\t}\n\n\tif (!interfaces::engine->is_connected() || !interfaces::engine->is_in_game() || !g::local || !g::local->is_alive())\n\t{\n\t\tcheckpoints.clear();\n\t\tcurrent_checkpoint = 0;\n\t\tpress_delay = 0.0f;\n\t\treturn;\n\t}\n\n\tif (g::local->move_type() == movetype_noclip)\n\t{\n\t\tcheckpoints.clear();\n\t\tcurrent_checkpoint = 0;\n\t\tpress_delay = 0.0f;\n\t\treturn;\n\t}\n\n\tif (interfaces::console->get_convar(\"sv_cheats\")->get_int() == 0)\n\t{\n\t\tcheckpoints.clear();\n\t\tcurrent_checkpoint = 0;\n\t\tpress_delay = 0.0f;\n\t\treturn;\n\t}\n\n\tvec3_t hAng = vec3_t(0, 0, 0);\n\n\tif (press_delay < interfaces::globals->realtime)\n\t{\n\t\tif (menu::checkkey(c::misc::savepos, c::misc::savepos_s))\n\t\t{\n\t\t\tinterfaces::engine->get_view_angles(hAng);\n\n\t\t\tcheckpoints.push_front({ vec3_t(hAng.x, hAng.y, hAng.z), g::local->origin() });\n\n\t\t\tcurrent_checkpoint = 0;\n\n\t\t\tif (checkpoints.size() > 99)\n\t\t\t{\n\t\t\t\tcheckpoints.pop_back();\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 1; ++i)\n\t\t\t{\n\t\t\t\tfeatures::notification::run(\"succesfully created & saved checkpoint\", \"#_print_created_checkpoint\", true, true, true);\n\t\t\t}\n\n\t\t\tpress_delay = interfaces::globals->realtime + 0.2f;\n\t\t}\n\n\t\tif (!checkpoints.empty())\n\t\t{\n\t\t\tif (menu::checkkey(c::misc::loadpos, c::misc::loadpos_s))\n\t\t\t{\n\t\t\t\tauto& cur = checkpoints.at(current_checkpoint);\n\n\t\t\t\tstd::string cmd = (\"setpos_exact \") + std::to_string(cur.second.x) + (\" \") + std::to_string(cur.second.y) + (\" \") + std::to_string(cur.second.z);\n\t\t\t\tinterfaces::engine->execute_cmd(cmd.c_str());\n\n\t\t\t\tcmd = (\"setang_exact \") + std::to_string(cur.first.x) + (\" \") + std::to_string(cur.first.y) + (\" \") + std::to_string(cur.first.z);\n\t\t\t\tinterfaces::engine->execute_cmd(cmd.c_str());\n\n\t\t\t\tfor (int i = 1; i <= 1; ++i)\n\t\t\t\t{\n\t\t\t\t\tfeatures::notification::run(\"succesfully teleported to checkpoint\", \"#_print_teleport_checkpoint\", true, true, true);\n\t\t\t\t}\n\n\t\t\t\tpress_delay = interfaces::globals->realtime + 0.2f;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid features::misc::viewfov()\n{\n\tif (!interfaces::engine->is_in_game() || !interfaces::engine->is_connected())\n\t{\n\t\treturn;\n\t}\n\n\tif (!g::local || !g::local->is_alive())\n\t{\n\t\treturn;\n\t}\n\n\tstatic auto save_viewmodel_fov = interfaces::console->get_convar(\"viewmodel_fov\")->get_float();\n\n\tinterfaces::console->get_convar(\"viewmodel_fov\")->callbacks.clear();\n\n\tif (c::misc::enable_fov)\n\t{\n\t\tinterfaces::console->get_convar(\"viewmodel_fov\")->set_value(c::misc::field_of_view);\n\t}\n\telse\n\t{\n\t\tinterfaces::console->get_convar(\"viewmodel_fov\")->set_value(save_viewmodel_fov);\n\t}\n}\n\nvoid features::misc::viewmodel()\n{\n\tif (!interfaces::engine->is_in_game() || !interfaces::engine->is_connected())\n\t{\n\t\treturn;\n\t}\n\n\tif (!g::local || !g::local->is_alive())\n\t{\n\t\treturn;\n\t}\n\n\tstatic auto save_view_model_x = interfaces::console->get_convar(\"viewmodel_offset_x\")->get_float();\n\tstatic auto save_",
    "#include \"Info.h\"\n#include \"../../Utils/Logger/Logging.h\"\n#include <map>\n#include \"../User/User.h\"\n\nvoid DmiSystemUuidConversion(const BYTE* PByte, short Version)\n{\n\t// Check if input byte array contains at least 16 bytes for the UUID\n\tif (PByte == nullptr) {\n\t\tLogger::Error(\"Input byte array is null.\", nullptr);\n\t\treturn;\n\t}\n\n\tbool only0xff = true;\n\tbool only0x00 = true;\n\tint i{};\n\n\t//\n\t// 16 because of the byte uuid\n\t// this process also makes so that the uuid isn't all\n\t// 1's and 0's\n\t//\n\n\n\tfor (i = 0; i < 16 && (only0x00 || only0xff); i++) {\n\t\tif (PByte[i] != 0x00) { only0x00 = false; }\n\t\tif (PByte[i] != 0xFF) { only0xff = false; }\n\t}\n\n\tif (only0x00) { std::puts(\"Not present : 0x00\"); return; }\n\tif (only0xff) { std::puts(\"Not Settable: 0xff\"); return; }\n\n\t// Print UUID in the correct format based on the UUID version\n\tif (Version >= 0x0206) {\n\t\tLogger::Info(\"\\t\\t UUID:\\t\\t\\t%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n\t\t\tPByte[3], PByte[2], PByte[1], PByte[0], PByte[5], PByte[4], PByte[7], PByte[6],\n\t\t\tPByte[8], PByte[9], PByte[10], PByte[11], PByte[12], PByte[13], PByte[14], PByte[15]);\n\n\n\t}\n\telse {\n\n\t\tLogger::Info(\"\\t\\t UUID:\\t\\t\\t%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\n\t\t\tPByte[0], PByte[1], PByte[2], PByte[3], PByte[4], PByte[5], PByte[6], PByte[7],\n\t\t\tPByte[8], PByte[9], PByte[10], PByte[11], PByte[12], PByte[13], PByte[14], PByte[15]);\n\t}\n}\n\nconst char* DmiStringConversion(\n\tDmiHeader* PDmiHeader, BYTE Source\n)\n{\n\tstd::size_t Length{};\n\tstd::size_t Index{};\n\n\tauto BytePointer = reinterpret_cast<char*>(PDmiHeader);\n\n\tif (Source == 0) { return \"Not specified\"; }\n\tBytePointer += PDmiHeader->Length;\n\n\twhile (Source > 1 && *BytePointer) {\n\t\tBytePointer += std::strlen(BytePointer);\n\t\tBytePointer++;\n\t\tSource--;\n\t}\n\n\tif (!*BytePointer) { return \"BAD_INDEXING\"; }\n\n\tLength = std::strlen(BytePointer);\n\tfor (int i = 0; i < Length; i++) {\n\t\tif (BytePointer[i] < 32 || BytePointer[i] == 127) { BytePointer[i] = '.'; }\n\t}\n\treturn BytePointer;\n\n}\n\nconst char* DmiMemoryDeviceType(BYTE Code)\n{\n\tstd::map<int, const char*> MemoryDeviceType_;\n\n\tMemoryDeviceType_[DMT_OTHER] = \"Other\"; /* 0x01 */\n\tMemoryDeviceType_[DMT_UNKNOWN] = \"Unknown\";\n\tMemoryDeviceType_[DMT_DRAM] = \"DRAM\";\n\tMemoryDeviceType_[DMT_EDRAM] = \"EDRAM\";\n\tMemoryDeviceType_[DMT_VRAM] = \"VRAM\";\n\tMemoryDeviceType_[DMT_SRAM] = \"SRAM\";\n\tMemoryDeviceType_[DMT_RAM] = \"RAM\";\n\tMemoryDeviceType_[DMT_ROM] = \"ROM\";\n\tMemoryDeviceType_[DMT_FLASH] = \"Flash\";\n\tMemoryDeviceType_[DMT_EEPROM] = \"EEPROM\";\n\tMemoryDeviceType_[DMT_FEPROM] = \"FEPROM\";\n\tMemoryDeviceType_[DMT_EPROM] = \"EPROM\";\n\tMemoryDeviceType_[DMT_CDRAM] = \"CDRAM\";\n\tMemoryDeviceType_[DMT_3DRAM] = \"3DRAM\";\n\tMemoryDeviceType_[DMT_SDRAM] = \"SDRAM\";\n\tMemoryDeviceType_[DMT_SGRAM] = \"SGRAM\";\n\tMemoryDeviceType_[DMT_RDRAM] = \"RDRAM\";\n\tMemoryDeviceType_[DMT_DDR] = \"DDR\";\n\tMemoryDeviceType_[DMT_DDR2] = \"DDR2\";\n\tMemoryDeviceType_[DMT_DDR2_FB_DIMM] = \"DDR2 FB-DIMM\";\n\tMemoryDeviceType_[DMT_RESERVED1] = \"Reserved\";\n\tMemoryDeviceType_[DMT_RESERVED2] = \"Reserved\";\n\tMemoryDeviceType_[DMT_RESERVED3] = \"Reserved\";\n\tMemoryDeviceType_[DMT_DDR3] = \"DDR3\";\n\tMemoryDeviceType_[DMT_FBD2] = \"FBD2\";\n\tMemoryDeviceType_[DMT_DDR4] = \"DDR4\";\n\tMemoryDeviceType_[DMT_LPDDR] = \"LPDDR\";\n\tMemoryDeviceType_[DMT_LPDDR2] = \"LPDDR2\";\n\tMemoryDeviceType_[DMT_LPDDR3] = \"LPDDR3\";\n\tMemoryDeviceType_[DMT_LPDDR4] = \"LPDDR4\";\n\tMemoryDeviceType_[DMT_LOGICAL_NONVOLATILE_DEVICE] = \"Logical non-volatile device\";\n\tMemoryDeviceType_[DMT_HBM] = \"HBM\";\n\tMemoryDeviceType_[DMT_HBM2] = \"HBM2\"; /* 0x21 */\n\n\n\tif (Code >= DMT_OTHER\n\t\t&& Code <= DMT_HBM2) {\n\t\treturn MemoryDeviceType_[Code - 0x01];\n\t}\n\n\treturn \"Out of spec\";\n}\n\n\nbool Info::GetDmi(std::vector<uint8_t>& Buffer)\n{\n\tconst BYTE ByteSignature[] = { 'B', 'M', 'S', 'R' };\n\tconst DWORD Signature = *((DWORD*)ByteSignature);\n\n\tDWORD Size = GetSystemFirmwareTable(Signature, 0, nullptr, 0);\n\tif (Size == 0) {\n\t\tLOG_WARN(\"GetSystemFirmwareTable returned 0\", 0);\n\t\treturn false;\n\t}\n\n\tBuffer.resize(Size, 0);\n\n\tif (Size != GetSystemFirmwareTable(Signature, 0, Buffer.data(), Size))\n\t{\n\t\tBuffer.clear();\n\t\tLOG_WARN(\"GetSystemFirmwareTable size mismatch\", 0);\n\t\treturn false;\n\t}\n\n\tSMBIOSData = reinterpret_cast<RawSMBIOSData*>(Buffer.data());\n\n\treturn true;\n}\n\nvoid Info::GetUserInfo()\n{\n\tstd::vector<uint8_t> Buffer;\n\tbool Result = false;\n\tDWORD Flag = { 1 };\n\n\tResult = GetDmi(Buffer);\n\n\tif (!Result || !SMBIOSData)\n\t{\n\t\tLOG_ERROR(\"Unable to retrieve SMBIOS table\", 0);\n\t\treturn;\n\t}\n\n\tUser User;\n\tLOG_INFO(\"User has been created\", 0);\n\n\tBYTE* B_ = SMBIOSData->SMBIOSTableData;\n\tfor (DWORD Index{}; Index < SMBIOSData->Length; Index++)\n\t{\n\t\tDmiHeader* Header = reinterpret_cast<DmiHeader*>(B_);\n\n\t\t// Check if moving beyond the allocated memory\n\t\tif (B_ + Header->Length >= SMBIOSData->SMBIOSTableData + SMBIOSData->Length) {\n\t\t\tbreak;  // Exit loop to avoid going out of bounds\n\t\t}\n\n\t\tif (Header->Type == DMI_ENTRY_BIOS && Flag)\n\t\t{\n\t\t\tLogger::Info(\"Type %02d - [Bios Device Type]\", Header->Ty",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: BP_WorldSecurityLaw_AttackToNonCriminal\n\n#include \"Basic.hpp\"\n\n#include \"BP_WorldSecurityLaw_AttackToNonCriminal_classes.hpp\"\n#include \"BP_WorldSecurityLaw_AttackToNonCriminal_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function BP_WorldSecurityLaw_AttackToNonCriminal.BP_WorldSecurityLaw_AttackToNonCriminal_C.Condition\n// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// struct FPalDamageResult                 DamageResult                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)\n// class UPalIndividualCharacterHandle*    CriminalHandle                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)\n// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nbool UBP_WorldSecurityLaw_AttackToNonCriminal_C::Condition(const struct FPalDamageResult& DamageResult, class UPalIndividualCharacterHandle** CriminalHandle)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_WorldSecurityLaw_AttackToNonCriminal_C\", \"Condition\");\n\n\tParams::BP_WorldSecurityLaw_AttackToNonCriminal_C_Condition Parms{};\n\n\tParms.DamageResult = std::move(DamageResult);\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tif (CriminalHandle != nullptr)\n\t\t*CriminalHandle = Parms.CriminalHandle;\n\n\treturn Parms.ReturnValue;\n}\n\n\n// Function BP_WorldSecurityLaw_AttackToNonCriminal.BP_WorldSecurityLaw_AttackToNonCriminal_C.IsOrganizationCitizen\n// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)\n// Parameters:\n// EPalOrganizationType                    OrganizationType                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// bool                                    bCitizen                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UBP_WorldSecurityLaw_AttackToNonCriminal_C::IsOrganizationCitizen(EPalOrganizationType OrganizationType, bool* bCitizen)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_WorldSecurityLaw_AttackToNonCriminal_C\", \"IsOrganizationCitizen\");\n\n\tParams::BP_WorldSecurityLaw_AttackToNonCriminal_C_IsOrganizationCitizen Parms{};\n\n\tParms.OrganizationType = OrganizationType;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tif (bCitizen != nullptr)\n\t\t*bCitizen = Parms.bCitizen;\n}\n\n\n// Function BP_WorldSecurityLaw_AttackToNonCriminal.BP_WorldSecurityLaw_AttackToNonCriminal_C.IsValidCharacterActor\n// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)\n// bool                                    bValid                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// class UPalCharacterParameterComponent*  CharacterParameter                                     (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)\n\nvoid UBP_WorldSecurityLaw_AttackToNonCriminal_C::IsValidCharacterActor(class AActor* Actor, bool* bValid, class UPalCharacterParameterComponent** CharacterParameter)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_WorldSecurityLaw_AttackToNonCriminal_C\", \"IsValidCharacterActor\");\n\n\tParams::BP_WorldSecurityLaw_AttackToNonCriminal_C_IsValidCharacterActor Parms{};\n\n\tParms.Actor = Actor;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tif (bValid != nullptr)\n\t\t*bValid = Parms.bValid;\n\n\tif (CharacterParameter != nullptr)\n\t\t*CharacterParameter = Parms.CharacterParameter;\n}\n\n}\n\n",
    "#include \"pch.h\"\n// dear imgui, v1.75\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/2847 (please post your screenshots/video there!)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Wiki                  https://github.com/ocornut/imgui/wiki\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but I need your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.org\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE (2 variations)\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUG WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize screen real-estate usage.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption (NB- we do allocate when \"growing\" content e.g. creating a window,.\n   opening a tree node for the first time, etc. but a typical frame should not allocate anything).\n\n Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\n - CTRL+Click on a slider or drag box to input value as text.\n - Use mouse wheel to scrol",
    "#include \"RenderUtils.h\"\n\n#include <D3d11_4.h>\n\nusing namespace std::string_literals;\nusing Microsoft::WRL::ComPtr;\n\nnamespace d3d_render_utils {\n\n\tvoid GetAdapterInfo(ID3D11Device *d3dDevice, int32_t &adapterIndex, std::wstring &adapterName) {\n\t\tComPtr<IDXGIDevice> dxgiDevice;\n\t\tOK_OR_THROW(QUERY(d3dDevice, &dxgiDevice), \"Failed to query DXGI device.\");\n\n\t\tComPtr<IDXGIAdapter> adapter;\n\t\tOK_OR_THROW(dxgiDevice->GetParent(__uuidof(IDXGIAdapter), (void**)&adapter), \"Failed to get DXGI adapter.\");\n\n\t\tComPtr<IDXGIFactory> factory;\n\t\tOK_OR_THROW(adapter->GetParent(__uuidof(IDXGIFactory), (void**)&factory), \"Failed to get DXGI factory.\");\n\n\t\tDXGI_ADAPTER_DESC adapterDesc;\n\t\tadapter->GetDesc(&adapterDesc);\n\n\t\tComPtr<IDXGIAdapter> enumeratedAdapter;\n\t\tfor (UINT idx = 0; factory->EnumAdapters(idx, &enumeratedAdapter) != DXGI_ERROR_NOT_FOUND; idx++) {\n\t\t\tDXGI_ADAPTER_DESC enumeratedDesc;\n\t\t\tenumeratedAdapter->GetDesc(&enumeratedDesc);\n\n\t\t\tif (enumeratedDesc.AdapterLuid.HighPart == adapterDesc.AdapterLuid.HighPart &&\n\t\t\t\tenumeratedDesc.AdapterLuid.LowPart == adapterDesc.AdapterLuid.LowPart)\n\t\t\t{\n\t\t\t\tadapterIndex = idx;\n\t\t\t\tadapterName = adapterDesc.Description;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthrow MakeException(\"No valid adapter found.\");\n\t}\n\n\tID3D11Device *CreateDevice(IDXGIAdapter *dxgiAdapter) {\n\t\tUINT creationFlags = 0;\n#if _DEBUG\n\t\tcreationFlags |= D3D11_CREATE_DEVICE_DEBUG;\n#endif\n\n\t\tD3D_FEATURE_LEVEL featureLevel;\n\n\t\tID3D11Device *device;\n\t\tComPtr<ID3D11DeviceContext> context;\n\t\tOK_OR_THROW(D3D11CreateDevice(dxgiAdapter, dxgiAdapter != nullptr ? D3D_DRIVER_TYPE_UNKNOWN : D3D_DRIVER_TYPE_HARDWARE,\n\t\t\tnullptr, creationFlags, nullptr, 0, D3D11_SDK_VERSION, &device, &featureLevel, &context),\n\t\t\t\"Failed to create D3D11 device!\");\n\n\t\tif (featureLevel < D3D_FEATURE_LEVEL_11_0) {\n\t\t\tthrow MakeException(\"DX11 level hardware required!\");\n\t\t}\n\n\t\t//todo: check if needed:\n\t\tComPtr<ID3D11Multithread> multithread;\n\t\tif (SUCCEEDED(QUERY(context, &multithread))) {\n\t\t\tmultithread->SetMultithreadProtected(true);\n\t\t}\n\t\telse {\n\t\t\tDebug(\"Failed to get ID3D11Multithread interface. Ignore.\\n\");\n\t\t}\n\n\t\treturn device;\n\t}\n\n\tID3D11Device *CreateDevice(uint32_t adapterIndex) {\n\t\tComPtr<IDXGIFactory1> factory;\n\t\tOK_OR_THROW(CreateDXGIFactory1(__uuidof(IDXGIFactory1), (void **)&factory), \"Failed to create DXGIFactory1!\");\n\n\t\tComPtr<IDXGIAdapter> adapter;\n\t\tOK_OR_THROW(factory->EnumAdapters(adapterIndex, &adapter), \"Failed to create DXGIAdapter!\");\n\n\t\treturn CreateDevice(adapter.Get());\n\t}\n\n\tID3D11Texture2D *CreateTexture(ID3D11Device *device, uint32_t width, uint32_t height, \n\t\tDXGI_FORMAT format, bool mipmaps, bool shared, UINT sampleCount)\n\t{\n\t\tD3D11_TEXTURE2D_DESC desc = { 0 };\n\t\tdesc.Width = width;\n\t\tdesc.Height = height;\n\t\tdesc.Format = format;\n\t\tdesc.SampleDesc.Count = sampleCount;\n\t\tdesc.MipLevels = mipmaps ? 0 : 1;\n\t\tdesc.MiscFlags = (shared ? D3D11_RESOURCE_MISC_SHARED : 0) | (mipmaps ? D3D11_RESOURCE_MISC_GENERATE_MIPS : 0);\n\t\t// D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX | D3D11_RESOURCE_MISC_SHARED_NTHANDLE\n\n\t\tdesc.ArraySize = 1;\n\t\tdesc.SampleDesc.Quality = 0;\n\t\tdesc.Usage = D3D11_USAGE_DEFAULT;\n\t\tdesc.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;\n\t\tdesc.CPUAccessFlags = 0;\n\n\t\tID3D11Texture2D *texture;\n\t\tOK_OR_THROW(device->CreateTexture2D(&desc, nullptr, &texture), \"Failed to create texture.\");\n\t\treturn texture;\n\t}\n\n\tID3D11Buffer *_CreateBuffer(ID3D11Device *device, const void *bufferData, size_t bufferSize, D3D11_USAGE usage) {\n\t\tD3D11_BUFFER_DESC bufferDesc = { 0 };\n\t\tbufferDesc.Usage = usage;\n\t\tbufferDesc.ByteWidth = (UINT)bufferSize;\n\t\tbufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;\n\t\tbufferDesc.StructureByteStride = 0;\n\n\t\tD3D11_SUBRESOURCE_DATA dataDesc = { 0 };\n\t\tdataDesc.pSysMem = bufferData;\n\n\t\tID3D11Buffer *buffer;\n\t\tOK_OR_THROW(device->CreateBuffer(&bufferDesc, bufferData != nullptr ? &dataDesc : nullptr, &buffer), \"Failed to create D3D11 buffer.\");\n\t\treturn buffer;\n\t}\n\n\tvoid UpdateBuffer(ID3D11DeviceContext *context, ID3D11Buffer *buffer, const void *bufferData) {\n\t\tcontext->UpdateSubresource(buffer, 0, nullptr, bufferData, 0, 0);\n\t}\n\n\tID3D11VertexShader *CreateVertexShader(ID3D11Device *device, std::vector<uint8_t> &vertexShaderCSO) {\n\t\tID3D11VertexShader *vertexShader;\n\t\tOK_OR_THROW(device->CreateVertexShader(&vertexShaderCSO[0], vertexShaderCSO.size(), nullptr, &vertexShader),\n\t\t\t\"Failed to create vertex shader.\");\n\t\treturn vertexShader;\n\t}\n\n\tID3D11PixelShader *CreatePixelShader(ID3D11Device *device, std::vector<uint8_t> &pixelShaderCSO) {\n\t\tID3D11PixelShader *pixelShader;\n\t\tOK_OR_THROW(device->CreatePixelShader(&pixelShaderCSO[0], pixelShaderCSO.size(), nullptr, &pixelShader),\n\t\t\t\"Failed to create pixel shader.\");\n\t\treturn pixelShader;\n\t}\n\n\tID3D11Texture2D *GetTextureFromHandle(ID3D11Device *device, HANDLE handle) {\n\t\tID3D11Texture2D *texture;\n\t\tOK_OR_THROW(device->OpenSharedResource(handle, __uuidof(ID3D11Texture2D), (void **)&texture),\n\t\t\t\"[VDispDvr] SyncTexture is NULL!\");\n\t\treturn texture;\n\t}\n\n\tHA",
    "#include \"MCExplore.h\"\n#include \"Agent.h\"\n#include <iostream>\n#include <set>\n#include <numeric>\n\n\n\nstd::vector<EpisodeStep> MCExplore_generateEpisode(Agent& agent, Environment* penv, std::pair<int, int> start, int length) {\n    std::vector<EpisodeStep> episode;\n    std::pair<int, int> state = start;\n    const auto& grid = penv->getGrid();\n    while (length > 0 && grid[state.first][state.second] != CellType::Target) {\n        auto actionProbabilities = agent.getStochasticPolicy(state);\n        ActionType action = agent.chooseActionStochastic(state); \n        auto s_next = agent.getNextState(state, action);\n        auto reward = penv->getReward(state.first, state.second, action);\n        episode.push_back({ state, action, reward });\n        state = s_next;\n        length--;\n    }\n    return episode;\n}\n\nvoid MCExplore::evaluatePolicy(Agent& agent) {\n    std::map<std::pair<int, int>, std::vector<float>> returns; // \u72b6\u6001\u7684\u6240\u6709\u8fd4\u56de\u503c\n    auto penv = agent.getEnvironment();\n    const auto& grid = penv->getGrid();\n    for (size_t i = 0; i < grid.size(); i++) {\n        for (size_t j = 0; j < grid[i].size(); j++) {\n            for (int e = 0; e < EpisodeNum; ++e) {\n                auto episode = agent.generateEpisode(agent, penv, { i,j }, EpisodeLen);\n                std::set<std::pair<int, int>> visitedStates; // \u7528\u4e8e\u8bb0\u5f55\u60c5\u8282\u4e2d\u5df2\u8bbf\u95ee\u7684\u72b6\u6001\n                float G = 0; // \u521d\u59cb\u5316\u7d2f\u79ef\u5956\u52b1\n                for (auto it = episode.rbegin(); it != episode.rend(); ++it) { // \u9006\u5e8f\u904d\u5386\u60c5\u8282\n                    G = it->reward + gamma * G; // \u66f4\u65b0\u7d2f\u79ef\u5956\u52b1\n                    auto& state = it->state;\n                    if (visitedStates.count(state) == 0) { // \u5982\u679c\u662f\u9996\u6b21\u8bbf\u95ee\n                        visitedStates.insert(state);\n                        returns[state].push_back(G);\n                    }\n                }\n            }\n        }\n    }\n\n    // \u66f4\u65b0\u72b6\u6001\u503c\u4e3a\u6240\u6709\u8fd4\u56de\u503c\u7684\u5e73\u5747\u503c\n    auto& stateValues = penv->getStateValues();\n    for (auto& [state, allReturns] : returns) {\n        float averageReturn = std::accumulate(allReturns.begin(), allReturns.end(), 0.0f) / allReturns.size();\n        stateValues[state.first][state.second] = averageReturn;\n    }\n}\n\nvoid MCExplore::improvePolicyGreedy(Agent& agent) {\n    auto penv = agent.getEnvironment();\n    const auto& grid = penv->getGrid();\n    for (size_t i = 0; i < penv->getGrid().size(); i++) {\n        for (size_t j = 0; j < penv->getGrid()[i].size(); j++) {\n            std::pair<int, int> state = { i, j };\n            auto actionProbabilities = agent.getStochasticPolicy(state);\n            float maxActionValue = -std::numeric_limits<float>::infinity();\n            ActionType bestAction = ActionType::Up;\n            for (const auto& [action, prob] : actionProbabilities) {\n                if (action == ActionType::Stay && grid[state.first][state.second] != CellType::Target)continue;\n                auto s_next = agent.getNextState(state, action);\n                float reward = penv->getReward(state.first, state.second, action);\n                float actionValue = reward + gamma * penv->getStateValues()[s_next.first][s_next.second];\n                if (actionValue > maxActionValue) {\n                    maxActionValue = actionValue;\n                    bestAction = action;\n                }\n            }\n            // \u66f4\u65b0\u7b56\u7565\uff0c\u53ea\u4e3a\u6700\u4f73\u52a8\u4f5c\u8bbe\u7f6e\u6982\u7387\u4e3a1\uff0c\u5176\u4ed6\u52a8\u4f5c\u4e3a0\n            std::map<ActionType, float> updatedProbabilities;\n            for (const auto& action : actionProbabilities) {\n                updatedProbabilities[action.first] = (action.first == bestAction) ? 1.0f : 0.0f;\n            }\n            agent.setStochasticPolicy(state, updatedProbabilities);\n        }\n    }\n}\n\n\nvoid MCExplore::run(Agent& agent) {\n\n    auto gamma = 0.9f;\n\n    evaluatePolicy(agent);\n    improvePolicyGreedy(agent);\n\n}",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include \"hand.hpp\"\n#include \"Player.hpp\"\n#include \"Dealer.hpp\"\n#include \"test.hpp\"\n#include \"Button.hpp\"\n#include \"Client.h\"\n\nusing sf::Texture;\nusing sf::Sprite;\n\nint main(void)\n{\n    WSADATA wsaData;\n    SOCKET clientSocket;\n    sockaddr_in serverAddr;\n\n    initCreateConnect(wsaData, clientSocket, serverAddr);\n\n    string message;\n \n    // Prompt user for input\n    message = promptForInput();\n\n    // Send user input to server\n    sendToServer(message, clientSocket);\n\n    // Close socket\n    closeSocket(clientSocket);\n\n    srand((unsigned int)time(NULL));\n\n    Test t; \n    t.runTests(); \n\n    sf::RenderWindow window(sf::VideoMode(1920, 1080), \"BLACKJACK\");\n\n    Texture b;\n    b.loadFromFile(\"Cards/background.png\");\n\n    Sprite background(b);\n    background.setScale(1.5f, 1.5f);\n\n    Texture x1;\n    x1.loadFromFile(\"Cards/card back black.png\");\n\n    //this is a set position for the backcard and I think we should keep it in main in the future because we can control when we want to remove it\n    Sprite backCard(x1);\n    backCard.setScale(0.26f, 0.26f);\n    backCard.setPosition(950, 50);\n\n\n    Deck gDeck;\n    Player player(gDeck);\n    Dealer dealer(gDeck);\n\n\n    //\n    \n    Texture HitTexture; \n    HitTexture.loadFromFile(\"Cards/redHitButton.png\");\n    HitButton Hit(HitTexture); \n   \n\n  \n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n            {\n                window.close();\n            }\n\n          //  if (player.canSplit())\n            //{\n                \n            \n            //}\n           \n        }\n\n        window.clear();\n        window.draw(background);\n\n        window.draw(Hit); \n        dealer.displayHand(window);\n        window.draw(backCard);\n\n        player.displayHand(window);\n        window.display();\n    }\n    return 0;\n}\n\n",
    "// Dear ImGui: standalone example application for DirectX 11\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#include \"imgui_impl_dx11.h\"\n#include <d3d11.h>\n#include <tchar.h>\n\n// Data\nstatic ID3D11Device*            g_pd3dDevice = nullptr;\nstatic ID3D11DeviceContext*     g_pd3dDeviceContext = nullptr;\nstatic IDXGISwapChain*          g_pSwapChain = nullptr;\nstatic UINT                     g_ResizeWidth = 0, g_ResizeHeight = 0;\nstatic ID3D11RenderTargetView*  g_mainRenderTargetView = nullptr;\n\n// Forward declarations of helper functions\nbool CreateDeviceD3D(HWND hWnd);\nvoid CleanupDeviceD3D();\nvoid CreateRenderTarget();\nvoid CleanupRenderTarget();\nLRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\n// Main code\nint main(int, char**)\n{\n    // Create application window\n    //ImGui_ImplWin32_EnableDpiAwareness();\n    WNDCLASSEXW wc = { sizeof(wc), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L\"ImGui Example\", nullptr };\n    ::RegisterClassExW(&wc);\n    HWND hwnd = ::CreateWindowW(wc.lpszClassName, L\"Dear ImGui DirectX11 Example\", WS_OVERLAPPEDWINDOW, 100, 100, 1280, 800, nullptr, nullptr, wc.hInstance, nullptr);\n\n    // Initialize Direct3D\n    if (!CreateDeviceD3D(hwnd))\n    {\n        CleanupDeviceD3D();\n        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);\n        return 1;\n    }\n\n    // Show the window\n    ::ShowWindow(hwnd, SW_SHOWDEFAULT);\n    ::UpdateWindow(hwnd);\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // Enable Docking\n    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;       // Enable Multi-Viewport / Platform Windows\n    //io.ConfigViewportsNoAutoMerge = true;\n    //io.ConfigViewportsNoTaskBarIcon = true;\n    //io.ConfigViewportsNoDefaultParent = true;\n    //io.ConfigDockingAlwaysTabBar = true;\n    //io.ConfigDockingTransparentPayload = true;\n    //io.ConfigFlags |= ImGuiConfigFlags_DpiEnableScaleFonts;     // FIXME-DPI: Experimental. THIS CURRENTLY DOESN'T WORK AS EXPECTED. DON'T USE IN USER APP!\n    //io.ConfigFlags |= ImGuiConfigFlags_DpiEnableScaleViewports; // FIXME-DPI: Experimental.\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // When viewports are enabled we tweak WindowRounding/WindowBg so platform windows can look identical to regular ones.\n    ImGuiStyle& style = ImGui::GetStyle();\n    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)\n    {\n        style.WindowRounding = 0.0f;\n        style.Colors[ImGuiCol_WindowBg].w = 1.0f;\n    }\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplWin32_Init(hwnd);\n    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f);\n    //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());\n    //IM_ASSERT(font != nullptr);\n\n    // Our state\n    bool show_demo_window = true;\n    bool show_another_window = false;\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    while ",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "// local includes\n#include \"src/platf/windows/winapilayer.h\"\n#include \"tests/conftest.cpp\"\n\nTEST(LoggingTest, GetErrorString) {\n  const display_device::WinApiLayer layer;\n\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_INVALID_PARAMETER), R\"(\\[code: ERROR_INVALID_PARAMETER, .+?\\])\"));\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_NOT_SUPPORTED), R\"(\\[code: ERROR_NOT_SUPPORTED, .+?\\])\"));\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_ACCESS_DENIED), R\"(\\[code: ERROR_ACCESS_DENIED, .+?\\])\"));\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_INSUFFICIENT_BUFFER), R\"(\\[code: ERROR_INSUFFICIENT_BUFFER, .+?\\])\"));\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_GEN_FAILURE), R\"(\\[code: ERROR_GEN_FAILURE, .+?\\])\"));\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_SUCCESS), R\"(\\[code: ERROR_SUCCESS, .+?\\])\"));\n  EXPECT_TRUE(test_regex(layer.get_error_string(ERROR_ACCOUNT_DISABLED), R\"(\\[code: )\" + std::to_string(ERROR_ACCOUNT_DISABLED) + R\"(, .+?\\])\"));\n}\n\nTEST(LoggingTest, QueryDisplayConfigPathAndModeCount) {\n  const display_device::WinApiLayer layer;\n\n  const auto active_devices { layer.query_display_config(display_device::WinApiLayer::query_type_e::Active) };\n  const auto all_devices { layer.query_display_config(display_device::WinApiLayer::query_type_e::All) };\n\n  EXPECT_TRUE(active_devices);\n  EXPECT_TRUE(all_devices);\n\n  // This test (and some others) is pointless without any paths. We should always have at least 1 active display device!\n  EXPECT_TRUE(!active_devices->paths.empty());\n  EXPECT_TRUE(all_devices->paths.size() >= active_devices->paths.size());\n  EXPECT_TRUE(all_devices->modes.size() == active_devices->modes.size());\n}\n\nTEST(LoggingTest, QueryDisplayConfigPathActivePaths) {\n  const display_device::WinApiLayer layer;\n\n  const auto active_devices { layer.query_display_config(display_device::WinApiLayer::query_type_e::Active) };\n  EXPECT_TRUE(active_devices);\n\n  for (const auto &path : active_devices->paths) {\n    EXPECT_TRUE(static_cast<bool>(path.flags & DISPLAYCONFIG_PATH_ACTIVE));\n  }\n}\n\nTEST(LoggingTest, QueryDisplayConfigModeIndexValidity) {\n  // The MS docs is not clear when to access the index union struct or not. It appears that union struct is available,\n  // whenever QDC_VIRTUAL_MODE_AWARE is specified when querying (always in our case).\n  //\n  // The docs state, however, that it is only available when DISPLAYCONFIG_PATH_SUPPORT_VIRTUAL_MODE flag is set, but\n  // that is just BS (maybe copy-pasta mistake), because some cases were found where the flag is not set and the union\n  // is still being used.\n  const display_device::WinApiLayer layer;\n\n  const auto active_devices { layer.query_display_config(display_device::WinApiLayer::query_type_e::Active) };\n  const auto all_devices { layer.query_display_config(display_device::WinApiLayer::query_type_e::All) };\n\n  for (const auto &devices : { active_devices, all_devices }) {\n    EXPECT_TRUE(devices);\n\n    for (const auto &path : devices->paths) {\n      const auto clone_group_id = path.sourceInfo.cloneGroupId;\n      const auto source_mode_index = path.sourceInfo.sourceModeInfoIdx;\n      const auto target_mode_index = path.targetInfo.targetModeInfoIdx;\n      const auto desktop_mode_index = path.targetInfo.desktopModeInfoIdx;\n\n      // It is always invalid unless we are preparing paths for new topology\n      EXPECT_EQ(clone_group_id, DISPLAYCONFIG_PATH_CLONE_GROUP_INVALID);\n\n      if (source_mode_index != DISPLAYCONFIG_PATH_SOURCE_MODE_IDX_INVALID) {\n        EXPECT_TRUE(source_mode_index < devices->modes.size());\n        EXPECT_EQ(devices->modes[source_mode_index].infoType, DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE);\n      }\n\n      if (target_mode_index != DISPLAYCONFIG_PATH_TARGET_MODE_IDX_INVALID) {\n        EXPECT_TRUE(target_mode_index < devices->modes.size());\n        EXPECT_EQ(devices->modes[target_mode_index].infoType, DISPLAYCONFIG_MODE_INFO_TYPE_TARGET);\n      }\n\n      if (desktop_mode_index != DISPLAYCONFIG_PATH_DESKTOP_IMAGE_IDX_INVALID) {\n        EXPECT_TRUE(desktop_mode_index < devices->modes.size());\n        EXPECT_EQ(devices->modes[desktop_mode_index].infoType, DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE);\n      }\n    }\n  }\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <Eigen/Dense>\n#include <algorithm>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <numeric>\n#include <random>\n#include <vector>\n#define LOGV(v) std::cout << #v << \"[\" << v.rows() << \" : \" << 1 << \"]\" << std::endl\n#define LOGM(v) std::cout << #v << \"[\" << v.rows() << \" : \" << v.cols() << \"]\" << std::endl\n#define LOG(v) std::cout << #v << \"=\" << std::endl \\\n                         << v << std::endl\n\nEigen::MatrixXd readMatrix()\n{\n    // Open the file\n    std::ifstream file(\"matrix.txt\");\n    if (!file.is_open()) {\n        std::cout << \"Error opening file.\" << std::endl;\n        return Eigen::MatrixXd();\n    }\n    // Read the matrix from the file\n    // Read the matrix dimensions\n    int rows, cols;\n    file >> rows >> cols;\n    // Create a Eigen::MatrixXd to store the data\n    Eigen::MatrixXd M(rows, cols);\n    // Read the matrix elements\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            file >> M(i, j);\n        }\n    }\n    // Close the file\n    file.close();\n    return M;\n}\n\n// \u00c3\u00e5\u00ed\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0 \u00f1\u00eb\u00f3\u00f7\u00e0\u00e9\u00ed\u00fb\u00f5 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00ee\u00e2 \u00ef\u00ee \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00ec\u00f3 \u00e8 \u00ea\u00ee\u00e2\u00e0\u00f0\u00e8\u00e0\u00f6\u00e8\u00e8\nEigen::VectorXd generateRandomVector(const Eigen::VectorXd& mean,\n    const Eigen::MatrixXd& covariance)\n{\n    // Create random number generator\n    std::random_device rd;\n    std::mt19937 generator(rd());\n    std::normal_distribution<double> distribution(0.0, 1.0); // Gaussian distribution with mean 0 and standard deviation 1\n    // Compute Cholesky decomposition of the covariance matrix\n    Eigen::LLT<Eigen::MatrixXd> llt(covariance);\n    Eigen::MatrixXd L = llt.matrixL();\n\n    // Generate random vector from standard Gaussian distribution\n    Eigen::VectorXd z(mean.size());\n    for (int i = 0; i < mean.size(); ++i) {\n        z(i) = distribution(generator);\n    }\n    // Transform random vector to match the desired mean and covariance\n    Eigen::VectorXd random_vector = mean + L * z;\n    return random_vector;\n}\n\n// \u00dd\u00eb\u00eb\u00e8\u00ef\u00f1 \u00ef\u00ee \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00ec\u00f3 \u00e8 \u00ea\u00ee\u00e2\u00e0\u00f0\u00e8\u00e0\u00f6\u00e8\u00e8\n// x - \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00e5\n// P - \u00ea\u00ee\u00e2\u00e0\u00f0\u00e8\u00e0\u00f6\u00e8\u00ff\n// n - \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f1\u00e8\u00e3\u00ec (\u00ec\u00e0\u00f1\u00f8\u00f2\u00e0\u00e1)\n// NP - \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f2\u00ee\u00f7\u00e5\u00ea \u00fd\u00eb\u00eb\u00e8\u00ef\u00f1\u00e0\n// \u00e2\u00ee\u00e7\u00e2\u00f0\u00e0\u00f9\u00e0\u00e5\u00f2 NP \u00f2\u00ee\u00f7\u00e5\u00ea \u00fd\u00eb\u00eb\u00e8\u00ef\u00f1\u00e0 + 4 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00e4\u00eb\u00ff \u00ee\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e8 \u00ee\u00f1\u00e5\u00e9\nstd::tuple<Eigen::VectorXd, Eigen::VectorXd> cov2elli(const Eigen::VectorXd& x, const Eigen::MatrixXd& P, int n = 3, int NP = 16)\n{\n    // +4 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00ee\u00f1\u00e5\u00e9\n    Eigen::VectorXd X(NP + 4);\n    Eigen::VectorXd Y(NP + 4);\n    double alpha = 2 * M_PI / NP;\n    Eigen::MatrixXd circle(2, NP);\n    for (int i = 0; i < NP; ++i) {\n        circle(0, i) = cos(alpha * i);\n        circle(1, i) = sin(alpha * i);\n    }\n    Eigen::JacobiSVD<Eigen::MatrixXd> svd(P, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    Eigen::MatrixXd R = svd.matrixU();\n    Eigen::MatrixXd D = svd.singularValues().asDiagonal();\n    Eigen::MatrixXd d = D.array().sqrt().matrix();\n    Eigen::MatrixXd ellip = n * R * d * circle;\n    for (int i = 0; i < ellip.cols(); ++i) {\n        X(i) = x(0) + ellip(0, i);\n        Y(i) = x(1) + ellip(1, i);\n    }\n    Eigen::MatrixXd axis(2, 4);\n    axis << -1, 1, 0, 0,\n        0, 0, -1, 1;\n    axis = (n * R * d * axis).colwise() + x;\n\n    X.segment(NP, 4) = axis.row(0);\n    Y.segment(NP, 4) = axis.row(1);\n    return std::make_tuple(X, Y);\n}\n// \u00cf\u00f0\u00e5\u00ee\u00e1\u00f0\u00e0\u00e7\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00e8\u00e7 \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00fb\u00f5 \u00e2 \u00d1\u00ca \u00f0\u00ee\u00e1\u00ee\u00f2\u00e0\nEigen::VectorXd toFrame(const Eigen::VectorXd& F,\n    const Eigen::VectorXd& p,\n    Eigen::MatrixXd& PF_f = Eigen::MatrixXd(),\n    Eigen::MatrixXd& PF_p = Eigen::MatrixXd())\n{\n    Eigen::VectorXd pf;\n    Eigen::VectorXd t = F.head(2);\n    double a = F(2);\n    Eigen::Matrix2d R;\n    R << cos(a), -sin(a), sin(a), cos(a);\n    pf = R.transpose() * (p - t);\n    if (!PF_f.isZero() && !PF_p.isZero()) {\n        double px = p(0);\n        double py = p(1);\n        double x = t(0);\n        double y = t(1);\n        PF_f << -cos(a), -sin(a), cos(a) * (py - y) - sin(a) * (px - x),\n            sin(a), -cos(a), -cos(a) * (px - x) - sin(a) * (py - y);\n        PF_p = R.transpose();\n    }\n    return pf;\n}\n// \u00cf\u00f0\u00e5\u00ee\u00e1\u00f0\u00e0\u00e7\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00e8\u00e7 \u00d1\u00ca \u00f0\u00ee\u00e1\u00ee\u00f2\u00e0 \u00e2 \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00f3\u00fe.\nEigen::VectorXd fromFrame(const Eigen::VectorXd& F,\n    const Eigen::VectorXd& pf,\n    Eigen::MatrixXd& PW_f = Eigen::MatrixXd(),\n    Eigen::MatrixXd& PW_pf = Eigen::MatrixXd())\n{\n    Eigen::VectorXd pw;\n    Eigen::VectorXd t = F.head(2);\n    double a = F(2);\n    Eigen::Matrix2d R;\n    R << cos(a), -sin(a), sin(a), cos(a);\n    pw = R * pf + t.replicate(1, pf.cols());\n    if (!PW_f.isZero() && !PW_pf.isZero()) {\n        double px = pf(0);\n        double py = pf(1);\n        PW_f << 1, 0, -py * cos(a) - px * sin(a),\n            0, 1, px * cos(a) - py * sin(a);\n        PW_pf = R;\n    }\n    return pw;\n}\n\n// \u00cd\u00e0\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00e8 \u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e5 \u00e2 x \u00e8 y.\n//\n// \u00e2\u00f5\u00ee\u00e4:  y = [\u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e5 ; \u00ed\u00e0\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5]\n// \u00c2\u00fb\u00f5\u00ee\u00e4: p = [p x ; p y]\n// P_y: \u00df\u00ea\u00ee\u00e1\u00e8\u00e0\u00ed \u00ee\u00f2\u00ed\u00ee\u00f1\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee y. \u00cc\u00e0\u00f2\u00f0\u00e8\u00f6\u00e0 2x2\nEigen::VectorXd invScan(const Eigen::VectorXd& y, Eigen::MatrixXd& P_y = Eigen::MatrixXd())\n{\n    Eigen::VectorXd p;\n    double d = y(0);\n    double a = y(1);\n    double px = d * cos(a);\n    double py = d * sin(a);\n    p.resize(2);\n    p << px, py;\n  ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/**\r\n    ##################################\r\n    #                                #\r\n    #      AUTORES DO PROJETO:       #\r\n    #                                #\r\n    # MARCO VINICIUS DA COSTA BUSATO #\r\n    #      FELYPE CESAR MOLINARI     #\r\n    #     LAURA FERRARI HECKMANN     #\r\n    #                                #\r\n    ##################################\r\n*/\r\n\r\n#include <iostream>\r\n#include <windows.h>\r\n#include <conio.h>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\n///Coordenadas do personagem e da bomba\r\nint xPersonagem = 2, yPersonagem = 2;\r\nint xBomba, yBomba;\r\n\r\n///Controle de movimento aleat\u00f3rio dos inimigos\r\nint deslocamentos;\r\nint direcao;\r\nint inimigo;\r\n\r\n///Controle de tempo entre movimenta\u00e7\u00e3o de inimigos e explos\u00e3o de bomba.\r\nint timerInimigo = 0;\r\nint timerBomba = 0;\r\n\r\n///Controla quanto tempo o caractere de explos\u00e3o fica em tela\r\nint explosaoBomba = 0;\r\n\r\n///Controles gerais de execu\u00e7\u00e3o do jogo\r\nbool gameLoop = true;\r\nbool bombaEmJogo = false;\r\n\r\nstring causaDaMorte = \"Indefinida\";\r\n\r\n///Variavel para tecla pressionada\r\nchar tecla;\r\n\r\n///Matriz que controla a impress\u00e3o do mapa\r\n///0: Caminho livre\r\n///1: Parede s\u00f3lida\r\n///2: Parede fr\u00e1gil\r\n///3 e 6: Caracteres da bomba (pois ela pisca)\r\n///4: Caractere de explos\u00e3o da bomba\r\n///5: Inimigos\r\nint m[10][22]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n               0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\r\n               0,1,0,0,2,0,2,2,0,0,2,0,2,0,2,0,2,0,0,0,5,1,\r\n               0,1,0,1,2,1,2,1,0,1,0,1,2,1,2,1,0,1,0,1,0,1,\r\n               0,1,2,0,2,0,2,0,0,0,2,2,2,0,2,2,2,0,0,2,0,1,\r\n               0,1,0,1,2,1,2,1,5,1,2,1,2,1,0,1,2,1,2,1,2,1,\r\n               0,1,0,0,2,0,2,2,0,0,0,0,2,0,2,2,0,0,0,0,0,1,\r\n               0,1,0,1,0,1,2,1,2,1,0,1,0,1,2,1,2,1,0,1,0,1,\r\n               0,1,5,0,0,2,2,0,0,2,0,0,0,2,2,2,0,2,0,0,5,1,\r\n               0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\r\n\r\n///Estrutura do inimigo\r\nstruct Inimigo{\r\n    int xInimigo;\r\n    int yInimigo;\r\n};\r\n\r\n///Inimigos\r\nInimigo a;\r\nInimigo b;\r\nInimigo c;\r\nInimigo d;\r\n\r\n///Ponteiro para armazenar o inimigo escolhido em quest\u00e3o\r\nInimigo* inimigoEscolhido;\r\n\r\n///As 4 pr\u00f3ximas fun\u00e7\u00f5es s\u00e3o booleanos que controlam a possibilidade de movimenta\u00e7\u00e3o do personagem\r\nbool personagemCima(int x, int y){\r\n\r\n    if(m[x-1][y] == 1 || m[x-1][y] == 2 || m[x-1][y] == 3 || m[x-1][y] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemBaixo(int x, int y){\r\n\r\n    if(m[x+1][y] == 1 || m[x+1][y] == 2 || m[x+1][y] == 3 || m[x+1][y] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemEsquerda(int x, int y){\r\n\r\n    if(m[x][y-1] == 1 || m[x][y-1] == 2 || m[x][y-1] == 3 || m[x][y-1] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemDireita(int x, int y){\r\n\r\n    if(m[x][y+1] == 1 || m[x][y+1] == 2 || m[x][y+1] == 3 || m[x][y+1] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\n///As 4 pr\u00f3ximas fun\u00e7\u00f5es s\u00e3o booleanos que controlam a possibilidade de movimenta\u00e7\u00e3o dos inimigos\r\nbool inimigoCima(Inimigo &inimigoEscolhido){\r\n\r\n   if(m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 1 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 2 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 3 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 5 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 6 ||\r\n      ///As coordenadas -1 indicam que o inimigo j\u00e1 morreu, uma vez que n\u00e3o existe essa coordenada na matriz.\r\n      inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoBaixo(Inimigo &inimigoEscolhido){\r\n\r\n    if(m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 1 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 2 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 3 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 5 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 6 ||\r\n       inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoEsquerda(Inimigo &inimigoEscolhido){\r\n\r\n    if(m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 1 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 2 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 3 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 5 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 6 ||\r\n       inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoDireita(Inimigo &ini",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// SPDX-FileCopyrightText: 2022 UnionTech Software Technology Co., Ltd.\n//\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"commandlinemanager.h\"\n\n#include <QCommandLineOption>\n\nclass CommandLineManagerGlobal : public CommandLineManager {};\nQ_GLOBAL_STATIC(CommandLineManagerGlobal, commandLineManagerGlobal);\n\nCommandLineManager::CommandLineManager()\n    : m_commandParser(new QCommandLineParser)\n{\n    // \u5fc5\u987b\u8bbe\u7f6e\u4e3a\u957f\u9009\u9879\u6a21\u5f0f\uff0c\u5426\u5219\u89e3\u6790\u65f6 -window-id \u5c06\u8bc6\u522b\u9519\u8bef\n    m_commandParser->setSingleDashWordOptionMode(QCommandLineParser::ParseAsLongOptions);\n\n    initOptions();\n}\n\nCommandLineManager *CommandLineManager::instance()\n{\n    return commandLineManagerGlobal;\n}\n\nCommandLineManager::~CommandLineManager()\n{\n\n}\n\nvoid CommandLineManager::initOptions()\n{\n    QCommandLineOption subWindowOption(\"window-id\", \"displays as a child of the given ID window.\\nNOTE:is '-window-id',not '--window-id'\", \"ID\");\n    QCommandLineOption pathOption(QStringList() << \"d\" << \"directory\", \"set the path to find pictures.\", \"PATH\");\n    QCommandLineOption intervalTimeOption(QStringList() << \"t\" << \"interval-time\", \"set the number of seconds slideshow pictures.\"\n                                                                                   \"\\n 0:1 minutes\\n 1:3 minutes\\n 2:5 minutes\\n 3:10 minutes\"\n                                                                                   \"\\n 4:30 minutes\\n 5:60 minutes\", \"TIME\");\n    QCommandLineOption intervalModeOption(QStringList() << \"m\" << \"interval-mode\", \"set whether to paly randomly.\\n  true or false\", \"MODE\");\n    QCommandLineOption config(QStringList() << \"config\", \"show config user Interface\");\n\n    m_commandParser->addOption(subWindowOption);\n    m_commandParser->addOption(pathOption);\n    m_commandParser->addOption(intervalTimeOption);\n    m_commandParser->addOption(intervalModeOption);\n    m_commandParser->addOption(config);\n}\n\nvoid CommandLineManager::process(const QStringList &arguments)\n{\n    m_commandParser->process(arguments);\n}\n\nbool CommandLineManager::isSet(const QString &name) const\n{\n    return m_commandParser->isSet(name);\n}\n\nQString CommandLineManager::value(const QString &name) const\n{\n    return m_commandParser->value(name);\n}\n\nQStringList CommandLineManager::positionalArguments()\n{\n    return m_commandParser->positionalArguments();\n}\n\nQStringList CommandLineManager::unknownOptionNames()\n{\n    return m_commandParser->unknownOptionNames();\n}\n\n",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Point {\r\npublic:\r\n    int x, y;\r\n};\r\n\r\n// Compare function for sorting points based on X coordinate\r\nint compareX(const void* a, const void* b) {\r\n    Point *p1 = (Point *)a, *p2 = (Point *)b;\r\n    return (p1->x - p2->x);\r\n}\r\n\r\n// Compare function for sorting points based on Y coordinate\r\nint compareY(const void* a, const void* b) {\r\n    Point *p1 = (Point *)a, *p2 = (Point *)b;\r\n    return (p1->y - p2->y);\r\n}\r\n\r\n// Utility function to calculate distance between two points\r\nfloat dist(Point p1, Point p2) {\r\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\r\n}\r\n\r\n// Brute force method to find smallest distance between points\r\nfloat bruteForce(Point P[], int n) {\r\n    float min_dist = FLT_MAX;\r\n    for (int i = 0; i < n; ++i) {\r\n        for (int j = i + 1; j < n; ++j) {\r\n            if (dist(P[i], P[j]) < min_dist) {\r\n                min_dist = dist(P[i], P[j]);\r\n            }\r\n        }\r\n    }\r\n    return min_dist;\r\n}\r\n\r\n// Utility function to find minimum of two float values\r\nfloat min(float x, float y) {\r\n    return (x < y) ? x : y;\r\n}\r\n\r\n// Utility function to find the distance between the closest points of a strip\r\nfloat stripClosest(Point strip[], int size, float d) {\r\n    float min_dist = d;\r\n    qsort(strip, size, sizeof(Point), compareY);\r\n\r\n    for (int i = 0; i < size; ++i) {\r\n        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < min_dist; ++j) {\r\n            if (dist(strip[i], strip[j]) < min_dist) {\r\n                min_dist = dist(strip[i], strip[j]);\r\n            }\r\n        }\r\n    }\r\n    return min_dist;\r\n}\r\n\r\n// Recursive function to find the smallest distance\r\nfloat closestUtil(Point P[], int n) {\r\n    if (n <= 3) {\r\n        return bruteForce(P, n);\r\n    }\r\n\r\n    int mid = n / 2;\r\n    Point midPoint = P[mid];\r\n\r\n    float dl = closestUtil(P, mid);\r\n    float dr = closestUtil(P + mid, n - mid);\r\n\r\n    float d = min(dl, dr);\r\n\r\n    Point strip[n];\r\n    int j = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (abs(P[i].x - midPoint.x) < d) {\r\n            strip[j] = P[i];\r\n            j++;\r\n        }\r\n    }\r\n\r\n    return min(d, stripClosest(strip, j, d));\r\n}\r\n\r\n// Main function to find the smallest distance\r\nfloat closest(Point P[], int n) {\r\n    qsort(P, n, sizeof(Point), compareX);\r\n    return closestUtil(P, n);\r\n}\r\n\r\nint main() {\r\n    int T;\r\n    cin >> T;\r\n    while (T--) {\r\n        int N;\r\n        cin >> N;\r\n        Point P[N];\r\n        for (int i = 0; i < N; i++) {\r\n            cin >> P[i].x >> P[i].y;\r\n        }\r\n        cout << fixed << setprecision(6) << closest(P, N) << ' '<< endl;\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"product\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "const int Green = 13;\nconst int Yellow = 12;\nconst int Red = 11;\n\nconst int GroupB[] = {2, 3, 4, 5, 6, 7, 8};\nconst int botao = 10;\n\nvoid setup() {\n  pinMode(Green, OUTPUT);\n  pinMode(Yellow, OUTPUT);\n  pinMode(Red, OUTPUT);\n  for (int i = 0; i < 7; i++) {\n    pinMode(GroupB[i], OUTPUT);\n  }\n  pinMode(botao, INPUT_PULLUP);\n}\n\nvoid loop() {  \n  while (digitalRead(botao) == HIGH) {\n    digitalWrite(Green, HIGH);\n    \n     for (int i = 0; i < 5; i++) {\n      \n      \tfor (int j = 0; j < 7; j++) {\n        digitalWrite(GroupB[j], HIGH);\n        delay(100);\n        digitalWrite(GroupB[j], LOW);\n        delay(200);\n      }      \n    }\n    \n    digitalWrite(Green, LOW);\n    digitalWrite(Yellow, HIGH);\n\n    for (int i = 0; i < 3; i++) {\n      for (int j = 8; j >=0 ; j--) {\n      digitalWrite(GroupB[j], HIGH);\n      delay(800);\n      }   \n      for (int j = 0; j < 7; j++) {\n        digitalWrite(GroupB[j], LOW);\n      }\n    } \n    \n    digitalWrite(Yellow, LOW);\n    digitalWrite(Red, HIGH);\n \t\n    for (int R = 0; R < 3; R++) {\n      for (int u = 0; u < 5; u++) { \n        for (int d = 0; d < 7; d++) {\n          digitalWrite(GroupB[d], HIGH);\n        }\n        delay(300);\n        for (int j = 0; j < 7; j++) {\n          digitalWrite(GroupB[j], LOW);\n        }\n        delay(300);\n      }\n      delay(10000);\n    }\n    \n    digitalWrite(Red, LOW); \n  }\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\nint t, e, n, q, j, h, u;\nint a[100001], AIB[11][100001], l[100001], r[100001], ind[100001], sol[100001];\n\nvoid Add(int x, int quantity)\n{\n    for(int i = x; i <= 100000; i += ((i ^ (i - 1)) & i))\n        AIB[e][i] += quantity;\n}\n\nint Compute(int x)\n{\n    int ret = 0;\n    for(int i = x; i > 0; i -= ((i ^ (i - 1)) & i))\n        ret += AIB[e][i];\n    return ret;\n}\n\nbool cmp(int le, int ra)\n{\n\treturn l[le] < l[ra];\n}\n\nint main() \n{\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\tcin >> t;\n\tfor(e = 1; e <= t; e++)\n\t{\n\t\tcin >> n >> q;\n\t\tfor(j = 0; j < n; j++) \n\t\t\tcin >> a[j]; \n\t\tfor(j = 1; j <= q; j++)\n\t\t{\n\t\t\tcin >> l[j];\n\t\t\tcin >> r[j];\n\t\t\tind[j] = j;\n\t\t}\n        sort(ind + 1, ind + q + 1, cmp);\n\t\tl[0] = -1;\n\t\tfor(j = 1; j <= q; j++)\n\t\t{\n\t\t\th = ind[j];\n            if(l[h] > l[ind[j - 1]]) \n\t\t\t    for(u = l[ind[j - 1]] + 1; u <= l[h]; u++) \n\t\t\t\t\tAdd(a[u], a[u]);\n\t\t\tsol[h] = Compute(100000) - Compute(a[r[h]]);\n\t\t}\n\t\tfor(j = 1; j <= q; j++)\n\t\t    cout << sol[j] << \" \";\n\t\tcout << \"\\n\";\n\t}\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <set>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <sstream>\n#include \"parser.hpp\"\n\nextern int yylex();\nextern Tree * root;\n\n/*\n * These values are globals defined in the parsing function.\n */\nextern std::string* target_program;\nextern std::set<std::string> symbols;\nint a = 0;\nvoid print_node(std::string variable_name, std::string node_value){\n  std::cout<<variable_name<<\" \"<<\"[label=\\\"\"<<node_value<<\"\\\"];\\n\"<<std::endl;\n\n}\nvoid print_connection(std::string child, std::string parent){\n  std::cout<<parent<<\" -> \"<<child<<\";\\n\"<<std::endl;\n}\nvoid print_tree(Tree *node,std::string parent){\n  std::string current_node;\n  if(node == NULL){\n    return;\n  }\n    std::ostringstream stm ;\n    stm << a ;\n    current_node = node->node_type + stm.str();\n    a++;\n    if(node->node_type != \"STATEMENT\"){\n      print_node(current_node, node->node_type + (node->value.size() > 0 ? (\" \" + node->value) : \"\"));\n      print_connection(current_node,parent);\n    }\n    for (std::vector<Tree *>::iterator it = node->block.begin() ; it != node->block.end(); it++){\n      print_tree(*it,parent);\n    }\n    for (std::vector<Tree *>::iterator it = node->child.begin() ; it != node->child.end(); it++){\n      print_tree(*it,current_node);\n    }\n}\n\nint main() {\n  if (!yylex()) {\n    std::cout << \"digraph G {\" << std::endl;\n    print_tree(root,\"block\");\n    std::cout << \"}\" << std::endl;\n  }\n}\n",
    "// Include important C++ libraries here\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\n// Make code easier to type with \"using namespace\"\nusing namespace sf;\nusing namespace std;\n\nint main()\n{\n    // Create a video mode object\n\tVideoMode vm(1920, 1080);\n\t// Create and open a window for the game\n\tRenderWindow window(vm, \"Chaos Game!!\", Style::Default);\n\n    vector<Vector2f> vertices;\n    vector<Vector2f> points;\n\n\tFont font;\n\tif (!font.loadFromFile(\"KOMIKAP_.ttf\"))\n\t{\n\t\tcerr << \"Something wrong with font.\" << endl;\n\t}\n\t\n\tText displayCoords; //new object to show the coordinates to user\n\tdisplayCoords.setFont(font);\n\tdisplayCoords.setCharacterSize(15);\n\tdisplayCoords.setFillColor(Color::White);\n\tdisplayCoords.setPosition(1500.f, 600.f); // need to change coords\n\tstring completestring = \"\";\n\tstring displayvertices;\n\n\n\twhile (window.isOpen())\n\t{\n        /*\n\t\t****************************************\n\t\tHandle the players input\n\t\t****************************************\n\t\t*/\n        Event event;\n\t\twhile (window.pollEvent(event))\n\t\t{\n\n\t\t\n\t\t\tif (event.type == Event::Closed)\n            {\n\t\t\t\t// Quit the game when the window is closed\n\t\t\t\twindow.close();\n            }\n            if (event.type == sf::Event::MouseButtonPressed)\n            {\n\t\t\t\tFont font;\n            \tif (event.mouseButton.button == sf::Mouse::Left)\n                {\n                    std::cout << \"the left button was pressed\" << std::endl;\n                    std::cout << \"mouse x: \" << event.mouseButton.x << std::endl;\n                    std::cout << \"mouse y: \" << event.mouseButton.y << std::endl;\n\n                    if(vertices.size() < 3)\n                    {\n                        vertices.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n\t\t\t\t\t\tdisplayvertices = \"Vertex \" + to_string(vertices.size()) + \"\\nmouse x: \" + to_string(event.mouseButton.x) + \"\\nmouse y: \" + to_string(event.mouseButton.y) +\"\\n\";\n\t\t\t\t\t\tcompletestring = completestring + displayvertices;\n\t\t\t\t\t\tdisplayCoords.setString(completestring);\n                    }\n                    else if(points.size() == 0)\n                    {\n\t\t\tpoints.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n                        ///fourth click\n                        ///push back to points vector\n                    }\n                }\n            }\n        }\n        if (Keyboard::isKeyPressed(Keyboard::Escape))\n\t\t{\n\t\t\twindow.close();\n\t\t}\n        /*\n\t\t****************************************\n\t\tUpdate\n\t\t****************************************\n\t\t*/\n\n        if(points.size() > 0)\n        {\n            ///generate more point(s)\n            ///select random vertex\n            ///calculate midpoint between random vertex and the last point in the vector\n            ///push back the newly generated coord.\n\t    \tfor (int i=0; i<50; i++)\n\t\t\t{\n\t\t\t\tint index=rand() % vertices.size();\n\t\t\t\tVector2f randVertex = vertices[index];\n\n\t\t\t\tVector2f midpoint = (randVertex + points.back())/2.0f;\n\t\t\t\tpoints.push_back(midpoint);\n\n\t\t\t\tRectangleShape rect(Vector2f(5,5));\n\t\t\t\trect.setPosition(midpoint);\n\t\t\t\trect.setFillColor(Color::Red);\n\t\t\t\twindow.draw(rect);\n\t\t\t}\n        }\n\n        /*\n\t\t****************************************\n\t\tDraw\n\t\t****************************************\n\t\t*/\n        window.clear();\n        for(unsigned long long int i = 0; i < vertices.size(); i++)\n        {\n            RectangleShape rect(Vector2f(10,10));\n            rect.setPosition(Vector2f(vertices[i].x, vertices[i].y));\n            rect.setFillColor(Color::Blue);\n            window.draw(rect);\n        }\n\tfor (unsigned long long int i=0; i< points.size();i++){\n\t    RectangleShape rect(Vector2f(5,5));\n\t    rect.setPosition(Vector2f(points[i].x, points[i].y));\n\t    rect.setFillColor(Color::Blue);\n\t    window.draw(rect);\n\t}\n\n    \tText text;\n    \ttext.setFont(font);\n    \ttext.setCharacterSize(25);\n    \ttext.setFillColor(Color::White);\n    \ttext.setPosition(10.f, 10.f);\n    \ttext.setString(\"Click on 3 spots to set up triangle vertices. \\nThen click for the 4th point to start generating the fractal. \");\n\t\t\n\twindow.draw(text);\n\twindow.draw(displayCoords);\n\twindow.display();\n    }\n}\n//Karnpreet Klair and Musa Rana",
    "#include \"Audio.h\"\n\nAudio::Audio(MicType micType) {\n  wavData = new char*[wavDataSize/dividedWavDataSize];\n  for (int i = 0; i < wavDataSize/dividedWavDataSize; ++i) wavData[i] = new char[dividedWavDataSize];\n  i2s = new I2S(micType);\n}\n\nAudio::~Audio() {\n  for (int i = 0; i < wavDataSize/dividedWavDataSize; ++i) delete[] wavData[i];\n  delete[] wavData;\n  delete i2s;\n}\n\nvoid Audio::CreateWavHeader(byte* header, int waveDataSize){\n  header[0] = 'R';\n  header[1] = 'I';\n  header[2] = 'F';\n  header[3] = 'F';\n  unsigned int fileSizeMinus8 = waveDataSize + 44 - 8;\n  header[4] = (byte)(fileSizeMinus8 & 0xFF);\n  header[5] = (byte)((fileSizeMinus8 >> 8) & 0xFF);\n  header[6] = (byte)((fileSizeMinus8 >> 16) & 0xFF);\n  header[7] = (byte)((fileSizeMinus8 >> 24) & 0xFF);\n  header[8] = 'W';\n  header[9] = 'A';\n  header[10] = 'V';\n  header[11] = 'E';\n  header[12] = 'f';\n  header[13] = 'm';\n  header[14] = 't';\n  header[15] = ' ';\n  header[16] = 0x10;  // linear PCM\n  header[17] = 0x00;\n  header[18] = 0x00;\n  header[19] = 0x00;\n  header[20] = 0x01;  // linear PCM\n  header[21] = 0x00;\n  header[22] = 0x01;  // monoral\n  header[23] = 0x00;\n  header[24] = 0x80;  // sampling rate 16000\n  header[25] = 0x3E;\n  header[26] = 0x00;\n  header[27] = 0x00;\n  header[28] = 0x00;  // Byte/sec = 16000x2x1 = 32000\n  header[29] = 0x7D;\n  header[30] = 0x00;\n  header[31] = 0x00;\n  header[32] = 0x02;  // 16bit monoral\n  header[33] = 0x00;\n  header[34] = 0x10;  // 16bit\n  header[35] = 0x00;\n  header[36] = 'd';\n  header[37] = 'a';\n  header[38] = 't';\n  header[39] = 'a';\n  header[40] = (byte)(waveDataSize & 0xFF);\n  header[41] = (byte)((waveDataSize >> 8) & 0xFF);\n  header[42] = (byte)((waveDataSize >> 16) & 0xFF);\n  header[43] = (byte)((waveDataSize >> 24) & 0xFF);\n}\n\nvoid Audio::Record() {\n  CreateWavHeader(paddedHeader, wavDataSize);\n  int bitBitPerSample = i2s->GetBitPerSample();\n  if (bitBitPerSample == 16) {\n    for (int j = 0; j < wavDataSize/dividedWavDataSize; ++j) {\n      i2s->Read(i2sBuffer, i2sBufferSize/2);\n      for (int i = 0; i < i2sBufferSize/8; ++i) {\n        wavData[j][2*i] = i2sBuffer[4*i + 2];\n        wavData[j][2*i + 1] = i2sBuffer[4*i + 3];\n      }\n    }\n  }\n  else if (bitBitPerSample == 32) {\n    for (int j = 0; j < wavDataSize/dividedWavDataSize; ++j) {\n      i2s->Read(i2sBuffer, i2sBufferSize);\n      for (int i = 0; i < i2sBufferSize/8; ++i) {\n        wavData[j][2*i] = i2sBuffer[8*i + 2];\n        wavData[j][2*i + 1] = i2sBuffer[8*i + 3];\n      }\n    }\n  }\n}\n",
    "#include \"Arduino.h\"\r\n#include \"TM1638_Module.h\"\r\n\r\nbyte digit[] = {\r\n 0b00111111,  // 0\r\n 0b00000110,\r\n 0b01011011,\r\n 0b01001111,\r\n 0b01100110,\r\n 0b01101101,\r\n 0b01111101,\r\n 0b00000111,\r\n 0b01111111,\r\n 0b01101111,   // 9\r\n 0b00000000,  // clear all\r\n 0b01000000,  // minus \"-\"\r\n\t};\r\n\r\n\r\n\r\nTM1638_Module::TM1638_Module(const uint8_t strobe,\r\n\tconst uint8_t clock,\r\n\tconst uint8_t data): strobe(strobe),clock(clock),data(data) {\r\n\r\n\t}\r\n\r\nTM1638_Module::~TM1638_Module() \r\n\t{}\r\n\r\nvoid TM1638_Module::init() {\r\n\tpinMode(strobe, OUTPUT);\r\n\tpinMode(clock, OUTPUT);\r\n\tpinMode(data, OUTPUT);\r\n\r\n\tsendCommand(0x8f);  // activate and set brightness to max\r\n\treset();\r\n\t}\r\n\r\nvoid TM1638_Module::sendCommand(uint8_t value)\r\n\t{\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, value);\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nvoid TM1638_Module::tm1638_led(byte pos, byte state) {\r\n\tif ((pos > 7) || (state > 1)) return;\r\n\tsendCommand(0x44);  // set single address\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, (0xc1 + pos * 2)); // 3rd LED\r\n\tshiftOut(data, clock, LSBFIRST, state);\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nvoid TM1638_Module::tm1638_num(byte pos, byte num, bool dp) {\r\n\tif ((pos > 7) || (num > 11)) return;  // 0-9, space, minus/dash\r\n\tbyte out = digit[num];\r\n\tif (dp) out |= 0x80;\r\n\tsendCommand(0x44);  // set single address\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, (0xc0 + pos * 2)); // 3rd LED\r\n\tshiftOut(data, clock, LSBFIRST, out);\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nvoid TM1638_Module::reset()\r\n\t{\r\n\tsendCommand(0x40); // set auto increment mode\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, 0xc0);   // set starting address to 0\r\n\tfor (uint8_t i = 0; i < 16; i++)\r\n\t\t{\r\n\t\tshiftOut(data, clock, LSBFIRST, 0x00);\r\n\t\t}\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nuint8_t TM1638_Module::readButtons(void)\r\n\t{\r\n\tuint8_t buttons = 0;\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, 0x42);\r\n\r\n\tpinMode(data, INPUT);\r\n\r\n\tfor (uint8_t i = 0; i < 4; i++)\r\n\t\t{\r\n\t\tuint8_t v = shiftIn(data, clock, LSBFIRST) << i;\r\n\t\tbuttons |= v;\r\n\t\t}\r\n\r\n\tpinMode(data, OUTPUT);\r\n\tdigitalWrite(strobe, HIGH);\r\n\treturn buttons;\r\n\t}\r\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n\n#define GLAD_GL_IMPLEMENTATION\n#include <gl.h>\n\n#ifdef SFML_SYSTEM_IOS\n#include <SFML/Main.hpp>\n#endif\n\n#ifndef GL_SRGB8_ALPHA8\n#define GL_SRGB8_ALPHA8 0x8C43\n#endif\n\nstd::string resourcesDir()\n{\n#ifdef SFML_SYSTEM_IOS\n    return \"\";\n#else\n    return \"resources/\";\n#endif\n}\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    bool exit = false;\n    bool sRgb = false;\n\n    while (!exit)\n    {\n        // Request a 24-bits depth buffer when creating the window\n        sf::ContextSettings contextSettings;\n        contextSettings.depthBits = 24;\n        contextSettings.sRgbCapable = sRgb;\n\n        // Create the main window\n        sf::RenderWindow window(sf::VideoMode(800, 600), \"SFML graphics with OpenGL\", sf::Style::Default, contextSettings);\n        window.setVerticalSyncEnabled(true);\n\n        // Create a sprite for the background\n        sf::Texture backgroundTexture;\n        backgroundTexture.setSrgb(sRgb);\n        if (!backgroundTexture.loadFromFile(resourcesDir() + \"background.jpg\"))\n            return EXIT_FAILURE;\n        sf::Sprite background(backgroundTexture);\n\n        // Create some text to draw on top of our OpenGL object\n        sf::Font font;\n        if (!font.loadFromFile(resourcesDir() + \"tuffy.ttf\"))\n            return EXIT_FAILURE;\n        sf::Text text(\"SFML / OpenGL demo\", font);\n        sf::Text sRgbInstructions(\"Press space to toggle sRGB conversion\", font);\n        sf::Text mipmapInstructions(\"Press return to toggle mipmapping\", font);\n        text.setFillColor(sf::Color(255, 255, 255, 170));\n        sRgbInstructions.setFillColor(sf::Color(255, 255, 255, 170));\n        mipmapInstructions.setFillColor(sf::Color(255, 255, 255, 170));\n        text.setPosition(280.f, 450.f);\n        sRgbInstructions.setPosition(175.f, 500.f);\n        mipmapInstructions.setPosition(200.f, 550.f);\n\n        // Load a texture to apply to our 3D cube\n        sf::Texture texture;\n        if (!texture.loadFromFile(resourcesDir() + \"logo.png\"))\n            return EXIT_FAILURE;\n\n        // Attempt to generate a mipmap for our cube texture\n        // We don't check the return value here since\n        // mipmapping is purely optional in this example\n        texture.generateMipmap();\n\n        // Make the window the active window for OpenGL calls\n        window.setActive(true);\n\n        // Load OpenGL or OpenGL ES entry points using glad\n#ifdef SFML_OPENGL_ES\n        gladLoadGLES1(reinterpret_cast<GLADloadfunc>(sf::Context::getFunction));\n#else\n        gladLoadGL(reinterpret_cast<GLADloadfunc>(sf::Context::getFunction));\n#endif\n\n        // Enable Z-buffer read and write\n        glEnable(GL_DEPTH_TEST);\n        glDepthMask(GL_TRUE);\n#ifdef SFML_OPENGL_ES\n        glClearDepthf(1.f);\n#else\n        glClearDepth(1.f);\n#endif\n\n        // Disable lighting\n        glDisable(GL_LIGHTING);\n\n        // Configure the viewport (the same size as the window)\n        glViewport(0, 0, static_cast<GLsizei>(window.getSize().x), static_cast<GLsizei>(window.getSize().y));\n\n        // Setup a perspective projection\n        glMatrixMode(GL_PROJECTION);\n        glLoadIdentity();\n        GLfloat ratio = static_cast<float>(window.getSize().x) / static_cast<float>(window.getSize().y);\n#ifdef SFML_OPENGL_ES\n        glFrustumf(-ratio, ratio, -1.f, 1.f, 1.f, 500.f);\n#else\n        glFrustum(-ratio, ratio, -1.f, 1.f, 1.f, 500.f);\n#endif\n\n        // Bind the texture\n        glEnable(GL_TEXTURE_2D);\n        sf::Texture::bind(&texture);\n\n        // Define a 3D cube (6 faces made of 2 triangles composed by 3 vertices)\n        static const GLfloat cube[] =\n        {\n            // positions    // texture coordinates\n            -20, -20, -20,  0, 0,\n            -20,  20, -20,  1, 0,\n            -20, -20,  20,  0, 1,\n            -20, -20,  20,  0, 1,\n            -20,  20, -20,  1, 0,\n            -20,  20,  20,  1, 1,\n\n             20, -20, -20,  0, 0,\n             20,  20, -20,  1, 0,\n             20, -20,  20,  0, 1,\n             20, -20,  20,  0, 1,\n             20,  20, -20,  1, 0,\n             20,  20,  20,  1, 1,\n\n            -20, -20, -20,  0, 0,\n             20, -20, -20,  1, 0,\n            -20, -20,  20,  0, 1,\n            -20, -20,  20,  0, 1,\n             20, -20, -20,  1, 0,\n             20, -20,  20,  1, 1,\n\n            -20,  20, -20,  0, 0,\n             20,  20, -20,  1, 0,\n            -20,  20,  20,  0, 1,\n            -20,  20,  20,  0, 1,\n             20,  20, -20,  1, 0,\n             20,  20,  20,  1, 1,\n\n            -20, -20, -20,  0, 0,\n             20, -20, -20,  1, 0,\n            -20,  20, -20,  0, 1,\n            -20,  20, -20,  0, 1,\n             20, -20, -20,  1, 0,\n             20,  20, -20,  1, 1,\n\n            -20, -",
    "#include \"utils.h\"\n#include <time.h>\n\nnamespace utils\n{\n\tstd::string GenRandomStr()\n\t{\n\t\tsrand((unsigned)time(0) * GetCurrentThreadId());\n\n\t\tstatic const int len = 16;\n\t\tstatic char charset[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\t\tchar str[len]{ 0 };\n\t\tfor (int i = 0; i < len - 1; i++)\n\t\t\tstr[i] = charset[rand() % (strlen(charset) - 1)];\n\n\t\treturn str;\n\t}\n\n\tstd::string GenTempPath()\n\t{\n\t\tchar path[MAX_PATH];\n\t\tauto len = GetTempPathA(MAX_PATH, path);\n\t\tif (!len)\n\t\t\treturn \"\";\n\n\t\tif (path[strlen(path) - 1] == L'\\\\')\n\t\t\tpath[strlen(path) - 1] = 0;\n\n\t\treturn std::string(path);\n\t}\n\n\tbool CreateFileFromMemory(const std::string& path, void* data, size_t size)\n\t{\n\t\tDWORD BytesWritten;\n\t\tBOOL result;\n\t\tHANDLE f;\n\t\tif (!data || !size)\n\t\t\treturn false;\n\n\t\tf = CreateFileA(path.c_str(), GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\tif (!IsValidHandle(f))\n\t\t\treturn false;\n\n\t\tresult = WriteFile(f, data, size, &BytesWritten, NULL);\n\t\tCloseHandle(f);\n\n\t\treturn result && (BytesWritten == size);\n\t}\n\n\tbool DeleteFileFromDisk(const std::string& path)\n\t{\n\t\treturn DeleteFileA(path.c_str());\n\t}\n\n\tbool ReadFileFromMemory(const std::string& path, void* data, size_t dataSize)\n\t{\n\t\tDWORD BytesRead;\n\t\tBOOL result;\n\t\tHANDLE f;\n\t\tif (!data)\n\t\t\treturn false;\n\n\t\tf = CreateFileA(path.c_str(), GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\tif (!IsValidHandle(f))\n\t\t\treturn false;\n\n\t\tresult = ReadFile(f, data, dataSize, &BytesRead, 0);\n\t\tCloseHandle(f);\n\n\t\treturn result && (BytesRead <= dataSize);\n\t}\n\n\t// return = buffer that need to free by caller\n\tPVOID Ntqsi(ULONG klass)\n\t{\n\t\tULONG returnLength = 0;\n\t\tULONG dwBuffer = 0;\n\t\tPVOID pBuffer = 0;\n\t\tNTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)klass, nullptr, 0, &returnLength);\n\n\t\tif (status != 0xC0000004)\n\t\t\treturn 0;\n\n\t\tpBuffer = UAlloc((returnLength + 0x1000));\n\t\tif (!pBuffer)\n\t\t\treturn 0;\n\n\t\tdwBuffer = returnLength + 0x1000;\n\t\tstatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0xB, pBuffer, dwBuffer, &returnLength);\n\t\tif (!NT_SUCCESS(status))\n\t\t{\n\t\t\tUFree(pBuffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn pBuffer;\n\t}\n\n\tPVOID GetKernelModule(LPCSTR moduleName, SIZE_T * size)\n\t{\n\t\tPVOID modbase = 0;\n\t\tauto pSystemModules = (PSYSTEM_MODULE_INFORMATION)Ntqsi(0xB); // systemModuleInformation\n\t\tif (!pSystemModules)\n\t\t\treturn 0;\n\t\t\n\t\tfor (auto i = 0u; i < pSystemModules->Count; i++)\n\t\t{\n\t\t\tauto pModule = &pSystemModules->Module[i];\n\t\t\tauto name = pModule->FullPathName + pModule->OffsetToFileName;\n\t\t\tif (strstr((char*)name, moduleName))\n\t\t\t{\n\t\t\t\tif (size)\n\t\t\t\t\t*size = pModule->ImageSize;\n\t\t\t\tmodbase = pModule->ImageBase;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tUFree(pSystemModules);\n\t\treturn modbase;\n\t}\n\n\tbool GetPhysicalMemoryRange(std::vector<std::pair<ULONG_PTR, ULONG>>* out)\n\t{\n\t\tULONGLONG MaxPhysicalRange;\n\t\tif (!GetPhysicallyInstalledSystemMemory(&MaxPhysicalRange))\n\t\t\treturn false;\n\t\tMaxPhysicalRange *= 1024;\n\t\tMaxPhysicalRange -= 1;\n\n\t\t// printf(\"[+] Your system max physical address : 0x%llX\\n\", MaxPhysicalRange);\n\n\t\tHKEY hKey;\n\t\tDWORD type, size;\n\t\tUCHAR* data = nullptr;\n\n\t\tauto result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"HARDWARE\\\\RESOURCEMAP\\\\System Resources\\\\Physical Memory\", 0, KEY_READ, &hKey);\n\t\tif (result != ERROR_SUCCESS)\n\t\t\treturn false;\n\n\t\tresult = RegQueryValueExA(hKey, \".Translated\", NULL, &type, NULL, &size);\n\t\tif (result != ERROR_SUCCESS)\n\t\t\treturn false;\n\n\t\tdata = new UCHAR[size];\n\t\tif (!data)\n\t\t\treturn false;\n\n\t\tRegQueryValueExA(hKey, \".Translated\", NULL, &type, data, &size);\n\n\t\tauto count = ((_CM_RESOURCE_LIST*)data)->List->PartialResourceList.Count;\n\t\tauto pMemRange = ((_CM_RESOURCE_LIST*)data)->List->PartialResourceList.PartialDescriptors;\n\n\t\tfor (auto i = 0u; i < count; i++)\n\t\t{\n\t\t\tauto physmem = pMemRange[i];\n\t\t\tif (physmem.Memory.OutOfRange(MaxPhysicalRange))\n\t\t\t{\n\t\t\t\t// printf(\"[!] this memory is out of range < %016llX , %08X > \\n\", physmem.Memory.Start, physmem.Memory.Length);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// printf(\"[+] valid physical memory range found < %016llX , %08X > \\n\", physmem.Memory.Start, physmem.Memory.Length);\n\t\t\tout->push_back({ physmem.Memory.Start, physmem.Memory.Length });\n\t\t}\n\t\tdelete[] data;\n\t\tRegCloseKey(hKey);\n\t\treturn true;\n\t}\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"responsiveui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Created by MichaelBrunner on 12/04/2024.\n//\n\n#include \"cwapi3d.test.controller.h\"\n#include \"spdlog/spdlog.h\"\n\n#include <locale>\n#include <cwchar>\n#include <optional>\n\nvoid countVisibleIdentifiableElementIds(CwAPI3D::ElementController &aElementController) {\n    const auto lVisibleIdentifiableElementIds = aElementController.getVisibleIdentifiableElementIDs();\n    if (!lVisibleIdentifiableElementIds) {\n        spdlog::error(\"VisibleIdentifiableElementIDs is null\");\n        return;\n    }\n    spdlog::info(\"VisibleIdentifiableElementIDs count: {}\", lVisibleIdentifiableElementIds->count());\n}\n\nvoid createSnapshot(CwAPI3D::UtilityController &aUtilityController) {\n    const auto lSnapshotBase64 = aUtilityController.createSnapshot(L\"PNG\");\n    if (!lSnapshotBase64) {\n        spdlog::error(\"SnapshotBytes is null\");\n        return;\n    }\n    aUtilityController.printToConsole(lSnapshotBase64->data());\n    spdlog::info(\"Snapshot size: {}\", std::wcslen(lSnapshotBase64->data()));\n}\n\nstd::optional<std::string> cwApi3dStringToStdString(CwAPI3D::Interfaces::ICwAPI3DString *const lValueKey) {\n    char str[256];\n\n    size_t convertedChars = 0;\n    errno_t err = wcstombs_s(&convertedChars, str, sizeof(str), lValueKey->data(), _TRUNCATE);\n    if (err != 0) {\n        spdlog::error(\"wcstombs_s failed\");\n        return std::nullopt;\n    }\n    return std::string(str);\n}\n\nvoid CwAPI3D::Test::cwApi3dControllerIT(CwAPI3D::ControllerFactory *aControllerFactory) {\n\n    spdlog::info(\"-------- cwApi3dControllerIT started --------\");\n\n    // Todo: Implement following in separate functions\n    auto lElementMapQuery = aControllerFactory->createElementMapQuery();\n    lElementMapQuery->setBySubgroup();\n    const auto lVisibleElementIds = aControllerFactory->getElementController()->getVisibleIdentifiableElementIDs();\n    const auto lElementIDListMap = aControllerFactory->getElementController()->mapElements(lVisibleElementIds,\n                                                                                           lElementMapQuery);\n    for (auto il{0}; il < lElementIDListMap->count(); il++) {\n        const auto lValueKey = lElementIDListMap->valueAt(il);\n        const auto lValueElements = lElementIDListMap->itemAt(il);\n        char str[256];\n        auto lValueKeyAsString = cwApi3dStringToStdString(lValueKey);\n        if (!lValueKeyAsString) {\n            spdlog::error(\"cwApi3dStringToStdString failed\");\n            return;\n        }\n        spdlog::info(\"Key: {} ; value count {}\", lValueKeyAsString.value().c_str(), lValueElements->count());\n    }\n\n    // act\n    countVisibleIdentifiableElementIds(*aControllerFactory->getElementController());\n    createSnapshot(*aControllerFactory->getUtilityController());\n\n    spdlog::info(\"-------- cwApi3dControllerIT finished --------\");\n}\n\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n\nclass City {\n  std::string name;\n  double lat;\n  double lon;\npublic:\n  City(std::string _name=\"\", double _lat=0, double _lon=0):name(_name), lat(_lat), lon(_lon) {}\n\n  std::string get_name(){\n    return name;\n  }\n  double get_lat(){\n    return lat;\n  }\n  double get_lon(){\n    return lon;\n  }\n\n  void set_name(std::string _name){\n    name = _name;\n  }\n  void set_lat(double _lat){\n    lat = _lat;\n  }\n  void set_lon(double _lon){\n    lon = _lon;\n  }\n};\n\ndouble distance(City city1, City city2){\n    double lat1 = city1.get_lat();\n    double lat2 = city2.get_lat();\n\n    double lon1 = city1.get_lon();\n    double lon2 = city2.get_lon();\n\n    double dLat = (lat2 - lat1) *\n                  M_PI / 180.0;\n    double dLon = (lon2 - lon1) *\n                  M_PI / 180.0;\n\n    lat1 = (lat1) * M_PI / 180.0;\n    lat2 = (lat2) * M_PI / 180.0;\n\n    double a = pow(sin(dLat / 2), 2) +\n               pow(sin(dLon / 2), 2) *\n               cos(lat1) * cos(lat2);\n    double rad = 6371;\n    double c = 2 * asin(sqrt(a));\n    return rad * c;\n}\n\nint main() {\n  \n  std::ifstream fin(\"data/cities10k.txt\");\n  \n  std::string name;\n  double lat;\n  double lon;\n\n  City city;\n  std::vector<City> cities;\n\n  while(fin>>name>>lat>>lon) {\n\n    city.set_name(name);\n    city.set_lat(lat);\n    city.set_lon(lon);\n\n    cities.push_back(city); \n  }\n\n  double farest_distance = 0;\n  City city_1;\n  City city_2;\n\n  for(int i = 0; i < cities.size()-1; i++){\n    for(int j = i; j < cities.size()-1; j++){\n      double new_distance = distance(cities[i], cities[j]);\n      if(new_distance > farest_distance){\n        farest_distance = new_distance;\n        city_1 = cities[i];\n        city_2 = cities[j];\n      }\n    }\n  }\n\n  std::cout<<\"Farest cities are \"<<city_1.get_name()<<\" and \"<<city_2.get_name()<<\". And the distance between them is \"<<farest_distance<<std::endl;\n\n  return 0;\n}\n",
    "#include <ros/ros.h>\n#include <std_msgs/String.h>\n#include <geometry_msgs/Twist.h>\n\nclass RobotController\n{\npublic:\n    RobotController()\n    {\n        // Initialize the subscriber to the /gesture topic\n        gesture_sub = nh.subscribe(\"/gesture\", 10, &RobotController::gestureCallback, this);\n\n        // Initialize the publisher to the /cmd_vel topic\n        cmd_vel_pub = nh.advertise<geometry_msgs::Twist>(\"/cmd_vel\", 10);\n    }\n\n    void gestureCallback(const std_msgs::String::ConstPtr& msg)\n    {\n        ROS_INFO(\"Received Gesture: [%s]\", msg->data.c_str());\n\n        geometry_msgs::Twist vel_msg;\n        if (msg->data == \"5\")\n        {\n            ROS_INFO(\"Stopping the robot.\");\n            geometry_msgs::Twist stop_msg;\n            stop_msg.linear.x = 0.0;\n            stop_msg.angular.z = 0.0;\n            cmd_vel_pub.publish(stop_msg);\n        }\n        if (msg->data == \"good\")\n        {\n            ROS_INFO(\"Moving the robot forward.\");\n            vel_msg.linear.x = 0.3;  // Set speed to 0.5 m/s\n            vel_msg.angular.z = 0.0; // No angular velocity\n            cmd_vel_pub.publish(vel_msg);\n        }\n        else if (msg->data == \"ROCK\")\n        {\n            ROS_INFO(\"Turning the robot right.\");\n            vel_msg.linear.x = 0.0;  // No linear velocity\n            vel_msg.angular.z = -0.3; // Set angular velocity to turn right\n            cmd_vel_pub.publish(vel_msg);\n        }\n    }\n\nprivate:\n    ros::NodeHandle nh;\n    ros::Subscriber gesture_sub;\n    ros::Publisher cmd_vel_pub;\n};\n\nint main(int argc, char **argv)\n{\n    ros::init(argc, argv, \"gesture_control\");\n    RobotController robotController;\n    ros::spin();\n    return 0;\n}\n",
    "\r\n#include <iostream>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <string>\r\n#include <cmath>\r\n#include <fstream> \r\n#include <sstream> \r\n#include <cmath> \r\n\r\nusing namespace std;\r\n\r\n#define M_PI 3.14159265358979323846\r\n\r\nenum class SeatType {\r\n    ECONOMY,\r\n    BUSINESS,\r\n    FIRST_CLASS\r\n};\r\n\r\nenum class FoodOption {\r\n    VEGETARIAN,\r\n    NON_VEGETARIAN,\r\n    BOTH\r\n};\r\n\r\nclass Seat {\r\npublic:\r\n    SeatType seatType;\r\n    string seatNumber;\r\n\r\n    Seat(SeatType type, const string& number) : seatType(type), seatNumber(number) {}\r\n};\r\n\r\nclass Aircraft {\r\npublic:\r\n    string model;\r\n    size_t economySeats;\r\n    size_t businessSeats;\r\n    size_t firstClassSeats;\r\n\r\n    Aircraft(const string& mdl, size_t economy, size_t business, size_t firstClass)\r\n        : model(mdl), economySeats(economy), businessSeats(business), firstClassSeats(firstClass) {}\r\n};\r\n\r\nclass Airport {\r\npublic:\r\n    string airportCode;\r\n    string airportName;\r\n    string location;\r\n    int runway; // Changed to integer\r\n    double latitude;\r\n    double longitude;\r\n\r\n    Airport(const string& code, const string& name, const string& loc, int rw, double lat, double lon)\r\n        : airportCode(code), airportName(name), location(loc), runway(rw), latitude(lat), longitude(lon) {}\r\n\r\n};\r\n\r\nclass Flight {\r\npublic:\r\n    string flightNumber;\r\n    string departureAirport;\r\n    string destinationAirport;\r\n    string departureTime;\r\n    string departureDay;\r\n    string arrivalTime;\r\n    string arrivalDay;\r\n    Aircraft aircraft;\r\n    vector<Seat> availableSeats;\r\n    FoodOption foodOption;\r\n    unordered_map<string, Airport>& airports; \r\n\r\n    Flight(const string& number, const string& departure, const string& destination,\r\n        const string& depTime, const string& depDay, const string& arrTime, const string& arrDay,\r\n        const Aircraft& ac, FoodOption food, unordered_map<string, Airport>& airportMap)\r\n        : flightNumber(number), departureAirport(departure), destinationAirport(destination),\r\n        departureTime(depTime), departureDay(depDay), arrivalTime(arrTime), arrivalDay(arrDay),\r\n        aircraft(ac), foodOption(food), airports(airportMap) {\r\n            initializeSeats();\r\n        }\r\n\r\n    void displaySeatDetails() const {\r\n        cout << \"Seat Details for \" << flightNumber << \":\" << endl;\r\n\r\n        displaySeatDetailsByClass(SeatType::ECONOMY, \"Economy Class\");\r\n        displaySeatDetailsByClass(SeatType::BUSINESS, \"Business Class\");\r\n        displaySeatDetailsByClass(SeatType::FIRST_CLASS, \"First Class\");\r\n\r\n        cout << endl;\r\n    }\r\n\r\n    double calculateDistance() const {\r\n        // Get departure and destination airports\r\n        auto departureAirportIter = airports.find(departureAirport);\r\n        auto destinationAirportIter = airports.find(destinationAirport);\r\n\r\n        if (departureAirportIter != airports.end() && destinationAirportIter != airports.end()) {\r\n            const Airport& departureAirport = departureAirportIter->second;\r\n            const Airport& destinationAirport = destinationAirportIter->second;\r\n\r\n            // Calculate distance using Haversine formula\r\n            double distance = calculateDistance(departureAirport, destinationAirport);\r\n            return distance;\r\n        } else {\r\n            cerr << \"Error: Departure or destination airport not found.\" << endl;\r\n            return 0.0;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    void displaySeatDetailsByClass(SeatType seatClass, const string& className) const {\r\n        cout << \"   \" << className << \":\" << endl;\r\n        for (const auto& seat : availableSeats) {\r\n            if (seat.seatType == seatClass) {\r\n                cout << \"      \" << seat.seatNumber;\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    void initializeSeats() {\r\n        for (size_t i = 1; i <= aircraft.economySeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::ECONOMY, \"E\" + to_string(i)));\r\n        }\r\n\r\n        for (size_t i = 1; i <= aircraft.businessSeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::BUSINESS, \"B\" + to_string(i)));\r\n        }\r\n\r\n        for (size_t i = 1; i <= aircraft.firstClassSeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::FIRST_CLASS, \"F\" + to_string(i)));\r\n        }\r\n    }\r\n\r\n    double calculateDistance(const Airport& source, const Airport& destination) const {\r\n        // We change radian to degree\r\n        double lat1 = source.latitude * M_PI / 180.0;\r\n        double lon1 = source.longitude * M_PI / 180.0;\r\n        double lat2 = destination.latitude * M_PI / 180.0;\r\n        double lon2 = destination.longitude * M_PI / 180.0;\r\n\r\n        // Earth radius in kilometers\r\n        const double R = 6371.0;\r\n\r\n        // Haversine formula\r\n        double dlon = lon2 - lon1;\r\n        double dlat = lat2 - lat1;\r\n        double a = sin(dlat / 2) * sin(dlat / 2) + cos(lat1) * cos(lat2) * sin(dlon / 2) * sin(dlon / 2);\r\n        double c = 2 * atan2(sqrt(a), sqrt(1 - a));\r\n        double distance =",
    "#include \"Product.h\"\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\nProduct::Product()\n{\n\n}\n\nProduct::~Product()\n{\n\n}\nProduct::Product(int i,string n,float p,string b,Date e)\n{\n    id=i;\n    name=n;\n    price=p;\n    brand=b;\n    expire_date.day=e.day;\n    expire_date.month=e.month;\n    expire_date.year=e.year;\n    id_price.first=id;\n    id_price.second=price;\n    (*this).save_to_file_pro();\n    \n}\nvoid Product::set_product_id(int i){id=i;}\n\nint Product::get_product_id(){return id;}\n\nvoid Product::set_product_name(string n){name=n;}\n\nstring Product::get_product_name(){return name;}\n    \nvoid Product::set_product_price(float p){price=p;}\n\nfloat Product::get_product_price(){return price;}\n\nvoid Product::set_product_brand(string b){brand=b;}\n    \nstring Product::get_product_brand(){return brand;}\n    \n/*void Product::set_product_expire_date(Date d){expire_date=d;}\n\nDate Product::get_product_expire_date(){expire_date.print(); return expire_date;}*/\nvoid Product::save_to_file_pro()\n{\n    /*ofstream binFile(\"z.dat\", ios::binary | ios::out | ios::in);\n    binFile.write(reinterpret_cast<char*>(id_price), sizeof(id_price));\n    binFile.close();*/\n    ofstream wf(\"z.dat\", ios::out | ios::binary);\n    if(!wf) {\n        cout << \"Cannot open file!\" << endl;\n    }\n    wf.write((char *) &id_price, sizeof(id_price));\n}",
    "#include <iostream>\n#include <conio.h>\n#include <windows.h>\nusing namespace std;\n\nbool gameOver;//this variable is used to check if the game is over\nconst int width = 20;//width and height of the game\nconst int height = 20;//width and height of the game\nint x, y, fruitX, fruitY, score;//x and y are the coordinates of the head of the snake\nint tailX[100], tailY[100];//tailX and tailY are the coordinates of the tail of the snake\nint nTail;//length of the tail\n\nenum eDirecton { STOP = 0, LEFT, RIGHT, UP, DOWN };\neDirecton dir;\n//this function is used to set up the game\nvoid Setup()\n{\n    gameOver = false;\n    dir = STOP;\n    x = width / 2;\n    y = height / 2;\n    fruitX = rand() % width;\n    fruitY = rand() % height;\n    score = 0;\n}\n//this function is used to draw the game\nvoid Draw()\n{\n    system(\"cls\");//cls is used to clear the screen\n    for (int i = 0; i < width + 2; i++)\n        cout << \"#\";//# is used to print the game\n    cout << endl;//endl is used to move the cursor to the next line\n    //for loop is used to print the game\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            if (j == 0)//this if statement is used to print the game\n                cout << \"#\";\n            if (i == y && j == x)//this if statement is used to print the game\n                cout << \"@\";     // head\n            else if (i == fruitY && j == fruitX)//this if statement is used to print the game\n                cout << \"$\";         // apple\n            else\n            {\n                bool print = false;//this variable is used to print the game\n                for (int k = 0; k < nTail; k++)//for loop is used to print the game\n                {\n                    if (tailX[k] == j && tailY[k] == i)//this if statement is used to print the game\n                    {\n                        cout << \"^\"; print = true; // body\n                    }\n                }\n                if (!print) cout << \" \";//this if statement is used to print the game\n\n            }\n\n            if (j == width - 1)//this if statement is used to print the game\n                cout << \"#\";\n        }\n        cout << endl;\n    }\n\n    for (int i = 0; i < width + 2; i++)//this for loop is used to print the game\n        cout << \"#\";//# is used to print the game\n    cout << endl;\n    cout << \"Score:\" << score << endl;//this cout statement is used to print the game\n}\n//this function is used to take input from the user\nvoid Input()\n{\n    if (_kbhit())\n    {\n        switch (_getch())//this switch statement is used to take input from the user\n        {\n        case 'a' ://this case statement is used to take input from the user\n            dir = LEFT;\n            break;\n        case 'd'://this case statement is used to take input from the user\n            dir = RIGHT;\n            break;\n        case 'w'://this case statement is used to take input from the user\n            dir = UP;\n            break;\n        case 's'://this case statement is used to take input from the user\n            dir = DOWN;\n            break;\n        case 'x'://this case statement is used to take input from the user\n            gameOver = true;\n            break;\n        }\n    }\n}\n//this function is used to move the snake\nvoid algorithm()\n{\n    int prevX = tailX[0];\n    int prevY = tailY[0];\n    int prev2X, prev2Y;\n    tailX[0] = x;\n    tailY[0] = y;\n    for (int i = 1; i < nTail; i++)\n    {\n        prev2X = tailX[i];\n        prev2Y = tailY[i];\n        tailX[i] = prevX;\n        tailY[i] = prevY;\n        prevX = prev2X;\n        prevY = prev2Y;\n    }\n\n    switch (dir)\n    {\n    case LEFT:\n        x--;\n        break;\n    case RIGHT:\n        x++;\n        break;\n    case UP:\n        y--;\n        break;\n    case DOWN:\n        y++;\n        break;\n    default:\n        break;\n    }\n    if (x >= width)\n        x = 0; else if (x < 0) x = width - 1;\n    if (y >= height)\n        y = 0; else if (y < 0) y = height - 1;\n\n    for (int i = 0; i < nTail; i++)\n        if (tailX[i] == x && tailY[i] == y)\n            gameOver = true;\n\n    if (x == fruitX && y == fruitY)\n    {\n        score += 10;\n        fruitX = rand() % width;\n        fruitY = rand() % height;\n        nTail++;\n    }\n}\n//pragrammin in start\nint main()\n{\n    Setup();//this function is used to set up the game\n    while (!gameOver)\n    {\n        Draw();//this function is used to draw the game\n        Input();//this function is used to take input from the user\n        algorithm();//this function is used to move the snake\n        Sleep(40); // Adding a delay to slow down the snake's movement\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"e_commerce_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"network.hpp\"\r\n#include \"trace.hpp\"\r\n\r\nvoid network::block_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = out program = \" + process + \"  action = block\";\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = in program = \" + process + \"  action = block\";\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::unblock_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = out program = \" + process;\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = in program = \" + process;\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::setup()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tblock_connection(fivem_path);\r\n\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\t\r\n\t\tblock_connection(steam_process);\r\n\t}\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tblock_connection(steam_process);\r\n\r\n}\r\n\r\n\r\nvoid network::destroy()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tunblock_connection(fivem_path);\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tunblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tunblock_connection(steam_process);\r\n\t}\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"pch.h\"\r\n\r\n#include \"ntwdblib.h\"\r\n#include <WinSock2.h>\r\n#include <nb30.h>\r\n\r\n//#include <excpt.h>\r\n\r\n#pragma warning (disable : 4996)\r\n#pragma comment(lib, \"Netapi32.lib\")\r\n\r\n#define  DBCURSOR  cursor_t   // cursor record type\r\n#define  DBHANDLE  void   // generic handle\r\n\r\nLPSTR __cdecl GetConnectionError(PDBPROCESS dbproc, int* lpErr, char** a3);\r\nBOOL __stdcall FreeMemory(PDBPROCESS dbproc, LPVOID lpMem);\r\nint __stdcall GeneralError(PDBPROCESS dbproc, int dbErrCode);\r\nLPVOID __stdcall AllocateHeapMemory(int op, PDBPROCESS dbproc, size_t dwBytes, int zero);\r\nchar* __stdcall dberrstr(unsigned __int16 dbErrCode);\r\nBOOL __stdcall LibMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);\r\nvoid __stdcall tidyproc(PDBPROCESS dbproc);\r\nvoid __stdcall free_rowbuffer(PDBPROCESS dbproc);\r\nint __stdcall CheckEntry(PDBPROCESS dbproc);\r\nretval_t* __stdcall ReturnRequestedRetval(PDBPROCESS dbproc, int length);\r\nBOOL __cdecl ConvertNumericDecimalToDouble(DBNUMERIC* Src, double* lpValue);\r\nint __stdcall bcpRead(PDBPROCESS dbproc, bcp_t* bcp, size_t Size, void* lpBuffer);\r\nint __stdcall bcpInsert(PDBPROCESS dbproc);\r\nint __stdcall bcpLengthConversion(char type, int length, char usertype, int direction);\r\nchar* __stdcall CursorWriteBuf(PDBPROCESS dbproc, int ColumnType, int length, void* Src);\r\nint __cdecl PrepareFullName(PDBPROCESS dbproc, bcp_info_t* bcpinfo, int b);\r\nint __cdecl bcpCmd(PDBPROCESS dbproc, const char* Src, ...);\r\nint __stdcall CursorBuildKeysetSelect(DBCURSOR* hcursor);\r\nint __stdcall CursorVerify(DBCURSOR* cursor, PDBPROCESS dbproc);\r\nint __cdecl InitLocal(HINSTANCE hInstance);\r\nvoid __cdecl clntcomn_init();\r\nvoid __cdecl clntcomn_cleanup();\r\n// Netapi32.lib\r\n\r\n\r\nBYTE ver60[] = { 6,0,0,0,0,0,0,0 };\r\nSecEntry g_SecEntrys = { (DBPROCESS* )-1 ,0,0};\r\nDWORD TlsErrIndex = -1;\r\nHANDLE hGlobalHeap = 0;\r\nint g_fSSPIInit = 0;\r\nchar null_string[4] = { 0 };\r\nint bDtm = 0;\r\nshort UsDefaultTimeFlags = 0;\r\nshort UsDefaultMnyFlags = 0;\r\nHINSTANCE DbHandle = 0;\r\nint DbTimeOut = 0;\r\nPDBPROCESS* DbProcArray = 0;\r\nDBERRHANDLE_PROC DbErrHandler = 0;\r\nDBMSGHANDLE_PROC DbMsgHandler = 0;\r\nPDBPROCESS validdbproc = 0;\r\nshort word_7335B844 = 0;\r\nchar byte_7335B848[32] = { 0 };\r\nLPCVOID pMemMap = 0;\r\nint debug_no_entry = 0;\r\nCRITICAL_SECTION CriticalSection = { 0 };\r\nHKEY hKey = 0;\r\nPSecurityFunctionTableA g_pSecFunctionTable = 0;\r\nCRITICAL_SECTION sspiSection = { 0 };\r\nHMODULE hModule = 0;\r\nDTC_GET_TRANSACTION_MANAGER fnGetTranMan = 0;\r\nCRITICAL_SECTION ErrSem = { 0 };\r\nCRITICAL_SECTION MsgSem = { 0 };\r\nchar DeciSep[8] = { 0 };\r\nchar SMonths[12][7] = {0};\r\nchar byte_7335B954[12] = { 0 };\r\nCRITICAL_SECTION OptionSem = { 0 };\r\nCRITICAL_SECTION bcpCmdSem = { 0 };\r\nint UseClientCursors = 0;\r\nCRITICAL_SECTION DbProcSem = { 0 };\r\nchar ThouSep[8] = { 0 };\r\nchar MnySign[32] = { 0 };\r\nCRITICAL_SECTION UseSem = { 0 };\r\n__int16 DTM_FORMAT = 0;\r\nDWORD DataReadySleep = 0;\r\n__int16 DefaultTimeFlags = 0;\r\nchar DefaultThouSep[32] = { 0 };\r\nchar TimeSep[32] = { 0 };\r\nchar szCol[32] = { 0 };\r\nchar DateSep[32] = { 0 };\r\nchar szSkip[32] = { 0 };\r\nchar TimeStrAm[32] = { 0 };\r\nchar DefaultSMonthsFE[13][7] = {0};\r\nchar DefaultDeciSep[32] = { 0 };\r\n__int16 DefaultMnyFlags = 0;\r\nchar szRow[32] = { 0 };\r\nchar DefaultSMonths[13][7] = { 0 };\r\nchar TimeStrPm[32] = { 0 };\r\n__int16 DefaultDateFlags = 0;\r\nchar DefaultMnySign[32] = { 0 };\r\nint fNTIsRunning = 0;\r\nULONG g_cbMaxToken = 0;\r\n\r\nchar ProgVersion[] = { 1,2,0,0,0};\r\n\r\nBYTE moneys[] = {2, 3, 0, 1};\r\nint mnyradix[] = { 10000, 1000, 100, 10, 0 };\r\nchar DblibName[] = \"MSDBLIB\";\r\nchar TdsVer[] = { 4,2,0,0 };\r\nchar dbon[] = \" on \";\r\nchar dboff[] = \" off \";\r\nint MonthDay[] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 366 };\r\nchar DefaultUsSMonths[][6] = { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\r\nchar DefaultUsSMonthsFE[][6] = { \"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\" };\r\nchar UsDefaultDateFlags[] = \"J\";\r\nchar UsDefaultMnySign[] = \"$\";\r\nchar UsDefaultDeciSep[] = \".\";\r\nchar UsDefaultThouSep[] = \",\";\r\nint ArC[] = { 6,3,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };\r\nint ArB[] = { 6,9,2,7,6,9,4,9,2,4,0,0,0,0,0,0,0,0,0 };\r\nint ArA[] = { 6,5,6,0,1,7,6,7,9,4,7,4,1,8,2,0,0,0,0 };\r\nchar Offsets[][10] = {\"select\",\"from\",\"table\",\"order\",\"compute\",\"statement\",\"procedure\",\"execute\",\"param\"};\r\nchar ConvertArray[256] = {\r\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1\r\n};\r\noption_t OptionDict[] = {\r\n\t{   0, 0x11, (char*)\"\",           0,      0},\r\n\t{   1,    9, (char*)\"offse",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"news_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Interpolation.hpp\"\n#include \"Angle.hpp\"\n#include <cmath>\n\nusing namespace gf;\n\nfloat easing::linear(float t)\n{\n    return t;\n}\n\nfloat easing::in_quad(float t)\n{\n    return t * t;\n}\n\nfloat easing::out_quad(float t)\n{\n    return t * (2 - t);\n}\n\nfloat easing::in_out_quad(float t)\n{\n    if (t < 0.5f)\n    {\n        return 2 * t * t;\n    }\n    else\n    {\n        return -1 + (4 - 2 * t) * t;\n    }\n}\n\nfloat easing::in_cubic(float t)\n{\n    return t * t * t;\n}\n\nfloat easing::out_cubic(float t)\n{\n    return (--t) * t * t + 1;\n}\n\nfloat easing::in_out_cubic(float t)\n{\n    if (t < 0.5f)\n    {\n        return 4 * t * t * t;\n    }\n    else\n    {\n        return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n    }\n}\n\nfloat easing::in_quart(float t)\n{\n    return t * t * t * t;\n}\n\nfloat easing::out_quart(float t)\n{\n    return 1 - (--t) * t * t * t;\n}\n\nfloat easing::in_out_quart(float t)\n{\n    if (t < 0.5f)\n    {\n        return 8 * t * t * t * t;\n    }\n    else\n    {\n        return 1 - 8 * (--t) * t * t * t;\n    }\n}\n\nfloat easing::in_quint(float t)\n{\n    return t * t * t * t * t;\n}\n\nfloat easing::out_quint(float t)\n{\n    return 1 + (--t) * t * t * t * t;\n}\n\nfloat easing::in_out_quint(float t)\n{\n    if (t < 0.5f)\n    {\n        return 16 * t * t * t * t * t;\n    }\n    else\n    {\n        return 1 + 16 * (--t) * t * t * t * t;\n    }\n}\n\nfloat easing::in_sine(float t)\n{\n    return 1 - std::cos(t * M_PI * 2);\n}\n\nfloat easing::out_sine(float t)\n{\n    return std::sin(t * M_PI / 2);\n}\n\nfloat easing::in_out_sine(float t)\n{\n    return 0.5f * (1 - std::cos(t * M_PI));\n}\n\nfloat easing::in_expo(float t)\n{\n    return static_cast<float>((t == 0) ? 0 : std::pow(2, 10 * (t - 1)));\n}\n\nfloat easing::out_expo(float t)\n{\n    return static_cast<float>((t == 1) ? 1 : 1 - std::pow(2, -10 * t));\n}\n\nfloat easing::in_out_expo(float t)\n{\n    if (t == 0)\n    {\n        return 0;\n    }\n    if (t == 1)\n    {\n        return 1;\n    }\n    if (t < 0.5f)\n    {\n        return static_cast<float>(0.5f * std::pow(2, 20 * t - 10));\n    }\n    else\n    {\n        return static_cast<float>(1 - 0.5f * std::pow(2, -20 * t + 10));\n    }\n}\n\nfloat easing::in_circ(float t)\n{\n    return 1 - std::sqrt(1 - t * t);\n}\n\nfloat easing::out_circ(float t)\n{\n    return std::sqrt((2 - t) * t);\n}\n\nfloat easing::in_out_circ(float t)\n{\n    if (t < 0.5f)\n    {\n        return 0.5f * (1 - std::sqrt(1 - 4 * t * t));\n    }\n    else\n    {\n        return 0.5f * (std::sqrt(-((2 * t - 3) * (2 * t - 1))) + 1);\n    }\n}\n\n",
    "#include<iostream>\nusing namespace std;\n\nint main()\n{\n    // forca = guarda a palavra secreta,letra = guardar a letra que o usu\u00e1rio digitar, paDesv = medir palavra de acordo qu\u00ea foi desvendada \n    // tamanho =  armazenar o tamanho , chances = quantas chances o usu\u00e1rio vai ter , acertos = acertos do usu\u00e1rio\n    //Vari\u00e1vel bool para verificar se a letra \u00e9 a certa ou nao\n    char forca[30], letra[1], paDesv[30];\n    int tamanho, chances, acertos;\n    bool acerto = false;\n    // inicializar minhas vari\u00e1veis (tam, chances e acertos)\n\n    tamanho = 0;\n    chances = 5;\n    acertos = 0;\n\n    cout << \"           \" << \"=====================\" << endl;\n    cout << \"               \" << \"JOGO DA FORCA\" << endl;\n    cout << \"           \" << \"=====================\";\n\n    // pedir ao usu\u00e1rio para digitar uma palavra e usando system para limpar a palavra digitada para que o outro usu\u00e1rio n\u00e3o veja.\n    cout << endl << \" digite a palavra secreta: \";\n    cin >> forca;\n\n    system(\"cls\");\n\n\n    //obter o tamanho da palavra\n    for (int i = 0; forca[i] != '\\0'; i++) {\n        tamanho++;\n    }\n\n    // preencher meu vetor secreto (paDesv)\n    for (int i = 0; i < 30; i++) {\n        paDesv[i] = '-';\n    }\n\n    //informa\u00e7\u00f5es do jogo, verificar se o usu\u00e1rio acertou ou n\u00e3o.\n\n    while (chances > 0 && (acertos < tamanho)) {\n        system(\"cls\");\n\n\n        cout << \"chances restantes : \" << chances << endl;\n        cout << \"palavra secreta: \";\n\n        for (int i = 0; i < tamanho; i++) {\n            cout << paDesv[i];\n        }\n        acerto = false;\n        cout << endl;\n\n        cout << \"digite uma letra: \";\n        cin >> letra[0];\n\n        for (int i = 0; i < tamanho; i++) {\n            if (forca[i] == letra[0]) {\n                acerto = true;\n                paDesv[i] = forca[i];\n                acertos++;\n            }\n        }\n        // verificar se houve acerto ou n\u00e3o, se n houver diminuio as chances\n\n        if (!acerto) {\n            chances--;\n        }\n\n    }\n\n    acerto = false;\n    system(\"cls\");\n\n    if (acertos == tamanho) {\n        cout << \"parabens voce ganhou!!!\";\n    }\n    else {\n        cout << \"chances perdida, voce perdeu!\";\n    }\n\n    return 0;\n}\n",
    "/****************************************************************************************************\n  @file robotMotor.h\n  @brief Servo Motor control class utilizing pwm module\n  @author Jeremy Reynolds <62484970+jeremy-reynolds@users.noreply.github.com>\n  @version 1.0.0\n  @date 2024/03/30\n\n  @details\n  robotMotor is a simple class written in Arduino IDE to manage servo motors for a simple robotic arm \n  application. The code utilizes a PCA9685 16ch PWM module with an I2C connection using the library \n  from Adafruit called PWMServoDriver.h.  This library allows for non blocking movements of the Servo\n  motors for smoother control.\n\n  version 1.0.0 - initial version\n  \n  # LICENSE #\n  \n  MIT License\n\n  Copyright (c) 2024 dolphin-tiger\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n****************************************************************************************************/\n#include \"robotMotor.h\"\n#include <Arduino.h>\n\n#define MIN_PULSE_WIDTH       480   //650\n#define MAX_PULSE_WIDTH       2400  //2350\n#define DEFAULT_PULSE_WIDTH   1465\n#define FREQUENCY             50\n\n  robotMotor::robotMotor() {\n\n  }\n\n  int pulseWidth(int angle)\n  {\n    int pulse_wide, analog_value;\n    pulse_wide   = map(angle, 0, 180, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);\n    analog_value = int(float(pulse_wide) / 1000000 * FREQUENCY * 4096);\n    return analog_value;\n  }\n\n  void robotMotor::attach(int i2c, int ch){\n    i2cAddress = i2c;\n    motorID = ch;\n\n    position = centerPosition;\n\n    svo = Adafruit_PWMServoDriver(i2cAddress); //redefine the object if this works?\n    svo.begin();\n    svo.setPWMFreq(FREQUENCY);  // Analog servos run at ~60 Hz updates\n    svo.setPWM(motorID, 0, pulseWidth(position));\n  }\n\n\n  //-- move methods ---------------------------------------------------------------------------\n  void robotMotor::moveInc(int val) {\n    int tempPosition = position + val;\n    if      ( tempPosition > maxPosition) { position = maxPosition;}\n    else if ( tempPosition < minPosition) { position = minPosition;}\n    else                                  { position = tempPosition;}\n    svo.setPWM(motorID, 0, pulseWidth(position));  \n  }\n\n  void robotMotor::setPosition(int pos) {\n    int tempPosition = pos;\n    if      (tempPosition > maxPosition)  { position = maxPosition; }\n    else if (tempPosition < minPosition)  { position = minPosition; }\n    else                                  { position = tempPosition;}\n    svo.setPWM(motorID, 0, pulseWidth(position));\n  }\n  \n  int robotMotor::getPosition() {\n    if      (position > maxPosition)      { position = maxPosition; }\n    else if (position < minPosition)      { position = minPosition; }\n    else                                  { position = position;    }\n    return position;\n  }\n\n  //-- center postion methods -----------------------------------------------------------------\n  void robotMotor::setCenterPosition(int pos){\n    int tempPosition = pos;\n    if      (pos > maxPosition)           { centerPosition = maxPosition; }\n    else if (pos < minPosition)           { centerPosition = minPosition; }\n    else                                  { centerPosition = pos;}\n  }\n  int robotMotor::getCenterPosition() {\n    return centerPosition;\n  }\n\n  //-- minimum position methods ---------------------------------------------------------------\n  void robotMotor::setMinPosition(int pos){\n    int tempPosition = pos;\n    if      (pos > maxPosition)           { }\n    else                                  { minPosition = pos; }\n  }\n\n  int robotMotor::getMinPosition() {\n    return minPosition;\n  }\n\n  //-- maximum position methods ---------------------------------------------------------------\n  void robotMotor::setMaxPosition(int pos){\n    int tempPosition = pos;\n    if      (pos < minPosition)           { }\n    else                                  { maxPosition = pos; }\n  }\n\n  int robotMotor::getMaxPosition() {\n    return maxPosition;\n  }\n\n  //-- other methods -------------------------------------------",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// ------------------------------------------------------------------------\n// ClickEncoderInterface.cpp\n//\n// Nov. 2022\n// Ryan \"Ratimus\" Richardson\n// ------------------------------------------------------------------------\n#include \"ClickEncoderInterface.h\"\n\n// Constructor\nClickEncoderInterface :: ClickEncoderInterface(ClickEncoder &rEnc, int sense):\n  enc(rEnc),\n  sensivity(sense)\n{\n  pos      = 0;\n  oldPos   = pos;\n  update();\n}\n\nencEvnts ClickEncoderInterface :: getEvent(void)\n{\n  static bool heldClicked(0);\n  ButtonState prevState = btnState;\n\n  update();\n\n  if (pos != oldPos)\n  {\n    int d = pos - oldPos;\n\n    if (d <= -sensivity)                 // Right Click\n    {\n      oldPos -= sensivity;\n      if (btnState == ButtonState::Held) // Hold+Turn\n      {\n        heldClicked = 1;\n        return encEvnts::ShiftRight;\n      }\n      return encEvnts::Right;\n    }\n    else if (d >= sensivity)             // Left Click\n    {\n      oldPos += sensivity;\n      if (btnState == ButtonState::Held) // Hold+Turn\n      {\n        heldClicked = 1;\n        return encEvnts::ShiftLeft;\n      }\n\n      return encEvnts::Left;\n    }\n  }\n\n  if (prevState != btnState)\n  {\n    if (btnState == ButtonState::Open)\n    {\n      if (prevState == ButtonState::Clicked)\n      {\n        return encEvnts::Click;\n      }\n\n      if (prevState == ButtonState::DoubleClicked)\n      {\n        return encEvnts::DblClick;\n      }\n\n      if (prevState == ButtonState::ClickedAndHeld)\n      {\n        return encEvnts::ClickHold;\n      }\n\n      if (!heldClicked)\n      {\n        if (prevState == ButtonState::Pressed)\n        {\n          return encEvnts::Press;\n        }\n\n        return encEvnts::Hold;\n      }\n      else\n      {\n        heldClicked = 0;\n      }\n    }\n  }\n\n  return encEvnts::NUM_ENC_EVNTS;\n}\n// ButtonStates you may see in the wild:\n//  Open\n//  Clicked\n//  DoubleClicked\n//  ClickedAndHeld\n//  Held\n//  Pressed (this one's rare--you're lucky if you spot him!)\n//     [You'll need to give the user feedback when this state is entered if you're going to use it,\n//     [else they're almost guaranteed to blow past it into the HELD state\n//\n// ButtonStates that are extinct in the wild and exist only in captivity:\n//  Closed\n//  Released",
    "#include <iostream>\n\n\nint main(){\n\n\t//Declare pointer and reference\n\n    double double_value {12.34};\n    double& ref_double_value {double_value}; // Reference to double_value\n    double* p_double_value {&double_value}; //Pointer to double_value\n\t\n\t//Reading\n\tstd::cout << \"double_value : \" << double_value << std::endl;\n\tstd::cout << \"ref_double_value : \" << ref_double_value << std::endl;\n\tstd::cout << \"p_double_value : \" << p_double_value << std::endl;\n\tstd::cout << \"*p_double_value : \" << *p_double_value << std::endl;\n\t\n\t//Writting through pointer\n\t*p_double_value = 15.44;\n\t\n    std::cout << std::endl;\n\tstd::cout << \"double_value : \" << double_value << std::endl;\n\tstd::cout << \"ref_double_value : \" << ref_double_value << std::endl;\n\tstd::cout << \"p_double_value : \" << p_double_value << std::endl;\n\tstd::cout << \"*p_double_value : \" << *p_double_value << std::endl;\n\t\n\t//Writting through reference\n\tref_double_value = 18.44;\n\t\n    std::cout << std::endl;\n\tstd::cout << \"double_value : \" << double_value << std::endl;\n\tstd::cout << \"ref_double_value : \" << ref_double_value << std::endl;\n\tstd::cout << \"p_double_value : \" << p_double_value << std::endl;\n\tstd::cout << \"*p_double_value : \" << *p_double_value << std::endl;\n\n\n    double some_other_double{78.45};\n\n    //Make the reference reference something else.\n    ref_double_value = some_other_double;\n\n    std::cout << \"Making the reference reference something else...\" << std::endl;\n    std::cout << std::endl;\n\tstd::cout << \"double_value : \" << double_value << std::endl;\n\tstd::cout << \"ref_double_value : \" << ref_double_value << std::endl;\n\tstd::cout << \"p_double_value : \" << p_double_value << std::endl;\n\tstd::cout << \"*p_double_value : \" << *p_double_value << std::endl;\n\n\n\n    //Make the pointer point to something else\n    p_double_value = &some_other_double;\n    std::cout << \"Making the pointer point somewhere else...\" << std::endl;\n    std::cout << std::endl;\n\tstd::cout << \"double_value : \" << double_value << std::endl;\n\tstd::cout << \"ref_double_value : \" << ref_double_value << std::endl;\n    std::cout << \"&double_value : \" << &double_value << std::endl;\n    std::cout << \"&ref_double_value : \" << &ref_double_value << std::endl;\n\tstd::cout << \"p_double_value : \" << p_double_value << std::endl;\n\tstd::cout << \"*p_double_value : \" << *p_double_value << std::endl;\n\n\n    *p_double_value = 555.5;\n\n    std::cout << std::endl;\n\tstd::cout << \"double_value : \" << double_value << std::endl;\n\tstd::cout << \"ref_double_value : \" << ref_double_value << std::endl;\n    std::cout << \"&double_value : \" << &double_value << std::endl;\n    std::cout << \"&ref_double_value : \" << &ref_double_value << std::endl;\n\tstd::cout << \"p_double_value : \" << p_double_value << std::endl;\n\tstd::cout << \"*p_double_value : \" << *p_double_value << std::endl;\n   \n    return 0;\n}",
    "#include \"framework/Application.h\"\n#include \"framework/Core.h\"\n#include \"framework/World.h\"\n#include \"framework/AssetManager.h\"\n#include \"framework/PhysicsSystem.h\"\n\nnamespace ss\n{\n\tApplication::Application(unsigned int windowWidth, unsigned int windowHeight, const std::string& title, sf::Uint32 style)\n\t\t: mWindow{ sf::VideoMode(windowWidth, windowHeight), title, style },\n\t\tmTargetFrameRate{ 60.f },\n\t\tmTickClock{},\n\t\tcurrentWorld{ nullptr },\n\t\tmCleanCycleClock{},\n\t\tmCleanCycleInterval{ 2.f }\n\t{\n\t}\n\n\tvoid Application::Run()\n\t{\n\t\tmTickClock.restart();\n\t\tfloat accumulatedTime = 0.f;\n\t\tfloat targetDeltaTime = 1.f / mTargetFrameRate;\n\n\t\t//If Event is close, close the window\n\t\twhile (mWindow.isOpen())\n\t\t{\n\t\t\tsf::Event windowEvent;\n\n\t\t\twhile (mWindow.pollEvent(windowEvent))\n\t\t\t{\n\t\t\t\tif (windowEvent.type == sf::Event::EventType::Closed())\n\t\t\t\t{\n\t\t\t\t\tmWindow.close();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfloat frameDeltaTime = mTickClock.restart().asSeconds();\n\t\t\taccumulatedTime += frameDeltaTime;\n\n\t\t\twhile (accumulatedTime > targetDeltaTime)\n\t\t\t{\n\t\t\t\taccumulatedTime -= targetDeltaTime;\n\t\t\t\tTickInternal(targetDeltaTime);\n\t\t\t\tRenderInternal();\n\t\t\t}\n\t\t}\n\t}\n\n\tsf::Vector2u Application::GetWindowSize() const\n\t{\n\t\treturn mWindow.getSize();\n\t}\n\n\tvoid Application::TickInternal(float deltaTime)\n\t{\n\t\t//Execute Tick on the top level first then TickInternal of the currentWorld\n\t\t//First tick if player input, after what game logic is updated\n\t\tTick(deltaTime);\n\n\t\tif (currentWorld)\n\t\t{\n\t\t\t//currentWorld->BeginPlayInternal(); //Transfered to be calleed only at the begining (LoadWorld()). May not work when changing level?\n\t\t\tcurrentWorld->TickInternal(deltaTime);\n\t\t}\n\n\t\tPhysicsSystem::Get().Step(deltaTime); //Physics system update\n\n\t\tif (mCleanCycleClock.getElapsedTime().asSeconds() >= mCleanCycleInterval)\n\t\t{\n\t\t\tmCleanCycleClock.restart();\n\t\t\tAssetManager::Get().CleanCycle();\n\n\t\t\tif (currentWorld)\n\t\t\t{\n\t\t\t\tcurrentWorld->CleanCycle();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Application::RenderInternal()\n\t{\n\t\tmWindow.clear();\n\n\t\tRender();\n\n\t\tmWindow.display();\n\t}\n\n\tvoid Application::Render()\n\t{\n\t\tif (currentWorld)\n\t\t{\n\t\t\tcurrentWorld->Render(mWindow);\n\t\t}\n\t}\n\n\tvoid Application::Tick(float deltaTime)\n\t{\n\t}\n}\n",
    "// Licensed under GPL 3.0 -- full license text in file LICENSE\n#include \"mkproj.hpp\"\n#include \"gitignores.hpp\"\n#include \"string_utils.hpp\"\n#include \"hello_world.hpp\"\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <sys/stat.h>\n#include <fstream>\n\n\nint python(const std::string name, const bool welcome_script)\n{\n    std::string version;\n\n    std::cout << \"Python version (major.minor without patch or type nothing for global python): \";\n    std::getline(std::cin, version);\n\n    std::cout << info << \"Making venv (.env).\\n\";\n    std::cout << info << \"Hint -- to activate venv run \\n\";\n    std::cout << \\\n    \"    -> `source .env/bin/activate` for bash; or `source .env/bin/activate.[fish or csh] for fish or csh`\" << std::endl;\n    \n    const int retcode = system((\"/usr/bin/env python\" + version + \" -m venv .env\").c_str()); // python env\n    if (retcode != 0) {\n        std::cerr << error << \"Failed create python venv!\" << std::endl;\n        return 2;\n    }\n\n    std::ofstream requirements(\"requirements.txt\");\n    if (requirements) {\n        requirements.close();\n    } else {\n        std::cerr << warning << \"failed to open file \\\"requirements.txt\\\"\" << std::endl;\n    }\n\n    if (welcome_script) {\n        std::cout << info << \"Writing welcome script...\" << std::endl;\n        std::ofstream main_py(\"main.py\");\n            if (!main_py) {\n            std::cerr << warning << \"failed to open file \\\"main.py\\\"\" << std::endl;\n        } else {\n            main_py << python_hello_world;\n            main_py.close();\n        }\n    }\n\n    std::cout << info << \"Writing .gitignore...\" << std::endl;\n    std::ofstream gitignore(\".gitignore\");\n    if (gitignore) {\n        gitignore << python_gitignore_template;\n        gitignore.close();\n    } else {\n        std::cerr << error << \"Failed to open file \\\".gitignore\\\"!\" << std::endl; return 1;\n    }\n    if (!version.empty()) {\n        std::cout << green << \"MkProj for Python \" << version << \" success.\" << reset << std::endl;\n    } else {\n        std::cout << green <<  \"MkProj for Python success.\" << reset << std::endl;\n    }\n    return 0;\n}\n\nint cpp(const std::string name, const bool welcome_script)\n{\n    \n    if (welcome_script) {\n        std::cout << info << \"Writing welcome script...\" << std::endl;\n        std::ofstream main_cpp(\"main.cpp\");\n        if (main_cpp) {\n            main_cpp << cpp_hello_world;\n            main_cpp.close();\n        } else {\n            std::cerr << error << \"Failed to open file \\\"main.cpp\\\".\\nNot critical -- continue\" << std::endl;\n        }\n    }\n\n    std::cout << info << \"Writing .gitignore...\" << std::endl;\n    std::ofstream gitignore(\".gitignore\");\n    if (gitignore) {\n        gitignore << cpp_gitignore_template;\n        gitignore.close();\n    } else {\n        std::cerr << error <<\"Failed to open file \\\".gitignore\\\"!\" << std::endl;\n        return 1;\n    }\n\n    std::cout << green << \"MkProj for C++ success.\" << reset << std::endl;\n    return 0;\n}\n\nint c(const std::string name, const bool welcome_script)\n{\n    if (welcome_script) {\n        std::cout << \":: Writing welcome script...\" << std::endl;\n        std::ofstream main_c(\"main.c\");\n        if (main_c) {\n        main_c << c_hello_world;\n        main_c.close();\n        } else {\n            std::cerr << error << \"Failed to open file \\\"main.c\\\"\" << std::endl;\n        }\n    }\n\n    std::cout << info << \"Writing .gitignore...\" << std::endl;\n    std::ofstream gitignore(\".gitignore\");\n    if (gitignore) {\n        gitignore << c_gitignore_template;\n        gitignore.close();\n    } else {\n        std::cerr << error << \"Failed to open file \\\".gitignore\\\"!\" << std::endl;\n        return 1;\n    }\n\n    std::cout << green << \"MkProj for C success.\" << reset << std::endl;\n    return 0;\n}\n",
    "#include \"..\\..\\main\\main.h\"\r\n\r\nvoid Console::SetinfoStealer::AddressConversion_AndPrint(std::string& address)\r\n{\r\n    if (address.empty())\r\n        return;\r\n\r\n    size_t pos = 0;\r\n    int backslash_count = 0;\r\n\r\n    while ((pos = address.find(\"\\\\\", pos)) != std::string::npos)\r\n    {\r\n        if (backslash_count % 2 == 0) address.replace(pos, 1, \"\\n\");\r\n        else                          address.replace(pos, 1, \" \");\r\n\r\n        pos += 2;\r\n        backslash_count++;\r\n    }\r\n\r\n    g_Console.PrintColor(cvar.visuals.color_gameconsole.ordinary_text[0] * 255, cvar.visuals.color_gameconsole.ordinary_text[1] * 255, cvar.visuals.color_gameconsole.ordinary_text[2] * 255, address.c_str());\r\n    g_pConsole->DPrintf(\"\\n\");\r\n}\r\n\r\nvoid Console::SetinfoStealer::Run()\r\n{\r\n    if (!cvar.console.other.key_write_console) \r\n        return;\r\n\r\n    std::string Crypt_hw_dll;\r\n    Crypt_hw_dll = skCrypt(\"hw.dll\");\r\n\r\n    DWORD hw = (DWORD)GetModuleHandle(Crypt_hw_dll.c_str());\r\n\r\n    g_Console.PrintColor(cvar.visuals.color_gameconsole.main_text[0] * 255, cvar.visuals.color_gameconsole.main_text[1] * 255, cvar.visuals.color_gameconsole.main_text[2] * 255, Language::GetString(skCrypt(\"\\nOutput almost all setinfo players that were currently on the server\\n\"), skCrypt(u8\"\\n\u00c2\u00fb\u00e2\u00ee\u00e4 \u00ef\u00ee\u00f7\u00f2\u00e8 \u00e2\u00f1\u00e5\u00f5 setinfo \u00e8\u00e3\u00f0\u00ee\u00ea\u00ee\u00e2 \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e5 \u00e2 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e9 \u00ec\u00ee\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e0 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e5:\\n\"));\r\n\r\n    auto offset_key1 = 0x12043CC;\r\n    auto offset_key2 = 0x12043CC + 0x250;\r\n    auto offset_key3 = 0x12043CC + (0x250 * 2);\r\n    auto offset_key4 = 0x12043CC + (0x250 * 3);\r\n    auto offset_key5 = 0x12043CC + (0x250 * 4);\r\n    auto offset_key6 = 0x12043CC + (0x250 * 5);\r\n    auto offset_key7 = 0x12043CC + (0x250 * 6);\r\n    auto offset_key8 = 0x12043CC + (0x250 * 7);\r\n    auto offset_key9 = 0x12043CC + (0x250 * 8);\r\n    auto offset_key10 = 0x12043CC + (0x250 * 9);\r\n    auto offset_key11 = 0x12043CC + (0x250 * 10);\r\n    auto offset_key12 = 0x12043CC + (0x250 * 11);\r\n    auto offset_key13 = 0x12043CC + (0x250 * 12);\r\n    auto offset_key14 = 0x12043CC + (0x250 * 13);\r\n    auto offset_key15 = 0x12043CC + (0x250 * 14);\r\n    auto offset_key16 = 0x12043CC + (0x250 * 15);\r\n    auto offset_key17 = 0x12043CC + (0x250 * 16);\r\n    auto offset_key18 = 0x12043CC + (0x250 * 17);\r\n    auto offset_key19 = 0x12043CC + (0x250 * 18);\r\n    auto offset_key20 = 0x12043CC + (0x250 * 19);\r\n    auto offset_key21 = 0x12043CC + (0x250 * 20);\r\n    auto offset_key22 = 0x12043CC + (0x250 * 21);\r\n    auto offset_key23 = 0x12043CC + (0x250 * 22);\r\n    auto offset_key24 = 0x12043CC + (0x250 * 23);\r\n    auto offset_key25 = 0x12043CC + (0x250 * 24);\r\n    auto offset_key26 = 0x12043CC + (0x250 * 25);\r\n    auto offset_key27 = 0x12043CC + (0x250 * 26);\r\n    auto offset_key28 = 0x12043CC + (0x250 * 27);\r\n    auto offset_key29 = 0x12043CC + (0x250 * 28);\r\n    auto offset_key30 = 0x12043CC + (0x250 * 29);\r\n    auto offset_key31 = 0x12043CC + (0x250 * 30);\r\n    auto offset_key32 = 0x12043CC + (0x250 * 31);\r\n\r\n    std::vector<std::string> key_strings;\r\n\r\n    for (int i = 0; i < MAX_CLIENTS; i++)\r\n        key_strings.push_back(std::string((const char*)(hw + offset_key1 + (0x250 * i))));\r\n\r\n    for (const auto& key : key_strings)\r\n        AddressConversion_AndPrint(key);\r\n\r\n    cvar.console.other.key_write_console = false;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n==============================================================================\nAuthor: Michael Gene Brockus (Dreamer)\nEmail: michaelbrockus@gmail.com\nOrganization: Fossil Logic\nDescription: \n    This file is part of the Fossil Logic project, where innovation meets\n    excellence in software development. Michael Gene Brockus, also known as\n    \"Dreamer,\" is a dedicated contributor to this project. For any inquiries,\n    feel free to contact Michael at michaelbrockus@gmail.com.\n==============================================================================\n*/\n#include \"fossil/xcore/thread.hpp\"\n\nnamespace fscl {\n\n// =================================================================\n// Classic Thread Management\n// =================================================================\n\n/**\n * Create a new thread.\n *\n * @param func The function to be executed by the thread.\n * @param arg  The argument to be passed to the thread function.\n * @return     A handle to the created thread.\n */\ncthread thread_create(CThreadFunc func, void* arg) {\n    return fscl_thread_create(func, arg);\n}\n\n/**\n * Wait for a thread to finish execution.\n *\n * @param handle The handle of the thread to join.\n */\nvoid thread_join(cthread handle) {\n    fscl_thread_join(handle);\n}\n\n/**\n * Erase a thread and free associated resources.\n *\n * @param handle The handle of the thread to erase.\n */\nvoid thread_erase(cthread handle) {\n    fscl_thread_erase(handle);\n}\n\n/**\n * Sleep the current thread for a specified number of milliseconds.\n *\n * @param milliseconds The duration of sleep in milliseconds.\n */\nvoid thread_sleep(unsigned int milliseconds) {\n    fscl_thread_sleep(milliseconds);\n}\n\n/**\n * Yield the execution of the current thread to another thread.\n */\nvoid thread_yield() {\n    fscl_thread_yield();\n}\n\n/**\n * Detach a thread, allowing it to run independently.\n *\n * @param handle The handle of the thread to detach.\n */\nvoid thread_detach(cthread handle) {\n    fscl_thread_detach(handle);\n}\n\n/**\n * Get the ID of the current thread.\n *\n * @return The ID of the current thread.\n */\nunsigned long thread_get_id() {\n    return fscl_thread_get_id();\n}\n\n// =================================================================\n// Thread Pool Management\n// =================================================================\n\n/**\n * Create a new thread pool with a specified number of threads.\n *\n * @param num_threads The number of threads in the pool.\n * @return            A handle to the created thread pool.\n */\ncthread_pool thread_pool_create(int num_threads) {\n    return fscl_thread_pool_create(num_threads);\n}\n\n/**\n * Execute a task in the thread pool.\n *\n * @param pool The thread pool in which to execute the task.\n * @param func The function to be executed by a thread in the pool.\n * @param arg  The argument to be passed to the thread function.\n */\nvoid thread_pool_execute(cthread_pool pool, CThreadFunc func, void* arg) {\n    fscl_thread_pool_execute(pool, func, arg);\n}\n\n/**\n * Wait for all tasks in the thread pool to finish execution.\n *\n * @param pool The thread pool to wait for.\n */\nvoid thread_pool_wait(cthread_pool pool) {\n    fscl_thread_pool_wait(pool);\n}\n\n/**\n * Erase a thread pool and free associated resources.\n *\n * @param pool The thread pool to erase.\n */\nvoid thread_pool_erase(cthread_pool pool) {\n    fscl_thread_pool_erase(pool);\n}\n\n// =================================================================\n// Mutex Thread Management\n// =================================================================\n\n/**\n * Create a new mutex.\n *\n * @param mutex Pointer to the cmutex structure to store the created mutex.\n */\nvoid mutex_create(cmutex* mutex) {\n    fscl_mutex_create(mutex);\n}\n\n/**\n * Lock a mutex, preventing other threads from accessing the protected resource.\n *\n * @param mutex Pointer to the cmutex structure to be locked.\n */\nvoid mutex_lock(cmutex* mutex) {\n    fscl_mutex_lock(mutex);\n}\n\n/**\n * Unlock a locked mutex, allowing other threads to access the protected resource.\n *\n * @param mutex Pointer to the cmutex structure to be unlocked.\n */\nvoid mutex_unlock(cmutex* mutex) {\n    fscl_mutex_unlock(mutex);\n}\n\n/**\n * Erase a mutex and free associated resources.\n *\n * @param mutex Pointer to the cmutex structure to be erased.\n */\nvoid mutex_erase(cmutex* mutex) {\n    fscl_mutex_erase(mutex);\n}\n\n} // namespace fscl\n",
    "#include \"halfedgemesh.h\"\n\n// travel around the Face and get the three vertex IDs belonging to this face\nVector3i HalfEdgeMesh::getVertexIdsFromFace(Face* f) {\n    Vector3i vertexIDList(-1, -1, -1);\n    HalfEdge* h = f->he;\n    int i=0;\n    do {\n        vertexIDList[i++] = h->vertex->id;\n        h = h->next;\n    } while (h != f->he);\n    return vertexIDList;\n}\n\n// travel around the halfedges connected to this vertex and get the face IDs that this vertex is a part of\nvector<int> HalfEdgeMesh::getFaceIdsFromVertex(Vertex* v) {\n    vector<int> faceIDList;\n    HalfEdge* h = v->he;\n    int i=0;\n    do {\n        faceIDList.push_back(h->face->id);\n        h = h->twin->next;\n    } while (h != v->he);\n    return faceIDList;\n}\n\nVector3f HalfEdgeMesh::getFaceNormal(Face* face) {\n    // visualize:\n    //         v1\n    //      /  |\n    //  v2  f0 |\n    //    \\    |\n    //        v0\n    HalfEdge* heV0V1 = face->he;\n    Vertex* v0 = heV0V1->vertex;\n    Vertex* v1 = heV0V1->next->vertex;\n    Vertex* v2 = heV0V1->next->next->vertex;\n\n    Vector3f v01 = (v1->vertex3f - v0->vertex3f);\n    Vector3f v02 = (v2->vertex3f - v0->vertex3f);\n\n    Vector3f faceNormal = v01.cross(v02);\n    faceNormal.normalize();\n    return faceNormal;\n}\n\nVector3f HalfEdgeMesh::getVertexNormal(Vertex* vertex) {\n    int n=0;\n    HalfEdge* h = vertex->he;\n    Vector3f faceNormalSum = Vector3f(0.f, 0.f, 0.f);\n    do {\n        n += 1;\n        faceNormalSum += getFaceNormal(h->face);\n        h = h->twin->next;\n    } while (h != vertex->he);\n    return faceNormalSum/(float)n;\n}\n\nvoid HalfEdgeMesh::addHalfEdges(vector<HalfEdge*> hes) {\n    for (HalfEdge* he : hes) {\n        halfEdgeMap[he->id] = he;\n    }\n}\n\nvoid HalfEdgeMesh::addEdges(vector<Edge*> es) {\n    for (Edge* e : es) {\n        edgeMap[e->id] = e;\n    }\n}\n\nvoid HalfEdgeMesh::addFaces(vector<Face*> fs) {\n    for (Face* f : fs) {\n        faceMap[f->id] = f;\n    }\n}\n\nvoid HalfEdgeMesh::addVertices(vector<Vertex*> vs) {\n    for (Vertex* v : vs) {\n        vertexMap[v->id] = v;\n    }\n}\n\nvoid HalfEdgeMesh::deleteHalfEdges(vector<HalfEdge*> hes) {\n    for (HalfEdge* he : hes) {\n        auto it = halfEdgeMap.find(he->id);\n        delete halfEdgeMap[he->id]; // delete the ptr\n        halfEdgeMap.erase(it); // erase the entry from the map\n    }\n}\n\nvoid HalfEdgeMesh::deleteEdges(vector<Edge*> es) {\n    for (Edge* e : es) {\n        auto it = edgeMap.find(e->id);\n        delete edgeMap[e->id]; // delete the ptr\n        edgeMap.erase(it); // erase the entry from the map\n    }\n}\n\nvoid HalfEdgeMesh::deleteFaces(vector<Face*> fs) {\n    for (Face* f : fs) {\n        auto it = faceMap.find(f->id);\n        delete faceMap[f->id]; // delete the ptr\n        faceMap.erase(it); // erase the entry from the map\n    }\n}\n\nvoid HalfEdgeMesh::deleteVertices(vector<Vertex*> vs) {\n    for (Vertex* v : vs) {\n        auto it = vertexMap.find(v->id);\n        delete vertexMap[v->id]; // delete the ptr\n        vertexMap.erase(it); // erase the entry from the map\n    }\n}\n",
    "#include<iostream>\n#include<vector>  \n#include<type_traits>\n#include<algorithm>\n\nvoid insertionSort(std::vector<double>& arr) {\n    if (arr.empty()) {\n        return;\n    }  \n    for (size_t i = 1; i < arr.size(); i++) {\n        int key = arr[i];\n        size_t j = i - 1;  \n        while (j < arr.size() && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }  \n        arr[j + 1] = key;\n    }\n}\n\n\nvoid selectionSort(std::vector<double>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; i++) {\n        int min_index = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        std::swap(arr[i], arr[min_index]);\n    }\n}\n\n\nvoid bubbleSort(std::vector<double>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                std::swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\n\nvoid gnomeSort(std::vector<double>& arr) {\n    int n = arr.size();\n    int index = 0;  \n    while (index < n) {\n        if (index == 0)\n            index++;\n        if (arr[index] >= arr[index - 1])\n            index++;\n        else {\n            std::swap(arr[index], arr[index - 1]);\n            index--;\n        }\n    }\n}\n\n\nvoid cocktailSort(std::vector<double>& arr) {\n    int n = arr.size();\n    bool swapped = true;\n    int start = 0;\n    int end = n - 1;  \n    while (swapped) {\n        swapped = false;  \n        for (int i = start; i < end; i++) {\n            if (arr[i] > arr[i + 1]) {\n                std::swap(arr[i], arr[i + 1]);\n                swapped = true;\n            }\n        }  \n        if (!swapped) \n            break;  \n        end--;  \n        for (int i = end; i > start; i--) {\n            if (arr[i] < arr[i - 1]) {\n                std::swap(arr[i], arr[i - 1]);\n                swapped = true;\n            }\n        }  \n        start++;\n    }\n}\n\n\nvoid heapify(std::vector<double>& arr, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;  \n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }  \n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }  \n    if (largest != i) {\n        std::swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}  \nvoid heapSort(std::vector<double>& arr) {\n    int n = arr.size();\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }  \n    for (int i = n - 1; i > 0; i--) {\n        std::swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\n\ntemplate<class T>\nvoid quickSortR(T* a, long N) {\n    long i = 0, j = N-1;\n    T temp, p;  p = a[ N>>1 ];  \n    do {\n        while ( a[i] < p ) i++;\n        while ( a[j] > p ) j--;  \n        if (i <= j) {\n            temp = a[i]; a[i] = a[j]; a[j] = temp;\n            i++; j--;\n        }\n    } \n    while ( i<=j );\n    if ( j > 0 ) quickSortR(a, j);\n    if ( N > i ) quickSortR(a+i, N-i);\n}\n\n\nvoid merge(std::vector<double>& arr, int left, int middle, int right) {\n    int n1 = middle - left + 1;\n    int n2 = right - middle;  \n    int L[n1], R[n2];  \n    for (int i = 0; i < n1; i++) {\n        L[i] = arr[left + i];\n    }  \n    for (int i = 0; i < n2; i++) {  \n        R[i] = arr[middle + 1 + i];\n    }  \n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }  \n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }  \n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\nvoid mergeSort(std::vector<double>& arr, int left, int right) {\n    if (left < right) {\n        int middle = left + (right - left) / 2;\n        mergeSort(arr, left, middle);\n        mergeSort(arr, middle + 1, right);\n        merge(arr, left, middle, right);\n    }\n}\n\n\n/*\n// \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u043b\u044f\u00a0\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0443\u0437\u043b\u0430 \u0432\u00a0\u0434\u0432\u043e\u0438\u0447\u043d\u043e\u043c \u0434\u0435\u0440\u0435\u0432\u0435\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;  \n    \n    Node(int value) {\n        data = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};  \n\n// \u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f\u00a0\u0432\u0441\u0442\u0430\u0432\u043a\u0438 \u0443\u0437\u043b\u0430 \u0432\u00a0\u0434\u0432\u043e\u0438\u0447\u043d\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e\nNode* insert(Node* root, int value) {\n    if (root == nullptr) {\n        return new Node(value);\n    }  \n    if (value < root->data) {\n        root->left = insert(root->left, value);\n    } else {\n        root->right = insert(root->right, value);\n    }  \n    return root;\n}\n\n// \u0420\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f\u00a0\u043e\u0431\u0445\u043e\u0434\u0430 \u0434\u0432\u043e\u0438\u0447\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430 \u0432\u00a0\u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044f\nvoid inOrderTraversal(Node* root) {\n    if (root != nullptr) {\n        inOrderTraversal(root->left);\n        std::cout << root->data << \" \";\n        inOrderTraversal(root->right);\n    }\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f\u00a0\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u0441\u00a0\u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0434\u0432\u043e\u0438\u0447\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430\nvoid treeSort(std::vector<double>& arr, int n) {\n    Node* root = nullptr;  // \u0412\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043a\u0430\u0436\u0434\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include <Arduino.h>\n#include <Adafruit_CircuitPlayground.h>\n\n#define NEOPIX_PIN    A2\n#define NUM_PIXELS    5\n\nAdafruit_CPlay_NeoPixel strip = Adafruit_CPlay_NeoPixel(NUM_PIXELS, NEOPIX_PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup() {\n  CircuitPlayground.begin();\n  Serial.begin(115200);\n  // Print log\n  Serial.println(\"setup\");\n}\n\nvoid loop() {\n  CircuitPlayground.clearPixels();\n\n  // Color can be set using RGB or Hex\n  CircuitPlayground.setPixelColor(0, 255,   0,   0);\n  CircuitPlayground.setPixelColor(1, 128, 128,   0);\n  CircuitPlayground.setPixelColor(2,   0, 255,   0);\n  CircuitPlayground.setPixelColor(3,   0, 128, 128);\n  CircuitPlayground.setPixelColor(4,   0,   0, 255);\n  \n  CircuitPlayground.setPixelColor(5, 0xFF0000);\n  CircuitPlayground.setPixelColor(6, 0x808000);\n  CircuitPlayground.setPixelColor(7, 0x00FF00);\n  CircuitPlayground.setPixelColor(8, 0x008080);\n  CircuitPlayground.setPixelColor(9, 0x0000FF);\n\n  // Reading Accelerometer Data\n  // Serial.println(CircuitPlayground.motionX());\n  // Serial.println(CircuitPlayground.motionY());\n  // Serial.println(CircuitPlayground.motionZ());\n\n  // This print format must be follow in order to display the data in Teloplot\n  Serial.print(\">X Value:\");\n  Serial.println(CircuitPlayground.motionX());\n  Serial.print(\">Y Value:\");\n  Serial.println(CircuitPlayground.motionY());\n  Serial.print(\">Z Value:\");\n  Serial.println(CircuitPlayground.motionZ());\n\n  delay(50);\n}",
    "#include \"lib.hpp\"\n\nbool createWindow(int width, int height, const char* title)\n{\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n        cout << \"SDL could not initialize! SDL_Error: \" << SDL_GetError() << endl;\n        return false;\n    }\n\n    SDL_Window* window = SDL_CreateWindow(title, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_SHOWN);\n    if (window == NULL) {\n        cout << \"Window could not be created! SDL_Error: \" << SDL_GetError() << endl;\n        return false;\n    }\n\n    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n    if (renderer == NULL) {\n        cout << \"Renderer could not be created! SDL_Error: \" << SDL_GetError() << endl;\n        return false;\n    }\n\n    SDL_SetRenderDrawColor(renderer, 0xFF, 0xFF, 0xFF, 0xFF);\n\n    return true;\n}\n\nint main()\n{\n    if (!createWindow(800, 600, \"Hello World!\")) {\n        return 1;\n    }\n\n    while (true) {\n        SDL_Event e;\n        while (SDL_PollEvent(&e) != 0) {\n            if (e.type == SDL_QUIT) {\n                break;\n            }\n        }\n    }\n\n    return 0;\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// dear imgui, v1.85 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// SparseHandler.cpp\n\n#include \"StdAfx.h\"\n\n#include \"../../../C/CpuArch.h\"\n\n#include \"../../Common/ComTry.h\"\n\n#include \"../../Windows/PropVariantUtils.h\"\n\n#include \"../Common/RegisterArc.h\"\n#include \"../Common/StreamUtils.h\"\n\n#include \"HandlerCont.h\"\n\n#define Get16(p) GetUi16(p)\n#define Get32(p) GetUi32(p)\n\n#define G16(_offs_, dest) dest = Get16(p + (_offs_));\n#define G32(_offs_, dest) dest = Get32(p + (_offs_));\n\nusing namespace NWindows;\n\nnamespace NArchive {\nnamespace NSparse {\n\n// libsparse and simg2img\n\nstruct CHeader\n{\n  // UInt32 magic;          /* 0xed26ff3a */\n  // UInt16 major_version;  /* (0x1) - reject images with higher major versions */\n  // UInt16 minor_version;  /* (0x0) - allow images with higer minor versions */\n  UInt16 file_hdr_sz;    /* 28 bytes for first revision of the file format */\n  UInt16 chunk_hdr_sz;   /* 12 bytes for first revision of the file format */\n  UInt32 BlockSize;      /* block size in bytes, must be a multiple of 4 (4096) */\n  UInt32 NumBlocks;      /* total blocks in the non-sparse output image */\n  UInt32 NumChunks;      /* total chunks in the sparse input image */\n  // UInt32 image_checksum; /* CRC32 checksum of the original data, counting \"don't care\" as 0. */\n\n  void Parse(const Byte *p)\n  {\n    // G16 (4, major_version);\n    // G16 (6, minor_version);\n    G16 (8, file_hdr_sz)\n    G16 (10, chunk_hdr_sz)\n    G32 (12, BlockSize)\n    G32 (16, NumBlocks)\n    G32 (20, NumChunks)\n    // G32 (24, image_checksum);\n  }\n};\n \n// #define SPARSE_HEADER_MAGIC 0xed26ff3a\n\n#define CHUNK_TYPE_RAW        0xCAC1\n#define CHUNK_TYPE_FILL       0xCAC2\n#define CHUNK_TYPE_DONT_CARE  0xCAC3\n#define CHUNK_TYPE_CRC32      0xCAC4\n\n#define MY_CHUNK_TYPE_FILL       0\n#define MY_CHUNK_TYPE_DONT_CARE  1\n#define MY_CHUNK_TYPE_RAW_START 2\n\nstatic const char * const g_Methods[] =\n{\n    \"RAW\"\n  , \"FILL\"\n  , \"SPARSE\" // \"DONT_CARE\"\n  , \"CRC32\"\n};\n\nstatic const unsigned kFillSize = 4;\n\nstruct CChunk\n{\n  UInt32 VirtBlock;\n  Byte Fill [kFillSize];\n  UInt64 PhyOffset;\n};\n\nstatic const Byte k_Signature[] = { 0x3a, 0xff, 0x26, 0xed, 1, 0 };\n\n\nZ7_class_CHandler_final: public CHandlerImg\n{\n  Z7_IFACE_COM7_IMP(IInArchive_Img)\n\n  Z7_IFACE_COM7_IMP(IInArchiveGetStream)\n  Z7_IFACE_COM7_IMP(ISequentialInStream)\n\n  CRecordVector<CChunk> Chunks;\n  UInt64 _virtSize_fromChunks;\n  unsigned _blockSizeLog;\n  UInt32 _chunkIndexPrev;\n\n  UInt64 _packSizeProcessed;\n  UInt64 _phySize;\n  UInt32 _methodFlags;\n  bool _isArc;\n  bool _headersError;\n  bool _unexpectedEnd;\n  // bool _unsupported;\n  UInt32 NumChunks; // from header\n\n  HRESULT Seek2(UInt64 offset)\n  {\n    _posInArc = offset;\n    return InStream_SeekSet(Stream, offset);\n  }\n\n  void InitSeekPositions()\n  {\n    /* (_virtPos) and (_posInArc) is used only in Read() (that calls ReadPhy()).\n       So we must reset these variables before first call of Read() */\n    Reset_VirtPos();\n    Reset_PosInArc();\n    _chunkIndexPrev = 0;\n    _packSizeProcessed = 0;\n  }\n\n  // virtual functions\n  bool Init_PackSizeProcessed() Z7_override\n  {\n    _packSizeProcessed = 0;\n    return true;\n  }\n  bool Get_PackSizeProcessed(UInt64 &size) Z7_override\n  {\n    size = _packSizeProcessed;\n    return true;\n  }\n\n  HRESULT Open2(IInStream *stream, IArchiveOpenCallback *openCallback) Z7_override;\n  HRESULT ReadPhy(UInt64 offset, void *data, UInt32 size, UInt32 &processed);\n};\n\n\n\nstatic const Byte kProps[] =\n{\n  kpidSize,\n  kpidPackSize\n};\n\nstatic const Byte kArcProps[] =\n{\n  kpidClusterSize,\n  kpidNumBlocks,\n  kpidMethod\n};\n\nIMP_IInArchive_Props\nIMP_IInArchive_ArcProps\n\nZ7_COM7F_IMF(CHandler::GetArchiveProperty(PROPID propID, PROPVARIANT *value))\n{\n  COM_TRY_BEGIN\n  NCOM::CPropVariant prop;\n\n  switch (propID)\n  {\n    case kpidMainSubfile: prop = (UInt32)0; break;\n    case kpidClusterSize: prop = (UInt32)((UInt32)1 << _blockSizeLog); break;\n    case kpidNumBlocks: prop = (UInt32)NumChunks; break;\n    case kpidPhySize: if (_phySize != 0) prop = _phySize; break;\n\n    case kpidMethod:\n    {\n      FLAGS_TO_PROP(g_Methods, _methodFlags, prop);\n      break;\n    }\n\n    case kpidErrorFlags:\n    {\n      UInt32 v = 0;\n      if (!_isArc)        v |= kpv_ErrorFlags_IsNotArc;\n      if (_headersError)  v |= kpv_ErrorFlags_HeadersError;\n      if (_unexpectedEnd) v |= kpv_ErrorFlags_UnexpectedEnd;\n      // if (_unsupported) v |= kpv_ErrorFlags_UnsupportedMethod;\n      if (!Stream && v == 0 && _isArc)\n        v = kpv_ErrorFlags_HeadersError;\n      if (v != 0)\n        prop = v;\n      break;\n    }\n  }\n  \n  prop.Detach(value);\n  return S_OK;\n  COM_TRY_END\n}\n\n\nZ7_COM7F_IMF(CHandler::GetProperty(UInt32 /* index */, PROPID propID, PROPVARIANT *value))\n{\n  COM_TRY_BEGIN\n  NCOM::CPropVariant prop;\n\n  switch (propID)\n  {\n    case kpidSize: prop = _size; break;\n    case kpidPackSize: prop = _phySize; break;\n    case kpidExtension: prop = (_imgExt ? _imgExt : \"img\"); break;\n  }\n  \n  prop.Detach(value);\n  return S_OK;\n  COM_TRY_END\n}\n\n\nstatic unsigned GetLogSize(UInt32 size)\n{\n  unsigned k;\n  for (k = 0; k < 32; k++)\n    if (((UI",
    "#include <vector>\n#include \"binarytree.hpp\"\n#include \"slidwindow.hpp\"\nusing namespace std;\n\nvoid bitree_demo()\n{\n\t//\u6839\u636e\u6570\u7ec4\u6784\u9020\u4e8c\u53c9\u6811\n\tvector<int> list = { 1,5,3,3,6,9,8 };\n\tbinarytree<int>* tree = new binarytree<int>(list);\n\t//fun\u7ed1\u5b9aprint\u51fd\u6570\uff0c\u5148\u5e8f\u904d\u5386\u4e8c\u53c9\u6811\u6253\u5370\u5404\u8282\u70b9\u503c\n\tauto fun = bind(&binarytree<int>::print,tree, placeholders::_1);\n\ttree->order(fun,0);\n\t//\u67e5\u627edata==3\u7684\u8282\u70b9\u5730\u5740\n\tauto address = tree->search(3);\n\tfor (auto iter = address.begin(); iter != address.end(); iter++)\n\t{\n\t\tcout << \"address: \" << *iter << \"  data:\" << (*iter)->data << endl;\n\t}\n\t//\u67e5\u627e\u7b2c\u4e00\u4e2adata==3\u7684\u8282\u70b9\u7684\u7236\u8282\u70b9\u5730\u5740\n\tauto father = tree->parent(address[0]);\n\tcout << \"address: \" << father << \"  data:\" << father->data << endl;\n\n\n}\n\nvoid graph_demo()\n{\n\n}\n\nvoid PID_demo()\n{\n\n\n}\n\nvoid slidwin_demo()\n{\n\tvector<int> arr;\n\tint i;\n\tint n;\n\tint item;\n\tcin >> n;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> item;\n\t\tarr.push_back(item);\n\t}\n\tslidewindow<int> window = slidewindow<int>(arr);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\twindow.add();\n\t}\n\tfunction<void(int)> fun = (\n\t\t[&](int item)\n\t\t{\n\t\t\tcout << item << endl;\n\t\t}\n\t);\n\twindow.order(fun);\n}\n\nvoid main()\n{\n\tslidwin_demo();\n}\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <EnginePCH.h>\r\n\r\n#include \"BufferDX11.h\"\r\n\r\nBufferDX11::BufferDX11( ID3D11Device2* pDevice, UINT bindFlags, const void* data, size_t count, UINT stride )\r\n    : m_pDevice( pDevice )\r\n    , m_pDeviceContext( NULL )\r\n    , m_pBuffer( NULL )\r\n    , m_uiStride( stride )\r\n    , m_BindFlags( bindFlags )\r\n    , m_uiCount( (UINT)count )\r\n    , m_bIsBound( false )\r\n{\r\n    D3D11_BUFFER_DESC bufferDesc;\r\n    D3D11_SUBRESOURCE_DATA resourceData;\r\n\r\n    bufferDesc.Usage = D3D11_USAGE_DEFAULT;\r\n    bufferDesc.BindFlags = bindFlags;\r\n    bufferDesc.ByteWidth = m_uiStride * m_uiCount;\r\n    bufferDesc.CPUAccessFlags = 0;\r\n    bufferDesc.MiscFlags = 0;\r\n    bufferDesc.StructureByteStride = 0;\r\n\r\n    resourceData.pSysMem = data;\r\n    resourceData.SysMemPitch = 0;\r\n    resourceData.SysMemSlicePitch = 0;\r\n\r\n    if ( FAILED( m_pDevice->CreateBuffer( &bufferDesc, &resourceData, &m_pBuffer ) ) )\r\n    {\r\n        ReportError( \"Failed to create buffer.\" );\r\n    }\r\n\r\n    m_pDevice->GetImmediateContext2( &m_pDeviceContext );\r\n}\r\n\r\nBufferDX11::~BufferDX11()\r\n{}\r\n\r\nbool BufferDX11::Bind( unsigned int id, Shader::ShaderType shaderType, ShaderParameter::Type parameterType )\r\n{\r\n    assert( m_pDeviceContext );\r\n\r\n    ID3D11Buffer* buffers[] = { m_pBuffer.Get() };\r\n    UINT offsets[] = { 0 };\r\n    UINT strides[] = { m_uiStride };\r\n\r\n    switch ( m_BindFlags )\r\n    {\r\n    case D3D11_BIND_VERTEX_BUFFER:\r\n        m_pDeviceContext->IASetVertexBuffers( id, 1, buffers, strides, offsets );\r\n        m_bIsBound = true;\r\n        break;\r\n    case D3D11_BIND_INDEX_BUFFER:\r\n        m_pDeviceContext->IASetIndexBuffer( m_pBuffer.Get(), DXGI_FORMAT_R32_UINT, 0 );\r\n        m_bIsBound = true;\r\n        break;\r\n    default:\r\n        throw new std::exception( \"BufferDX11::Bind: Unimplemented buffer type.\" );\r\n        // return false;\r\n        break;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nvoid BufferDX11::UnBind( unsigned int id, Shader::ShaderType shaderType, ShaderParameter::Type parameterType )\r\n{\r\n    ID3D11Buffer* buffers[] = { nullptr };\r\n\r\n    switch ( m_BindFlags )\r\n    {\r\n    case D3D11_BIND_VERTEX_BUFFER:\r\n        m_pDeviceContext->IASetVertexBuffers( id, 1, buffers, nullptr, nullptr );\r\n        m_bIsBound = true;\r\n        break;\r\n    case D3D11_BIND_INDEX_BUFFER:\r\n        m_pDeviceContext->IASetIndexBuffer(nullptr, DXGI_FORMAT_UNKNOWN, 0 );\r\n        m_bIsBound = true;\r\n        break;\r\n    default:\r\n        throw new std::exception( \"BufferDX11::Bind: Unimplemented buffer type.\" );\r\n        // return false;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid BufferDX11::Copy( std::shared_ptr<Buffer> other )\r\n{\r\n    std::shared_ptr<BufferDX11> srcBuffer = std::dynamic_pointer_cast<BufferDX11>( other );\r\n\r\n    if ( srcBuffer && srcBuffer.get() != this &&\r\n         m_uiCount * m_uiStride == srcBuffer->m_uiCount * srcBuffer->m_uiStride )\r\n    {\r\n        m_pDeviceContext->CopyResource( m_pBuffer.Get(), srcBuffer->m_pBuffer.Get() );\r\n    }\r\n    else\r\n    {\r\n        ReportError( \"Source buffer is not compatible with this buffer.\" );\r\n    }\r\n}\r\n\r\nBuffer::BufferType BufferDX11::GetType() const\r\n{\r\n    switch ( m_BindFlags )\r\n    {\r\n    case D3D11_BIND_VERTEX_BUFFER:\r\n        return Buffer::VertexBuffer;\r\n        break;\r\n    case D3D11_BIND_INDEX_BUFFER:\r\n        return Buffer::IndexBuffer;\r\n        break;\r\n    case D3D11_BIND_CONSTANT_BUFFER:\r\n        return Buffer::ConstantBuffer;\r\n        break;\r\n    default:\r\n        return Buffer::Unknown;\r\n        break;\r\n    }\r\n}\r\n\r\nunsigned int BufferDX11::GetElementCount() const\r\n{\r\n    return m_uiCount;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tic_tac_toe\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define DESCRIPTOR_DEF\n#include \"croskblight.h\"\n#include <acpiioct.h>\n#include <ntstrsafe.h>\n#define NOTVM 1\n\nstatic ULONG CrosKBLightDebugLevel = 100;\nstatic ULONG CrosKBLightDebugCatagories = DBG_INIT || DBG_PNP || DBG_IOCTL;\n\nNTSTATUS\nDriverEntry(\n\t__in PDRIVER_OBJECT  DriverObject,\n\t__in PUNICODE_STRING RegistryPath\n\t)\n{\n\tNTSTATUS               status = STATUS_SUCCESS;\n\tWDF_DRIVER_CONFIG      config;\n\tWDF_OBJECT_ATTRIBUTES  attributes;\n\n\tCrosKBLightPrint(DEBUG_LEVEL_INFO, DBG_INIT,\n\t\t\"Driver Entry\");\n\n\tWDF_DRIVER_CONFIG_INIT(&config, CrosKBLightEvtDeviceAdd);\n\n\tWDF_OBJECT_ATTRIBUTES_INIT(&attributes);\n\n\t//\n\t// Create a framework driver object to represent our driver.\n\t//\n\n\tstatus = WdfDriverCreate(DriverObject,\n\t\tRegistryPath,\n\t\t&attributes,\n\t\t&config,\n\t\tWDF_NO_HANDLE\n\t\t);\n\n\tif (!NT_SUCCESS(status))\n\t{\n\t\tCrosKBLightPrint(DEBUG_LEVEL_ERROR, DBG_INIT,\n\t\t\t\"WdfDriverCreate failed with status 0x%x\\n\", status);\n\t}\n\n\treturn status;\n}\n\n#define MAX_DEVICE_REG_VAL_LENGTH 0x100\nNTSTATUS GetSmbiosName(WCHAR systemProductName[MAX_DEVICE_REG_VAL_LENGTH]) {\n\tNTSTATUS status = STATUS_UNSUCCESSFUL;\n\tHANDLE parentKey = NULL;\n\tUNICODE_STRING ParentKeyName;\n\tOBJECT_ATTRIBUTES  ObjectAttributes;\n\tRtlInitUnicodeString(&ParentKeyName, L\"\\\\Registry\\\\Machine\\\\Hardware\\\\DESCRIPTION\\\\System\\\\BIOS\");\n\n\tInitializeObjectAttributes(&ObjectAttributes,\n\t\t&ParentKeyName,\n\t\tOBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,\n\t\tNULL,    // handle\n\t\tNULL);\n\n\tstatus = ZwOpenKey(&parentKey, KEY_READ, &ObjectAttributes);\n\tif (!NT_SUCCESS(status)) {\n\t\treturn status;\n\t}\n\n\tULONG ResultLength;\n\tPKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePoolZero(NonPagedPool, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_DEVICE_REG_VAL_LENGTH, CROSKBLIGHT_POOL_TAG);\n\tif (!KeyValueInfo) {\n\t\tstatus = STATUS_NO_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tUNICODE_STRING SystemProductNameValue;\n\tRtlInitUnicodeString(&SystemProductNameValue, L\"SystemProductName\");\n\tstatus = ZwQueryValueKey(parentKey, &SystemProductNameValue, KeyValuePartialInformation, KeyValueInfo, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_DEVICE_REG_VAL_LENGTH, &ResultLength);\n\tif (!NT_SUCCESS(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (KeyValueInfo->DataLength > MAX_DEVICE_REG_VAL_LENGTH) {\n\t\tstatus = STATUS_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\n\tRtlZeroMemory(systemProductName, sizeof(systemProductName));\n\tRtlCopyMemory(systemProductName, &KeyValueInfo->Data, KeyValueInfo->DataLength);\n\nexit:\n\tif (KeyValueInfo) {\n\t\tExFreePoolWithTag(KeyValueInfo, CROSKBLIGHT_POOL_TAG);\n\t}\n\treturn status;\n}\n\n#if NOTVM\nNTSTATUS ConnectToEc(\n\t_In_ WDFDEVICE FxDevice\n) {\n\tPCROSKBLIGHT_CONTEXT pDevice = GetDeviceContext(FxDevice);\n\tWDF_OBJECT_ATTRIBUTES objectAttributes;\n\n\tWDF_OBJECT_ATTRIBUTES_INIT(&objectAttributes);\n\tobjectAttributes.ParentObject = FxDevice;\n\n\tNTSTATUS status = WdfIoTargetCreate(FxDevice,\n\t\t&objectAttributes,\n\t\t&pDevice->busIoTarget\n\t);\n\tif (!NT_SUCCESS(status))\n\t{\n\t\tCrosKBLightPrint(\n\t\t\tDEBUG_LEVEL_ERROR,\n\t\t\tDBG_IOCTL,\n\t\t\t\"Error creating IoTarget object - 0x%x\\n\",\n\t\t\tstatus);\n\t\tif (pDevice->busIoTarget)\n\t\t\tWdfObjectDelete(pDevice->busIoTarget);\n\t\treturn status;\n\t}\n\n\tDECLARE_CONST_UNICODE_STRING(busDosDeviceName, L\"\\\\DosDevices\\\\GOOG0004\");\n\n\tWDF_IO_TARGET_OPEN_PARAMS openParams;\n\tWDF_IO_TARGET_OPEN_PARAMS_INIT_OPEN_BY_NAME(\n\t\t&openParams,\n\t\t&busDosDeviceName,\n\t\t(GENERIC_READ | GENERIC_WRITE));\n\n\topenParams.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;\n\topenParams.CreateDisposition = FILE_OPEN;\n\topenParams.FileAttributes = FILE_ATTRIBUTE_NORMAL;\n\n\tCROSEC_INTERFACE_STANDARD CrosEcInterface;\n\tRtlZeroMemory(&CrosEcInterface, sizeof(CrosEcInterface));\n\n\tstatus = WdfIoTargetOpen(pDevice->busIoTarget, &openParams);\n\tif (!NT_SUCCESS(status))\n\t{\n\t\tCrosKBLightPrint(\n\t\t\tDEBUG_LEVEL_ERROR,\n\t\t\tDBG_IOCTL,\n\t\t\t\"Error opening IoTarget object - 0x%x\\n\",\n\t\t\tstatus);\n\t\tWdfObjectDelete(pDevice->busIoTarget);\n\t\treturn status;\n\t}\n\n\tstatus = WdfIoTargetQueryForInterface(pDevice->busIoTarget,\n\t\t&GUID_CROSEC_INTERFACE_STANDARD,\n\t\t(PINTERFACE)&CrosEcInterface,\n\t\tsizeof(CrosEcInterface),\n\t\t1,\n\t\tNULL);\n\tWdfIoTargetClose(pDevice->busIoTarget);\n\tpDevice->busIoTarget = NULL;\n\tif (!NT_SUCCESS(status)) {\n\t\tCrosKBLightPrint(DEBUG_LEVEL_ERROR, DBG_PNP,\n\t\t\t\"WdfFdoQueryForInterface failed 0x%x\\n\", status);\n\t\treturn status;\n\t}\n\n\tpDevice->CrosEcBusContext = CrosEcInterface.InterfaceHeader.Context;\n\tpDevice->CrosEcCmdXferStatus = CrosEcInterface.CmdXferStatus;\n\treturn status;\n}\n\nstatic NTSTATUS send_ec_command(\n\t_In_ PCROSKBLIGHT_CONTEXT pDevice,\n\tUINT32 cmd,\n\tUINT32 version,\n\tUINT8* out,\n\tsize_t outSize,\n\tUINT8* in,\n\tsize_t inSize)\n{\n\tPCROSEC_COMMAND msg = (PCROSEC_COMMAND)ExAllocatePoolWithTag(NonPagedPool, sizeof(CROSEC_COMMAND) + max(outSize, inSize), CROSKBLIGHT_POOL_TAG);\n\tif (!msg) {\n\t\treturn STATUS_NO_MEMORY;\n\t}\n\tmsg->Version = version;\n\tmsg->Command = cmd;\n\tmsg->OutSize = outSize;\n\tmsg->InSize = inSize;\n\n\tif (outSize)\n\t\tmemcpy(msg->Data, out, outSize);\n\n\tNTSTATUS status = (*pDevice->CrosEcCmdXferStatus)(pDevice->CrosEcBusCon",
    "#include <iostream>\nusing namespace std;\n\n//---------------------\n#define RED  \"\\x1B[31m\"\n#define GRN  \"\\x1B[32m\"\n#define YEL  \"\\x1B[33m\"\n#define BLU  \"\\x1B[34m\"\n#define MAG  \"\\x1B[35m\"\n#define CYN  \"\\x1B[36m\"\n#define WHT  \"\\x1B[37m\"\n#define END  \"\\033[0m\"\n//---------------------\n\n\nint main(int argc, char *argv[])\n{\n     gitClassObj;\n    if(argc >= 2)\n    {\n        string argument = string(argv[1]);\n        //git init\n        if (argument == \"init\")\n        {\n            gitClassObj.gitInit();\n            cout <<GRN \"git repository initialized successfully!\" END<< endl;\n            \n        }\n        //git add\n        else if (argument == \"add\")                                               \n        {\n            if(argc == 2){     \n                cout << RED \"missing arguments!\" <<endl;\n                cout << \"Provide a third argument e.g.\" << endl;\n                cout << \"git add <'.' | 'file_name'>\" END << endl;\n            }\n            if(argc >= 3){\n                if(argc == 3){\n                    string argumentC = string(argv[2]);\n                    if (argumentC == \".\") {\n                        gitClassObj.gitAdd();\n                    }\n                    else\n                    {\n                        string files[1] = {string(argv[2])};\n                        gitClassObj.gitAdd(files, 1);\n                    }\n\n                } else {\n                    string files[argc-2];\n                    for (int i = 0; i < argc-2; i++)\n                    {\n                        files[i] = string(argv[i]); \n                    }\n                    gitClassObj.gitAdd(files, argc-2);\n                }\n            }\n            \n        }\n        //git commit\n        else if (argument == \"commit\")\n        {\n            if(argc == 4)    //[ git, commit, -m, \"msg\" ]\n            {\n                string argumentC = string(argv[2]);    \n                string argumentD = string(argv[3]);      \n                if(argumentC == \"-m\")\n                {\n                    gitClassObj.gitCommit(argumentD);\n                    cout << \"files commited successfully\" << endl;\n                }\n            }\n            else \n            {\n                cout << RED \"missing arguments!\" <<endl;\n                cout << \"Provide with a message field e.g.\" << endl;\n                cout << \"git commit -m 'my commit message'\" END << endl;\n            }\n        }\n        // git revert\n        else if(argument == \"revert\")\n        {\n            if(argc == 3)\n            {\n                string argumentC = string(argv[2]);\n                if(argumentC == \"HEAD\")\n                {\n                    gitClassObj.gitRevert(argumentC);\n                    cout << \"The project is now at HEAD\" << endl;\n                }\n                else\n                {\n                    gitClassObj.gitRevert(argumentC);\n                    cout << \"Reverted to <commit_id> commit\" << endl;\n                }\n            }\n            else \n            {\n                cout << RED \"invalid arguments, should be like: \" << endl;\n                cout << \"git revert <'HEAD'|'commit_hash'>\" END<< endl;\n            }\n        }\n        // //git log\n        else if(argument == \"log\")\n        {\n            gitClassObj.gitLog();\n        }\n        //git status\n        // else if(argument == \"status\")\n        // {\n        //     gitClassObj.gitStatus();\n        // }\n        //wrong arguments\n        else\n        {\n            cout << RED \"Invalid arguments\" END << endl;\n        }\n\n    }\n    else \n    {\n        cout << YEL \"git is version control system made by linus Torvalds, this project is a clone of that original system with minimal features \\n\\n\";\n\n        cout << \"Usage: \" << endl;\n        cout << \"git init                           ->   initialize an empty git repository in the current dir\" << endl;\n        cout << \"git add <'.'|'file_name'>          ->   add the files to staging area\" << endl;\n        cout << \"git commit <m 'commit message'>    ->   commit your staging files\" << endl;\n        cout << \"git revert <'HEAD'|'commit_hash'>  ->   rollback to a specific commit\" END << endl;\n    }\n}",
    "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstring>\n#include \"inventar.h\"\nusing namespace std;\nfstream f;\nfstream o;\nint main(){\n\tinventar produs[100];int n;\n\tint op;\n\tchar d;\n\tcitire(produs, n);\n\tcout<<\"Informatia a fost citita din date.in\"<<endl;\n\n\tdo{\n        cout<<\"Ce dorit sa faceti?\"<<endl;\n\tcout<<\"\t1 -Afisarea informatiei.\"<<endl;\n\tcout<<\"\t2 -Adaugarea informatiai.\"<<endl;\n\tcout<<\"\t3 -Sortarea informatiei.\"<<endl;\n\tcout<<\"\t4 -Filtrarea informatiei.\"<<endl;\n\tcout<<\"\t6 -Excluderea informatiei.\"<<endl;\n\tcout<<\"\t7 -Salvarea informatiei.\"<<endl;\n\tcout<<\" \t0 -Oprirea programului\"<<endl<<\"\t\";\n\tcin>>op;\n\tswitch(op){\n\t\tcase 1:\n\t\t\tafisare(produs, n);\n\t\t  break;\n\t\tcase 2:\n\t\t  \tadaugare(produs, n);\n\t\t  break;\n\t\tcase 3:\n\t\t  \tcout<<\"Alegeti tipul de sortare:\"<<endl<<\n\t\t\t\t\"1 -Sortare dupa pret.\"<<endl<<\n\t\t\t\t\"2 -Sortare dupa disponibilitate.\"<<endl<<\n\t\t\t\t\"3 -Sortare alfabetic dupa marca.\"\n\t\t\t\t<<endl;\n\t\t\tint s;\n\t\t\tcin>>s;\n\t\t\tswitch(s){\n\t\t\t\tcase 1:\n\t\t\t\t\tcout<<\"Doriti sa filtrati iteme crescator?\"\n\t\t\t\t\t<<endl<<\"da sau nu(d & n)\";\n\t\t\t\t\tcin>>d;\n\t\t\t\t\tif(d=='d'){SortarePret(produs, n, true);}\n\t\t\t\t\telse{SortarePret(produs, n, false);}\n\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tSortareDispon(produs, n);\n\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"Doriti sa filtrati alfabetic crescator?\"\n\t\t\t\t\t<<endl<<\"da sau nu(d & n)\";\n\t\t\t\t\tcin>>d;\n\t\t\t\t\tif(d=='d'){SortareMarca(produs, n, true);}\n\t\t\t\t\telse{SortareMarca(produs, n, false);}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\tbreak;\n\t\tcase 4:\n\t\t\tcout<<\"Alegeti tipul de filtrare:\"<<endl<<\n\t\t\t\t\"1 -Filtrare dupa disponibilitate.\"<<endl<<\n\t\t\t\t\"2 -Filtrare dupa pret.\"<<endl<<\n\t\t\t\t\"3 -Filtrare dupa marca\"<<endl\n\t\t\t\t<<endl;\n\t\t\tint f;\n\t\t\tcin>>f;\n\t\t\tswitch(f){\n\t\t\t\tcase 1:\n\t\t\t\t\tcout<<\"Doriti sa filtrati iteme disponibile?\"\n\t\t\t\t\t<<endl<<\"da sau nu(d & n)\";\n\t\t\t\t\tcin>>d;\n\t\t\t\t\tif(d == 'd'){filtrare(produs, n, true);}\n\t\t\t\t\telse {filtrare(produs, n, false);}\n\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcout<<\"Introduceti pretul min si maxim:\"\n\t\t\t\t\t<<endl;\n\t\t\t\t\tdouble min,max;\n\t\t\t\t\tcin>>min>>max;\n\t\t\t\t\tfiltrare(produs, n, min, max);\n\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"Introduceti ce marca doriti\"<<endl;\n\t\t\t\t\tchar comp[15];\n\t\t\t\t\tcin>>comp;\n\t\t\t\t\tfiltrare(produs, n, comp);\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\n\t\tbreak;\n\t\tcase 5:\n\n\t\tbreak;\n\t\tcase 6:{\t\n\t\t\tafisare(produs ,n);\n\t\t\tcout<<\"Cite elemente doriti sa stergeti?\"<<endl;\n\t\t\tint ids;\n\t\t\tcin>>ids;\n\t\t\tint e[ids];\n\t\t\tcout<<\"Ce elemene doriti sa stergeti(nr din tabel)\"<<endl;\n\t\t\tfor (int i=0;i<ids;i++){\n\t\t\t\tcin>>e[i];\n\t\t\t}\t\n\t\t\tsterge(produs, n, e, ids);\n\t\t       }\n\t\tbreak;\n\t\tcase 7:\n\t\t\tcout<<\"Alegeti cum va fi numit fisierul in care for fi salvate datele despre stoc:\"<<endl;\n\t\t\tchar numeout[20];\n\t\t\tcin>>numeout;\n\t\t\tsalvare(produs, n, numeout);\n\t\tbreak;\n\t\tcase 0:\n\t  \t\tcout<<\"Multumim ca esti alauri de noi\"<<endl;\n\t\tbreak;\n\t\tdefault:\n\t\t\tcout<<\"Optiune invalida\"<<endl;\n\t\tbreak;\n\t}\n\t}while(op!=0);\n\n\treturn 0;\n\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n#include \"QFileDialog\"\r\n#include \"qcustomplot.h\"\r\n#include <QMenu>\r\n#include <QAction>\r\n#include <QMenuBar>\r\n#include <QVBoxLayout>\r\n#include <QFileDialog>\r\n#include <QTimer>\r\n#include <QDebug>\r\n#include <QApplication>\r\n#include <QTextBrowser>\r\n#include <QMessageBox>\r\n#include <QTemporaryFile>\r\n#include <QResource>\r\n#include <QPropertyAnimation>\r\n#include <QGraphicsOpacityEffect>\r\n#include <cstdlib>\r\n\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    // \u8bbe\u7f6e\u7a97\u53e3\u7684\u80cc\u666f\u989c\u8272\u548c\u5b57\u4f53\u6837\u5f0f\r\n    setStyleSheet(\"font-family: Arial;\");\r\n    // \u8bbe\u7f6e\u7a97\u53e3\u6807\u9898\u680f\u56fe\u6807\r\n    setWindowIcon(QIcon(\":/jisuan.png\"));// \u52a0\u8f7d\u56fe\u6807\r\n    Colors.clear();// \u6e05\u7a7a\u989c\u8272\u5217\u8868\r\n    Colors.push_back(Qt::red);//\u6dfb\u52a0\u989c\u8272\r\n    Colors.push_back(Qt::green);\r\n    Colors.push_back(Qt::yellow);\r\n    Colors.push_back(Qt::cyan);\r\n    Colors.push_back(Qt::magenta);\r\n    QMenuBar *menuBar=new QMenuBar(this);// \u521b\u5efa\u83dc\u5355\u680f\r\n    ui->customPlot->setMouseTracking(true);// \u8bbe\u7f6e\u9f20\u6807\u8ddf\u8e2a\r\n    this->setMenuBar(menuBar);// \u8bbe\u7f6e\u83dc\u5355\u680f\r\n    QMenu* menu = new QMenu(\"\u6587\u4ef6\");// \u521b\u5efa\u83dc\u5355\r\n    QMenu* menu1 = new QMenu(\"\u5e2e\u52a9\");\r\n    QMenu* menu2 = new QMenu(\"\u652f\u6301\");\r\n    QAction* InputFromFile = new QAction(\"\u901a\u8fc7\u6587\u4ef6\u8f93\u5165\", this);// \u521b\u5efa\u83dc\u5355\u9879\r\n    QAction* Documentation = new QAction(\"\u8bf4\u660e\u6587\u6863\", this);\r\n    QAction* video = new QAction(\"\u4f7f\u7528\u89c6\u9891\", this);\r\n    QAction* Github = new QAction(\"Github\", this);\r\n    menuBar->addMenu(menu);// \u6dfb\u52a0\u83dc\u5355\u5230\u83dc\u5355\u680f\r\n    menuBar->addMenu(menu1);\r\n    menuBar->addMenu(menu2);\r\n    menu->addAction(InputFromFile);// \u6dfb\u52a0\u83dc\u5355\u9879\u5230\u83dc\u5355\r\n    menu1->addAction(Documentation);\r\n    menu1->addAction(video);\r\n    menu2->addAction(Github);\r\n    // \u521d\u59cb\u5316 functionLabel\r\n    functionLabel = new QLabel(this);\r\n    functionLabel->setStyleSheet(\"color: white; \");// \u8bbe\u7f6e\u5b57\u4f53\u989c\u8272\u4e3a\u767d\u8272\r\n    functionLabel->hide(); // \u521d\u59cb\u9690\u85cf\r\n    functionLabel->setAlignment(Qt::AlignCenter); // \u5c45\u4e2d\u663e\u793a\u6587\u672c\r\n    functionLabel->setWindowFlags(Qt::Window| Qt::FramelessWindowHint);// \u8bbe\u7f6e\u65e0\u8fb9\u6846\u7a97\u53e3\r\n    functionLabel->setAttribute(Qt::WA_TranslucentBackground,true);// \u8bbe\u7f6e\u80cc\u666f\u900f\u660e\r\n    QFont font(\"TeX Gyre Termes\", 12); // \u521b\u5efa\u5b57\u4f53\u5bf9\u8c61\uff0c\u8bbe\u7f6e\u5b57\u4f53\u4e3aTeX Gyre Termes\uff0c\u5927\u5c0f\u4e3a12\r\n    functionLabel->setFont(font); // \u8bbe\u7f6efunctionLabel\u7684\u5b57\u4f53\u4e3a\u6307\u5b9a\u7684\u5b57\u4f53\r\n    // \u521d\u59cb\u5316 functionLabel_1\r\n    functionLabel_1 = new QLabel(this);// \u521b\u5efa\u7b2c\u4e8c\u4e2afunctionLabel\r\n    functionLabel_1->setStyleSheet(\"color: white; \");// \u8bbe\u7f6e\u5b57\u4f53\u989c\u8272\u4e3a\u767d\u8272\r\n    functionLabel_1->hide(); // \u521d\u59cb\u9690\u85cf\r\n    functionLabel_1->setAlignment(Qt::AlignCenter); // \u5c45\u4e2d\u663e\u793a\u6587\u672c\r\n    functionLabel_1->setWindowFlags(Qt::Window| Qt::FramelessWindowHint);// \u8bbe\u7f6e\u65e0\u8fb9\u6846\u7a97\u53e3\r\n    functionLabel_1->setAttribute(Qt::WA_TranslucentBackground,true);// \u8bbe\u7f6e\u80cc\u666f\u900f\u660e\r\n    functionLabel->setFont(font); // \u8bbe\u7f6efunctionLabel\u7684\u5b57\u4f53\u4e3a\u6307\u5b9a\u7684\u5b57\u4f53\r\n    connect(InputFromFile,&QAction::triggered,this,&MainWindow::InputFromFile_triggered);\r\n    connect(Github,&QAction::triggered,this,&MainWindow::on_btn_manu_znyw_clicked);\r\n    connect(Documentation,&QAction::triggered,this,&MainWindow::opendoc);\r\n    connect(video,&QAction::triggered,this,&MainWindow::openmkv);\r\n    connect(ui->pushButton,&QPushButton::clicked,this,&MainWindow::PushTheButton);\r\n    connect(ui->pushButton_2,&QPushButton::clicked,this,&MainWindow::saveChart);\r\n    connect(ui->customPlot, &QCustomPlot::plottableDoubleClick, this, &MainWindow::handlePlottableClick);\r\n    connect(ui->pushButton_3,&QPushButton::clicked,this,&MainWindow::saveTxt);\r\n    connect(ui->pushButton_4,&QPushButton::clicked,this,&MainWindow::clearTextBrowser);\r\n    connect(ui->customPlot, &QCustomPlot::mouseMove,this,&MainWindow::handleMouseMove);\r\n    connect(ui->customPlot, &QCustomPlot::plottableClick, this, &MainWindow::equationprint);\r\n    connect(ui->pushButton_5,&QPushButton::clicked,this,&MainWindow::clearchart);\r\n\r\n    // \u8bbe\u7f6e\u80cc\u666f\u8272\r\n    ui->customPlot->setBackground(QColor(50, 50, 50));\r\n    ui->customPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);\r\n    // \u8bbe\u7f6ex,y\u5750\u6807\u8f74\u4e3b\u523b\u5ea6\u7ebf\u989c\u8272\r\n    ui->customPlot->xAxis->setTickPen(QPen(Qt::yellow));\r\n    ui->customPlot->yAxis->setTickPen(QPen(Qt::yellow));\r\n\r\n    ui->customPlot->xAxis->setTicks(true);\r\n    ui->customPlot->yAxis->setTicks(true);\r\n    // \u8bbe\u7f6ex,y\u5750\u6807\u8f74 \u5b50\u523b\u5ea6\u7ebf\u989c\u8272\r\n    ui->customPlot->xAxis->setSubTickPen(QColor(255, 165, 0));\r\n    ui->customPlot->yAxis->setSubTickPen(QColor(255, 165, 0));\r\n    // \u8bbe\u7f6ex,y\u8f74\u523b\u5ea6\u6570\u5b57\u989c\u8272\r\n    ui->customPlot->xAxis->setTickLabelColor(Qt::white);\r\n    ui->customPlot->yAxis->setTickLabelColor(Qt::white);\r\n\r\n    // \u8bbe\u7f6ex,y\u5750\u6807\u8f74\u57fa\u7ebf\u989c\u8272\r\n    ui->customPlot->xAxis->setBasePen(QPen(Qt::red));\r\n    ui->customPlot->yAxis->setBasePen(QPen(Qt::red));\r\n    ui->customPlot->xAxis->setRange(-10, 10);\r\n    ui->customPlot->yAxis->setRange(-10, 10);\r\n    ui->customPlot->xAxis->setLabel(\"x\");\r\n    ui->customPlot->yAxis->setLabel(\"y\");\r\n    ui->customPlot->xAxis->setLabelColor(QColor(0, 160, 230));\r\n    ui->customPlot->yAxis->setLabelColor(QColor(0, 160, 230));\r\n    QFont xFont = ui->customPlot->xAxis->labelFont();\r\n    xFont.setPixelSize(20);// \u8bbe\u7f6e\u50cf\u7d20\u5927\u5c0f\r\n    xFont.setBold(true);// \u7c97\u4f53\r\n    xFont.setItalic(true);// \u659c\u4f53\r\n    ui->customPl",
    "#include \"Symbol.h\"\n#include <iostream>\n\nvoid Symbol::generateSymbolOfRightDownStairs() {\n    for (int i = 1; i <= _step; i++) {\n        for (int j = 1; j <= i; j++) {\n            std::cout << _character;\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid Symbol::generateSymbolOfLeftDownStairs() {\n    for (int i = 1; i <= _step; i++) {\n        for (int j = 1; j <= _step; j++) {\n            outputIfAbsoluteValueIsLessThanSpecifiedValue(i, _step + 1 - j);\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid Symbol::generateSymbolOfDiamond() {\n    // \u6bb5\u6570\u304c\u5076\u6570\u3060\u3068\u7dba\u9e97\u306a\u30c0\u30a4\u30e4\u30e2\u30f3\u30c9\u72b6\u306b\u306a\u3089\u306a\u3044\u305f\u3081\u3001\u5947\u6570\u306e\u5834\u5408\u6bb5\u6570\u3092-1\n    if (_step % 2 == 0) _step -= 1;\n    int median = (double)_step / 2 + 0.5;\n\n    // \u4e2d\u592e\u307e\u3067\u306e\u63cf\u753b\n    for (int i = 1; i <= median; i++) {\n        for (int j = 1; j <= _step; j++) {\n            outputIfAbsoluteValueIsLessThanSpecifiedValue(i - 1,\n                abs(median - j));\n        }\n        std::cout << \"\\n\";\n    }\n\n    // \u4e2d\u592e\u3088\u308a\u4e0b\u306e\u63cf\u753b\n    for (int i = median - 1; i >= 1; i--) {\n        for (int j = 1; j <= _step; j++) {\n            outputIfAbsoluteValueIsLessThanSpecifiedValue(i - 1,\n                abs(median - j));\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid Symbol::outputIfAbsoluteValueIsLessThanSpecifiedValue(\n    int determinedValue, int designatedValue) {\n    if (determinedValue >= designatedValue) {\n        std::cout << _character;\n    } else {\n        std::cout << \" \";\n    }\n}\n",
    "#include \"scanner.h\"\n#include \"token.h\"\n\nnamespace YAML {\nstruct Mark;\n\nScanner::SimpleKey::SimpleKey(const Mark& mark_, std::size_t flowLevel_)\n    : mark(mark_),\n      flowLevel(flowLevel_),\n      pIndent(nullptr),\n      pMapStart(nullptr),\n      pKey(nullptr) {}\n\nvoid Scanner::SimpleKey::Validate() {\n  // Note: pIndent will *not* be garbage here;\n  //       we \"garbage collect\" them so we can\n  //       always refer to them\n  if (pIndent)\n    pIndent->status = IndentMarker::VALID;\n  if (pMapStart)\n    pMapStart->status = Token::VALID;\n  if (pKey)\n    pKey->status = Token::VALID;\n}\n\nvoid Scanner::SimpleKey::Invalidate() {\n  if (pIndent)\n    pIndent->status = IndentMarker::INVALID;\n  if (pMapStart)\n    pMapStart->status = Token::INVALID;\n  if (pKey)\n    pKey->status = Token::INVALID;\n}\n\n// CanInsertPotentialSimpleKey\nbool Scanner::CanInsertPotentialSimpleKey() const {\n  if (!m_simpleKeyAllowed)\n    return false;\n\n  return !ExistsActiveSimpleKey();\n}\n\n// ExistsActiveSimpleKey\n// . Returns true if there's a potential simple key at our flow level\n//   (there's allowed at most one per flow level, i.e., at the start of the flow\n// start token)\nbool Scanner::ExistsActiveSimpleKey() const {\n  if (m_simpleKeys.empty())\n    return false;\n\n  const SimpleKey& key = m_simpleKeys.top();\n  return key.flowLevel == GetFlowLevel();\n}\n\n// InsertPotentialSimpleKey\n// . If we can, add a potential simple key to the queue,\n//   and save it on a stack.\nvoid Scanner::InsertPotentialSimpleKey() {\n  if (!CanInsertPotentialSimpleKey())\n    return;\n\n  SimpleKey key(INPUT.mark(), GetFlowLevel());\n\n  // first add a map start, if necessary\n  if (InBlockContext()) {\n    key.pIndent = PushIndentTo(INPUT.column(), IndentMarker::MAP);\n    if (key.pIndent) {\n      key.pIndent->status = IndentMarker::UNKNOWN;\n      key.pMapStart = key.pIndent->pStartToken;\n      key.pMapStart->status = Token::UNVERIFIED;\n    }\n  }\n\n  // then add the (now unverified) key\n  m_tokens.push(Token(Token::KEY, INPUT.mark()));\n  key.pKey = &m_tokens.back();\n  key.pKey->status = Token::UNVERIFIED;\n\n  m_simpleKeys.push(key);\n}\n\n// InvalidateSimpleKey\n// . Automatically invalidate the simple key in our flow level\nvoid Scanner::InvalidateSimpleKey() {\n  if (m_simpleKeys.empty())\n    return;\n\n  // grab top key\n  SimpleKey& key = m_simpleKeys.top();\n  if (key.flowLevel != GetFlowLevel())\n    return;\n\n  key.Invalidate();\n  m_simpleKeys.pop();\n}\n\n// VerifySimpleKey\n// . Determines whether the latest simple key to be added is valid,\n//   and if so, makes it valid.\nbool Scanner::VerifySimpleKey() {\n  if (m_simpleKeys.empty())\n    return false;\n\n  // grab top key\n  SimpleKey key = m_simpleKeys.top();\n\n  // only validate if we're in the correct flow level\n  if (key.flowLevel != GetFlowLevel())\n    return false;\n\n  m_simpleKeys.pop();\n\n  bool isValid = true;\n\n  // needs to be less than 1024 characters and inline\n  if (INPUT.line() != key.mark.line || INPUT.pos() - key.mark.pos > 1024)\n    isValid = false;\n\n  // invalidate key\n  if (isValid)\n    key.Validate();\n  else\n    key.Invalidate();\n\n  return isValid;\n}\n\nvoid Scanner::PopAllSimpleKeys() {\n  while (!m_simpleKeys.empty())\n    m_simpleKeys.pop();\n}\n}  // namespace YAML\n",
    "import word;\n#include <random>\n\n\nWord::Word():\n    m_wordId{ -1 },\n    m_word{ \"\" }\n{\n}\n\nWord::Word(const std::string& word) :\n    m_wordId{ -1 },\n    m_word{ word }\n{\n}\n\n\nsize_t Word::GetWordSize() const\n{\n    return m_word.size();\n}\n\n\nstd::string Word::GetVisibleCharacters() const\n{\n    size_t length = m_word.size();\n    std::string visibleCharacters = m_word;\n    for (int i = 0; i < length; ++i)\n    {\n        if (m_revealedCharacters.find(i) == m_revealedCharacters.end() && m_word[i] != ' ')\n        {\n            visibleCharacters[i] = '_';\n        }\n    }\n    return visibleCharacters;\n}\n\nvoid Word::RevealRandomCharacter()\n{\n    size_t length = m_word.size();\n    int randomIndex;\n    std::random_device rd;\n    std::default_random_engine engine(rd());\n    std::uniform_int_distribution<int> distribution(0, length - 1);\n\n    do {\n        randomIndex = distribution(engine);\n    } while (m_revealedCharacters.find(randomIndex) != m_revealedCharacters.end() or m_word[randomIndex] == ' ');\n\n    m_revealedCharacters.insert(randomIndex);\n}\n\nbool Word::IsRevealed() const\n{\n    uint16_t nonSpaceCharacters = GetNoOfCharacters();\n    return (m_revealedCharacters.size() == nonSpaceCharacters);\n}\n\nbool Word::operator==(const std::string& word) const\n{\n    return m_word == word;\n}\n\nstd::string Word::GetEmptyWord() const\n{\n    size_t length = m_word.size();\n\n    std::string emptyWord(length, '_');\n\n    return emptyWord;\n}\n\nuint16_t Word::GetNoOfCharacters() const\n{\n    uint16_t count = 0;\n    for (char ch : m_word)\n    {\n        if (!std::isspace(static_cast<unsigned char>(ch)))\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nint Word::GetWordId() const\n{\n    return m_wordId;\n}\n\nvoid Word::SetWordId(int wordId)\n{\n    m_wordId = wordId;\n}\n\nstd::string Word::GetWord() const\n{\n    return m_word;\n}\n\nvoid Word::SetWord(const std::string& word)\n{\n    m_word = word;\n    m_revealedCharacters.clear();\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include \"udp_forward_session.h\"\r\n\r\nUDPForwardSession::UDPForwardSession(asio::ip::udp::socket & li_udp_socket, asio::ip::udp::socket dst_udp_socket,\r\n                                     const asio::ip::udp::endpoint & src_endpoint, const asio::ip::udp::endpoint & dst_endpoint)\r\n    : m_li_udp_socket(li_udp_socket)\r\n    , m_dst_udp_socket(std::move(dst_udp_socket))\r\n    , m_src_endpoint(src_endpoint)\r\n    , m_dst_endpoint(dst_endpoint)\r\n    , m_recv_buffer(4 * 1024)\r\n{}\r\n\r\nUDPForwardSession::~UDPForwardSession() {}\r\n\r\nvoid UDPForwardSession::do_read_data()\r\n{\r\n    auto self(shared_from_this());\r\n    m_dst_udp_socket.async_receive(asio::buffer(m_recv_buffer), [=](const asio::error_code & ec, std::size_t bytes_transferred) {\r\n        LAMBDA_REF(self);\r\n        if (ec)\r\n        {\r\n            std::error_code local_endpoint_ec;\r\n            LOG_WARN(\"udp socket {} receive from {} error code:{}, msg:{}\", m_dst_udp_socket.local_endpoint(local_endpoint_ec), m_dst_endpoint, ec.value(),\r\n                     ec.message());\r\n            on_close();\r\n            return;\r\n        }\r\n\r\n        LOG_TRACE(\"recv udp data from {} to {}\", m_dst_endpoint, m_src_endpoint);\r\n\r\n        m_li_udp_socket.async_send_to(asio::buffer(m_recv_buffer.data(), bytes_transferred), m_src_endpoint,\r\n                                      [=](const asio::error_code & ec, std::size_t bytes_transferred) {\r\n                                          LAMBDA_REF(self);\r\n                                          if (ec)\r\n                                          {\r\n                                              LOG_WARN(\"udp socket sendto {} error:{}\", m_src_endpoint, ec.message());\r\n                                              on_close();\r\n                                              return;\r\n                                          }\r\n                                          m_last_alive_time_point = std::chrono::steady_clock::now();\r\n                                          do_read_data();\r\n                                      });\r\n    });\r\n}\r\n\r\nvoid UDPForwardSession::on_udp_data(std::vector<uint8_t> && data)\r\n{\r\n    m_last_alive_time_point = std::chrono::steady_clock::now();\r\n    auto self(shared_from_this());\r\n    auto asio_buffer = asio::buffer(data);\r\n\r\n    LOG_TRACE(\"recv udp data from {} to {}, size:{}\", m_src_endpoint, m_dst_endpoint, data.size());\r\n\r\n    m_dst_udp_socket.async_send(asio_buffer, [=, data = std::move(data)](const asio::error_code & ec, std::size_t bytes_transferred) {\r\n        LAMBDA_REF(self);\r\n        LOG_WARN_IF(ec, \"udp socket sendto {} error:{}\", m_dst_endpoint, ec.message());\r\n    });\r\n}\r\n\r\nstd::chrono::steady_clock::time_point UDPForwardSession::last_alive_timepoint() const\r\n{\r\n    return m_last_alive_time_point;\r\n}\r\n\r\nvoid UDPForwardSession::close()\r\n{\r\n    on_close();\r\n}\r\n\r\nvoid UDPForwardSession::on_close()\r\n{\r\n    if (m_dst_udp_socket.is_open())\r\n    {\r\n        std::error_code ec;\r\n        m_dst_udp_socket.shutdown(m_dst_udp_socket.shutdown_both, ec);\r\n        m_dst_udp_socket.close(ec);\r\n\r\n        if (close_handle)\r\n            close_handle();\r\n    }\r\n}\r\n",
    "// Include important C++ libraries here\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cstdlib>\n\n// Make code easier to type with \"using namespace\"\nusing namespace sf;\nusing namespace std;\n\nint main()\n{\n    // Create a video mode object\n\tVideoMode vm(1920, 1080);\n\t// Create and open a window for the game\n\tRenderWindow window(vm, \"Timber Game!!\", Style::Default);\n\n    vector<Vector2f> vertices;\n    vector<Vector2f> points;\n    sf::Font font;\n    if (!font.loadFromFile(\"arial.ttf\"))\n    {\n        std::cout << \"Unable to upload file\" << std::endl;\n    }\n    sf::Text text;\n    text.setFont(font);\n    text.setString(\"Click on 3 points to draw the triangle.\");\n    text.setCharacterSize(30);\n    text.setFillColor(sf::Color::Red);\n    text.setStyle(sf::Text::Bold);\n\n    \n    while (window.isOpen())\n    {\n        /*\n        ****************************************\n        Handle the players input\n        ****************************************\n        */\n        //I made additions from the font/text sfml until the window.draw(text)\n\n        Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == Event::Closed)\n            {\n                // Quit the game when the window is closed\n                window.close();\n            }\n            if (event.type == sf::Event::MouseButtonPressed)\n            {\n                if (event.mouseButton.button == sf::Mouse::Left)\n                {\n                    std::cout << \"the left button was pressed\" << std::endl;\n                    std::cout << \"mouse x: \" << event.mouseButton.x << std::endl;\n                    std::cout << \"mouse y: \" << event.mouseButton.y << std::endl;\n\n                    if (vertices.size() < 3)\n                    {\n                        vertices.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n                    }\n                    else if (points.size() == 0)\n                    {\n                        ///fourth click\n                        ///push back to points vector\n                        //I went ahead and added the std::cout and the push_back. Lemme know\n                        //if that the implementation requires changes\n                        std::cout << \"click a point inside the triangle\" << std::endl;\n                        points.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n                    }\n                }\n            }\n        }\n        if (Keyboard::isKeyPressed(Keyboard::Escape))\n        {\n            window.close();\n        }\n        /*\n   ****************************************\n   Update\n   ****************************************\n   */\n        //window.clear();\n        //window.draw(text);\n            for (int i = 0; i < 1; i++)\n            {\n                if (points.size() > 0)\n                {\n                    /*\n                    ///generate more point(s)\n                    ///select random vertex\n                    ///calculate midpoint between random vertex and the last point in the vector\n                    ///push back the newly generated coord.\n                    int a;\n                    a = rand() % 3;\n                    //we will use rand to give us the random vertex\n                    float x;\n                    float y;\n                    //So in this case, we make x for the x-coordinate when we take the diff\n                    //y for the y-coordinate for the y dif\n                    //then we just push this new coordinate into the points vector.\n                    if (points.at(points.size() -1 ).x < vertices.at(a).x)\n                    {\n                        x = (vertices.at(a).x - points.at(points.size() - 1).x) / 2 + points.at(points.size() - 1).x;\n                    }\n                    else {\n                        x = points.at(points.size() - 1).x - (points.at(points.size() - 1).x - vertices.at(a).x) / 2;\n                    }\n                    if (points.at(points.size() - 1).y < vertices.at(a).y)\n                    {\n                        y = (vertices.at(a).y - points.at(points.size() - 1).y) / 2 + points.at(points.size() - 1).y;\n                    }\n                    else\n                    {\n                        y = points.at(points.size() - 1).y - (points.at(points.size() - 1).y - vertices.at(a).y) / 2;\n                    }\n                    points.push_back(Vector2f(x, y));\n                    */\n                 \n                    int a = rand() % 3;\n                    float x;\n                    float y;\n                    \n                    \n                        x = (vertices.at(a).x + points.at(points.size() - 1).x) / 2;\n                   \n                        y = (vertices.at(a).y + points.at(points.size() - 1).y) / 2;\n                   \n                    points.push_back(Vector2f(x, y));\n                }\n            }\n            /*\n        ********************************",
    "# 1 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\"\n# 2 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\" 2\n\n//========================== main func ==========================\nvoid setup() {\n  prizm.PrizmBegin();\n  Serial.begin(115200);\n  Serial.print((reinterpret_cast<const __FlashStringHelper *>(\n# 7 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\" 3\n              (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 7 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\"\n              \"\\n\\n[[[Setup Start]]]\\n\\n\"\n# 7 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\" 3\n              ); &__c[0];}))\n# 7 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\"\n              ))); // \uc138\ud305\uc644\ub8cc \uba54\uc2dc\uc9c0\n  huskeylensInit();\n  motorInit();\n  battVoltagePrint();\n  linetrace_analogSetting(3.0, 60, 40, 35);\n\n  Get_Avoid_Return(TEA, COLA, BLUE); // \ubbf8\uc158 \uc138\ud305\uac12\n\n  Serial.print((reinterpret_cast<const __FlashStringHelper *>(\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\" 3\n              (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\"\n              \"\\n\\n[[[Setup Finish]]]\\n\\n\"\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\" 3\n              ); &__c[0];}))\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\"\n              ))); // \uc138\ud305\uc644\ub8cc \uba54\uc2dc\uc9c0\n}\n\nvoid loop() {\n  // battVoltagePrint(1000);\n  setBattVoltage2(12.65); // \uc815\uc0c1\uc791\ub3d9 \ubc30\ud130\ub9ac \uc804\uc555 12.8 ~ 12.2\n\n  // MissionStart();\n  // MissionStart_register();\n  // Mission_Stupid();\n}\n# 1 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n// robot State Check\nvoid battVoltagePrint() {\n  int battVoltage = prizm.readBatteryVoltage();\n  Serial.print((reinterpret_cast<const __FlashStringHelper *>(\n# 4 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 4 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              \"battVoltage : \"\n# 4 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              ); &__c[0];}))\n# 4 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              )));\n  Serial.print(battVoltage / 100);\n  Serial.print((reinterpret_cast<const __FlashStringHelper *>(\n# 6 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 6 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              \".\"\n# 6 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              ); &__c[0];}))\n# 6 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              )));\n  Serial.print(battVoltage % 100);\n  Serial.println((reinterpret_cast<const __FlashStringHelper *>(\n# 8 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n                (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 8 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n                \"V\"\n# 8 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n                ); &__c[0];}))\n# 8 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n                ))); // \ud604 \ubc30\ud130\ub9ac \uc804\uc555 \uccb4\ud06c\n}\n\nvoid battVoltagePrint(int time) {\n  int battVoltage = prizm.readBatteryVoltage();\n  Serial.print((reinterpret_cast<const __FlashStringHelper *>(\n# 13 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 13 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              \"battVoltage : \"\n# 13 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              ); &__c[0];}))\n# 13 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              )));\n  Serial.print(battVoltage / 100);\n  Serial.print((reinterpret_cast<const __FlashStringHelper *>(\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              \".\"\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n              ); &__c[0];}))\n# 15 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n              )));\n  Serial.print(battVoltage % 100);\n  Serial.println((reinterpret_cast<const __FlashStringHelper *>(\n# 17 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n                (__extension__({static const char __c[] __attribute__((__progmem__)) = (\n# 17 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n                \"V\"\n# 17 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\" 3\n                ); &__c[0];}))\n# 17 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n                ))); // \ud604 \ubc30\ud130\ub9ac ",
    "#include \"./CV2.h\"\r\nvoid CV2::grepBitmap()\r\n{\r\n    /*\r\n        process the grep picture\r\n    */\r\n    double t1, t2;\r\n    _pictureCol = pictureCol;\r\n    _pictureRow = pictureRow;\r\n    createBitmap(); // creat the blank picture board\r\n    RGB *piont[pictureRow], *_piont[pictureRow];\r\n\r\n    /*-------the primary of piont and _piont----------*/\r\n    for (int i = 0; i < pictureRow; i++)\r\n    {\r\n        piont[i] = (RGB *)((char *)priex + i * stride);    // piont\r\n        _piont[i] = (RGB *)((char *)_priex + i * _stride); //_piont\r\n    }\r\n    /*-----------------------------------------------*/\r\n\r\n    t1 = omp_get_wtime();\r\n    for (int i = 0; i < _pictureRow; i++)\r\n    {\r\n        for (int j = 0; j < _pictureCol; j++)\r\n        {\r\n            BYTE base = (BYTE)(piont[i][j].Blue * 0.33 + piont[i][j].Green * 0.33 + piont[i][j].Red * 0.33); // the vital\r\n            _piont[i][j].Blue = base;\r\n            _piont[i][j].Green = base;\r\n            _piont[i][j].Red = base;\r\n        }\r\n    }\r\n    t2 = omp_get_wtime();\r\n    std::cout << std::endl;\r\n    std::cout << \"//*****************************//\" << std::endl;\r\n    std::cout << \"// grep is: \" << (t2 - t1) << \"//\" << std::endl;\r\n    std::cout << \"//*****************************//\" << std::endl;\r\n    std::cout << std::endl;\r\n}\r\nvoid CV2::ac_grepBitmap() {}\r\nvoid CV2::binaryzationBitmap(int value)\r\n{\r\n    /*\r\n        process the piture's binaryzation\r\n    */\r\n    double t1, t2;\r\n    _pictureCol = pictureCol;\r\n    _pictureRow = pictureRow;\r\n    RGB *piont[pictureRow], *_piont[pictureRow];\r\n    createBitmap(); // creat the blank picture board\r\n\r\n    /*-------the primary of piont and _piont----------*/\r\n    for (int i = 0; i < pictureRow; i++)\r\n    {\r\n        piont[i] = (RGB *)((char *)priex + i * stride);    // piont\r\n        _piont[i] = (RGB *)((char *)_priex + i * _stride); //_piont\r\n    }\r\n    /*-----------------------------------------------*/\r\n    t1 = omp_get_wtime();\r\n    for (int i = 0; i < pictureRow; i++)\r\n    {\r\n        for (int j = 0; j < pictureCol; j++)\r\n        {\r\n            BYTE base = (BYTE)(piont[i][j].Blue * 0.33 + piont[i][j].Green * 0.33 + piont[i][j].Red * 0.33);\r\n            if (base > value)\r\n                base = WHITE; // the vital\r\n            else\r\n                base = BLACK;\r\n            _piont[i][j].Blue = base;\r\n            _piont[i][j].Green = base;\r\n            _piont[i][j].Red = base;\r\n        }\r\n    }\r\n    t2 = omp_get_wtime();\r\n    std::cout << std::endl;\r\n    std::cout << \"//*****************************//\" << std::endl;\r\n    std::cout << \"// binaryzation is: \" << (t2 - t1) << \"//\" << std::endl;\r\n    std::cout << \"//*****************************//\" << std::endl;\r\n    std::cout << std::endl;\r\n}\r\nvoid CV2::ac_binaryzationBitmap(int value) {}\r\nvoid CV2::segmentBitmap(int beginCol, int beginRow, int _col, int _row)\r\n{\r\n    /*\r\n        to segment your picture\r\n    */\r\n    double t1, t2;\r\n    _pictureRow = _row;\r\n    _pictureCol = _col;\r\n    createBitmap(); // creat the blank picture board\r\n    RGB *piont[pictureRow], *_piont[pictureRow];\r\n    for (int i = 0; i < pictureRow; i++)\r\n    {\r\n        piont[i] = (RGB *)((char *)priex + i * stride);    // piont\r\n        _piont[i] = (RGB *)((char *)_priex + i * _stride); //_piont\r\n    }\r\n    int Clen = beginCol + _pictureCol;\r\n    int Rlen = beginRow + _pictureRow;\r\n    t1 = omp_get_wtime();\r\n    for (int i = beginRow; i < Rlen; i++)\r\n    {\r\n        for (int j = beginCol; j < Clen; j++)\r\n        {\r\n            _piont[i - beginRow][j - beginCol] = piont[i][j]; // the vital\r\n        }\r\n    }\r\n    t2 = omp_get_wtime();\r\n    std::cout << std::endl;\r\n    std::cout << \"//*****************************//\" << std::endl;\r\n    std::cout << \"// segment is: \" << (t2 - t1) << \"//\" << std::endl;\r\n    std::cout << \"//*****************************//\" << std::endl;\r\n    std::cout << std::endl;\r\n}\r\nvoid CV2::ac_segmentBitmap(int beginCol, int beginRow, int _col, int _row) {}\r\nvoid CV2::createBitmap()\r\n{\r\n    /*\r\n        to creat the blank picture board\r\n    */\r\n    _Tag = *Tag;\r\n    _Head = *Head;\r\n    _Tag.biWidth = _pictureCol;                                      // change of the picture col\r\n    _Tag.biHeight = _pictureRow;                                     // change of the picture row\r\n    _Head.bfSize = Head->bfOffBits + _pictureRow * stride;           // change of the head and tag\r\n    out = malloc(_Head.bfSize);                                      // call some room of the new picture\r\n    _stride = (((_pictureCol * (Tag->biBitCount) + 31) & ~31) >> 3); // change of the new stride\r\n    _pictureSize = _Head.bfSize;\r\n    *(BITMAPFILE *)out = _Head;                      // introduce the new Head\r\n    *(BITMAPINFOR *)((char *)out + 14) = _Tag;       // introduce the new Tag\r\n    _priex = (RGB *)((char *)out + Head->bfOffBits); // locate the out(pionter)\r\n}\r\nCV2::CV2(FILE *file)\r\n{\r\n    /*\r\n        jude the picture whether exsit and get the basic information of the picture\r\n    */\r\n    if (file == NULL)\r\n        st",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\r\n// Created by Ali on 2024-04-07.\r\n//\r\n#include \"universal_header.h\"\r\n\r\nstd::vector<HW> read_HW_from_file()\r\n{\r\n    std::vector<HW> HWs;\r\n    std::ifstream file(\"HW.txt\");\r\n    if (file.is_open())\r\n    {\r\n        HW temp_HW(\"\", \"\", \"\", false);\r\n        std::string line;\r\n        while (std::getline(file, line))\r\n        {\r\n            std::vector<std::string> info;\r\n            std::istringstream iss(line);\r\n            std::string word;\r\n\r\n            while (iss >> word)\r\n            {\r\n                info.push_back(word);\r\n            }\r\n            if (info[0] == \"HW\")\r\n            {\r\n                temp_HW.name = info[1];\r\n                temp_HW.teacher = info[2];\r\n                temp_HW.course = info[3];\r\n                temp_HW.visibility = info[4] == \"1\";\r\n                continue;\r\n            }\r\n            else if (info[0] == \"EOH\")\r\n            {\r\n                HWs.push_back(temp_HW);\r\n                temp_HW.name = \"\";\r\n                temp_HW.teacher = \"\";\r\n                temp_HW.course = \"\";\r\n                temp_HW.visibility = false;\r\n                temp_HW.slaves.clear();\r\n                continue;\r\n            }\r\n            else\r\n            {\r\n                temp_HW.bring_student_to_HW(info[0], info[1], std::stoi(info[2]), (info[3] == \"1\"));\r\n            }\r\n        }\r\n        file.close();\r\n    }\r\n    else\r\n    {\r\n        std::cerr << RED() << \"Unable to open file for reading\" << WHITE() << std::endl;\r\n    }\r\n    return HWs;\r\n}\r\nvoid save_HW_to_file(const std::vector<HW>& HWs)\r\n{\r\n    std::ofstream file(\"HW.txt\");\r\n    if (!file)\r\n    {\r\n        std::cerr << RED() << \"Unable to open file for writing\" << WHITE() << std::endl;\r\n        std::this_thread::sleep_for(std::chrono::seconds(1));\r\n    }\r\n\r\n    for (const auto& h : HWs)\r\n    {\r\n        file << \"HW\" << \"\\t\";\r\n        file << h.name << \"\\t\";\r\n        file << h.teacher << \"\\t\";\r\n        file << h.course << \"\\t\";\r\n        file << h.visibility << \"\\n\";\r\n        for (const auto& s : h.slaves)\r\n        {\r\n            file << s.name_of_student << \"\\t\";\r\n            file << s.link_of_uploaded_HW << \"\\t\";\r\n            file << s.score_of_HW << \"\\t\";\r\n            file << s.sent << \"\\n\";\r\n        }\r\n        file << \"EOH\\n\";\r\n    }\r\n    file.close();\r\n}",
    "#include \"SQLiteDatabase.h\"\nstatic int callback(void *data, int argc, char **argv, char **azColName);\n\nSQLiteDatabase::SQLiteDatabase() : db(nullptr), errMsg(nullptr) {}\n\n// SQLite callback function for retrieving data\nstatic int callback(void *data, int argc, char **argv, char **azColName) {\n    std::string* result = static_cast<std::string*>(data);\n    bool rowsProcessed = false; // Flag to track if any rows have been processed\n    *result +=\"----------------------------------\\n\";\n    for (int i = 0; i < argc; i++) {\n        if (argv[i]) {\n            *result += azColName[i];\n            *result += \": \";\n            *result += argv[i];\n            *result += \"\\n\";\n            rowsProcessed = true; // Set the flag to true if any row is processed\n        }\n    }\n\n    if (!rowsProcessed) {\n        *result += \"No results found.\\n\"; // Append a message if no rows are processed\n    }\n    *result +=\"----------------------------------\\n\";\n\n    return 0;\n}\nvoid SQLiteDatabase::openDatabase(const char *dbName) {\n    int rc = sqlite3_open(dbName, &db);\n    if (rc) {\n        std::cerr << \"Error opening SQLite database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid SQLiteDatabase::createTable() {\n    const char *sql = \"CREATE TABLE IF NOT EXISTS Messages(\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"sender TEXT NOT NULL,\"\n                      \"receiver TEXT NOT NULL,\"\n                      \"message TEXT NOT NULL,\"\n                      \"timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\"\n                      \");\";\n\n    int rc = sqlite3_exec(db, sql, nullptr, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n        sqlite3_close(db);\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid SQLiteDatabase::storeMessage(const char *sender, const char *receiver, const char *message) {\n    char *sql = sqlite3_mprintf(\"INSERT INTO Messages (sender, receiver, message) VALUES ('%q', '%q', '%q');\",\n                                 sender, receiver, message);\n\n    int rc = sqlite3_exec(db, sql, nullptr, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n    }\n}\n\nstd::string SQLiteDatabase::retrieveSentMessages(std::string sender) {\n    //std::string sentMessages;\n    // sqlite3_stmt *stmt;\n    // const char *sql = \"SELECT * FROM Messages WHERE sender = ?;\";\n    // int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    // if (rc != SQLITE_OK) {\n    //     std::cerr << \"SQL error: \" << sqlite3_errmsg(db) << std::endl;\n    //     return sentMessages;\n    // }\n\n    // sqlite3_bind_text(stmt, 1, sender, -1, SQLITE_STATIC);\n\n    // while (sqlite3_step(stmt) == SQLITE_ROW) {\n    //     sentMessages += reinterpret_cast<const char *>(sqlite3_column_text(stmt, 3)); // Assuming message is stored in column 3\n    //     sentMessages += \"\\n\";\n    // }\n\n    // sqlite3_finalize(stmt);\n    // return sentMessages;\n    /****************************************/\n    std::string sql = \"SELECT * FROM Messages WHERE sender LIKE \\\"\"+sender+\"\\\";\";\n    std::string sentMessages;\n    char* errMsg = nullptr;\n    int rc = sqlite3_exec(db, sql.c_str(), callback, &sentMessages, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n    }\n\n    // If no messages were found, append a message to the result\n    if (sentMessages.empty()) {\n        sentMessages = \"No messages found for the specified sender.\";\n    }\n\n    return sentMessages;\n}\n\nstd::string SQLiteDatabase::retrieveReceivedMessages(std::string receiver) {\n    // std::string receivedMessages;\n    // sqlite3_stmt *stmt;\n    // const char *sql = \"SELECT * FROM Messages WHERE receiver = ?;\";\n    // int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    // if (rc != SQLITE_OK) {\n    //     std::cerr << \"SQL error: \" << sqlite3_errmsg(db) << std::endl;\n    //     return receivedMessages;\n    // }\n\n    // sqlite3_bind_text(stmt, 1, receiver, -1, SQLITE_STATIC);\n\n    // while (sqlite3_step(stmt) == SQLITE_ROW) {\n    //     receivedMessages += reinterpret_cast<const char *>(sqlite3_column_text(stmt, 3)); // Assuming message is stored in column 3\n    //     receivedMessages += \"\\n\";\n    // }\n\n    // sqlite3_finalize(stmt);\n    // return receivedMessages;\n    /****************************************/\n    std::string sql = \"SELECT * FROM Messages WHERE receiver LIKE \\\"\"+receiver+\"\\\";\";\n    std::string receivedMessages;\n    char* errMsg = nullptr;\n    int rc = sqlite3_exec(db, sql.c_str(), callback, &receivedMessages, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n    }\n\n    // If no messages were found, append a message to the result\n    if (receivedMessages.empty()) {\n        receivedMessages = \"No messages found f",
    "#include <iostream>\nusing namespace std;\nclass entry\n{\nprotected:\n    static int count;\n    string name, address, phone, roll;\n\npublic:\n    int id;\n    string password;\n    entry()\n    {\n        id = count;\n        count++;\n    }\n    void getdata()\n    {\n        system(\"cls\");\n\n        cout << \"enter the details\"\n             << endl;\n        cout << \"*****************\" << endl;\n        cout << \"name :\" << endl;\n        cin >> name;\n        cout << \"address :\" << endl;\n        cin >> address;\n        cout << \"phone number:\" << endl;\n        cin >> phone;\n        cout << \"roll no :\" << endl;\n        cin >> roll;\n        pass();\n        cout << \"id :\" << id << endl;\n        cout << \"data inserted successfully.......!!!\" << endl;\n        getchar();\n    }\n    void putdata()\n    {\n        system(\"cls\");\n        cout << \"DETAILS.....\" << endl;\n        cout << \"name         : \" << name << endl\n             << \"address      : \" << address << endl\n             << \"phone number : \" << phone << endl\n             << \"roll no      : \" << roll << endl\n             << \"id           : \" << id << endl\n             << endl;\n        getchar();\n    }\n    void pass()\n    {\n        cout << \"enter your password\" << endl;\n        cin >> password;\n    }\n    void edit()\n    {\n        system(\"cls\");\n\n        cout << \"enter the details\"\n             << endl;\n        cout << \"*****************\" << endl;\n        cout << \"name :\" << endl;\n        cin >> name;\n        cout << \"address :\" << endl;\n        cin >> address;\n        cout << \"phone number:\" << endl;\n        cin >> phone;\n        cout << \"roll no :\" << endl;\n        cin >> roll;\n        int temp;\n        cout << \"do you want to change password\" << endl;\n        cout << \"1.yes\\n2.no\" << endl;\n        cin >> temp;\n        if (temp == 1)\n            pass();\n        cout << \"id :\" << id << endl;\n        cout << \"data inserted successfully.......!!!\" << endl;\n        getchar();\n    }\n};\n\nint entry::count = 1;\nclass book : public entry\n{\nprotected:\n    static int book1;\n    static int book2;\n    static int book3;\n    static int book4;\n    static int book5;\n\n    int c = 0;\n    int cpp = 0;\n    int dms = 0;\n    int cgr = 0;\n    int java = 0;\n    int day1 = 0;\n    int day2 = 0;\n    int day3 = 0;\n    int day4 = 0;\n    int day5 = 0;\n\npublic:\n    books_avaliable()\n    {\n        cout << endl\n             << endl\n             << endl\n             << endl;\n        cout << \"\\t\\t\\t\\t\\t^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  book name      ||     ||  quatity   ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||--------------------------------------||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c++ book :     ||     ||     \" << book1 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c book :       ||     ||     \" << book2 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  dms book :     ||     ||     \" << book3 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  cgr book :     ||     ||     \" << book4 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  java book :    ||     ||     \" << book5 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t-----------------------------------------\" << endl;\n        getchar();\n    }\n\n    void get_book()\n    {\n        system(\"cls\");\n        cout << endl\n             << endl\n             << endl\n             << endl;\n        cout << \"\\t\\t\\t\\t\\t^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  book name      ||     ||  quatity   ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||--------------------------------------||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c++ book :     ||     ||     \" << book1 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c book :       ||     ||     \" << book2 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  dms book :     ||     ||     \" << book3 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  cgr book :     ||     ||     \" << book4 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  java book :    ||     ||     \" << book5 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t-----------------------------------------\" << endl;\n        getchar();\n\n        int quantity, choice, day;\n\n        do\n        {\n            cout << \"enter the number which book do you want to get\" << endl;\n            cout << \"\\n1.c++ \\n2.c\\n3.dms\\n4.cgr\\n5.java\\n6.exit\" << endl;\n            cin >> choice;\n            switch (choice)\n            {\n            case 1:\n                cout << \"enter how many quantity do you want to get\" << endl;\n                cin >> quantity;\n\n                if (quantity > book1)\n                {\n                    cout << quantity << \" quanti",
    "#include <iostream>\r\n#include <vector>\r\n#include <stack>\r\nusing namespace std;\r\n\r\nclass TreeNode\r\n{\r\npublic:\r\n    int val;\r\n    TreeNode *left;\r\n    TreeNode *right;\r\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n};\r\n\r\nclass Solution\r\n{\r\n    bool helper(TreeNode *l, TreeNode *r)\r\n    {\r\n        if (!l && !r)\r\n            return true;\r\n        if (!l || !r || l->val != r->val)\r\n            return false;\r\n        return helper(l->left, r->right) && helper(l->right, r->left);\r\n    }\r\n\r\npublic:\r\n    bool isSymmetric(TreeNode *root) { return helper(root->left, root->right); }\r\n};\r\n\r\nint main()\r\n{\r\n    Solution sol;\r\n    TreeNode *root = new TreeNode(1);\r\n    root->left = new TreeNode(2);\r\n    root->right = new TreeNode(2);\r\n    root->left->left = new TreeNode(3);\r\n    root->left->right = new TreeNode(4);\r\n    root->right->left = new TreeNode(4);\r\n    root->right->right = new TreeNode(3);\r\n\r\n    cout << sol.isSymmetric(root) << endl;\r\n    return 0;\r\n}\r\n\r\n// https://leetcode.com/problems/symmetric-tree/\r\n",
    "#include \"matrix.h\"\n#include \"test-helpers.h\"\n\n#include <gtest/gtest.h>\n\nnamespace {\n\nclass ctors_test : public ::testing::Test {\nprotected:\n  void SetUp() override {\n    element::reset_allocations();\n  }\n};\n\n} // namespace\n\nTEST_F(ctors_test, default_ctor) {\n  matrix<element> a;\n\n  expect_empty(a);\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, zeros_ctor) {\n  constexpr size_t ROWS = 40;\n  constexpr size_t COLS = 100;\n  constexpr size_t SIZE = ROWS * COLS;\n\n  matrix<element> a(ROWS, COLS);\n\n  EXPECT_EQ(ROWS, a.rows());\n  EXPECT_EQ(COLS, a.cols());\n  EXPECT_EQ(SIZE, a.size());\n  EXPECT_FALSE(a.empty());\n  EXPECT_NE(nullptr, a.data());\n\n  for (size_t i = 0; i < ROWS; ++i) {\n    for (size_t j = 0; j < COLS; ++j) {\n      EXPECT_EQ(0, a(i, j));\n    }\n  }\n\n  expect_allocations(SIZE);\n}\n\nTEST_F(ctors_test, zeros_ctor_empty) {\n  matrix<element> a(0, 0);\n\n  expect_empty(a);\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, zeros_ctor_weird) {\n  matrix<element> a(10, 0);\n  expect_empty(a);\n\n  matrix<element> b(0, 10);\n  expect_empty(b);\n\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, init_ctor) {\n  matrix<element> a({\n      {10, 20, 30},\n      {40, 50, 60},\n  });\n\n  EXPECT_EQ(2, a.rows());\n  EXPECT_EQ(3, a.cols());\n  EXPECT_EQ(6, a.size());\n  EXPECT_FALSE(a.empty());\n  EXPECT_NE(nullptr, a.data());\n\n  EXPECT_EQ(10, a(0, 0));\n  EXPECT_EQ(20, a(0, 1));\n  EXPECT_EQ(30, a(0, 2));\n  EXPECT_EQ(40, a(1, 0));\n  EXPECT_EQ(50, a(1, 1));\n  EXPECT_EQ(60, a(1, 2));\n\n  expect_allocations(6);\n}\n\nTEST_F(ctors_test, copy_ctor) {\n  constexpr size_t ROWS = 40;\n  constexpr size_t COLS = 100;\n  constexpr size_t SIZE = ROWS * COLS;\n\n  matrix<element> a(ROWS, COLS);\n\n  expect_allocations(SIZE);\n\n  fill(a);\n\n  expect_allocations(SIZE);\n\n  matrix<element> b = a;\n\n  expect_equal(a, b);\n\n  expect_allocations(SIZE * 2);\n}\n\nTEST_F(ctors_test, copy_ctor_empty) {\n  matrix<element> a;\n  matrix<element> b = a;\n\n  expect_empty(a);\n  expect_empty(b);\n\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, copy_assignment) {\n  constexpr size_t ROWS_A = 40;\n  constexpr size_t COLS_A = 100;\n  constexpr size_t SIZE_A = ROWS_A * COLS_A;\n\n  constexpr size_t ROWS_B = 15;\n  constexpr size_t COLS_B = 15;\n  constexpr size_t SIZE_B = ROWS_B * COLS_B;\n\n  matrix<element> b(ROWS_B, COLS_B);\n\n  {\n    matrix<element> a(ROWS_A, COLS_A);\n\n    expect_allocations(SIZE_A + SIZE_B);\n\n    fill(a);\n\n    expect_allocations(SIZE_A + SIZE_B);\n\n    b = a;\n\n    expect_equal(a, b);\n\n    expect_allocations(SIZE_A * 2 + SIZE_B);\n  }\n\n  for (size_t i = 0; i < ROWS_A; ++i) {\n    for (size_t j = 0; j < COLS_A; ++j) {\n      EXPECT_EQ(elem(i, j), b(i, j));\n    }\n  }\n}\n\nTEST_F(ctors_test, self_copy_assignment) {\n  constexpr size_t ROWS = 40;\n  constexpr size_t COLS = 100;\n  constexpr size_t SIZE = ROWS * COLS;\n\n  matrix<element> a(ROWS, COLS);\n\n  expect_allocations(SIZE);\n\n  fill(a);\n\n  expect_allocations(SIZE);\n\n  a = a;\n\n  expect_allocations(SIZE);\n\n  for (size_t i = 0; i < ROWS; ++i) {\n    for (size_t j = 0; j < COLS; ++j) {\n      EXPECT_EQ(elem(i, j), a(i, j));\n    }\n  }\n}\n\nTEST_F(ctors_test, copy_assignment_empty) {\n  constexpr size_t ROWS_B = 40;\n  constexpr size_t COLS_B = 100;\n  constexpr size_t SIZE_B = ROWS_B * COLS_B;\n\n  matrix<element> a;\n  matrix<element> b(ROWS_B, COLS_B);\n  b = a;\n\n  expect_empty(a);\n  expect_empty(b);\n\n  expect_allocations(SIZE_B);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\nstruct Node{\n    int data;\n    Node* next;\n};\ntypedef struct Node* node;\n\nbool empty(node back){\n    return back == nullptr;\n}\nint getSize(node back){\n    int cnt = 0;\n    while(back != nullptr){\n        ++cnt;\n        back = back->next;\n    }\n    return cnt;\n}\nnode makeNode(int x){\n    node tmp = new Node();\n    tmp->data = x;\n    tmp->next = nullptr;\n    return tmp;\n}\n\nvoid push(node& back, int x){\n    node tmp =  makeNode(x);\n    tmp->next = back;\n    back = tmp;\n}\n\nvoid pop(node& back){\n    node truoc = nullptr;\n    node sau = back;\n    while(sau->next != nullptr){\n        truoc = sau;\n        sau = sau->next;\n    }\n    if(truoc == nullptr){\n        back = nullptr;\n    }else{\n        truoc->next = nullptr;\n    }\n}\n\nint front(node back){\n    while(back->next != nullptr){\n        back = back->next;\n    }\n    return back->data;\n}\n int main(){\n    node back = nullptr;\n    push(back, 6);\n    push(back, 8);\n    vector<int> lp;\n    while(1){\n        int top = front(back);pop(back);\n        string s = to_string(top);\n        if(s.size() == 9) break;\n        lp.push_back(top);\n        push(back, top * 10 + 6);\n        push(back, top * 10 + 8);\n    }\n    for(int x:lp){\n        cout<< x << \" \\n\";\n    }\n    return 0;\n }",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\n#include<fstream>\n#include<forward_list>\n#include<string>\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\nclass TaskNode\n{\n    private:\n        string title;\n        string description;\n        string dueDate;\n    public:\n        TaskNode(){}\n        TaskNode(string &title,string &description, string &dueDate)\n        {\n            this->title=title;\n            this->description=description;\n            this->dueDate=dueDate;\n        }\n        string getTitle() { return title;}\n        string getDescription() { return description;}\n        string getDueDate() { return dueDate;}\n        void printTask()\n        {\n            cout<<endl;\n            cout<<\" Task title: \"<<title<<endl;\n            cout<<\" Task Description: \"<<description<<endl;\n            cout<<\" Task Due Date: \"<<dueDate<<endl;\n        }\n};\nclass TaskManager\n{\n    private:\n        forward_list<TaskNode> tasks;\n        TaskManager(){ loadTasks();}\n        static bool isObjectCreated;\n    protected:\n        void loadTasks();\n        void unloadTasks();\n    public:\n        static TaskManager* getTaskManager()\n        {\n            if(isObjectCreated==false){\n                isObjectCreated=true;\n                return new TaskManager();\n            }\n            else\n                cout<<\"\\nYou can get only one task manager\"<<endl;\n            return nullptr;\n        }\n        int menu();\n        void addTask();\n        void deleteTask(string&);\n        void viewAllTasks();\n        ~TaskManager();\n\n};\nbool TaskManager::isObjectCreated=false;\nvoid TaskManager::loadTasks()\n{\n    tasks.clear();\n    ifstream fin;\n    string t,d,dd;\n    fin.open(\"mytasks.txt\",ios::in|ios::binary);\n    if(!fin)\n        cout<<\"Task Manager is empty\";\n    else\n    {\n        fin.ignore();\n        while(!fin.eof())\n        {\n            getline(fin,t);\n            getline(fin,d);\n            getline(fin,dd);\n            tasks.push_front(*(new TaskNode(t,d,dd)));\n        }\n    }\n    fin.close();\n\n}\nvoid TaskManager::unloadTasks()\n{\n    TaskNode temp;\n    ofstream fout;\n    if(!tasks.empty())\n    {\n        fout.open(\"mytasks.txt\",ios::out|ios::binary);\n        while(!tasks.empty())\n        {\n            temp=tasks.front();\n            fout<<'\\n'<<temp.getTitle();\n            fout<<'\\n'<<temp.getDescription();\n            fout<<'\\n'<<temp.getDueDate();\n            tasks.pop_front();\n        }\n        fout.close();\n    }\n    else\n        remove(\"mytasks.txt\");\n}\nint TaskManager::menu()\n{\n    int choice;\n    cout<<endl;\n    cout<<\"1. Add New Task\"<<endl;\n    cout<<\"2. Delete Task\"<<endl;\n    cout<<\"3. View All Tasks\"<<endl;\n    cout<<\"4. Exit\"<<endl;\n    cout<<\"Enter your choice: \";\n    cin>>choice;\n    return choice;\n}\nvoid TaskManager::addTask()\n{\n    string t,d,dd;    \n    cout<<\"\\nEnter task title:\"<<endl;\n    cin.ignore();\n    getline(cin,t);\n    cout<<\"Enter task description:\"<<endl;\n    getline(cin,d);\n    cout<<\"Enter due date: \"<<endl;\n    getline(cin,dd);\n    TaskNode newTask(t,d,dd);\n    tasks.push_front(newTask);\n    cout<<\"Task Added Successfully\"<<endl;\n}\nvoid TaskManager::deleteTask(string &t)\n{\n    forward_list<TaskNode>::iterator it,it1;\n    bool flag=true;\n    it=tasks.begin();\n    it1=tasks.before_begin();\n    \n    while(it!=tasks.end())\n    {\n        if(it->getTitle()==t)\n        {\n            tasks.erase_after(it1);\n            cout<<\"\\nTask deleted Successfully\"<<endl;\n            flag=false;\n            break;\n        }\n        it1=it++;\n    }\n    if(flag)\n        cout<<\"\\nTask not found\"<<endl;\n}\nvoid TaskManager::viewAllTasks()\n{\n    if(tasks.empty())\n        cout<<\"\\nNo Task in the task manager\";\n    else\n        for(auto task:tasks)\n            task.printTask();\n    char x;\n    cout<<\"\\nEnter any key to proceed:\";\n    cin>>x;\n}\nTaskManager::~TaskManager()\n{\n    unloadTasks();\n    isObjectCreated=false;\n}\nint main()\n{\n    TaskManager *tm;\n    tm=TaskManager::getTaskManager();\n    string temp;\n    while(true)\n    {\n        system(\"cls\");\n        switch(tm->menu())\n        {\n            case 1:\n                tm->addTask();\n                break;\n            case 2:\n                cout<<\"\\nEnter title of the task to delete: \";\n                cin.ignore();\n                getline(cin,temp);\n                tm->deleteTask(temp);\n                break;\n            case 3:\n                tm->viewAllTasks();\n                break;\n            case 4:\n                delete tm;\n                exit(0);\n            default:\n                cout<<\"\\nInvalid choice, retry\";\n        }\n        getchar();\n        fflush(stdin);\n    }\n}\n",
    "//\n//  neural_network.cpp\n//  neural-network\n//\n//  Created by Hugh Drummond on 11/4/2024.\n//\n\n#include \"neural_network.hpp\"\n\nNeuralNetwork::NeuralNetwork(int inputNodes, std::vector<int> hiddenLayerSizes, int outputNodes)\n    : sizes({inputNodes}) {\n        sizes.insert(sizes.end(), hiddenLayerSizes.begin(), hiddenLayerSizes.end());\n        sizes.push_back(outputNodes);\n        \n        for (size_t i = 0; i < sizes.size() - 1; ++i) {\n            Matrix weightMatrix(sizes[i + 1], sizes[i] + 1);\n            weightMatrix.randomize();\n            weights.push_back(weightMatrix);\n        }\n}\n\ndouble NeuralNetwork::sigmoid(double x) {\n    return 1 / (1 + exp(-x));\n}\n\ndouble NeuralNetwork::dsigmoid(double x) {\n    return sigmoid(x) * (1 - sigmoid(x));\n}\n\nstd::vector<int> NeuralNetwork::randomOrder(size_t n) {\n    std::vector<int> numbers(n);\n    for (int i = 0; i < n; ++i) {\n        numbers[i] = i;\n    }\n    std::vector<int>& arr = numbers;\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    for (int i = (unsigned)arr.size() - 1; i > 0; --i) {\n        std::uniform_int_distribution<int> dist(0, i);\n        int j = dist(gen);\n        std::swap(arr[i], arr[j]);\n    }\n    return numbers;\n}\n\n/**\n * Performs feedforward propagation to calculate the output of the neural network given input values.\n * Precondtions:\n *  - input.size() == this.inputNodes\n * Parameters:\n *  - values: A vector containing the input values to be fed into the neural network.\n * Returns:\n *  - Matrix: The output of the neural network after performing feedforward propagation. (n x 1)\n */\nMatrix NeuralNetwork::feedForward(std::vector<double> input) {\n    if (input.size() != sizes.front()) {\n        std::cerr << \"ERROR: feedforward input.size() != this.inputNodes\" << std::endl;\n        return Matrix();\n    }\n    // Create n x 1 input matrix\n    std::vector<std::vector<double>> data({});\n    for (int i = 0; i < input.size(); ++i) {\n        data.push_back(std::vector<double>({input[i]}));\n    }\n    \n    activations.clear();\n    // Calculate activations through forward feed\n    Matrix activation(data);\n    for (int i = 0; i < weights.size(); ++i) {\n        activation.appendRow(1); // Bias\n        activations.push_back(activation);\n//        std::cout << \"\\tLayer \" << i << \" activation\" << std::endl << activation << std::endl;\n        activation = weights[i] * activation;\n        activation.map(sigmoid);\n    }\n    activations.push_back(activation);\n\n    return activation;\n}\n\nvoid NeuralNetwork::backPropogate(Matrix result,\n                                  std::vector<double> expected, double learningRate) {\n    if (expected.size() != sizes.back()) {\n        std::cerr << \"ERROR: feedforward expected.size() != this.outputNodes\" << std::endl;\n        return;\n    }\n    // Calculate Errors\n    std::vector<std::vector<double>> data({});\n    for (int i = 0; i < expected.size(); ++i) {\n        data.push_back(std::vector<double>({expected[i]}));\n    }\n    std::vector<Matrix> errors({});\n    Matrix error = Matrix(data) - result;\n    errors.push_back(error);\n//    std::cout << \"\\tError 0:\\n\" << error << std::endl;\n    \n    for (int i = 1; i < weights.size(); ++i) {\n        Matrix weight = weights[weights.size()-i].transpose();\n        weight.popRow(); // Bias\n        error = weight * error;\n        errors.push_back(error);\n//        std::cout << \"\\tError \" << i << \":\\n\" << error << std::endl;\n        \n    }\n    \n    // Calculate Gradiate\n    for (int i = 0; i < errors.size(); ++i) {\n        Matrix row = activations[activations.size()-1-i];\n        if (i != 0) {\n            row.popRow(); // Bias\n        }\n        row.map(dsigmoid);\n        row = row.elemntWiseMultiply(errors[i]);\n        row.scalarMultiply(learningRate);\n        // Update Bias\n        for (int j = 0; j < row.numRows(); ++j) {\n            int k = weights[weights.size()-1-i].numCols() - 1;\n            weights[weights.size()-1-i](j,k) += row(j,0);\n        }\n        \n        // Update Weights\n        Matrix activation = activations[activations.size()-2-i];\n        activation.popRow(); // Bias\n        row = row * (activation.transpose());\n        for (int j = 0; j < row.numRows(); ++j) {\n            for (int k = 0; k < row.numCols(); ++ k) {\n                weights[weights.size()-1-i](j,k) += row(j,k);\n            }\n        }\n//        std::cout << row << std::endl;\n    }\n    \n    return;\n}\n\nvoid NeuralNetwork::train(std::vector<std::vector<double>> inputs,\n                          std::vector<std::vector<double>> outputs, double learningRate) {\n    int epoch = 10000;\n    for (int e = 0; e < epoch; ++e) {\n        std::vector<int> order = randomOrder(inputs.size());\n        for (int i = 0; i < inputs.size(); ++i) {\n            Matrix result = feedForward(inputs[order[i]]);\n            backPropogate(result, outputs[order[i]], learningRate);\n        }\n    }\n}\n\nstd::ostream& operator<<(std::ostream& os, const NeuralNetwork& network) {\n    \n    os << \"Neural Network:\" << std::endl;\n    os << \"  Lay",
    "#include \"VisualizerNodeDrawOverride.h\"\n\n#include <maya/MDistance.h>\n#include <maya/MFnUnitAttribute.h>\n\n// Viewport 2.0 includes\n#include <maya/MDrawRegistry.h>\n#include <maya/MPxDrawOverride.h>\n#include <maya/MUserData.h>\n#include <maya/MDrawContext.h>\n#include <maya/MHWGeometryUtilities.h>\n#include <maya/MPointArray.h>\n#include <maya/MGlobal.h>\n#include <maya/MEventMessage.h>\n#include <maya/MFnDependencyNode.h>\n#include <maya/MFnPointArrayData.h>\n\n#include <assert.h>\n\n\n// By setting isAlwaysDirty to false in MPxDrawOverride constructor, the\n// draw override will be updated (via prepareForDraw()) only when the node\n// is marked dirty via DG evaluation or dirty propagation. Additional\n// callback is also added to explicitly mark the node as being dirty (via\n// MRenderer::setGeometryDrawDirty()) for certain circumstances. Note that\n// the draw callback in MPxDrawOverride constructor is set to NULL in order\n// to achieve better performance.\nVisualizerNodeDrawOverride::VisualizerNodeDrawOverride(const MObject& obj)\n: MHWRender::MPxDrawOverride(obj, NULL, true)\n{\n    fModelEditorChangedCbId = MEventMessage::addEventCallback(\n        \"modelEditorChanged\", OnModelEditorChanged, this);\n\n    MStatus status;\n    MFnDependencyNode node(obj, &status);\n    fVisualizerNode = status ? dynamic_cast<VisualizerNode*>(node.userNode()) : NULL;\n}\n\nVisualizerNodeDrawOverride::~VisualizerNodeDrawOverride()\n{\n    fVisualizerNode = NULL;\n\n    if (fModelEditorChangedCbId != 0)\n    {\n        MMessage::removeCallback(fModelEditorChangedCbId);\n        fModelEditorChangedCbId = 0;\n    }\n}\n\nvoid VisualizerNodeDrawOverride::OnModelEditorChanged(void *clientData)\n{\n    // Mark the node as being dirty so that it can update on display appearance\n    // switch among wireframe and shaded.\n    VisualizerNodeDrawOverride *ovr = static_cast<VisualizerNodeDrawOverride*>(clientData);\n    if (ovr && ovr->fVisualizerNode)\n    {\n        MHWRender::MRenderer::setGeometryDrawDirty(ovr->fVisualizerNode->thisMObject());\n    }\n}\n\nMHWRender::DrawAPI VisualizerNodeDrawOverride::supportedDrawAPIs() const\n{\n    // this plugin supports both GL and DX\n    return (MHWRender::kOpenGL | MHWRender::kDirectX11 | MHWRender::kOpenGLCoreProfile);\n}\n\nfloat VisualizerNodeDrawOverride::getMultiplier(const MDagPath& objPath) const\n{\n    // Retrieve value of the size attribute from the node\n    MStatus status;\n    MObject visNode = objPath.node(&status);\n    if (status)\n    {\n        MPlug plug(visNode, VisualizerNode::size);\n        if (!plug.isNull())\n        {\n            MDistance sizeVal;\n            if (plug.getValue(sizeVal))\n            {\n                return (float)sizeVal.asCentimeters();\n            }\n        }\n    }\n\n    return 1.0f;\n}\n\nbool VisualizerNodeDrawOverride::isBounded(const MDagPath& /*objPath*/,\n                                      const MDagPath& /*cameraPath*/) const\n{\n    return true;\n}\n\nMBoundingBox VisualizerNodeDrawOverride::boundingBox(\n    const MDagPath& objPath,\n    const MDagPath& cameraPath) const\n{\n    MPoint corner1( -0.17, 0.0, -0.7 );\n    MPoint corner2( 0.17, 0.0, 0.3 );\n\n    float multiplier = getMultiplier(objPath);\n    corner1 = corner1 * multiplier;\n    corner2 = corner2 * multiplier;\n\n    return MBoundingBox( corner1, corner2 );\n}\n\n// Called by Maya each time the object needs to be drawn.\nMUserData* VisualizerNodeDrawOverride::prepareForDraw(\n    const MDagPath& objPath,\n    const MDagPath& cameraPath,\n    const MHWRender::MFrameContext& frameContext,\n    MUserData* oldData)\n{\n    // Any data needed from the Maya dependency graph must be retrieved and cached in this stage.\n    // There is one cache data for each drawable instance, if it is not desirable to allow Maya to handle data\n    // caching, simply return null in this method and ignore user data parameter in draw callback method.\n    // e.g. in this sample, we compute and cache the data for usage later when we create the \n    // MUIDrawManager to draw footprint in method addUIDrawables().\n    FootPrintData* data = dynamic_cast<FootPrintData*>(oldData);\n    if (!data)\n    {\n        data = new FootPrintData();\n    }\n    \n    float fMultiplier = getMultiplier(objPath);\n\n    data->fLineList.clear();\n\n    MStatus status; \n    MFnDependencyNode fNode; \n    fNode.setObject(objPath.node());\n\n    MPlug lineDataPlug = fNode.findPlug(\"lineData\", true, &status);\n\n    if (status) {\n        MObject lineDataObj = lineDataPlug.asMObject(); \n        if (lineDataObj.hasFn(MFn::Type::kPointArrayData)) {\n            MFnPointArrayData fPointArrayData; \n            fPointArrayData.setObject(lineDataObj); \n            MPointArray lineList = fPointArrayData.array();\n\n\n            for (int i = 0; i < lineList.length(); i += 2) {\n                data->fLineList.append(lineList[i] * fMultiplier);\n                data->fLineList.append(lineList[i + 1] * fMultiplier);\n            }\n        }\n    }\n\n#if 0\n    for (int i = 0; i <= soleCount - 2; i++)\n    {\n        data->fLineList.append(sole[i][0] *",
    "#include <iostream>\n#include <windows.h>\n#include \"Queue.h\"\n#include \"Stack.h\"\n#include <locale>\n#include <ctime>\n#include <io.h>\n#include <fcntl.h>\nusing namespace std;\n\nint main(int argc, wchar_t* argv[])\n{\n    _setmode(_fileno(stdout), _O_U16TEXT);\n    _setmode(_fileno(stdin),  _O_U16TEXT);\n    _setmode(_fileno(stderr), _O_U16TEXT);\n\n  Queue bigQ(100);\n  Queue smallQ(4);\n  Stack S(100);\n  char ch;\n  int i;\n\n  for (i=0; i<26; i++)\n    bigQ.put('A'+i);\n\n  wcout << L\"\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 bigQ: \";\n  for (i=0; i<26; i++){\n    ch = bigQ.get();\n    if (ch != 0) wcout << ch << L\" \";\n  }\n\n  wcout << L\"\\n\\n\";\n\n  wcout << L\"\u041f\u044b\u0442\u0430\u0435\u043c\u0441\u044f \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c: \";\n  for (i=0; i<5; i++){\n    wcout << L\" \" <<  (char) ('Z' - i);\n    smallQ.put('Z' - i);\n  }\n\n  wcout << L\"\\n\";\n\n  wcout << L\"\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 smallQ: \";\n  for (i = 0; i < 5; i++){\n    ch = smallQ.get();\n\n    if (ch != 0) wcout << ch << L\" \";\n  }\n\n  wcout << endl;\n\n  for (i=0; i<27; i++)\n    S.put('A' + i);\n\n  wcout << L\"\\n\";\n  wcout << L\"\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 S: \";\n  for (i=0; i<27; i++){\n    ch = S.get();\n    if (ch != 0) wcout << ch << L\" \";\n  }\n\n  return 0;\n}",
    "// Created by Antonio \"Antoniowski\" Romano\n\n/*\\\n    Class used to abstract the database and its logics.\n    Every operation to do on the database will be filtered by the database class.\n*/\n\n\n#include \"database.h\"\n\nDatabase* Database::_instance = nullptr;\n\nDatabase::Database()\n{\n}\n\n/**\n * Cannot create a database object. A new database class can be only be created\n * by using the getInstance method.\n * \n */\n\nDatabase::Database(const Database& database) = delete;\n\nDatabase::~Database()\n{\n\n}\n\n\nDatabase* Database::getInstance()\n{\n    if(_instance == nullptr)\n        _instance = new Database();\n\n    return _instance;\n}\n\nbool Database::connect()\n{\n    //Connect to the local database\n    int rc;\n    rc = sqlite3_open(\"./localdata.db\", &sqlite_db);\n    if(rc)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nbool Database::disconnect()\n{\n    //Disconnect from the database\n\n    if(sqlite3_close(sqlite_db))\n        return true;\n\n    return false;\n    \n}\n\nvoid Database::drop_table()\n{\n    //Delete all tables in database.\n\n    connect();\n    std::string query_basis = \"DROP TABLE IF EXISTS \";\n    std::vector<std::string> tables = {\"LOGIN\", \"PASSWORDS\", \"PATH\"};\n    for(std::string t: tables)\n    {\n        sqlite3_exec(sqlite_db, (query_basis+t+\";\").c_str(), NULL, NULL, NULL);\n    }\n    disconnect();\n\n}\n\nvoid Database::create_tables()\n{\n    connect();    \n    sqlite3_exec(sqlite_db, LOGIN_CREATE_SCHEMA.c_str(), NULL, NULL, NULL);\n    sqlite3_exec(sqlite_db, PATH_CREATE_SCHEMA.c_str(), NULL, NULL, NULL);\n    sqlite3_exec(sqlite_db, PASSWORDS_CREATE_SCHEMA.c_str(), NULL, NULL, NULL);\n    disconnect();\n}\n\nvoid Database::first_init()\n{\n    drop_table();\n    create_tables();\n}\n\nvoid Database::init()\n{\n    connect();\n    \n    disconnect();\n}\n\nbool Database::insert(std::string table, std::vector<std::string> colums, std::vector<std::string> values)\n{\n    if(colums.size() > values.size())\n        return false;\n    \n    connect();\n    \n    std::string query_basis_1 = \"INSERT INTO \";\n    std::string query_basis_2 = \") VALUES(\";\n    std::string query_basis_3 = \");\";\n    std::string colums_string = \"\";\n    std::string values_string = \"\";\n    \n    for(int i=0; i<colums.size(); i++)\n    {\n        colums_string += colums.at(i);\n        values_string += \"'\"+values.at(i)+\"'\";\n        if(i != colums.size()-1)\n        {            \n            colums_string += \", \";\n            values_string += \", \";\n            continue;\n        }\n    }\n    std::string query = query_basis_1+table+\"(\"+colums_string+query_basis_2+values_string+query_basis_3;\n    sqlite3_exec(sqlite_db, query.c_str(), NULL,NULL,NULL);\n\n    disconnect();\n    return true;\n}\n\nstd::string Database::get_value(std::string column, std::string table, std::string where_condition)\n{\n    std::string query_1 = \"SELECT \";\n    std::string queey_2 = \" FROM \";\n    std::string query_3 = \" WHERE \";\n    std::string query;\n    if(where_condition != \"\")\n    {\n        query = query_1 + column + queey_2 + table + query_3 + where_condition + \";\";\n    }else{\n        query = query_1 + column + queey_2 + table + \";\";\n    }\n\n    connect();\n    sqlite3_stmt* statement;\n    const void* result;\n    int rc = sqlite3_prepare_v2(sqlite_db, query.c_str(),query.length(),&statement, nullptr);\n    if(rc != SQLITE_OK)\n    {\n        disconnect();\n        return \"Error\\n\";\n    }\n\n    std::string x = \"\";\n    while ((rc = sqlite3_step(statement)) == SQLITE_ROW)\n    {\n        result = sqlite3_column_text(statement, 0);\n        std::string string_result(static_cast<char const *>(result));\n        x = string_result;\n    }\n    sqlite3_finalize(statement);\n    disconnect();\n    return x;\n}\n\nstd::vector<std::tuple<std::string, std::string,std::string>> Database::get_password_rows(std::string service_name)\n{\n    /**\n     * Returns a password row with service, password and last update date.\n     * If service_name is \"\" (empty) returns all the password rows.\n     * \n     * \n     * If there is an aerroe with the query statement return a vector with only one tuple. The error tuple\n     * contains only ERROR as values.\n    */\n    std::string query_1 = \"SELECT * FROM PASSWORDS\";\n    std::string query_2 = \" WHERE SERVICE = \";\n    std::string query_end= \";\";\n    std::string query = \"\";\n    if(service_name != \"\")\n    {\n        query = query_1 + query_2 + \"'\"+service_name+\"'\"+query_end;\n    }else{\n        query = query_1 + query_end;\n    }\n\n    connect();\n    sqlite3_stmt* statement;\n    int rc = sqlite3_prepare_v2(sqlite_db, query.c_str(),query.length(),&statement, nullptr);\n    if(rc != SQLITE_OK)\n    {\n        disconnect();\n        std::tuple<std::string, std::string, std::string> error_tuple = std::make_tuple(\"ERROR\", \"ERROR\", \"ERROR\");\n        std::vector<std::tuple<std::string, std::string, std::string>> error_vector = {error_tuple};\n        return error_vector;\n    }\n\n    const void* result;\n    std::string username = \"\";\n    std::string password = \"\";\n    std::string last_update = \"\";\n    std::tuple<std::string,std::stri",
    "#include \"/opt/homebrew/Cellar/freeglut/3.4.0/include/GL/glut.h\"\n#include \"/opt/homebrew/Cellar/glfw/3.4/include/GLFW/glfw3.h\"\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT);\n\n  //house\n    glBegin(GL_QUADS); \n    glColor3f(1.0, 0.0, 0.0); \n    glVertex2f(-0.5f, -0.5f); //lb\n    glVertex2f(0.5f, -0.5f);  //rb\n    glVertex2f(0.5f, 0.0f);   //rt\n    glVertex2f(-0.5f, 0.0f);  //lt\n    glEnd();\n\n  //roof\n    glBegin(GL_TRIANGLES); \n    glColor3f(0.0, 0.0, 0.0); \n    glVertex2f(-0.5f, 0.0f);  \n    glVertex2f(0.5f, 0.0f);   \n    glVertex2f(0.0f, 0.5f);   \n    glEnd();\n\n\n  //door\n   glBegin(GL_QUADS);\n    glColor3f(0.0, 1.0, 0.0);\n    glVertex2f(-0.1f, -0.5f); //lb\n    glVertex2f(0.1f, -0.5f); //rb\n    glVertex2f(0.1f, -0.2f); //rt\n    glVertex2f(-0.1f, -0.2f); //lt\n    glEnd();\n\n    glFlush(); \n}\n\nvoid init() {\n    glClearColor(1.0, 1.0, 1.0, 1.0);\n    glColor3f(0.0, 0.0, 0.0);    \n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowSize(500, 500);\n    glutInitWindowPosition(100, 100); \n    glutCreateWindow(\"Simple 2D House in OpenGL\");\n    init();\n    glutDisplayFunc(display);\n    glutMainLoop();\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <string>\n#include <regex>\n#include <vector>\n\nusing namespace std;\n\n// Token structure\nstruct Token {\n    string type;\n    string lexeme;\n    int line;\n};\n\nvector<Token> tokenize(const string& code) {\n    vector<Token> tokens;\n    // Define regular expressions for tokens\n    string reservedword = \"\\\\b(int|float|void|cin|cout|continue|break|#include|using|namespace|std|main|if|else|while|for|return)\\\\b\";\n    string identifier = \"\\\\b[a-zA-Z][a-zA-Z0-9]*\\\\b\";\n    string digit = \"\\\\b[0-9]\\\\b\";\n    string number = \"\\\\b[0-9]+(?:\\\\.[0-9]+)?\\\\b\";\n    string stringsPattern = R\"(\".*?\")\";\n    string symbol = \"\\\\b[(|)|{|}|\\\\[|\\\\]|,|;|+|-|*|/|==|!=|>|>=|<|<=|=|&&|\\\\|\\\\||<<|>>]\\\\b\";\n    string whitespacePattern = \"\\\\s+\";\n\n    // Combine regular expressions into one\n    string tokenRegexStr = \"(\" + reservedword + \"|\" + identifier + \"|\" + digit + \"|\" + number + \"|\" + stringsPattern + \"|\" + symbol + \"|\" + whitespacePattern + \")\";\n    regex tokenRegex(tokenRegexStr);\n\n    // Tokenization process\n    smatch match;\n    int lineNumber = 1;\n    string::const_iterator start = code.begin();\n    string::const_iterator end = code.end();\n    while (regex_search(start, end, match, tokenRegex)) {\n        if (!regex_match(match[0].str(), regex(whitespacePattern))) {\n            Token token;\n            token.lexeme = match[0];\n            token.line = lineNumber;\n            // Determine token type\n            if (regex_match(token.lexeme, regex(reservedword)))\n                token.type = \"Reservedword\";\n            else if (regex_match(token.lexeme, regex(identifier)))\n                token.type = \"Identifier\";\n            else if (regex_match(token.lexeme, regex(digit)))\n                token.type = \"Digit\";\n            else if (regex_match(token.lexeme, regex(number)))\n                token.type = \"Number\";\n            else if (regex_match(token.lexeme, regex(stringsPattern)))\n                token.type = \"String\";\n            else if (regex_match(token.lexeme, regex(symbol)))\n                token.type = \"Symbol\";\n            tokens.push_back(token);\n        }\n\n        start = match.suffix().first;\n        // Count lines\n        while (start != end && (*start == '\\n' || *start == '\\r')) {\n            if (*start == '\\n') lineNumber++;\n            ++start;\n        }\n    }\n    return tokens;\n}\n\nint main() {\n    string code = R\"(\n        #include <iostream>\n        using namespace std;\n        int main(){\n          int x;\n          int s=0, t=10;\n          while (t >= 0){\n           cin>>x;\n           t = t - 1;\n           s = s + x;\n        }\n        cout<<\"sum=\"<<s;\n        return 0;\n    }\n    )\";\n    vector<Token> tokens = tokenize(code);\n    for (const auto& token : tokens) {\n        cout << \"Type: \" << token.type << \", Lexeme: \" << token.lexeme << \", Line: \" << token.line << endl;\n    }\n    return 0;\n}",
    "#include \"cerberus.h\"\n#include <chrono>\n#include <cstdarg>\n#include <cstring>\n#include <deque>\n#include <dirent.h>\n#include <string>\n#include <thread>\n\ntypedef uint8_t byte;\ntypedef bool boolean;\n#define F(a) (a)\n\nchar* autoloadBinaryFilename = nullptr;\n\nint load(std::string filename, unsigned int startAddr);\nbool SD_exists(std::string& filename);\nFILE* SD_open(std::string& filename, const char* mode);\n\nvoid runCode();\n\n/** Next is the string in CAT's internal memory containing the edit line, **/\n/** intialized in startup.                              **/\nvolatile char editLine[38];\nvolatile char previousEditLine[38];\nvolatile uint16_t bytesRead;\n\n/** The above is self-explanatory: it allows for repeating previous command **/\nvolatile byte pos = 1; /** Position in edit line currently occupied by cursor **/\nvolatile bool mode = false; /** false = 6502 mode, true = Z80 mode**/\nvolatile bool cpurunning = false; /** true = CPU is running, CAT should not use the buses **/\nvolatile bool interruptFlag = false; /** true = Triggered by interrupt **/\nvolatile bool fast = true; /** true = 8 MHz CPU clock, false = 4 MHz CPU clock **/\nvolatile bool expflag = false;\nvoid (*resetFunc)(void) = 0; /** Software reset fuction at address 0 **/\n\n/** Compilation defaults **/\n#define config_dev_mode 0 // Turn off various BIOS outputs to speed up development, specifically uploading code\n#define config_silent 0 // Turn off the startup jingle\n#define config_enable_nmi 1 // Turn on the 50hz NMI timer when CPU is running. If set to 0 will only trigger an NMI on keypress\n#define config_outbox_flag 0x0200 // Outbox flag memory location (byte)\n#define config_outbox_data 0x0201 // Outbox data memory location (byte)\n#define config_inbox_flag 0x0202 // Inbox flag memory location (byte)\n#define config_inbox_data 0x0203 // Inbox data memory location (word)\n#define config_code_start 0x0205 // Start location of code\n#define config_eeprom_address_mode 0 // First EEPROM location\n#define config_eeprom_address_speed 1 // Second EEPROM location\n\n/* Status constants */\n#define STATUS_DEFAULT 0\n#define STATUS_BOOT 1\n#define STATUS_READY 2\n#define STATUS_UNKNOWN_COMMAND 3\n#define STATUS_NO_FILE 4\n#define STATUS_CANNOT_OPEN 5\n#define STATUS_MISSING_OPERAND 6\n#define STATUS_SCROLL_PROMPT 7\n#define STATUS_FILE_EXISTS 8\n#define STATUS_ADDRESS_ERROR 9\n#define STATUS_POWER 10\n#define STATUS_EOF 11\n\nconst uint8_t chardefs[] = {\n    0x5a, 0x99, 0xe7, 0x5e, 0x5e, 0x24, 0x18, 0x66, 0xf0, 0xf0, 0xf0, 0xf0,\n    0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00,\n    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,\n    0x0f, 0x0f, 0x0f, 0x0f, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff,\n    0xf0, 0xf0, 0xf0, 0xf0, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,\n    0x00, 0x00, 0x00, 0x00, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,\n    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,\n    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff,\n    0x7e, 0x66, 0x66, 0x66, 0x00, 0x08, 0x0c, 0xff, 0xff, 0x0c, 0x08, 0x00,\n    0x00, 0x10, 0x30, 0xff, 0xff, 0x30, 0x10, 0x00, 0x18, 0x18, 0x3c, 0x7e,\n    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x18,\n    0x7e, 0x99, 0x99, 0xff, 0xff, 0x99, 0x99, 0x7e, 0x18, 0x24, 0x42, 0x99,\n    0x99, 0x42, 0x24, 0x18, 0x00, 0x24, 0x24, 0x00, 0x81, 0x42, 0x3c, 0x00,\n    0x00, 0x24, 0x24, 0x00, 0x3c, 0x42, 0x81, 0x00, 0x3c, 0x7e, 0x99, 0xff,\n    0xe7, 0x7e, 0x3c, 0x66, 0x3c, 0x7e, 0x99, 0xdd, 0xff, 0xff, 0xff, 0xdb,\n    0x3c, 0x42, 0x84, 0x88, 0x88, 0x84, 0x42, 0x3c, 0x42, 0x24, 0x7e, 0xdb,\n    0xff, 0xbd, 0xa5, 0x18, 0x18, 0x3c, 0x3c, 0x7e, 0x7e, 0xff, 0x99, 0x18,\n    0x00, 0x80, 0xe0, 0xbc, 0xff, 0x78, 0x60, 0x00, 0x00, 0x00, 0x24, 0x18,\n    0x18, 0x24, 0x00, 0x00, 0x81, 0x42, 0x24, 0x00, 0x00, 0x24, 0x42, 0x81,\n    0x00, 0x00, 0x3c, 0xc3, 0xc3, 0x3c, 0x00, 0x00, 0x18, 0x18, 0x24, 0x24,\n    0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00, 0x00, 0x24, 0x24, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x7e, 0x24, 0x24, 0x7e, 0x24, 0x00,\n    0x00, 0x08, 0x3e, 0x28, 0x3e, 0x0a, 0x3e, 0x08, 0x00, 0x62, 0x64, 0x08,\n    0x10, 0x26, 0x46, 0x00, 0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,\n    0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x08,\n    0x08, 0x08, 0x04, 0x00, 0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,\n    0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00, 0x00, 0x00, 0x08, 0x08,\n    0x3e, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,\n    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00,\n    0x00, 0x3c, 0x46, 0x4a, 0x52, 0x62, 0x3c, 0x00, 0x00, 0x18, 0x28, 0x08,\n    0x08, 0x08, 0x3e, 0x00, 0x00, 0x3c, 0x42, 0x02, 0x3c, 0x40, 0x7e, 0x0",
    "// dear imgui, v1.85 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowMisc()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includes\n#include <ctype.h>          // toupp",
    "#include<iostream>\nusing namespace std;\n\nint main(){\n\n\n// Square\n  // outer loop -> Rows\n  // for(int i=0; i<4; i=i+1){\n\n  //   // Print 4 Stars\n  // for(int j=0; j<4; j=j+1){\n  //   cout<< \"*\";\n  // }\n  // cout<< endl;\n  // }\n\n\n// // Rectangle\n//   for(int i=0; i<3; i=i+1){\n//   for(int j=0; j<6; j=j+1){\n//     cout<< \"*\";\n//   }\n//   cout<< endl;\n//   }\n\n\n// Hollow Rectangle\n// Outer loop\n  // for(int row=0; row<5; row=row+1){\n  //   // inner loop\n  // for(int col=0; col<5; col=col+1){\n  //   // if zeroth or last row, then print star\n  //   if(row == 0 || row == 4){\n  //     cout<< \"*\";\n  //   }\n  //    else{\n  //     if(col == 0 || col == 4){\n  //       cout<< \"*\";\n  //     }\n  //     else{\n  //       cout<< \" \";\n  //     }\n  //    }\n  // }\n  // cout<< endl;\n  // }\n\n\n  // int n;\n  // cin>> n;\n  // // Half Pyramid\n  // for(int row=0; row<n; row=row+1){\n  // for(int col=0; col<row+1; col=col+1){\n  //   cout<< \"*\";\n  // }\n  // cout<< endl;\n  // }\n\n  // Inverted Half Pyramid\n  // int n;\n  // cin>> n;\n  // for(int row=0; row<n; row=row+1){\n  // for(int col=0; col<n-row; col=col+1){\n  //   cout<< \"*\";\n  // }\n  // cout<< endl;\n  // }\n\n\n// Numeric Half Pyramid\n//    int n;\n//   cin>> n;\n//   for(int row=0; row<n; row=row+1){\n//   for(int col=0; col<row+1; col=col+1){\n//     cout<< col+1 << \"\";\n//   }\n//   cout<< endl;\n//   }\n// }\n\n\n\n// Pyramid \n//   int n;\n//   cin>> n;\n\n//   for(int row=0; row<n; row=row+1){\n//   for(int col=0; col<n-row-1; col=col+1){\n//     cout<< \" \";\n//   }\n\n//   for(int col=0; col<row+1; col=col=col+1){\n//     cout<< \"* \";\n//   }\n\n//   cout<< endl;\n//   }\n\n//   return 0;\n// }\n\n int n;\n  cin>> n;\n\n  for(int row=0; row<n; row=row+1){\n  for(int col=0; col<n-row-1; col=col+1){\n    cout<< \" \";\n  }\n\n  for(int col=0; col<row+1; col=col=col+1){\n    cout<< \"* \";\n  }\n\n  cout<< endl;\n  }\n\n  return 0;\n}\n",
    "#include \"ApcGpu.hpp\"\n#include <iostream>\n#include <limits>\n#include <stdlib.h>\n#include <vector>\n\n#include \"Kernels.cuh\"\n\n#include \"cuda_runtime.h\"\n#include \"device_launch_parameters.h\"\n\nApcGpu::ApcGpu(float* points, int pointCount, int pointDimension, float dampingFactor)\n{\n\tif (pointCount <= 0)\n\t{\n\t\tstd::cout << \"Point count is not positive!\\n\";\n\t\texit(-1);\n\t}\n\tm_pointCount = pointCount;\n\n\tif (pointDimension <= 0)\n\t{\n\t\tstd::cout << \"Point dimension is not positive!\\n\";\n\t\texit(-1);\n\t}\n\tm_pointDimension = pointDimension;\n\n\tif (dampingFactor < 0 || dampingFactor > 1)\n\t{\n\t\tstd::cout << \"Damping factor outside the range!\\n\";\n\t\texit(-1);\t\n\t}\n\tm_dampingFactor = dampingFactor;\n\n\tcudaMallocManaged((void**)&m_points, 4 * m_pointCount * m_pointDimension);\n    cudaMallocManaged((void**)&m_similarity, 4 * m_pointCount * m_pointCount);\n    cudaMallocManaged((void**)&m_responsibility, 4 * m_pointCount * m_pointCount);\n    cudaMallocManaged((void**)&m_availability, 4 * m_pointCount * m_pointCount);\n\n\tmemcpy(m_points, points, 4 * m_pointCount * m_pointDimension);\n}\n\nApcGpu::~ApcGpu()\n{\n    cudaFree(m_points);\n    cudaFree(m_similarity);\n    cudaFree(m_responsibility);\n    cudaFree(m_availability);\n}\n\nvoid ApcGpu::cluster(int iterations)\n{\n\tupdateSimilarity();\n\tfor (int iter = 0; iter < iterations; iter++)\n\t{\n\t\tupdateResponsibility();\n\t\tupdateAvailability();\n\t}\n\tcudaDeviceSynchronize();\n\tlabelPoints();\n}\n\nvoid ApcGpu::updateSimilarity()\n{\n    // Run 1024 = 32*32 threads per block\n    int threadCount = 32;\n    // Calculate block count\n    int blockCount = ((m_pointCount - 1)/ 32) + 1;\n\n    // Call 2D similarity kernel\n\tlaunchKernel_updateSimilarity(blockCount, threadCount, m_points, m_similarity, m_pointCount, m_pointDimension);\n}\n\nvoid ApcGpu::updateResponsibility()\n{\n\t// Run 1024 = 32*32 threads per block\n    int threadCount = 32;\n    // Calculate block count\n    int blockCount = ((m_pointCount - 1)/ 32) + 1;\n\tlaunchKernel_updateResponsibility(blockCount, threadCount, m_similarity, m_responsibility, m_availability, m_pointCount, m_dampingFactor);\n}\n\nvoid ApcGpu::updateAvailability()\n{\n\t// Run 1024 = 32*32 threads per block\n    int threadCount = 32;\n    // Calculate block count\n    int blockCount = ((m_pointCount - 1)/ 32) + 1;\n\tlaunchKernel_updateAvailability(blockCount, threadCount, m_similarity, m_responsibility, m_availability, m_pointCount, m_dampingFactor);\n}\n\nvoid ApcGpu::labelPoints()\n{\n\t// TODO: Can switch this to GPU as well. Currently in CPU.\n\n\t// Find all exemplar points by checking the criteria\n\tstd::vector<int> exemplars;\n\tfor (int i = 0; i < m_pointCount; i++)\n\t{\n\t\tfloat criteria = m_availability[m_pointCount * i + i] + m_responsibility[m_pointCount * i + i];\n\t\tstd::cout << \"A + R for \" << i << \": \" << criteria << \"\\n\";\n\t\tif (criteria > 0)\n\t\t\texemplars.push_back(i);\n\t}\n\n\t// Label all points and print\n\tfor (int i = 0; i < m_pointCount; i++)\n\t{\n\t\t// Find max similarity to an exemplar per point\n\t\tfloat max = -std::numeric_limits<float>::max();\n\t\tint selectedExemplar = -1;\n\t\tfor (int e = 0; e < exemplars.size(); e++)\n\t\t{\n\t\t\tif (m_similarity[m_pointCount * i + exemplars[e]] > max)\n\t\t\t{\n\t\t\t\tmax = m_similarity[m_pointCount * i + exemplars[e]];\n\t\t\t\tselectedExemplar = e;\n\t\t\t}\n\t\t}\n\n\t\tif (selectedExemplar == -1)\n\t\t\tstd::cout << \"No exemplar selected for\" << i << \"!\";\n\t\telse\n\t\t\tstd::cout << \"Point \" << i << \": Cluster \" << selectedExemplar << \" around point \" << exemplars[selectedExemplar] <<\"\\n\";\n\t}\n}\n",
    "#include <Windows.h>\n#include <detours.h>\n#include <memoryapi.h>\n\n// Define a struct to hold the hook information\nstruct HookInfo {\n    void* original_fn;\n    void* hook_fn;\n    std::uintptr_t addr;\n};\n\n// Define a function to hook a function using a trampoline\ntemplate<typename FN>\nbool HookTrampoline(HookInfo& hook, FN original, FN hooked) {\n    std::uintptr_t trampoline_buf[512];\n    std::uintptr_t trampoline_size = 0;\n\n    // Calculate the size of the trampoline\n    if (!DetourCreateTrampoline(original, trampoline_buf, sizeof(trampoline_buf), &trampoline_size)) {\n        return false;\n    }\n\n    // Allocate memory for the hook\n    hook.addr = VirtualAlloc(nullptr, trampoline_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (!hook.addr) {\n        return false;\n    }\n\n    // Write the hook function to memory\n    if (!WriteProcessMemory(GetCurrentProcess(), hook.addr, hooked, trampoline_size, nullptr)) {\n        return false;\n    }\n\n    // Write the trampoline to memory\n    if (!WriteProcessMemory(GetCurrentProcess(), (std::uintptr_t)trampoline_buf, hook.addr, trampoline_size, nullptr)) {\n        return false;\n    }\n\n    // Install the hook\n    hook.original_fn = original;\n    hook.hook_fn = (FN)hook.addr;\n    DetourTransactionBegin();\n    DetourUpdateThread(GetCurrentThread());\n    DetourAttach(&(PVOID&)original, hook.hook_fn);\n    DetourTransactionCommit();\n\n    return true;\n}\n\n// Define the custom Present function\nHRESULT STDMETHODCALLTYPE CustomPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) {\n    // Do something before the original function is called\n    // ...\n\n    // Call the original function\n    HRESULT hr = O::Present(pSwapChain, SyncInterval, Flags);\n\n    // Do something after the original function is called\n    // ...\n\n    return hr;\n}\n\n// Define the InitHook function\nvoid InitHook() {\n    HMODULE DiscordHook = LoadLibraryA(\"DiscordHook.dll\");\n    if (!DiscordHook) {\n        std::cerr << \"Error: Failed to load DiscordHook.dll\" << std::endl;\n        return;\n    }\n\n    Modules DiscordModules;\n    DiscordModules.Attach(GetCurrentProcess(), DiscordHook);\n\n    DWORD PresentSig = DiscordModules.DiscordHook->Scan(\"OverlayReset\", \"FF 15 ? ? ? ? 8D 4D EC 8B F0 E8 ? ? ? ? 8B C6 5E 8B E5 5D C2\") + 0x2;\n    if (!PresentSig) {\n        std::cerr << \"Error: Failed to find OverlayReset signature\" << std::endl;\n        return;\n    }\n\n    O::Present = reinterpret_cast<O::PresentFn*>(PresentSig);\n\n    HookInfo DiscordOverlayResetHook;\n    if (!HookTrampoline(DiscordOverlayResetHook, O::Present, CustomPresent)) {\n        std::cerr << \"Error: Failed to hook Present function\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Hook installed successfully\" << std::endl;\n}\n\n// Define the entry point for the program\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {\n    if (dwReason == DLL_PROCESS_ATTACH) {\n        InitHook();\n    }\n    return TRUE;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "\n// Importing the modules\n#include \"Convert_to_postfix.h\"\n#include \"Expression_Tree.h\"\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\n// Constructor\nConvert_to_postfix::Convert_to_postfix() {}\n\n// Destructor\nConvert_to_postfix::~Convert_to_postfix() {}\n\n\n/** Converts an infix expression to postfix expression.\n\t@param infix_string: infix expression to convert\n\t@return: postfix expression converted from the infix expression\n*/\nstring Convert_to_postfix::infix_to_postfix(const string& infix_string) {\n\n\tExpression_Tree exp_parser_obj;\n\n\t// Initializing the variables\n\tistringstream iss(infix_string);\n\tostringstream output_string;\n\tstack<string> operand_stk;\n\tstring token;\n\n\t// Creating a while loop to parse the infix string\n\tfor (int i = 0; i < infix_string.size(); i++) {\n\n\t\t// Adding the character to the token\n\t\ttoken = infix_string[i];\n\n\t\t// Checking whether the token is empty\n\t\tif (token == \" \") {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t// Checking if token's next character is either '=', '&', '|'\n\t\tif (token == \">\" || token == \"<\" || token == \"=\" || token == \"!\" || token == \"&\" || token == \"|\") {\n\n\t\t\tif (i < infix_string.size() && (infix_string[i + 1] == '=' || infix_string[i + 1] == '&' || infix_string[i + 1] == '|')) {\n\t\t\t\ttoken += infix_string[i + 1];\n\t\t\t}\n\n\t\t}\n\n\t\t// Adding token to the output string if the token is digit\n\t\tif (isdigit(token.front())) {\n\n\t\t\t// Setting the index variable equal to i\n\t\t\tint index = i;\n\n\t\t\tstring operand;\n\n\t\t\t// Creating a digit operand\n\t\t\twhile (isdigit(infix_string[index])) {\n\t\t\t\toperand += infix_string[index];\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\toutput_string << ' ' << operand;\n\n\t\t\t// Setting the correct index\n\t\t\ti = index - 1;\n\t\t}\n\n\t\t// Adding token to the stack if the token is \"(\"\n\t\telse if (token == \"(\") { operand_stk.push(token); }\n\n\t\t// Adding elements from stack to output string if the token is \")\"\n\t\telse if (token == \")\") {\n\n\t\t\twhile (operand_stk.top() != \"(\") {\n\t\t\t\toutput_string << ' ' << operand_stk.top();\n\t\t\t\toperand_stk.pop();\n\t\t\t}\n\n\t\t\toperand_stk.pop();\n\t\t}\n\n\t\telse {\n\n\t\t\t// Adding the elements to the output string if it matches the conditions\n\t\t\twhile (!operand_stk.empty() && operand_stk.top() != \"(\" && token != \"=\" && token != \"|\" && token != \"&\" &&\n\t\t\t\texp_parser_obj.precedence(token) <= exp_parser_obj.precedence(operand_stk.top())) {\n\n\t\t\t\toutput_string << ' ' << operand_stk.top();\n\t\t\t\toperand_stk.pop();\n\t\t\t}\n\n\t\t\t// Checking if token is not \"=\", \"|\", or \"&\"\n\t\t\tif (token != \"=\" && token != \"|\" && token != \"&\") {\n\t\t\t\toperand_stk.push(token);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Adding all the remaining elements to the output string\n\twhile (!operand_stk.empty()) {\n\t\toutput_string << ' ' << operand_stk.top();\n\t\toperand_stk.pop();\n\t}\n\n\t// Returning\n\treturn output_string.str();\n\n}",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n\nstd::map<std::string, int> variables;\n\nvoid processAssignment(const std::string& line) {\n    std::istringstream stream(line);\n    std::string identifier;\n    char equals;\n    int value;\n    stream >> identifier >> equals >> value;\n    variables[identifier] = value;\n}\n\nvoid processPrint(const std::string& line) {\n    size_t start = line.find('(') + 1;\n    size_t end = line.find_last_of(')');\n    std::string content = line.substr(start, end - start);\n    std::istringstream stream(content);\n    std::string text, comma, identifier;\n    stream >> text >> comma >> identifier;\n    text.pop_back(); // Remove the trailing comma\n    std::cout << text << \" \" << variables[identifier] << std::endl;\n}\n\nvoid processLine(const std::string& line) {\n    if (line.find(\"print\") != std::string::npos) {\n        processPrint(line);\n    } else {\n        processAssignment(line);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input.py>\\n\";\n        return 1;\n    }\n\n    std::string input_file = argv[1];\n    std::ifstream input(input_file);\n    if (!input) {\n        std::cerr << \"Could not open input file: \" << input_file << \"\\n\";\n        return 1;\n    }\n\n    std::string line;\n    while (std::getline(input, line)) {\n        // Skip empty lines and comments\n        if (line.empty() || line[0] == '#') continue;\n        processLine(line);\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\nusing namespace std;\ntemplate <class type>\nclass Node {\nprivate:\n  type data;\n  Node* next;\npublic:\n  Node() : next(NULL) {}\n\n  void set_data(type data) {\n    this->data = data;\n  }\n\n  void set_next(Node* next) {\n    this->next = next;\n  }\n\n  Node* get_next() {\n    return next;\n  }\n\n  type get_data() {\n    return data;\n  }\n};\ntemplate <class type>\nclass CircularSinglyLinkedlist {\nprivate:\n  Node<type>* tail;\npublic:\nint count=0;\n  CircularSinglyLinkedlist() : tail(NULL) {}\n  bool is_empty() // o(1)\n  {\n    return tail == NULL;\n  }\n  void insert_first(type val) // o(1)\n   {\n    Node<type>* newnode = new Node<type>;\n    newnode->set_data(val);\n    if (!is_empty()) {\n      newnode->set_next(tail->get_next());\n      tail->set_next(newnode);\n    } else {\n      tail = newnode;\n      newnode->set_next(newnode); // Handle single element case (circular)\n    }\n  count++;\n  }\n  void insert_end(type val) // o(1)\n   {\n    if (is_empty()) {\n      insert_first(val);\n    } else {\n      Node<type>* newnode = new Node<type>;\n      newnode->set_data(val);\n      newnode->set_next(tail->get_next());\n      tail->set_next(newnode);\n      tail = newnode;\n    }\n  count++;\n  }\n void delete_first() // o(1)\n {\n Node<type>*temp=tail->get_next();\n tail->set_next(temp->get_next());\ndelete temp;\ncount--;\n }\nvoid delete_end() // o(N)\n{\nNode<type>* temp = tail->get_next();\nNode<type>* prev;\nwhile(temp->get_data()!=tail->get_data())\n{prev=temp;\ntemp=temp->get_next();\n}\nprev->set_next(tail->get_next());\ntail=prev;\ndelete temp;\ncount--;\n}\nvoid insert_after(type item,type newitem) // o(N)\n{\nNode<type>*temp=tail->get_next();\ndo\n{\nif(temp->get_data()==item)\n {\nNode<type>*newelement=new Node<type>;\nnewelement->set_data(newitem);\nnewelement->set_next(temp->get_next());\ntemp->set_next(newelement);\ncount++;\nbreak;\n}\nelse{\ntemp=temp->get_next();\n}\n}while(temp!=tail->get_next());\n}\nvoid insert_before(type item,type newitem) // o(N)\n{\n Node<type>* current = tail->get_next();\n Node<type>* previous = nullptr;\ndo\n{\nif(current->get_data()==item)\n {\nprevious->set_data(newitem);\nprevious->set_next(current);\n count++;\n break;\n }\nprevious=current;\ncurrent=current->get_next();\n}while(current->get_next()!=tail->get_next());\n}\nvoid delete_before(type item ) // o(N)\n{\n  Node<type>*temp=tail->get_next();\n  Node<type>*current=temp->get_next();\n  current=current->get_next();\n  Node<type>*cur;\ndo{\n if(item==current->get_data())\n {cur=temp->get_next();\n  temp->set_next(current);\n  delete cur;\n count--;\n break;\n }\ncurrent=current->get_next();\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\n}\nvoid delete_after(type item) // o(N)\n{\n  Node<type>*temp=tail->get_next();\n  Node<type>*current=temp->get_next();\n  current=current->get_next();\n  Node<type>*cur;\ndo{\n if(item==temp->get_data())\n {cur=temp->get_next();\n   temp->set_next(current);\n delete cur;\n count--;\n break;\n }\ncurrent=current->get_next();\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\n}\n  void display() // o(N)\n  {\n  int n=1;\n    cout << \"*******  all elements ********\\n\\n\";\n    if (is_empty()) {\n      cout << \"List is empty\\n\";\n      return;\n    }\n\n    Node<type>* temp = tail->get_next();\n    do {\n      cout<<\"item \"<<n<<\":\"<<temp->get_data()<<endl;\n n++;\n      temp = temp->get_next();\n    } while (temp != tail->get_next());\n  }\nbool isfind(type item) // o(N)\n{\nNode<type>*temp=tail->get_next();\ndo{\nif(item==temp->get_data())\nreturn true;\n\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\nreturn false;\n}\nvoid replace(type old_item,type new_item) // o(N)\n{\nNode<type>*temp=tail->get_next();\nbool exist=false;\ndo{\nif(old_item==temp->get_data())\n{\n exist=true;\n temp->set_data(new_item);\nbreak;\n}\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\nif(exist==false)\ncout<<\"NOT found\";}\nvoid displaybyrecursion() // o(N)\n{\nstatic Node<type>*temp=tail->get_next();\nstatic int n=1;\nif (is_empty()) {\n      cout << \"List is empty\\n\";\n      return;\n }\nif(n==1){\ncout<<\"item \"<<n<<\":\"<<temp->get_data()<<endl;\ntemp=temp->get_next();}\nif(temp==tail->get_next())\nreturn ;\nelse{\nn++;\n cout<<\"item \"<<n<<\":\"<<temp->get_data()<<endl;\n  temp=temp->get_next();\ndisplaybyrecursion();\n}\n}\nint size() //o(1)\n{\nreturn count;\n}\n};\nint main() {\n  CircularSinglyLinkedlist<int> numbers;\n  for (int i = 0; i < 10; i++) {\n    numbers.insert_first(i);\n  }\n  numbers.insert_end(100);\nnumbers.replace(1,10001);\nnumbers.display();\n\ncout<<\"\\n size :\"<<numbers.size();\n\n return 0;\n}\n\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"UI/Widget/SSDMenuHUDWidget.h\"\r\n#include \"UI/Widget/SSDMenuWidget.h\"\r\n#include \"UI/Style/SDStyle.h\"\r\n#include \"UI/Style/SDMenuWidgetStyle.h\"\r\n#include \"SlateOptMacros.h\"\r\n#include \"Widgets/Input/SButton.h\"\r\n#include \"Widgets/Images/SImage.h\"\r\n#include \"Widgets/SOverlay.h\"\r\n#include \"Widgets/Layout/SDPIScaler.h\"\r\n\r\n\r\nBEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION\r\nvoid SSDMenuHUDWidget::Construct(const FArguments& InArgs)\r\n{\r\n\t// \u901a\u8fc7SDStyle\u83b7\u53d6SDMenuWidgetStyle\u5728\u7f16\u8f91\u5668\u4e2d\u7684MenuStyle\r\n\tMenuStyle = &SDStyle::Get().GetWidgetStyle<FSDMenuStyle>(\"BPSDMenuStyle\");\r\n\r\n\t// \u7ed1\u5b9a\u63a7\u4ef6\u7f29\u653e\u89c4\u5219\u65b9\u6cd5\r\n\tUIScaler.Bind(this, &SSDMenuHUDWidget::GetUIScaler);\r\n\t\r\n\tChildSlot\r\n\t[\r\n\t\tSNew(SDPIScaler)\t\t// DPI\u7a97\u53e3\u5927\u5c0f\u4fee\u6539\u65f6\u8bbe\u7f6eUIScaler\r\n\t\t\t.DPIScale(UIScaler)\r\n\t\t\t[\r\n\t\t\tSNew(SOverlay) \r\n\t\t\t\t+ SOverlay::Slot()\r\n\t\t\t\t.HAlign(HAlign_Fill)\t// \u6837\u5f0fHorizontal\u6c34\u5e73\u5168\u586b\u5145\r\n\t\t\t\t.VAlign(VAlign_Fill)\t// \u6837\u5f0fVertical\u5782\u76f4\u5168\u586b\u5145\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t// \u6dfb\u52a0\u80cc\u666f\u56fe\u7247:\u5148\u5b9e\u4f8b\u5316\u4e00\u4e2a\u7ec4\u4ef6\uff0c\u7136\u540e\u7ed9\u7ec4\u4ef6\u6dfb\u52a0\u4e00\u4e2a\u7b14\u5237\r\n\t\t\t\t\t\tSNew(SImage).Image(&MenuStyle->MenuHUDBackgroundBrush)\r\n\t\t\t\t\t]\r\n\t\t\t\r\n\t\t\t\t+ SOverlay::Slot()\r\n\t\t\t\t.HAlign(HAlign_Center)\t// \u6837\u5f0f\u6c34\u5e73\u5c45\u4e2d\r\n\t\t\t\t.VAlign(VAlign_Center)\t// \u6837\u5f0f\u5782\u76f4\u5c45\u4e2d\r\n\t\t\t\t.Expose(ImageSlot)\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t// \u5b9e\u4f8b\u5316SSDMenuWidget\u5e76\u83b7\u53d6\u5176\u6307\u9488MenuWidget\r\n\t\t\t\t\t\tSAssignNew(MenuWidget, SSDMenuWidget)\r\n\t\t\t\t\t]\r\n\r\n\t\t\t\r\n\t\t\t]\r\n\t];\r\n\t\r\n}\r\n\r\nfloat SSDMenuHUDWidget::GetUIScaler() const\r\n{\r\n\t// \u7a97\u53e3\u5bbd\u5ea6\u5927\u4e8e1080\u65f6\uff0c\u5b9a\u503c\u4e3a1\uff0c\u5c0f\u4e8e1080\u65f6\u7ebf\u6027\u53d8\u5316\r\n\tauto VSW = GetViewportSize().Y;\r\n\tif (VSW < 1080.0f) {\r\n\t\treturn VSW / 1080.0f;\r\n\t}\r\n\treturn 1.0f;\r\n}\r\n\r\nFVector2D SSDMenuHUDWidget::GetViewportSize() const\r\n{\r\n\tFVector2D Res(1920, 1080);\r\n\tif (GEngine && GEngine->GameViewport) {\r\n\t\tGEngine->GameViewport->GetViewportSize(Res);\r\n\t}\r\n\treturn Res;\r\n}\r\n\r\nEND_SLATE_FUNCTION_BUILD_OPTIMIZATION\r\n",
    "\n\n#include \"include\\PerkEntryPointExtenderAPI.h\"\n\nstruct Hooks {\n    struct SetMagicTimeSlowdownStart {\n        static void thunk(RE::VATS* a_vats, float a_worldMagnitude, float a_playerMagnitude) {\n            const auto magicTimeSlowdown = a_vats->magicTimeSlowdown;\n            const auto playermagicTimeSlowdown = a_vats->playerMagicTimeSlowdown;\n            \n            if (a_worldMagnitude < 0) {\n                if (playermagicTimeSlowdown == 0) {\n                    func(a_vats, magicTimeSlowdown, a_worldMagnitude * -1);\n                } else {\n                    func(a_vats, magicTimeSlowdown, a_worldMagnitude * -1 * playermagicTimeSlowdown);\n                \n                }\n                   \n            }\n            else {\n                if (magicTimeSlowdown == 0) {\n                    func(a_vats, a_worldMagnitude, 1.0f);\n                } else {\n                    func(a_vats, magicTimeSlowdown * a_worldMagnitude, playermagicTimeSlowdown);\n                }\n                   \n            }\n        }\n        static inline REL::Relocation<decltype(thunk)> func;\n    };\n\n        struct GetActiveEffectMagnitude {\n        static float thunk(RE::ActiveEffect* a_AE) {\n            float timescale;\n            const auto magicTime = RE::VATS::GetSingleton();\n            float playertimescale = magicTime->playerMagicTimeSlowdown;\n            if (playertimescale == 0.0f) {\n                playertimescale = 1.0f;\n            }\n           if (a_AE->effect->baseEffect->IsHostile()) {\n           \n           timescale = a_AE->GetMagnitude()*-1;          \n           a_AE->duration = a_AE->duration * timescale * -1 * playertimescale;\n           }\n           else {\n           timescale = a_AE->GetMagnitude();\n           a_AE->duration = a_AE->duration * playertimescale;\n           }\n           return timescale;\n        }\n        static inline REL::Relocation<decltype(thunk)> func;\n    };\n\n    struct SlowTimeStop {\n        static void thunk(RE::SlowTimeEffect* a_SlowTime) {\n           const auto magicTime = RE::VATS::GetSingleton();\n           auto magicTimeSlowdown = magicTime->magicTimeSlowdown;\n           auto playermagicTimeSlowdown = magicTime->playerMagicTimeSlowdown;\n           float timescale;\n           if (a_SlowTime->effect->baseEffect->IsHostile()) {\n           timescale = a_SlowTime->GetMagnitude();\n           magicTime->SetMagicTimeSlowdown((magicTimeSlowdown), playermagicTimeSlowdown/timescale);\n           } else {\n           timescale = a_SlowTime->GetMagnitude();\n           magicTime->SetMagicTimeSlowdown((magicTimeSlowdown / timescale), playermagicTimeSlowdown);\n           }\n           func(a_SlowTime);\n        }\n        static inline REL::Relocation<decltype(thunk)> func;\n    };\n\n    struct NullMagicTimeSlowdownStop {\n        static void thunk(RE::VATS* a_vats, float a_worldMagnitude, float a_playerMagnitude) {\n        }\n        static inline REL::Relocation<decltype(thunk)> func;\n    };\n\n    struct NullGetCurrentMultiplier {\n        static float thunk(RE::VATS* a_vats) {\n            return 1.0f;\n        }\n        static inline REL::Relocation<decltype(thunk)> func;\n    };\n\n    // struct PlayerCharacter_Update {\n    //     static void thunk(RE::PlayerCharacter* a_player, float a_delta) {\n    //        func(a_player, a_delta);\n    //    }\n    //    static inline REL::Relocation<decltype(thunk)> func;\n    //};\n\n    static void Install() {\n        // stl::write_vfunc<RE::PlayerCharacter, 0xAD, PlayerCharacter_Update>();\n\n        REL::Relocation<std::uintptr_t> checkslowtime{RELOCATION_ID(529316, 34972), REL::Relocate(0x0, 0x0)};\n        REL::safe_fill(checkslowtime.address(), REL::NOP, 0x13);\n\n        stl::write_vfunc<RE::SlowTimeEffect, 0x13, SlowTimeStop>();\n\n\n        REL::Relocation<std::uintptr_t> FunctionNullGetCurrentMultiplier{RELOCATION_ID(34175, 34968),\n                                                                          REL::Relocate(0x6E, 0x6E)};\n        stl::write_thunk_call<NullGetCurrentMultiplier>(FunctionNullGetCurrentMultiplier.address());\n        \n\n        REL::Relocation<std::uintptr_t> functionNullMagicTimeSlowdownStop{RELOCATION_ID(34177, 34970),\n                                                                          REL::Relocate(0x35, 0x35)};\n        stl::write_thunk_call<NullMagicTimeSlowdownStop>(functionNullMagicTimeSlowdownStop.address());\n\n\n         REL::Relocation<std::uintptr_t> functionSetMagicTimeSlowdownStart{RELOCATION_ID(34175, 34968), REL::Relocate(0x5D, 0x5D)};\n         stl::write_thunk_call<SetMagicTimeSlowdownStart>(functionSetMagicTimeSlowdownStart.address());\n\n         REL::Relocation<std::uintptr_t> functionGetActiveEffectMagnitude{RELOCATION_ID(34175, 34968), REL::Relocate(0x4C, 0x4C)};\n         stl::write_thunk_call<GetActiveEffectMagnitude>(functionGetActiveEffectMagnitude.address());\n\n\n    }\n};\n\nSKSEPluginLoad(const SKSE::LoadInterface* skse) {\n    SKSE::Init(skse);\n    Hooks::Install();\n    return true;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Dumper.h\"\n\n#include <fstream>\n\nstd::vector<microsoft_pe_t::section_t*> g_executable_sections;\nstd::vector<microsoft_pe_t::section_t*> g_read_only_sections;\n\nmicrosoft_pe_t* g_data;\n\nvoid Dumper::MSPE::get_executable_and_read_only_sections()\n{\n\t// Get pe sections and iterate through them.\n\tstd::vector<microsoft_pe_t::section_t*>* sections = g_data->pe()->sections();\n\n\tfor (microsoft_pe_t::section_t* i : *sections)\n\t{\n\t\t// Check if each section is executable\n\t\tbool is_executable = i->characteristics() & 0x20000000;  // Section is executable.\n\t\tbool is_read_only = i->characteristics() & 0x40000000;  // Section is readable.\n\n\t\tif (is_executable)\n\t\t\tg_executable_sections.push_back(i);\n\n\t\tif (is_read_only)\n\t\t\tg_read_only_sections.push_back(i);\n\t}\n\n\tif (g_executable_sections.empty() || g_read_only_sections.empty())\n\t{\n\t\tprintf(\"Error, failed to find any executable sections in the pe.\\n\");\n\t\tthrow;\n\t}\n}\n\nvoid Dumper::MSPE::parse_sections_for_vtables()\n{\n\tuintptr_t* SectionBuffer;\n\tsize_t TotalSectionSize = 0;\n\n\tfor (microsoft_pe_t::section_t* i : g_read_only_sections)\n\t{\n\t\tTotalSectionSize += i->size_of_raw_data();\n\t}\n\n\tfor (microsoft_pe_t::section_t* i : g_executable_sections)\n\t{\n\t\tprintf(\"Parsing %s Section for VTables.\\n\", i->name().c_str());\n\n\t\tsize_t SectionSize = i->size_of_raw_data();\n\t\tsize_t Max = SectionSize / sizeof(uintptr_t);\n\n\t\tfor (size_t i = 0; i < Max; i++)\n\t\t{\n\t\t\tif (i == 0 || i + 1 > Max)\n\t\t\t\tcontinue;\n\n\t\t\tprintf(\"Test: %llu\\n\", i);\n\t\t}\n\t}\n}\n\nvoid Dumper::MSPE::Dump(const char* binary_path)\n{\n\tstd::ifstream input(binary_path, std::ios::binary);\n\n\tkaitai::kstream ks(&input);\n\n\tg_data = new microsoft_pe_t(&ks);\n\n\tDumper::MSPE::get_executable_and_read_only_sections();\n\n\tDumper::MSPE::parse_sections_for_vtables();\n}",
    "#include <bits/stdc++.h>\r\n#include<windows.h>\r\nusing namespace std;\r\nvoid printf_green(const char *s)\r\n{\r\n\tprintf(\"\\033[0m\\033[1;32m%s\\033[0m\", s);\r\n}\r\nBOOL SetConsoleColor(WORD wAttributes)  \r\n{  \r\n\tHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);  \r\n\tif (hConsole == INVALID_HANDLE_VALUE)  \r\n\t\treturn FALSE;  \r\n\t\r\n\treturn SetConsoleTextAttribute(hConsole, wAttributes);  \r\n}  \r\nbool check()\r\n{\r\n\tstring ans,ans2;\r\n\tfreopen(\"a.out\",\"r\",stdin);\r\n\tchar c;\r\n\twhile(scanf(\"%c\",&c)!=EOF) ans+=c;\r\n\tfclose(stdin);\r\n\tfreopen(\"b.out\",\"r\",stdin);\r\n\twhile(scanf(\"%c\",&c)!=EOF) ans2+=c;;\r\n\tfclose(stdin);\r\n\treturn ans == ans2;\r\n}\r\nint main() {\r\n\tint n;\r\n\tcin>>n;\r\n\tfor(int i = 1; n?i<=n:1;i++) {\r\n\t\tsystem(\"gen > test.in\");\r\n\t\tsystem(\"sol.exe < test.in > a.out\");\r\n\t\tsystem(\"ans.exe < test.in > b.out\"); \r\n\t\t\r\n\t\tif (check()) {\r\n\t\t\t\tSetConsoleColor(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | BACKGROUND_GREEN);\r\n\t\t\t\tprintf(\"[AC in %d]\",i);\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t}\r\n\t\telse{\r\n\t\t\tSetConsoleColor(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | BACKGROUND_RED);\r\n\t\t\tprintf(\"[WA in %d]\",i);\r\n\t\t\t\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\tprintf_green(\"ALL TESTS RIGHT\");\r\n}",
    "/*\n * Copyright (C) 2008-2018 TrinityCore <https://www.trinitycore.org/>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"ScriptMgr.h\"\n#include \"AuctionHouseBot.h\"\n#include \"Chat.h\"\n#include \"Language.h\"\n#include \"RBAC.h\"\n\nstatic const uint32 ahbotQualityIds[MAX_AUCTION_QUALITY] =\n{\n    LANG_AHBOT_QUALITY_GRAY, LANG_AHBOT_QUALITY_WHITE,\n    LANG_AHBOT_QUALITY_GREEN, LANG_AHBOT_QUALITY_BLUE,\n    LANG_AHBOT_QUALITY_PURPLE, LANG_AHBOT_QUALITY_ORANGE,\n    LANG_AHBOT_QUALITY_YELLOW\n};\n\nclass ahbot_commandscript : public CommandScript\n{\npublic:\n    ahbot_commandscript(): CommandScript(\"ahbot_commandscript\") {}\n\n    std::vector<ChatCommand> GetCommands() const override\n    {\n        static std::vector<ChatCommand> ahbotItemsAmountCommandTable =\n        {\n            { \"gray\",           rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_GRAY,   true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_GRAY>,     \"\" },\n            { \"white\",          rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_WHITE,  true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_WHITE>,    \"\" },\n            { \"green\",          rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_GREEN,  true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_GREEN>,    \"\" },\n            { \"blue\",           rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_BLUE,   true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_BLUE>,     \"\" },\n            { \"purple\",         rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_PURPLE, true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_PURPLE>,   \"\" },\n            { \"orange\",         rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_ORANGE, true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_ORANGE>,   \"\" },\n            { \"yellow\",         rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS_YELLOW, true,  &HandleAHBotItemsAmountQualityCommand<AUCTION_QUALITY_YELLOW>,   \"\" },\n            { \"\",               rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS,        true,  &HandleAHBotItemsAmountCommand,                                  \"\" },\n        };\n\n        static std::vector<ChatCommand> ahbotItemsRatioCommandTable =\n        {\n            { \"alliance\",       rbac::RBAC_PERM_COMMAND_AHBOT_RATIO_ALLIANCE, true,  &HandleAHBotItemsRatioHouseCommand<AUCTION_HOUSE_ALLIANCE>,    \"\" },\n            { \"horde\",          rbac::RBAC_PERM_COMMAND_AHBOT_RATIO_HORDE,    true,  &HandleAHBotItemsRatioHouseCommand<AUCTION_HOUSE_HORDE>,       \"\" },\n            { \"neutral\",        rbac::RBAC_PERM_COMMAND_AHBOT_RATIO_NEUTRAL,  true,  &HandleAHBotItemsRatioHouseCommand<AUCTION_HOUSE_NEUTRAL>,     \"\" },\n            { \"\",               rbac::RBAC_PERM_COMMAND_AHBOT_RATIO,          true,  &HandleAHBotItemsRatioCommand,                                 \"\" },\n        };\n\n        static std::vector<ChatCommand> ahbotCommandTable =\n        {\n            { \"items\",          rbac::RBAC_PERM_COMMAND_AHBOT_ITEMS,    true,   NULL,                       \"\", ahbotItemsAmountCommandTable },\n            { \"ratio\",          rbac::RBAC_PERM_COMMAND_AHBOT_RATIO,    true,   NULL,                       \"\", ahbotItemsRatioCommandTable },\n            { \"rebuild\",        rbac::RBAC_PERM_COMMAND_AHBOT_REBUILD,  true,   &HandleAHBotRebuildCommand, \"\" },\n            { \"reload\",         rbac::RBAC_PERM_COMMAND_AHBOT_RELOAD,   true,   &HandleAHBotReloadCommand,  \"\" },\n            { \"status\",         rbac::RBAC_PERM_COMMAND_AHBOT_STATUS,   true,   &HandleAHBotStatusCommand,  \"\" },\n        };\n\n        static std::vector<ChatCommand> commandTable =\n        {\n            { \"ahbot\",          rbac::RBAC_PERM_COMMAND_AHBOT,  false, NULL,    \"\", ahbotCommandTable },\n        };\n\n        return commandTable;\n    }\n\n    static bool HandleAHBotItemsAmountCommand(ChatHandler* handler, const char* args)\n    {\n        uint32 qVals[MAX_AUCTION_QUALITY];\n        char* arg = strtok((char*)args, \" \");\n        for (int i = 0; i < MAX_AUCTION_QUALITY; ++i)\n        {\n            if (!arg)\n                return false;\n            qVals[i] = atoi(arg);\n            arg = strtok(NULL, \" \");\n        }\n\n        sAuctionBot->SetItemsAmount(qVals);\n\n        for (int i = 0; i < MAX_AUCTION_QUALITY; ++i)\n            handler->PSendSysMessage(LANG_AHBOT_ITEMS_AMOUNT, handler->GetTrinityString(ahbotQualityIds[i]), sAuctionBotConfig->GetConfigItemQualityAmount(AuctionQuality(i)));\n\n        return true;\n    }\n\n    template <AuctionQuality Q>\n    static bool HandleAHBotItemsA",
    "\ufeff// GitHubDesktop2Chinese.cpp: \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n\n\n#define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING\n#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING\t//\u6d88\u9664 converter.to_bytes\u7684\u8b66\u544a\n#define _CRT_SECURE_NO_WARNINGS\t\t\t\t\t\t\t\t//\u6d88\u9664 sprintf\u7684\u8b66\u544a\n\n#define PAUSE if(!no_pause) system(\"pause\")\n\n#include \"GitHubDesktop2Chinese.h\"\n#include <string>\n#include <filesystem>\n\n#include <regex>\n\n#include \"spdlog/spdlog.h\"\t\t\t// \u65e5\u5fd7\u5f0f\u8f93\u51fa\u5e93\n#include \"nlohmann/json.hpp\"\t\t// JSON\u8bfb\u53d6\u672c\u5730\u914d\u7f6e\u5e93\n#include \"WinReg/WinReg.hpp\"\t\t// \u6ce8\u518c\u8868\u64cd\u4f5c\u5e93\n\n#include <CLI/CLI.hpp>\t\t\t\t// \u53c2\u6570\u7ba1\u7406\u5668:\t\thttps://github.com/CLIUtils/CLI11\n#include \"Utils/utils.hpp\"\n\n\n#if _DEBUG\n#define NO_REPLACE 0\n#endif // _DEBUG\n\n\n\n\nnamespace fs = std::filesystem;\nusing json = nlohmann::json;\n\n// \u8bbe\u7f6e\u4e00\u4e2a\u8def\u5f84\u7684\u5168\u5c40\u53d8\u91cf  \u6307\u5411\u8981\u4fee\u6539JS\u7684\u76ee\u5f55\nfs::path Base;\nfs::path LocalizationJSON;\n\nbool no_pause;\t\t\t\t\t\t\t\t\t// \u7a0b\u5e8f\u5728\u7ed3\u675f\u524d\u662f\u5426\u6682\u505c\nbool only_read_from_remote;\t\t\t\t\t\t// \u4ec5\u4ece\u8fdc\u7a0burl\u4e2d\u8bfb\u53d6\u672c\u5730\u5316\u6587\u4ef6\n\njson localization = R\"(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"main\": [\n\t\t\t\t\t\t\t\t[\"XXXXX\", \"XXXXX\"]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"renderer\": [\n\t\t\t\t\t\t\t\t[\"xxxxx\",\"xxxxx\"]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t)\"_json;\nbool _debug_goto_devoptions;\n\nbool _debug_error_check_mode_main = false;\nbool _debug_error_check_mode_renderer = false;\nbool _debug_invalid_check_mode = false;\nbool _debug_no_replace_res = false;\nbool _debug_translation_from_bak = false;\t\t// \u76f4\u63a5\u4ece\u5907\u4efd\u6587\u4ef6\u4e2d\u7ffb\u8bd1\u5230\u76ee\u6807\u6587\u4ef6\u4e2d\nbool _debug_dev_replace = false;\t\t\t\t// \u5f00\u53d1\u6a21\u5f0f\u66ff\u6362\n\n// argv[0] \u662f\u7a0b\u5e8f\u8def\u5f84\nint main(int argc, char* argv[])\n{\n\t// \u8bbe\u7f6e\u63a7\u5236\u53f0\u6253\u5370\u65e5\u5fd7\u8f93\u51fa\u7b49\u7ea7\n#if _DEBUG\n\tspdlog::set_level(spdlog::level::debug);\n#endif // _DEBUG\n\t// \u6ce8\u518c\u547d\u4ee4\u884c\n\t{\n\t\tCLI::App app{ \"\u6c49\u5316GitHub Desktop\u7ba1\u7406\u3001\u66ff\u6362\u8d44\u6e90\" };\n\n\t\t//app.require_subcommand(1);\n\n\t\t// \u5b50\u547d\u4ee4 \u5f00\u53d1\u8005\u9009\u9879\n\t\tauto dev_cmd = app.add_subcommand(\"dev\", \"\u5f00\u53d1\u8005\u9009\u9879\");\n\t\tdev_cmd->add_flag(\"-d,--dev\", _debug_goto_devoptions, \"\u8fdb\u5165\u5f00\u53d1\u8005\u9009\u9879\u8c03\u6574\u529f\u80fd(\u53ef\u5728\u5f00\u542f\u7a0b\u5e8f\u65f6\u6309\u4f4fshift\u76f4\u63a5\u8fdb\u5165)\");\n\t\tdev_cmd->add_flag(\"--mainerrorcheck\", _debug_error_check_mode_main,\t\t\t\"[\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f]\u5bf9main.js\u4ee5\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f\u8fdb\u884c\u6392\u67e5\");\n\t\tdev_cmd->add_flag(\"--rendererrorcheck\", _debug_error_check_mode_renderer,\t\"[\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f]\u5bf9renderer.js\u4ee5\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f\u8fdb\u884c\u6392\u67e5\");\n\t\tdev_cmd->add_flag(\"--invalidcheck\", _debug_invalid_check_mode,\t\t\t\t\"[\u68c0\u6d4b\u5931\u6548\u9879]\u5bf9\u672c\u5730\u5316\u6587\u4ef6\u4e2d\u7684\u5931\u6548\u66ff\u6362\u9879\u8fdb\u884c\u68c0\u6d4b\");\n\t\tdev_cmd->add_flag(\"--noreplaceres\", _debug_no_replace_res,\t\t\t\t\t\"[\u8d44\u6e90\u4e0d\u66ff\u6362]\u5f00\u542f\u540e\u4e0d\u4f1a\u5bf9\u8d44\u6e90\u8fdb\u884c\u66ff\u6362,\u4f46\u4e0d\u4f1a\u963b\u6b62[\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f]\");\n\t\tdev_cmd->add_flag(\"--translationfrombak\", _debug_translation_from_bak,\t\t\"[\u4ece\u5907\u4efd\u6587\u4ef6\u4e2d\u8bfb\u53d6\u66ff\u6362]\u4f18\u5148\u4ece\u5907\u4efd\u6587\u4ef6\u4e2d\u8bfb\u53d6js\u6587\u4ef6\u5185\u5bb9\u8fdb\u884c\u66ff\u6362,\u5f00\u542f[\u68c0\u6d4b\u5931\u6548\u9879]\u65f6\u5efa\u8bae\u5f00\u542f\u6b64\u9879\");\n\t\tdev_cmd->add_flag(\"--devreplace\", _debug_dev_replace,\t\t\t\t\t\t\"[\u5f00\u53d1\u6a21\u5f0f\u66ff\u6362]\u4ec5\u66ff\u6362\u6307\u5b9a\u6620\u5c04\u4ee5\u8282\u7ea6\u6c49\u5316\u65f6\u95f4(\u4f1a\u5f71\u54cd\u5176\u4ed6\u9879)\");\n\n\n\t\tapp.add_flag(\"--nopause\", no_pause,\t\t\t\t\t\t\t\"\u7a0b\u5e8f\u5728\u7ed3\u675f\u524d\u4e0d\u518d\u6682\u505c\u7b49\u5f85\");\n\t\tapp.add_flag(\"-r,--onlyfromremote\", only_read_from_remote,\t\"\u4ec5\u4ece\u8fdc\u7a0burl\u4e2d\u8bfb\u53d6\u672c\u5730\u5316\u6587\u4ef6\");\n\t\tapp.add_option(\"-j,--json\", LocalizationJSON,\t\t\t\t\"\u6307\u5b9a\u672c\u5730\u5316JSON\u6587\u4ef6\u7684\u672c\u5730\u8def\u5f84\");\n\t\tapp.add_option(\"-g,--githubdesktoppath\", Base,\t\t\t\t\"\u6307\u5b9aGitHubDesktop\u8981\u6c49\u5316\u7684\u8d44\u6e90\u6240\u5728\u76ee\u5f55\");\n\t\t\n\t\tapp.callback([&]() {\n\t\t\t// \u624b\u52a8\u6307\u5b9a\u4e86\u672c\u5730\u5316\u6587\u4ef6\u76ee\u5f55\n\t\t\tif (!LocalizationJSON.string().empty()) {\n\t\t\t\tif (!LocalizationJSON.string().ends_with(\".json\")) {\n\t\t\t\t\tthrow CLI::ValidationError(\"(-j,--json) \u6307\u5b9a\u7684\u672c\u5730\u5316\u6587\u4ef6\u8def\u5f84\u5fc5\u987b\u4ee5.json\u7ed3\u5c3e\");\n\t\t\t\t}\n\t\t\t\tif (!fs::exists(LocalizationJSON)) {\n\t\t\t\t\tstd::ofstream io(LocalizationJSON);\n\t\t\t\t\tio << std::setw(4) << localization << std::endl;\n\t\t\t\t\tio.close();\n\t\t\t\t\tthrow CLI::ValidationError(\"(-j,--json) \u6307\u5b9a\u7684\u672c\u5730\u5316\u6587\u4ef6\u4e0d\u5b58\u5728,\u5df2\u5728\u6307\u5b9a\u4f4d\u7f6e\u521b\u5efa\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \u624b\u52a8\u6307\u5b9a\u4e86GitHubDesktop\u8d44\u6e90\u6587\u4ef6\u76ee\u5f55\n\t\t\tif (!Base.string().empty()) {\n\t\t\t\tif (!fs::exists(Base)) {\n\t\t\t\t\tthrow CLI::ValidationError(\"(-g,--githubdesktoppath) \u6307\u5b9a\u7684\u8d44\u6e90\u6587\u4ef6\u76ee\u5f55\u4e0d\u5b58\u5728\");\n\t\t\t\t}\n\t\t\t\tif (!fs::exists(Base / \"index.html\")) {\n\t\t\t\t\tthrow CLI::ValidationError(\"(-g,--githubdesktoppath) \u6307\u5b9a\u7684\u8d44\u6e90\u6587\u4ef6\u76ee\u5f55\u65e0\u6548,\u8be5\u76ee\u5f55\u4e0b\u5e94\u8be5\u662f\u5b58\u653emain.js\u548crenderer.js\u6587\u4ef6\u7684\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\tCLI11_PARSE(app, argc, argv);\n\t\tspdlog::info(\"LocalizationJSON:{}\", LocalizationJSON.string());\n\t}\n\n\t// \u5f00\u53d1\u8005\u58f0\u660e\n\tspdlog::info(\"\u5f00\u53d1\u8005\uff1aCNGEGE>2024/04/13\");\n\t\n\tif (GetKeyState(VK_SHIFT) & 0x8000 || _debug_goto_devoptions) {\n\t\t// \u5982\u679cShift\u6309\u4e0b, \u5219\u8fdb\u5165\u5f00\u53d1\u8005\u9009\u9879\n\t\tSetConsoleTitle(\"\u5f00\u53d1\u8005\u6a21\u5f0f\");\n\t\tspdlog::info(\"\u60a8\u5df2\u8fdb\u5165\u5f00\u53d1\u8005\u6a21\u5f0f\");\n\t\tDeveloperOptions();\n\t}\n\n\tif (LocalizationJSON.empty()) {\n\t\tLocalizationJSON = \"localization.json\";\n\t}\n\n\t// \u5982\u679c\u662f\u4ec5\u4ece\u8fdc\u7a0b\u4ed3\u5e93\u8bfb\u53d6\u6c49\u5316\u6587\u4ef6\n\tif (only_read_from_remote) {\n\t\tspdlog::info(\"\u5c1d\u8bd5\u4ece\u8fdc\u7a0b\u5f00\u6e90\u9879\u76ee\u4e2d\u83b7\u53d6\");\n\t\tstd::string httpjson;\n\t\tif (utils::ReadHttpDataString(\"https://raw.kkgithub.com\", \"/cngege/GitHubDesktop2Chinese/master/json/localization.json\", httpjson)) {\n\t\t\tlocalization = json::parse(httpjson);\n\t\t\tspdlog::info(\"\u8fdc\u7a0b\u8bfb\u53d6\u6210\u529f\");\n\t\t}\n\t\telse {\n\t\t\tspdlog::warn(\"\u8fdc\u7a0b\u83b7\u53d6\u5931\u8d25,\u8bf7\u68c0\u67e5\u7f51\u7edc\u548c\u4ee3\u7406,\u5e76\u7a0d\u540e\u518d\u8bd5\");\n\t\t\tPAUSE;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t// \u6ca1\u6709\u6307\u5b9a\u4ec5\u4ece\u8fdc\u7a0b\u4ed3\u5e93\u83b7\u53d6\u6c49\u5316\u6587\u4ef6\n\telse {\n\t\t// \u5224\u65ad\u6c49\u5316\u6620\u5c04\u6587\u4ef6\u662f\u5426\u5b58\u5728, \u4e0d\u5b58\u5728\u5219\u521b\u5efa\u4e00\u4e2a\n\t\tif (!fs::exists(LocalizationJSON)) {\n\t\t\t// \u6ca1\u6709\u53d1\u73b0json\u6587\u4ef6,\u5c1d\u8bd5\u4ece\u8fdc\u7a0b\u5f00\u6e90\u9879\u76ee\u4e2d\u83b7\u53d6\n\t\t\tspdlog::warn(\"\u6ca1\u6709\u6307\u5b9a,\u6216\u4ece\u6307\u5b9a\u4f4d\u7f6e\u6ca1\u6709\u53d1\u73b0 {} \u6587\u4ef6\", \"localization.json\");\n\t\t\tspdlog::info(\"\u5c1d\u8bd5\u4ece\u8fdc\u7a0b\u5f00\u6e90\u9879\u76ee\u4e2d\u83b7\u53d6\");\n\t\t\tstd::string httpjson;\n\t\t\tif (utils::ReadHttpDataString(\"https://raw.kkgithub.com\", \"/cngege/GitHubDesktop2Chinese/master/json/localization.json\", httpjson)) {\n\t\t\t\tlocalization = json::parse(httpjson);\n\t\t\t\tspdlog::info(\"\u8fdc\u7a0b\u8bfb\u53d6\u6210\u529f\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspdlog::warn(\"\u8fdc\u7a0b\u83b7\u53d6\u5931\u8d25: {}, \u5df2\u521b\u5efa\u6846\u67b6,\u8bf7\u5148\u7f16\u8f91\u521b\u5efa\u7ffb\u8bd1\u6620\u5c04\", \"localization.json\");\n\t\t\t\tstd::ofstream io(LocalizationJSON);\n\t\t\t\tio << std::setw(4) << localization << std::endl;\n\t\t\t\tio.close();\n\t\t\t\tPAUSE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// \u672c\u5730\u8bfb\u53d6\u6c49\u5316\u6587\u4ef6\u5230json\u4e2d\n\t\t\tstd::if",
    "#include \"../Hooking/Hooking.hpp\"\n\n#include \"Ranked.hpp\"\n\n// TODO: Change the hook function because this is not a good way to do this. add mmr gain or loss\nvoid Ranked::ScoreboardSkillRating(UObject* Caller, UFunction* Function, void* Params)\n{\n\tauto PRI = (UGFxData_PRI_TA*)Caller;\n\n\tif (PRI && PRI->PlayerID.Platform != 0 && EnableScoreboardSkill)\n\t{\n\t\tauto OnlineGame = PRI->GetOnlineGame();\n\t\tauto APRI = PRI->PRI;\n\n\t\tif (OnlineGame && APRI)\n\t\t{\n\t\t\tauto GameEvent = (AGameEvent_Soccar_TA*)APRI->GameEvent;\n\t\t\t\n\t\t\tif (GameEvent && GameEvent->IsPlayingPublic() && !GameEvent->IsPlayingPrivate())\n\t\t\t{\n\t\t\t\tauto DataStore = GetDataStore();\n\t\t\t\tauto Playlist = GameEvent->GetPlaylist();\n\t\t\t\tauto Skill = OnlineGame->Skill;\n\n\t\t\t\tif (DataStore && Playlist && Skill)\n\t\t\t\t{\n\t\t\t\t\tif (!Skill->SkillsSynced(APRI->UniqueId))\n\t\t\t\t\t{\n\t\t\t\t\t\tSkill->SyncPlayerSkill(APRI->UniqueId, Skill->__EventSkillSynced__Delegate);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tauto Rating = Skill->GetUpdatedPlayerRating(APRI->UniqueId, Skill->GetSkillPlaylistID(Playlist->PlaylistId));\n\n\t\t\t\t\t\tfloat Current = Skill->GetMMR(Rating.Mu, Rating.Sigma) * 20.0f + 100.0f;\n\n\t\t\t\t\t\tstd::string PlayerName = std::format(\"{} [{:.1f}]\", APRI->PlayerName.ToString(), Current);\n\n\t\t\t\t\t\tDataStore->SetStringValue(L\"PlayerInfo\", PRI->RowIndex, L\"PlayerName\", std::wstring(PlayerName.begin(), PlayerName.end()).c_str());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Ranked::PlaylistSkillRating(UObject* Caller, UFunction* Function, void* Params)\n{\n\tauto PlaylistNode = (UMenuTreeNode_Playlist_TA*)Caller;\n\n\tif (PlaylistNode && EnablePlaylistSkill)\n\t{\n\t\tauto Playlist = PlaylistNode->Playlist;\n\t\tauto Node = PlaylistNode->GFxNode;\n\n\t\tif (Playlist && Node)\n\t\t{\n\t\t\tauto Shell = Node->Shell;\n\n\t\t\tif (Shell)\n\t\t\t{\n\t\t\t\tauto DataStore = Shell->DataStore;\n\n\t\t\t\tif (DataStore)\n\t\t\t\t{\n\t\t\t\t\tPlaylist->UpdateSkillData();\n\n\t\t\t\t\tauto Skill = Playlist->GetOnlineGameSkill();\n\n\t\t\t\t\tif (Skill)\n\t\t\t\t\t{\n\t\t\t\t\t\tauto Rating = Skill->GetUpdatedPlayerRating(GetUniqueNetId(), Playlist->Id);\n\n\t\t\t\t\t\tfloat Current = Skill->GetMMR(Rating.Mu, Rating.Sigma) * 20.0f + 100.0f;\n\t\t\t\t\t\tfloat Previous = Skill->GetMMR(Rating.PrevMu, Rating.PrevSigma) * 20.0f + 100.0f;\n\t\t\t\t\t\tfloat Change = Current - Previous;\n\n\t\t\t\t\t\tstd::string Title = Previous == 100.0f ? std::format(\"{} [{:.1f}]\", Playlist->KeyName.ToString(), Current) : std::format(\"{} [{:.1f}{}]\", Playlist->KeyName.ToString(), Previous, Change >= 0 ? std::format(\" + {:.1f}\", Change) : std::format(\" - {:.1f}\", std::abs(Change)));\n\n\t\t\t\t\t\tPlaylistNode->Title = DataStore->GetValue(L\"MenuTreePlaylistNode\", Node->RowIndex, L\"Title\").S;\n\n\t\t\t\t\t\tDataStore->SetStringValue(L\"MenuTreePlaylistNode\", Node->RowIndex, L\"Title\", std::wstring(Title.begin(), Title.end()).c_str());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Ranked::TournamentSkillRating(UObject* Caller, UFunction* Function, void* Params)\n{\n\tauto Tour = (UGFxData_AutoTour_TA*)Caller;\n\n\tif (Tour && EnableTournamentSkill)\n\t{\n\t\tauto Tournament = Tour->AutoTour;\n\n\t\tif (Tournament)\n\t\t{\n\t\t\tauto Game = Tournament->OnlineGame;\n\n\t\t\tif (Game)\n\t\t\t{\n\t\t\t\tauto Skill = Game->Skill;\n\n\t\t\t\tif (Skill)\n\t\t\t\t{\n\t\t\t\t\tauto Rating = Skill->GetUpdatedPlayerRating(GetUniqueNetId(), 34);\n\n\t\t\t\t\tfloat Current = Skill->GetMMR(Rating.Mu, Rating.Sigma) * 20.0f + 100.0f;\n\t\t\t\t\tfloat Previous = Skill->GetMMR(Rating.PrevMu, Rating.PrevSigma) * 20.0f + 100.0f;\n\t\t\t\t\tfloat Change = Current - Previous;\n\n\t\t\t\t\tfor (auto Card : Tour->TourCards)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Card)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tauto TourSetting = Card->GetEligibleTourSetting();\n\t\t\t\t\t\tauto Shell = Card->Shell;\n\n\t\t\t\t\t\tif (TourSetting && Shell)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto DataStore = Shell->DataStore;\n\n\t\t\t\t\t\t\tif (DataStore)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstd::string Title = Previous == 100.0f ? std::format(\"{} [{:.1f}]\", TourSetting->Title.ToString(), Current) : std::format(\"{} [{:.1f}{}]\", TourSetting->Title.ToString(), Previous, Change >= 0 ? std::format(\" + {:.1f}\", Change) : std::format(\" - {:.1f}\", std::abs(Change)));\n\n\t\t\t\t\t\t\t\tDataStore->SetStringValue(L\"AutoTourTourCard\", Card->RowIndex, L\"Title\", std::wstring(Title.begin(), Title.end()).c_str());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Ranked::Initialize()\n{\n\tHookFunction(\"Function TAGame.GFxData_PRI_TA.UpdatePRIData\", Hook::ProcessInternal, &ScoreboardSkillRating);\n\tHookFunctionPost(\"Function TAGame.MenuTreeNode_Playlist_TA.EventPlaylistNodeUpdated\", Hook::CallFunction, &PlaylistSkillRating);\n\tHookFunction(\"Function TAGame.GFxData_AutoTour_TA.Show\", Hook::ProcessInternal, &TournamentSkillRating);\n}",
    "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <random>\n#include <cstring>\n#include <ctime>\n\ndouble learning_rate = 0.01;\nint epoch = 10;\nint data_size = 0;\nint test_size = 0;\n\ninline double sigmoid(double x)\n{\n    return 1.0 / (1.0 + std::exp(-x));\n}\n\ninline double sigmoid_derivative(double x)\n{\n    return x * (1.0 - x);\n}\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-0.5, 0.5);\n\nconst int size_x = 28;\nconst int size_y = 28;\n\nconst int size = 500;\nint result;\nshort input[size_x * size_y];\ndouble weights1[size][size_x * size_y];\ndouble hidden[size];\ndouble weights2[10][size];\ndouble output[10];\ndouble hidden_error[size];\ndouble output_error[10];\n\nvoid init_weights()\n{\n    for (int i = 0; i < size; i++)\n        for (int j = 0; j < size_x * size_y; j++)\n            weights1[i][j] = dis(gen);\n    for (int i = 0; i < 10; i++)\n        for (int j = 0; j < size; j++)\n            weights2[i][j] = dis(gen);\n}\n\nvoid init_input(int count, bool test = false)\n{\n    char data_file[35];\n    sprintf(data_file, \"./data/data%d.txt\", count);\n    if (test)\n        sprintf(data_file, \"./data/data%d_test.txt\", count);\n    std::ifstream dat(data_file);\n    dat >> result;\n    dat.get();\n    for (int i = 0; i < size_x; i++)\n    {\n        for (int j = 0; j < size_y; j++)\n        {\n            char c = dat.get();\n            input[i * size_x + j] = (c == '*') ? 1 : 0;\n        }\n        dat.get();\n    }\n    dat.close();\n}\n\nvoid save_weights(int ep)\n{\n    std::ofstream out(\"weights.txt\");\n    out << ep << std::endl;\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size_x * size_y; j++)\n            out << weights1[i][j] << \" \";\n        out << std::endl;\n    }\n    for (int i = 0; i < 10; i++)\n    {\n        for (int j = 0; j < size; j++)\n            out << weights2[i][j] << \" \";\n        out << std::endl;\n    }\n    out.close();\n}\n\nint load_weights()\n{\n    std::ifstream in(\"weights.txt\");\n    int ep;\n    in >> ep;\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size_x * size_y; j++)\n            in >> weights1[i][j];\n    }\n    for (int i = 0; i < 10; i++)\n    {\n        for (int j = 0; j < size; j++)\n            in >> weights2[i][j];\n    }\n    in.close();\n    return ep;\n}\n\nvoid train()\n{\n    int i = 0;\n    std::ifstream weights(\"weights.txt\");\n    if (weights)\n        i = load_weights() + 1;\n    else\n        init_weights();\n    weights.close();\n    for (; i < epoch; i++)\n    {\n        int start_time = std::time(0);\n        std::cout << \"Epoch: \" << i + 1 << std::endl;\n        for (int j = 0; j < data_size; j++)\n        {\n            init_input(j + 1);\n\n            for (int n = 0; n < size; n++)\n            {\n                for (int m = 0; m < size_x * size_y; m++)\n                    hidden[n] += weights1[n][m] * input[m];\n                hidden[n] = sigmoid(hidden[n]);\n            }\n            for (int n = 0; n < 10; n++)\n            {\n                for (int m = 0; m < size; m++)\n                    output[n] += weights2[n][m] * hidden[m];\n                output[n] = sigmoid(output[n]);\n            }\n            for (int n = 0; n < 10; n++)\n                output_error[n] = output[n] - ((n == result - 1) ? 1 : 0);\n            for (int n = 0; n < size; n++)\n            {\n                hidden_error[n] = 0;\n                for (int m = 0; m < 10; m++)\n                    hidden_error[n] += weights2[m][n] * output_error[m];\n                hidden_error[n] *= sigmoid_derivative(hidden[n]);\n            }\n            for (int n = 0; n < 10; n++)\n            {\n                for (int m = 0; m < size; m++)\n                    weights2[n][m] -= learning_rate * output_error[n] * hidden[m];\n            }\n            for (int n = 0; n < size; n++)\n            {\n                for (int m = 0; m < size_x * size_y; m++)\n                    weights1[n][m] -= learning_rate * hidden_error[n] * input[m];\n            }\n\n            memset(hidden, sizeof(hidden), 0);\n            memset(output, sizeof(output), 0);\n            memset(hidden_error, sizeof(hidden_error), 0);\n            memset(output_error, sizeof(output_error), 0);\n        }\n        save_weights(i);\n        std::cout << \"Time used: \" << std::time(0) - start_time << \"s\" << std::endl;\n    }\n    std::cout << \"Training finished.\" << std::endl;\n}\n\nvoid test()\n{\n    std::cout << \"Testing...\" << std::endl;\n    int correct = 0;\n    int start_time = std::time(0);\n    for (int i = 0; i < test_size; i++)\n    {\n        init_input(i + 1, true);\n\n        for (int n = 0; n < size; n++)\n        {\n            for (int m = 0; m < size_x * size_y; m++)\n                hidden[n] += weights1[n][m] * input[m];\n            hidden[n] = sigmoid(hidden[n]);\n        }\n        for (int n = 0; n < 10; n++)\n        {\n\n            for (int m = 0; m < size; m++)\n                output[n] += weights2[n][m] * hidden[m];\n            output[n] = sigmoid(output[n]);\n        }\n        int max = 0;\n        for (int n = 1; n < 10; n+",
    "#include <iostream>\r\n#include <list>\r\n\r\nusing namespace std;\r\n\r\nclass User\r\n{\r\npublic:\r\n    string Fullname;\r\n    string Address;\r\n    string PhoneNumber;\r\n    int Age;\r\n    string Birthdate;\r\n\r\n    User(string f, string a, string p, int g, string b)\r\n     : Fullname(f), Address(a), PhoneNumber(p), Age(g), Birthdate(b) {}\r\n};\r\n\r\nclass UserService\r\n{\r\npublic:\r\n    list<User> Users;\r\n\r\n    void AddUser(User user)\r\n    {\r\n        Users.push_back(user);\r\n    }\r\n\r\n    void GetUser()\r\n    {\r\n        for(auto user : Users)\r\n        {\r\n            cout << \"Fullname: \" << user.Fullname << endl;\r\n            cout << \"Address: \" << user.Address << endl;\r\n            cout << \"Age: \" << user.Age << endl;\r\n            cout << \"PhoneNumber: \" << user.PhoneNumber << endl;\r\n            cout << \"Birthdate: \"<< user.Birthdate << endl;\r\n        }\r\n    }\r\n\r\n    void push_front(User user)\r\n    {\r\n        Users.push_front(user);\r\n    }\r\n\r\n    void reseiz()\r\n    {\r\n        Users.clear();\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    string Fullname, Address, PhoneNumber, Birthdate;\r\n    int Age;\r\n\r\n    cout << \"Welcome to taraqqiyot!\" << endl;\r\n\r\n    cout << \"Fullname: \";\r\n    cin >> Fullname;\r\n\r\n    cout << \"Address: \";\r\n    cin >> Address;\r\n\r\n    cout << \"Age: \";\r\n    cin >> Age;\r\n\r\n    cout << \"PhoneNumber: \";\r\n    cin >> PhoneNumber;\r\n\r\n    cout << \"Birthdate: \";\r\n    cin >> Birthdate;\r\n\r\n    UserService userService;\r\n\r\n    User newUser(Fullname, Address, PhoneNumber, Age, Birthdate);\r\n\r\n    userService.AddUser(newUser);\r\n\r\n    userService.GetUser();\r\n\r\n    cout << \"Foydalanuvchini ro'yxatning birinchi qismiga qo'shish:\" << endl;\r\n    userService.push_front(newUser);\r\n\r\n    cout << \"Foydalanuvchilar old qismga qo'shgandan keyin:\" << endl;\r\n    userService.GetUser();\r\n\r\n    cout << \"Ro'yxatni qayta tiklash:\" << endl;\r\n    userService.reseiz();\r\n\r\n    cout << \"O'lchamni o'zgartirgandan keyin foydalanuvchilar: \" << endl;\r\n    userService.GetUser();\r\n\r\n    return 0;\r\n}\r\n",
    "/***********************************************\n#\n# Author: Sun Qinxuan\n#\n# Email: sunqinxuan@outlook.com\n#\n# Last modified:\t2021-10-11 09:06\n#\n# Filename:\t\tavm.cpp\n#\n# Description: \n#\n************************************************/\n#include \"avm/avm.h\"\n\nnamespace RESMAL \n{\n\tusing namespace std;\n\tAVM::AVM() : //avm_width_(16.0), avm_resolution_(600), \n\t\t\t\t lookup_table_(new LookupTable()),\n\t\t\t\t dist_backwheel_(1.5), height_backwheel_(0.32), offset_(1.3), \n//\t\t\t\t dist_backwheel_(1.51), height_backwheel_(0.25), offset_(1.0), \n\t\t\t\t cx_avm_(avm_resolution_/2.0+offset_*avm_resolution_/avm_width_), \n\t\t\t\t cy_avm_(avm_resolution_/2.0),\n\t\t\t\t it_(nh_),\n\t\t\t\t filter_wd_(7)\n\t{\n\t\t// set trans_wheel_vehicle_;\n\t\t// T_wv = [ 1 0 0 |  0  ]\n\t\t//        [ 0 1 0 | -d/2]\n\t\t//        [ 0 0 1 |  h  ]\n\t\t//        [ 0 0 0 |  1  ]\n\t\ttrans_wheel_vehicle_.setIdentity();\n\t\ttrans_wheel_vehicle_.translation()(1)=-0.5*dist_backwheel_;\n\t\ttrans_wheel_vehicle_.translation()(2)=height_backwheel_;\n\t\ttrans_ground_vehicle_=trans_wheel_vehicle_;\n\n\t\tYAML::Node yaml_extrinsic=YAML::LoadFile(\"data/calib_extrinsic.yaml\");\n\t\tYAML::Node yaml_intrinsic_right=YAML::LoadFile(\"data/calib_right.yaml\");\n\t\tYAML::Node yaml_intrinsic_front=YAML::LoadFile(\"data/calib_front.yaml\");\n\t\tYAML::Node yaml_intrinsic_left=YAML::LoadFile(\"data/calib_left.yaml\");\n\t\tYAML::Node yaml_intrinsic_rear=YAML::LoadFile(\"data/calib_rear.yaml\");\n\n\t\tstd::vector<double> tmp;\n\t\tEigen::Quaterniond q;\n\n\t\t// [x,y,z,qw,qx,qy,qz]\n\t\ttmp=yaml_extrinsic[\"pose_wheel_camera_right\"].as<std::vector<double>>();\n\t\ttrans_wheel_camera_right_calib_.setIdentity();\n\t\ttrans_wheel_camera_right_calib_.translation()(0)=tmp[0];\n\t\ttrans_wheel_camera_right_calib_.translation()(1)=tmp[1];\n\t\ttrans_wheel_camera_right_calib_.translation()(2)=tmp[2];\n\t\tq.w()=tmp[3]; \n\t\tq.x()=tmp[4]; \n\t\tq.y()=tmp[5];\n\t\tq.z()=tmp[6]; \n\t\tq.normalize();\n\t\ttrans_wheel_camera_right_calib_.linear()=q.toRotationMatrix();\n\t\tcout<<\"trans_wheel_camera_right_calib_:\"<<endl<<trans_wheel_camera_right_calib_.matrix()<<endl<<endl;\n\t\ttrans_wheel_camera_right_=trans_wheel_camera_right_calib_;\n\n\t\ttmp=yaml_extrinsic[\"pose_wheel_camera_front\"].as<std::vector<double>>();\n\t\ttrans_wheel_camera_front_calib_.setIdentity();\n\t\ttrans_wheel_camera_front_calib_.translation()(0)=tmp[0];\n\t\ttrans_wheel_camera_front_calib_.translation()(1)=tmp[1];\n\t\ttrans_wheel_camera_front_calib_.translation()(2)=tmp[2];\n\t\tq.w()=tmp[3]; \n\t\tq.x()=tmp[4]; \n\t\tq.y()=tmp[5]; \n\t\tq.z()=tmp[6]; \n\t\tq.normalize();\n\t\ttrans_wheel_camera_front_calib_.linear()=q.toRotationMatrix();\n\t\tcout<<\"trans_wheel_camera_front_calib_:\"<<endl<<trans_wheel_camera_front_calib_.matrix()<<endl<<endl;\n\t\ttrans_wheel_camera_front_=trans_wheel_camera_front_calib_;\n\n\t\ttmp=yaml_extrinsic[\"pose_wheel_camera_left\"].as<std::vector<double>>();\n\t\ttrans_wheel_camera_left_calib_.setIdentity();\n\t\ttrans_wheel_camera_left_calib_.translation()(0)=tmp[0];\n\t\ttrans_wheel_camera_left_calib_.translation()(1)=tmp[1];\n\t\ttrans_wheel_camera_left_calib_.translation()(2)=tmp[2];\n\t\tq.w()=tmp[3]; \n\t\tq.x()=tmp[4]; \n\t\tq.y()=tmp[5]; \n\t\tq.z()=tmp[6]; \n\t\tq.normalize();\n\t\ttrans_wheel_camera_left_calib_.linear()=q.toRotationMatrix();\n\t\tcout<<\"trans_wheel_camera_left_calib_:\"<<endl<<trans_wheel_camera_left_calib_.matrix()<<endl<<endl;\n\t\ttrans_wheel_camera_left_=trans_wheel_camera_left_calib_;\n\n\t\ttmp=yaml_extrinsic[\"pose_wheel_camera_rear\"].as<std::vector<double>>();\n\t\ttrans_wheel_camera_rear_calib_.setIdentity();\n\t\ttrans_wheel_camera_rear_calib_.translation()(0)=tmp[0];\n\t\ttrans_wheel_camera_rear_calib_.translation()(1)=tmp[1];\n\t\ttrans_wheel_camera_rear_calib_.translation()(2)=tmp[2];\n\t\tq.w()=tmp[3]; \n\t\tq.x()=tmp[4];\n\t\tq.y()=tmp[5];\n\t\tq.z()=tmp[6];\n\t\tq.normalize();\n\t\ttrans_wheel_camera_rear_calib_.linear()=q.toRotationMatrix();\n\t\tcout<<\"trans_wheel_camera_rear_calib_:\"<<endl<<trans_wheel_camera_rear_calib_.matrix()<<endl<<endl;\n\t\ttrans_wheel_camera_rear_=trans_wheel_camera_rear_calib_;\n\n\t\ttmp=yaml_intrinsic_right[\"camera_matrix\"][\"data\"].as<std::vector<double>>();\n\t\tcamera_intrinsic_right_[0]=tmp[0];\n\t\tcamera_intrinsic_right_[1]=tmp[4];\n\t\tcamera_intrinsic_right_[2]=tmp[2];\n\t\tcamera_intrinsic_right_[3]=tmp[5];\n\t\ttmp=yaml_intrinsic_right[\"distortion_coefficients\"][\"data\"].as<std::vector<double>>();\n\t\tcamera_intrinsic_right_[4]=tmp[0];\n\t\tcamera_intrinsic_right_[5]=tmp[1];\n\t\tcamera_intrinsic_right_[6]=tmp[2];\n\t\tcamera_intrinsic_right_[7]=tmp[3];\n\t\tcamera_intrinsic_right_[8]=yaml_intrinsic_right[\"image_width\"].as<double>();\n\t\tcamera_intrinsic_right_[9]=yaml_intrinsic_right[\"image_height\"].as<double>();\n\t\tcout<<\"camera_intrinsic_right_: \"<<endl;\n\t\tfor(int i=0;i<10;i++) cout<<camera_intrinsic_right_[i]<<\" \";\n\t\tcout<<endl;\n\n\t\ttmp=yaml_intrinsic_front[\"camera_matrix\"][\"data\"].as<std::vector<double>>();\n\t\tcamera_intrinsic_front_[0]=tmp[0];\n\t\tcamera_intrinsic_front_[1]=tmp[4];\n\t\tcamera_intrinsic_front_[2]=tmp[2];\n\t\tcamera_intrinsic_front_[3]=tmp[5];\n\t\ttmp=yaml_intrinsic_front[\"distortion_coefficients\"][\"data\"].as<std::vector<double>>();\n\t\tcamera_intrinsic_front",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quetes_application\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"systemc.h\"\r\n#include \"fifo.h\"\r\n#include \"comun.h\"\r\n\r\n#include \"mem.h\"\r\n#include \"heatEq.h\"\r\n#include \"convHalf.h\"\r\n#include \"filtro3x3.h\"\r\n#include \"expandir.h\"\r\n#include \"suavizar.h\"\r\n#include \"convByte.h\"\r\n#include \"traducir.h\"\r\n#include \"pantalla.h\"\r\n#include \"escritor.h\"\r\n\r\n\r\nclass producer : public sc_module\r\n{\r\npublic:\r\n\tsc_port<write_if_T<sc_uint<19>>> readAddr; // , writeAddr; // producer output port\r\n//sc_port<write_if_T<sc_uint<8>>> dummy;\r\n\r\nSC_CTOR(producer) // module constructor\r\n{\r\n\tSC_THREAD(main); // start the process\r\n}\r\nvoid main() // the producer process\r\n{\r\n\tint i, j;\r\n\r\n\twhile (true) {\r\n\t\tfor (i = 0; i < HEIGHT; ++i) {\r\n\t\t\tfor (j = 0; j < WIDTH; ++j) {\r\n\t\t\t\treadAddr->write(j + i * WIDTH);\r\n\t\t\t\twait(SC_ZERO_TIME);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n};\r\n\r\n\r\n\r\nclass top : public sc_module\r\n{\r\npublic:\r\nfifo_T<sc_uint<19>> *QreadAddr, *QwriteAddr;\r\nfifo_T<sc_uint<8>> *QmemIn, *QmemOut, *Qnivel, *Qretorno;\r\nfifo_T<sc_uint<24>>* Qpixel;\r\nfifo_T<Ftype> *QhalfConv, *Qcalculado, * Qexpandido, *Qsuavizado, *QretornoFloat;\r\n\r\nfifo_T<Ftype>* Qdata00, * Qdata01, * Qdata02;\r\nfifo_T<Ftype>* Qdata10, * Qdata11, * Qdata12;\r\nfifo_T<Ftype>* Qdata20, * Qdata21, * Qdata22;\r\n\r\nfifo_T<Ftype>* QdataX00, * QdataX01, * QdataX02;\r\nfifo_T<Ftype>* QdataX10, * QdataX11, * QdataX12;\r\nfifo_T<Ftype>* QdataX20, * QdataX21, * QdataX22;\r\n\r\nproducer* instProducer;\r\nmem* instMem;\r\nheatEq* instHeatEq;\r\nconvHalf* instConvHalf;\r\nfiltro3x3* instFiltroEq; \r\nfiltro3x3* instFiltroSuavizar; \r\n\r\nexpandir* instExpandir;\r\nsuavizar* instSuavizar;\r\nconvByte* instConvByteRetorno, *instConvBytePantalla;\r\ntraducir* instTraducir;\r\npantalla* instPantalla;\r\nescritor* instEscritor;\r\n\r\n\r\nSC_CTOR(top) // the module constructor\r\n{\r\n\r\nQreadAddr = new fifo_T<sc_uint<19>>(\"QreadAddr\", 1);\r\nQwriteAddr = new fifo_T<sc_uint<19>>(\"QwriteAddr\", 1);\r\n\r\nQmemIn = new fifo_T<sc_uint<8>>(\"QmemIn\", 1);\r\nQmemOut = new fifo_T<sc_uint<8>>(\"QmemOut\",1);\r\nQretorno = new fifo_T<sc_uint<8>>(\"Qretorno\", 1);\r\n\r\nQnivel = new fifo_T<sc_uint<8>>(\"Qnivel\", 1);\r\nQpixel = new fifo_T<sc_uint<24>>(\"Qpixel\", 1);\r\n\r\nQhalfConv = new fifo_T<Ftype>(\"QhalfConv\", 1);\r\nQcalculado = new fifo_T<Ftype>(\"Qcalculado\", 1);\r\nQexpandido = new fifo_T<Ftype>(\"Qexpandido\", 1);\r\nQsuavizado = new fifo_T<Ftype>(\"Qsuavizado\", 1);\r\nQretornoFloat = new fifo_T<Ftype>(\"QretornoFloat\", 1);\r\n\r\nQdata00 = new fifo_T<Ftype>(\"Qdata00\", 1);\r\nQdata01 = new fifo_T<Ftype>(\"Qdata01\", 1);\r\nQdata02 = new fifo_T<Ftype>(\"Qdata02\", 1);\r\nQdata10 = new fifo_T<Ftype>(\"Qdata10\", 1);\r\nQdata11 = new fifo_T<Ftype>(\"Qdata11\", 1);\r\nQdata12 = new fifo_T<Ftype>(\"Qdata12\", 1);\r\nQdata20 = new fifo_T<Ftype>(\"Qdata20\", 1);\r\nQdata21 = new fifo_T<Ftype>(\"Qdata21\", 1);\r\nQdata22 = new fifo_T<Ftype>(\"Qdata22\", 1);\r\n\r\nQdataX00 = new fifo_T<Ftype>(\"QdataX00\", 1);\r\nQdataX01 = new fifo_T<Ftype>(\"QdataX01\", 1);\r\nQdataX02 = new fifo_T<Ftype>(\"QdataX02\", 1);\r\nQdataX10 = new fifo_T<Ftype>(\"QdataX10\", 1);\r\nQdataX11 = new fifo_T<Ftype>(\"QdataX11\", 1);\r\nQdataX12 = new fifo_T<Ftype>(\"QdataX12\", 1);\r\nQdataX20 = new fifo_T<Ftype>(\"QdataX20\", 1);\r\nQdataX21 = new fifo_T<Ftype>(\"QdataX21\", 1);\r\nQdataX22 = new fifo_T<Ftype>(\"QdataX22\", 1);\r\n\r\ninstProducer = new producer(\"instProducer\");\r\ninstMem = new mem(\"instMem\");\r\ninstConvHalf = new convHalf(\"instConvHalf\");\r\ninstFiltroEq = new filtro3x3(\"instFiltroEq\", WIDTH, HEIGHT);\r\ninstHeatEq = new heatEq(\"instHeatEq\");\r\n\r\ninstExpandir = new expandir(\"instExpandir\");\r\ninstFiltroSuavizar = new filtro3x3(\"instFiltroSuavizar\", WIDTH*2, HEIGHT*2);\r\ninstSuavizar = new suavizar(\"instSuavizar\");\r\ninstConvByteRetorno = new convByte(\"instConvByteRetorno\");\r\ninstConvBytePantalla = new convByte(\"instConvBytePantalla\");\r\ninstTraducir = new traducir(\"instTraducir\");\r\ninstPantalla = new pantalla(\"instPantalla\", \"videoCalor.yuv\");\r\ninstEscritor = new escritor(\"instEscritor\");\r\n\r\ninstProducer->readAddr(*QreadAddr);\r\n\r\ninstMem->readAddr( *QreadAddr);\r\ninstMem->writeAddr( *QwriteAddr);\r\ninstMem->dataIn( *QmemIn);\r\ninstMem->dataOut(*QmemOut);\r\n\r\ninstConvHalf->byteIn(*QmemOut);\r\ninstConvHalf->halfOut(*QhalfConv);\r\n\r\ninstFiltroEq->dataIn(*QhalfConv);\r\ninstFiltroEq->dataOut00(*Qdata00);\r\ninstFiltroEq->dataOut01(*Qdata01);\r\ninstFiltroEq->dataOut02(*Qdata02);\r\ninstFiltroEq->dataOut10(*Qdata10);\r\ninstFiltroEq->dataOut11(*Qdata11);\r\ninstFiltroEq->dataOut12(*Qdata12);\r\ninstFiltroEq->dataOut20(*Qdata20);\r\ninstFiltroEq->dataOut21(*Qdata21);\r\ninstFiltroEq->dataOut22(*Qdata22);\r\n\r\n\r\ninstHeatEq->dataIn00(*Qdata00);\r\ninstHeatEq->dataIn01(*Qdata01);\r\ninstHeatEq->dataIn02(*Qdata02);\r\ninstHeatEq->dataIn10(*Qdata10);\r\ninstHeatEq->dataIn11(*Qdata11);\r\ninstHeatEq->dataIn12(*Qdata12);\r\ninstHeatEq->dataIn20(*Qdata20);\r\ninstHeatEq->dataIn21(*Qdata21);\r\ninstHeatEq->dataIn22(*Qdata22);\r\ninstHeatEq->dataOut(*Qcalculado);\r\ninstHeatEq->retorno(*QretornoFloat);\t// es una copia de Qcalculado\r\n\r\ninstConvByteRetorno->halfIn(*QretornoFloat);\r\ninstConvByteRetorno->byteOut(*Qretorno);\r\n\r\ninstEscritor->byteIn(*Qretorno);\r\ninstEscritor->byteOut(*QmemIn);\r\ninstEscritor->write",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host windo doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().\n//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.\n//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.\n//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when ",
    "#pragma once\n\n#include \"object/_all.hpp\"\n#include \"ast/_all.hpp\"\n#include \"parser/parser.hpp\"\n\nstd::shared_ptr<Node> Parser::make_error() {\n    parse_token();\n    return std::make_shared<ErrorNode>();\n}\n\nstd::shared_ptr<Node> Parser::parse_program() {\n    auto region = std::make_shared<RegionNode>();\n    while (_current->type != Token::Type::End) {\n        if (_current->type == Token::Type::Import && doImport) {\n            parse_import_now(region);\n            continue;\n        }\n        region->statements.push_back(parse_statement());\n    }\n    parse_token();\n    return std::make_shared<ProgramNode>(region);\n}\n\nstd::shared_ptr<Node> Parser::parse_statement() {\n    switch (_current->type) {\n    case Token::Type::LBrace:\n        return parse_region();\n    case Token::Type::Class:\n        return parse_class_creation();\n    case Token::Type::Const:\n    case Token::Type::Let:\n    case Token::Type::Private:\n    case Token::Type::Public:\n    case Token::Type::Var:\n    case Token::Type::Global:\n        return std::make_shared<StatementNode>(parse_creation());\n    case Token::Type::Constructor:\n    case Token::Type::Destructor:\n        return parse_function_creation();\n    case Token::Type::If:\n        return parse_if();\n    case Token::Type::Import:\n        return std::make_shared<StatementNode>(parse_import());\n    case Token::Type::Return:\n        return std::make_shared<StatementNode>(parse_return());\n    case Token::Type::For:\n        return parse_for();\n    case Token::Type::While:\n    case Token::Type::Dowhile:\n        return parse_while();\n    case Token::Type::Enumerate:\n        return parse_enumerate_creation();\n    case Token::Type::Delete:\n        return std::make_shared<StatementNode>(parse_remove());\n    default:\n        return std::make_shared<StatementNode>(parse_expr());\n    }\n}\n\nstd::shared_ptr<Node> Parser::parse_region() {\n    if (_current->type != Token::Type::LBrace) {\n        format_error(\"Regions must start with a left brace.\");\n        return make_error();\n    }\n    parse_token();\n    auto region = std::make_shared<RegionNode>();\n    while (!shouldEnd()) {\n        if (_current->type == Token::Type::Import && doImport) {\n            parse_import_now(region);\n            continue;\n        }\n        region->statements.push_back(parse_statement());\n    }\n    if (_current->type != Token::Type::RBrace) {\n        end_not_correct_error();\n    }\n    parse_token();\n    return region;\n}\n\nstd::shared_ptr<Node> Parser::parse_expr() {\n    return std::make_shared<ExprNode>(parse_expr_level(OperatorPriority::Lowest));\n}\n\nstd::shared_ptr<Node> Parser::parse_expr_level(OperatorPriority pri) {\n    auto _node = lookupPre(_current->type);\n    if (_node->type == Node::Type::Error) {\n        return _node;\n    }\n    while (!shouldEnd() && pricmp(pri, getpri(_current->type))) {\n        _node = lookupIn(_current->type, _node);\n        if (_node->type == Node::Type::Error) {\n            return _node;\n        }\n    }\n    if (_current->type == Token::Type::Semicolon) {\n        parse_token();\n    }\n    return _node;\n}\n\nstd::shared_ptr<Node> Parser::parse_if() {\n    if (_current->type != Token::Type::If) {\n        unhandled_compiler_error();\n        return make_error();\n    }\n    parse_token();\n    auto _node = std::make_shared<IfNode>();\n    _node->_cond = parse_expr();\n    _node->_then = parse_statement();\n    if (_current->type == Token::Type::Else) {\n        parse_token();\n        _node->_else = parse_statement();\n    }\n}\n\nstd::shared_ptr<Node> Parser::parse_for() {\n    if (_current->type != Token::Type::For) {\n        unhandled_compiler_error();\n        return make_error();\n    }\n    parse_token();\n    auto _node = std::make_shared<ForNode>();\n    _node->_var = parse_identifier();\n    if (_current->type != Token::Type::LParan) {\n        format_error(\"For-Repeat must be written in the format of \\\"for var(range) statement\\\".\");\n    }\n    parse_token();\n    _node->_elem = parse_expr();\n    if (_current->type != Token::Type::RParan) {\n        format_error(\"For-Repeat must be written in the format of \\\"for var(range) statement\\\".\");\n    }\n    parse_token();\n    _node->_body = parse_statement();\n}\n\nstd::shared_ptr<Node> Parser::parse_while() {\n    if (_current->type != Token::Type::While && _current->type != Token::Type::Dowhile) {\n        unhandled_compiler_error();\n        return make_error();\n    }\n    bool isDoWhile = (_current->type == Token::Type::Dowhile);\n    parse_token();\n    auto _node = std::make_shared<WhileNode>();\n    _node->isDoWhile = isDoWhile;\n    _node->_cond = parse_expr();\n    _node->_body = parse_statement();\n}\n\nstd::shared_ptr<Node> Parser::parse_function() {\n    if (_current->type != Token::Type::Function && _current->type != Token::Type::Lambda) {\n        unhandled_compiler_error();\n        return make_error();\n    }\n    auto _obj = std::make_shared<FunctionNode>();\n    _obj->isLambda = (_current->type == Token::Type::Lambda);\n\n    parse_token();\n    if (_current->type != Token::Type::LParan) {\n",
    "#include \"CustomGCode.hpp\"\n#include \"Config.hpp\"\n#include \"GCode.hpp\"\n#include \"GCodeWriter.hpp\"\n\nnamespace Slic3r {\n\nnamespace CustomGCode {\n\n//BBS: useless config and function\n#if 0\n// If loaded configuration has a \"colorprint_heights\" option (if it was imported from older Slicer), \n// and if CustomGCode::Info.gcodes is empty (there is no color print data available in a new format\n// then CustomGCode::Info.gcodes should be updated considering this option.\nextern void update_custom_gcode_per_print_z_from_config(Info& info, DynamicPrintConfig* config)\n{\n\tauto *colorprint_heights = config->option<ConfigOptionFloats>(\"colorprint_heights\");\n    if (colorprint_heights == nullptr)\n        return;\n    if (info.gcodes.empty() && ! colorprint_heights->values.empty()) {\n\t\t// Convert the old colorprint_heighs only if there is no equivalent data in a new format.\n        const std::vector<std::string>& colors = ColorPrintColors::get();\n        const auto& colorprint_values = colorprint_heights->values;\n        info.gcodes.clear();\n        info.gcodes.reserve(colorprint_values.size());\n        int i = 0;\n        for (auto val : colorprint_values)\n            info.gcodes.emplace_back(Item{ val, ColorChange, 1, colors[(++i)%7] });\n\n        info.mode = SingleExtruder;\n\t}\n\n\t// The \"colorprint_heights\" config value has been deprecated. At this point of time it has been converted\n\t// to a new format and therefore it shall be erased.\n    config->erase(\"colorprint_heights\");\n}\n#endif\n\n// If information for custom Gcode per print Z was imported from older Slicer, mode will be undefined.\n// So, we should set CustomGCode::Info.mode should be updated considering code values from items.\nextern void check_mode_for_custom_gcode_per_print_z(Info& info)\n{\n    if (info.mode != Undef)\n        return;\n\n    bool is_single_extruder = true;\n    for (auto item : info.gcodes) \n    {\n        if (item.type == ToolChange) {\n            info.mode = MultiAsSingle;\n            return;\n        }\n        if (item.type == ColorChange && item.extruder > 1)\n            is_single_extruder = false;\n    }\n\n    info.mode = is_single_extruder ? SingleExtruder : MultiExtruder;\n}\n\n// Return pairs of <print_z, 1-based extruder ID> sorted by increasing print_z from custom_gcode_per_print_z.\n// print_z corresponds to the first layer printed with the new extruder.\nstd::vector<std::pair<double, unsigned int>> custom_tool_changes(const Info& custom_gcode_per_print_z, size_t num_extruders)\n{\n    std::vector<std::pair<double, unsigned int>> custom_tool_changes;\n    for (const Item& custom_gcode : custom_gcode_per_print_z.gcodes)\n        if (custom_gcode.type == ToolChange) {\n            // If extruder count in PrinterSettings was changed, use default (0) extruder for extruders, more than num_extruders\n            assert(custom_gcode.extruder >= 0);\n            custom_tool_changes.emplace_back(custom_gcode.print_z, static_cast<unsigned int>(size_t(custom_gcode.extruder) > num_extruders ? 1 : custom_gcode.extruder));\n        }\n    return custom_tool_changes;\n}\n\n} // namespace CustomGCode\n\n} // namespace Slic3r\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"ProjectKJClientPlayerController.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Blueprint/AIBlueprintHelperLibrary.h\"\n#include \"NiagaraSystem.h\"\n#include \"NiagaraFunctionLibrary.h\"\n#include \"ProjectKJClientCharacter.h\"\n#include \"Engine/World.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"InputActionValue.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"Engine/LocalPlayer.h\"\n\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\n\nAProjectKJClientPlayerController::AProjectKJClientPlayerController()\n{\n\tbShowMouseCursor = true;\n\tDefaultMouseCursor = EMouseCursor::Default;\n\tCachedDestination = FVector::ZeroVector;\n\tFollowTime = 0.f;\n}\n\nvoid AProjectKJClientPlayerController::BeginPlay()\n{\n\t// Call the base class  \n\tSuper::BeginPlay();\n\n\t//Add Input Mapping Context\n\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(GetLocalPlayer()))\n\t{\n\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t}\n}\n\nvoid AProjectKJClientPlayerController::SetupInputComponent()\n{\n\t// set up gameplay key bindings\n\tSuper::SetupInputComponent();\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(InputComponent))\n\t{\n\t\t// Setup mouse input events\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Started, this, &AProjectKJClientPlayerController::OnInputStarted);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Triggered, this, &AProjectKJClientPlayerController::OnSetDestinationTriggered);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Completed, this, &AProjectKJClientPlayerController::OnSetDestinationReleased);\n\t\tEnhancedInputComponent->BindAction(SetDestinationClickAction, ETriggerEvent::Canceled, this, &AProjectKJClientPlayerController::OnSetDestinationReleased);\n\n\t\t// Setup touch input events\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Started, this, &AProjectKJClientPlayerController::OnInputStarted);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Triggered, this, &AProjectKJClientPlayerController::OnTouchTriggered);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Completed, this, &AProjectKJClientPlayerController::OnTouchReleased);\n\t\tEnhancedInputComponent->BindAction(SetDestinationTouchAction, ETriggerEvent::Canceled, this, &AProjectKJClientPlayerController::OnTouchReleased);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemplateCharacter, Error, TEXT(\"'%s' Failed to find an Enhanced Input Component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.\"), *GetNameSafe(this));\n\t}\n}\n\nvoid AProjectKJClientPlayerController::OnInputStarted()\n{\n\tStopMovement();\n}\n\n// Triggered every frame when the input is held down\nvoid AProjectKJClientPlayerController::OnSetDestinationTriggered()\n{\n\t// We flag that the input is being pressed\n\tFollowTime += GetWorld()->GetDeltaSeconds();\n\t\n\t// We look for the location in the world where the player has pressed the input\n\tFHitResult Hit;\n\tbool bHitSuccessful = false;\n\tif (bIsTouch)\n\t{\n\t\tbHitSuccessful = GetHitResultUnderFinger(ETouchIndex::Touch1, ECollisionChannel::ECC_Visibility, true, Hit);\n\t}\n\telse\n\t{\n\t\tbHitSuccessful = GetHitResultUnderCursor(ECollisionChannel::ECC_Visibility, true, Hit);\n\t}\n\n\t// If we hit a surface, cache the location\n\tif (bHitSuccessful)\n\t{\n\t\tCachedDestination = Hit.Location;\n\t}\n\t\n\t// Move towards mouse pointer or touch\n\tAPawn* ControlledPawn = GetPawn();\n\tif (ControlledPawn != nullptr)\n\t{\n\t\tFVector WorldDirection = (CachedDestination - ControlledPawn->GetActorLocation()).GetSafeNormal();\n\t\tControlledPawn->AddMovementInput(WorldDirection, 1.0, false);\n\t}\n}\n\nvoid AProjectKJClientPlayerController::OnSetDestinationReleased()\n{\n\t// If it was a short press\n\tif (FollowTime <= ShortPressThreshold)\n\t{\n\t\t// We move there and spawn some particles\n\t\tUAIBlueprintHelperLibrary::SimpleMoveToLocation(this, CachedDestination);\n\t\tUNiagaraFunctionLibrary::SpawnSystemAtLocation(this, FXCursor, CachedDestination, FRotator::ZeroRotator, FVector(1.f, 1.f, 1.f), true, true, ENCPoolMethod::None, true);\n\t}\n\n\tFollowTime = 0.f;\n}\n\n// Triggered every frame when the input is held down\nvoid AProjectKJClientPlayerController::OnTouchTriggered()\n{\n\tbIsTouch = true;\n\tOnSetDestinationTriggered();\n}\n\nvoid AProjectKJClientPlayerController::OnTouchReleased()\n{\n\tbIsTouch = false;\n\tOnSetDestinationReleased();\n}\n",
    "#include <WinSock2.h>\r\n#include <mswsock.h>\r\n// IPV6 \u00d6\u00a7\u00b3\u00d6\r\n#include <ws2tcpip.h>\r\n\r\n#include <list>\r\n\r\n#include <stdio.h>\r\n\r\n#pragma comment(lib,\"ws2_32\")\r\n\r\nusing namespace std;\r\n\r\nstruct scan_overlapped\r\n{\r\n\tOVERLAPPED o;\r\n\r\n\tint fd;\r\n\r\n\tint port;\r\n};\r\n\r\nstruct scanner\r\n{\r\n\tHANDLE *hcompletions;\r\n\r\n\tLPFN_CONNECTEX pfn_connectex;\r\n\tLPFN_DISCONNECTEX pfn_disconnectex;\r\n\r\n\tHANDLE *hthreads;\r\n\r\n\tHANDLE hevent;\r\n\r\n\tunsigned int i;\r\n\r\n\tvolatile unsigned int v;\r\n\r\n\tint working;\r\n};\r\n\r\nDWORD WINAPI scan_thread_proc(LPVOID parameter)\r\n{\r\n\tstruct scanner *pscanner = (struct scanner *)parameter;\r\n\tHANDLE hcompletion;\r\n\tstruct scan_overlapped *pso;\r\n\tOVERLAPPED *po;\r\n\tULONG_PTR completionkey;\r\n\tDWORD numberofbytes;\r\n\tSOCKET fd;\r\n\tBOOL flag;\r\n\tunsigned int i;\r\n\tunsigned int port;\r\n\r\n\ti = pscanner->i;\r\n\thcompletion = pscanner->hcompletions[i];\r\n\r\n\tSetEvent(pscanner->hevent);\r\n\r\n\twhile (pscanner->working)\r\n\t{\r\n\t\tflag = GetQueuedCompletionStatus(hcompletion, &numberofbytes, &completionkey, &po, INFINITE);\r\n\t\t//printf(\"flag %d, po %p\\r\\n\", flag, po);\r\n\t\t//if (flag)\r\n\t\t{\r\n\t\t\tif (po)\r\n\t\t\t{\r\n\t\t\t\tpso = (struct scan_overlapped *)CONTAINING_RECORD(po, struct scan_overlapped, o);\r\n\r\n\t\t\t\tport = pso->port;\r\n\t\t\t\tpso->fd = -1;\r\n\r\n\t\t\t\tfd = (SOCKET)completionkey;\r\n\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tsetsockopt(fd, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"port %d\\r\\n\", port);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpscanner->pfn_disconnectex(fd, NULL, 0, 0);\r\n\r\n\t\t\t\tclosesocket(fd);\r\n\r\n\t\t\t\tInterlockedDecrement((volatile unsigned int *)&pscanner->v);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn(0);\r\n}\r\n\r\nint myconnect(list<struct scan_overlapped> *fds, struct scanner *pscanner, const struct sockaddr *psa, unsigned int len, unsigned int port,\r\n\tunsigned int i)\r\n{\r\n\tGUID id_connectex = WSAID_CONNECTEX;\r\n\tGUID id_disconnectex = WSAID_DISCONNECTEX;\r\n\tDWORD numberofbytes = 0;\r\n\tstruct scan_overlapped so;\r\n\tstruct scan_overlapped *pso;\r\n\tSOCKET fd;\r\n\tint result = 0;\r\n\r\n\tfd = WSASocket(psa->sa_family, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);\r\n\tif (fd != -1 && CreateIoCompletionPort((HANDLE)fd, pscanner->hcompletions[i], (ULONG_PTR)fd, 0) == pscanner->hcompletions[i])\r\n\t{\r\n\t\tif ((pscanner->pfn_connectex || WSAIoctl(fd, SIO_GET_EXTENSION_FUNCTION_POINTER, &id_connectex, sizeof(id_connectex), &pscanner->pfn_connectex, sizeof(pscanner->pfn_connectex), &numberofbytes, NULL, NULL) != SOCKET_ERROR) && \r\n\t\t\t(pscanner->pfn_disconnectex || WSAIoctl(fd, SIO_GET_EXTENSION_FUNCTION_POINTER, &id_disconnectex, sizeof(id_disconnectex), &pscanner->pfn_connectex, sizeof(pscanner->pfn_disconnectex), &numberofbytes, NULL, NULL) != SOCKET_ERROR))\r\n\t\t{\r\n\t\t\tlist<struct scan_overlapped>::reverse_iterator rit;\r\n\r\n\t\t\tmemset(&so.o, 0, sizeof(so.o));\r\n\t\t\tso.port = port;\r\n\r\n\t\t\tfds->push_back(so);\r\n\t\t\trit = fds->rbegin();\r\n\r\n\t\t\tpso = &*rit;\r\n\r\n\t\t\tpso->fd = fd;\r\n\r\n\t\t\tstruct sockaddr_in sai;\r\n\r\n\t\t\tmemset(&sai, 0, sizeof(sai));\r\n\t\t\tsai.sin_family = psa->sa_family;\r\n\t\t\tsai.sin_addr.S_un.S_addr = 0;\r\n\t\t\tsai.sin_port = 0;\r\n\r\n\t\t\tbind(fd, (const struct sockaddr *)&sai, len);\r\n\r\n\t\t\tInterlockedIncrement((volatile unsigned int *)&pscanner->v);\r\n\r\n\t\t\t//if (pscanner->v > 10000)\r\n\t\t\t//{\r\n\t\t\t//\tunsigned int v = pscanner->v;\r\n\r\n\t\t\t//\twhile (pscanner->v + 5000 > v)\r\n\t\t\t//\t{\r\n\t\t\t//\t\tSleep(1000);\r\n\t\t\t//\t}\r\n\t\t\t//}\r\n\r\n\t\t\tint errorcode;\r\n\t\t\tresult = pscanner->pfn_connectex(fd, (const struct sockaddr *)psa, len, NULL, 0, NULL, &pso->o) ||\r\n\t\t\t\t(errorcode = WSAGetLastError()) == ERROR_IO_PENDING;\r\n\r\n\t\t\tif (result == 0)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"errorcode %d\\r\\n\", errorcode);\r\n\r\n\t\t\t\t//closesocket(fd);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn(result);\r\n}\r\n\r\nint wmain(int argc, WCHAR *argv[])\r\n{\r\n\tlist<struct scan_overlapped> fds;\r\n\tstruct scanner pscanner[1];\r\n\tunsigned int i;\r\n\tunsigned int count;\r\n\r\n\tWSADATA wsadata;\r\n\r\n\tWSAStartup(MAKEWORD(2, 2), &wsadata);\r\n\r\n\tstruct sockaddr_in sai;\r\n\r\n\tmemset(&sai, 0, sizeof(sai));\r\n\tsai.sin_family = AF_INET;\r\n\r\n\tpscanner->v = 0;\r\n\r\n\tchar cp[256];\r\n\tif (argc > 1)\r\n\t{\r\n\t\ti = 0;\r\n\t\twhile (argv[1][i] != '\\0' && i + 1 < sizeof(cp))\r\n\t\t{\r\n\t\t\tcp[i] = argv[1][i];\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tcp[i] = '\\0';\r\n\t}\r\n\tsai.sin_addr.S_un.S_addr = inet_addr(cp);\r\n\r\n\tSYSTEM_INFO si;\r\n\tGetSystemInfo(&si);\r\n\r\n\tcount = si.dwNumberOfProcessors;\r\n\r\n\tprintf(\"%s, %d\\r\\n\", cp, count);\r\n\r\n\tunsigned int tickcount0;\r\n\tunsigned int tickcount1;\r\n\r\n\ttickcount0 = GetTickCount();\r\n\r\n\t// \u00b2\u00bb\u00d7\u00f7\u00b4\u00ed\u00ce\u00f3\u00c5\u00d0\u00b6\u00cf\r\n\r\n\tpscanner->pfn_connectex = NULL;\r\n\tpscanner->pfn_disconnectex = NULL;\r\n\r\n\tpscanner->working = 1;\r\n\r\n\tpscanner->hevent = CreateEvent(NULL, TRUE, FALSE, NULL);\r\n\r\n\tpscanner->hcompletions = (HANDLE *)malloc(sizeof(HANDLE)* count);\r\n\tpscanner->hthreads = (HANDLE *)malloc(sizeof(HANDLE)* count);\r\n\tfor (i = 0; i < count; i++)\r\n\t{\r\n\t\tpscanner->hcompletions[i] = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);\r\n\r\n\t\tpscanner->i = i;\r\n\t\tResetEvent(pscanner->hevent);\r\n\t\tif (pscanner->hthreads[i] = CreateThread(NULL, 0, scan_thread_proc, pscanner, 0, NULL))\r\n\t\t{\r\n\t\t\tWaitForSingleObject(pscanner->hevent, INFINITE);\r",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "\ufeff#pragma warning(disable : 4996)\n#include <iostream>\n#include <fstream>\n//https://github.com/google/benchmark/pull/1470\n#define BENCHMARK_STATIC_DEFINE\n#pragma comment(lib, \"shlwapi.lib\")\n#include <benchmark/benchmark.h>\n#include <openssl/sha.h>\n#include <immintrin.h>\n#include \"micro_hash256.h\"\n\nstd::shared_ptr<char[]> data;\nstd::streampos fsize;\nstd::shared_ptr<char[]> read_file_to_buffer(const char* filename, std::streampos& file_size);\nstd::streampos fileSize(const char* filePath);\n\nvoid print_sha256_hash(const uint8_t hash[32]) {\n  for (int i = 0; i < 32; ++i) {\n    printf(\"%02x\", hash[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid OsCryptAPI(benchmark::State& state) {\n  uint8_t hash_bytes[32]{};\n  for (auto _ : state) {\n    sha256Buffer((uint8_t*)data.get(), fsize, hash_bytes, 32);\n  }\n  //print_sha256_hash(hash_bytes);\n}\nvoid OpensslCryptAPI(benchmark::State& state) {\n  uint8_t hash_bytes[32]{};\n  SHA256_CTX sha256;\n  SHA256_Init(&sha256);\n  for (auto _ : state) {\n    SHA256_Update(&sha256, data.get(), fsize);\n    SHA256_Final(hash_bytes, &sha256);\n  }\n  //print_sha256_hash(hash_bytes);\n\n}\nBENCHMARK(OsCryptAPI)->Unit(benchmark::TimeUnit::kSecond)->Iterations(1);\nBENCHMARK(OpensslCryptAPI)->Unit(benchmark::TimeUnit::kSecond)->Iterations(1);\n\nint main(int argc,char*argv[])\n{\n  data = read_file_to_buffer(R\"(C:\\Program Files\\Google\\Chrome\\Application\\123.0.6312.107\\chrome.dll)\",fsize);\n\n  benchmark::Initialize(&argc, argv);\n  benchmark::RunSpecifiedBenchmarks();\n  benchmark::Shutdown();\n}\n\nstd::shared_ptr<char[]> read_file_to_buffer(const char* filename,\n                                           std::streampos& file_size) {\n  std::ifstream ifile(filename, std::ios::binary | std::ios::in);\n  if (!ifile.is_open()) {\n    return NULL;\n  }\n  auto fsize = fileSize(filename);\n  if (fsize == 0) return NULL;\n  file_size = fsize;\n\n  auto p = std::shared_ptr<char[]>(new char[fsize]);\n  ifile.read(p.get(), fsize);\n\n  return p;\n}\n\nstd::streampos fileSize(const char* filePath) {\n  std::streampos fsize = 0;\n  std::ifstream file(filePath, std::ios::binary);\n\n  fsize = file.tellg();\n  file.seekg(0, std::ios::end);\n  fsize = file.tellg() - fsize;\n  file.close();\n\n  return fsize;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <ctime>\r\n#include <iostream>\r\n#include <filesystem>\r\n#include <string>\r\n#include <fstream>\r\n#include <Windows.h>\r\n#include \"commands.h\"\r\n\r\nnamespace fs = std::filesystem;\r\ntypedef std::string string;\r\n\r\n//clear terminal command\r\nvoid purge() { std::cout << \"\\033[2J\\033[1;1H\"; }\r\n\r\n//print something in the terminal (print is removed)\r\nvoid print(string message) {\r\n\ttry {\r\n\t\tstd::cout << message.substr(6) << \"\\n\";\r\n\t}\r\n\tcatch (std::exception& e) {\r\n\t\tstd::cerr << \"PrintError : No content.\";\r\n\t}\r\n}\r\n\r\n//Show the current time\r\nvoid time() {\r\n\tstd::time_t currentTime = time(nullptr);\r\n\tstd::tm* timeInfo = std::localtime(&currentTime);\r\n\r\n\tchar buffer[80];\r\n\tstd::strftime(buffer, sizeof(buffer), \"%Y-%m-%d / %H:%M:%S\", timeInfo);\r\n\tstd::cout << \"The current time : \" << buffer << \"\\n\";\r\n}\r\n\r\n\r\n//Show all the folder where the user is located\r\nvoid showFolder(fs::path actualPath) {\r\n\ttry {\r\n\t\t//browse the actualPath\r\n\t\tfor (const auto& entry : fs::directory_iterator(actualPath)) {\r\n\t\t\t//check if it is a regular file\r\n\t\t\tif (fs::is_regular_file(entry)) {\r\n\t\t\t\tstd::cout << \"File : \" << entry.path() << \"\\n\";\r\n\t\t\t}\r\n\t\t\t//check if it is a directory\r\n\t\t\telse if (fs::is_directory(entry)) {\r\n\t\t\t\tstd::cout << \"Directory : \" << entry.path() << \"\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//ERROR MANAGEMENT \r\n\tcatch (const std::exception& e) {\r\n\t\t// e.what() -> show the error\r\n\t\tstd::cerr << \"Error accessing directory : \" << e.what() << \"\\n\";\r\n\t}\r\n\r\n}\r\n\r\n//Change the directory\r\nbool changeDir(string newPath, fs::path& savedPath) {\r\n\ttry {\r\n\t\t//remove 'gt' -> get the path without the command\r\n\t\tnewPath = newPath.substr(3);\r\n\t\tfs::current_path(newPath);\r\n\t\tsavedPath = fs::current_path();\r\n\t\treturn true;\r\n\t}\r\n\t//error management\r\n\tcatch (std::exception) {\r\n\t\tstd::cerr << \"DirectoryError : The requested file could not be found.\\n\";\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n}\r\n\r\nbool makeDir(string nameDir) {\r\n\ttry {\r\n\t\tnameDir = nameDir.substr(6);\r\n\t\tif (fs::exists(nameDir)) {\r\n\t\t\tstd::cout << \"The file already exists.\\n\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (fs::create_directory(nameDir)) {\r\n\t\t\tstd::cout << nameDir << \" has been created successfully.\\n\";\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t}\r\n\tcatch (std::exception& e) {\r\n\t\tstd::cerr << \"FileCreationError :\" << e.what() << std::endl;\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n}\r\n\r\nbool delFolder(string nameDir) {\r\n\ttry {\r\n\t\tnameDir = nameDir.substr(5);\r\n\t\tif (fs::exists(nameDir)) {\r\n\t\t\t//delete all directory / file\r\n\t\t\tfs::remove_all(nameDir);\r\n\t\t\tstd::cout << nameDir << \" has been deleted successfully.\";\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t//if the spelling is false\r\n\t\telse std::cout << nameDir << \" is not a file, check the spelling.\\n\"; return false;\r\n\t}\r\n\t//error management\r\n\tcatch (std::exception& e) {\r\n\t\tstd::cerr << \"FileDeleteError : \" << e.what() << std::endl;\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool moveFile(string fileToMove) {\r\n\t//newDirectory / input C:\\Users\\amogu\\Desktop\\iMAGE\r\n\tstd::string newDirectoryInput;\r\n\ttry {\r\n\t\t//get file name\r\n\t\tfileToMove = fileToMove.substr(3);\r\n\r\n\t\tfs::path file(fileToMove);\r\n\r\n\t\t// check if file exists\r\n\t\tif (fs::exists(file)) {\r\n\t\t\tstd::cout << \"Where do you want to move \" << file.filename() << \"> \";\r\n\t\t\tstd::getline(std::cin >> std::ws, newDirectoryInput);\r\n\t\t\t// check if new dir exists\r\n\t\t\tif (fs::exists(newDirectoryInput)) {\r\n\r\n\r\n\t\t\t\tfs::path newDirectory(newDirectoryInput);\r\n\t\t\t\tfs::rename(file, newDirectory / file.filename());\r\n\t\t\t\tstd::cout << \"moved successfully\";\r\n\t\t\t\treturn true;\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//if path doesn't exist\r\n\t\t\tstd::cout << \"Error! : \\n-Path to move the file doesn't exist.\\n\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// if file does not exist\r\n\t\tstd::cout << \"Error! : \\n-File to move doesn't exist.\\n\";\r\n\t\treturn false;\r\n\r\n\t}\r\n\tcatch (std::exception& e) {\r\n\t\tstd::cerr << \"File moving error : \" << e.what() << \"\\n\";\r\n\t}\r\n}\r\n\r\nbool renameFile(string oldName) {\r\n\ttry {\r\n\t\toldName = oldName.substr(4);\r\n\t\tstd::string newName;\r\n\t\tif (fs::exists(oldName)) {\r\n\t\t\tstd::cout << \"New file / Directory name (with extension)  : \";\r\n\t\t\tstd::getline(std::cin >> std::ws, newName);\r\n\t\t\tfs::rename(oldName, newName);\r\n\t\t\tstd::cout << oldName << \" has been renamed successfully.\";\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\tstd::cout << \"Error : 2 possibilites : \\n-The initial file doesn't exist.\\n-Wrong spelling initial file.\\n\";\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\tcatch (std::exception& e) {\r\n\t\tstd::cerr << \"File naming error : \" << e.what() << \"\\n\";\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool makeFile(string name) {\r\n\ttry {\r\n\t\tname = name.substr(4);\r\n\t\tstd::ofstream mkFile(name);\r\n\t\tif (mkFile.is_open()) {\r\n\t\t\tstd::cout << \"File created successfully\";\r\n\t\t\tmkFile.close();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\tcatch (std::exception& e) {\r\n\t\tstd::cerr << \"File creating error : \" << e.what() << \"\\n\";\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool copyFile(string file) {\r\n\tstd::string newFdir;\r\n\ttry {\r\n\t\tfile = file.substr(4);\r\n\t\tif (fs::exists(file)) {\r\n\t\t\tstd::cout << \"New directory : \";\r\n\t\t\tstd::getline(std::cin >> std::ws, newFdir);\r\n\r\n\t\t\tif ",
    "#include<iostream>\n#include<string>\nusing namespace std;\n/*\n41. Write a class Array which will store integer elements in dynamically allocated space. \nclass Array\n{\n\tint size;\n\tint *arr;\n}\nProvide below functions in Array class - \n 1. Default constructor - Take 5 as default size. Initialize the array elements to 0\n 2. Parameterized constructor - Takes size as parameter. Initialize the array elements to 0.\n 3. Copy constructor - Performs deep copy of Array object.\n 4. Destructor - Deletes memory which is allocated dynamically.*/\nclass Array{\n\tpublic:\n\t\tint size;\n\t\tint *arr;\n\t\n\t\n\t\tArray():size(5),arr(0){\n\t\t\tcout<<size<<\" \"<<arr<<endl;\t\n\t\t}\n\n\t\tArray(int s){\n\t\t\tthis->size= s;\n\t\t\tarr= new int[this->size];\n\t\t}\n\n\t\tArray(Array &src){\n\t\t\t//copy size;\n\t\t\tthis->size = src.size;\n\t\t\t//create seperate memory\n\t\t\tthis->arr = new int[this->size];\n\t\t\t//copy contents of memory\n\t\t\tfor(int i=0;i<src.size;i++){\n\t\t\t\tthis->arr[i] = src.arr[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid dis(){\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tcout<<\"\\t\"<<arr[i];\n\t\t\t}\n\t\t}\n\n\t\t~Array()\n\t\t{\n\t\t \tdelete []arr;\n\t\t}\n\n};\n\nint main(){\n\tArray a;\n\tArray a1(5);\n\ta1.arr[0] = 1;\n\tArray a2(a1);\n        cout << \"t: \" << a1.size << \" \" << a1.arr[0] << endl;\n        cout << \"t2: \" << a2.size << \" \" << a2.arr[0] << endl;\n\n\n\treturn 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"NFA.h\"\n\nNFA::NFA()\n{\n\treadFile();\n}\n\n\n\nstd::unordered_set<std::string> NFA::getStates() const\n{\n\treturn this->m_states;\n}\n\nstd::unordered_set<std::string> NFA::getAlphabet() const\n{\n\treturn this->m_alphabet;\n}\n\nstd::unordered_map<std::pair<std::string, std::string>, std::string, PairHash, PairEqual> NFA::getTransitions() const\n{\n\treturn this->m_transitions;\n}\n\nstd::string NFA::getInitialState() const\n{\n\treturn this->m_initialState;\n}\n\nstd::vector<std::string> NFA::getFinalState() const\n{\n\treturn this->m_finalStates;\n}\n\n\n\nvoid NFA::readFile()\n{\n\tstd::ifstream file(\"file.txt\");\n\tif (!file.is_open())\n\t{\n\t\tstd::cout << (\"Fisierul nu a putut fii deschis!\");\n\t\treturn;\n\t}\n\tstd::string state1, state2, alph;\n\tint dim;\n\tfile >> dim;\n\n\tfor (int i = 0; i < dim; i++)\n\t{\n\t\tfile >> state1 >> state2 >> alph;\n\t\taddCharacterForAlphabet(alph);\n\t\taddStateForStates(state1);\n\t\taddStateForStates(state2);\n\t\taddTransition(state1, alph, state2);\n\t}\n\tfile >> m_initialState;\n\tfile >> dim;\n\tfor (int i = 0; i < dim; i++)\n\t{\n\t\tfile >> state1;\n\t\tm_finalStates.emplace_back(state1);\n\t}\n\n\tfile.close();\n}\n\nvoid NFA::addStateForStates(const std::string state)\n{\n\tif (m_states.empty())\n\t\tm_states.insert(state);\n\telse if (m_states.find(state) == m_states.end())\n\t{\n\t\tm_states.insert(state);\n\t}\n}\n\nvoid NFA::addCharacterForAlphabet(const std::string alph)\n{\n\tif (m_alphabet.empty())\n\t\tm_alphabet.insert(alph);\n\telse if (m_alphabet.find(alph) == m_alphabet.end())\n\t\tm_alphabet.insert(alph);\n}\n\nvoid NFA::addTransition(const std::string state1, const std::string alph, const std::string state2)\n{\n\tif (m_transitions.find({ state1, state2 }) == m_transitions.end())\n\t\tm_transitions.insert({ {state1,state2},alph });\n\telse\n\t{\n\t\tstd::string alphabet = m_transitions.at({ state1,state2 });\n\t\talphabet += \"+\" + alph;\n\t\tm_transitions.at({ state1,state2 }) = alphabet;\n\t}\n}\n\nvoid NFA::printAutomaton()\n{\n\tstd::cout << \"States: \\n\";\n\tfor (auto it : m_states)\n\t{\n\t\tstd::cout << it << \" \";\n\t}\n\n\tstd::cout << \"\\nInitial state: \" << m_initialState << \"\\n\";\n\n\tstd::cout << \"Final states: \\n\";\n\tfor (int i = 0; i < m_finalStates.size(); i++)\n\t{\n\t\tstd::cout << m_finalStates[i] << \" \";\n\t}\n\n\tstd::cout << \"Alphabet: \\n\";\n\tfor (auto it : m_alphabet)\n\t{\n\t\tstd::cout << it << \" \";\n\t}\n\n\tstd::cout << \"\\nTransitions: \\n\";\n\tfor (auto it : m_transitions)\n\t{\n\t\tstd::cout << \"(\" << it.first.first << \", \" << it.first.second << \")-> \" << it.second << \"\\n\";\n\t}\n\tstd::cout << \"\\n\";\n}\n\nvoid NFA::printTransitions()\n{\n\tstd::cout << \"\\nTransitions: \\n\";\n\tfor (auto it : m_transitions)\n\t{\n\t\tstd::cout << \"(\" << it.first.first << \", \" << it.first.second << \")-> \" << it.second << \"\\n\";\n\t}\n\tstd::cout << \"\\n\";\n}\n\nvoid NFA::addNewInitialState()\n{\n\tstd::string newInitialState = \"I\";\n\tm_states.insert(newInitialState);\n\tm_transitions.insert({ {newInitialState,m_initialState },m_lambda });\n\tm_initialState = newInitialState;\n}\n\nvoid NFA::addNewFinalState()\n{\n\tstd::string newFinalState = \"F\";\n\tm_states.insert(newFinalState);\n\tfor (int i = 0; i < m_finalStates.size(); i++)\n\t{\n\t\tm_transitions.insert({ {m_finalStates[i],newFinalState}, m_lambda});\n\t}\n\tm_finalStates.clear();\n\tm_finalStates.emplace_back(newFinalState);\n}\n\nvoid NFA::updateAutomaton()\n{\n\taddNewInitialState();\n\taddNewFinalState();\n\tstd::cout << \"Noul automat:\\n\";\n\tprintAutomaton();\n}\n\nint NFA::generatedRandomNumber()\n{\n\tint randomNumber = rand() % m_states.size();\n\treturn randomNumber;\n}\n\nstd::string NFA::getRandomState()\n{\n\tint index = generatedRandomNumber();\n\tint i = 0;\n\tfor (std::string state : m_states)\n\t{\n\t\tif (i != index)\n\t\t\ti++;\n\t\telse if (i == index && state != m_initialState && state != m_finalStates[0])\n\t\t\treturn state;\n\t}\n}\n\nstd::vector<std::string> NFA::getStatesEnterInState(std::string& state)\n{\n\tstd::vector<std::string> states;\n\tfor (auto transition : m_transitions)\n\t{\n\t\tif (transition.first.second == state)\n\t\t{\n\t\t\tauto it = std::find(states.begin(), states.end(), transition.first.first);\n\t\t\tif (it == states.end())\n\t\t\t{\n\t\t\t\tif (transition.first.first != state)\n\t\t\t\t\tstates.emplace_back(transition.first.first);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn states;\n}\n\nstd::vector<std::string> NFA::getStatesOutOfState(std::string& state)\n{\n\tstd::vector<std::string> states;\n\tfor (auto transition : m_transitions)\n\t{\n\t\tif (transition.first.first == state)\n\t\t{\n\t\t\tauto it = std::find(states.begin(), states.end(), transition.first.second);\n\t\t\tif (it == states.end())\n\t\t\t{\n\t\t\t\tif (transition.first.second != state)\n\t\t\t\t\tstates.emplace_back(transition.first.second);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn states;\n}\n\nstd::string NFA::getTransitionToStates(std::string& stateIn, std::string& state)\n{\n\tstd::string transitionStates = \"\";\n\tint nrTrasition = 0;\n\tauto it = m_transitions.find({ stateIn,state });\n\tif (it != m_transitions.end() && it->second != m_lambda)\n\t{\n\t\ttransitionStates += it->second;\n\t}\n\n\tif (transitionStates.size() > 1 && (transitionStates.front() != '(' || transitionStates.back() != ')'))\n\t\ttransitionStates = \"(\" + transitionStates + \")\";\n\n\treturn transitionStates;\n}\n\nstd::stri",
    "#include<iostream>\r\n#include<string>\r\n#include\"gettime.h\"\r\nusing namespace std;\r\nclass busdata{\r\n    private:\r\n    int busnumber;\r\n    string ownername;\r\n    string drivername;\r\n    string from;\r\n    string to;\r\n    int Ahour,Amin;int Dhour;int Dmin;\r\n    public:\r\n    busdata(){};\r\n\r\n    busdata( int _busnumber,\r\n    string _ownername,\r\n    string _drivername,\r\n    string _from,\r\n    string _to,\r\n    int _Ahour,int _Amin,int _Dhour,int _Dmin)\r\n    {\r\n        busnumber=_busnumber;\r\n        ownername=_ownername;\r\n        drivername=_drivername;\r\n        from=_from;\r\n        to=_to;\r\n        Ahour=_Ahour;\r\n        Amin=_Amin;\r\n        Dhour=_Dhour;\r\n        Dmin=_Dmin;\r\n    }\r\n\r\n    int getbusnumber(){\r\n        return busnumber;\r\n    };\r\n\r\n    string getownername(){\r\n        return ownername;\r\n    };\r\n    string getdrivername(){\r\n        return drivername;\r\n    };\r\n    string getfrom(){\r\n        return from;\r\n    };\r\n    string getto(){\r\n        return to;\r\n    };\r\n    string getarrival(){\r\n        string arrival= to_string(Ahour)+\":\"+ to_string(Amin);\r\n        return arrival;\r\n    };\r\n\r\n    string getdeparture(){\r\n        string departure= to_string(Dhour) +\":\"+ to_string(Dmin)  ;\r\n        return departure;\r\n    };\r\n\r\n\r\n\r\n\r\n};\r\n\r\nclass bus{\r\n    private:\r\n    static const int MAX=100;\r\n    busdata p[MAX];\r\n    int buscount;\r\n    public:\r\n    bus(){\r\n        buscount=0;\r\n    }\r\n\r\n    //add bus data\r\n    void addbusdetail(busdata newb){\r\n        if(buscount<MAX){\r\n            p[buscount++]=newb;\r\n        }\r\n\r\n    };\r\n\r\n    //show detail\r\n    void showdetail(){\r\n        cout << \"----------*----------*-----------*------*----------*-------------*-------\\n\";\r\n        cout << \"Bus number\\tBus Owner\\tBus driver\\tFrom\\tTo\\tArrival\\t\\tDeparture\\n\";\r\n        for(int i=0;i<buscount;i++){\r\n            cout<<p[i].getbusnumber()<<\"\\t\\t\"<<p[i].getownername()<<\"\\t\"<<p[i].getdrivername()\r\n            << \"\\t\" << p[i].getfrom() << \"\\t\" << p[i].getto() << \"\\t\" << p[i].getarrival()\r\n            << \"\\t\" << p[i].getdeparture() << endl;\r\n        };\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n};\r\n\r\nint main(){\r\n\r\n    bus data;\r\n\r\n    int choice;\r\n    do{\r\n        cout<<\"------------------------------------\\n\";\r\n        cout<<\"         BUS OWNER                  \\n\";\r\n        cout<<\"-------------------------------------\\n\";\r\n        cout<<\"1.Add bus detail             \\n\";\r\n        cout<<\"2.Show detail                \\n\";\r\n        cout<<\"3.Exit                       \\n\";\r\n        cout<<\"Enter your choice\";\r\n        cin>>choice;\r\n        switch (choice)\r\n        {\r\n        case 1:{ int bn;string bo,bd;\r\n                string from;string to;\r\n                int Ahour,Amin;int Dhour;int Dmin;\r\n                cout<<\"\\nEnter your bus number:\";\r\n                cin>>bn;\r\n                cout<<\"\\nEnter bus owner name:\";\r\n                cin.ignore();\r\n                getline(cin,bo);\r\n                cout<<\"\\nEnter bus driver name:\";\r\n                cin>>bd;\r\n                cout<<\"\\nEnter bus destination:---\";\r\n                cout<<\"From:\";\r\n                cin>>from;\r\n                cout<<\"\\tTo:\";\r\n                cin>>to;\r\n                cout<<\"\\nEnter Arrival time:\";\r\n                getTimeFromUser(Ahour,Amin);\r\n                cout<<\"\\nEnter Departure time:\";\r\n                getTimeFromUser(Dhour,Dmin);\r\n\r\n                busdata newp(bn,bo,bd,from,to,Ahour,Amin,Dhour,Dmin);\r\n                data.addbusdetail(newp);\r\n                break;\r\n        }\r\n        case 2:{\r\n            data.showdetail();break;\r\n        }\r\n        default:\r\n            break;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }while(choice != 3);\r\n    return 0;\r\n}",
    "#include<iostream>\n#include \"net.h\"\n#include \"llm.h\"\n#include <math.h>\n#include <stdio.h>\n\nusing namespace std;\n\n\nvoid pretty_print(const ncnn::Mat& m)\n{\n    for (int q=0; q<m.c; q++)\n    {\n        const float* ptr = m.channel(q);\n        for (int z=0; z<m.d; z++)\n        {\n            for (int y=0; y<m.h; y++)\n            {\n                for (int x=0; x<m.w; x++)\n                {\n                    printf(\"%f \", ptr[x]);\n                }\n                ptr += m.w;\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"------------------------\\n\");\n    }\n    printf(\"dims=%d w=%d h=%d d=%d c=%d \\n\",m.dims,m.w,m.h,m.d,m.c);\n}\n//0=1024 1=64793 2=0 3=66348032\n\nncnn::Mat get_embding(ncnn::Mat input){\n    ncnn::Net embding;\n    embding.opt.use_fp16_packed = false;\n    embding.opt.use_fp16_storage = false;\n    embding.opt.use_fp16_arithmetic = false;\n    embding.opt.use_vulkan_compute = false;\n    if (embding.load_param(\"/home/hp/code/llm/ncnn-20240410/model_file/embding.ncnn.param\"))\n        exit(-1);\n    if (embding.load_model(\"/home/hp/code/llm/ncnn-20240410/model_file/embding.ncnn.bin\"))\n        exit(-1);\n    ncnn::Extractor ex = embding.create_extractor();\n\n\n    ex.input(\"in0\", input);\n    //pretty_print(input);\n    ncnn::Mat out;\n    ex.extract(\"out0\", out);\n\n    //pretty_print(out);\n    return out;\n}\n\n\nncnn::Mat forward_llm(ncnn::Mat embding,ncnn::Mat cos_mat,ncnn::Mat sin_mat){\n    int dims = embding.w;\n    int seq_len = embding.h;\n    ncnn::Net llm;\n\n    llm.opt.use_fp16_packed = false;\n    llm.opt.use_fp16_storage = false;\n    llm.opt.use_fp16_arithmetic = false;\n    llm.opt.use_vulkan_compute = false;\n\n    if (llm.load_param(\"/home/hp/code/llm/ncnn-20240410/model_file/all.ncnn.param\"))\n        exit(-1);\n    if (llm.load_model(\"/home/hp/code/llm/ncnn-20240410/model_file/all.ncnn.bin\"))\n        exit(-1);\n    ncnn::Extractor ex = llm.create_extractor();\n    ex.input(\"in0\", embding);\n    ex.input(\"in1\", cos_mat);\n    ex.input(\"in2\", sin_mat);\n\n    ncnn::Mat out;\n    ex.extract(\"out0\", out);\n\n    //\u53d6\u6700\u540e\u4e00\u4e2a\u7ef4\u5ea6\u7684Mat\n    ncnn::Mat reslut(dims,1);\n    for(int i=0;i<dims;i++){\n        float* ptr = (float*)reslut;\n        float* out_ptr = (float*)out;\n        ptr[i]=out_ptr[(seq_len-1)*dims+i]; \n    }\n    return reslut;\n}\n\n//inpiut 1 1024\nncnn::Mat linear(ncnn::Mat input){\n    ncnn::Net linear;\n    linear.opt.use_fp16_packed = false;\n\n    linear.opt.use_fp16_storage = false;\n\n    linear.opt.use_fp16_arithmetic = false;\n    linear.opt.use_vulkan_compute = false;\n    if (linear.load_param(\"/home/hp/code/llm/ncnn-20240410/model_file/line.ncnn.param\"))\n        exit(-1);\n    if (linear.load_model(\"/home/hp/code/llm/ncnn-20240410/model_file/line.ncnn.bin\"))\n        exit(-1);\n    ncnn::Extractor ex = linear.create_extractor();\n\n    ex.input(\"in0\", input);\n    ncnn::Mat out;\n    ex.extract(\"out0\", out);\n\n\n    return out;\n\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <SDL2/SDL.h>\n#include <iostream>\n\nconst int SCREEN_WIDTH = 640;\nconst int SCREEN_HEIGHT = 480;\nconst int PLAYER_SIZE = 20;\nconst int OBJECT_SIZE = 10;\nconst int OBSTACLE_SIZE = 30;\nconst int NUM_OBJECTS = 5;\nconst int NUM_OBSTACLES = 5;\n\nSDL_Window* gWindow = NULL;\nSDL_Renderer* gRenderer = NULL;\n\nSDL_Rect playerRect = { SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, PLAYER_SIZE, PLAYER_SIZE };\nSDL_Rect objects[NUM_OBJECTS];\nSDL_Rect obstacles[NUM_OBSTACLES];\n\nint score = 0;\nint playerSpeed = 5;\n\nvoid initializeSDL() {\n    SDL_Init(SDL_INIT_VIDEO);\n    gWindow = SDL_CreateWindow(\"Simple SDL Game\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED);\n}\n\nvoid closeSDL() {\n    SDL_DestroyRenderer(gRenderer);\n    SDL_DestroyWindow(gWindow);\n    SDL_Quit();\n}\n\nvoid handleInput() {\n    SDL_Event e;\n    while (SDL_PollEvent(&e) != 0) {\n        if (e.type == SDL_QUIT) {\n            closeSDL();\n            exit(0);\n        }\n        else if (e.type == SDL_KEYDOWN) {\n            switch (e.key.keysym.sym) {\n                case SDLK_UP:\n                    if (playerRect.y > 0)\n                        playerRect.y -= playerSpeed;\n                    break;\n                case SDLK_DOWN:\n                    if (playerRect.y < SCREEN_HEIGHT - PLAYER_SIZE)\n                        playerRect.y += playerSpeed;\n                    break;\n                case SDLK_LEFT:\n                    if (playerRect.x > 0)\n                        playerRect.x -= playerSpeed;\n                    break;\n                case SDLK_RIGHT:\n                    if (playerRect.x < SCREEN_WIDTH - PLAYER_SIZE)\n                        playerRect.x += playerSpeed;\n                    break;\n            }\n        }\n    }\n}\n\nvoid generateObjectsAndObstacles() {\n    for (int i = 0; i < NUM_OBJECTS; ++i) {\n        objects[i].x = rand() % (SCREEN_WIDTH - OBJECT_SIZE);\n        objects[i].y = rand() % (SCREEN_HEIGHT - OBJECT_SIZE);\n        objects[i].w = OBJECT_SIZE;\n        objects[i].h = OBJECT_SIZE;\n    }\n\n    for (int i = 0; i < NUM_OBSTACLES; ++i) {\n        obstacles[i].x = rand() % (SCREEN_WIDTH - OBSTACLE_SIZE);\n        obstacles[i].y = rand() % (SCREEN_HEIGHT - OBSTACLE_SIZE);\n        obstacles[i].w = OBSTACLE_SIZE;\n        obstacles[i].h = OBSTACLE_SIZE;\n    }\n}\n\nbool checkCollision(SDL_Rect rect1, SDL_Rect rect2) {\n    return (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x && rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y);\n}\n\nvoid render() {\n    SDL_SetRenderDrawColor(gRenderer, 255, 255, 255, 255);\n    SDL_RenderClear(gRenderer);\n\n    // Render player\n    SDL_SetRenderDrawColor(gRenderer, 255, 0, 0, 255);\n    SDL_RenderFillRect(gRenderer, &playerRect);\n\n    // Render objects\n    SDL_SetRenderDrawColor(gRenderer, 0, 255, 0, 255);\n    for (int i = 0; i < NUM_OBJECTS; ++i) {\n        SDL_RenderFillRect(gRenderer, &objects[i]);\n    }\n\n    // Render obstacles\n    SDL_SetRenderDrawColor(gRenderer, 0, 0, 255, 255);\n    for (int i = 0; i < NUM_OBSTACLES; ++i) {\n        SDL_RenderFillRect(gRenderer, &obstacles[i]);\n    }\n\n    SDL_RenderPresent(gRenderer);\n}\n\nint main(int argc, char* args[]) {\n    initializeSDL();\n    generateObjectsAndObstacles();\n\n    bool quit = false;\n    while (!quit) {\n        handleInput();\n\n        // Collision detection\n        for (int i = 0; i < NUM_OBJECTS; ++i) {\n            if (checkCollision(playerRect, objects[i])) {\n                std::cout << \"Object collected!\\n\";\n                objects[i].x = rand() % (SCREEN_WIDTH - OBJECT_SIZE);\n                objects[i].y = rand() % (SCREEN_HEIGHT - OBJECT_SIZE);\n                score++;\n                playerSpeed += 1; // Increase speed\n                std::cout << '\\a';\n            }\n        }\n\n        for (int i = 0; i < NUM_OBSTACLES; ++i) {\n            if (checkCollision(playerRect, obstacles[i])) {\n                std::cout << \"Game Over!\\n\";\n                quit = true;\n            }\n        }\n\n        render();\n    }\n\n    closeSDL();\n    return 0;\n}\n",
    "//========= Copyright \u00a9 1996-2005, Valve Corporation, All rights reserved. ============//\n//\n// Purpose: Defines a symbol table\n//\n// $Header: $\n// $NoKeywords: $\n//=============================================================================//\n\n#pragma warning (disable:4514)\n\n#include \"utlsymbol.h\"\n#include \"tier0/memdbgon.h\"\n\n#define INVALID_STRING_INDEX CStringPoolIndex( 0xFFFF, 0xFFFF )\n\n#define MIN_STRING_POOL_SIZE\t2048\n\n//-----------------------------------------------------------------------------\n// globals\n//-----------------------------------------------------------------------------\n\nCUtlSymbolTable* CUtlSymbol::s_pSymbolTable = 0; \nbool CUtlSymbol::s_bAllowStaticSymbolTable = true;\n\n\n//-----------------------------------------------------------------------------\n// symbol methods\n//-----------------------------------------------------------------------------\n\nvoid CUtlSymbol::Initialize()\n{\n\t// If this assert fails, then the module that this call is in has chosen to disallow\n\t// use of the static symbol table. Usually, it's to prevent confusion because it's easy\n\t// to accidentally use the global symbol table when you really want to use a specific one.\n\tAssert( s_bAllowStaticSymbolTable );\n\n\t// necessary to allow us to create global symbols\n\tstatic bool symbolsInitialized = false;\n\tif (!symbolsInitialized)\n\t{\n\t\ts_pSymbolTable = new CUtlSymbolTable;\n\t\tsymbolsInitialized = true;\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Purpose: Singleton to delete table on exit from module\n//-----------------------------------------------------------------------------\nclass CCleanupUtlSymbolTable\n{\npublic:\n\t~CCleanupUtlSymbolTable()\n\t{\n\t\tdelete CUtlSymbol::s_pSymbolTable;\n\t\tCUtlSymbol::s_pSymbolTable = NULL;\n\t}\n};\n\nstatic CCleanupUtlSymbolTable g_CleanupSymbolTable;\n\nCUtlSymbolTable* CUtlSymbol::CurrTable()\n{\n\tInitialize();\n\treturn s_pSymbolTable; \n}\n\n\n//-----------------------------------------------------------------------------\n// string->symbol->string\n//-----------------------------------------------------------------------------\n\nCUtlSymbol::CUtlSymbol( char const* pStr )\n{\n\tm_Id = CurrTable()->AddString( pStr );\n}\n\nchar const* CUtlSymbol::String( ) const\n{\n\treturn CurrTable()->String(m_Id);\n}\n\nvoid CUtlSymbol::DisableStaticSymbolTable()\n{\n\ts_bAllowStaticSymbolTable = false;\n}\n\n//-----------------------------------------------------------------------------\n// checks if the symbol matches a string\n//-----------------------------------------------------------------------------\n\nbool CUtlSymbol::operator==( char const* pStr ) const\n{\n\tif (m_Id == UTL_INVAL_SYMBOL) \n\t\treturn false;\n\treturn strcmp( String(), pStr ) == 0;\n}\n\n\n\n//-----------------------------------------------------------------------------\n// symbol table stuff\n//-----------------------------------------------------------------------------\n\nstruct LessCtx_t\n{\n\tchar const* m_pUserString;\n\tCUtlSymbolTable* m_pTable;\n\t\n\tLessCtx_t( ) : m_pUserString(0), m_pTable(0) {}\n};\n\nstatic LessCtx_t g_LessCtx;\n\n\ninline const char* CUtlSymbolTable::StringFromIndex( const CStringPoolIndex &index ) const\n{\n\tAssert( index.m_iPool < m_StringPools.Count() );\n\tAssert( index.m_iOffset < m_StringPools[index.m_iPool]->m_TotalLen );\n\n\treturn &m_StringPools[index.m_iPool]->m_Data[index.m_iOffset];\n}\n\n\nbool CUtlSymbolTable::SymLess( CStringPoolIndex const& i1, CStringPoolIndex const& i2 )\n{\n\tchar const* str1 = (i1 == INVALID_STRING_INDEX) ? g_LessCtx.m_pUserString :\n\t\t\t\t\t\t\t\t\t\t\tg_LessCtx.m_pTable->StringFromIndex( i1 );\n\tchar const* str2 = (i2 == INVALID_STRING_INDEX) ? g_LessCtx.m_pUserString :\n\t\t\t\t\t\t\t\t\t\t\tg_LessCtx.m_pTable->StringFromIndex( i2 );\n\t\n\treturn strcmp( str1, str2 ) < 0;\n}\n\n\nbool CUtlSymbolTable::SymLessi( CStringPoolIndex const& i1, CStringPoolIndex const& i2 )\n{\n\tchar const* str1 = (i1 == INVALID_STRING_INDEX) ? g_LessCtx.m_pUserString :\n\t\t\t\t\t\t\t\t\t\t\tg_LessCtx.m_pTable->StringFromIndex( i1 );\n\tchar const* str2 = (i2 == INVALID_STRING_INDEX) ? g_LessCtx.m_pUserString :\n\t\t\t\t\t\t\t\t\t\t\tg_LessCtx.m_pTable->StringFromIndex( i2 );\n\t\n\treturn strcmpi( str1, str2 ) < 0;\n}\n\n//-----------------------------------------------------------------------------\n// constructor, destructor\n//-----------------------------------------------------------------------------\n\nCUtlSymbolTable::CUtlSymbolTable( int growSize, int initSize, bool caseInsensitive ) : \n\tm_Lookup( growSize, initSize, caseInsensitive ? SymLessi : SymLess ), m_StringPools( 8 )\n{\n}\n\nCUtlSymbolTable::~CUtlSymbolTable()\n{\n\t// Release the stringpool string data\n\tRemoveAll();\n}\n\n\nCUtlSymbol CUtlSymbolTable::Find( char const* pString )\n{\t\n\tif (!pString)\n\t\treturn CUtlSymbol();\n\t\n\t// Store a special context used to help with insertion\n\tg_LessCtx.m_pUserString = pString;\n\tg_LessCtx.m_pTable = this;\n\t\n\t// Passing this special invalid symbol makes the comparison function\n\t// use the string passed in the context\n\tUtlSymId_t idx = m_Lookup.Find( INVALID_STRING_INDEX );\n\treturn CUtlSymbol",
    "#include <iostream>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\nstruct Produto {\n    string nome;\n    int quantidade;\n    string validade;\n    string fornecedor;\n    float custo;\n    float precoVenda;\n};\n\nmap<string, Produto> estoque; // Mapa para armazenar os produtos\n\nvoid adicionarProduto() {\n    Produto produto;\n\n    cout << \"Digite o nome do produto: \";\n    cin >> produto.nome;\n\n    cout << \"Digite a quantidade do produto: \";\n    cin >> produto.quantidade;\n\n    cout << \"Digite a data de validade do produto (dd/mm/aaaa): \";\n    cin >> produto.validade;\n\n    cout << \"Digite o nome do fornecedor do produto: \";\n    cin >> produto.fornecedor;\n\n    cout << \"Digite o custo do produto: \";\n    cin >> produto.custo;\n\n    // Calcula o pre\u00e7o de venda como o dobro do custo\n    produto.precoVenda = produto.custo * 2;\n\n    estoque[produto.nome] = produto;\n\n    cout << \"Produto adicionado com sucesso!\" << endl;\n}\n\nvoid removerProduto() {\n    string nome;\n\n    cout << \"Digite o nome do produto a ser removido: \";\n    cin >> nome;\n\n    if (estoque.find(nome) != estoque.end()) {\n        estoque.erase(nome);\n        cout << \"Produto removido com sucesso!\" << endl;\n    } else {\n        cout << \"Produto nao encontrado.\" << endl;\n    }\n}\n\nvoid editarProduto() {\n    string nome;\n\n    cout << \"Digite o nome do produto a ser editado: \";\n    cin >> nome;\n\n    if (estoque.find(nome) != estoque.end()) {\n        Produto& produto = estoque[nome];\n\n        cout << \"Digite a nova quantidade do produto: \";\n        cin >> produto.quantidade;\n\n        cout << \"Digite a nova data de validade do produto (dd/mm/aaaa): \";\n        cin >> produto.validade;\n\n        cout << \"Digite o novo nome do fornecedor do produto: \";\n        cin >> produto.fornecedor;\n\n        cout << \"Produto editado com sucesso!\" << endl;\n    } else {\n        cout << \"Produto nao encontrado.\" << endl;\n    }\n}\n\nvoid exibirEstoque() {\n    cout << \"Estoque atual:\" << endl;\n    for (map<string, Produto>::iterator it = estoque.begin(); it != estoque.end(); ++it) {\n        cout << \"Nome: \" << it->second.nome << endl;\n        cout << \"Quantidade: \" << it->second.quantidade << endl;\n        cout << \"Data de Validade: \" << it->second.validade << endl;\n        cout << \"Fornecedor: \" << it->second.fornecedor << endl;\n        cout << \"Custo: R$ \" << it->second.custo << endl;\n        cout << \"Preco de Venda: R$ \" << it->second.precoVenda << endl;\n        cout << \"--------------------------\" << endl;\n    }\n}\n\nvoid gerarRelatorioTXT() {\n    ofstream relatorio(\"relatorio.txt\");\n    if (!relatorio.is_open()) {\n        cout << \"Erro ao criar arquivo de relatorio\" << endl;\n        return;\n    }\n\n    relatorio << \"Relatorio de Estoque\" << endl;\n    for (map<string, Produto>::iterator it = estoque.begin(); it != estoque.end(); ++it) {\n        relatorio << \"Nome: \" << it->second.nome << endl;\n        relatorio << \"Quantidade: \" << it->second.quantidade << endl;\n        relatorio << \"Data de Validade: \" << it->second.validade << endl;\n        relatorio << \"Fornecedor: \" << it->second.fornecedor << endl;\n        relatorio << \"Custo: R$ \" << it->second.custo << endl;\n        relatorio << \"Preco de Venda: R$ \" << it->second.precoVenda << endl;\n        relatorio << \"--------------------------\" << endl;\n    }\n\n    relatorio.close();\n\n    cout << \"Relatorio gerado com sucesso (relatorio.txt)\" << endl;\n}\n\nint main() {\n    int escolha;\n\n    do {\n        cout << \"======================================\" << endl;\n        cout <<\"Sistema de Gerenciamento de Estoque  v1.0\"<<endl;\n        cout << \"Escolha uma opcao:\" << endl;\n        cout << \"1. Adicionar Produto\" << endl;\n        cout << \"2. Remover Produto\" << endl;\n        cout << \"3. Editar Produto\" << endl;\n        cout << \"4. Exibir Estoque\" << endl;\n        cout << \"5. Gerar Relatorio em TXT\" << endl;\n        cout << \"6. Sair\" << endl;\n        cout << \"Escolha uma opcao: \";\n        cin >> escolha;\n\n        switch (escolha) {\n            case 1:\n                adicionarProduto();\n                break;\n            case 2:\n                removerProduto();\n                break;\n            case 3:\n                editarProduto();\n                break;\n            case 4:\n                exibirEstoque();\n                break;\n            case 5:\n                gerarRelatorioTXT();\n                break;\n            case 6:\n                cout << \"Saindo do programa...\" << endl;\n                break;\n            default:\n                cout << \"Opcao invalida. Tente novamente.\" << endl;\n                break;\n        }\n    } while (escolha != 6);\n\n    return 0;\n}\n",
    "class Solution {\npublic:\n    string tictactoe(vector<vector<int>>& moves) {\n        vector<vector<int>> board(3, vector<int>(3,0));\n        char turn = 'A';\n        int n = moves.size();\n        for (int i = 0; i < n; i++) {\n            if (turn == 'A') {\n                board[moves[i][0]][moves[i][1]] = 1;\n                turn = 'B';\n            } else {\n                board[moves[i][0]][moves[i][1]] = 2;\n                turn = 'A';\n            }\n        }\n        for (int i = 0; i < 3; i++) {\n            int cntA = 0, cntB = 0;\n            for (int j = 0; j < 3; j++) {\n                if (board[i][j] == 1) {\n                    cntA++;\n                } else if (board[i][j] == 2) {\n                    cntB++;\n                }\n            }\n            if (cntA == 3)\n                return \"A\";\n            else if (cntB == 3)\n                return \"B\";\n        }\n        for (int i = 0; i < 3; i++) {\n            int cntA = 0, cntB = 0;\n            for (int j = 0; j < 3; j++) {\n                if (board[j][i] == 1) {\n                    cntA++;\n                } else if (board[j][i] == 2) {\n                    cntB++;\n                }\n            }\n            if (cntA == 3)\n                return \"A\";\n            else if (cntB == 3)\n                return \"B\";\n        }\n        if ((board[0][0] == 1 && board[1][1] == 1 && board[2][2] == 1) ||\n            (board[0][2] == 1 && board[1][1] == 1 && board[2][0] == 1)) {\n            return \"A\";\n        } else if ((board[0][0] == 2 && board[1][1] == 2 && board[2][2] == 2) ||\n                   (board[0][2] == 2 && board[1][1] == 2 && board[2][0] == 2)) {\n            return \"B\";\n        } else if (moves.size() != 9) {\n            return \"Pending\";\n        }\n        return \"Draw\";\n    }\n};",
    "// Author: Frank Mayet\n// Creation Date: 11.03.2024\n\n#include <iostream>\n#include <eq_client.h>\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <pybind11/numpy.h>\n\nnamespace py = pybind11;\n\npy::dict read(std::string address) {\n    py::gil_scoped_release release;\n\n    EqCall eq;      // Equipment function call object\n    EqAdr  ea;      // Equipment address object\n    EqData src;     // Equipment data object to be sent to server\n    EqData dst;     // Equipment data object returned data is stored to\n\n    // Set the address of a DOOCS channel\n    ea.adr(address);\n\n    // Make the call\n    int return_code = eq.get(&ea, &src, &dst);\n    result[\"address\"] = address;\n    result[\"timestamp\"]  = std::to_string(dst.time());\n    result[\"macropulse\"] = dst.get_event_id().to_int();\n    \n    if (return_code) {\n      result[\"data\"] = \"\";\n      result[\"macropulse\"] = -1;\n      result[\"error_code\"] = std::to_string(dst.error());\n    }\n\n    switch (dst.type()) {\n    case DATA_STRING:\n      result[\"data\"] = dst.get_string();\n      result[\"type\"] = \"STRING\";\n      break;\n    case DATA_INT:\n      result[\"data\"] = dst.get_int();\n      result[\"data\"] = \"INT\"\n      break;\n    case DATA_FLOAT:\n      result[\"data\"] = dst.get_float();\n      result[\"type\"] = \"FLOAT\";\n      break;\n    case DATA_IMAGE:\n      parse_image(dst, result);\n      break;\n    }\n\n    py::gil_scoped_acquire acquire;\n    return result;\n}\n\ntemplate <typename T> void write(std::string address, T value) {\n  gil_scoped_release release;\n  EqCall eq;      // Equipment function call object\n  EqAdr  ea;      // Equipment address object\n  EqData data_in;     // Equipment data object to be sent to server\n  EqData data_out;     // Equipment data object returned data is stored to\n\n  // Set the address of a DOOCS channel\n  ea.adr(address);\n\n  data_in.set(value);\n\n  // Set the value to be sent to the server\n  src.set_int(value);\n\n  // Make the call\n  eq.set(&ea, &src, &dst);\n  py::gil_scoped_acquire acquire;\n}\n  \n\nvoid parse_image(EqData const &dst, py::dict rdict) {\n      assert(dst.type() == DATA_IMAGE);s\n\n  IMH header;\n  dst.get_image_header(&header);\n\n  size_t size = header.aoi_width * header.aoi_height * header.bpp;\n  uint8_t *buffer = new uint8_t[size];\n\n  int size_dummy = 0;\n  dst.get_image(&buffer, &size_dummy, &header);\n\n  switch (header.bpp) {\n  case 1:\n    py::array_t<uint8_t> image({header.aoi_height, header.aoi_width},\n\t\t\t       {header.aoi_width*header.bpp, header.bpp},\n\t\t\t       buffer\n\t\t\t       );\n    rdict[\"data\"] = image;\n    break;\n  case 2:\n    py::array_t<uint16_t> image({header.aoi_height, header.aoi_width},\n\t\t\t\t{header.aoi_width*header.bpp, header.bpp},\n\t\t\t\t(uint16_t*)buffer\n\t\t\t\t);\n    rdict[\"data\"] = image;\n    break;\n  case 4:\n    py::array_t<uint32_t> image({header.aoi_height, header.aoi_width},\n\t\t\t\t{header.aoi_width*header.bpp, header.bpp},\n\t\t\t\t(uint32_t*)buffer\n\t\t\t\t);\n    rdict[\"data\"] = image;\n    break;\n  default:\n    rdict[\"data\"] = \"UNSUPPORTED IMAGE FORMAT\";\n  }\n}\n\n\n\nPYBIND11_MODULE(lldoocs, m) {\n    m.doc() = R\"pbdoc(\n        LockLess DOOCS \n        -----------------------\n\n        .. currentmodule:: lldoocs\n\n        .. autosummary::\n           :toctree: _generate\n\n           read\n           write\n    )pbdoc\";\n\n    m.def(\"read\", &read, \"Get image data from a DOOCS server\");\n    m.def(\"write\", [](const std::string &s, const int &i) {\n      return write(s, i);\n    });\n    m.def(\"write\", [](const std::string &s, const float &i) {\n      return write(s, i);\n    });\n\n#ifdef VERSION_INFO\n      m.attr(\"__version__\") = MACRO_STRINGIFY(VERSION_INFO);\n#else\n    m.attr(\"__version__\") = \"dev\";\n#endif\n}\n",
    "#include \"VertexBuffer.hpp\"\n\n#include \"KeyEngineCore\\Log.hpp\"\n\n#include <glad/glad.h>\n\nnamespace KeyEngine {\n\n    constexpr unsigned int shader_data_type_to_components_count(const ShaderDataType type)\n    {\n        switch (type)\n        {\n        case ShaderDataType::Float:\n        case ShaderDataType::Int:\n            return 1;\n\n        case ShaderDataType::Float2:\n        case ShaderDataType::Int2:\n            return 2;\n\n        case ShaderDataType::Float3:\n        case ShaderDataType::Int3:\n            return 3;\n\n        case ShaderDataType::Float4:\n        case ShaderDataType::Int4:\n            return 4;\n        }\n\n        LOG_ERROR(\"shader_data_type_to_components_count: unknown ShaderDataType!\");\n        \n        return 0;\n    }\n\n    constexpr size_t shader_data_type_size(const ShaderDataType type)\n    {\n        switch (type)\n        {\n        case ShaderDataType::Float:\n        case ShaderDataType::Float2:\n        case ShaderDataType::Float3:\n        case ShaderDataType::Float4:\n            return sizeof(GLfloat) * shader_data_type_to_components_count(type);\n\n        case ShaderDataType::Int:\n        case ShaderDataType::Int2:\n        case ShaderDataType::Int3:\n        case ShaderDataType::Int4:\n            return sizeof(GLint) * shader_data_type_to_components_count(type);\n        }\n\n        LOG_ERROR(\"shader_data_type_size: unknown ShaderDataType!\");\n\n        return 0;\n    }\n\n    constexpr unsigned int shader_data_type_to_component_type(const ShaderDataType type)\n    {\n        switch (type)\n        {\n        case ShaderDataType::Float:\n        case ShaderDataType::Float2:\n        case ShaderDataType::Float3:\n        case ShaderDataType::Float4:\n            return GL_FLOAT;\n\n        case ShaderDataType::Int:\n        case ShaderDataType::Int2:\n        case ShaderDataType::Int3:\n        case ShaderDataType::Int4:\n            return GL_INT;\n        }\n\n        LOG_ERROR(\"shader_data_type_to_component_type: unknown ShaderDataType!\");\n\n        return GL_FLOAT;\n    }\n\n    constexpr GLenum usage_to_GLenum(const VertexBuffer::EUsage usage)\n    {\n        switch (usage)\n        {\n        case VertexBuffer::EUsage::Static:  return GL_STATIC_DRAW;\n        case VertexBuffer::EUsage::Dynamic: return GL_DYNAMIC_DRAW;\n        case VertexBuffer::EUsage::Stream:  return GL_STREAM_DRAW;\n        }\n\n        LOG_ERROR(\"Unknown VertexBuffer usage\");\n\n        return GL_STREAM_DRAW;\n    }\n\n    BufferElement::BufferElement(const ShaderDataType _type)\n        : type(_type)\n        , component_type(shader_data_type_to_component_type(_type))\n        , components_count(shader_data_type_to_components_count(_type))\n        , size(shader_data_type_size(_type))\n        , offset(0)\n    {\n    }\n\n    VertexBuffer::VertexBuffer(const void* data, const size_t size, BufferLayout buffer_layout, const EUsage usage)\n        : m_buffer_layout(std::move(buffer_layout))\n    {\n        glGenBuffers(1, &m_id);\n        glBindBuffer(GL_ARRAY_BUFFER, m_id);\n        glBufferData(GL_ARRAY_BUFFER, size, data, usage_to_GLenum(usage));\n    }\n\n    VertexBuffer::~VertexBuffer() { glDeleteBuffers(1, &m_id); }\n\n    VertexBuffer& VertexBuffer::operator=(VertexBuffer&& vertexBuffer) noexcept\n    {\n        m_id = vertexBuffer.m_id;\n        vertexBuffer.m_id = 0;\n        return *this;\n    }\n\n    VertexBuffer::VertexBuffer(VertexBuffer&& vertexBuffer) noexcept\n        : m_id(vertexBuffer.m_id)\n        , m_buffer_layout(std::move(vertexBuffer.m_buffer_layout))\n    {\n        vertexBuffer.m_id = 0;\n    }\n\n    void VertexBuffer::bind() const { glBindBuffer(GL_ARRAY_BUFFER, m_id); }\n\n    void VertexBuffer::unbuid() { glBindBuffer(GL_ARRAY_BUFFER, 0); }\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Frequency.h\"\n#include <vector>\n\n//Frequency::Frequency()\n//{\n//}\n\nvoid Frequency::Initialize()\n\t{\n\t\tpaError = Pa_Initialize();\n\n\t\tif (paError != paNoError)\n\t\t{\n\t\t\tprintf(\"PA ERROR: %s\\n\", Pa_GetErrorText(paError));\n\t\t}\n\n\t\t/* OPEN STREAM */\n\n\t\tconst PaDeviceInfo* deviceInfo = Pa_GetDeviceInfo(deviceIndex);\n\t\tdeviceName = deviceInfo->name;\n\n\t\tPaStreamParameters inputParameters{};\n\t\tinputParameters.device = deviceIndex;\n\t\tinputParameters.channelCount = deviceInfo->maxInputChannels;\n\t\tinputParameters.hostApiSpecificStreamInfo = NULL;\n\t\tinputParameters.sampleFormat = paFloat32;\n\t\tinputParameters.suggestedLatency = deviceInfo->defaultLowInputLatency;\n\n\t\tunsigned long nyquistFreq = static_cast<unsigned long>(deviceInfo->defaultSampleRate / 2);\n\n\n\t\tpaError = Pa_OpenStream(&stream,\n\t\t\t&inputParameters,\n\t\t\tNULL,\n\t\t\tdeviceInfo->defaultSampleRate,\n\t\t\tnyquistFreq,\n\t\t\tpaNoFlag,\n\t\t\tstreamCallback,\n\t\t\tthis);\n\n\t\tif (paError)\n\t\t{\n\t\t\tprintf(\"PA ERROR: %s\\n\", Pa_GetErrorText(paError));\n\t\t}\n\n\t\tpaError = Pa_StartStream(stream);\n\n\t\tif (paError)\n\t\t{\n\t\t\tprintf(\"PA ERROR: %s\\n\", Pa_GetErrorText(paError));\n\t\t}\n\t}\n\nvoid Frequency::Terminate()\n{\n\tpaError = Pa_StopStream(stream);\n\n\tif (paError)\n\t{\n\t\tprintf(\"PA ERROR: %s\\n\", Pa_GetErrorText(paError));\n\t}\n\n\tpaError = Pa_CloseStream(stream);\n\n\tif (paError)\n\t{\n\t\tprintf(\"PA ERROR: %s\\n\", Pa_GetErrorText(paError));\n\t}\n}\n\nint Frequency::streamCallback(const void* input, void* output,\n\tunsigned long frameCount,\n\tconst PaStreamCallbackTimeInfo * timeInfo,\n\tPaStreamCallbackFlags statusFlags,\n\tvoid* userData)\n{\n\tFrequency* frequency = static_cast<Frequency*>(userData);\n\tPaDeviceIndex deviceIndex = frequency->deviceIndex;\n\n\tfloat* inputStream = (float*)input;\n\tint inputChannels = Pa_GetDeviceInfo(deviceIndex)->maxInputChannels;\n\tdouble sampleRate = Pa_GetDeviceInfo(deviceIndex)->defaultSampleRate;\n\tunsigned long bufferSize = frameCount * inputChannels;\n\tint fftSize = static_cast<int>(sampleRate / 2);\n\n\tstd::vector<float> left(fftSize);\n\tstd::vector<float> right(fftSize);\n\tint leftIndex = 0;\n\tint rightIndex = 0;\n\n\tfor (int index = 0; index < static_cast<int>(bufferSize); index++) {\n\t\tif (index % 2 == 0) {\n\t\t\tif (leftIndex < fftSize) {\n\t\t\t\tleft[leftIndex] = inputStream[index];\n\t\t\t\tleftIndex++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle buffer overflow\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (rightIndex < fftSize) {\n\t\t\t\tright[rightIndex] = inputStream[index];\n\t\t\t\trightIndex++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Handle buffer overflow\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int index = frameCount; index < fftSize; index++)\n\t{\n\t\tleft[index] = 0.0;\n\t\tright[index] = 0.0;\n\t}\n\n\tkiss_fft_cpx* sampleStreamInput = new kiss_fft_cpx[fftSize];\n\tkiss_fft_cpx* sampleStreamOutput = new kiss_fft_cpx[fftSize];\n\n\tfor (int index = 0; index < fftSize; index++)\n\t{\n\t\tsampleStreamInput[index].r = left[index];\n\t\tsampleStreamInput[index].i = 0;\n\t}\n\n\tkiss_fft_cfg configuration = kiss_fft_alloc(fftSize, 0, NULL, NULL);\n\tkiss_fft(configuration, sampleStreamInput, sampleStreamOutput);\n\n\tdouble peakMagnitude = 0.0;\n\tint peakIndex = 0;\n\n\tfor (int index = 0; index < fftSize / 2; index++)\n\t{\n\t\tdouble outputFrequencyMagnitude = sampleStreamOutput[index].r;\n\n\t\tif (outputFrequencyMagnitude > peakMagnitude)\n\t\t{\n\t\t\tpeakMagnitude = outputFrequencyMagnitude;\n\t\t\tpeakIndex = index;\n\t\t}\n\t}\n\n\tdouble frequencyBin = static_cast<double>(peakIndex) * (static_cast<double>(bufferSize) / static_cast<double>(fftSize));\n\n\tsystem(\"cls\");\n\tprintf(\"PEAK INDEX CHANNEL: %d\\n\", peakIndex);\n\tprintf(\"PEAK MAGNE CHANNEL: %f\\n\", peakMagnitude);\n\tprintf(\"FREQUENCY         : %f\\n\", frequencyBin);\n\n\tfrequency->callbackExecutionCounter++;\n\n\t/*delete[] left;\n\tdelete[] right;*/\n\tdelete[] sampleStreamInput;\n\tdelete[] sampleStreamOutput;\n\n\treturn paContinue;\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# endif\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n  /* __HP_aCC = VVRRPP */\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n  /* __DECCXX_VER = VVRRTPPPP */\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\n\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\n# define COMPILER_ID \"zOS\"\n# if defined(__ibmxl__)\n#  define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n#  define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n#  define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n#  define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n# else\n   /* __IBMCPP__ = VRP */\n#  define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n#  define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n#  define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n# endif\n\n\n#elif defined(__ibmxl__) || (defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800)\n# define COMPILER_ID \"XL\"\n# if defined(__ibmxl__)\n#  define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\n#  define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\n#  define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\n#  define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\n# else\n   /* __IBMCPP__ = VRP */\n#  define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\n#  define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\n#  define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\n# endif\n\n\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && _",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lore\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"slumbernaut\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"ParticleSystem.h\"\n#include <SFML/Graphics/CircleShape.hpp>\n\n// TODO To another file\n#include \"Emitters/SphereEmitter.h\"\n#include \"Emitters/ConeEmitter.h\"\n#include \"Emitters/PlaneEmitter.h\"\n\nParticleSystem::ParticleSystem(unsigned int maxParticles) :\n    m_maxParticles(maxParticles),\n    m_startColor(sf::Color::White),\n    m_endColor(sf::Color::White),\n    m_force(sf::Vector2f(0.0f, 0.0f)),\n    m_particleMass(1.0f),\n    m_emitterPosition(0.0f, 0.0f),\n    m_emissionRate(0.0f),\n    m_emitterRadius(0.0f),\n    m_particleLifetime(1.0f),\n    m_particleSize(1.0f),\n    m_particleSpeed(0.0f),\n    m_particleRotationSpeed(0.0f),\n    m_isDrawTrail(false),\n    m_trailSize(0)\n{\n    // Default sphere emitter\n    m_emitter = std::make_shared<SphereEmitter>(SphereEmitter());\n}\n\nvoid ParticleSystem::update(float dt)\n{\n    float particlesToCreate = m_emissionRate * dt;\n\n    for (int i = 0; i < particlesToCreate; ++i)\n    {\n        if (m_particles.size() < m_maxParticles)\n        {\n            if (m_emitter)\n            {\n                const sf::Vector2f position = m_emitter->calculatePosition();\n                const sf::Vector2f velocity = m_emitter->calculateVelocity();\n                const float angle = m_emitter->calculateAngle();\n\n                ParticleSettings settings{ m_particleLifetime, m_particleSize, m_particleSpeed, angle, m_particleRotationSpeed, m_force, m_particleMass, m_startColor, m_endColor, m_isDrawTrail, m_trailSize, m_particleSizeCurve, m_rgbCurve, m_alphaCurve, m_forceCurve };\n                m_particles.push_back({ position.x, position.y, settings });\n                m_particles.back().setVelocity(velocity * m_particleSpeed);\n            }\n        }\n    }\n\n    for (auto&& particle : m_particles)\n        particle.update(dt);\n\n    m_particles.erase(std::remove_if(m_particles.begin(), m_particles.end(),\n        [](const Particle& p) { return !p.isAlive(); }),\n        m_particles.end());\n}\n\nvoid ParticleSystem::draw(sf::RenderWindow& window) const\n{\n    for (const auto& particle : m_particles)\n    {\n        if (particle.isDrawTail() && particle.trailSize() > 1) {\n            for (int i = 1; i < particle.trailSize(); ++i) {\n                sf::Vertex line[] = {\n                    sf::Vertex(particle.trailIndex(i - 1), particle.color()),\n                    sf::Vertex(particle.trailIndex(i), particle.color())\n                };\n                window.draw(line, 2, sf::Lines);\n            }\n        }\n\n        sf::CircleShape shape(particle.size());\n        shape.setFillColor(particle.color());\n        shape.setPosition(particle.position());\n        window.draw(shape);\n    }\n}\n",
    "/**\n* @file  uthread.cpp\n* @author chenxueyou\n* @version 0.1\n* @brief   :A asymmetric coroutine library for C++\n* History\n*      1. Date: 2014-12-12 \n*          Author: chenxueyou\n*          Modification: this file was created \n*/\n\n#ifndef MY_UTHREAD_CPP\n#define MY_UTHREAD_CPP\n\n\n#include \"uthread.h\"\n//#include <stdio.h>\n\nvoid uthread_resume(schedule_t &schedule , int id)\n{\n    if(id < 0 || id >= schedule.max_index){\n        return;\n    }\n\n    uthread_t *t = &(schedule.threads[id]);\n\n    if (t->state == SUSPEND) {\n        swapcontext(&(schedule.main),&(t->ctx));\n    }\n}\n\nvoid uthread_yield(schedule_t &schedule)\n{\n    if(schedule.running_thread != -1 ){\n        uthread_t *t = &(schedule.threads[schedule.running_thread]);\n        t->state = SUSPEND;\n        schedule.running_thread = -1;\n\n        swapcontext(&(t->ctx),&(schedule.main));\n    }\n}\n\n// \nvoid uthread_body(schedule_t *ps)\n{\n    int id = ps->running_thread;\n\n    if(id != -1){\n        uthread_t *t = &(ps->threads[id]);\n\n        t->func(t->arg);\n\n        t->state = FREE;\n        \n        ps->running_thread = -1;\n    }\n}\n\n// \nint uthread_create(schedule_t &schedule,Fun func,void *arg)\n{\n    int id = 0;\n    \n    for(id = 0; id < schedule.max_index; ++id ){\n        if(schedule.threads[id].state == FREE){\n            break;\n        }\n    }\n    \n    if (id == schedule.max_index) {\n        schedule.max_index++;\n    }\n\n    uthread_t *t = &(schedule.threads[id]);\n\n    t->state = RUNNABLE;\n    t->func = func;\n    t->arg = arg;\n\n    // \u83b7\u53d6\u5f53\u524d\u4e0a\u4e0b\u6587\n    getcontext(&(t->ctx));\n    \n    t->ctx.uc_stack.ss_sp = t->stack;\n    t->ctx.uc_stack.ss_size = DEFAULT_STACK_SZIE;\n    t->ctx.uc_stack.ss_flags = 0;\n    // \u8bbe\u7f6e\u540e\u7ee7\u4e0a\u4e0b\u6587\uff0c\u7edf\u4e00\u4e3amain\n    t->ctx.uc_link = &(schedule.main);\n    schedule.running_thread = id;\n    \n    // \u4fee\u6539\u4e0a\u4e0b\u6587\u6307\u5411uthread_body\u51fd\u6570\n    makecontext(&(t->ctx),(void (*)(void))(uthread_body),1,&schedule);\n\n    // \u5207\u6362\u5230\u65b0\u521b\u5efa\u7684uthread\n    swapcontext(&(schedule.main), &(t->ctx));\n    \n    return id;\n}\n\nint schedule_finished(const schedule_t &schedule)\n{\n    if (schedule.running_thread != -1){\n        return 0;\n    }else{\n        for(int i = 0; i < schedule.max_index; ++i){\n            if(schedule.threads[i].state != FREE){\n                return 0;\n            }\n        }\n    }\n\n    return 1;\n}\n\n#endif",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"story\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"main.h\"\n#include \"autoSelect/selection.h\"\n#include \"pros/misc.hpp\"\n#include \"pros/rtos.h\"\n#include \"pros/screen.hpp\"\n#include \"sylib/system.hpp\"\n\n\n\nnamespace selector{\n\nint auton;\nint autonCount;\nconst char *btnmMap[] = {\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"}; // up to 10 autons\n\nlv_obj_t *tabview;\nlv_obj_t *redBtnm;\nlv_obj_t *blueBtnm;\n\nlv_res_t redBtnmAction(lv_obj_t *btnm, const char *txt){\n\t//printf(\"red button: %s released\\n\", txt);\n\n\tfor(int i = 0; i < autonCount; i++){\n\t\tif(strcmp(txt, btnmMap[i]) == 0){\n\t\t\tauton = i+1;\n\t\t}\n\t}\n\n\treturn LV_RES_OK; // return OK because the button matrix is not deleted\n}\n\nlv_res_t blueBtnmAction(lv_obj_t *btnm, const char *txt)\n{\n\t//printf(\"blue button: %s released\\n\", txt);\n\n\tfor(int i = 0; i < autonCount; i++){\n\t\tif(strcmp(txt, btnmMap[i]) == 0){\n\t\t\tauton = -(i+1);\n\t\t}\n\t}\n\n\treturn LV_RES_OK; // return OK because the button matrix is not deleted\n}\n\nlv_res_t skillsBtnAction(lv_obj_t *btn){\n  \t//printf(\"skills pressed\");\n\tauton = 0;\n\treturn LV_RES_OK;\n}\n\nint tabWatcher() {\n\tint activeTab = lv_tabview_get_tab_act(tabview);\n\twhile(1){\n\t\tint currentTab = lv_tabview_get_tab_act(tabview);\n\n\t\tif(currentTab != activeTab){\n\t\t\tactiveTab = currentTab;\n\t\t\tif(activeTab == 0){\n\t\t\t\tif(auton == 0) auton = 1;\n\t\t\t\tauton = abs(auton);\n\t\t\t\tlv_btnm_set_toggle(redBtnm, true, abs(auton)-1);\n\t\t\t}else if(activeTab == 1){\n\t\t\t\tif(auton == 0) auton = -1;\n\t\t\t\tauton = -abs(auton);\n\t\t\t\tlv_btnm_set_toggle(blueBtnm, true, abs(auton)-1);\n\t\t\t}else{\n\t\t\t\tauton = 0;\n\t\t\t}\n\t\t}\n\n\t\tpros::delay(20);\n\t}\n}\n\nvoid init(int hue, int default_auton, const char **autons){\n\n\tint i = 0;\n\tdo{\n\t\tmemcpy(&btnmMap[i], &autons[i], sizeof(&autons));\n\t\ti++;\n\t}while(strcmp(autons[i], \"\") != 0);\n\n\tautonCount = i;\n\tauton = default_auton;\n\n\t// lvgl theme\n\tlv_theme_t *th = lv_theme_alien_init(hue, NULL); //Set a HUE value and keep font default RED\n\tlv_theme_set_current(th);\n\n\t// create a tab view object\n\ttabview = lv_tabview_create(lv_scr_act(), NULL);\n\n\t// add 3 tabs (the tabs are page (lv_page) and can be scrolled\n\tlv_obj_t *redTab = lv_tabview_add_tab(tabview, \"Red\");\n\tlv_obj_t *blueTab = lv_tabview_add_tab(tabview, \"Blue\");\n\tlv_obj_t *skillsTab = lv_tabview_add_tab(tabview, \"Skills\");\n\n\t//set default tab\n\tif(auton < 0){\n\t\tlv_tabview_set_tab_act(tabview, 1, LV_ANIM_NONE);\n\t}else if(auton == 0){\n\t\tlv_tabview_set_tab_act(tabview, 2, LV_ANIM_NONE);\n\t}\n\n\t// add content to the tabs\n\t// button matrix\n\tredBtnm = lv_btnm_create(redTab, NULL);\n\tlv_btnm_set_map(redBtnm, btnmMap);\n\tlv_btnm_set_action(redBtnm, redBtnmAction);\n\tlv_btnm_set_toggle(redBtnm, true, abs(auton)-1);//3\n\tlv_obj_set_size(redBtnm, 450, 50);\n\tlv_obj_set_pos(redBtnm, 0, 100);\n\tlv_obj_align(redBtnm, NULL, LV_ALIGN_CENTER, 0, 0);\n\n\t// blue tab\n\tblueBtnm = lv_btnm_create(blueTab, NULL);\n\tlv_btnm_set_map(blueBtnm, btnmMap);\n\tlv_btnm_set_action(blueBtnm, *blueBtnmAction);\n\tlv_btnm_set_toggle(blueBtnm, true, abs(auton)-1);\n\tlv_obj_set_size(blueBtnm, 450, 50);\n\tlv_obj_set_pos(blueBtnm, 0, 100);\n\tlv_obj_align(blueBtnm, NULL, LV_ALIGN_CENTER, 0, 0);\n\n\t// skills tab\n\tlv_obj_t *skillsBtn = lv_btn_create(skillsTab, NULL);\n\tlv_obj_t *label = lv_label_create(skillsBtn, NULL);\n\tlv_label_set_text(label, \"Skills\");\n\tlv_btn_set_action(skillsBtn, LV_BTN_ACTION_CLICK, *skillsBtnAction);\n\t// lv_btn_set_state(skillsBtn, LV_BTN_STATE_TGL_REL);\n\tlv_obj_set_size(skillsBtn, 450, 50);\n\tlv_obj_set_pos(skillsBtn, 0, 100);\n\tlv_obj_align(skillsBtn, NULL, LV_ALIGN_CENTER, 0, 0);\n\n\t// start tab watcher\n\tvoid tabWatcher_task(void*);\n\tpros::task_t my_task = pros::c::task_create(tabWatcher_task,(void*) \"PROS\", TASK_PRIORITY_DEFAULT, TASK_STACK_DEPTH_DEFAULT, \"My Task\");\n\n}\n\n} // namespace selector\n",
    "#include <enet/enet.h>\n#include <iostream>\n\n#include \"Client.h\"\n\nClient::Client()\n\t: mClient(nullptr), mPeer(nullptr)\n{\n\tif (enet_initialize() != 0) {\n\t\tLog(\"Failed to Initialise ENet Client\");\n\t\treturn;\n\t}\n\n\tatexit(enet_deinitialize);\n\n\tmClient = enet_host_create(NULL, 1, 1, 0, 0);\n\n\tif (mClient == NULL)\n\t{\n\t\tLog(\"Failed to Create ENet Client\");\n\t\treturn;\n\t}\n}\n\nvoid Client::Connect(const std::string& ip, int port)\n{\n\tENetAddress address;\n\tENetEvent event;\n\n\tenet_address_set_host(&address, ip.c_str());\n\taddress.port = port;\n\n\tmPeer = enet_host_connect(mClient, &address, 1, 0);\n\tif (mPeer == NULL)\n\t{\n\t\tLog(\"Failed to Connect to Server\");\n\t}\n\n\tif (enet_host_service(mClient, &event, 5000) > 0 &&\n\t\tevent.type == ENET_EVENT_TYPE_CONNECT)\n\t{\n\t\tLog(\"Connection to 127.0.0.1:7777 succeeded\");\n\t}\n\telse\n\t{\n\t\tenet_peer_reset(mPeer);\n\t\tLog(\"Connection to 127.0.0.1:7777 failed.\");\n\t}\n}\n\nvoid Client::Message(const std::string& message)\n{\n\tconst char* convertedMessage = message.c_str();\n\n\tENetPacket* packet = enet_packet_create(convertedMessage, strlen(convertedMessage) + 1, ENET_PACKET_FLAG_RELIABLE);\n\n\tif (enet_peer_send(mPeer, 0, packet) != 0)\n\t{\n\t\tLog(\"Error with sending Message\");\n\t\tenet_packet_destroy(packet);\n\t}\n}\n\nvoid Client::ReceiveMessages()\n{\n\tENetEvent event;\n\n\twhile (enet_host_service(mClient, &event, 0) > 0)\n\t{\n\t\tswitch (event.type)\n\t\t{\n\t\tcase ENET_EVENT_TYPE_RECEIVE:\n\t\t\t//printf(\"A packet of length %u containing %s was received from %s on channel %u.\\n\",\n\t\t\t//\tevent.packet->dataLength,\n\t\t\t//\tevent.packet->data,\n\t\t\t//\tevent.peer->data,\n\t\t\t//\tevent.channelID);\n\n\t\t\tstd::cout << \"[SERVER] \" << event.packet->data << std::endl;\n\n\t\t\t/* Clean up the packet now that we're done using it. */\n\t\t\tenet_packet_destroy(event.packet);\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid Client::Disconnect()\n{\n\tENetEvent event;\n\n\tenet_peer_disconnect(mPeer, 0);\n\n\twhile (enet_host_service(mClient, &event, 0) > 0)\n\t{\n\t\tswitch (event.type)\n\t\t{\n\t\tcase ENET_EVENT_TYPE_RECEIVE:\n\t\t\tenet_packet_destroy(event.packet);\n\t\t\tbreak;\n\t\tcase ENET_EVENT_TYPE_DISCONNECT:\n\t\t\tLog(\"Successfully Disconnected from Server\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tenet_peer_reset(mPeer);\n}\n\nvoid Client::Log(const std::string& log)\n{\n\tstd::cout << \"[LOG] \" << log << std::endl;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// dear imgui, v1.89.6 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)\n//-------------------------------------------------------------------------\n\n// Compile time options:\n//#define IMGUI_STB_NAMESPACE           ImStb\n//#define IMGUI_STB_TRUETYPE_FILENAME   \"my_folder/stb_truetype.h\"\n//#define IMGUI_STB_RECT_PACK_FILENAME  \"my_folder/stb_rect_pack",
    "#include <iostream>\r\n#include \"dec.h\"\r\n//globally defined\r\nusing namespace std;\r\nstring board[9] = {\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"}; \r\nint player = 1;   \r\nint position = 0;  \r\n\r\nvoid introduction()\r\n{\r\n\tcout<<\"Press [Enter] to begin: \";\r\n\tgetchar(); //haults the screen  \r\n\tcout<<\"\\n\";\r\n\t\r\n\t cout<<\"\\n\";\r\n  cout<<\"***********\\n\";\r\n  cout<<\"Tic-Tac-Toe\\n\";\r\n  cout<<\"***********\\n\";\r\n  \r\n  cout<<\"Player 1) X\\n\";\r\n  cout<<\"Player 2) O\\n\";\r\n  \r\n  cout<<\"The 3x3 grid is shown below:\\n\\n\";\r\n  \r\n  cout << \"     |     |      \\n\";\r\n  cout << \"  1  |  2  |  3   \\n\";\r\n  cout << \"_____|_____|_____ \\n\";\r\n  cout << \"     |     |      \\n\";\r\n  cout << \"  4  |  5  |  6   \\n\";\r\n  cout << \"_____|_____|_____ \\n\";\r\n  cout << \"     |     |      \\n\";\r\n  cout << \"  7  |  8  |  9   \\n\";\r\n  cout << \"     |     |      \\n\\n\";\r\n  \r\n}\r\n\r\n\r\n\r\nbool is_winner()\r\n{\r\n\tbool winner = false;\r\n\t//checking the rows\r\n\tif((board[0]==board[1]) && (board[1]==board[2]) && board[0] != \" \") \r\n\t{\r\n\t\twinner = true;\r\n\t}\r\n\telse if ((board[3] == board[4]) && (board[4] == board[5]) && board[3] != \" \") \r\n\t{\r\n    winner = true;\r\n    } \r\n\t \r\n\telse if ((board[6] == board[7]) && (board[7] == board[8]) && board[6] != \" \") \r\n\t{\r\n    winner = true;\r\n  \t} \r\n\r\n\t//checking the columns\r\n\t\r\n\telse if((board[0]==board[3]) && (board[3]==board[6]) && board[0] != \" \")\r\n\t{\r\n\t\twinner = true;\r\n\t}\r\n\t\r\n\telse if ((board[1] == board[4]) && (board[4] == board[7]) && board[1] != \" \")\r\n\t{\r\n    winner = true;\r\n \t } \r\n\t\r\n\telse if ((board[2] == board[5]) && (board[5] == board[8]) && board[2] != \" \") \r\n\t{\r\n    winner = true;\r\n  \t}\r\n\r\n\t//checking the diagonals\r\n\t\r\n\telse if ((board[0]==board[4]) && (board[4]==board[8]) && board[0] != \" \")\r\n\t{\r\n\t\twinner = true;\r\n\t}\r\n\t\r\n\telse if ((board[2]==board[4]) && (board[4]==board[6]) && board[2] != \" \")\r\n\t{\r\n\t\twinner = true;\r\n\t}\r\n\t\r\n\treturn winner;\r\n\t\r\n}\r\n\r\nbool filled_up()\r\n{\r\n\tbool filled = true;\r\n\t\r\n\tfor(int i = 0; i<9; i++)\r\n\t{\r\n\t\tif(board[i]==\" \")\r\n\t\t{\r\n\t\t\tfilled = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn filled;\r\n}\r\n\r\n\r\n\r\n\r\nvoid draw()\r\n{\r\n  cout<<  \"     |     |      \\n\";\r\n  cout << \"  \" << board[0] << \"  |  \" << board[1] << \"  |  \" << board[2] << \"\\n\";\r\n  cout << \"_____|_____|_____ \\n\";\r\n  cout << \"     |     |      \\n\";\r\n  cout << \"  \" << board[3] << \"  |  \" << board[4] << \"  |  \" << board[5] << \"\\n\";\r\n  cout << \"_____|_____|_____ \\n\";\r\n  cout << \"  \" << board[6] << \"  |  \" << board[7] << \"  |  \" << board[8] << \"\\n\";\r\n  cout << \"     |     |      \\n\";\r\n  cout << \"\\n\";\r\n\r\n}\r\n\r\n\r\n\r\nvoid set_position()\r\n{\r\n\tcout<<\"Player \"<<player<<\"'s turn (Enter: 1-9)\";   //1-9 (Enter: (1-9))\r\n\twhile(!(cin>>position))\r\n\t{\r\n\t\tcout<<\"Please enter a valid number between (1-9)\"<<endl;\r\n\t\tcin.clear();  //flushing the buffer\r\n    \tcin.ignore();  \r\n\t}\r\n\tcout<<endl;\r\n\t\r\n\twhile (board[position -1] != \" \"){\r\n    cout<<\"Oops, that position is already filled\\nTry again\\n\";\r\n    cout << \"Player \" << player << \"'s Turn (Enter 1-9): \";\r\n    cin>>position;\r\n    cout<<\"\\n\";\r\n\r\n\t\r\n}\r\n\r\n}\r\n\r\n\r\nvoid update_board()\r\n{\r\n  \r\n  if (player % 2 == 1){\r\n    board[position - 1] = \"X\";   //1-9        0-8\r\n  }\r\n  else\r\n  {\r\n    board[position - 1] = \"O\";\r\n  }\r\n}\r\n\r\n\r\nvoid change_player() {\r\n  if (player == 1){\r\n    player++;\r\n  }\r\n  else{\r\n    player--;\r\n  }\r\n}\r\n\r\n\r\nvoid take_turn()\r\n{\r\n\twhile(!is_winner() && !filled_up())  \r\n\t{\r\n\t\t//invoking the functions\r\n\t\tset_position();\r\n\t\tupdate_board();\r\n\t\tchange_player();\r\n\t\tdraw();\r\n\t}\r\n}\r\n\r\nvoid end_game()\r\n{\r\n\tif(is_winner())\r\n\t{\r\n\t\tcout<<\"There is a winner!\"<<endl;\r\n\t\t\r\n\t}\r\n\t\r\n\telse if(filled_up())\r\n\t{\r\n\t\tcout<<\"There is a tie!\"<<endl;\r\n\t}\r\n}\r\n\r\n",
    "#include <Arduino.h>\n#include <SPI.h>\n#include <winbond.h>\n\n#define _begin digitalWrite(W25Q_SS_PIN, LOW)\n#define _end digitalWrite(W25Q_SS_PIN, HIGH)\n#define _wait                  \\\n    while (readBusyBit() == 1) \\\n    {                          \\\n        delay(10);             \\\n    }\n\nWinbond flash;\n\nWinbond::Winbond()\n{\n    this->maxSPIFrequency = DEFAULT_MAX_SPI_FREQUENCY;\n}\nvoid Winbond::readManufacturer()\n{\n    uint8_t readStr[6];\n    _begin;\n    readStr[0] = SPI.transfer(0x90, SPI_TRANSMITRECEIVE); // Transfer the 8-bit value of data to shift register, remembering that the least significant bit goes first\n    readStr[1] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[2] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[3] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[4] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[5] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    _end;\n    Serial.print(\"Manufactorer ID: \");\n    Serial.print(readStr[4]);\n    Serial.print(\"   Device ID: \");\n    Serial.println(readStr[5]);\n}\nvoid Winbond::readUniqueID()\n{\n    uint8_t readStr[13];\n    _begin;\n    ;\n    readStr[0] = SPI.transfer(0x4b, SPI_TRANSMITRECEIVE);  //\n    readStr[1] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[2] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[3] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[4] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[5] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[6] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[7] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[8] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[9] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);  //\n    readStr[10] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[11] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[12] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);\n    _end;\n    String strout = \"Serial Numer: \";\n    for (int i = 5; i <= 11; i++)\n    {\n        strout += readStr[i];\n        strout += \"-\";\n    }\n    strout += readStr[12];\n    Serial.println(strout);\n}\nvoid Winbond::readJedecID()\n{\n    uint8_t readStr[4];\n    _begin;\n    readStr[0] = SPI.transfer(0x9f, SPI_TRANSMITRECEIVE); //\n    readStr[1] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[2] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    readStr[3] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE); //\n    _end;\n    Serial.printf(\"Manufacturer ID: %d   Memory Type: %d   Capacity: %d\\r\\n\", readStr[1], readStr[2], readStr[3]);\n}\nvoid Winbond::readStatus(statusRegisterIndex resgisterIndex = STATUS_REGISTER_1)\n{\n    uint8_t data[3];\n    _begin;\n    (resgisterIndex == STATUS_REGISTER_1) ? SPI.transfer(0x05, SPI_TRANSMITRECEIVE) : SPI.transfer(0x35, SPI_TRANSMITRECEIVE);\n    data[1] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);\n    data[2] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);\n    _end;\n    Serial.printf(\"Status Register %d: %d %d\\r\\n\", resgisterIndex + 1, data[1], data[2]);\n}\nuint8_t Winbond::readBusyBit()\n{\n    uint8_t data[3];\n    _begin;\n    data[0] = SPI.transfer(0x05, SPI_TRANSMITRECEIVE);\n    data[1] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);\n    data[2] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);\n    _end;\n    return data[2] & 0b00000001;\n}\nvoid Winbond::readData(uint32_t address, uint16_t data_lenght)\n{\n    if (data_lenght == 0 || data_lenght > 256)\n        return;\n    uint8_t msb_address = (address >> 16) & 0xff;\n    uint8_t mid_address = (address >> 8) & 0xff;\n    uint8_t lsb_address = address & 0xff;\n    uint8_t data[5];\n    _begin;\n    data[0] = SPI.transfer(0x03, SPI_TRANSMITRECEIVE);\n    data[1] = SPI.transfer(msb_address, SPI_TRANSMITRECEIVE);\n    data[2] = SPI.transfer(mid_address, SPI_TRANSMITRECEIVE);\n    data[3] = SPI.transfer(lsb_address, SPI_TRANSMITRECEIVE);\n    for (uint8_t i = 0; i < data_lenght; i++)\n        Serial.printf(\"%d \", SPI.transfer(0x00, SPI_TRANSMITRECEIVE));\n    Serial.println(\"\");\n    data[4] = SPI.transfer(0x00, SPI_TRANSMITRECEIVE);\n    _end;\n}\nvoid Winbond::readPage(uint32_t address)\n{\n    uint8_t msb_address = (address >> 16) & 0xff;\n    uint8_t mid_address = (address >> 8) & 0xff;\n    uint8_t lsb_address = address & 0xff;\n    uint8_t data[5];\n    _begin;\n    data[0] = SPI.transfer(0x03, SPI_TRANSMITRECEIVE);\n    data[1] = SPI.transfer(msb_address, SPI_TRANSMITRECEIVE);\n    data[2] = SPI.transfer(mid_address, SPI_TRANSMITRECEIVE);\n    data[3] = SPI.transfer(lsb_address, SPI_TRANSMITRECEIVE);\n    for (int i = 1; i <= 255; i++)\n        Serial.printf(\"%d \", SPI.transfer(0x00, SPI_TRANSMITRECEIVE));\n    Serial.println(SPI.transfer(0x00, SPI_TRANSMITRECEIVE));\n    _end;\n}\nvoid Winbond::writeData(uint32_t address, uint8_t data)\n{\n    uint8_t msb_address = (address >> 16) & 0xff;\n    uint8_t mid_address = (address >> 8) & 0xff;\n    uint8_t lsb_address = address & 0xff;\n    // enable write\n    _begin;\n    SPI.transfer(0x06, SPI_TRANSMITRECEIVE);\n    _end;\n ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//Binary search:\r\n//Using divide and conquer method write a program for binary search.\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint binarySearch(int array[], int x, int LOW, int UP) {\r\n    if (UP >= LOW) {\r\n        int mid = (LOW +UP)/ 2;\r\n        // If found at mid, then return it\r\n        if (array[mid] == x)\r\n            return mid;\r\n        // Search the left half\r\n        if (array[mid] > x)\r\n            return binarySearch(array, x, LOW, mid - 1);\r\n        // Search the right half\r\n        return binarySearch(array, x, mid + 1, UP);\r\n    }\r\n    return -1; // Element not found\r\n}\r\n\r\nint main() {\r\n    int array[50];\r\n    \r\n    int i,n;\r\n    cout<<\"Enter size of array:\\n\";\r\n    cin>>n;\r\n    cout<<\"Enter the elements in array:\\n\";\r\n    for(i=0;i<n;i++)\r\n        cin>>array[i];\r\n    int x;\r\n    cout << \"Enter the element you want to search: \";\r\n    cin >> x;\r\n    int result = binarySearch(array, x, 0, n - 1);\r\n    if (result == -1)\r\n        cout << \"Element not found\";\r\n    else\r\n        cout << \"Element is found at index \" << result;\r\n    return 0;\r\n}",
    "/*!\n * @file DFRobot_ColorTemperature.cpp\n * @brief This is the implementation file for DFRobot_ColorTemperature\n * @copyright   Copyright (c) 2010 DFRobot Co.Ltd (http://www.dfrobot.com)\n * @license     The MIT License (MIT)\n * @author [TangJie](jie.tang@dfrobot.com)\n * @version  V1.0\n * @date  2024-04-01\n * @url https://github.com/DFRobot/DFRobot_ColorTemperature\n */\n\n#include \"DFRobot_ColorTemperature.h\"\n\nDFRobot_ColorTemperature::DFRobot_ColorTemperature(TwoWire *pWire)\n{\n  _pWire = pWire;\n  _addr = COLORTEMPERATURE_ADDR;\n};\n\nDFRobot_ColorTemperature::DFRobot_ColorTemperature(Stream *s):DFRobot_RTU(s)\n{\n  _s = s;\n  _addr = COLORTEMPERATURE_ADDR;\n};\n\nint8_t DFRobot_ColorTemperature::begin(void)\n{\n  delay(500);\n  setTimeoutTimeMs(200);\n  \n  if(_addr > 0xF7){\n    DBG(\"Invaild Device addr.\");\n  }\n  if(_addr != 0){\n    if(!detectDeviceAddress(_addr)){\n      DBG(\"Device addr Error.\");\n      return -1;\n    }\n  }else{\n    return -1;\n  }\n  return 0;\n}\n\nuint16_t DFRobot_ColorTemperature::readLUX(void)\n{\n  uint16_t data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_LUX_REG,buffer,2);\n  if(_pWire){\n    data = buffer[1] << 8 | buffer[0];\n  }else{\n    data = buffer[0] << 8 | buffer[1];\n  }\n  \n  return data;\n}\n\nuint16_t DFRobot_ColorTemperature::readCCT(void)\n{\n  uint16_t data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_CCT_REG,buffer,2);\n  if(_pWire){\n    data = buffer[1] << 8 | buffer[0];\n  }else{\n    data = buffer[0] << 8 | buffer[1];\n  }\n  return data;\n}\n\nfloat DFRobot_ColorTemperature::readX(void)\n{\n  float data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_X_REG,buffer,2);\n  if(_pWire){\n    data = (float)(buffer[1] << 8 | buffer[0]) / 10000;\n  }else{\n    data = (float)(buffer[0] << 8 | buffer[1]) / 10000;\n  }\n  \n  return data;\n}\n\nfloat DFRobot_ColorTemperature::readY(void)\n{\n  float data = 0;\n  uint8_t buffer[4];\n  readReg(COLORTEMPERATURE_Y_REG,buffer,2);\n  if(_pWire){\n    data = (float)(buffer[1] << 8 | buffer[0]) / 10000;\n  }else{\n    data = (float)(buffer[0] << 8 | buffer[1]) / 10000;\n  }\n  return data;\n}\n\nbool  DFRobot_ColorTemperature::detectDeviceAddress(uint8_t addr)\n{\nuint8_t buf[2];\n  if(_pWire){\n  _pWire->begin();\n  }\n  readReg(COLORTEMPERATURE_ADDR_REG, buf, 2);\n  DBG((buf[0] << 8| buf[1]));\n  if(_pWire){\n    if(addr == ((buf[1] << 8| buf[0]) & 0xFF))\n    return true;\n  }else{\n    if(addr == ((buf[0] << 8| buf[1]) & 0xFF))\n    return true;\n  }\n  return false;\n}\n\nuint8_t DFRobot_ColorTemperature::readReg(uint16_t reg, void *pBuf, uint8_t size)\n{\n  uint8_t* _pBuf = (uint8_t*)pBuf;\n  \n    if(pBuf == NULL){\n      DBG(\"data error\");\n      return 0;\n    }\n  if(_pWire){\n    uint8_t _reg = reg;\n    _pWire->begin();\n    _pWire->beginTransmission(_addr);\n    _pWire->write(_reg);\n    _pWire->endTransmission();\n    _pWire->requestFrom(_addr, size);\n    for(uint8_t i = 0; i < size; i++)\n      _pBuf[i] = _pWire->read();\n    \n    return size;\n  }else{\n    return readInputRegister(_addr, reg, _pBuf, size);\n  }\n}",
    "\ufeff#include <iostream>\n#include <thread>\n#include <vector>\n#include <chrono>\n#include <algorithm>\n\nvoid sum(int number) {\n    std::vector<int> v1(number);\n    std::vector<int> v2(number);\n    std::transform(v1.begin(), v1.end(), v2.begin(), v2.begin(), std::plus<int>());\n}\n\nvoid threading(int numberThreads, int vectorNumber) {\n    auto start = std::chrono::steady_clock::now();\n    if (numberThreads == 2)\n    {\n        std::thread t1(sum, vectorNumber);\n        std::thread t2(sum, vectorNumber);\n        t1.join();\n        t2.join();\n    }\n    else if (numberThreads == 4) {\n        std::thread t1(sum, vectorNumber);\n        std::thread t2(sum, vectorNumber);\n        std::thread t3(sum, vectorNumber);\n        std::thread t4(sum, vectorNumber);\n        t1.join();\n        t2.join();\n        t3.join();\n        t4.join();\n    }\n    else if (numberThreads == 8) {\n        std::thread t1(sum, vectorNumber);\n        std::thread t2(sum, vectorNumber);\n        std::thread t3(sum, vectorNumber);\n        std::thread t4(sum, vectorNumber);\n        std::thread t5(sum, vectorNumber);\n        std::thread t6(sum, vectorNumber);\n        std::thread t7(sum, vectorNumber);\n        std::thread t8(sum, vectorNumber);\n        t1.join();\n        t2.join();\n        t3.join();\n        t4.join();\n        t5.join();\n        t6.join();\n        t7.join();\n        t8.join();\n    }\n    else if (numberThreads == 16) {\n        std::thread t1(sum, vectorNumber);\n        std::thread t2(sum, vectorNumber);\n        std::thread t3(sum, vectorNumber);\n        std::thread t4(sum, vectorNumber);\n        std::thread t5(sum, vectorNumber);\n        std::thread t6(sum, vectorNumber);\n        std::thread t7(sum, vectorNumber);\n        std::thread t8(sum, vectorNumber);\n        std::thread t9(sum, vectorNumber);\n        std::thread t10(sum, vectorNumber);\n        std::thread t11(sum, vectorNumber);\n        std::thread t12(sum, vectorNumber);\n        std::thread t13(sum, vectorNumber);\n        std::thread t14(sum, vectorNumber);\n        std::thread t15(sum, vectorNumber);\n        std::thread t16(sum, vectorNumber);\n        t1.join();\n        t2.join();\n        t3.join();\n        t4.join();\n        t5.join();\n        t6.join();\n        t7.join();\n        t8.join();\n        t9.join();\n        t10.join();\n        t11.join();\n        t12.join();\n        t13.join();\n        t14.join();\n        t15.join();\n        t16.join();\n    }\n    else {\n        std::thread t1(sum, vectorNumber);\n        t1.join();\n    }\n    auto end = std::chrono::steady_clock::now();\n    std::chrono::duration<double> elapsed_seconds = end - start;\n    std::cout << elapsed_seconds.count() << \"        \";\n}\n\nint main()\n{\n    unsigned int n = std::thread::hardware_concurrency();\n    std::cout << \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0445 \u044f\u0434\u0435\u0440 - \"<< n <<\"\\n\\n\";\n\n    std::cout << \"               \" << 1000 << \"            \" << 10000 << \"            \" << 100000 << \"            \" << 1000000 << \"\\n\";\n\n    //\u0417\u0430\u043f\u0443\u0441\u043a \u043e\u0434\u043d\u043e\u0433\u043e \u043f\u043e\u0442\u043e\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\n    std::cout << \"1 \u043f\u043e\u0442\u043e\u043a\u043e\u0432   \";\n    threading(1, 1000);\n    threading(1, 10000);\n    threading(1, 100000);\n    threading(1, 1000000);\n    std::cout << \"\\n\";\n\n    std::cout << \"2 \u043f\u043e\u0442\u043e\u043a\u043e\u0432   \";\n    threading(2, 1000);\n    threading(2, 10000);\n    threading(2, 100000);\n    threading(2, 1000000);\n    std::cout << \"\\n\";\n\n    std::cout << \"4 \u043f\u043e\u0442\u043e\u043a\u043e\u0432   \";\n    threading(4, 1000);\n    threading(4, 10000);\n    threading(4, 100000);\n    threading(4, 1000000);\n    std::cout << \"\\n\";\n\n    std::cout << \"8 \u043f\u043e\u0442\u043e\u043a\u043e\u0432   \";\n    threading(8, 1000);\n    threading(8, 10000);\n    threading(8, 100000);\n    threading(8, 1000000);\n    std::cout << \"\\n\";\n\n    std::cout << \"16 \u043f\u043e\u0442\u043e\u043a\u043e\u0432   \";\n    threading(16, 1000);\n    threading(16, 10000);\n    threading(16, 100000);\n    threading(16, 1000000);\n    std::cout << \"\\n\";\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"firefly_web\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\nclass ToiletCleaner {\npublic:\n    void clean() {\n        std::cout << \"\u0422\u0443\u0430\u043b\u0435\u0442 \u043c\u044b\u0435\u0442\u0441\u044f...\" << std::endl;\n    }\n};\n\nint main() {\n    ToiletCleaner cleaner;\n    cleaner.clean(); // \u041d\u0430\u0447\u0430\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043c\u044b\u0442\u044c\u044f \u0442\u0443\u0430\u043b\u0435\u0442\u0430\n    return 0;\n}\n\n\nclass GirlApproacher {\npublic:\n    void approach() {\n        std::cout << \"\u041f\u043e\u0434\u043a\u0430\u0442\u044b\u0432\u0430\u044e \u043a \u0434\u0435\u0432\u0443\u0448\u043a\u0435...\" << std::endl;\n    }\n};\n\nint main() {\n    GirlApproacher approacher;\n    approacher.approach(); // \u041d\u0430\u0447\u0430\u0442\u044c \u043f\u043e\u0434\u043a\u0430\u0442\u044b\u0432\u0430\u0442\u044c \u043a \u0434\u0435\u0432\u0443\u0448\u043a\u0435\n    return 0;\n}\n\n\n\n__________________\u2584\u2580\u2584\n_______________\u2584\u2580____\u2580\u2584\n_____________\u2584\u2580_____\u2584\u2580\u2588\n___________\u2584\u2580_____\u2584\u2580_\u2584\u2580_\u2584\u2580\u2584\n________\u2584\u2580_____\u2584\u2580_\u2584\u2580_\u2584\u2580____\u2580\u2584\n________\u2588\u2580\u2584_____\u2580\u2588_\u2584\u2580_________\u2580\u2584\n___\u2584\u2580\u2584_\u2580\u2584_\u2580\u2584_____\u2580_____\u2584\u2588\u2584_____\u2580\u2584\n\u2584\u2580____\u2580\u2584_\u2580\u2584_\u2580\u2584_______\u2584\u2580_\u2588_\u2580\u2584_____\u2580\u2584\n\u2588\u2580\u2584_____\u2580\u2584_\u2588\u2580_________\u2580\u2588_\u2580\u2584_\u2580\u2584_\u2584\u2580_\u2588\n\u2580\u2584_\u2580\u2584_____\u2580_____\u2584\u2588\u2584_____\u2580\u2584_\u2580\u2584_\u2588_\u2584\u2580\n__\u2580\u2584_\u2580\u2584______\u2584\u2580_\u2588_\u2580\u2584_____\u2580\u2584_\u2580\u2588\u2580\n_____\u2580\u2584_\u2580\u2584_\u2584\u2580_\u2584\u2580_\u2588\u2580_____\u2584\u2580\u2588\n________\u2580\u2584_\u2588_\u2584\u2580_\u2584\u2580_____\u2584\u2580_\u2584\u2580\n__________\u2580\u2588\u2580_\u2584\u2580_____\u2584\u2580_\u2584\u2580\n_______________\u2588\u2580\u2584_\u2584\u2580_\u2584\u2580\n________________\u2580\u2584_\u2588_\u2584\u2580\n__________________\u2580\u2588\u2580\n\n\u28b0\u287f\u280b\u2801\u2800\u2800\u2808\u2809\u2819\u283b\u28f7\u28c4\u2800\n\u2800\u2800\u2800\u2800\u2880\u28ff\u2807\u2800\u2880\u28f4\u28f6\u287e\u283f\u283f\u283f\u28bf\u28ff\u28e6\u2840\u2800\n\u2800\u2800\u28c0\u28c0\u28f8\u287f\u2800\u2800\u28b8\u28ff\u28c7\u2800\u2800\u2800\u2800\u2800\u2800\u2819\u28f7\u2840\u2800\u2800\u2800\n\u2800\u28fe\u285f\u281b\u28ff\u2847\u2800\u2800\u28b8\u28ff\u28ff\u28f7\u28e4\u28e4\u28e4\u28e4\u28f6\u28f6\u28ff\u2807\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u2800\u2800\n\u2880\u28ff\u2800\u2880\u28ff\u2847\u2800\u2800\u2800\u283b\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u28ff\u284f\u2800\u2800\u2800\u2800\u28b4\u28f6\u28f6\u28ff\u28ff\u28ff\u28c6\n\u28b8\u28ff\u2800\u28b8\u28ff\u2847\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2801\u2800\u2800\u2800\u28ff\u2847\u28c0\u28e0\u28f4\u28fe\u28ee\u28dd\u283f\u283f\u283f\u28fb\u285f\n\u28b8\u28ff\u2800\u2818\u28ff\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u28f6\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2801\u2809\n\u2838\u28ff\u2800\u2800\u28ff\u2847\u2800\u2800\u2800\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281f\u2809\u2800\n\u2800\u283b\u28f7\u28f6\u28ff\u28c7\u2800\u2800\u2800\u28a0\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28db\u28db\u28fb\u2809\u2801\n\u2800\u2800\u2800\u2800\u28b8\u28ff\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2800\u2800\u28b8\u28ff\u28c0\u28c0\u28c0\u28fc\u287f\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u28ff\u28ff\u287f\u2800\n\u2800\u2800\u2800\u2800\u2800\u2819\u281b\u281b\u281b\u280b\u2801\u2800\u2819\u283b\u283f\u281f\u280b\u2811\u281b\u280b\n\n\u28b0\n\u28b8\n\u28b8\n\u28b8\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u28f6\u28ff\u28f6\u28c4\n\u28bf\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28e4\u28c4\n\u2800\u2839\u28ff\u28e7\u28c0\u28e0\u28f4\u28fe\u28f7\u28ff\u28f7\u283e\u28b7\u280b\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u2877\n\u2800\u2800\u2808\u28bf\u287f\u281f\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2839\u28ff\u28ff\u28ff\u285f\n\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u285f\u28bf\u28ff\u28c4\u2800\u2800\u2800\u2800\u28a0\u28f6\u28fe\u28ff\u2847\n\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u2800\u2819\u283f\u287f\u2886\u28f4\u28ff\u28ff\u28ff\u28ff\u2847\n\u2800\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u28e4\u28f6\u28fe\u28ff\u28ff\u28ff\u28ff\u28f7\u2839\u28f7\u28e4\u28e4\u28c4\u28c0\u2840\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u284f\u28ff\u28ff\u28ff\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28cf\u2800\u2800\u2880\u28c0\u28c8\u28c9\u28c9\u28c9\u28d9\u28c1\u28c0\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u2847\u28ff\u28ff\u288f\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u2847\u28ff\u28ff\u28f7\u2808\u2809\u2819\u281b\u28bb\u28ed\u28f7\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u2847\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u28b9\u28ff\u28f7\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u2847\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u28fe\u28ff\u284f\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28ff\u28ff\u2847\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u28b0\u28ff\u28ff\n\u2800\u2800\u2800\u2800\u2800\u2818\u28bf\u287f\u2807\u283b\u28ff\u281f\u2800\u2800\u2800\u2800\u28bf\u28ff\u2807\u28b0\n\n\n\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\n\u3000|\u3000Windows\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000[\uff0d][\u53e3][\u00d7]|\n\u3000|\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\u3000\uffe3|\n\u3000|\u3000Windows \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0438\u043b, \u0447\u0442\u043e \u0443 \u0432\u0430\u0441 \u043c\u0430\u043b\u0435\u043d\u044c\u043a\u0438\u0439 \u043f\u0435\u043d\u0438\u0441.\u3000\u3000\u3000\u3000\u3000\u3000\u3000 |\n\u3000| \u3000\u042d\u0442\u043e \u043f\u0440\u0430\u0432\u0434\u0430? \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 |\n\u3000|\u3000\u3000\u3000\u3000\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\u3000\u3000\u3000\u3000\uff3f\uff3f\uff3f\uff3f\uff3f\uff3f\u3000\u3000\u3000\u3000\uff3f\uff3f\uff3f\uff3f\uff3f\u3000\u3000 |\n\u3000| \u3000\u3000\u3000\uff5c\u0414\u0410\u3000\u3000\u3000\u3000 |\u3000\u3000\u3000\uff5c\u041c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c\uff5c \u3000 \u3000 |\u0414\u0410 \u3000 \u3000 |\u3000 \u3000 |\n\u3000|\u3000\u3000\u3000\u3000\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\u3000\u3000\u3000\u3000\uffe3\uffe3\uffe3\uffe3\uffe3\uffe3\u3000\u3000\u3000\u3000\uffe3\uffe3\uffe3\uffe3\uffe3\u3000\u3000 |",
    "#include \"lst_timer.h\"\n#include \"../http/http_conn.h\"\n\nsort_timer_lst::sort_timer_lst()\n{\n    head = NULL;\n    tail = NULL;\n}\nsort_timer_lst::~sort_timer_lst()\n{\n    util_timer *tmp = head;\n    while (tmp)\n    {\n        head = tmp->next;\n        delete tmp;\n        tmp = head;\n    }\n}\n\nvoid sort_timer_lst::add_timer(util_timer *timer)\n{\n    if (!timer)\n    {\n        return;\n    }\n    if (!head)\n    {\n        head = tail = timer;\n        return;\n    }\n    if (timer->expire < head->expire)\n    {\n        timer->next = head;\n        head->prev = timer;\n        head = timer;\n        return;\n    }\n    add_timer(timer, head);\n}\nvoid sort_timer_lst::adjust_timer(util_timer *timer)\n{\n    if (!timer)\n    {\n        return;\n    }\n    util_timer *tmp = timer->next;\n    if (!tmp || (timer->expire < tmp->expire))\n    {\n        return;\n    }\n    if (timer == head)\n    {\n        head = head->next;\n        head->prev = NULL;\n        timer->next = NULL;\n        add_timer(timer, head);\n    }\n    else\n    {\n        timer->prev->next = timer->next;\n        timer->next->prev = timer->prev;\n        add_timer(timer, timer->next);\n    }\n}\nvoid sort_timer_lst::del_timer(util_timer *timer)\n{\n    if (!timer)\n    {\n        return;\n    }\n    if ((timer == head) && (timer == tail))\n    {\n        delete timer;\n        head = NULL;\n        tail = NULL;\n        return;\n    }\n    if (timer == head)\n    {\n        head = head->next;\n        head->prev = NULL;\n        delete timer;\n        return;\n    }\n    if (timer == tail)\n    {\n        tail = tail->prev;\n        tail->next = NULL;\n        delete timer;\n        return;\n    }\n    timer->prev->next = timer->next;\n    timer->next->prev = timer->prev;\n    delete timer;\n}\nvoid sort_timer_lst::tick()\n{\n    if (!head)\n    {\n        return;\n    }\n    \n    time_t cur = time(NULL);\n    util_timer *tmp = head;\n    while (tmp)\n    {\n        if (cur < tmp->expire)\n        {\n            break;\n        }\n        tmp->cb_func(tmp->user_data);\n        head = tmp->next;\n        if (head)\n        {\n            head->prev = NULL;\n        }\n        delete tmp;\n        tmp = head;\n    }\n}\n\nvoid sort_timer_lst::add_timer(util_timer *timer, util_timer *lst_head)\n{\n    util_timer *prev = lst_head;\n    util_timer *tmp = prev->next;\n    while (tmp)\n    {\n        if (timer->expire < tmp->expire)\n        {\n            prev->next = timer;\n            timer->next = tmp;\n            tmp->prev = timer;\n            timer->prev = prev;\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n    if (!tmp)\n    {\n        prev->next = timer;\n        timer->prev = prev;\n        timer->next = NULL;\n        tail = timer;\n    }\n}\n\nvoid Utils::init(int timeslot)\n{\n    m_TIMESLOT = timeslot;\n}\n\n//\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u975e\u963b\u585e\nint Utils::setnonblocking(int fd)\n{\n    int old_option = fcntl(fd, F_GETFL);\n    int new_option = old_option | O_NONBLOCK;\n    fcntl(fd, F_SETFL, new_option);\n    return old_option;\n}\n\n//\u5c06\u5185\u6838\u4e8b\u4ef6\u8868\u6ce8\u518c\u8bfb\u4e8b\u4ef6\uff0cET\u6a21\u5f0f\uff0c\u9009\u62e9\u5f00\u542fEPOLLONESHOT\nvoid Utils::addfd(int epollfd, int fd, bool one_shot, int TRIGMode)\n{\n    epoll_event event;\n    event.data.fd = fd;\n\n    if (1 == TRIGMode)\n        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;\n    else\n        event.events = EPOLLIN | EPOLLRDHUP;\n\n    if (one_shot)\n        event.events |= EPOLLONESHOT;\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);\n    setnonblocking(fd);\n}\n\n//\u4fe1\u53f7\u5904\u7406\u51fd\u6570\nvoid Utils::sig_handler(int sig)\n{\n    //\u4e3a\u4fdd\u8bc1\u51fd\u6570\u7684\u53ef\u91cd\u5165\u6027\uff0c\u4fdd\u7559\u539f\u6765\u7684errno\n    int save_errno = errno;\n    int msg = sig;\n    send(u_pipefd[1], (char *)&msg, 1, 0);\n    errno = save_errno;\n}\n\n//\u8bbe\u7f6e\u4fe1\u53f7\u51fd\u6570\nvoid Utils::addsig(int sig, void(handler)(int), bool restart)\n{\n    struct sigaction sa;\n    memset(&sa, '\\0', sizeof(sa));\n    sa.sa_handler = handler;\n    if (restart)\n        sa.sa_flags |= SA_RESTART;\n    sigfillset(&sa.sa_mask);\n    assert(sigaction(sig, &sa, NULL) != -1);\n}\n\n//\u5b9a\u65f6\u5904\u7406\u4efb\u52a1\uff0c\u91cd\u65b0\u5b9a\u65f6\u4ee5\u4e0d\u65ad\u89e6\u53d1SIGALRM\u4fe1\u53f7\nvoid Utils::timer_handler()\n{\n    m_timer_lst.tick();\n    alarm(m_TIMESLOT);\n}\n\nvoid Utils::show_error(int connfd, const char *info)\n{\n    send(connfd, info, strlen(info), 0);\n    close(connfd);\n}\n\nint *Utils::u_pipefd = 0;\nint Utils::u_epollfd = 0;\n\nclass Utils;\nvoid cb_func(client_data *user_data)\n{\n    epoll_ctl(Utils::u_epollfd, EPOLL_CTL_DEL, user_data->sockfd, 0);\n    assert(user_data);\n    close(user_data->sockfd);\n    http_conn::m_user_count--;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool printSumK(int ind , int arr[] , int n, vector<int> & ds ,int k , int currSum){\n\n    // base case\n    if(ind==n){\n\n        if(currSum==k){\n        //print the subsequence\n        for (auto it : ds) {\n            cout<<it<<\" \";\n        }\n\n       \n        cout<<endl;\n        return true;\n        }\n         else return false;\n    }\n\n    // take \n    ds.push_back(arr[ind]);\n    currSum+=arr[ind];\n    if(printSumK(ind+1 , arr, n , ds ,k, currSum)==true) return true;\n    // not take\n    ds.pop_back();  \n    currSum= currSum-arr[ind];\n    if(printSumK(ind+1 , arr, n , ds , k,currSum )==true) return true;\n    return false;\n\n}\n\n\nvoid print(int ind , int arr[] , int n, vector<int> & ds ){\n\n    // base case\n    if(ind==n){\n        //print the subsequence\n        for (auto it : ds) {\n            cout<<it<<\" \";\n        }\n\n        if(ds.size()==0) cout<<\"{}\"<<endl;\n        cout<<endl;\n        return ;\n    }\n\n    // take \n    ds.push_back(arr[ind]);\n    print(ind+1 , arr, n , ds);\n    // not take\n    ds.pop_back();   \n    print(ind+1 , arr, n , ds);\n\n}\nint main(){\n\n    int n ;\n    cout<<\"Enter the size of the array :\"<<endl;\n    cin>>n;\n    int arr[n];\n    for(int i=0;i<n;i++){\n        cout<<\"Enter \"<<i<<\"th elementof the array :\"<<endl;     \n        cin>>arr[i];\n    }\n    vector<int> ds;\n    cout<<\"Printing 1 subsequences having sum equal to k : \"<<endl;\n    print(0,arr,n,ds);\n\n    cout<<\"Enter k (k is the sum that you want  ) :\"<<endl;\n    int k;\n    cin>>k;\n    cout<<\"Printing all the subsequences having sum is eqaul to k : \"<<endl;\n    bool ans=printSumK(0,arr,n,ds,k,0);\n\n    return 0;\n}\n\n/*\n\n\nEnter the size of the array :\n3\nEnter 0th elementof the array :\n1\nEnter 1th elementof the array :\n2\nEnter 2th elementof the array :\n1\nPrinting 1 subsequences having sum equal to k : \n1 2 1 \n1 2 \n1 1 \n1 \n2 1 \n2 \n1\n{}\n\nEnter k (k is the sum that you want  ) :\n2\nPrinting all the subsequences having sum is eqaul to k :\n1 1\n\n\n*/",
    "//HEADER FILES\n#include<iostream>\n#include<bits/stdc++.h>\n#include<fstream>\n#include<cctype>\n#include<iomanip>\n#include<tr1/unordered_map>\n#include<stdio.h>\n#include<ctime>\nusing namespace std;\n\n//CLASS FOR ACCOUNT RECORDS\nclass account\n{\n\tint ac_no;      //account number\n\tchar name[20];  //name of account holder\n\tint balance;    //account balance (in Rs)\n    int min_bal;    //min balance limit\n    int max_bal;    //max balance limit\n    char m_no[20];  //mobile number\n    char pass[20];  //account password\n    tm ac_dt;       //account creation date and time\npublic:\n\tvoid create_account();\t    //function to get data from user\n\tvoid show_account(bool, bool) const;\t//function to show data on screen\n\tvoid modify_account();\t    //function to add new data\n\tvoid deposite(int);\t        //function to accept amount and add to balance amount\n\tvoid withdraw(int);\t        //function to accept amount and subtract from balance amount\n\tvoid show() const;\t        //function to show data in tabular format\n    void show_name() const;     //function to show name of account holder\n\tint get_ac_no() const;\t    //function to return account number\n\tint get_balance() const;\t//function to return balance amount\n    int get_min_bal() const;    //function to return min balance limit\n    int get_max_bal() const;    //function to return max balance limit\n    void set_balance(int);      //function to modify balance amount\n    bool authenticate(char []); //function to match password\n};\n\n//STRUCTURE FOR TRANSACTION\nstruct Transaction\n{\n    int tid;        //transaction ID\n    int from;       //from account number\n    int to;         //to account number\n    int amount;     //amount to be transfered\n};\ntypedef struct Transaction Transaction;\n\nvector<account> Accounts;\nstd::tr1::unordered_map<int,int> ID;\n\n//function declaration\nvoid write_account();\t                            //function to write record for new account\nvoid display_sp(int);\t                            //function to display account details given by user\nvoid modify_account(int);\t                        //function to modify record of existing account\nvoid delete_account(int);\t                        //function to delete record of existing account\nvoid display_all();\t\t                            //function to display all account details\nvoid deposit_withdraw(int, int, int, bool=false);   //function to desposit/withdraw amount for given account \nint ac_exists(int);                                 //function to check if account number already exists\nint get_acno(string);\n\n//ACCOUNT FUNCTIONS DEFINATION\nbool check_acno(string s){\n    for(int i=0; i<s.length(); i++){\n        if(s[i] < '0' || s[i] > '9') return false;\n    }\n    return true;\n}\n\nvoid account::create_account(){\n    string temp_acno;\n    do{\n        cout<<\"Enter Account Number : \";\n\t    cin>>temp_acno;\n        if(temp_acno.size() != 6 || !check_acno(temp_acno) || (get_acno(temp_acno) < 100000)){\n            cout<<\"<--Enter 6-digit Valid Account Number-->\\n\\n\";\n        }\n        else if(ac_exists(get_acno(temp_acno)) != -1){ \n            cout<<\"<--Account Number Already Exists-->\\n\\n\";\n        }\n        else{\n            break;\n        }\n        \n    }while(1);\n    ac_no = get_acno(temp_acno);\n\n    cin.ignore();\n    do{\n        cout<<\"\\nEnter Account Holder\\'s Name : \";\n        cin.getline(name,20);\n\n        int i=0;\n        while(i<20 && name[i] != '\\0'){\n            if(!((name[i]>='a'&&name[i]<='z') || (name[i]>='A'&&name[i]<='Z') || (name[i]==' '))){\n                break;\n            }\n            i++;\n        }\n        if(name[i] == '\\0') break;\n        else cout<<\"<--Please Enter A Valid Name-->\\n\";\n    }while(1);\n \n    do{\n        cout<<\"\\nEnter Mobile Number : \";\n        cin.getline(m_no,20);\n\n        int i=0;\n        while(i<20 && m_no[i] != '\\0'){\n            i++;\n        }\n        if(i == 10){\n            i=0;\n            while(i<20 && m_no[i] != '\\0'){\n                if(!(m_no[i]>='0' && m_no[i]<='9')){\n                    break;\n                }\n                i++;\n            }\n            if(m_no[i] == '\\0') break;\n        }\n        cout<<\"<--Please Enter A Valid Mobile Number-->\\n\";\n    }while(1);\n\n    do{\n        cout<<\"\\nCreate Password : \";\n        cin.getline(pass,20);\n\n        char pass_cpy[20];\n        cout<<\"Enter Password Again : \";\n        cin.getline(pass_cpy,20);\n        if(strcmp(pass, pass_cpy) == 0) break;\n        else cout<<\"<--Passwords Not Matched, Try Again-->\\n\";\n    }while(1);\n\n    cout<<\"\\nEnter Minimum Balance Limit : Rs \";\n\tcin>>min_bal;\n    min_bal = max(min_bal, 0);\n\n    cout<<\"\\nEnter Maximum Balance Limit : Rs \";\n\tcin>>max_bal;\n    max_bal = max(max_bal, min_bal);\n\n    do{\n        cout<<\"\\nEnter Initial Deposite Amount : Rs \";\n\t    cin>>balance;\n        if(balance < min_bal){\n            cout<<\"<--Minimum Balance Limit : Rs \"<<min_bal<<\"-->\\n\";\n        }\n        else if(balance > max_bal){\n            cout<<\"<--Maximum Balance Limit : Rs \"<<max_bal<<\"-->\\n\";\n        }\n    }wh",
    "#include \"simulator.h\"\n#include \"exceptions.h\"\n#include <QMessageBox>\n\nSimulator::Simulator(QObject *parent) :\n    QObject(parent),\n    processor(new Processor()),\n    debugMode(false)\n{\n    // Conecci\u00f3n de se\u00f1ales\n    connect(processor, &Processor::lcdSignalEmitted, this, &Simulator::passLcdValue);\n    connect(processor, &Processor::instSignalEmitted, this, &Simulator::passInstValue);\n}\n\nSimulator::~Simulator() {\n    delete processor;\n}\n\n// Slots para pasar los valores del LCD e instrucci\u00f3n emitidos por el procesador\nvoid Simulator::passLcdValue(QString  value)\n{\n    emit lcdSignalPassed(value);\n}\n\nvoid Simulator::passInstValue(QString opcode, QString operando, QString  accumulator, int programCounter)\n{\n    emit instSignalPassed(opcode, operando, accumulator, programCounter);\n}\n\n\n// Carga el arreglo de instrucciones en el simulador\nvoid Simulator::loadInstructionByteArray(const QByteArray& instructionArray)\n{\n    instructionVector.clear();\n    parseInstructionByteArray(instructionArray);\n}\n\n// Reinicia el procesador\nvoid Simulator::restartProcessor()\n{\n    processor->restartProcessor();\n}\n\n// Ejecuta la simulaci\u00f3n del programa, con opci\u00f3n de modo de depuraci\u00f3n\nint Simulator::runSimulation(bool debugMode)\n{\n    if(debugMode)\n    {\n        simulateStep();\n    }\n    else\n    {\n        simulateCompleteProgram();\n    }\n    return processor->getProgramCounter();\n}\n\nvoid Simulator::simulateStep()\n{\n    int pc = processor->getProgramCounter();\n    if(pc < instructionVector.length())\n        processor->executeInstruction(instructionVector.at(pc));\n}\n\nvoid Simulator::simulateCompleteProgram()\n{\n    processor->restartProcessor();\n\n    int maxIterations = 100;\n    while(processor->getProgramCounter() < instructionVector.length())\n    {\n        int pc = processor->getProgramCounter();\n        processor->executeInstruction(instructionVector.at(pc));\n\n        if(maxIterations-- < 0)\n        {\n            throw FileException(\"El programa tiene un bucle infinito.\");\n        }\n    }\n}\n\n// Analiza el arreglo de bytes de instrucciones y crea las instrucciones correspondientes\nvoid Simulator::parseInstructionByteArray(const QByteArray& instructionArray)\n{\n    instructionVector.clear();\n\n    for(int i = 0; i + 4 <= instructionArray.length(); i += 4)\n    {\n        Instruction instr;\n        instr.opcode = instructionArray[i];\n        instr.operand = Int24(const_cast<char*>(instructionArray.data() + i + 1));\n        instructionVector.append(instr);\n    }\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#ifndef NO_CUDA\n\n#include \"GpuMatAcquisitor.hpp\"\n\n#include <thread>\n\nextern void CUDADeviceSynchronize();\n\nnamespace RoboPioneers::Modules::CameraDriver::Acquisitors\n{\n\t/// \u63a5\u6536\u5230\u56fe\u50cf\u4e8b\u4ef6\n\tvoid GpuMatAcquisitor::ReceivePictureIncomeEvent(AbstractAcquisitor::RawPicture data)\n\t{\n\t\tif (!Working.load())\n\t\t{\n\t\t\tWorking = true;\n\t\t}\n\n\t\t// \u66f4\u65b0\u6700\u65b0\u56fe\u7247\u72b6\u6001\n\t\tif (!IsPictureLatest.load())\n\t\t{\n\t\t\tIsPictureLatest = true;\n\t\t}\n\n\t\tauto&& picture = ConvertRawDataToPicture(data);\n\t\tauto&& gpu_picture = ConvertRawDataToGPUPicture(data, picture);\n\n\t\tstd::unique_lock picture_lock(PictureMutex);\n\t\tPicture = std::move(picture);\n\t\tpicture_lock.unlock();\n\n\t\tstd::unique_lock gpu_picture_lock(GpuPictureMutex);\n\t\tGpuPicture = gpu_picture;\n\t\tgpu_picture_lock.unlock();\n\t}\n\n\t/// \u83b7\u53d6GPU\u56fe\u50cf\n\tcv::cuda::GpuMat GpuMatAcquisitor::GetGpuPicture(bool wait_for_latest) noexcept(false)\n\t{\n\t\tif (!IsWorking())\n\t\t{\n\t\t\tthrow std::runtime_error(\"MatAcquisitor::GetPicture Device Is Offline.\");\n\t\t}\n\n\t\t// \u5982\u679c\u8981\u6c42\u7b49\u5f85\uff0c\u5219\u4f1a\u4e0d\u65ad\u5730\u6838\u9a8c\u56fe\u7247\u662f\u5426\u4e3a\u6700\u65b0\n\t\twhile (wait_for_latest && !IsPictureLatest.load())\n\t\t{\n\t\t\t// \u7b49\u5f85\u65f6\u4ea4\u51fa\u5f53\u524d\u7684\u65f6\u95f4\u7247\uff0c\u5904\u7406\u5668\u4f1a\u5c06\u5206\u914d\u7ed9\u8be5\u7ebf\u7a0b\u8d44\u6e90\u6682\u65f6\u4ea4\u7ed9\u522b\u7684\u53bf\u57ce\n\t\t\tstd::this_thread::yield();\n\t\t}\n\n\t\tstd::shared_lock lock(GpuPictureMutex);\n\t\t// \u82e5\u56fe\u50cf\u4e3a\u7a7a\uff0c\u8bf4\u660e\u8fd9\u662f\u7b2c\u4e00\u6b21\u83b7\u53d6\u56fe\u50cf\uff0c\u9700\u8981\u7b49\u5f85\u7b2c\u4e00\u5f20\u56fe\u50cf\u5230\u8fbe\n\t\twhile (GpuPicture.empty())\n\t\t{\n\t\t\tlock.unlock();\n\t\t\tstd::this_thread::yield();\n\t\t\tlock.lock();\n\t\t}\n\t\tIsPictureLatest = false;\n\t\treturn GpuPicture;\n\t}\n\n\t/// \u5c06\u539f\u59cb\u6570\u636e\u8f6c\u6362\u4e3a\u663e\u5b58\u4e2d\u7684\u56fe\u7247\n\tcv::cuda::GpuMat GpuMatAcquisitor::ConvertRawDataToGPUPicture(\n\t\t\tconst AbstractAcquisitor::RawPicture &data, const cv::Mat &picture)\n\t{\n\t\tcv::cuda::GpuMat gpu_mat(picture);\n\t\tCUDADeviceSynchronize();\n\t\treturn gpu_mat;\n\t}\n}\n\n#endif",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#define OLC_PGE_APPLICATION\n#define _USE_MATH_DEFINES\n\n#include \"olcPixelGameEngine.h\"\n//#include <iostream>\n#include <math.h>\n//#include <string>\n\nusing namespace std;\n\n// Override base class with your custom functionality\nclass Example : public olc::PixelGameEngine\n{\npublic:\n\tExample()\n\t{\n\t\t// Name your application\n\t\tsAppName = \"2D Transformations\";\n\t}\n\nprivate:\n\tint counter = 0, t_count = 0, r_count = 0, s_count = 0, sh_count = 0, rf_count = 0, start = 0;\n\tint x, y, theta = 0, running = 0, translating = 0, rotating = 0, scaling = 0, shearing = 0, reflecting = 0;\n\tolc::vd2d A, B, C, D, t1, t2, t3, t4, center, txt_size;\n\tstring text = \"None\", tl = \"\";\n\npublic:\n\tbool OnUserCreate() override\n\t{\n\t\t// Called once at the start, so create things here\n\t\treturn true;\n\t}\n\n\tbool OnUserUpdate(float fElapsedTime) override\n\t{\n\t\tClear(olc::GREEN);\n\t\t\n\t\tif (GetKey(olc::Key::SPACE).bPressed && !start) {\n\t\t\tcounter = 4;\n\t\t\tstart = 1;\n\n\t\t\tA.x = t1.x = 100;\n\t\t\tA.y = t1.y = 100;\n\n\t\t\tB.x = t2.x = 100;\n\t\t\tB.y = t2.y = 300;\n\n\t\t\tC.x = t3.x = 300;\n\t\t\tC.y = t3.y = 300;\n\n\t\t\tD.x = t4.x = 300;\n\t\t\tD.y = t4.y = 100;\n\t\t}\n\n\t\tif (counter < 4){\n\t\t\tif (GetMouse(0).bPressed) {\n\t\t\t\tx = GetMouseX();\n\t\t\t\ty = GetMouseY();\n\n\t\t\t\tswitch (counter) {\n\t\t\t\tcase 0: A.x = x;\n\t\t\t\t\t\tA.y = y;\n\n\t\t\t\t\t\t// temporary A\n\t\t\t\t\t\tt1.x = x;\n\t\t\t\t\t\tt1.y = y;\n\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: B.x = x;\n\t\t\t\t\t\tB.y = y;\n\n\t\t\t\t\t\t// temporary B\n\t\t\t\t\t\tt2.x = x;\n\t\t\t\t\t\tt2.y = y;\n\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: C.x = x;\n\t\t\t\t\t\tC.y = y;\n\n\t\t\t\t\t\t// temporary C\n\t\t\t\t\t\tt3.x = x;\n\t\t\t\t\t\tt3.y = y;\n\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: D.x = x;\n\t\t\t\t\t\tD.y = y;\n\n\t\t\t\t\t\t// temporary D\n\t\t\t\t\t\tt4.x = x;\n\t\t\t\t\t\tt4.y = y;\n\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// main running block where everything that is to be displayed and updated will happen\n\t\tif (counter == 4) {\n\t\t\tDrawObj();\n\n\t\t\tif (GetKey(olc::Key::T).bPressed && !rotating && !scaling && !shearing && !reflecting) {\n\t\t\t\ttranslating = 1;\n\t\t\t\tt_count++;\n\t\t\t}\n\n\t\t\telse if (GetKey(olc::Key::R).bPressed && !translating && !scaling && !shearing && !reflecting) {\n\t\t\t\trotating = 1;\n\t\t\t\tr_count++;\n\t\t\t}\n\n\t\t\telse if (GetKey(olc::Key::S).bPressed && !rotating && !translating && !shearing && !reflecting) {\n\t\t\t\tscaling = 1;\n\t\t\t\ts_count++;\n\t\t\t}\n\n\t\t\telse if (GetKey(olc::Key::H).bPressed && !rotating && !scaling && !translating && !reflecting) {\n\t\t\t\tshearing = 1;\n\t\t\t\tsh_count++;\n\t\t\t}\n\n\t\t\telse if (GetKey(olc::Key::F).bPressed && !rotating && !scaling && !translating && !shearing) {\n\t\t\t\treflecting = 1;\n\t\t\t\trf_count++;\n\t\t\t}\n\n\t\t\tif (translating) {\n\t\t\t\ttranslate();\n\n\t\t\t\tif (t_count % 2 == 0) {\n\t\t\t\t\ttranslating = 0;\n\t\t\t\t\tt_count = 0;\n\n\t\t\t\t\t// Updating the transformation text\n\t\t\t\t\ttext = \"None\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rotating) {\n\t\t\t\trotate();\n\n\t\t\t\tif (r_count % 2 == 0) {\n\t\t\t\t\trotating = 0;\n\t\t\t\t\tr_count = 0;\n\n\t\t\t\t\t// Updating the transformation text\n\t\t\t\t\ttext = \"None\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (scaling) {\n\t\t\t\tscale();\n\n\t\t\t\tif (s_count % 2 == 0) {\n\t\t\t\t\tscaling = 0;\n\t\t\t\t\ts_count = 0;\n\n\t\t\t\t\t// Updating the transformation text\n\t\t\t\t\ttext = \"None\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shearing) {\n\t\t\t\tshear();\n\n\t\t\t\tif (sh_count % 2 == 0) {\n\t\t\t\t\tshearing = 0;\n\t\t\t\t\tsh_count = 0;\n\n\t\t\t\t\t// Updating the transformation text\n\t\t\t\t\ttext = \"None\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (reflecting) {\n\t\t\t\treflect();\n\n\t\t\t\tif (rf_count % 2 == 0) {\n\t\t\t\t\treflecting = 0;\n\t\t\t\t\trf_count = 0;\n\n\t\t\t\t\t// Updating the transformation text\n\t\t\t\t\ttext = \"None\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// function to reset the object and variables\n\t\tif (GetKey(olc::Key::NP0).bPressed) {\n\t\t\tA.x = t1.x;\n\t\t\tA.y = t1.y;\n\n\t\t\tB.x = t2.x;\n\t\t\tB.y = t2.y;\n\n\t\t\tC.x = t3.x;\n\t\t\tC.y = t3.y;\n\n\t\t\tD.x = t4.x;\n\t\t\tD.y = t4.y;\n\n\t\t\ttheta = 0;\n\t\t\ttranslating = 0, rotating = 0, scaling = 0, shearing = 0, reflecting = 0;\n\t\t\tt_count = 0, r_count = 0, s_count = 0, sh_count = 0, rf_count = 0;\n\n\t\t\ttext = \"None\";\n\t\t}\n\n\t\t// get the angle of point A anytime by pressing CAPS_LOCK\n\t\tif (GetKey(olc::Key::CAPS_LOCK).bPressed) {\n\t\t\tfindAngle();\n\t\t}\n\n\t\tif (GetKey(olc::Key::M).bPressed) {\n\t\t\ttranslate(center.x, center.y);\n\t\t}\n\n\n\t\t// Displaying the current transformation's name on the top of the screen\n\t\ttxt_size = GetTextSize(text);\n\t\tDrawString(ScreenWidth() / 2 - txt_size.x / 2, 20, text, olc::BLACK);\n\n\t\treturn true;\n\t}\n\n\tvoid DrawObj() {\n\t\tstring t1, t2, res;\n\t\tolc::vi2d t_size;\n\n\t\tDrawLine(A, B, olc::BLACK);\n\t\tDrawLine(B, C, olc::BLACK);\n\t\tDrawLine(C, D, olc::BLACK);\n\t\tDrawLine(D, A, olc::BLACK);\n\n\t\t// calculating the object's center\n\t\tcenter.x = (A.x + B.x + C.x + D.x) / 4;\n\t\tcenter.y = (A.y + B.y + C.y + D.y) / 4;\n\n\t\t// drawing center point of the object\n\t\tFillCircle(center, 1, olc::RED);\n\n\t\t// drawiing the coordinates for A\n\t\tt1 = to_string(int(A.x));\n\t\tt2 = to_string(int(A.y));\n\t\tres = t1 + \",\" + t2;\n\n\t\tt_size = GetTextSize(res);\n\t\tDrawString(A.x - t_size.x / 2, A.y, res, olc::BLACK);\n\n\t\t// drawiing the coordinates for B\n\t\tt1 = to_string(int(B.x));\n\t\tt2 = to_string(int(B.y));\n\t\tres = t1 + \",\" + t2;\n\n\t\tt_size = GetTextSize(res);\n\t\tDrawString(B.x - t_size.x / 2, B.y, re",
    "#if (ARDUINO >= 100)\n  #include \"Arduino.h\"\n#else\n  #if defined(__AVR__)\n    #include <avr/io.h>\n  #endif\n  #include \"WProgram.h\"\n#endif\n\n#include \"AFMotor.h\"\n\n\n\nstatic uint8_t latch_state;\n\n#if (MICROSTEPS == 8)\nuint8_t microstepcurve[] = {0, 50, 98, 142, 180, 212, 236, 250, 255};\n#elif (MICROSTEPS == 16)\nuint8_t microstepcurve[] = {0, 25, 50, 74, 98, 120, 141, 162, 180, 197, 212, 225, 236, 244, 250, 253, 255};\n#endif\n\nAFMotorController::AFMotorController(void) {\n    TimerInitalized = false;\n}\n\nvoid AFMotorController::enable(void) {\n  // setup the latch\n  /*\n  LATCH_DDR |= _BV(LATCH);\n  ENABLE_DDR |= _BV(ENABLE);\n  CLK_DDR |= _BV(CLK);\n  SER_DDR |= _BV(SER);\n  */\n  pinMode(MOTORLATCH, OUTPUT);\n  pinMode(MOTORENABLE, OUTPUT);\n  pinMode(MOTORDATA, OUTPUT);\n  pinMode(MOTORCLK, OUTPUT);\n\n  latch_state = 0;\n\n  latch_tx();  // \"reset\"\n\n  //ENABLE_PORT &= ~_BV(ENABLE); // enable the chip outputs!\n  digitalWrite(MOTORENABLE, LOW);\n}\n\n\nvoid AFMotorController::latch_tx(void) {\n  uint8_t i;\n\n  //LATCH_PORT &= ~_BV(LATCH);\n  digitalWrite(MOTORLATCH, LOW);\n\n  //SER_PORT &= ~_BV(SER);\n  digitalWrite(MOTORDATA, LOW);\n\n  for (i=0; i<8; i++) {\n    //CLK_PORT &= ~_BV(CLK);\n    digitalWrite(MOTORCLK, LOW);\n\n    if (latch_state & _BV(7-i)) {\n      //SER_PORT |= _BV(SER);\n      digitalWrite(MOTORDATA, HIGH);\n    } else {\n      //SER_PORT &= ~_BV(SER);\n      digitalWrite(MOTORDATA, LOW);\n    }\n    //CLK_PORT |= _BV(CLK);\n    digitalWrite(MOTORCLK, HIGH);\n  }\n  //LATCH_PORT |= _BV(LATCH);\n  digitalWrite(MOTORLATCH, HIGH);\n}\n\nstatic AFMotorController MC;\n\n/******************************************\n               MOTORS\n******************************************/\ninline void initPWM1(uint8_t freq) {\n#if defined(__AVR_ATmega8__) || \\\n    defined(__AVR_ATmega48__) || \\\n    defined(__AVR_ATmega88__) || \\\n    defined(__AVR_ATmega168__) || \\\n    defined(__AVR_ATmega328P__)\n    // use PWM from timer2A on PB3 (Arduino pin #11)\n    TCCR2A |= _BV(COM2A1) | _BV(WGM20) | _BV(WGM21); // fast PWM, turn on oc2a\n    TCCR2B = freq & 0x7;\n    OCR2A = 0;\n#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n    // on arduino mega, pin 11 is now PB5 (OC1A)\n    TCCR1A |= _BV(COM1A1) | _BV(WGM10); // fast PWM, turn on oc1a\n    TCCR1B = (freq & 0x7) | _BV(WGM12);\n    OCR1A = 0;\n#elif defined(__PIC32MX__)\n    #if defined(PIC32_USE_PIN9_FOR_M1_PWM)\n        // Make sure that pin 11 is an input, since we have tied together 9 and 11\n        pinMode(9, OUTPUT);\n        pinMode(11, INPUT);\n        if (!MC.TimerInitalized)\n        {   // Set up Timer2 for 80MHz counting fro 0 to 256\n            T2CON = 0x8000 | ((freq & 0x07) << 4); // ON=1, FRZ=0, SIDL=0, TGATE=0, TCKPS=<freq>, T32=0, TCS=0; // ON=1, FRZ=0, SIDL=0, TGATE=0, TCKPS=0, T32=0, TCS=0\n            TMR2 = 0x0000;\n            PR2 = 0x0100;\n            MC.TimerInitalized = true;\n        }\n         // Setup OC4 (pin 9) in PWM mode, with Timer2 as timebase\n        OC4CON = 0x8006;    // OC32 = 0, OCTSEL=0, OCM=6\n        OC4RS = 0x0000;\n        OC4R = 0x0000;\n    #elif defined(PIC32_USE_PIN10_FOR_M1_PWM)\n        // Make sure that pin 11 is an input, since we have tied together 9 and 11\n        pinMode(10, OUTPUT);\n        pinMode(11, INPUT);\n        if (!MC.TimerInitalized)\n        {   // Set up Timer2 for 80MHz counting fro 0 to 256\n            T2CON = 0x8000 | ((freq & 0x07) << 4); // ON=1, FRZ=0, SIDL=0, TGATE=0, TCKPS=<freq>, T32=0, TCS=0; // ON=1, FRZ=0, SIDL=0, TGATE=0, TCKPS=0, T32=0, TCS=0\n            TMR2 = 0x0000;\n            PR2 = 0x0100;\n            MC.TimerInitalized = true;\n        }\n         // Setup OC5 (pin 10) in PWM mode, with Timer2 as timebase\n        OC5CON = 0x8006;    // OC32 = 0, OCTSEL=0, OCM=6\n        OC5RS = 0x0000;\n        OC5R = 0x0000;\n    #else\n        // If we are not using PWM for pin 11, then just do digital\n        digitalWrite(11, LOW);\n    #endif\n#else\n   #error \"This chip is not supported!\"\n#endif\n    #if !defined(PIC32_USE_PIN9_FOR_M1_PWM) && !defined(PIC32_USE_PIN10_FOR_M1_PWM)\n        pinMode(11, OUTPUT);\n    #endif\n}\n\ninline void setPWM1(uint8_t s) {\n#if defined(__AVR_ATmega8__) || \\\n    defined(__AVR_ATmega48__) || \\\n    defined(__AVR_ATmega88__) || \\\n    defined(__AVR_ATmega168__) || \\\n    defined(__AVR_ATmega328P__)\n    // use PWM from timer2A on PB3 (Arduino pin #11)\n    OCR2A = s;\n#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)\n    // on arduino mega, pin 11 is now PB5 (OC1A)\n    OCR1A = s;\n#elif defined(__PIC32MX__)\n    #if defined(PIC32_USE_PIN9_FOR_M1_PWM)\n        // Set the OC4 (pin 9) PMW duty cycle from 0 to 255\n        OC4RS = s;\n    #elif defined(PIC32_USE_PIN10_FOR_M1_PWM)\n        // Set the OC5 (pin 10) PMW duty cycle from 0 to 255\n        OC5RS = s;\n    #else\n        // If we are not doing PWM output for M1, then just use on/off\n        if (s > 127)\n        {\n            digitalWrite(11, HIGH);\n        }\n        else\n        {\n            digitalWrite(11, LOW);\n        }\n    #endif\n#else\n   #error \"This chip is not sup",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Pawns/D_Turret.h\"\n\nAD_Turret::AD_Turret()\n{\n\tTowerMeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"TowerMeshComponent\"));\n\tTowerMeshComponent->SetupAttachment(MeshComponent);\n\n\tProjectileBasePosition->SetupAttachment(TowerMeshComponent);\n\n\tHealth = 250.0f;\n}\n\nvoid AD_Turret::BeginPlay()\n{\n\tSuper::BeginPlay();\t\n}\n\nfloat AD_Turret::TakeDamage(float DamageAmount, FDamageEvent const& DamageEvent, AController* EventInstigator,\n\tAActor* DamageCauser)\n{\n\tSuper::TakeDamage(DamageAmount, DamageEvent, EventInstigator, DamageCauser);\n\n\tHealth -= DamageAmount;\n\n\tif (Health > 0)\n\t\treturn DamageAmount;\n\n\tDestroy();\n\n\treturn DamageAmount;\n}\n\nFVector AD_Turret::GetTowerLocation() const\n{\t\n\tFVector ComponentLocation = TowerMeshComponent->GetComponentLocation();\n\tComponentLocation.Z += 60.0f;\n\n\treturn ComponentLocation;\n}\n\nFRotator AD_Turret::GetTowerRotation() const\n{\n\treturn TowerMeshComponent->GetComponentRotation();\n}\n\nvoid AD_Turret::Rotate()\n{\n\tFRotator TowerRotation = TowerMeshComponent->GetRelativeRotation();\n\n\tFRotator Rotation = GetControlRotation() - GetActorRotation();\n\n\tfloat YawDelta = Rotation.Yaw - TowerRotation.Roll;\n\tfloat PitchDelta = Rotation.Pitch - TowerRotation.Roll;\n\n\tFRotator NewTowerRotation = FRotator(PitchDelta, YawDelta, 0);\n\n\tTowerMeshComponent->SetRelativeRotation(FMath::Lerp(TowerRotation, NewTowerRotation, 0.1));\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Created by shawn on 24-3-5.\n//\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int key, value;\n    Node *prev, *next;\n\n    Node(int k = 0, int v = 0) : key(k), value(v) {}\n};\n\nclass LRUCache {\n\nprivate:\n    int capacity;\n    Node *dummy;\n    unordered_map<int, Node *> key_to_node;\n\n    void remove(Node *x) {\n        x->prev->next = x->next;\n        x->next->prev = x->prev;\n    }\n\n    void push_front(Node *x) {\n        x->prev = dummy;\n        x->next = dummy->next;\n        x->prev->next = x;\n        x->next->prev = x;\n    }\n\n    Node *get_node(int key) {\n        auto it = key_to_node.find(key);\n        if (it == key_to_node.end())\n            return nullptr;\n        auto node = it->second;\n        remove(node);\n        push_front(node);\n        return node;\n    }\n\npublic:\n    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {\n        dummy->prev = dummy;\n        dummy->next = dummy;\n    }\n\n    int get(int key) {\n        auto node = get_node(key);\n        return node ? node->value : -1;\n    }\n\n    void put(int key, int value) {\n        auto node = get_node(key);\n        if (node) {\n            node->value = value;\n            return;\n        }\n        key_to_node[key] = node = new Node(key, value);\n        push_front(node);\n        if (key_to_node.size() > capacity) {\n            auto back_node = dummy->prev;\n            key_to_node.erase(back_node->key);\n            remove(back_node);\n            delete back_node;\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\nint main() {\n    LRUCache *obj = new LRUCache(2);\n    int result;\n    // \u7f13\u5b58\u662f {1=1}\n    obj->put(1, 1);\n    // \u7f13\u5b58\u662f {1=1, 2=2}\n    obj->put(2, 2);\n    // \u8fd4\u56de 1\n    result = obj->get(1);\n    cout << \"result: \" << result << endl;\n    // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5173\u952e\u5b57 2 \u4f5c\u5e9f\uff0c\u7f13\u5b58\u662f {1=1, 3=3}\n    obj->put(3, 3);\n    // \u8fd4\u56de -1 (\u672a\u627e\u5230)\n    result = obj->get(2);\n    cout << \"result: \" << result << endl;\n\n    // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5173\u952e\u5b57 1 \u4f5c\u5e9f\uff0c\u7f13\u5b58\u662f {4=4, 3=3}\n    obj->put(4, 4);\n    // \u8fd4\u56de -1 (\u672a\u627e\u5230)\n    result = obj->get(1);\n    cout << \"result: \" << result << endl;\n\n    // \u8fd4\u56de 3\n    result = obj->get(3);\n    cout << \"result: \" << result << endl;\n\n    // \u8fd4\u56de 4\n    result = obj->get(4);\n    cout << \"result: \" << result << endl;\n}",
    "// Adrian Cortez\n// This program creates a game of tic tac toe by utilizing decision structures, loops, arrays, functions, and more\n\n#include <iostream>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// prints the tic tac toe grid\nvoid printGrid (char grid[4][4]) {\n    // print grid\n    for (int row = 1; row < 4; ++row) {\n        cout << \"+---+---+---+ \\n\";\n        for (int col = 1; col < 4; ++col){\n            cout << \"| \" << grid[row][col] << \" \";\n        }\n        cout << \"|\\n\";\n    }\n    cout << \"+---+---+---+\\n\\n\";\n}\n\n// validates data input from user\nvoid dataValidation (int col, int row)\n{\n    // data validation\n    while (col < 1 || col > 3 || row < 1 || row > 3) { // data validation\n        cout << \"Error. That is not a valid row/column. Pick a row (1, 2, 3): \";\n        cin >> row;\n        \n        cout << \"Pick a column (1, 2, 3): \";\n        cin >> col;\n        cout << endl;\n    }\n}\n\n// checks if the spot the user takes is already taken\nbool occupiedCheck (char grid[4][4], int col, int row)\n{\n    bool isOccupied;\n    // determine if chosen pick is occupied\n    if (grid[row][col] == 'X' || grid[row][col] == 'O'){\n        isOccupied = true;\n    }\n    else {\n        isOccupied = false;\n    }\n    return isOccupied;\n}\n\n// determines if there is a winner, or if it is a tie\nbool checkWin (char grid[4][4], char players[9], int index)\n{\n    bool gameEnd = false;\n    \n    // determine if there is a winner\n    for (int i = 0; i < 2; i++) {\n        // check rows and columns\n        for (int x = 1; x < 4; x++) {\n            if ((grid[x][1] == players[i] && grid[x][2] == players[i] && grid[x][3] == players[i]) || (grid[1][x] == players[i] && grid[2][x] == players[i] && grid[3][x] == players[i])) {\n                cout << \"Player \" << players[i] << \" has won the game! Congratulations! Game over.\" << endl;\n                gameEnd = true;\n            }\n        }\n        // check diagonals\n        if ((grid[1][1] == players[i] && grid[2][2] == players[i] && grid[3][3] == players[i]) || (grid[3][1] == players[i] && grid[2][2] == players[i] && grid[1][3] == players[i])) {\n               cout << \"Player \" << players[i] << \" has won the game! Congratulations! Game over.\" << endl;\n            gameEnd = true;\n        }\n    }\n    // determine if it is a tie\n    if (index == 9 && gameEnd != true) {\n        cout << \"The game is a tie. No one wins. Game over :(\" << endl;\n        gameEnd = true;\n    }\n    \n    return gameEnd;\n}\n\n// main method\nint main ()\n{\n    // declare variables\n    char grid[4][4] = {{' ', ' ', ' ', ' '}, {' ', ' ', ' ', ' '}, {' ', ' ', ' ', ' '}, {' ', ' ', ' ', ' '}}; // 2d array\n    bool gameOver = false; // used to end game\n    int col = 0;\n    int row = 0;\n    char players[9] = {'X','O','X','O','X','O','X','O','X'}; // used to switch between players\n    int index = 0; // used with players array to switch between players\n    \n    \n    cout << \"Welcome to Tic Tac Toe\" << endl;\n    \n    printGrid(grid);\n    \n    // begin loop\n    while (gameOver != true) {\n        \n        // prompt user to input row and column\n        cout << players[index] << \"'s turn\" << endl << \"Pick a row (1, 2, 3): \";\n        cin >> row;\n        cout << \"Pick a column (1, 2, 3): \";\n        cin >> col;\n        \n        // data validation\n        dataValidation(col, row);\n        \n        // determine if chosen pick is occupied\n        bool isOccupied = occupiedCheck(grid, col, row);\n        \n      // show error message if spot is occupied\n        while (isOccupied != false){\n            cout << endl << \"ERROR: That spot is occupied. \" << players[index] << \"'s turn again.\" << endl << \" Pick a row (1, 2, 3): \";\n            cin >> row;\n            \n            cout << \"Pick a column (1, 2, 3): \";\n            cin >> col;\n            \n            // data validation\n            dataValidation(col, row);\n            // check if it is occupied (again)\n            isOccupied = occupiedCheck(grid, col, row);\n        }\n        \n        // place character in chosen spot,\n        grid[row][col] = players[index];\n        \n        // print table with character in spot\n        printGrid(grid);\n        \n        // increase index for next player's turn on the list\n        index++;\n        \n        // check if there is a winner\n        gameOver = checkWin(grid, players, index);\n    }\n    \n    // end program\n    cout << endl << \"Bye!\" << endl;\n        return 0;\n}\n    \n\n\n",
    "\ufeff#include <iostream> \n\n#include <cmath> \n\n\n\nusing namespace std;\n\n\n\nint main() {\n\n    int n; // \u041a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \u043c\u0430\u0441\u0438\u0432\u0443 \n\n    double a[100]; // \u041c\u0430\u0441\u0438\u0432 \u0434\u0456\u0439\u0441\u043d\u0438\u0445 \u0447\u0438\u0441\u0435\u043b \n\n    double min_abs = 1e9; // \u041c\u0456\u043d\u0456\u043c\u0430\u043b\u044c\u043d\u0438\u0439 \u0437\u0430 \u043c\u043e\u0434\u0443\u043b\u0435\u043c \u0435\u043b\u0435\u043c\u0435\u043d\u0442 \n\n    double sum_after_zero = 0; // \u0421\u0443\u043c\u0430 \u043c\u043e\u0434\u0443\u043b\u0456\u0432 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \u043f\u0456\u0441\u043b\u044f \u043f\u0435\u0440\u0448\u043e\u0433\u043e \u043d\u0443\u043b\u044f \n\n    int min_index, max_index; // \u0406\u043d\u0434\u0435\u043a\u0441\u0438 \u043c\u0456\u043d\u0456\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0456 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \n\n\n\n    cout << \"\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \u043c\u0430\u0441\u0438\u0432\u0443: \";\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n\n        cout << \"\u0412\u0432\u0435\u0434\u0456\u0442\u044c \" << i + 1 << \"-\u0439 \u0435\u043b\u0435\u043c\u0435\u043d\u0442: \";\n\n        cin >> a[i];\n\n    }\n\n\n\n    for (int i = 0; i < n; i++) {\n\n        if (abs(a[i]) < min_abs) {\n\n            min_abs = abs(a[i]);\n\n        }\n\n    }\n\n\n\n    bool found_zero = false;\n\n    for (int i = 0; i < n; i++) {\n\n        if (a[i] == 0) {\n\n            found_zero = true;\n\n        }\n\n        if (found_zero) {\n\n            sum_after_zero += abs(a[i]);\n\n        }\n\n    }\n\n\n\n    min_index = 0;\n\n    max_index = 0;\n\n    for (int i = 1; i < n; i++) {\n\n        if (a[i] < a[min_index]) {\n\n            min_index = i;\n\n        }\n\n        if (a[i] > a[max_index]) {\n\n            max_index = i;\n\n        }\n\n    }\n\n\n\n    double sum = 0;\n\n    for (int i = min_index; i <= max_index; i++) {\n\n        sum += a[i];\n\n    }\n\n    double avg = sum / (max_index - min_index + 1);\n\n\n\n    cout << \"\u041c\u0456\u043d\u0456\u043c\u0430\u043b\u044c\u043d\u0438\u0439 \u0437\u0430 \u043c\u043e\u0434\u0443\u043b\u0435\u043c \u0435\u043b\u0435\u043c\u0435\u043d\u0442: \" << min_abs << endl;\n\n    cout << \"\u0421\u0443\u043c\u0430 \u043c\u043e\u0434\u0443\u043b\u0456\u0432 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \u043f\u0456\u0441\u043b\u044f \u043f\u0435\u0440\u0448\u043e\u0433\u043e \u043d\u0443\u043b\u044f: \" << sum_after_zero << endl;\n\n    cout << \"\u0421\u0435\u0440\u0435\u0434\u043d\u0454 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u043d\u0435 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \u043c\u0456\u0436 \" << min_index + 1 << \" \u0442\u0430 \" << max_index + 1 << \" \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\u0438: \" << avg << endl;\n\n\n\n    return 0;\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yes_no_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"atividade_pratica_introducao_2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'deposit_calc.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.2.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../my_calc/deposit_calc.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'deposit_calc.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.2.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_Deposit_calc_t {\n    const uint offsetsAndSize[12];\n    char stringdata0[135];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(offsetof(qt_meta_stringdata_Deposit_calc_t, stringdata0) + ofs), len \nstatic const qt_meta_stringdata_Deposit_calc_t qt_meta_stringdata_Deposit_calc = {\n    {\nQT_MOC_LITERAL(0, 12), // \"Deposit_calc\"\nQT_MOC_LITERAL(13, 30), // \"on_pushButton_calc_dep_clicked\"\nQT_MOC_LITERAL(44, 0), // \"\"\nQT_MOC_LITERAL(45, 25), // \"on_pushButton_add_clicked\"\nQT_MOC_LITERAL(71, 31), // \"on_pushButton_clear_dep_clicked\"\nQT_MOC_LITERAL(103, 31) // \"on_pushButton_close_dep_clicked\"\n\n    },\n    \"Deposit_calc\\0on_pushButton_calc_dep_clicked\\0\"\n    \"\\0on_pushButton_add_clicked\\0\"\n    \"on_pushButton_clear_dep_clicked\\0\"\n    \"on_pushButton_close_dep_clicked\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_Deposit_calc[] = {\n\n // content:\n      10,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       4,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   38,    2, 0x08,    1 /* Private */,\n       3,    0,   39,    2, 0x08,    2 /* Private */,\n       4,    0,   40,    2, 0x08,    3 /* Private */,\n       5,    0,   41,    2, 0x08,    4 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid Deposit_calc::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<Deposit_calc *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_pushButton_calc_dep_clicked(); break;\n        case 1: _t->on_pushButton_add_clicked(); break;\n        case 2: _t->on_pushButton_clear_dep_clicked(); break;\n        case 3: _t->on_pushButton_close_dep_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject Deposit_calc::staticMetaObject = { {\n    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),\n    qt_meta_stringdata_Deposit_calc.offsetsAndSize,\n    qt_meta_data_Deposit_calc,\n    qt_static_metacall,\n    nullptr,\nqt_incomplete_metaTypeArray<qt_meta_stringdata_Deposit_calc_t\n, QtPrivate::TypeAndForceComplete<Deposit_calc, std::true_type>\n, QtPrivate::TypeAndForceComplete<void, std::false_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>\n\n\n>,\n    nullptr\n} };\n\n\nconst QMetaObject *Deposit_calc::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *Deposit_calc::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_Deposit_calc.stringdata0))\n        return static_cast<void*>(this);\n    return QDialog::qt_metacast(_clname);\n}\n\nint Deposit_calc::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QDialog::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 4)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 4;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 4)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 4;\n    }\n    return _id;\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint x[100]; //this array will store 0, 1, up to m-1 and 0,1, up to n-1 respectively, so as to be able to form all the tuples\r\nint x2[100][2]; // this matrix will store all the tuples that can form a solution(subgroup)\r\nint n2, p2;\r\nint c = 0;\r\n\r\nbool OK(int k) {\r\n    for (int i = 1; i < k; ++i)\r\n        if (x[k] <= x[i]) // a solution should countain tuples that do not repeat, and the x coordinate and y coordinate are stored in an inccreasing order\r\n            return false;\r\n    return true;\r\n}\r\n\r\nbool Solutie(int k, int n)\r\n{\r\n    return k == n; // we check if the solution has the requested number of elements(p2) (the number goes from 1 to the total number of possible elements in a tuple (m*n))\r\n}\r\n\r\n// the basic backtracking algorithm for generating permutations\r\n// it returns a new line in the output when the solution is complete\r\nchar back(int k, int n) {\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        x[k] = i;\r\n        if (OK(k))\r\n            if (Solutie(k, n))\r\n                return '\\0';\r\n            else\r\n                return back(k + 1, n);\r\n    }\r\n}\r\n////\r\nbool search(int x_coord, int y_coord, int k) {\r\n    // searches a tuple in the subgroup\r\n    for (int i2 = 1; i2 <= k; ++i2)\r\n        if ((x2[i2][0] == x_coord) && (x2[i2][1] == y_coord))\r\n            return true;\r\n    return false;\r\n}\r\nbool condition(int k, int m, int n) {\r\n    // this function checks the stability of the + in the subgroup, i.e, every element added with any element with respect to the module class should be in the subgropu\r\n    // assume by contr that the subgroup is closed w r t the addition in Zm and Zn and if we find 2 elemeents which go out of the subgroup, we return false\r\n    for (int i = 1; i <= k; ++i)\r\n        for (int j = 1; j <= k; ++j) {\r\n            if (!search((x2[i][0] + x2[j][0]) % m, (x2[i][1] + x2[j][1]) % n, k))\r\n                return false;\r\n        }\r\n    return true;\r\n}\r\n\r\nvoid Afis(int k, int m, int n) {\r\n    // printing the solution\r\n    if (condition(k, m, n) && x2[0][0] == 0 && x2[0][1] == 0) {\r\n        for (int i = 1; i <= k; ++i)\r\n            cout << \"(\" << x2[i][0] << \", \" << x2[i][1] << \") \";\r\n        cout << endl;\r\n        c++;\r\n    }\r\n}\r\n\r\n/*\r\n - this function recursively generates and checks all possible subgroups of tuples\r\n of length p2 from the matrix. It starts from startIndex in the matrix to avoid duplicates and unnecessary computations.\r\n - here, k is the curent position in the subgroup being constructed.\r\n */\r\nvoid back2(int k, const vector<vector<int>>& matrix, int startIndex, int m, int n) {\r\n    if (k == p2 + 1) {\r\n        // check if the subgroup has the requested length( at every step)\r\n        Afis(p2, m, n);\r\n        return;\r\n    }\r\n\r\n    for (int i = startIndex; i <= n2 - p2 + k; ++i) {\r\n        //choose the next tuple and call back2 recurisevely to continue forming the subgroup\r\n        x2[k][0] = matrix[i - 1][0];\r\n        x2[k][1] = matrix[i - 1][1];\r\n        back2(k + 1, matrix, i + 1, m, n);\r\n    }\r\n}\r\n\r\nint main() {\r\n    int n, m, p;\r\n    cin >> m >> n;\r\n    // defining a vector type matrix so as to be able to work with tuples more easily and print them as tuples (a,b)\r\n    vector<vector<int>> matrix(m * n, vector<int>(2));\r\n\r\n    // generate the Zm and Zn classes\r\n    cout << back(1, n) << endl;\r\n    cout << back(1, m) << endl;\r\n    p = 0;\r\n    for (int i = 1; i <= m; i++)\r\n        for (int j = 1; j <= n; j++)\r\n            if (p < m * n) {\r\n                // store the tuples in the matrix \r\n                matrix[p][0] = x[i];\r\n                matrix[p][1] = x[j];\r\n                p++;\r\n            }\r\n\r\n    n2 = m * n;\r\n    //check for all the subgroups of length 1, 2, up to length m*n, using the backtracking algorithm\r\n    for (int i = 1; i <= m * n; i++) {\r\n        p2 = i;\r\n        back2(1, matrix, 1, m, n);\r\n    }\r\n    cout << endl;\r\n    // print how many subgroups we have\r\n    cout << c;\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\r\n#include<fstream>\r\n#include<cctype>\r\n#include<iomanip>\r\nusing namespace std;\r\n\r\n\r\n\r\nclass account\r\n{\r\n\tint acno;\r\n\tchar name[50];\r\n\tint deposit;\r\n\tchar type;\r\npublic:\r\n\tvoid create_account();\r\n\tvoid show_account() const;\r\n\tvoid modify();\r\n\tvoid dep(int);\r\n\tvoid draw(int);\r\n\tvoid report() const;\r\n\tint retacno() const;\r\n\tint retdeposit() const;\r\n\tchar rettype() const;\r\n};\r\n\r\nvoid account::create_account()\r\n{\r\n\tsystem(\"CLS\");\r\n\tcout<<\"\\n\\t\\t\\tEnter the Account No. : \";\r\n\tcin>>acno;\r\n\tcout<<\"\\n\\n\\t\\t\\tEnter the Name of the Account holder : \";\r\n\tcin.ignore();\r\n\tcin.getline(name,50);\r\n\tcout<<\"\\n\\t\\t\\tEnter Type of the Account (C/S) : \";\r\n\tcin>>type;\r\n\ttype=toupper(type);\r\n\tcout<<\"\\n\\t\\t\\tEnter The Initial amount : \";\r\n\tcin>>deposit;\r\n\tcout<<\"\\n\\n\\t\\t\\tAccount Created..\";\r\n}\r\n\r\nvoid account::show_account() const\r\n{\r\n\tcout<<\"\\n\\t\\t\\tAccount No. : \"<<acno;\r\n\tcout<<\"\\n\\t\\t\\tAccount Holder Name : \";\r\n\tcout<<name;\r\n\tcout<<\"\\n\\t\\t\\tType of Account : \"<<type;\r\n\tcout<<\"\\n\\t\\t\\tBalance amount : \"<<deposit;\r\n}\r\n\r\n\r\nvoid account::modify()\r\n{\r\n\tcout<<\"\\n\\t\\t\\tAccount No. : \"<<acno;\r\n\tcout<<\"\\n\\t\\t\\tModify Account Holder Name : \";\r\n\tcin.ignore();\r\n\tcin.getline(name,50);\r\n\tcout<<\"\\n\\t\\t\\tModify Type of Account : \";\r\n\tcin>>type;\r\n\ttype=toupper(type);\r\n\tcout<<\"\\n\\t\\t\\tModify Balance amount : \";\r\n\tcin>>deposit;\r\n}\r\n\r\n\r\nvoid account::dep(int x)\r\n{\r\n\tdeposit+=x;\r\n}\r\n\r\nvoid account::draw(int x)\r\n{\r\n\tdeposit-=x;\r\n}\r\n\r\nvoid account::report() const\r\n{\r\n\tcout<<acno<<setw(10)<<\" \"<<name<<setw(10)<<\" \"<<type<<setw(6)<<deposit<<endl;\r\n}\r\n\r\nint account::retacno() const\r\n{\r\n\treturn acno;\r\n}\r\n\r\nint account::retdeposit() const\r\n{\r\n\treturn deposit;\r\n}\r\n\r\nchar account::rettype() const\r\n{\r\n\treturn type;\r\n}\r\n\r\n\r\n\r\nvoid write_account();\r\nvoid display_sp(int);\r\nvoid modify_account(int);\r\nvoid delete_account(int);\r\nvoid display_all();\r\nvoid deposit_withdraw(int, int);\r\n\r\nint main()\r\n{\r\n\tchar ch;\r\n\tint num;\r\n\tdo\r\n\t{\r\n\tsystem(\"CLS\");\r\n\tcout<<\"\\n\\n\\t\\t\\t\\t======================\\n\";\r\n\tcout<<\"\\t\\t\\t\\tBANK MANAGEMENT SYSTEM\";\r\n\tcout<<\"\\n\\t\\t\\t\\t======================\\n\";\r\n\r\n\t\tcout<<\"\\t\\t\\t\\t    ::MAIN MENU::\\n\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t1. NEW ACCOUNT\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t2. DEPOSIT AMOUNT\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t3. WITHDRAW AMOUNT\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t4. BALANCE ENQUIRY\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t5. ALL ACCOUNT HOLDER LIST\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t6. CLOSE AN ACCOUNT\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t7. MODIFY AN ACCOUNT\";\r\n\t\tcout<<\"\\n\\t\\t\\t\\t8. EXIT\";\r\n\t\tcout<<\"\\n\\n\\t\\t\\t\\tSelect Your Option (1-8): \";\r\n\t\tcin>>ch;\r\n\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\tcase '1':\r\n\t\t\twrite_account();\r\n\t\t\tbreak;\r\n\t\tcase '2':\r\n\t\t\tsystem(\"CLS\");\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tEnter The account No. : \"; cin>>num;\r\n\t\t\tdeposit_withdraw(num, 1);\r\n\t\t\tbreak;\r\n\t\tcase '3':\r\n\t\t\tsystem(\"CLS\");\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tEnter The account No. : \"; cin>>num;\r\n\t\t\tdeposit_withdraw(num, 2);\r\n\t\t\tbreak;\r\n\t\tcase '4':\r\n\t\t\tsystem(\"CLS\");\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tEnter The account No. : \"; cin>>num;\r\n\t\t\tdisplay_sp(num);\r\n\t\t\tbreak;\r\n\t\tcase '5':\r\n\t\t\tdisplay_all();\r\n\t\t\tbreak;\r\n\t\tcase '6':\r\n\t\t\tsystem(\"CLS\");\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tEnter The account No. : \"; cin>>num;\r\n\t\t\tdelete_account(num);\r\n\t\t\tbreak;\r\n\t\t case '7':\r\n\t\t \tsystem(\"CLS\");\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tEnter The account No. : \"; cin>>num;\r\n\t\t\tmodify_account(num);\r\n\t\t\tbreak;\r\n\t\t case '8':\r\n\t\t \tsystem(\"CLS\");\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tBrought To You By code-projects.org\";\r\n\t\t\tbreak;\r\n\t\t default :cout<<\"\\a\";\r\n\t\t}\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n    }while(ch!='8');\r\n\treturn 0;\r\n}\r\n\r\n\r\nvoid write_account()\r\n{\r\n\taccount ac;\r\n\tofstream outFile;\r\n\toutFile.open(\"account.dat\",ios::binary|ios::app);\r\n\tac.create_account();\r\n\toutFile.write(reinterpret_cast<char *> (&ac), sizeof(account));\r\n\toutFile.close();\r\n}\r\n\r\nvoid display_sp(int n)\r\n{\r\n\taccount ac;\r\n\tbool flag=false;\r\n\tifstream inFile;\r\n\tinFile.open(\"account.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\treturn;\r\n\t}\r\n\tcout<<\"\\n\\t\\t\\tBALANCE DETAILS\\n\";\r\n    \twhile(inFile.read(reinterpret_cast<char *> (&ac), sizeof(account)))\r\n\t{\r\n\t\tif(ac.retacno()==n)\r\n\t\t{\r\n\t\t\tac.show_account();\r\n\t\t\tflag=true;\r\n\t\t}\r\n\t}\r\n    inFile.close();\r\n\tif(flag==false)\r\n\t\tcout<<\"\\n\\n\\t\\t\\tAccount number does not exist\";\r\n}\r\n\r\n\r\n\r\nvoid modify_account(int n)\r\n{\r\n\tbool found=false;\r\n\taccount ac;\r\n\tfstream File;\r\n    File.open(\"account.dat\",ios::binary|ios::in|ios::out);\r\n\tif(!File)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\treturn;\r\n\t}\r\n\twhile(!File.eof() && found==false)\r\n\t{\r\n\t\tFile.read(reinterpret_cast<char *> (&ac), sizeof(account));\r\n\t\tif(ac.retacno()==n)\r\n\t\t{\r\n\t\t\tac.show_account();\r\n\t\t\tcout<<\"\\n\\n\\t\\t\\tEnter The New Details of account\"<<endl;\r\n\t\t\tac.modify();\r\n\t\t\tint pos=(-1)*static_cast<int>(sizeof(account));\r\n\t\t\tFile.seekp(pos,ios::cur); //fncallat1353\r\n\t\t    File.write(reinterpret_cast<char *> (&ac), sizeof(account));\r\n\t\t    cout<<\"\\n\\n\\t\\t\\tRecord Updated\";\r\n\t\t    found=true;\r\n\t\t  }\r\n\t}\r\n\tFile.close();\r\n\tif(found==false)\r\n\t\tcout<<\"\\n\\n\\t\\t\\tRecord Not Found \";\r\n}\r\n\r\n\r\n\r\nvoid delete_account(int n)\r\n{\r\n\taccou",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cipher_io_client\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream> \n\n#include <vector> \n\n\n\nusing namespace std;\n\n\n\nint main() {\n\n    // \u0420\u043e\u0437\u043c\u0456\u0440 \u043c\u0430\u0442\u0440\u0438\u0446\u0456 \n\n    int n, m;\n\n    cin >> n >> m;\n\n\n\n    // \u0412\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u043c\u0430\u0442\u0440\u0438\u0446\u0456 \n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    for (int i = 0; i < n; i++) {\n\n        for (int j = 0; j < m; j++) {\n\n            cin >> a[i][j];\n\n        }\n\n    }\n\n\n\n    // \u0417\u043d\u0430\u0445\u043e\u0434\u0436\u0435\u043d\u043d\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0438\u0445 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \u0443 \u043a\u043e\u0436\u043d\u043e\u043c\u0443 \u0440\u044f\u0434\u043a\u0443 \n\n    for (int i = 0; i < n; i++) {\n\n        int max = a[i][0];\n\n        for (int j = 1; j < m; j++) {\n\n            if (a[i][j] > max) {\n\n                max = a[i][j];\n\n            }\n\n        }\n\n        cout << max << \" \";\n\n    }\n\n    cout << endl;\n\n\n\n    // \u041e\u0431\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044f \u0441\u0435\u0440\u0435\u0434\u043d\u044c\u043e\u0433\u043e \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f \u0432\u0456\u0434'\u0454\u043c\u043d\u0438\u0445 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0456\u0432 \n\n    // \u0433\u043e\u043b\u043e\u0432\u043d\u043e\u0457 \u0434\u0456\u0430\u0433\u043e\u043d\u0430\u043b\u0456 \n\n    int sum = 0, cnt = 0;\n\n    for (int i = 0; i < n; i++) {\n\n        if (a[i][i] < 0) {\n\n            sum += a[i][i];\n\n            cnt++;\n\n        }\n\n    }\n\n    double avg = (cnt == 0) ? 0 : (double)sum / cnt;\n\n\n\n    // \u0412\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0443 \n\n    cout << avg << endl;\n\n\n\n    return 0;\n\n}\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"blur_effect\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include \"types.h\"\n#include \"match.h\"\n\nbool Match::makeMove(const Move& move) {\n    if (state[move.pos.first + move.pos.second * BOARD_SIZE] !=\n        CellState::empty) {\n        return false;\n    }\n    if (move.player != CellState::player1 && move.player != CellState::player2) {\n        return false;\n    }\n    state[move.pos.first + move.pos.second * BOARD_SIZE] = move.player;\n    return true;\n}\n\nconst BoardState& Match::getBoardState() const { return state; }\n\nOutcome Match::getOutcome() {\n    if (hasPlayerWon(CellState::player1)) {\n        return Outcome::player1Won;\n    }\n    else if (hasPlayerWon(CellState::player2)) {\n        return Outcome::player2Won;\n    }\n    else if (!isThereACellWithState(CellState::empty)) {\n        return Outcome::draw;\n    }\n    else {\n        return Outcome::playerTurn;\n    }\n}\n\nstd::ostream& operator<<(std::ostream& os, const Match& match) {\n    for (int i{0}; i < BOARD_SIZE; ++i) {\n        os << \"|\";\n        for (int j{0}; j < BOARD_SIZE; ++j) {\n            os << match.state[j + i * BOARD_SIZE] << \"|\";\n        }\n        os << '\\n';\n    }\n    return os;\n}",
    "/* This program solves the prefix sum problem using a parallel algorithm */\n\n#include <iostream>\n#include <thread>\n#include <string>\n#include <math.h>\n\n\n#include \"barrier.h\"\n\n\nusing namespace std;\n\nint sizeOfInput = 1000;      \nint numberOfThreads = 8;\nint numberOfPhases = 0;\n\n\n// An array to store the input array, output array and intermediate results\nint **data;\n\n\n// An array to store information about worker threads\nstd::thread* workers;\n\n// A reusable barrier for worker threads to synchronize\nsynchronization::barrier* rendevousz;\n\n// The function executed by a worker thread\nvoid doWork( int myid ) {\n\n  // compute the size of a chunk\n  int sizeOfChunk = sizeOfInput / numberOfThreads;\n\n  // compute the beginning and ending indices of my chunk\n  int mystart = myid * sizeOfChunk;\n  int myfinish = myid == numberOfThreads - 1 ? sizeOfInput : mystart + sizeOfChunk;\n\n  // used by the prefix sum algorithm\n  int fixed = 1;\n\n  for(int i = 0; i < numberOfPhases; ++i)\n  {\n    //std::cout << \"Thread with ID = \" << myid << \" is starting phase #\" << i << std::endl;\n    // execute phase i\n    for(int j = mystart; j < myfinish; ++j )\n    {\n      // compute the new values for my chunk\n      if (j < fixed)\n      {\n\n        // simply copy the entry\n        data[i+1][j] = data[i][j];\n      } else\n      {\n        // compute the sum of two specific entries\n        data[i+1][j] = data[i][j] + data[i][j-fixed];\n      }\n\n    }\n    //std::cout << \"Thread with ID = \" << myid << \" has finished phase #\" << i << std::endl;\n\n    // double the value of fixed\n    fixed = 2*fixed;\n\n    // Wait until all threads have completed their work before moving to the next phase\n    //std::cout << \"Calling rendevousz->arriveAndWait();\" << std::endl;\n    rendevousz->arriveAndWait( );\n  }\n  \n  //std::cout << \"Returning from do_work()\" << std::endl;\n  return;\n}\n\n\n\n// The main function\nint main( int argc, char** argv )\n{\n\n  if (argc < 3) {\n    cerr << \"Too few arguments\" << endl;\n    exit( 1 );\n  }\n\n  // Read the size of the input array (n) and the number of worker threads (p) to use\n  sizeOfInput = stoi( argv[1] );\n  numberOfThreads = stoi( argv[2] );\n\n  // Note that an exception will be thrown if one of the arguments is not an integer \n\n  if ( sizeOfInput <= 0 || numberOfThreads <= 0 ) {\n    cerr << \"One of the arguments is invalid\" << endl;\n    exit( 1 );\n  }\n\n\n  // Calculate the number of phases (m) in the algorithm, given by ceiling of log2(n)\n  numberOfPhases = ceil( log2( sizeOfInput ) );\n\n  // Allocate space to store pointers to m+1 arrays\n  //    data[0] stores the input array\n  //    data[m] stores the output array\n  //    data[1]...data[m-1] store intermediate results\n  //    data[i+1] is computed from data[i] in phase i, where i = 0,...,m-1\n  data = new int*[numberOfPhases+1];\n\n  // Allocate space for each of the m+1 individual arrays\n  for(int i = 0; i < numberOfPhases+1; ++i)\n  {\n    data[i] = new int[sizeOfInput];\n  }\n\n  // Initialize elements of the input array (data[0])\n  for(int j = 0; j < sizeOfInput; ++j)\n  {\n    data[0][j] = 1;\n  }\n\n  // Create a barrier object to be used by worker threads to synchronize movement from one phase to the next\n  //     a thread can advance to phase i+1 only after ALL threads have completed phase i\n  //std::cout << \"Creating barrier rendevousz\" << std::endl;\n  rendevousz = new synchronization::barrier( numberOfThreads );\n  //std::cout << \"Finished creating barrier rendevousz\" << std::endl;\n\n  // Create worker threads\n  //    first parameter is the name of the function each thread has to execute\n  //    second parameter if the identifier of the worker thread\n\n  workers = new std::thread[numberOfThreads];\n\n  for(int i = 0; i < numberOfThreads; ++i) {\n    //std::cout << \"Starting work on thread #\" << i << std::endl;\n    workers[i] = std::thread( doWork, i );\n  }\n\n\n  // Wait for all worker threads to terminate\n  //    It is crucial to join to all the child threads in order to wait for them to complete\n  //    If the main thread terminates before the child threads, it will force termination all the child threads\n  for(int i = 0; i < numberOfThreads; ++i) {\n    // we never get here\n    //std::cout << \"Joining thread #\" << i << std::endl;\n    workers[i].join();\n  }\n\n\n  // Print the output array\n  for(int j = 0; j < sizeOfInput; ++j)\n    std::cout << \"output[\" << j << \"] = \" << data[numberOfPhases][j] << std::endl;\n\n\n  // Cleanup: deallocate all dyamically allocated objects\n\n  for(int i = 0; i < numberOfThreads; ++i)\n  {\n    delete[] workers;\n    workers = NULL;\n\n  }\n\n  for(int i = 0; i < numberOfPhases+1; ++i)\n  {\n    delete[] data[i];\n    data[i] = NULL;\n\n  }\n\n  delete[] data;\n  data = NULL;\n\n  delete rendevousz;\n  rendevousz = NULL;\n\n  return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// dear imgui: Renderer Backend for DirectX11\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n//  [X] Renderer: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX11 data\nstruct ImGui_ImplDX11_Data\n{\n    ID3D11Device*               pd3dDevice;\n    ID3D11DeviceContext*        pd3dDeviceContext;\n    IDXGIFactory*               pFactory;\n    ID3D11Buffer*               pVB;\n    ID3D11Buffer*               pIB;\n    ID3D11VertexShader*         pVertexShader;\n    ID3D11InputLayout*          pInputLayout;\n    ID3D11Buffer*               pVertexConstantBuffer;\n    ID3D11PixelShader*          pPixelShader;\n    ID3D11SamplerState*         pFontSampler;\n    ID3D11ShaderResourceView*   pFontTextureView;\n    ID3D11RasterizerState*      pRasterizerState;\n    ID3D11BlendState*           pBlendState;\n    ID3D11DepthStencilState*    pDepthStencilState;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX11_Data()       { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct VERTEX_CONSTANT_BUFFER_DX11\n{\n    float   mvp[4][4];\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Forward Declarations\nstatic void ImGui_ImplDX11_InitPlatformInterface();\nstatic void ImGui_ImplDX11_ShutdownPlatformInterface();\n\n// Functions\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* d",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nstruct Node {\r\n    string nama;\r\n    string nim;\r\n    Node* next;\r\n};\r\n\r\nclass LinkedList {\r\nprivate:\r\n    Node* head;\r\n\r\npublic:\r\n    LinkedList() {\r\n        head = nullptr;\r\n    }\r\n\r\n    void tambahDepan(string nama, string nim) {\r\n        Node* newNode = new Node;\r\n        newNode->nama = nama;\r\n        newNode->nim = nim;\r\n        newNode->next = head;\r\n        head = newNode;\r\n        cout << \"Data telah ditambahkan\" << endl;\r\n    }\r\n\r\n    void tambahBelakang(string nama, string nim) {\r\n        Node* newNode = new Node;\r\n        newNode->nama = nama;\r\n        newNode->nim = nim;\r\n        newNode->next = nullptr;\r\n        if (head == nullptr) {\r\n            head = newNode;\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        while (temp->next != nullptr) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newNode;\r\n        cout << \"Data telah ditambahkan\" << endl;\r\n    }\r\n\r\n    void tambahTengah(string nama, string nim, int posisi) {\r\n        if (posisi <= 0) {\r\n            cout << \"Posisi tidak valid\" << endl;\r\n            return;\r\n        }\r\n        Node* newNode = new Node;\r\n        newNode->nama = nama;\r\n        newNode->nim = nim;\r\n        Node* temp = head;\r\n        for (int i = 0; i < posisi - 1; i++) {\r\n            if (temp == nullptr) {\r\n                cout << \"Posisi tidak valid\" << endl;\r\n                return;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        if (temp == nullptr) {\r\n            cout << \"Posisi tidak valid\" << endl;\r\n            return;\r\n        }\r\n        newNode->next = temp->next;\r\n        temp->next = newNode;\r\n        cout << \"Data telah ditambahkan\" << endl;\r\n    }\r\n\r\n    void hapusDepan() {\r\n        if (head == nullptr) {\r\n            cout << \"Linked list kosong\" << endl;\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        head = head->next;\r\n        delete temp;\r\n        cout << \"Data berhasil dihapus\" << endl;\r\n    }\r\n\r\n    void hapusBelakang() {\r\n        if (head == nullptr) {\r\n            cout << \"Linked list kosong\" << endl;\r\n            return;\r\n        }\r\n        if (head->next == nullptr) {\r\n            delete head;\r\n            head = nullptr;\r\n            cout << \"Data berhasil dihapus\" << endl;\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        while (temp->next->next != nullptr) {\r\n            temp = temp->next;\r\n        }\r\n        delete temp->next;\r\n        temp->next = nullptr;\r\n        cout << \"Data berhasil dihapus\" << endl;\r\n    }\r\n\r\n    void hapusTengah(int posisi) {\r\n        if (posisi <= 0 || head == nullptr) {\r\n            cout << \"Linked list kosong atau posisi tidak valid\" << endl;\r\n            return;\r\n        }\r\n        if (posisi == 1) {\r\n            hapusDepan();\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        for (int i = 0; i < posisi - 2; i++) {\r\n            if (temp->next == nullptr) {\r\n                cout << \"Posisi tidak valid\" << endl;\r\n                return;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        if (temp->next == nullptr) {\r\n            cout << \"Posisi tidak valid\" << endl;\r\n            return;\r\n        }\r\n        Node* nodeToDelete = temp->next;\r\n        temp->next = temp->next->next;\r\n        delete nodeToDelete;\r\n        cout << \"Data berhasil dihapus\" << endl;\r\n    }\r\n\r\n    void ubahDepan(string namaBaru, string nimBaru) {\r\n        if (head == nullptr) {\r\n            cout << \"Linked list kosong\" << endl;\r\n            return;\r\n        }\r\n        head->nama = namaBaru;\r\n        head->nim = nimBaru;\r\n        cout << \"Data berhasil diubah\" << endl;\r\n    }\r\n\r\n    void ubahBelakang(string namaBaru, string nimBaru) {\r\n        if (head == nullptr) {\r\n            cout << \"Linked list kosong\" << endl;\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        while (temp->next != nullptr) {\r\n            temp = temp->next;\r\n        }\r\n        temp->nama = namaBaru;\r\n        temp->nim = nimBaru;\r\n        cout << \"Data berhasil diubah\" << endl;\r\n    }\r\n\r\n    void ubahTengah(string namaBaru, string nimBaru, int posisi) {\r\n        if (posisi <= 0 || head == nullptr) {\r\n            cout << \"Linked list kosong atau posisi tidak valid\" << endl;\r\n            return;\r\n        }\r\n        Node* temp = head;\r\n        for (int i = 0; i < posisi - 1; i++) {\r\n            if (temp == nullptr) {\r\n                cout << \"Posisi tidak valid\" << endl;\r\n                return;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        if (temp == nullptr) {\r\n            cout << \"Posisi tidak valid\" << endl;\r\n            return;\r\n        }\r\n        temp->nama = namaBaru;\r\n        temp->nim = nimBaru;\r\n        cout << \"Data berhasil diubah\" << endl;\r\n    }\r\n\r\n    void hapusList() {\r\n        Node* current = head;\r\n        Node* next;\r\n        while (current != nullptr) {\r\n            next = current->next;\r\n            delete current;\r\n            current = next;\r\n   ",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   randomChump.cpp                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: okrahl <okrahl@student.42.fr>              +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/02 18:07:48 by okrahl            #+#    #+#             */\n/*   Updated: 2024/04/02 19:29:01 by okrahl           ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Zombie.hpp\"\n\nvoid randomChump( std::string name )\n{\n\tZombie StackZombie(name);\n\tStackZombie.announce();\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n  Stockfish, a UCI chess playing engine derived from Glaurung 2.1\n  Copyright (C) 2004-2023 The Stockfish developers (see AUTHORS file)\n\n  Stockfish is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  Stockfish is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <iostream>\n\n#include \"bitboard.h\"\n#include \"endgame.h\"\n#include \"position.h\"\n#include \"psqt.h\"\n#include \"search.h\"\n#include \"syzygy/tbprobe.h\"\n#include \"thread.h\"\n#include \"tt.h\"\n#include \"uci.h\"\n\nusing namespace Stockfish;\n\nint main(int argc, char* argv[]) {\n\n  std::cout << engine_info() << std::endl;\n\n  CommandLine::init(argc, argv);\n  UCI::init(Options);\n  Tune::init();\n  PSQT::init();\n  Bitboards::init();\n  Position::init();\n  Bitbases::init();\n  Endgames::init();\n  Threads.set(size_t(Options[\"Threads\"]));\n  Search::clear(); // After threads are up\n  Eval::NNUE::init();\n\n  UCI::loop(argc, argv);\n\n  Threads.set(0);\n  return 0;\n}\n",
    "#include \"barrier.h\"\n#include <semaphore.h>\n\nnamespace synchronization\n{\n   \n   barrier::barrier( int numberOfThreads ) {\n      // Write your code here\n      sem_init(&mutex, 0, 1);\n      sem_init(&gate1, 0, 0);\n      sem_init(&gate2, 0, 1);\n      count = 0;\n      n = numberOfThreads;\n      return;\n   }\n\n   barrier::~barrier( ) {\n      sem_destroy(&mutex);\n      sem_destroy(&gate1);\n      sem_destroy(&gate2);\n      // Write your code here\n\n      return;\n   }\n\n   void barrier::arriveAndWait( void ) {\n      // Write your code here\n      // mutex for critical section where count is incremented for each thread\n      sem_wait(&mutex);\n      count++;\n      // if last thread, down gate2, and up gate1. this makes gate2 unavailable for the earlier threads so no thread can\n      // lap all the others, and then makes gate1 available for them to progress to second turnstile\n      if(count == n){\n         sem_wait(&gate2);\n         sem_post(&gate1);\n      }\n      sem_post(&mutex);\n\n      // wait at gate1, and then open it for the thread behind them.\n      sem_wait(&gate1);\n      sem_post(&gate1);\n\n      // critical section, count is decremented by each thread\n      sem_wait(&mutex);\n      count--;\n\n      // if last thread has reached, make gate1 unavailable, and open gate2\n      if(count == 0){\n         sem_wait(&gate1);\n         sem_post(&gate2);\n      }\n      sem_post(&mutex);\n\n      // wait at gate2, then open it for the thread behind\n      sem_wait(&gate2);\n      sem_post(&gate2);\n      return;\n   }\n\n}\n",
    "// Make sure to include these libraries in your Platform.io project before compiling!\n#include <Wire.h>\n#include <Adafruit_BMP280.h>\n#include <PubSubClient.h>\n#include <ESP8266WiFi.h>\n\n// WiFi settings\nconst char* ssid = \"wifi\"; // Change this to your WiFi network\nconst char* password = \"password\"; // Change this to your WiFi password\n\n// MQTT settings\nconst char* mqtt_server = \"mqttserver.local\"; // Change this to your mqtt server adress (examples: \"192.168.0.xx\" or \"mqtt.local\")\nconst int mqtt_port = 1883; // If you use a different MQTT port, change that here\nconst char* mqtt_username = \"username\"; // Change this to your MQTT username\nconst char* mqtt_password = \"password\"; // Change this to your MQTT password\nconst char* mqtt_topic = \"pc/temp/intake\"; // Change this if you wish to output the temperature to another place (useful if you want multiple sensors in different areas, example: \"pc/temp/exhaust\")\n\n// Initialize the BMP280 sensor\nAdafruit_BMP280 bmp;\n\n// Initialize the MQTT client\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nunsigned long publishMillis = 0;\n\nconst long publishInterval = 2000; // Interval to publish average temperature (milliseconds) change this if you require more or less data per time interval\n\nunsigned long sensorReadMillis = 0;\nconst long sensorReadInterval = 100; // Interval to read sensor (milliseconds) change this to a higher number if you want the sensor to be read less times a second (might lower accuracy but will reduce calculation load on the D1)\n\nfloat temperatureSum = 0;\nint readingsCount = 0;\n\n// Set up the WiFi connection\nvoid setup_wifi() {\n  Serial.println();\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) { // wait for connection\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected\"); // Debug prints for WiFi connection\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\n// Reconnect if connection lost\nvoid reconnect() {\n  while (!client.connected()) {\n    Serial.print(\"Attempting MQTT connection...\");\n    if (client.connect(\"ESP8266Client\", mqtt_username, mqtt_password)) {\n      Serial.println(\"connected\"); // Debug print for successful MQTT connection\n    } else {\n      Serial.print(\"failed, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" try again in 5 seconds\"); // Debug print for failed MQTT connection\n      delay(5000);\n    }\n  }\n}\n\n// Start the wifi and MQTT connection\nvoid setup() {\n  Serial.begin(9600);\n  setup_wifi();\n  client.setServer(mqtt_server, mqtt_port);\n  while (!bmp.begin(0x76)) {\n    Serial.println(\"Could not find a valid BMP280 sensor, check wiring!\"); // Debug print for failing to find BMP280, will retry after 2 seconds\n    delay (2000);\n  }\n}\n\n// Read the sensors and publish the data\nvoid loop() {\n  if (!client.connected()) {\n    reconnect();\n  }\n  client.loop();\n\n  unsigned long currentMillis = millis();\n\n  // Read sensor 20 times per second\n  if (currentMillis - sensorReadMillis >= sensorReadInterval) {\n    sensorReadMillis = currentMillis;\n    float temperature = bmp.readTemperature();\n    temperatureSum += temperature;\n    readingsCount++;\n  }\n\n  // Publish average temperature every 2 seconds\n  if (currentMillis - publishMillis >= publishInterval) {\n    publishMillis = currentMillis;\n    if (readingsCount > 0) {\n      float averageTemperature = temperatureSum / readingsCount;\n      client.publish(mqtt_topic, String(averageTemperature).c_str());\n      temperatureSum = 0;\n      readingsCount = 0;\n    }\n  }\n}",
    "#include \"simulation.h\"\n#include <vector>\n#include <utility>\n\nvoid Simulation::Draw()\n{\n\tgrid.Draw();\n}\n\nvoid Simulation::SetCellValue(int row, int column, int value)\n{\n\tgrid.SetValue(row, column, value);\n}\n\nint Simulation::CountLiveNeighbors(int row, int column)\n{\n\tint liveNeighbors = 0;\n\tstd::vector<std::pair<int, int>> NeighborOffSets = { {-1,0}, {1,0}, {0,-1}, {0,1}, {-1,-1}, {-1,1}, {1,-1}, {1,1}, };\n\n\tfor(const auto& offset : NeighborOffSets)\n\t{\n\t\tint neighborRow = (row + offset.first + grid.GetRows()) % grid.GetRows();\n\t\tint neighborColumn = (column + offset.second + grid.GetColumns()) % grid.GetColumns();\n\t\tliveNeighbors += grid.GetValue(neighborRow, neighborColumn);\n\t}\n\treturn liveNeighbors;\n\n}\n\nvoid Simulation::Update()\n{\n\tif (IsRunning()){\n\t\tfor (int i = 0; i < grid.GetRows(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < grid.GetColumns(); j++)\n\t\t\t{\n\t\t\t\tint liveNeighbors = CountLiveNeighbors(i, j);\n\t\t\t\tint cellValue = grid.GetValue(i, j);\n\t\t\t\tif (cellValue == 1)\n\t\t\t\t{\n\t\t\t\t\tif (liveNeighbors > 3 || liveNeighbors < 2) {\n\t\t\t\t\t\ttempGrid.SetValue(i, j, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttempGrid.SetValue(i, j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (liveNeighbors == 3) {\n\t\t\t\t\t\ttempGrid.SetValue(i, j, 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttempGrid.SetValue(i, j, 0);\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgrid = tempGrid;\n\t}\n}\n\nvoid Simulation::ClearGrid()\n{\n\tif (!IsRunning()) {\n\t\tgrid.Clear();\n\t}\n}\n\nvoid Simulation::CreateRandomState()\n{\n\tif (!IsRunning()) {\n\t\tgrid.FillRandom();\n\t}\n}\n\nvoid Simulation::ToggleCell(int row, int column)\n{\n\tif (!IsRunning()) {\n\t\tgrid.ToggleCell(row, column);\n\t}\n}\n",
    "#include <iostream>\n#include <vector>\n\n// Enum for character classes\nenum class CharacterClass {\n    Warrior,\n    Wizard,\n    Archer\n};\n\n// Structure for character data\nstruct Character {\n    int id;\n    CharacterClass charClass;\n    float meleeAttack;\n    float rangedAttack;\n};\n\n// Function to find the name of the strongest character\nint findStrongestCharacter(const std::vector<Character>& characters) {\n    if (characters.empty()) return -1; // Return -1 if the vector is empty\n\n    int strongestId = characters[0].id;\n    float maxStrength = characters[0].meleeAttack + characters[0].rangedAttack;\n\n    for (const auto& character : characters) {\n        float currentStrength = character.meleeAttack + character.rangedAttack;\n        if (currentStrength > maxStrength) {\n            maxStrength = currentStrength;\n            strongestId = character.id;\n        }\n    }\n\n    return strongestId;\n}\n\nint main() {\n    // Example characters\n    std::vector<Character> characters = {\n        {1, CharacterClass::Warrior, 15.5, 10.0},\n        {2, CharacterClass::Wizard, 12.0, 13.5},\n        {3, CharacterClass::Archer, 10.0, 18.0}\n    };\n\n    int strongestCharacterId = findStrongestCharacter(characters);\n    std::cout << \"The strongest character ID is: \" << strongestCharacterId << std::endl;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include<iostream>\n\n\n\nclass Apple {\nprivate:\n\tint nutritionalValue;\n\tint timeToRiot;\n\t//\u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0439 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442, \u0447\u0442\u043e \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n\t//\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u043d\u0443\u0442\u0440\u0438 \u043a\u043b\u0430\u0441\u0441\u0430\n\tApple() :nutritionalValue(100), timeToRiot(10) {\n\t\tstd::cout << \"Apple created\" << std::endl;\n\t}\n\t//\u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n\tstatic Apple* instance;\n\n\t// \u0417\u0430\u043f\u0440\u0435\u0449\u0430\u0435\u043c \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435\n\tApple(const Apple&) = delete;\n\tApple& operator = (const Apple&) = delete;\n\n\n\npublic:\n\t// \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430\n\tstatic Apple* getinstance() {\n\t\tif (instance==nullptr) {\n\t\t\tinstance = new Apple();\n\t\t}\n\t\treturn instance;\n\t}\n\n\t//\u041c\u0435\u0442\u043e\u0434\u044b \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0435\u0439\n\t\n\tvoid SetNutritionalValue(int value) {\n\t\tnutritionalValue = value;\n\t}\n\n\tvoid SetTimeToRiot(int time) {\n\t\ttimeToRiot = time;\n\t}\n\t\n\tint GetNutritionalValue() {\n\t\treturn nutritionalValue;\n\t}\n\n\tint GetTimeToRiot(){\n\t\treturn timeToRiot;\n\t}\n\t \n\n\n};\n\n//\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u043d\u0430 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\nApple* Apple::instance = nullptr;\n\nint main() {\n\t//\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n\tApple* apple1 = Apple::getinstance();\n\tstd::cout << \"NutritionalValue\" << apple1->GetNutritionalValue() << std::endl;\n\tstd::cout << \"TimeToRiot\" << apple1->GetTimeToRiot() << std::endl;\n\t//\u041c\u0435\u043d\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0435\u0439\n\tapple1 -> SetNutritionalValue(90);\n\tapple1 -> SetTimeToRiot(5);\n\t\n\t//\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0435\u0439 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442\n\tApple* apple2 = Apple::getinstance();\n\t\n\tstd::cout << \"NutritionalValue\" << apple2->GetNutritionalValue() << std::endl;\n\tstd::cout << \"TimeToRiot\" << apple2->GetTimeToRiot() << std::endl;\n\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"movie_recommendation\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n  Asynchronous WebServer library for Espressif MCUs\n\n  Copyright (c) 2016 Hristo Gochkov. All rights reserved.\n  This file is part of the esp8266 core for Arduino environment.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n#include \"ESPAsyncWebServer.h\"\n#include \"WebHandlerImpl.h\"\n\nAsyncStaticWebHandler::AsyncStaticWebHandler(const char* uri, FS& fs, const char* path, const char* cache_control)\n  : _fs(fs), _uri(uri), _path(path), _default_file(\"index.htm\"), _cache_control(cache_control), _last_modified(\"\"), _callback(nullptr)\n{\n  // Ensure leading '/'\n  if (_uri.length() == 0 || _uri[0] != '/') _uri = \"/\" + _uri;\n  if (_path.length() == 0 || _path[0] != '/') _path = \"/\" + _path;\n\n  // If path ends with '/' we assume a hint that this is a directory to improve performance.\n  // However - if it does not end with '/' we, can't assume a file, path can still be a directory.\n  _isDir = _path[_path.length()-1] == '/';\n\n  // Remove the trailing '/' so we can handle default file\n  // Notice that root will be \"\" not \"/\"\n  if (_uri[_uri.length()-1] == '/') _uri = _uri.substring(0, _uri.length()-1);\n  if (_path[_path.length()-1] == '/') _path = _path.substring(0, _path.length()-1);\n\n  // Reset stats\n  _gzipFirst = false;\n  _gzipStats = 0xF8;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setIsDir(bool isDir){\n  _isDir = isDir;\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setDefaultFile(const char* filename){\n  _default_file = String(filename);\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setCacheControl(const char* cache_control){\n  _cache_control = String(cache_control);\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(const char* last_modified){\n  _last_modified = String(last_modified);\n  return *this;\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(struct tm* last_modified){\n  char result[30];\n  strftime (result,30,\"%a, %d %b %Y %H:%M:%S %Z\", last_modified);\n  return setLastModified((const char *)result);\n}\n\n#ifdef ESP8266\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(time_t last_modified){\n  return setLastModified((struct tm *)gmtime(&last_modified));\n}\n\nAsyncStaticWebHandler& AsyncStaticWebHandler::setLastModified(){\n  time_t last_modified;\n  if(time(&last_modified) == 0) //time is not yet set\n    return *this;\n  return setLastModified(last_modified);\n}\n#endif\nbool AsyncStaticWebHandler::canHandle(AsyncWebServerRequest *request){\n  if(request->method() != HTTP_GET \n    || !request->url().startsWith(_uri) \n    || !request->isExpectedRequestedConnType(RCT_DEFAULT, RCT_HTTP)\n  ){\n    return false;\n  }\n  if (_getFile(request)) {\n    // We interested in \"If-Modified-Since\" header to check if file was modified\n    if (_last_modified.length())\n      request->addInterestingHeader(\"If-Modified-Since\");\n\n    if(_cache_control.length())\n      request->addInterestingHeader(\"If-None-Match\");\n\n    DEBUGF(\"[AsyncStaticWebHandler::canHandle] TRUE\\n\");\n    return true;\n  }\n\n  return false;\n}\n\nbool AsyncStaticWebHandler::_getFile(AsyncWebServerRequest *request)\n{\n  // Remove the found uri\n  String path = request->url().substring(_uri.length());\n\n  // We can skip the file check and look for default if request is to the root of a directory or that request path ends with '/'\n  bool canSkipFileCheck = (_isDir && path.length() == 0) || (path.length() && path[path.length()-1] == '/');\n\n  path = _path + path;\n\n  // Do we have a file or .gz file\n  if (!canSkipFileCheck && _fileExists(request, path))\n    return true;\n\n  // Can't handle if not default file\n  if (_default_file.length() == 0)\n    return false;\n\n  // Try to add default file, ensure there is a trailing '/' ot the path.\n  if (path.length() == 0 || path[path.length()-1] != '/')\n    path += \"/\";\n  path += _default_file;\n\n  return _fileExists(request, path);\n}\n\n#ifdef ESP32\n#define FILE_IS_REAL(f) (f == true && !f.isDirectory())\n#else\n#define FILE_IS_REAL(f) (f == true)\n#endif\n\nbool AsyncStaticWebHandler::_fileExists(AsyncWebServerRequest *request, const String& path)\n{\n  bool fileFound = false;\n  bool gzipFound = false;\n\n  String gzip = path + \".gz\";\n\n  if (_gzipFirst) {\n    request->_tempFile = _fs.open(gzip, \"r\");\n    gzipFound = FILE_IS_REAL(request->_tempFile);\n    if (!gzipFound){\n      request->_tempFi",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"header.h\"\n\nextern int numStudents;\nextern int addStudents;\nextern std::vector<STUDENT>students;\n\nint main()\n{\n\tSetConsoleCP(1251);\n\tSetConsoleOutputCP(1251);\n\tsetlocale(LC_ALL, \"RU\");\n\tint choice;\n\n\twhile (true)\n\t{\t\n\t\tstd::cout << \" \u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00ee\u00ec\u00e5\u00f0 \u00ec\u00e5\u00ed\u00fe \\n\";\n\t\tstd::cout << \"[1] \u00c2\u00e2\u00ee\u00e4 \u00f1 \u00ea\u00eb\u00e0\u00e2\u00e8\u00e0\u00f2\u00f3\u00f0\u00fb \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2;\\n\";\n\t\tstd::cout << \"[2] \u00c2\u00fb\u00e2\u00ee\u00e4 \u00ed\u00e0 \u00e4\u00e8\u00f1\u00ef\u00eb\u00e5\u00e9 \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e9 \u00e8 \u00ed\u00ee\u00ec\u00e5\u00f0\u00ee\u00e2 \u00e3\u00f0\u00f3\u00ef\u00ef \u00e2\u00f1\u00e5\u00f5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2, \u00e8\u00ec\u00e5\u00fe\u00f9\u00e8\u00f5 \u00ee\u00f6\u00e5\u00ed\u00ea\u00e8 4 \u00e8 5;\\n\";\n\t\tstd::cout << \"[3] \u00c4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2;\\n\";\n\t\tstd::cout << \"[4] \u00c2\u00fb\u00e2\u00ee\u00e4 \u00ed\u00e0 \u00e4\u00e8\u00f1\u00ef\u00eb\u00e5\u00e9 \u00e2\u00f1\u00e5\u00f5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2 \u00ef\u00ee \u00f3\u00ea\u00e0\u00e7\u00e0\u00ed\u00ee\u00ec\u00f3 \u00ed\u00ee\u00ec\u00e5\u00f0\u00f3 \u00e3\u00f0\u00f3\u00ef\u00ef\u00fb;\\n\";\n\t\tstd::cout << \"[5] \u00cf\u00ee\u00e8\u00f1\u00ea \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00e0 \u00ef\u00ee \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e8.\\n\";\n\t\tstd::cout << \"[0] \u00c2\u00fb\u00f5\u00ee\u00e4\\n\";\n\n\t\tstd::cin >> choice;\n\t\tswitch (choice)\n\t\t{\n\t\tcase EXIT:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\treturn 0;\n\t\t}\n\t\tcase INPUT_DATA:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tstd::cout << \"\u00d1\u00ea\u00ee\u00eb\u00fc\u00ea\u00ee \u00eb\u00fe\u00e4\u00e5\u00e9 \u00e2\u00fb \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc? \"; std::cin >> numStudents;\n\t\t\tinputData();\n\t\t\tfor (const auto& student : students) {\n\t\t\t\tstd::cout << \"\u00c8\u00ec\u00ff: \" << student.name << \", \u00d4\u00e0\u00ec\u00e8\u00eb\u00e8\u00ff: \" << student.surname << \", \u00c3\u00f0\u00f3\u00ef\u00ef\u00e0: \" << student.group << std::endl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tcase PRINT_GOODGRADES_STUDENTS:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tprintGoodGradesStudents(); break;\n\t\t}\n\t\tcase ADD_STUDENT:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tstd::cout << \"\u00d1\u00ea\u00ee\u00eb\u00fc\u00ea\u00ee \u00eb\u00fe\u00e4\u00e5\u00e9 \u00e2\u00fb \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc? \"; std::cin >> numStudents;\n\t\t\tinputData(); break;\n\t\t}\n\t\tcase PRINT_STUDENTS_BY_GROUP:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tprintStudentsByGroup();\tbreak;\n\t\t}\n\t\tcase SEARCH_STUDENT_BY_SURNAME:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tsearchStudentBySurname();\n\t\t\tbreak;\n\t\t}\n\t\tdefault: system(\"cls\"); std::cout << \"\u00cd\u00e5\u00ea\u00ea\u00ee\u00f0\u00e5\u00ea\u00f2\u00ed\u00fb\u00e9 \u00e2\u00e2\u00ee\u00e4 \u00ef\u00f3\u00ed\u00ea\u00f2\u00e0 \u00ec\u00e5\u00ed\u00fe\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl '\\n'\r\nlong double PI = acos(-1.0);\r\n#define fastio()                      \\\r\n\tios_base::sync_with_stdio(false); \\\r\n\tcin.tie(NULL)\r\n#define pb push_back\r\n#define NL cout<<endl;\r\n#define ppb pop_back\r\n#define pf push_front\r\n#define ppf pop_front\r\n#define all(x) (x).begin(), (x).end()\r\n#define ff(i, l, r) for(int i=l;i<r;i++)\r\n#define fr first\r\n#define sc second\r\n#define vii vector<vector<int>>\r\n#define vi vector<int>\r\n#define pii pair<int, int>\r\n#define mem1(a) memset(a, -1, sizeof(a))\r\n#define mem0(a) memset(a, 0, sizeof(a))\r\n#define ppc __builtin_popcount\r\n#define ppcll __builtin_popcountll\r\n#define YES \\\r\n\tyes();          \\\r\n\treturn\r\n#define NO\\\r\n\tno();          \\\r\n\treturn\r\n\r\nconst int MOD = (1e9 + 9);\r\n/*1sec -10^7-10^8 OPS APPROX\r\nint- (-10^-9 to 10^9)RANGE\r\nlong (-10^12 to 10^12)RANGE\r\nlong long(-10^18 to 10^18)RANGE\r\n(a+b)%M=((a%M)+(b%M))%M\r\n(a*b)%M=((a%M)*(b%M))%M\r\n(a-b)%M=((a%M)-(b%M)+M)%M\r\n(a/b)%M=((a%M)*(b^-1)%M)%M\r\nlower_bound:-LOGN\r\ninterator\r\n--FIRST ELEMENT IN AR >=x\r\n--NO OF ELEMENTS<x\r\nupper_bound:-\r\niterator\r\n--FIRST ELEMENT IN AR>x\r\n--NO OF ELEMENTS<=x\r\n*/\r\n#ifdef ANURAG\r\n#define debug(x)        \\\r\n\tcerr << #x << \": \"; \\\r\n\t_print(x);          \\\r\n\tcerr << endl;\r\n#else\r\n#define debug(x) ;\r\n#endif\r\n\r\nclass Solution {\r\npublic:\r\n    int check(int mid,vector<vector<int>>& a,int w){\r\n        int n=a.size();\r\n        int m=w;\r\n        int rec=0;\r\n        for(int i=1;i<n;i++){\r\n            if(a[i][0]-a[i-1][0]<=m){\r\n                m-=(a[i][0]-a[i-1][0]);\r\n            }else{\r\n                rec++;\r\n                m=w;\r\n            }\r\n        }\r\n        return ++rec<=mid;\r\n    }\r\n    int bs(vector<vector<int>>& a,int l,int h,int &ans,int w){\r\n        if(l>h){\r\n            return ans;\r\n        }\r\n        int mid=l+(h-l)/2;\r\n        if(check(mid,a,w))\r\n        {\r\n            ans=mid;\r\n            return bs(a,l,mid-1,ans,w);\r\n        }\r\n        return bs(a,mid+1,h,ans,w);\r\n    }\r\n    int minRectanglesToCoverPoints(vector<vector<int>>& a, int w) {\r\n        sort(a.begin(),a.end());\r\n        int n=a.size();\r\n        int l=0,h=1e9;\r\n        int ans=-1;\r\n        return bs(a,l,h,ans,w);\r\n    }\r\n};",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include <string.h>\n\n\nint minSubsequence(char* source, char* target) {\n    int source_len = strlen(source);\n    int target_len = strlen(target);\n    int count = 0;\n    int i, j;\n    int num = 0;\n    int last = -1;\n\n    for (i = 0; i < target_len; i++) {\n        int included = -1; // Initialize to -1 to indicate not found\n        int notinbehind = 1;\n\n        // Find the index of the current target character in the source string\n        for (j = 0; j < source_len; j++) {\n            if (target[i] == source[j]) {\n                included = j;\n                num += 1;\n                break;\n            }\n        }\n\n        // If the character is not found in the source string, return -1\n        if (included == -1) {\n            return -1;\n        }\n\n        // Check if the character is not behind the last occurrence\n        if (included > last) {\n            notinbehind = 0;\n            last = included;\n        }\n\n        // If the character is not behind the last occurrence, increment count\n        if (notinbehind == 1 || (notinbehind==0 && i==target_len-1)) {\n            count += 1;\n            num = 0;\n        }\n    }\n    return count;\n}\n\nint main() {\n    char source1[] = \"abc\";\n    char target1[] = \"acbacb\";\n    printf(\"%d\\n\", minSubsequence(source1, target1));\n\n    return 0;\n}\n",
    "\ufeff#ifndef TIME_H\n#define TIME_H\n\nclass Time\n{\nprivate:\n\tint hours, minutes, seconds;\n\tvoid trueTime();\n\npublic:\n\tconst int DEF_T = 0;\n\tconst int MIN_T = 0;\n\tconst int MAX_H = 24;\n\tconst int MAX_M = 60;\n\tTime();\n\tTime(int hours, int minutes, int seconds);\n\tint fullMinutes();\n\tvoid minusMinutes();\n\tint getHours();\n\tint getMinutes();\n\tint getSeconds();\n\tvoid setHours(int h);\n\tvoid setMinutes(int m);\n\tvoid setSeconds(int s);\n};\n\n#endif // !TIME_H\n\n#include \"time.h\"\n#include <iostream>\n#include <ostream>\n#include <iomanip>\n\nusing namespace std;\n\nTime::Time()\n{\n\tthis->hours = DEF_T;\n\tthis->minutes = DEF_T;\n\tthis->seconds = DEF_T;\n\n\ttrueTime();\n}\n\nTime::Time(int hours, int minutes, int seconds)\n\t: hours(hours), minutes(minutes), seconds(seconds)\n{\n\ttrueTime();\n}\n\nvoid Time::trueTime()\n{\n\tint sum = seconds + minutes * MAX_M + hours * int(pow(MAX_M, 2));\n\tif (sum < 0)\n\t{\n\t\tsum += int(pow(MAX_M, 2) * MAX_H);\n\t}\n\tseconds = sum % MAX_M;\n\tsum = sum / MAX_M;\n\tminutes = sum % MAX_M;\n\tsum = sum / MAX_M;\n\thours = sum % MAX_H;\n}\n\nint Time::fullMinutes()\n{\n\treturn minutes + hours * 60;\n}\n\nvoid Time::minusMinutes()\n{\n\tminutes -= 10;\n\ttrueTime();\n}\n\nint Time::getHours()\n{\n\treturn this->hours;\n}\nint Time::getMinutes()\n{\n\treturn this->minutes;\n}\nint Time::getSeconds()\n{\n\treturn this->seconds;\n}\nvoid Time::setHours(int h)\n{\n\tthis->hours = h;\n\ttrueTime();\n}\nvoid Time::setMinutes(int m)\n{\n\tthis->minutes = m;\n\ttrueTime();\n}\nvoid Time::setSeconds(int s)\n{\n\tthis->seconds = s;\n\ttrueTime();\n}\n\nostream& operator<<(ostream& os, Time& obj)\n{\n\tos << setfill('0') << setw(2) << obj.getHours() << \":\"\n\t\t<< setw(2) << obj.getMinutes() << \":\"\n\t\t<< setw(2) << obj.getSeconds() << endl;\n\treturn os;\n}\n\nistream& operator>>(istream& is, Time& obj)\n{\n\tint h, m, s;\n\tis >> h >> m >> s;\n\tobj.setHours(h);\n\tobj.setMinutes(m);\n\tobj.setSeconds(s);\n\treturn is;\n}\n\nint main()\n{\n\tTime* t1 = new Time();\n\tTime* t2 = new Time(25, 1, 70);\n\tTime* t3 = new Time(-10, -50, 70);\n\tTime* t4 = new Time();\n\n\tcin >> *t4;\n\tcout << *t1;\n\tcout << *t2;\n\tcout << *t3;\n\tcout << *t4;\n\n\tdelete t1;\n\tdelete t2;\n\tdelete t3;\n\tdelete t4;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pass_data_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"widgets_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include \"listtoolshb.h\"\r\n#include \"MyList.h\"\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct Profile\r\n{\r\n    string fullname;\r\n    string state;\r\n    bool operator==(Profile rhs)\r\n    {\r\n        if (fullname == rhs.fullname) return true; return false;\r\n    }\r\n    bool operator!=(Profile rhs)\r\n    {\r\n        if (fullname != rhs.fullname) return true; return false;\r\n    }\r\n};\r\nostream& operator<< (ostream& out, Profile& user)\r\n{\r\n    out << user.fullname << \"--\" << user.state;\r\n    return out;\r\n}\r\n\r\nbool searchDeque(MyList<Profile>& pq, Profile& president) {\r\n    for (const auto& profile : pq) {\r\n        if (profile.fullname == president.fullname) {\r\n            president = profile; // Update the president object with the found Profile\r\n            return true;\r\n        }\r\n    }\r\n    return false; // Profile not found\r\n}\r\n\r\nint main()\r\n{\r\n    MyList<Profile> pMyList; // create an object of MyList<Profile>\r\n\r\n    string line;\r\n    Profile temp;\r\n\r\n    //read from the \"presidentsWstates.txt\" file\r\n    ifstream file(\"presidentsWstates.txt\");\r\n    if (file.is_open()) {\r\n        while (getline(file, line)) {\r\n            stringstream ss(line);\r\n            getline(ss, temp.fullname, '\\t');\r\n            getline(ss, temp.state, '\\t');\r\n            pMyList.insertHead(temp); //insert the profile object into pMyList\r\n        }\r\n    }\r\n\r\n    //testing mylist implemenation\r\n    cout << \"Inserting profiles: \" << endl;\r\n    Profile newProfile = { \"Andrew Eisengruber\", \"MI\" };\r\n    pMyList.insertHead(newProfile);\r\n    pMyList.display(); // display all elements\r\n\r\n    cout << \"Depleting head: \" << pMyList.deleteHead() << endl; //\r\n\r\n    Profile searchProfile = { \"Abraham Lincoln\", \"IL\" };\r\n    if (pMyList.search(searchProfile)) {\r\n        cout << \"Found: \" << searchProfile << endl;\r\n    }\r\n    else {\r\n        cout << \"Not Found: \" << searchProfile << endl;\r\n    }\r\n\r\n  \r\n    temp.fullname = \"Gerald R. Ford\";\r\n    if (searchDeque(pMyList, temp)) {\r\n        cout << \"Found: \" << temp << endl;\r\n    }\r\n    else {\r\n        cout << \"Not found: \" << temp << endl;\r\n    }\r\n\r\n}\r\n",
    "\ufeff#include \"pch-cpp.hpp\"\n\n\n\n\n\ntemplate <typename T1>\nstruct VirtualActionInvoker1\n{\n\ttypedef void (*Action)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline void Invoke (Il2CppMethodSlot slot, RuntimeObject* obj, T1 p1)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\t((Action)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\ntemplate <typename T1>\nstruct GenericVirtualActionInvoker1\n{\n\ttypedef void (*Action)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline void Invoke (const RuntimeMethod* method, RuntimeObject* obj, T1 p1)\n\t{\n\t\tVirtualInvokeData invokeData;\n\t\til2cpp_codegen_get_generic_virtual_invoke_data(method, obj, &invokeData);\n\t\t((Action)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\ntemplate <typename T1>\nstruct InterfaceActionInvoker1\n{\n\ttypedef void (*Action)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);\n\t\t((Action)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\ntemplate <typename T1>\nstruct GenericInterfaceActionInvoker1\n{\n\ttypedef void (*Action)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline void Invoke (const RuntimeMethod* method, RuntimeObject* obj, T1 p1)\n\t{\n\t\tVirtualInvokeData invokeData;\n\t\til2cpp_codegen_get_generic_interface_invoke_data(method, obj, &invokeData);\n\t\t((Action)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\n\nstruct DelegateU5BU5D_tC5AB7E8F745616680F337909D3A8E6C722CDF771;\nstruct SingleU5BU5D_t89DEFE97BCEDB5857010E79ECE0F52CF6E93B87C;\nstruct TypeU5BU5D_t97234E1129B564EB38B8D85CAC2AD8B5B9522FFB;\nstruct Action_tD00B0A84D7945E50C2DFFC28EFEE6ED44ED2AD07;\nstruct AudioClip_t5D272C4EB4F2D3ED49F1C346DEA373CF6D585F20;\nstruct AudioSampleProvider_t602353124A2F6F2AEC38E56C3C21932344F712E2;\nstruct AudioSource_t871AC2272F896738252F04EE949AEF5B241D3299;\nstruct Binder_t91BFCE95A7057FADF4D8A1A342AFE52872246235;\nstruct Component_t39FBE53E5EFCF4409111FB22C15FF73717632EC3;\nstruct Delegate_t;\nstruct DelegateData_t9B286B493293CD2D23A5B2B5EF0E5B1324C2B77E;\nstruct GameObject_t76FEDD663AB33C991A9C9A23129337651094216F;\nstruct MemberFilter_tF644F1AE82F611B677CE1964D5A3277DDA21D553;\nstruct MethodInfo_t;\nstruct Object_tC12DECB6760A7F2CBF65D9DCF18D044C2D97152C;\nstruct String_t;\nstruct Transform_tB27202C6F4E36D225EE28A13E4D662BF99785DB1;\nstruct Type_t;\nstruct Void_t4861ACF8F4594C3437BB48B6E56783494B843915;\nstruct PCMReaderCallback_t3396D9613664F0AFF65FB91018FD0F901CC16F1E;\nstruct PCMSetPositionCallback_t8D7135A2FB40647CAEC93F5254AD59E18DEB6072;\nstruct SampleFramesHandler_tFE84FF9BBCEFB880D46227188F375BEF680AAA30;\nstruct AudioConfigurationChangeHandler_tE071B0CBA3B3A77D3E41F5FCB65B4017885B3177;\n\nIL2CPP_EXTERN_C RuntimeClass* AudioSettings_t66C4BCA1E463B061E2EC9063FB882ACED20D47BD_il2cpp_TypeInfo_var;\nIL2CPP_EXTERN_C RuntimeClass* AudioSource_t871AC2272F896738252F04EE949AEF5B241D3299_il2cpp_TypeInfo_var;\nIL2CPP_EXTERN_C RuntimeClass* Debug_t8394C7EEAECA3689C2C9B9DE9C7166D73596276F_il2cpp_TypeInfo_var;\nIL2CPP_EXTERN_C RuntimeClass* GameObject_t76FEDD663AB33C991A9C9A23129337651094216F_il2cpp_TypeInfo_var;\nIL2CPP_EXTERN_C RuntimeClass* Object_tC12DECB6760A7F2CBF65D9DCF18D044C2D97152C_il2cpp_TypeInfo_var;\nIL2CPP_EXTERN_C RuntimeClass* PlayableHandle_t5D6A01EF94382EFEDC047202F71DF882769654D4_il2cpp_TypeInfo_var;\nIL2CPP_EXTERN_C String_t* _stringLiteral2186DB8EA3F0EBBFF4B670DC1B315D485E2F447B;\nIL2CPP_EXTERN_C String_t* _stringLiteral49403A17E8D32B35CB5B66AB1A2651A7EEAD1B00;\nIL2CPP_EXTERN_C String_t* _stringLiteral66F9618FDA792CAB23AF2D7FFB50AB2D3E393DC5;\nIL2CPP_EXTERN_C String_t* _stringLiteralD5F2B3561CFA951FF37495C4B6AE6DB436EC2259;\nIL2CPP_EXTERN_C const RuntimeMethod* MarshalledUnityObject_MarshalNotNull_TisAudioClip_t5D272C4EB4F2D3ED49F1C346DEA373CF6D585F20_mC3A4EC248FAFFBF10CD74B1E57A203FE7D9E01F5_RuntimeMethod_var;\nIL2CPP_EXTERN_C const RuntimeMethod* MarshalledUnityObject_MarshalNotNull_TisAudioSource_t871AC2272F896738252F04EE949AEF5B241D3299_mD9CAE1F7BCD08FDB40173EA86F253A6E87B8EF65_RuntimeMethod_var;\nIL2CPP_EXTERN_C const RuntimeMethod* MarshalledUnityObject_Marshal_TisAudioClip_t5D272C4EB4F2D3ED49F1C346DEA373CF6D585F20_m4CF5833467B7EAC854506E5E808202FABD1F15CC_RuntimeMethod_var;\nIL2CPP_EXTERN_C const RuntimeType* AudioSource_t871AC2272F896738252F04EE949AEF5B241D3299_0_0_0_var;\nstruct Delegate_t_marshaled_com;\nstruct Delegate_t_marshaled_pinvoke;\n\nstruct DelegateU5BU5D_tC5AB7E8F745616680F337909D3A8E6C722CDF771;\nstruct SingleU5BU5D_t89DEFE97BCEDB5857010E79ECE0F52CF6E93B87C;\n\nIL2CPP_EXTERN_C_BEGIN\nIL2CPP_EXTERN_C_END\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Winvalid-offsetof\"\n#pragma clang diagnostic ignored \"-Wunused-variable\"\n#endif\nstruct U3CModuleU3E_t462BCCFB9B78348533823E0754F65F52A5348F89 \n{\n};\nstruct AudioSampleProvider_t602353124A2F6F2AEC38E56C3C21932344F712E2",
    "#include <iostream>\r\n\r\nint main() {\r\n  int var = 10;\r\n\r\n  // Declare pointers\r\n  int* ptrVar = &var;  // ptrVar points to the address of var\r\n  int** pPtrVar = &ptrVar;  // pPtrVar points to the address of ptrVar\r\n\r\n  // Print initial values\r\n  std::cout << \"Contents of var: \" << var << std::endl;\r\n  std::cout << \"Address of var: \" << &var << std::endl;\r\n\r\n  std::cout << \"Contents of ptrVar: \" << ptrVar << std::endl;\r\n  std::cout << \"Address of ptrVar: \" << &ptrVar << std::endl;\r\n  std::cout << \"Value pointed to by ptrVar: \" << *ptrVar << std::endl;\r\n\r\n  std::cout << \"Contents of pPtrVar: \" << pPtrVar << std::endl;\r\n  std::cout << \"Address of pPtrVar: \" << &pPtrVar << std::endl;\r\n  std::cout << \"Value pointed to by pPtrVar: \" << *pPtrVar << std::endl;\r\n\r\n  // Another level of pointers\r\n  int*** ppPtrVar = &pPtrVar;\r\n\r\n  std::cout << \"Contents of ppPtrVar: \" << ppPtrVar << std::endl;\r\n  std::cout << \"Address of ppPtrVar: \" << &ppPtrVar << std::endl;\r\n  std::cout << \"Value pointed to by ppPtrVar: \" << *ppPtrVar << std::endl;\r\n\r\n  return 0;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"StdAfx.h\"\r\n#include \"GLMath.h\"\r\nconst float M_PI=3.1415926;\r\n//\u8ba1\u7b97\u4e09\u89d2\u5f62\u9762\u79ef\r\nfloat calculate3dTriangleArea(const CVector4&v1,const CVector4&v2,const CVector4&v3){\r\n\tfloat area=0.5*getLength(cross(v2-v1,v3-v1));\r\n\treturn area;\r\n}\r\n//\u4ece\u76f8\u673a\u5750\u6807\u7cfb\u8868\u793a\u8f6c\u6362\u5230\u4e16\u754c\u5750\u6807\u7cfb\u8868\u793a\u7684\u77e9\u9635\r\nMatrix4 calculateViewMatrixInverse(const CVector4&_eyePos,const CVector4&_center,const CVector4&_up)\r\n\r\n{//up no need to be unit vector\r\n\r\n    //assert(_eyePos.w()==1);\r\n\r\n    //assert(_center.w()==1);\r\n\r\n   // assert(_up.w()==0);\r\n\r\n    CVector4 forward,side,up;\r\n\r\n    forward=_center-_eyePos;\r\n\r\n    up=_up;\r\n\r\n    forward=normalize(forward);\r\n\r\n    /* Side = forward x up */\r\n\r\n    side=cross(up, forward);\r\n\r\n    side=normalize(side);\r\n\r\n    /* Recompute up as: up = side x forward */\r\n\r\n    up=cross(forward, side);\r\n\r\n    //calculate back (use back as Z axis)\r\n\r\n    CVector4 back=forward;//Cc3dVector4(0,0,0,0)-forward;\r\n\r\n    //the matrix transform point from camera space to world space is\r\n\r\n    float m[16]={\r\n\r\n        side.x(),side.y(),side.z(),0,//col1\r\n\r\n        up.x(),up.y(),up.z(),0,\r\n\r\n        back.x(),back.y(),back.z(),0,\r\n\r\n        _eyePos.x(),_eyePos.y(),_eyePos.z(),1\r\n\r\n    };\r\n\r\n    Matrix4 viewMatInverse(m);\r\n\r\n    return viewMatInverse;\r\n\r\n}\r\n\r\n//\u4ece\u4e16\u754c\u5750\u6807\u7cfb\u8868\u793a\u8f6c\u6362\u5230\u76f8\u673a\u5750\u6807\u7cfb\u8868\u793a\r\n\r\nMatrix4 calculateViewMatrix(const CVector4&eyePos,const CVector4&center,const CVector4&up)\r\n\r\n{//up no need to be unit vector\r\n\r\n    //assert(eyePos.w()==1);\r\n\r\n    //assert(center.w()==1);\r\n\r\n    //assert(up.w()==0);\r\n\r\n    Matrix4 viewMatInverse=calculateViewMatrixInverse(eyePos, center, up);\r\n\r\n    //inverse viewMatInverse to get viewMat\r\n\r\n    //notice that the left up 3x3 sub matrix of viewMatInverse is orthogonal matrix,\r\n\r\n    //so we have easy way to inverse it, see:\r\n\r\n    //http://user.qzone.qq.com/350479720/blog/1329478296\r\n\r\n    //calculate the fourth col of view mat\r\n\r\n    const float *mInv=viewMatInverse.getArray();\r\n\r\n    float x=-(mInv[12]*mInv[0]+mInv[13]*mInv[1]+mInv[14]*mInv[2]);\r\n\r\n    float y=-(mInv[12]*mInv[4]+mInv[13]*mInv[5]+mInv[14]*mInv[6]);\r\n\r\n    float z=-(mInv[12]*mInv[8]+mInv[13]*mInv[9]+mInv[14]*mInv[10]);\r\n\r\n    //view mat\r\n\r\n    float m[16]={\r\n\r\n        mInv[0],mInv[4],mInv[8],0,//col 1\r\n\r\n        mInv[1],mInv[5],mInv[9],0,//col 2\r\n\r\n        mInv[2],mInv[6],mInv[10],0,//col 3\r\n\r\n        x,y,z,1//col 4\r\n\r\n    };\r\n\r\n    Matrix4 viewMat(m);\r\n\r\n    return viewMat;\r\n\r\n}\r\n//\u8ba1\u7b97\u7ed5\u54cd\u4eaeaxis\u7684\u65cb\u8f6c\u77e9\u9635\r\nMatrix4 calculateRotationMatrix(const CVector4&axis,float cosA,float sinA){\r\n\r\n    //axis must be a unit vector\r\n\r\n    //assert(axis.w()==0);\r\n\r\n    //assert(getLength2(axis)==1);\r\n\r\n    //\r\n\r\n    float nx=axis.x();\r\n\r\n    float ny=axis.y();\r\n\r\n    float nz=axis.z();\r\n\r\n    \r\n\r\n    float _cosA=1-cosA;\r\n\r\n    float nx_cosA=nx*_cosA;\r\n\r\n    float nz_cosA=nz*_cosA;\r\n\r\n    float nxnx_cosA=nx*nx_cosA;\r\n\r\n    float nxny_cosA=ny*nx_cosA;\r\n\r\n    float nxnz_cosA=nz*nx_cosA;\r\n\r\n    float nyny_cosA=ny*ny*_cosA;\r\n\r\n    float nynz_cosA=ny*nz_cosA;\r\n\r\n    float nznz_cosA=nz*nz_cosA;\r\n\r\n    float nxsinA=nx*sinA;\r\n\r\n    float nzsinA=nz*sinA;\r\n\r\n    float nysinA=ny*sinA;\r\n\r\n    float rotMat[16]={\r\n\r\n        nxnx_cosA+cosA,nxny_cosA+nzsinA,nxnz_cosA-nysinA,0,//col 1\r\n\r\n        nxny_cosA-nzsinA,nyny_cosA+cosA,nynz_cosA+nxsinA,0,//col 2\r\n\r\n        nxnz_cosA+nysinA,nynz_cosA-nxsinA,nznz_cosA+cosA,0,//col 3\r\n\r\n        0,0,0,1//col 4\r\n\r\n    };\r\n\r\n    return Matrix4(rotMat);\r\n\r\n}\r\n//\u8ba1\u7b97\u5e73\u79fb\u77e9\u9635\r\nMatrix4 calculateTranslateMatrix(const CVector4&translate){\r\n\r\n    //assert(translate.w()==0);\r\n\r\n    //1 0 0 dx\r\n\r\n    //0 1 0 dy\r\n\r\n    //0 0 1 dz\r\n\r\n    //0 0 0  1\r\n\r\n    float dx=translate.x();\r\n\r\n    float dy=translate.y();\r\n\r\n    float dz=translate.z();\r\n\r\n    float TMat[16]={\r\n\r\n        1,0,0,0,//col 1\r\n\r\n        0,1,0,0,\r\n\r\n        0,0,1,0,\r\n\r\n        dx,dy,dz,1\r\n\r\n    };\r\n\r\n    return Matrix4(TMat);\r\n\r\n}\r\n//\u8ba1\u7b97\u7f29\u653e\u77e9\u9635\r\nMatrix4 calculateScaleMatrix(float kx,float ky,float kz){\r\n\r\n    //1 0 0 0\r\n\r\n    //0 1 0 0\r\n\r\n    //0 0 1 0\r\n\r\n    //0 0 0 1\r\n\r\n    float SMat[16]={\r\n\r\n        kx,0,0,0,//col 1\r\n\r\n        0,ky,0,0,\r\n\r\n        0,0,kz,0,\r\n\r\n        0,0,0,1\r\n\r\n    };\r\n\r\n    return Matrix4(SMat);\r\n\r\n}\r\n//\u51e0\u6240\u900f\u5c04\u6295\u5f71\u77e9\u9635\r\nMatrix4 calculatePerspectiveProjectionMatrix(float fovy,float aspect,float zNear,float zFar)\r\n\r\n//if calculation failed, return zero matrix\r\n\r\n{\r\n\r\n    double sine, cotangent, deltaZ;\r\n\r\n    double radians = (fovy/2) * M_PI/180;\r\n\r\n    deltaZ = zFar - zNear;\r\n\r\n    sine = sinf(radians);\r\n\r\n    if ((deltaZ == 0) || (sine == 0) || (aspect == 0)) {\r\n\r\n        return zeroMat();\r\n\r\n    }\r\n\r\n    cotangent = cosf(radians) / sine;\r\n\r\n    float m[16]={\r\n\r\n        cotangent / aspect,0,0,0,//col 1\r\n\r\n        0,cotangent,0,0,//col 2\r\n\r\n        0,0,-(zFar + zNear) / deltaZ,-1,//col 3\r\n\r\n        0,0, -2 * zNear * zFar / deltaZ,0};//col 4\r\n\r\n    return Matrix4(m);\r\n\r\n}\r\n\r\nMatrix4 calculateOrthoProjectionMatrix(float left,float right,float bottom,float top,float near1,float far1){\r\n\r\n\t//\"near\" and \"far\" have been defined in windows, so we use other var name \r\n\r\n    float tx=-((right+left)/(right-left));\r",
    "#include \"../../includes/irc.hpp\"\n\nvoid Server::topic(User *user, vector<string> splitedCommand)\n{\n\tstring channel_name = splitedCommand[1];\n\tstring topic;\n\tfor (vector<string>::const_iterator it = splitedCommand.begin() + 1; it != splitedCommand.end(); ++it) {\n\t\tif (it != splitedCommand.begin() + 1) {\n\t\t\ttopic += \" \";  // Add a space between elements\n\t\t}\n\t\ttopic += *it;  // Append the element to the topic\n\t}\n\n\tcout << YELLOW << topic << endl;\n\tif (!channelExist(channel_name))\n\t{\n\t\tsendStringSocket(user->getSocket(),ERR_NOSUCHCHANNEL(user->getNickname(), channel_name));\n\t\treturn;\n\t}\n\n\tif(!_channels[channel_name]->isUserInChannel(user))\n\t{\n\t\tsendStringSocket(user->getSocket(), ERR_NOTONCHANNEL(user->getNickname(), channel_name));\n\t\treturn;\n\t}\n\tif (topic.empty())\n\t{\n\t\tif (_channels[channel_name]->getTopic().empty() == false)\n\t\t\tsendStringSocket(user->getSocket(), RPL_TOPIC(user->getNickname(), channel_name, _channels[channel_name]->getTopic()));\n\t\telse\n\t\t\tsendStringSocket(user->getSocket(), RPL_NOTOPIC(user->getNickname(), channel_name));\t\n\t}\n\telse \n\t{\n\t\tif (_channels[channel_name]->getIsTopicProtected() && !(_channels[channel_name]->isUserOperator(user)))\n\t\t{\n\t\t\tsendStringSocket(user->getSocket(), ERR_CHANOPRIVSNEEDED(user->getNickname(), channel_name));\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_channels[channel_name]->setTopic(topic);\n\t\t\tsendMessageToChannel(_channels[channel_name], RPL_TOPIC(user->getNickname(), channel_name, _channels[channel_name]->getTopic()));\n\t\t}\n\n\t}\n}",
    "#include \"Port_thread.h\"\r\n#include \"qdebug.h\"\r\n\r\n\r\nvoid Port_thread::get_command(){\r\n    QList<QSerialPortInfo> ports_list = QSerialPortInfo::availablePorts();;\r\n    QSerialPort* ser;\r\n    Start = true;\r\n    while (!end) {\r\n        switch (command) {         \r\n        case -1:\r\n            QThread::msleep(1);\r\n            break;\r\n        case 0:\r\n            ser->close();\r\n            ser->deleteLater();\r\n            emit back_value(0);\r\n            command = -1;\r\n            break;\r\n        case 1:\r\n            ser = new QSerialPort;\r\n            ser->setPort(ports_list[port_id]);\r\n            ser->setBaudRate(baudrate);\r\n            ser->setDataBits(databits);\r\n            ser->setParity(parity);\r\n            ser->setStopBits(stopbits);\r\n            ser->setFlowControl(flowcontrol);\r\n            if (!ser->open(QIODevice::ReadWrite)) {\r\n                qDebug() <<  \"Failed to open serial port!\";\r\n                emit back_value(-1);\r\n                command = -1;\r\n                break;\r\n            }\r\n            qDebug() << \"open serial port successfully!.\";\r\n            emit back_value(1);\r\n            first = true;\r\n            command = 2;\r\n            break;\r\n        case 2:\r\n            if (first){\r\n                first =false;\r\n                data = (\"L0\"+QString(\"%1\").arg(L0, 3, 10, QChar('0')) + \"I500\"+ \" \"+\"L1\"+QString(\"%1\").arg(L1, 3, 10, QChar('0')) + \"I500\" + \" \"+\"L2\"+QString(\"%1\").arg(L2, 3, 10, QChar('0')) + \"I500\" + \" \"\r\n                        \"R0\"+QString(\"%1\").arg(R0, 3, 10, QChar('0')) + \"I500\"+ \" \"+\"R1\"+QString(\"%1\").arg(R1, 3, 10, QChar('0')) + \"I500\" + \" \"+\"R2\"+QString(\"%1\").arg(R2, 3, 10, QChar('0')) + \"I500\" +\r\n                        + \"\\r\\n\"\r\n                        ).toLocal8Bit();\r\n                if (!ser->write(data)){\r\n                    ser->close();\r\n                    ser->deleteLater();\r\n                    emit back_value(-1);\r\n                    qDebug() << \"serial disconnect!.\";\r\n                    command = -1;\r\n                    break;\r\n                }\r\n                ser->waitForBytesWritten(10);\r\n\r\n                qDebug() << data;\r\n                QThread::msleep(500-40);\r\n            }\r\n            else{\r\n                if (play){\r\n                    play = false;\r\n                    data = (\"L0\"+QString(\"%1\").arg(L0, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time) + \" \" + \"L1\"+QString(\"%1\").arg(L1, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time)+ \" \"+\r\n                            \"L2\"+QString(\"%1\").arg(L2, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time) + \" \" + \"R0\"+QString(\"%1\").arg(R0, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time)+ \" \"+\r\n                            \"R1\"+QString(\"%1\").arg(R1, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time) + \" \" + \"R2\"+QString(\"%1\").arg(R2, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time)+ \" \"+\r\n                            \"A1\"+QString(\"%1\").arg(A1, 3, 10, QChar('0')) + \"I\" + QString::number(sleep_time) + \"\\r\\n\"\r\n                            ).toLocal8Bit();\r\n                if (!ser->write(data)){\r\n                        ser->close();\r\n                        ser->deleteLater();\r\n                        emit back_value(-1);\r\n                        qDebug() << \"serial disconnect!.\";\r\n                        command = -1;\r\n                        break;\r\n                    }\r\n                ser->waitForBytesWritten(10);\r\n                qDebug() << data;\r\n                QThread::msleep(sleep_time-40);\r\n                }                             \r\n            }\r\n            command = 2;\r\n            break;\r\n        }\r\n    }\r\n    Start = false;\r\n}\r\n\r\n\r\n\r\nPort_thread::Port_thread(QObject* parent) : QThread(parent)\r\n{\r\n    //port\r\n    port_id = 0;\r\n    baudrate = 115200;\r\n    databits = QSerialPort::DataBits::Data8;\r\n    parity = QSerialPort::Parity::NoParity;\r\n    stopbits = QSerialPort::StopBits::OneStop;\r\n    flowcontrol = QSerialPort::FlowControl::NoFlowControl;\r\n\r\n\r\n    //Axis\r\n    L0 = 500;\r\n    L1 = 500;\r\n    L2 = 500;\r\n    R0 = 500;\r\n    R1 = 500;\r\n    R2 = 500;\r\n    A1 = 0;\r\n\r\n    //while\r\n    end = false;\r\n    Start = false;\r\n    play = false;\r\n    first = true;\r\n    command = -1;\r\n    sleep_time = 500;\r\n\r\n    data = QString(\"\").toLocal8Bit();\r\n}\r\n",
    "#include <GL/glew.h>\n#ifdef __APPLE__\n#include <GLUT/glut.h>\n#else\n#include <GL/freeglut.h>\n#endif\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <glm/gtx/constants.hpp>\n#include <glm/gtx/string_cast.hpp>\n\n#include \"Camera.h\"\n#include \"Text.h\"\n#include \"ParticleSystem.h\"\n\n#include <iostream>\nusing namespace std;\nusing namespace glm;\n\nint g_winWidth = 1024;\nint g_winHeight = 512;\nGLfloat radius = 2.0f;\nint width = 64;\nint height = 32;\t\n\nGLfloat originPosition[] = { 0.0f, 5.0f, 20.0f, 1.0f };\nGLfloat wireframePosition[] = { 0.0f, 5.0f, -8.0f, 0.0f };\nvec3 min_point = vec3(-10.0f, 0.0f, -5.0f);\nvec3 max_point = vec3(10.0f, 10.0f, -5.0f);\n\nCamera g_cam;\nText g_text;\n\nunsigned char g_keyStates[256];\n\nunsigned int curTime = 0; //the milliseconds since the start\nunsigned int preTime = 0;\nParticleSystem parSys;\n\nchar v_shader_file[] = \"..\\\\..\\\\shaders\\\\v_shader.vert\";\nchar f_shader_file[] = \"..\\\\..\\\\shaders\\\\f_shader.frag\";\nchar c_shader_file[] = \"..\\\\..\\\\shaders\\\\c_shader.comp\";\n\nvoid initialization()\n{\n\t//std::cout<<\"Width\"<<width<<\" and Height\"<<height<<std::endl;\n\tparSys.create(width, height, min_point, max_point, c_shader_file, v_shader_file, f_shader_file);\n\n\tg_cam.set(38.0f, 13.0f, 4.0f, 0.0f, 0.0f, 0.0f, g_winWidth, g_winHeight, 45.0f, 0.01f, 10000.0f);\n\tg_text.setColor(0.0f, 0.0f, 0.0f);\n\n\t// add any stuff you want to initialize ...\n}\n\n/****** GL callbacks ******/\nvoid initialGL()\n{\n\tglDisable(GL_LIGHTING);\n\tglEnable(GL_DEPTH_TEST);\n\n\tglClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n}\n\nvoid idle()\n{\n\t// add any stuff to update at runtime ....\n\tcurTime = glutGet(GLUT_ELAPSED_TIME);\n\tfloat deltaT = (float)(curTime - preTime) / 1000.0f; // in seconds\n\tvec3 originPos = vec3(originPosition[0], originPosition[1], originPosition[2]);\n\tvec3 wireFramePos = vec3(wireframePosition[0], wireframePosition[1], wireframePosition[2]);\n\tfloat r = radius;\n\tparSys.update(deltaT, originPos, r, wireFramePos);\n\n\tg_cam.keyOperation(g_keyStates, g_winWidth, g_winHeight);\n\n\tglutPostRedisplay();\n\n\tpreTime = curTime;\n}\n\nvoid display()\n{\n\tglClearColor(1.0, 1.0, 1.0, 0.0);\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\n\tglUseProgram(0);\n\tglDisable(GL_LIGHTING);\n\tglEnable(GL_DEPTH_TEST);\n\n\tglMatrixMode(GL_MODELVIEW);\n\t\t\n\tglColor3f(1.0f, 0.0f, 0.0f);\n\t\n\tmat4 mat1 = translate(mat4(1.0f), vec3(originPosition[0], originPosition[1], originPosition[2]));\n\tmat4 modelmat1 = scale(mat1, vec3(1.0f, 1.0f, 1.0f));\n\tmat4 viewMatrix1 = g_cam.viewMat * modelmat1;\n\t\n\tglLoadMatrixf(value_ptr(viewMatrix1));\n\tglutSolidSphere(0.3, 50, 50);\n\n\n\tglMatrixMode(GL_MODELVIEW);\n\n\tglColor3f(1.0f, 0.0f, 0.0f);\n\n\tmat4 mat2 = translate(mat4(1.0f), vec3(0,0,0));\n\tmat4 modelmat2 = scale(mat2, vec3(1.0f, 1.0f, 1.0f));\n\tmat4 viewMatrix2 = g_cam.viewMat * modelmat2;\n\n\tglLoadMatrixf(value_ptr(viewMatrix2));\n\tvec3 corner1 = vec3(min_point.x, min_point.y, min_point.z);\n\tvec3 corner2 = vec3(max_point.x, min_point.y, min_point.z);\n\tvec3 corner3 = vec3(min_point.x, max_point.y, min_point.z);\n\tvec3 corner4 = vec3(max_point.x, max_point.y, min_point.z);\n\n\tglBegin(GL_LINES);\n\t// Line to corner 1\n\t\tglVertex3f(originPosition[0], originPosition[1], originPosition[2]);\n\t\tglVertex3f(corner1.x, corner1.y, corner1.z);\n\n\t\tglVertex3f(originPosition[0], originPosition[1], originPosition[2]);\n\t\tglVertex3f(corner2.x, corner2.y, corner2.z);\n\n\t\tglVertex3f(originPosition[0], originPosition[1], originPosition[2]);\n\t\tglVertex3f(corner3.x, corner3.y, corner3.z);\n\n\t\tglVertex3f(originPosition[0], originPosition[1], originPosition[2]);\n\t\tglVertex3f(corner4.x, corner4.y, corner4.z);\n\tglEnd();\n\n\tglMatrixMode(GL_MODELVIEW);\n\n\tglColor3f(0.0f, 1.0f, 0.0f);\n\n\tmat4 mat3 = translate(mat4(1.0f), vec3(wireframePosition[0], wireframePosition[1], wireframePosition[2]));\n\tmat4 modelmat3 = scale(mat3, vec3(1.0f, 1.0f, 1.0f));\n\tmat4 viewMatrix3 = g_cam.viewMat * modelmat3;\n\n\tglLoadMatrixf(value_ptr(viewMatrix3));\n\tglutWireSphere(radius, 30, 30);\n\n\tparSys.draw(1.0f, g_cam.viewMat, g_cam.projMat);\n\n\tg_cam.drawGrid();\n\tg_cam.drawCoordinateOnScreen(g_winWidth, g_winHeight);\n\tg_cam.drawCoordinate();\n\n\t// display the text\n\tif (g_cam.isFocusMode()) {\n\t\tstring str = \"Cam mode: Focus\";\n\t\tg_text.draw(10, 30, const_cast<char*>(str.c_str()), g_winWidth, g_winHeight);\n\t}\n\telse if (g_cam.isFPMode()) {\n\t\tstring str = \"Cam mode: FP\";\n\t\tg_text.draw(10, 30, const_cast<char*>(str.c_str()), g_winWidth, g_winHeight);\n\t}\n\n\t// display the Resolution\n\tstring str = \"Resolution: \" + std::to_string(width) + \"x\" + std::to_string(height);\n\tg_text.draw(10, 50, const_cast<char*>(str.c_str()), g_winWidth, g_winHeight);\n\n\t// display the number of particles\n\tstr = \"# of Particles ((w+1)*(h+1)): \" + std::to_string((width+1) * (height+1));\n\tg_text.draw(10, 70, const_cast<char*>(str.c_str()), g_winWidth, g_winHeight);\n\n\tglPopMatrix();\n\tglutSwapBuffers();\n}\n\nvoid reshape(int w, int h)\n{\n\tg_winWidth = w;\n",
    "#include <stdio.h>\n#include <fstream>\n#include <string>\n#include <memory>\n#include <cmath>\n\n#include \"utils.h\"\n// use only standard library\nusing namespace std;\n\nvoid append_padding_bits(vector<u8> &v, size_t b){\n\tsize_t len = b+1;\n\twhile(len % 64 != 56) len += 1;\n\tsize_t numZerosBytes = len - b - 1;\n\t\n\tvector<u8> zeros(numZerosBytes, (u8)0);\n\tv.push_back((u8)(1<<7));\n\tv.insert(v.end(), zeros.begin(), zeros.end());\n\t\n\tLOG(printf(\"len after appending padding bits = %lu\\n\", v.size()));\t\n}\n\nvoid append_bit_length(vector<u8> &v, size_t b){\n\tu8 chunks[8];\n\tchunks[0] = (u8)b;\n\tchunks[1] = (u8)(b >> 8);\n\tchunks[2] = (u8)(b >> 16);\n\tchunks[3] = (u8)(b >> 24);\n\tchunks[4] = (u8)(b >> 32);\n\tchunks[5] = (u8)(b >> 40);\n\tchunks[6] = (u8)(b >> 48);\n\tchunks[7] = (u8)(b >> 56);\n\tv.insert(v.end(), chunks, chunks+8);\n\tLOG(printf(\"len after appending length = %lu\\n\", v.size()));\n}\n\nvoid construct_table(u32 T[]){\n\tfor(int i = 1; i <= 64; i++){\n\t\tdouble t = 4294967296; // UINT32_MAX + 1 == 2^32\n\t\tt = t * abs(sin((double)i));\n\t\tT[i] = t;\n\t}\n}\n\nint F(int x, int y, int z) { return (x & y) | (~x & z); }\nint G(int x, int y, int z) { return (x & z) | (y & ~z); }\nint H(int x, int y, int z) { return x ^ y ^ z; }\nint I(int x, int y, int z) { return y ^ (x | ~z); }\n\n#define R1(a,b,c,d,k,s,i) \\\n\ta = b + (rotate_shift(a + F(b,c,d) + x[k] + T[i], s))\n#define R2(a,b,c,d,k,s,i) \\\n\ta = b + (rotate_shift(a + G(b,c,d) + x[k] + T[i], s))\n#define R3(a,b,c,d,k,s,i) \\\n\ta = b + (rotate_shift(a + H(b,c,d) + x[k] + T[i], s))\n#define R4(a,b,c,d,k,s,_i) \\\n\ta = b + (rotate_shift(a + I(b,c,d) + x[k] + T[_i], s))\n\nint main(int argc, i8* argv[]){\n\tif(argc != 2){\n\t\tprintf(\"Usage: babymd5 *file*\\n\");\n\t\treturn 1;\n\t}\n\tifstream input(argv[1]);\n\tif(!input.good()){\n\t\tprintf(\"Error reading file.\\n\");\n\t\treturn 1;\n\t}\n\tstring msg;\n\twhile(!input.eof() && input.good()){\n\t\tstring s; getline(input, s);\n\t\tmsg.append(s);\n\t}\n\tsize_t b = msg.size();\n\n\tauto mv = string_to_vector(msg);\n\tappend_padding_bits(mv, b);\n\tappend_bit_length(mv, b*8);\n\n\tauto mw = chars_to_words(mv);\n\tLOG(printf(\"The words are:\"));\n\tfor(u32 i = 0; i < mw.size();i++) LOG(printf(\"%u, \", mw[i]));\n\tLOG(printf(\"\\n\"));\n\tLOG(printf(\"Num of words: %lu\\n\", mw.size()));\n\n\t/* Step 3\n          word A: 01 23 45 67\n          word B: 89 ab cd ef\n          word C: fe dc ba 98\n          word D: 76 54 32 10\n\t*/\n\tu32 A = 0x67452301;\n\tu32 B = 0xefcdab89;\n\tu32 C = 0x98badcfe;\n\tu32 D = 0x10325476;\n\t\n\t// Step 4\n\t\t\n\tu32 x[16], T[65];\n\tconstruct_table(T);\n\tfor(unsigned i = 0; i < mw.size()/16; i++){\n\t\tfor(int j = 0; j < 16; j++)\n\t\t\tx[j] = mw[i*16 + j];\n\t\tu32 AA = A, BB = B, CC = C, DD = D;\n\t\t// Some BLACK MAGIC!!!\n\t\t//Round 1\n\t\tR1(A,B,C,D,0,7,1);  R1(D,A,B,C,1,12,2);  R1(C,D,A,B,2,17,3);  R1(B,C,D,A,3,22,4);\n\t\tR1(A,B,C,D,4,7,5);  R1(D,A,B,C,5,12,6);  R1(C,D,A,B,6,17,7);  R1(B,C,D,A,7,22,8);\n\t\tR1(A,B,C,D,8,7,9);  R1(D,A,B,C,9,12,10); R1(C,D,A,B,10,17,11);R1(B,C,D,A,11,22,12);\n\t\tR1(A,B,C,D,12,7,13);R1(D,A,B,C,13,12,14);R1(C,D,A,B,14,17,15);R1(B,C,D,A,15,22,16);\n\n\t\t//Round 2\n\t\tR2(A,B,C,D,1,5,17); R2(D,A,B,C,6,9,18); R2(C,D,A,B,11,14,19);R2(B,C,D,A,0,20,20);\n\t\tR2(A,B,C,D,5,5,21); R2(D,A,B,C,10,9,22);R2(C,D,A,B,15,14,23);R2(B,C,D,A,4,20,24);\n\t\tR2(A,B,C,D,9,5,25); R2(D,A,B,C,14,9,26);R2(C,D,A,B,3,14,27); R2(B,C,D,A,8,20,28);\n\t\tR2(A,B,C,D,13,5,29);R2(D,A,B,C,2,9,30); R2(C,D,A,B,7,14,31); R2(B,C,D,A,12,20,32);\n\n\t\t//Round 3\n\t\tR3(A,B,C,D,5,4,33); R3(D,A,B,C,8,11,34); R3(C,D,A,B,11,16,35);R3(B,C,D,A,14,23,36);\n\t\tR3(A,B,C,D,1,4,37); R3(D,A,B,C,4,11,38); R3(C,D,A,B,7,16,39); R3(B,C,D,A,10,23,40);\n\t\tR3(A,B,C,D,13,4,41);R3(D,A,B,C,0,11,42); R3(C,D,A,B,3,16,43); R3(B,C,D,A,6,23,44);\n\t\tR3(A,B,C,D,9,4,45); R3(D,A,B,C,12,11,46);R3(C,D,A,B,15,16,47);R3(B,C,D,A,2,23,48);\n\t\t\n\t\t//Round 4\n\t\tR4(A,B,C,D,0,6,49); R4(D,A,B,C,7,10,50); R4(C,D,A,B,14,15,51);R4(B,C,D,A,5,21,52);\n\t\tR4(A,B,C,D,12,6,53);R4(D,A,B,C,3,10,54); R4(C,D,A,B,10,15,55);R4(B,C,D,A,1,21,56);\n\t\tR4(A,B,C,D,8,6,57); R4(D,A,B,C,15,10,58);R4(C,D,A,B,6,15,59); R4(B,C,D,A,13,21,60);\n\t\tR4(A,B,C,D,4,6,61); R4(D,A,B,C,11,10,62);R4(C,D,A,B,2,15,63); R4(B,C,D,A,9,21,64);\n\t\t\n\t\tA = A + AA;\n\t\tB = B + BB;\n\t\tC = C + CC;\n\t\tD = D + DD;\n\t}\n\t\n\tstring digest = word_to_string(A);\n\tdigest += word_to_string(B);\n\tdigest += word_to_string(C);\n\tdigest += word_to_string(D);\n\n\tprintf(\"MD5 Hash is: %s\\n\", digest.c_str());\n\treturn 0;\n}",
    "/*\r\n     Develop a calculator program that performs basic arithmetic\r\n     operations such as addition, subtraction, multiplication, and\r\n     division. Allow the user to input two numbers and choose an\r\n     operation to perform.\r\n*/\r\n\r\n#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\n\r\nint calculator(int n1, int n2, char op) {\r\n     int res = INT_MIN;\r\n     switch (op)\r\n     {\r\n     case '+':\r\n          res = n1 + n2;\r\n          break;\r\n     case '-':\r\n          res = n1-+ n2;\r\n          break;\r\n     case '*':\r\n          res = n1 * n2;\r\n          break;\r\n     case '/':\r\n          res = n1 / n2;\r\n          break;\r\n     \r\n     default:\r\n          cout << \"Wrong Operation!\" << endl;\r\n          break;\r\n     }\r\n     return res;\r\n}\r\n\r\nint main() {\r\n     int n1, n2;\r\n     char operation;\r\n     cout << \"Enter Number 1: \"; cin >> n1;\r\n     cout << \"Enter Number 2: \"; cin >> n2;\r\n     cout << \"Enter Operation you wanna perform: \"; cin >> operation;\r\n     int res = calculator(n1, n2, operation);\r\n     cout << n1 << operation << n2 << \": \" << res;\r\n}",
    "#include <DMC/Manager.h>\n\n#include \"Model/Observable.cpp\"\n#include \"Model/Updates.cpp\"\n\n#include <cstdio>\n#include <future>\n#include <mutex>\n\nusing namespace DMC;\nusing namespace Holstein;\n\nstd::mutex lock;\n\nstd::string to_string(double g) {\n  std::stringstream stream;\n  stream << std::fixed << std::setprecision(1) << g;\n  return stream.str();\n}\n\nvoid lsimulation(SimOptions opt) {\n  bool standard = opt(\"g\") < 0;\n\n  Manager<Diagram> manager;\n\n  manager.add_update<chg_t>();\n  manager.add_update<add_n>();\n  manager.add_update<rem_n>();\n\n  manager.add_observable<Eg>();\n  manager.add_observable<Green>();\n\n  if (standard)\n    opt(\"g\") = 0.5;\n\n  manager.simulate(opt);\n\n  lock.lock();\n  if (standard)\n    manager.print(\"./Holstein/Results/Local/\");\n  else\n    manager.print(\"./Holstein/Results/Local/\" + to_string(opt(\"g\")) + \"/\");\n  lock.unlock();\n}\n\nvoid nsimulation(SimOptions opt) {\n  bool standard = opt(\"g\") < 0;\n\n  Manager<Diagram> manager;\n\n  manager.add_update<chg_t>();\n  manager.add_update<add_n>();\n  manager.add_update<nnchg_n>();\n  manager.add_update<rem_n>();\n\n  manager.add_observable<Eg>();\n  manager.add_observable<Green>();\n\n  if (standard)\n    opt(\"g\") = 0.5;\n  manager.simulate(opt);\n\n  lock.lock();\n  if (standard)\n    manager.print(\"./Holstein/Results/Neural/\");\n  else\n    manager.print(\"./Holstein/Results/Neural/\" + to_string(opt(\"g\")) + \"/\");\n  lock.unlock();\n}\n\nvoid prepare_file(double g = -1) {\n  std::string path = \"./Holstein/Results/\";\n  std::vector<std::string> updates = {\"Local\", \"Neural\"};\n  std::vector<std::string> observa = {\"Eg\", \"Green\"};\n\n  for (auto up : updates) {\n    for (auto ob : observa) {\n      FILE *file;\n      if (g < 0)\n        file = fopen((path + up + \"/\" + ob + \".dat\").data(), \"w\");\n      else\n        file = fopen(\n            (path + up + \"/\" + to_string(g) + \"/\" + ob + \".dat\").data(), \"w\");\n\n      if (!file) {\n        printf(\"prepare_file: the folder %s/%s was not found!\\n\", up.data(),\n               to_string(g).data());\n        exit(1);\n      }\n\n      if (ob == \"Green\") {\n        for (int i = 0; i != 199; i++)\n          fprintf(file, \"%f \", (i + 0.5) * (10. / 199));\n        fprintf(file, \"\\n\");\n      }\n\n      fclose(file);\n    }\n  }\n}\n\nvoid main_simulation(SimOptions opt, int nThread, double g = -1) {\n  prepare_file(g);\n\n  opt(\"g\") = g;\n\n  printf(\"main_simulation: simulation at g of %f\\n\", g);\n\n  // Defining the threads\n  std::vector<std::future<void>> futures(nThread);\n\n  // Do stuff\n  printf(\"main_simulation: started local...\\n\");\n  for (auto &f : futures)\n    f = std::async(lsimulation, opt);\n  for (auto &f : futures)\n    f.wait();\n\n  printf(\"main_simulation: started neural...\\n\");\n  for (auto &f : futures)\n    f = std::async(nsimulation, opt);\n  for (auto &f : futures)\n    f.wait();\n  printf(\"main_simulation: finished!\\n\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  // Read options\n  SimOptions opt(\"./Holstein/sim.ini\");\n\n  // Do simulations\n  if (argc <= 1) {\n    printf(\"Error: needed number of thread!\\n\");\n    return 1;\n  }\n\n  // Reading inputs\n  int nThread = std::stoi(argv[1]);\n\n  std::vector<double> gs = {-1, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};\n\n  for (double g : gs)\n    main_simulation(opt, nThread, g);\n\n  return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/****************************************************************************\n *\n * (c) 2009-2020 QGROUNDCONTROL PROJECT <http://www.qgroundcontrol.org>\n *\n * QGroundControl is licensed according to the terms in the file\n * COPYING.md in the root of the source code directory.\n *\n ****************************************************************************/\n\n/**\n *  @file\n *  @author Gus Grubba <gus@auterion.com>\n *  Original work: The OpenPilot Team, http://www.openpilot.org Copyright (C)\n * 2012.\n */\n\n//#define DEBUG_GOOGLE_MAPS\n\n#include \"QGCMapUrlEngine.h\"\n#include \"QGCLoggingCategory.h\"\n\n#include <QByteArray>\n#include <QString>\n\nQGC_LOGGING_CATEGORY(QGCMapUrlEngineLog, \"QGCMapUrlEngineLog\")\n\nconst char* UrlFactory::kCopernicusElevationProviderKey = \"Copernicus Elevation\";\nconst char* UrlFactory::kCopernicusElevationProviderNotice = \"\u00a9 Airbus Defence and Space GmbH\";\n\n//-----------------------------------------------------------------------------\nUrlFactory::UrlFactory() : \n    _timeout(5 * 1000) \n{\n\n    // The internal Qt code for map plugins has the concept of a Map Id. These ids must start at 1 and be sequential.\n    // Map Ids are used to identify the map provider to use. Because of this we keep the providers in a simple list\n    // such that the index into the list with the map id - 1.\n\n#ifndef QGC_NO_GOOGLE_MAPS\n    _providers.append(ProviderPair(\"Google Street Map\", new GoogleStreetMapProvider(this)));\n    _providers.append(ProviderPair(\"Google Satellite\", new GoogleSatelliteMapProvider(this)));\n    _providers.append(ProviderPair(\"Google Terrain\", new GoogleTerrainMapProvider(this)));\n    _providers.append(ProviderPair(\"Google Hybrid\", new GoogleHybridMapProvider(this)));\n    _providers.append(ProviderPair(\"Google Labels\", new GoogleLabelsMapProvider(this)));\n#endif\n\n    _providers.append(ProviderPair(\"Bing Road\", new BingRoadMapProvider(this)));\n    _providers.append(ProviderPair(\"Bing Satellite\", new BingSatelliteMapProvider(this)));\n    _providers.append(ProviderPair(\"Bing Hybrid\", new BingHybridMapProvider(this)));\n\n    _providers.append(ProviderPair(\"Statkart Topo\", new StatkartMapProvider(this)));\n    _providers.append(ProviderPair(\"Statkart Basemap\", new StatkartBaseMapProvider(this)));\n\n    _providers.append(ProviderPair(\"Eniro Topo\", new EniroMapProvider(this)));\n\n    // To be add later on Token entry !\n    //_providers.append(ProviderPair(\"Esri World Street\", new EsriWorldStreetMapProvider(this)));\n    //_providers.append(ProviderPair(\"Esri World Satellite\", new EsriWorldSatelliteMapProvider(this)));\n    //_providers.append(ProviderPair(\"Esri Terrain\", new EsriTerrainMapProvider(this)));\n\n    _providers.append(ProviderPair(\"Mapbox Streets\", new MapboxStreetMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Light\", new MapboxLightMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Dark\", new MapboxDarkMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Satellite\", new MapboxSatelliteMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Hybrid\", new MapboxHybridMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox StreetsBasic\", new MapboxStreetsBasicMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Outdoors\", new MapboxOutdoorsMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Bright\", new MapboxBrightMapProvider(this)));\n    _providers.append(ProviderPair(\"Mapbox Custom\", new MapboxCustomMapProvider(this)));\n\n    //_providers.append(ProviderPair(\"MapQuest Map\", new MapQuestMapMapProvider(this)));\n    //_providers.append(ProviderPair(\"MapQuest Sat\", new MapQuestSatMapProvider(this)));\n\n    _providers.append(ProviderPair(\"VWorld Street Map\", new VWorldStreetMapProvider(this)));\n    _providers.append(ProviderPair(\"VWorld Satellite Map\", new VWorldSatMapProvider(this)));\n\n    _providers.append(ProviderPair(kCopernicusElevationProviderKey, new CopernicusElevationProvider(this)));\n\n    _providers.append(ProviderPair(\"Japan-GSI Contour\", new JapanStdMapProvider(this)));\n    _providers.append(ProviderPair(\"Japan-GSI Seamless\", new JapanSeamlessMapProvider(this)));\n    _providers.append(ProviderPair(\"Japan-GSI Anaglyph\", new JapanAnaglyphMapProvider(this)));\n    _providers.append(ProviderPair(\"Japan-GSI Slope\", new JapanSlopeMapProvider(this)));\n    _providers.append(ProviderPair(\"Japan-GSI Relief\", new JapanReliefMapProvider(this)));\n\n    _providers.append(ProviderPair(\"LINZ Basemap\", new LINZBasemapMapProvider(this)));\n\n    _providers.append(ProviderPair(\"CustomURL Custom\", new CustomURLMapProvider(this)));\n}\n\n//-----------------------------------------------------------------------------\nUrlFactory::~UrlFactory() {}\n\nQString UrlFactory::getImageFormat(int qtMapId, const QByteArray& image) {\n    MapProvider* provider = getMapProviderFromQtMapId(qtMapId);\n    if (provider) {\n        return provider->getImageFormat(image);\n    } else {\n        qCWarning(QGCMapUrlEngineLog) << \"getImageFormat : map id not found:\" <",
    "// dear imgui, v1.90.5\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)\n//------------------------------------------------------",
    "#include \"DirectionalLight.hpp\"\r\n\r\nnamespace Raytracer {\r\nDirectionalLight::DirectionalLight()\r\n    : Light(), ls(1.0), color(white), direction(Vector3d(1.0, 0.0, 0.0)) {}\r\n\r\nDirectionalLight::DirectionalLight(const Vector3d& direction)\r\n    : Light(), ls(1.0), color(white), direction(direction.normalized()) {}\r\n\r\nDirectionalLight::DirectionalLight(const DirectionalLight& dl)\r\n    : Light(dl), ls(dl.ls), color(dl.color), direction(dl.direction) {}\r\n\r\nLight* DirectionalLight::clone() const { return new DirectionalLight(*this); }\r\n\r\nDirectionalLight::~DirectionalLight() {}\r\n\r\nbool DirectionalLight::operator==(const DirectionalLight& o) const {\r\n  return Light::operator==(o) && ls == o.ls && color == o.color &&\r\n         direction == o.direction;\r\n}\r\n\r\nVector3d DirectionalLight::get_direction(ShadeRec& sr) { return direction; }\r\n\r\nRGBColor DirectionalLight::L(ShadeRec& s) { return ls * color; }\r\n\r\nbool DirectionalLight::in_shadow(const Ray& ray, ShadeRec& sr) const {\r\n  double t;\r\n  const unsigned num_objects = sr.w.objects.size();\r\n  for (unsigned j = 0; j < num_objects; ++j) {\r\n    if (sr.w.objects[j]->hit(SHADOW_RAY, ray, t, sr)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n}\r\n",
    "#include <iostream>\n#include <chrono>\n#include <ctime>\n#include <limits>\nusing namespace std;\nusing namespace chrono;\n\nvoid menu() {\n    cout << \"0) exit program\\n\" <<\n            \"1) fill out de list\\n\" <<\n            \"2) actions with de list\\n\" <<\n            \"3) show de list\\n\" <<\n            \"4) fill out de array\\n\" <<\n            \"5) action with de array\\n\" <<\n            \"6) show de array\\n\" <<\n            \"7) time\\n\";\n}\n\nvoid menu2() {\n    cout << \"1) insert de element\\n\" <<\n            \"2) delete de element (index)\\n\" <<\n            \"3) delete de element (value)\\n\" <<\n            \"4) swap de element\\n\" <<\n            \"5) show de element (index)\\n\" <<\n            \"6) show de element (value)\\n\" <<\n            \"7) IDZ\\n\";\n}\n\n\n\nvoid clearStream() {\n    cin.clear();\n    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n    cin.sync();\n}\n\nint inputInt(){\n    int number;\n    while(!(cin >> number)) {\n        cin.clear();\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        cout << \"wrong input! \\n\";\n    }\n    return number;\n}\n\nint inputRandomInt(){\n    return rand()%100;\n}\n\nstruct Node {   //\u0443\u0437\u0435\u043b (\u0437\u0432\u0435\u043d\u043e) \u0441\u043f\u0438\u0441\u043a\u0430\n    int data;\n    Node *  prev;\n    Node *  next;\n    Node(int x) : data(x), prev(nullptr), next(nullptr) {}\n};\n\nstruct List {\n    Node * head;\n    Node * tail;\n\n    void createList(){\n        head = nullptr;\n        tail = nullptr;\n    }\n\n\n    void addHead(int x){\n        Node *temp = new Node(x);\n        temp->next = head;\n        if(head != nullptr){\n            head->prev = temp;\n        }\n        if(tail == nullptr){\n            tail = temp;\n        }\n        head = temp;\n    }\n\n    void addTail(int x){\n        Node *temp = new Node(x);\n        temp->prev = tail;\n        if(tail != nullptr){\n            tail->next = temp;\n        }\n        if(head == nullptr){\n            head = temp;\n        }\n        tail = temp;\n    }\n\n    void moveHead(){\n        if(head == nullptr)\n            return;\n        Node *temp = head->next;\n        if(temp != nullptr){\n            temp->prev = nullptr;\n        }\n        else{\n            tail = nullptr;\n        }\n        delete head;\n        head = temp;\n    }\n\n    void moveTail(){\n        if(tail == nullptr)\n            return;\n        Node *temp = tail->next;\n        if(temp != nullptr){\n            temp->next = nullptr;\n        }\n        else{\n            head = nullptr;\n        }\n        delete tail;\n        tail = temp;\n    }\n\n    void clearList(){\n        while(head != nullptr){\n            moveTail();\n        }\n    }\n\n    void randList(int &len){\n        for(int i = 0; i < len; i++){\n            addTail(inputRandomInt());\n        }\n    }\n\n    Node *getId(int id){\n        Node *temp = head;\n        int a = 0;\n        while(a != id && temp != nullptr){\n            temp = temp->next;\n            a++;\n        }\n        if(temp == nullptr) // \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043d\u0435\u0442\n            return nullptr;\n        else\n            return temp;\n    }\n\n    int getValue(int value){\n        int id = 0;\n        for(Node *temp = head; temp != nullptr; temp = temp->next){\n            if(temp->data == value){\n                return id;\n            }\n            id++;\n        }\n        return -1; // \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u043d\u0443\u0436\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n    }\n\n    void Insert(int id, int x){\n        Node *Ins = getId(id);\n        if(Ins == nullptr){\n            addTail(x);\n            return;\n        }\n        Node *prevIns = Ins->prev;\n        if(prevIns == nullptr){\n            addHead(x);\n            return;\n        }\n        Node *temp = new Node(x);\n        temp->prev = prevIns;\n        temp->next = Ins;\n        prevIns->next = temp;\n        Ins->prev = temp;\n    }\n\n    void deleteByValue(int value){\n        Node *temp = head;\n        if(temp == nullptr){\n            cout << \"there is no such element\";\n            return;\n        }\n        while(temp){ //\u043f\u0440\u043e\u0445\u043e\u0434\u0438\u043c\u0441\u044f \u043f\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c\n            if(temp->data == value){\n                break;\n            }\n            temp = temp->next;\n        }\n        if(temp->prev == nullptr){\n            moveHead(); //\u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u0435\u0440\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n            return;\n        }\n        if(temp->next == nullptr){\n            moveTail(); //\u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n            return;\n        }\n        else {\n            Node *prevDel = temp->prev;\n            Node *Del = temp->next;\n            prevDel->next = Del; //\u0435\u0441\u043b\u0438 \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u043d\u0435 head\n            Del->prev = prevDel; //\u0435\u0441\u043b\u0438 \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u043d\u0435 tail\n        }\n        delete temp;\n    }\n\n    void deleteByIndex(int index){\n        Node *temp = getId(index);\n        if(temp == nullptr){\n            cout << \"there is no such element\";\n            return;\n        }\n        if(temp->prev == nullptr){\n            moveHead(); //\u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u0435\u0440\u0432\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n            return;\n        }\n        if(temp->next == nullptr){\n            moveTail(); //\u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n            return;\n        }\n        else {\n            Node *prevDel = temp->prev;\n            Node *Del = temp->next;\n    ",
    "#include <ctype.h>\n#include <errno.h>\n#include <iostream> \n#include <stdio.h> \n#include <string.h> \n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h> \n\nvoid CreatePipe(int process[])\n{\n    if( pipe(process) < 0 )\n    {\n        std::cerr << \"CreatePipe() failed...\\n\";\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid Write(int pipe[], char output[], const int &SIZE, int &n_bytes)\n{\n    if( n_bytes = write(pipe[1], output, SIZE) < 0 )\n    {\n        std::cerr << \"Write() failed...\\n\";\n        exit(EXIT_FAILURE);        \n    }\n}\n\nvoid Read(int pipe[], char input[], const int &SIZE, int &n_bytes)\n{\n    memset(input, 0, SIZE);\n    if( n_bytes = read(pipe[0], input, SIZE) < 0 )\n    {\n        std::cerr << \"Read() failed...\\n\";\n        exit(EXIT_FAILURE);            \n    }\n}\n\nint main(int argc, char *argv[])\n{\n    const int SIZE = 30;\n    char message[] = \"This is some message.\";\n    char response[] = \"OK... response here.\";\n\n    bool is_running;\n    char bufferA[SIZE];\n    char bufferB[SIZE];\n\n    int pipeA[2];        \n    int pipeB[2];        \n    int pid; \n    int n_bytes;\n    // int length = strlen(message) + 1;\n\n    // create pipes\n    CreatePipe(pipeA);\n    CreatePipe(pipeB);\n\n    // create children\n    pid = fork();\n\n    // parent process\n    if( pid > 0 )\n    {\n        Write(pipeA, message, SIZE, n_bytes);\n        Read(pipeB, bufferA, SIZE, n_bytes);\n        std::cout << \"Parent received -> \" << bufferA << std::endl;\n    }\n    else\n    {\n        Read(pipeA, bufferB, SIZE, n_bytes);\n        std::cout << \"Child received -> \" << bufferB << std::endl;\n        Write(pipeB, response, SIZE, n_bytes);\n    }\n\n    return EXIT_SUCCESS;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"guess_the_number\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"GraphList.h\"\n\nGraphList::GraphList(const unsigned long long N, const bool weighted) : Graph(N, weighted) {\n    adjList = std::vector< std::vector< std::pair<unsigned long long, double > > > (N + 1, std::vector< std::pair<unsigned long long, double> >());\n}\n\nGraphList::~GraphList() {\n}\n\nvoid GraphList::addEdge(const unsigned long long node1, const unsigned long long node2) {\n    Graph::addEdge(node1, node2);\n    adjList.at(node1).push_back(std::make_pair(node2, 1.0));\n    adjList.at(node2).push_back(std::make_pair(node1, 1.0));\n}\n\nvoid GraphList::addEdge(const unsigned long long node1, const unsigned long long node2, const double weight) {\n    Graph::addEdge(node1, node2, weight);\n\n    if (!weighted) {\n        adjList.at(node1).push_back(std::make_pair(node2, 1.0));\n        adjList.at(node2).push_back(std::make_pair(node1, 1.0));\n    } else {\n        adjList.at(node1).push_back(std::make_pair(node2, weight));\n        adjList.at(node2).push_back(std::make_pair(node1, weight));\n    }\n}\n\nbool GraphList::isEdge(const unsigned long long node1, const unsigned long long node2) const {\n    for (unsigned long long i = 0; i < adjList.at(node1).size(); ++i)\n        if (adjList.at(node1).at(i).first == node2)\n            return true;\n    return false;\n}\n\ndouble GraphList::getWeight(const unsigned long long node1, const unsigned long long node2) const {\n    for (unsigned long long i = 0; i < adjList.at(node1).size(); ++i)\n        if (adjList.at(node1).at(i).first == node2)\n            return adjList.at(node1).at(i).second;\n    // edge doesn't exist\n    throw std::exception();\n}\n\nstd::vector<unsigned long long> GraphList::getNeighbours(const unsigned long long node) const {\n    std::vector<unsigned long long> ret;\n    for (unsigned long long i = 0; i < adjList.at(node).size(); ++i)\n        ret.push_back(adjList.at(node).at(i).first);\n    return ret;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (c) 2021, The Linux Foundation. All rights reserved.\n * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Changes from Qualcomm Innovation Center are provided under the following license:\n * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause-Clear\n */\n\n#define LOG_TAG \"vendor.qti.vibrator.offload\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <thread>\n#include <linux/input.h>\n#include <log/log.h>\n#include <fcntl.h>\n#include <cutils/log.h>\n#include <cutils/uevent.h>\n#include <cutils/properties.h>\n#include <sys/poll.h>\n#include <sys/ioctl.h>\n\n#include \"include/Vibrator.h\"\n#include \"VibratorPatterns.h\"\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace vibrator {\n\n#define UEVENT_MSG_LEN              1024\n#define SLATE_EVENT \"SLATE_EVENT=\"\n#define SLATE_EVENT_STRING_LEN      12 //length of SLATE_EVENT\n/*\n * TODO Need to work on solution to get this from kernel header\n * without effecting other kernel versions where this change\n * goes in.\n */\n#define SLATE_AFTER_POWER_UP        4\n\nPatternOffload::PatternOffload()\n{\n    char prop_str[PROPERTY_VALUE_MAX];\n    mEnabled = 0;\n\n    if (property_get(\"ro.vendor.qc_aon_presence\", prop_str, NULL))\n        mEnabled = atoi(prop_str);\n\n    if (mEnabled != 1)\n        return;\n\n    std::thread t(&PatternOffload::SSREventListener, this);\n    t.detach();\n}\n\nvoid PatternOffload::SSREventListener(void)\n{\n    int device_fd, n, ssr_event = 0;\n    char msg[UEVENT_MSG_LEN + 2];\n    char *msg_ptr = msg;\n\n    /* Offload during the bootup */\n    SendPatterns();\n\n    device_fd = uevent_open_socket(64*1024, true);\n    if(device_fd < 0)\n    {\n        ALOGE(\"open socket failed: %d\", device_fd);\n        return;\n    }\n\n    while ((n = uevent_kernel_multicast_recv(device_fd, msg, UEVENT_MSG_LEN)) > 0) {\n         if (n <= 0 || n > UEVENT_MSG_LEN) {\n            ALOGE(\"Message length %d is not correct\\n\", n);\n            continue;\n         }\n         msg[n] = '\\0';\n         msg[n+1] = '\\0';\n         if (strstr(msg, \"slate_com_dev\")) {\n             while(*msg_ptr) {\n                 if(!strncmp(msg_ptr, SLATE_EVENT, SLATE_EVENT_STRING_LEN)) {\n                     msg_ptr += SLATE_EVENT_STRING_LEN;\n                     ssr_event = (atoi(msg_ptr));\n                     switch(ssr_event) {\n                         case SLATE_AFTER_POWER_UP:\n                             ALOGD(\"SLATE is powered up\");\n                             SendPatterns();\n                             break;\n                     }\n                 }\n                 while(*msg_ptr++);\n             }\n         }\n     }\n}\n\n/** Offload patterns\n *  The sequence of steps in offloading patterns.\n *  1. Open the Glink channel to offload the patterns\n *  2. Send the configuration/meta data to co-proc\n *  3. Wait for the response from the co-proc\n *  4. Send the pattern data to co-proc\n *  5. Wait for the response\n *  6. Exit\n */\nvoid PatternOffload::SendPatterns()\n{\n    uint8_t *data;\n    uint32_t len;\n    int32_t rc;\n\n    rc = initChannel();\n    if (rc < 0)\n        return;\n\n    rc = get_pattern_config(&data, &len);\n    if (rc < 0 || !data)\n        return;\n\n    /* Send config data */\n    rc = sendData(data, len);\n    if (rc < 0)\n        return;\n\n    rc = get_pattern_data(&data, &len);\n    if (rc < 0)\n        return;\n\n    /* Send pattern data */\n    rc = sendData(data, len);\n    if (rc < 0)\n        ALOGE",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n\r\nint main(void)\r\n{\r\n \tmkdir(\"data\");\r\n\tgo123:\r\n\tint abcd = 0;\r\n\tabcd = 0;\r\n\t//\ud30c\uc77c\uc0dd\uc131 \r\n\tint acc;\r\n\tFILE *open;\r\n\topen = fopen(\"data\\\\acc.txt\", \"a\");\r\n\tfprintf(open, \"%d\", 1);\r\n\tfclose(open);\r\n\t\r\n\topen = fopen(\"data\\\\acc.txt\", \"r\");\r\n\tfscanf(open, \"%d\", &acc);\r\n\tif(acc == 1)\r\n\t{\r\n\tprintf(\"\uc2e4\ud589\uc744 \uc704\ud574 \uc77c\ubd80 \ud30c\uc77c\uc744  \uc0dd\uc131\ud574\uc57c \ud569\ub2c8\ub2e4. [\ub3d9\uc758(1)/ \uac70\ubd80(2)]\\n\");\r\n\tscanf(\"%d\", &abcd);\r\n\tif (abcd == 2)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\uc2e4\ud589\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\");\r\n\t\trmdir(\"data\");\r\n\t\topen = fopen(\"data\\\\acc.txt\", \"w\");\r\n\t\tfprintf(open, \"%d\", 0);\r\n\t\tfclose(open);\r\n\t\tSleep(1300);\r\n\t\treturn 0; \r\n\t}\r\n\telse if(abcd == 1)\r\n\t{\r\n\tprintf(\"\uae30\ubcf8\uac12\uc744 \uc801\uc6a9\ud569\ub2c8\ub2e4\");\r\n\tSleep(500);\r\n\tprintf(\".\");\r\n\tSleep(500);\r\n\tprintf(\".\");\r\n\tSleep(500);\r\n\tprintf(\".\\n\");\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\ach.txt\", \"a\");\r\n\tprintf(\"\\n[ach.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\coin.txt\", \"a\");\r\n\tprintf(\"\\n[coin.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 500);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\cupon.txt\", \"a\");\r\n\tprintf(\"\\n[cupon.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\passcheck.txt\", \"a\");\r\n\tprintf(\"\\n[passcheck.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\password.txt\", \"a\");\r\n\tprintf(\"\\n[password.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(1500);\r\n\tprintf(\"\\n====================================\\n\");\r\n\tprintf(\"\uc2e4\ud589\uc900\ube44 \uc644\ub8cc!\");\r\n\tSleep(1500); \r\n\tsystem(\"cls\");\r\n\tgoto main343;\r\n\t}\r\n\t\r\n  }\r\n\telse \r\n\t{\r\n\t\tgoto main343;\r\n\t}\r\n\t//\ud30c\uc77c \uc0dd\uc131\r\n\tmain343: \r\n\tFILE *pass,*pass1,*pass2,*pass3;\r\n\tint p12;\r\n\tint a;\r\n\tint pas;\r\n\tint passcheck;\r\n\tint password[2]; \r\n\tmain1:\r\n\tprintf(\"-----------------------------------------------------------\\n\\n\\n\\n\\n           [R-S-P Game]\\n\\n\" );                \r\n\tSleep(700);\r\n\tprintf(\"                                                                                                          \uac00\uc704!\\n\");\r\n\tSleep(500);\r\n\tprintf(\"                                                                                                                  \ubc14\uc704!\\n\");\r\n\tSleep(500);\r\n\tprintf(\"                                                                                                                            \ubcf4!\\n\\n\");\r\n\tSleep(500);\r\n\tprintf(\"-------------------------Made by \ub9cc\ub4ec\uc774----------------------------------\\n\");\r\n\tSleep(500);\r\n\tprintf(\" \ub85c\ub529\uc911\");\r\n\tSleep(300);\r\n\tprintf(\".\"); \r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(700);\r\n\tSleep(600);  \r\n\tint h1;\r\n\tint c;//\ucf54\uc778 \r\n\tint h;//\ucfe0\ud3f0  \r\n\tFILE *in, *out, *ini, *outo, *inin, *outout;\r\n\tin = fopen(\"data\\\\coin.txt\", \"r\");\r\n\tini = fopen(\"data\\\\cupon.txt\", \"r\");\r\n\tinin = fopen(\"data\\\\ach.txt\", \"r\");\r\n\tif(in == NULL && ini == NULL && inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(in == NULL && ini == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(in == NULL && inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(ini == NULL && inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(in == NULL)\r\n\t{\t\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0; \r\n\t}\r\n\tif(ini == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tfscanf(in, \"%d\", &c);\r\n\tfscanf(ini, \"%d\", &h);\r\n\tfscanf(inin, \"%d\", &h1);\r\n\tif(c < 0 && h < 0 && h1 < 0)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\uc758 \uac12\uc774 \uc798\ubabb \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tc = 0; \r\n\t\tout = fopen(\"data\\\\coin.txt\", \"w\");\r\n        fprintf(out, \"%d\", c);\r\n\t    fclose(out);\r\n\t    printf(\"[\uc5d0\ub7ec\uc218\uc815..]\\n\\n\");\r\n\t    Sleep(1000);\r\n\t    printf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\uc758 \uac12\uc774 \uc798\ubabb \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\th = 0;\r\n\t\touto = fopen(\"data\\\\cupon.txt\", \"w\");\r\n        fprintf(outo, \"%d\", h);\r\n\t    fclose(outo);\r\n\t    printf(\"[\uc5d0\ub7ec\uc218\uc815..]\\n\\n\"); \r\n\t    Sleep(500);\r\n\t    printf(\"\\n\uc5d0\ub7ec! : [ach.txt]\uc758 \uac12\uc774 \uc798\ubabb \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\th1 = 0; \r\n\t\toutout = fopen(\"",
    "#include <iostream>\n#include <chrono>\nusing namespace std;\n\nstruct List\n{\n  int data;\n  List *head;\n  List *tail;\n};\n\nint getNumber ()\n{\n  int a;\n  cin >> a;\n  while (cin.fail())\n  {\n    cin.clear();\n    cin.ignore();\n    cin >> a;\n  }\n  return a;\n}\n\nList *createList(int length)\n{\n  List *curr = nullptr;\n  List *next = nullptr;\n  for (int i = 0; i < length; ++i)\n  {\n    curr = new List;\n    curr->tail = next;\n    if (next)\n      next->head = curr;\n    next = curr;\n  }\n  curr->head = nullptr;\n  return curr;\n}\n\nint lenOfList(List *element)\n{\n  int len = 0;\n  while (element != nullptr)\n  {\n    len += 1;\n    element = element->tail;\n  }\n  return len;\n}\n\nvoid removeList(List *element)\n{\n  for (int i = 0; i < lenOfList(element); ++i)\n  {\n    delete element;\n    element = element->tail;\n  }\n}\n\nvoid printList(List *element)\n{\n  cout << '{';\n  if (!(lenOfList(element) == 1 && element->data == 0))\n  {\n    while (element != nullptr)\n    {\n      cout << element->data;\n      element = element->tail;\n      if (element != nullptr)\n        cout << \", \";\n    }\n  }\n  cout << '}';\n  cout << endl;\n}\n\nList *getElementOfListByIndex(List *element, int index)\n{\n  List *lookingForElement = element;\n  for (int i = 0; i < index; ++i)\n    lookingForElement = lookingForElement->tail;\n  return lookingForElement;\n}\n\nvoid fillListRandomly(List *element)\n{\n  while (element != nullptr)\n  {\n    element->data = rand() % 100;\n    element = element->tail;\n  }\n}\n\nvoid insertElementToBeginOfTheList(List *element, int input)\n{\n  List *newElement = new List;\n}\n\nvoid insertElementToEndOfTheList(List *element, int input)\n{\n  List *lastElement = element;\n  for (int i = 0; i < lenOfList(element)-1; ++i)\n  {\n    lastElement = lastElement->tail;\n  }\n  List *newElement = new List;\n  lastElement->tail = newElement;\n  newElement->head = lastElement;\n  newElement->tail = nullptr;\n  newElement->data = input;\n}\n\nvoid insertElementToSomePositionOfTheList(List *element, int index, int input)\n{\n  getElementOfListByIndex(element, index)->data = input;\n}\n\nList *deleteElementOfTheList(List *element, int index)\n{\n  List *removingElement = getElementOfListByIndex(element, index);\n  List *nextElement = removingElement->tail;\n  List *previousElement = removingElement->head;\n  if (!previousElement)\n  {\n    nextElement->head = nullptr;\n    element = nextElement;\n  }\n  else if (!nextElement)\n  {\n    previousElement->tail = nullptr;\n  }\n  else\n  {\n    nextElement->head = previousElement;\n    previousElement->tail = nextElement;\n  }\n  delete removingElement;\n  return element;\n}\n\nvoid fillListUserly(List *element)\n{\n  int number;\n  number = getNumber();\n  element->data = number;\n  while (number != -1)\n  {\n    number = getNumber();\n    insertElementToEndOfTheList(element, number);\n  }\n  deleteElementOfTheList(element, lenOfList(element)-1);\n}\n\nvoid changeElementsOfTheList(List *element, int index1, int index2)\n{\n  if (index1 < 0 || index2 < 0 || index1 > lenOfList(element)-1 || index2 > lenOfList(element)-1)\n  {\n    cout << \"incorrect indecies\" << endl;\n  }\n  else \n  {\n    List *element1 = getElementOfListByIndex(element, index1); \n    List *element2 = getElementOfListByIndex(element, index2);\n    int swappy = element1->data;\n    element1->data = element2->data;\n    element2->data = swappy;\n  }\n}\n\nbool correctIndex(int index, int len)\n{\n  if (index < 0 or index >= len)\n    return false;\n  return true;\n}\n\n\nint *createDynamicArray(int length)\n{\n  int *arr = new int[length];\n  return arr;\n}\n\nvoid printDynamicArray(int *array, int length)\n{\n  for (int i = 0; i < length; ++i)\n  {\n    cout << array[i] << ' ';\n  }\n  cout << endl;\n}\n\nvoid fillDynamicArrayRandomly(int *array, int length)\n{\n  for (int i = 0; i < length; ++i)\n  {\n    array[i] = rand() % 100;\n  }\n}\n\nvoid insertElementToEndOfTheDynamicArray(int *array, int *length, int input)\n{\n  *length += 1;\n  array[*length-1] = input;\n}\n\nvoid fillDynamicArrayUserly(int *array, int *length)\n{\n  int number;\n  number = getNumber();\n  *array = number;\n  while (number != -1)\n  {\n    number = getNumber();\n    insertElementToEndOfTheDynamicArray(array, length, number);\n  }\n}\n\nvoid insertToDynamicArray(int *array, int length, int index, int input)\n{\n  array[index] = input;\n}\n\nvoid changeElementsOfDynamicArray(int *array, int length, int index1, int index2)\n{\n    int swap = array[index1];\n    array[index1] = array[index2];\n    array[index2] = swap;\n}\n\nint getElementOfDynamicArray(int *array, int length, int index)\n{\n  return array[index];\n}\n\nvoid deleteElementOfDynamicArray(int *&array, int &length, int index)\n{\n  for (int i = index; i < length - 1; i++)\n  {\n      array[i] = array[i + 1];\n  }\n  length -= 1;\n  int* newArr = new int[length];\n  for (int i = 0; i < length; i++)\n  {\n      newArr[i] = array[i];\n  }\n  delete[] array;\n  array = newArr;\n}\n\nvoid copyFromListToDynamicArray(List *element, int *array, int *length)\n{\n  *length = lenOfList(element);\n  for (int i = 0; i < *length; ++i)\n  {\n    array[i] = getElementOfListByIndex(element, i)->dat",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"instaprofiel\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"pch.h\"\r\n#include \"Logic.h\"\r\n\r\nLogic::Logic() \r\n{\r\n    this->moduleBase = (uintptr_t)GetModuleHandle(L\"Spel2.exe\");\r\n\tthis->GetDynamicAddresses();\r\n}\r\n\r\nuintptr_t Logic::GetModuleBase()\r\n{\r\n    return this->moduleBase;\r\n}\r\n\r\nvoid Logic::GetDynamicAddresses()\r\n{\r\n\tthis->ply = (Player*)mem::ResolvePointerChain(moduleBase + 0x22DB7F08, { 0x1788, 0x178, 0x0 });\r\n\tthis->nextLevel = (float*)mem::ResolvePointerChain(moduleBase + 0x22DB7F08, { 0x1798, 0x120, 0x0 });\r\n}\r\n\r\nBOOL Logic::IsPointerInvalid()\r\n{\r\n\tif (this->ply == (Player*)0x40)\r\n    {\r\n\t\treturn true;\r\n\t} \r\n    return false;\r\n}\r\n\r\nvoid Logic::HandleInput()\r\n{ \r\n    // Failsafe for level transitions where pointer might not be valid for a split second\r\n    if (this->ply == NULL) return;\r\n\r\n    if (GetAsyncKeyState(VK_DELETE) & 1)\r\n    {\r\n        this->keep_running = 0;\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD0) & 1)\r\n    {\r\n        BOOL temp = this->lockMoney;\r\n        if (!temp)  // Off -> on\r\n        {\r\n            this->prevMoney = this->ply->utility->money;\r\n        }\r\n        else        // On -> off   \r\n        {\r\n            this->ply->utility->money = this->prevMoney;\r\n        }\r\n        this->lockMoney = ~(this->lockMoney);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD1) & 1)\r\n    {\r\n        BOOL temp = this->godMode;\r\n        if (!temp)\r\n        {\r\n            this->prevHealth = this->ply->health;\r\n        }\r\n        else\r\n        {\r\n            this->ply->health = this->prevHealth;\r\n        }\r\n        this->godMode = ~(this->godMode);\r\n        this->ToggleGodMode(this->godMode);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD2) & 1)\r\n    {\r\n        BOOL temp = this->lockBombs;\r\n        if (!temp)\r\n        {\r\n            this->prevBombs = this->ply->utility->bombs;\r\n        }\r\n        else\r\n        {\r\n            this->ply->utility->bombs = this->prevBombs;\r\n        }\r\n        this->lockBombs = ~(this->lockBombs);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD3) & 1)\r\n    {\r\n        BOOL temp = this->lockRopes;\r\n        if (!temp)\r\n        {\r\n            this->prevRopes = this->ply->utility->ropes;\r\n        }\r\n        else\r\n        {\r\n            this->ply->utility->ropes = this->prevRopes;\r\n        }\r\n        this->lockRopes = ~(this->lockRopes);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD4) & 1)\r\n    {\r\n        this->speedHack = ~(this->speedHack);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD5) & 1)\r\n    {\r\n        this->highJump = ~(this->highJump);\r\n        this->ToggleHighJump(this->highJump);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD6) & 1)\r\n    {\r\n        return;\r\n    }\r\n\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD7) & 1)\r\n    {\r\n        if (this->ply->state != 240)\r\n        {\r\n            this->ply->Teleport(this->nextLevel[0], this->nextLevel[1]);\r\n        }\r\n        return;\r\n    }\r\n}\r\n\r\nvoid Logic::ContinousWrite() \r\n{\r\n    // Failsafe for level transitions where pointer might not be valid for a split second\r\n    if (this->ply == NULL) return;\r\n\r\n    if (this->lockBombs)\r\n    {\r\n        this->ply->utility->bombs = 44;\r\n    }\r\n\r\n    if (this->lockRopes)\r\n    {\r\n        this->ply->utility->ropes = 55;\r\n    }\r\n\r\n    if (this->lockMoney)\r\n    {\r\n        this->ply->utility->money = 66778899;\r\n    }\r\n\r\n    if (this->speedHack)\r\n    {\r\n        if (this->ply->state != 88 && this->ply->state != 176 && this->ply->state != 240) {\r\n            if (GetAsyncKeyState(VK_LEFT))\r\n            {\r\n                this->ply->x -= this->runModifier;\r\n            }\r\n            else if (GetAsyncKeyState(VK_RIGHT))\r\n            {\r\n                this->ply->x += this->runModifier;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid Logic::ToggleGodMode(BOOL toggle)\r\n{\r\n    uintptr_t DETOUR_SOURCE = this->moduleBase + 0x228d5a92;\r\n\r\n    if (toggle) \r\n    {\r\n        this->ply->health = 33;\r\n\r\n        // detour to code cave\r\n        mem::Patch(DETOUR_SOURCE, 7, \"\\xE9\\x6E\\x13\\x3E\\x00\\x90\\x90\");\r\n    }\r\n    else\r\n    {\r\n        this->ply->health = prevHealth;\r\n\r\n        // restore stolen bytes\r\n        mem::Patch(DETOUR_SOURCE, 7, \"\\x41\\x88\\x86\\x17\\x01\\x00\\x00\");\r\n    }\r\n}\r\n\r\nvoid Logic::ToggleHighJump(BOOL toggle)\r\n{\r\n    uintptr_t DETOUR_SOURCE = this->moduleBase + 0x22885565;\r\n\r\n    if (toggle)\r\n    {\r\n        // detour to code cave\r\n        mem::Patch(DETOUR_SOURCE, 9, \"\\xE9\\xBa\\x18\\x43\\x00\\x90\\x90\\x90\\x90\");\r\n    }\r\n    else\r\n    {\r\n        // restore stolen bytes\r\n        mem::Patch(DETOUR_SOURCE, 9, \"\\xF3\\x41\\x0F\\x11\\xB6\\x0C\\x01\\x00\\x00\");\r\n    }\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Copyright 2023 Citra Emulator Project\n// Licensed under GPLv2 or any later version\n// Refer to the license.txt file included.\n\n#include <boost/container/small_vector.hpp>\n#include \"video_core/shader/generator/pica_fs_config.h\"\n#include \"video_core/shader/generator/spv_fs_shader_gen.h\"\n\nnamespace Pica::Shader::Generator::SPIRV {\n\nusing Pica::FramebufferRegs;\nusing Pica::LightingRegs;\nusing Pica::RasterizerRegs;\nusing Pica::TexturingRegs;\nusing TevStageConfig = TexturingRegs::TevStageConfig;\nusing TextureType = TexturingRegs::TextureConfig::TextureType;\n\nconstexpr u32 SPIRV_VERSION_1_3 = 0x00010300;\n\nFragmentModule::FragmentModule(const FSConfig& config_, const Profile& profile_)\n    : Sirit::Module{SPIRV_VERSION_1_3}, config{config_}, profile{profile_},\n      use_fragment_shader_barycentric{profile.has_fragment_shader_barycentric &&\n                                      config.lighting.enable} {\n    DefineArithmeticTypes();\n    DefineUniformStructs();\n    DefineInterface();\n    for (u32 i = 0; i < NUM_TEX_UNITS; i++) {\n        DefineTexSampler(i);\n    }\n    DefineEntryPoint();\n}\n\nFragmentModule::~FragmentModule() = default;\n\nvoid FragmentModule::Generate() {\n    AddLabel(OpLabel());\n\n    rounded_primary_color = Byteround(OpLoad(vec_ids.Get(4), primary_color_id), 4);\n    primary_fragment_color = ConstF32(0.f, 0.f, 0.f, 0.f);\n    secondary_fragment_color = ConstF32(0.f, 0.f, 0.f, 0.f);\n\n    // Do not do any sort of processing if it's obvious we're not going to pass the alpha test\n    if (config.framebuffer.alpha_test_func == Pica::FramebufferRegs::CompareFunc::Never) {\n        OpKill();\n        OpFunctionEnd();\n        return;\n    }\n\n    // Append the scissor and depth tests\n    WriteDepth();\n    WriteScissor();\n\n    // Write shader bytecode to emulate all enabled PICA lights\n    WriteLighting();\n\n    combiner_buffer = ConstF32(0.f, 0.f, 0.f, 0.f);\n    next_combiner_buffer = GetShaderDataMember(vec_ids.Get(4), ConstS32(26));\n    combiner_output = ConstF32(0.f, 0.f, 0.f, 0.f);\n\n    // Write shader bytecode to emulate PICA TEV stages\n    for (u32 index = 0; index < config.texture.tev_stages.size(); ++index) {\n        WriteTevStage(index);\n    }\n\n    WriteAlphaTestCondition(config.framebuffer.alpha_test_func);\n\n    // Emulate the fog\n    switch (config.texture.fog_mode) {\n    case TexturingRegs::FogMode::Fog:\n        WriteFog();\n        break;\n    case TexturingRegs::FogMode::Gas:\n        WriteGas();\n        return;\n    default:\n        break;\n    }\n\n    Id color{Byteround(combiner_output, 4)};\n    switch (config.framebuffer.logic_op) {\n    case FramebufferRegs::LogicOp::Clear:\n        color = ConstF32(0.f, 0.f, 0.f, 0.f);\n        break;\n    case FramebufferRegs::LogicOp::Set:\n        color = ConstF32(1.f, 1.f, 1.f, 1.f);\n        break;\n    case FramebufferRegs::LogicOp::Copy:\n        // Take the color output as-is\n        break;\n    case FramebufferRegs::LogicOp::CopyInverted:\n        // out += \"color = ~color;\\n\";\n        break;\n    case FramebufferRegs::LogicOp::NoOp:\n        // We need to discard the color, but not necessarily the depth. This is not possible\n        // with fragment shader alone, so we emulate this behavior with the color mask.\n        break;\n    default:\n        LOG_CRITICAL(HW_GPU, \"Unhandled logic_op {:x}\",\n                     static_cast<u32>(config.framebuffer.logic_op.Value()));\n        UNIMPLEMENTED();\n    }\n\n    // Write output color\n    OpStore(color_id, color);\n    OpReturn();\n    OpFunctionEnd();\n}\n\nvoid FragmentModule::WriteDepth() {\n    const Id input_pointer_id{TypePointer(spv::StorageClass::Input, f32_id)};\n    const Id gl_frag_coord_z{\n        OpLoad(f32_id, OpAccessChain(input_pointer_id, gl_frag_coord_id, ConstU32(2u)))};\n    const Id z_over_w{OpFNegate(f32_id, gl_frag_coord_z)};\n    const Id depth_scale{GetShaderDataMember(f32_id, ConstS32(2))};\n    const Id depth_offset{GetShaderDataMember(f32_id, ConstS32(3))};\n    depth = OpFma(f32_id, z_over_w, depth_scale, depth_offset);\n    if (config.framebuffer.depthmap_enable == Pica::RasterizerRegs::DepthBuffering::WBuffering) {\n        const Id gl_frag_coord_w{\n            OpLoad(f32_id, OpAccessChain(input_pointer_id, gl_frag_coord_id, ConstU32(3u)))};\n        depth = OpFDiv(f32_id, depth, gl_frag_coord_w);\n    }\n    OpStore(gl_frag_depth_id, depth);\n}\n\nvoid FragmentModule::WriteScissor() {\n    if (config.framebuffer.scissor_test_mode == RasterizerRegs::ScissorMode::Disabled) {\n        return;\n    }\n\n    const Id gl_frag_coord{OpLoad(vec_ids.Get(4), gl_frag_coord_id)};\n    const Id gl_frag_coord_xy{OpVectorShuffle(vec_ids.Get(2), gl_frag_coord, gl_frag_coord, 0, 1)};\n\n    const Id scissor_x1{GetShaderDataMember(i32_id, ConstS32(6))};\n    const Id scissor_y1{GetShaderDataMember(i32_id, ConstS32(7))};\n    const Id scissor_1{OpCompositeConstruct(vec_ids.Get(2), OpConvertSToF(f32_id, scissor_x1),\n                                            OpConvertSToF(f32_id, scissor_y1))};\n\n    const Id scissor_x2{GetShaderDataMember(i32_id, ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <string>\n#include \"Graduate.h\"\n\n\nGraduate::Graduate(string& fio, int gradYear) {\n    setFio(fio);\n    setGraduateYear(gradYear);\n}\n\nGraduate::Graduate(string& fio, int& graduateYear, string& workPlace, string& studyPlace) {\n    setFio(fio);\n    setGraduateYear(graduateYear);\n    setWorkPlace(workPlace);\n    setStudyPlace(studyPlace);\n}\n\nvoid Graduate::setFio(string newfio) {\n    if (newfio.empty()){\n        throw \"Can't assign empty name!\";\n    }\n\n    this->fio = newfio;\n}\n\nvoid Graduate::setGraduateYear(int gradYear) {\n    if (gradYear < 1900){\n        throw \"Invalid year!\";\n    }\n\n    this->graduateYear = gradYear;\n\n}\n\nvoid Graduate::setWorkPlace(string workPlace) {\n    if (workPlace.empty()){\n        throw \"Can't assign empty work place!\";\n    }\n\n    this->workPlace = workPlace;\n}\n\nvoid Graduate::setStudyPlace(string studyPlace) {\n    if (studyPlace.empty()){\n        throw \"Can't assign empty study place!\";\n    }\n\n    this->studyPlace = studyPlace;\n}\n\nstring Graduate::getFio() const {\n    return this->fio;\n}\n\nint Graduate::getGraduationYear() const {\n    return this->graduateYear;\n}\n\nstring Graduate::getWorkPlace() const {\n    return this->workPlace;\n}\n\nstring Graduate::getStudyPlace() const {\n    return this->studyPlace;\n}\n\nGraduate::operator string() const {\n    string str = \"FIO: \" + this->getFio() + \"\\ngrad. year: \" + to_string(this->getGraduationYear()) + \"\\n\";\n\n    if (this->getWorkPlace() == EMPTY){\n        str += \"study place: \" + this->getStudyPlace();\n    } else {\n        str += \"work place: \" + this->getWorkPlace();\n    }\n    str += \"\\n\";\n\n    return str;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <string>\r\n\r\nclass Cache_Settings {\r\npublic:\r\n    int MEM_SIZE = 65536;\r\n    int CACHE_SIZE = 4096;\r\n    int CACHE_LINE_SIZE = 32;\r\n    int CACHE_LINE_COUNT = 128;\r\n    int CACHE_WAY = 4;\r\n    int CACHE_SETS_COUNT = 32;    \r\n    int ADDR_LEN = 16;  \r\n    int CACHE_TAG_LEN = 6;\r\n    int CACHE_IDX_LEN = 5;\r\n    int CACHE_OFFSET_LEN = 5;  \r\n    int Cache_to_Mem_Ticks = 101;\r\n    int Cache_Find_Ticks = 6;\r\n    int Cache_Eror_Ticks = 113;\r\n    int Ask = 0;\r\n    int Miss = 0;\r\n    int Ticks = 0;          \r\n    std::string Politics;\r\n    std::vector<std::vector<int>> Tags;\r\n    std::vector<std::vector<int>> Times;\r\n    std::vector<std::vector<int>> Modified;\r\n    \r\n\r\n    Cache_Settings(std::string Politics) : Politics(Politics) {\r\n        Tags = std::vector<std::vector<int>>(CACHE_SETS_COUNT, std::vector<int>(CACHE_WAY, -1));\r\n        Times = std::vector<std::vector<int>>(CACHE_SETS_COUNT, std::vector<int>(CACHE_WAY, 0));\r\n        Modified = std::vector<std::vector<int>>(CACHE_SETS_COUNT, std::vector<int>(CACHE_WAY, 0));\r\n\r\n        if (Politics == \"RR\") {\r\n            for (int i = 0; i < CACHE_SETS_COUNT; i++) {\r\n                Times[i][0] = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    void cache_request(int Address, std::string Command) {\r\n        int tag = Address >> (CACHE_OFFSET_LEN + CACHE_IDX_LEN);\r\n        int Index = (Address >> CACHE_OFFSET_LEN) % CACHE_SETS_COUNT;\r\n        Ask += 1;\r\n\r\n        auto it = std::find(Tags[Index].begin(), Tags[Index].end(), tag);\r\n        if (it != Tags[Index].end()) {\r\n            Ticks += Cache_Find_Ticks;\r\n            int Second_index = std::distance(Tags[Index].begin(), it);\r\n            if (Politics == \"LRU\") {\r\n            for (int i = 0; i < CACHE_WAY; i++) {\r\n                Times[Index][i] += 1;\r\n            }\r\n            Times[Index][Second_index] = 0;\r\n        } else if (Politics == \"pLRU\") {\r\n            Times[Index][Second_index] = 1;\r\n            int Full = 1;\r\n            for (int i = 0; i < CACHE_WAY; i++)\r\n                if (Times[Index][i] == 0)     \r\n                    Full = 0;\r\n            if (Full == 1) {\r\n                Times[Index] = std::vector<int>(CACHE_WAY, 0);\r\n                Times[Index][Second_index] = 1;\r\n            }\r\n        } \r\n            if (Command == \"Write\") {\r\n                Modified[Index][Second_index] = 1;\r\n            }\r\n        } else {\r\n            Miss += 1;\r\n            Ticks += Cache_Eror_Ticks;\r\n            int Second_index = 0;\r\n            if (Politics == \"LRU\") {\r\n                int max_time = *std::max_element(Times[Index].begin(), Times[Index].end());\r\n                Second_index = std::distance(Times[Index].begin(), std::find(Times[Index].begin(), Times[Index].end(), max_time));\r\n            } else if (Politics == \"pLRU\") {\r\n                Second_index = std::distance(Times[Index].begin(), std::find(Times[Index].begin(), Times[Index].end(), 0));\r\n            } else if (Politics == \"RR\") {\r\n                Second_index = std::distance(Times[Index].begin(), std::find(Times[Index].begin(), Times[Index].end(), 1));\r\n            }\r\n\r\n            if (Modified[Index][Second_index] == 1) {\r\n                Ticks += Cache_to_Mem_Ticks;\r\n            }\r\n            Tags[Index][Second_index] = tag;\r\n            if (Command == \"Read\"){\r\n                Modified[Index][Second_index] = 0;\r\n            }\r\n            else {\r\n                Modified[Index][Second_index] = 1;\r\n            }\r\n            if (Politics == \"LRU\") {\r\n            for (int i = 0; i < CACHE_WAY; i++) {\r\n                Times[Index][i] += 1;\r\n            }\r\n            Times[Index][Second_index] = 0;\r\n        } else if (Politics == \"pLRU\") {\r\n            Times[Index][Second_index] = 1;\r\n            int Full = 1;\r\n            for (int i = 0; i < CACHE_WAY; i++)\r\n                if (Times[Index][i] == 0)     \r\n                    Full = 0;\r\n            if (Full == 1) {\r\n                Times[Index] = std::vector<int>(CACHE_WAY, 0);\r\n                Times[Index][Second_index] = 1;\r\n            }\r\n        } else if (Politics == \"RR\" ) {\r\n            for (int i = 0; i < CACHE_WAY; i++) {\r\n                if (Times[Index][i] == 1) {\r\n                    Times[Index][i] = 0;\r\n                    Times[Index][(i + 1) % CACHE_WAY] = 1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        }\r\n    }\r\n};\r\n\r\nvoid cache_implementation(std::string Politics) {\r\n    int M = 64;\r\n    int N = 60;\r\n    int K = 32;\r\n    Cache_Settings Cache(Politics);\r\n\r\n    std::vector<std::vector<int>> a(M, std::vector<int>(K, 0));\r\n    std::vector<std::vector<int>> b(K, std::vector<int>(N, 0));\r\n    std::vector<std::vector<int>> c(M, std::vector<int>(N, 0));\r\n\r\n    int Address = 1 << 10;\r\n\r\n    for (int i = 0; i < M; i++) {\r\n        for (int j = 0; j < K; ++j) {\r\n            a[i][j] = Address;\r\n            Address += 1;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < K; i++) {\r\n        for (int",
    "//\n// Created by romka on 12.12.2023.\n//\n#include \"../include/binary_command.h\"\n\nnamespace cpu {\n\n    BinaryCommand::BinaryCommand(Variable value1, Variable value2, const std::string &name,\n                                 const std::string &identifier):\n            Instruction(name, identifier), values(std::move(value1), std::move(value2)) {}\n\n    BinaryCommand::BinaryCommand(const std::string& value1, const std::string &value2, const std::string &name,\n                                 const std::string &identifier):\n            Instruction(name, identifier), values(value1, value2) {}\n\n    std::string BinaryCommand::get_instruction() const {\n        std::string result = get_identifier() + \": \" + get_name() + \" \" + values.first.get_name() +\n                             \" \" + values.second.get_name() + \"\\n\";\n        return result;\n    }\n\n    BinaryCommand::ConstPairVariables BinaryCommand::get_variables() const {\n        return values;\n    }\n\n    Instruction *BinaryCommand::clone() {\n        return new BinaryCommand(*this);\n    }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <thread>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid InteractWithClient(int clientSocket, vector<int>& clients) {\n    //send/recv client\n    cout << \"client connected \" << endl;\n    char buffer[1024];\n    while (1) {\n        int bytesrecvd = recv(clientSocket, buffer, sizeof(buffer), 0);\n        if (bytesrecvd <= 0) {\n            cout << \"Client disconnected\" << endl;\n            break;\n        }\n        string message(buffer, bytesrecvd);\n        cout << \"message from client : \" << message << endl;\n\n        for (auto& client : clients) {\n            if (client != clientSocket) {\n                send(client, message.c_str(), message.length(), 0);\n            }\n        }\n    }\n    auto it = find(clients.begin(), clients.end(), clientSocket);\n    if (it != clients.end()) {\n        clients.erase(it);\n    }\n    close(clientSocket);\n}\n\nint main() {\n    cout << \"server program\" << endl;\n\n    int listenSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (listenSocket < 0) {\n        cout << \"Failed to create socket\" << endl;\n        return 1;\n    }\n\n    //address structure\n    sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(9090);\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(listenSocket, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0) {\n        cout << \"Failed to bind socket\" << endl;\n        close(listenSocket);\n        return 1;\n    }\n\n    if (listen(listenSocket, SOMAXCONN) < 0) {\n        cout << \"Failed to listen to client\" << endl;\n        close(listenSocket);\n        return 1;\n    }\n\n    cout << \"Server started running \" << endl;\n    vector<int> clients;\n    while (1) {\n        int clientSocket = accept(listenSocket, nullptr, nullptr);\n        if (clientSocket < 0) {\n            cout << \"Invalid client socket \" << endl;\n        }\n        clients.push_back(clientSocket);\n        thread t1(InteractWithClient, clientSocket, ref(clients));\n        t1.detach();\n    }\n\n    close(listenSocket);\n\n    return 0;\n}\n",
    "#include <QtWidgets/QWidget>\n#include <QtWidgets/QApplication>\n#include <QtWidgets/QPushButton>\n#include <QtWidgets/QLineEdit>\n#include <QtWidgets/QGridLayout>\n#include <QtWidgets/QLabel>\n#include <QtWidgets/QFileDialog>\n\n#include <board.hpp>\n#include <blueprint.hpp>\n#include <iostream>\n\nclass LabelText : public QWidget {\nprivate:\n\tQLabel* label;\n\tQLineEdit* line_edit;\n\tQGridLayout* layout;\npublic:\n\tLabelText(const char* text, const char* def, size_t line_width, QWidget* parent = nullptr) : QWidget(parent) {\n\t\tlabel = new QLabel(text, this);\n\t\tif (def!= nullptr)\n\t\t\tline_edit = new QLineEdit(def, this);\n\t\telse\n\t\t\tline_edit = new QLineEdit(this);\n\n\t\tif (line_width > 0)\n\t\t\tline_edit->setFixedWidth(line_width);\n\t\tline_edit->setContentsMargins(0, 0, 0, 0);\n\n\t\tlayout = new QGridLayout(this);\n\n\t\tlayout->addWidget(label, 0, 0);\n\t\tlayout->addWidget(line_edit, 0, 1);\n\t\tsetLayout(layout);\n\t}\n\n\t~LabelText() override {\n\t\tdelete label;\n\t\tdelete line_edit;\n\t}\n\n\tfriend class MyApp;\n};\n\nclass PathSelector : public QWidget {\nprivate:\n\tQLineEdit* line_edit;\n\tQPushButton* button;\n\tQFileDialog* dialog;\n\tQGridLayout* layout;\npublic:\n\tPathSelector(const char* text, QWidget* parent = nullptr) : QWidget(parent) {\n\t\tif(text != nullptr)\n\t\t\tline_edit = new QLineEdit(text, this);\n\t\tline_edit->setReadOnly(true);\n\t\tbutton = new QPushButton(\"...\", this);\n\t\tbutton->setFixedWidth(30);\n\t\tdialog = new QFileDialog(this);\n\t\tdialog->setFileMode(QFileDialog::Directory);\n\t\tdialog->setOption(QFileDialog::ShowDirsOnly);\n\n\t\tlayout = new QGridLayout(this);\n\t\tlayout->addWidget(line_edit, 0, 0);\n\t\tlayout->addWidget(button, 0, 1);\n\t\tsetLayout(layout);\n\n\t\tconnect(button, &QPushButton::clicked, [this](){\n\t\t\tline_edit->setText(dialog->getExistingDirectory());\n\t\t});\n\t}\n\n\t~PathSelector() override {\n\t\tdelete line_edit;\n\t\tdelete button;\n\t\tdelete dialog;\n\t}\n\n\tfriend class MyApp;\n};\n\nclass MyApp : public QWidget {\nprivate:\n\tBlueprint* blueprint;\n\tLabelText* count;\n\tPathSelector* src, *dst;\npublic:\n\tMyApp(QWidget* parent = nullptr) : QWidget(parent) {\n\t\tblueprint = new Blueprint(this);\n\t\tthis->count = new LabelText(\"Numero de loterias\", \"4\", 50, this);\n\t\tthis->src = new PathSelector(\"Entrada\", this);\n\t\tthis->dst = new PathSelector(\"Salida\", this);\n\n\t\tauto* dialog = new QFileDialog(this);\n\t\tdialog->setFileMode(QFileDialog::Directory);\n\t\tdialog->setOption(QFileDialog::ShowDirsOnly);\n\n\t\tauto* button = new QPushButton(\"Submit\", this);\n\t\tconnect(button, &QPushButton::clicked, this, &MyApp::submit);\n\t\tauto* layout = new QGridLayout(this);\n\n\t\tlayout->addWidget(count, 0, 0);\n\n\t\tauto* selection_layout = new QGridLayout(this);\n\t\tselection_layout->addWidget(src, 0, 0);\n\t\tselection_layout->addWidget(dst, 0, 1);\n\n\t\tlayout->addLayout(selection_layout, 1, 0);\n\n\t\tlayout->addWidget(blueprint, 2, 0);\n\t\tlayout->addWidget(button,    3, 0);\n\t}\n\n\tvoid submit(){\n\t\tauto p = blueprint->build();\n\t\tp.insert(p.begin(), {\"SetCount\", {(size_t)std::stoi(count->line_edit->text().toStdString())}});\n\t\tfor (auto& i : p){\n\t\t\tstd::cout<< i.name << \" \";\n\t\t\tfor (auto& j : i.values)\n\t\t\t\tstd::cout<< j << \" \";\n\t\t\tstd::cout<< std::endl;\n\t\t}\n\t}\n\n\t~MyApp() override {}\n};\n\nint main(int argc, char** argv) {\n\n\tQApplication app(argc, argv);\n\n\tMyApp window;\n\n\twindow.resize(400, 200);\n\twindow.setWindowTitle(\"Tool Tip\");\n\twindow.show();\n\n\treturn app.exec();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"test_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\nusing namespace std;\n\nint main() {\n\tint sec , min, hr , totals , totalm , totalhr , rem , totaldone , total , remsec, remmin, remhr , percentage;\n\tchar x;\n\tdo\n\t{\n\tcout << \"inter your project time : \\n\";\n\tcout << \"hr = \";\n\tcin >> totalhr;\n\tcout << \"min = \";\n\tcin >> totalm;\n\tcout << \"sec = \";\n\tcin >> totals;\n\tcout << \"inter your project time done : \\n\";\n\tcout << \"hr = \";\n\tcin >> hr;\n\tcout << \"min = \";\n\tcin >> min;\n\tcout << \"sec = \";\n\tcin >> sec;\n\t\n\ttotal = totals + (totalm * 60) + (totalhr * 3600);\n\ttotaldone = sec + (min * 60) + (hr * 3600);\n\trem = total - totaldone;\n\tremhr = (rem / 3600);\n\tremmin = (rem / 60) - (remhr*60);\n\tremsec = rem - ((remhr * 3600) + (remmin * 60));\n\tpercentage = totaldone *100 / total;\n\t\n\tfor (int i = 1; i <= 50; i++)\n\t{\n\t\tif (i==1)\n\t\t{\n\t\t\tcout << \"|\";\n\t\t}\n\t\tif (i<=percentage/2)\n\t\t{\n\t\t\tcout << \"/\";\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t\tif (i == 50)\n\t\t{\n\t\t\tcout << \"|\";\n\t\t}\n\t}\n\n\tcout << \" about \" << percentage << \"% done\\nremaning :\" << remhr << \" hr: \" << remmin << \" min: \" << remsec << \" sec \\n\";\n\tcout << \"do you want to repeat press (a) , any key to end\\n\";\n\tcin >> x;\n\t} while (x == 'a');\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\n// Function to compute modular exponentiation\nlong long powerMod(long long base, long long exponent, long long modulus) {\n    long long result = 1;\n    base = base % modulus;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % modulus;\n        }\n        exponent = exponent >> 1;\n        base = (base * base) % modulus;\n    }\n    return result;\n}\n\n// Function to compute modular inverse using Extended Euclidean Algorithm\nlong long modInverse(long long a, long long m) {\n    long long m0 = m, t, q;\n    long long x0 = 0, x1 = 1;\n    if (m == 1) return 0;\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m;\n        a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nint main() {\n    long long p, q, e;\n    long long encryptedMessage;\n    cout << \"Enter values for p, q, and e: \";\n    cin >> p >> q >> e >>encryptedMessage;\n    long long N = p * q;\n    long long phiN = (p - 1) * (q - 1);\n    long long d = modInverse(e, phiN);\n    long long decryptedMessage = powerMod(encryptedMessage, d, N);\n    cout << \"Decrypted message: \" << decryptedMessage << endl;\n    return 0;\n}\n",
    "#include<iostream>\n#include<fstream>\n#include<cstdlib>\n\nclass Sorting { // sorting class implementing all 3 kinds of sorting methods as static function\npublic:\n\n    /*-----------------------swap function------------------------*/\n\n    static void swap(int* a, int* b) { // swap 2 input element's value\n        int temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n\n    /*-----------------------median function------------------------*/\n\n    static int median(int a, int b, int c) { // function for finding median of 3 input numbers\n        if ((a <= b && b <= c) || (c <= b && b <= a)) { return b; }\n        else if ((b <= a && a <= c) || (c <= a && a <= b)) { return a; }\n        else { return c; }\n    }\n\n    /*-----------------------naive quick sort------------------------*/\n\n    static int partition(int* unsorted, int start, int end) { //parition the given array based on comparing to pivot, and return the index of pivot's right position\n        int pivot = unsorted[end]; // set the pivot as end of the array\n        int i = start - 1;\n\n        for (int j = start; j <= end - 1; j++) { // j is for scan array, i is the last index of left sub array\n            if (unsorted[j] < pivot) { // if some element is less than pivot, put in in the left sub array\n                i++;\n                swap(&unsorted[i], &unsorted[j]); // switch the first element right sub array and j so the boundary of left sub array increased by 1.\n            }\n        }\n\n        unsorted[end] = unsorted[i + 1]; // after full divide, set the pivot's right position and return\n        unsorted[i + 1] = pivot;\n        return i + 1;\n    }\n\n    static void nquick_sort(int* unsorted, int start, int end) {\n        if (start < end) {\n            int q = partition(unsorted, start, end);\n            nquick_sort(unsorted, start, q-1);\n            nquick_sort(unsorted, q+1, end);\n        }\n    }\n\n    /*----------------randomized quick sort : median of 3 method------------------------*/\n\n    static int rand_partition(int* unsorted, int start, int end) { // partition functoin for setting pivot as median of 3\n\n        int rand1 = start + rand() % (end - start + 1); //get 3 random numbers\n        int rand2 = start + rand() % (end - start + 1);\n        int rand3 = start + rand() % (end - start + 1);\n\n        int pivot = median(unsorted[rand1], unsorted[rand2], unsorted[rand3]); // set the median value as pivot\n        int pivot_index = 0;\n\n        if (pivot == unsorted[rand1]) { pivot_index = rand1; }\n        else if (pivot == unsorted[rand2]) { pivot_index = rand2; }\n        else { pivot_index = rand3; }\n\n        swap(&unsorted[pivot_index], &unsorted[end]); // swap the last element with pivot, and use the same partition function above.\n\n        return partition(unsorted, start, end); \n\n    }\n\n    static void rquick_sort(int* unsorted, int start, int end) {\n        if (start < end) {\n            int q = rand_partition(unsorted, start, end);\n            rquick_sort(unsorted, start, q - 1);\n            rquick_sort(unsorted, q + 1, end);\n        }\n    }\n\n    /*-----------------------------------Tail recursive quick sort (for better space complexity) -----------------------------------*/\n\n\n    static void tquick_sort(int* unsorted, int start, int end) { // tail recursive quick sort\n        while (start < end) {\n            int q = rand_partition(unsorted, start, end); // use the randomized partition method to avoid worst case\n            if (q - start < end - q) {\n                tquick_sort(unsorted, start, q - 1);\n                start = q + 1; // set the start as the first index of smaller sub array, and partition large one smaller again.\n            }\n            else {\n                tquick_sort(unsorted, q + 1, end);\n                end = q - 1;\n            }\n        }\n    }\n\n};\n\nint main(int argc, char* argv[]) { // execute in CLI with \"compiledname\", \"inputfile\", \"outputfile\"\n\n    /*----------check number of arguments -------------------------------------------------*/\n\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input_file> <output_file>\" << std::endl;\n        return 1;\n    }\n\n    /*------------------------check input file opened--------------------------------------*/\n\n    std::ifstream input_file(argv[1]);\n\n    if (!input_file.is_open()) {\n        std::cerr << \"Error opening input file: \" << argv[1] << std::endl;\n        return 1;\n    }\n\n    /*------------------------------get data from input.txt---------------------------*/\n\n    int input_size;\n    input_file >> input_size; // get the number of input (first line)\n\n    int* input_array = new int[input_size]; // array for storing unsorted numbers\n\n    for (int i = 0; i < input_size; ++i) { // get the unsorted numbers (second line)\n        input_file >> input_array[i];\n    }\n\n    input_file.close();\n\n    /*-------------copy the input value for each method --------------*/\n\n    int* naive_input = new int[input_size];\n    int* rand_input = new int[input_size];\n    int* tailrecur",
    "#include<iostream>\nusing namespace std;\n\nclass student{\n\t\n\tprivate:\n\t  int roll;\n\t  int mark1;\n\t  int mark2;\n\t  int mark3;\n\t  \n\t   void total(){\n\t   \tint sum= this->mark1+this->mark2+  this->mark3;\n\t     cout<<\"total= \"<<sum<<endl;\n\t   }\n\t   \n\t   void percentage(){\n\t   \t   \n\t   \t int per=this->mark1+this->mark2+  this->mark3;\n\t   \t     \n\t   \t\n\t   }\n\t   \n\t   \n   public:\n\n     student(){\n     \tcout<<\"parameter less!!!\"<<\"\\n\";\n     \tthis->roll=0;\n     \tthis->mark1=0;\n     \tthis->mark2=0;\n        this->mark3=0;\n\t }\n\t\n\tstudent(int roll,int mark1,int mark2,int mark3){\n\t\t\tcout<<\"parameterized!!!\"<<\"\\n\";\n\t\t this->roll=roll; \n\t\t this->mark1=mark1; \n\t\t this->mark2=mark2; \n\t\t this->mark3=mark3;\n\t}\n\t\n\n\tvoid display(){\n\t\tvoid total();\n\t\n\tcout<<\"roll=\"<<this->roll<<endl;\n\tcout<<\"mark1=\"<<this->mark1<<endl;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n\tcout<<\"mark2=\"<<this->mark2<<endl;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n\tcout<<\"mark3=\"<<this->mark3<<endl;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n\t\n\t}\n\t\n\t\n\t\n\t\n\t\n};\n\n\n\nint main(){\n\tstudent s1(7,10,10,10);\n\ts1.display();\n\n\t\n}\n",
    "#include <stdio.h>\n#include <time.h>\n#include <Windows.h>\ntypedef struct {\t//\u5b57\u6bcd\u7ed3\u6784\u4f53\n\tint x, y;\n\tchar ch;\n} RAINDROP;\nconst int BUFFER_SIZE = 100;\nint WIDTH = 80;\nint HEIGHT = 30;\nconst int RAIN_LENGTH = 18;\nRAINDROP raindropLine[BUFFER_SIZE];\nHANDLE HOUT = GetStdHandle(STD_OUTPUT_HANDLE);\t//\u83b7\u5f97\u6807\u51c6\u8f93\u51fa\u7684\u53e5\u67c4\nvoid gotoxy(int x, int y) {\n\tCOORD pos;\t\t\t\t//\u5b9a\u4e49\u8868\u793a\u4e00\u4e2a\u5b57\u7b26\u5728\u63a7\u5236\u53f0\u5c4f\u5e55\u4e0a\u7684\u5750\u6807\u7684\u5bf9\u8c61\n\tpos.X = x;\n\tpos.Y = y;\n\tSetConsoleCursorPosition(HOUT, pos);\t//\u8bbe\u7f6e\u63a7\u5236\u53f0\u6807\u51c6\u8f93\u51fa\u5149\u6807\u4f4d\u7f6e\n}\nvoid show_cursor(BOOL hide) {\n\tCONSOLE_CURSOR_INFO cciCursor;\n\tif (GetConsoleCursorInfo(HOUT, &cciCursor)) {\t//\u83b7\u5f97\u5149\u6807\u4fe1\u606f\n\t\tcciCursor.bVisible = hide;\t\t\t\t\t//\u9690\u85cf\u5149\u6807\t\t\n\t\tSetConsoleCursorInfo(HOUT, &cciCursor);\t\t//\u91cd\u65b0\u8bbe\u7f6e\u5149\u6807\n\t}\n}\nvoid set_color(int color) {\n\tSetConsoleTextAttribute(HOUT, color);\t\t//\u8bbe\u7f6e\u8f93\u51fa\u989c\u8272\n}\nint main() {\n\tCONSOLE_SCREEN_BUFFER_INFO info;\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    // \u5c1d\u8bd5\u6700\u5927\u5316\u63a7\u5236\u53f0\u7a97\u53e3\n    HWND consoleWindow = GetConsoleWindow();\n    ShowWindow(consoleWindow, SW_MAXIMIZE);\n\n    // \u83b7\u53d6\u5f53\u524d\u5c4f\u5e55\u7f13\u51b2\u533a\u4fe1\u606f\n    GetConsoleScreenBufferInfo(hConsole, &info);\n    \n    // \u8bbe\u7f6e\u7f13\u51b2\u533a\u5c3a\u5bf8\u4e3a\u5c4f\u5e55\u5c3a\u5bf8\n    COORD bufferSize;\n    bufferSize.X = info.dwMaximumWindowSize.X; // \u5c4f\u5e55\u5bbd\u5ea6\n    bufferSize.Y = info.dwMaximumWindowSize.Y; // \u5c4f\u5e55\u9ad8\u5ea6\uff08\u6216\u6839\u636e\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u8f83\u5927\u7684\u503c\uff09\n    SetConsoleScreenBufferSize(hConsole, bufferSize);\n\tGetConsoleScreenBufferInfo(HOUT, &info);\t//\u83b7\u5f97\u63a7\u5236\u53f0\u7a97\u4f53\u4fe1\u606f\n\tHEIGHT = info.srWindow.Bottom;\t\t\t\t//\u6839\u636e\u63a7\u5236\u53f0\u7684\u5bbd\u9ad8\u8bbe\u7f6e\u663e\u793a\u7684\u5bbd\u9ad8\n\tWIDTH = info.srWindow.Right;\n\tshow_cursor(FALSE);\n\tsrand((unsigned int)time(NULL));\n\tfor (int i=0; i<BUFFER_SIZE; i++) {\t\t\t//\u968f\u673a\u8bbe\u7f6e\u5b57\u6bcd\u4e0b\u843d\u7684\u4f4d\u7f6e \n\t\traindropLine[i].x = rand()%WIDTH;\n\t\traindropLine[i].y = rand()%HEIGHT;\n\t\traindropLine[i].ch = rand() %26 + 97;\n\t}\t\t\t\n\twhile(true) {\n\t\tGetConsoleScreenBufferInfo(HOUT, &info);\t//\u5f53\u7a97\u4f53\u5927\u5c0f\u53d8\u5316\u65f6\uff0c\u91cd\u65b0\u8bbe\u7f6e\u5bbd\u9ad8\u4fe1\u606f\n\t\tHEIGHT = info.srWindow.Bottom;\n\t\tWIDTH = info.srWindow.Right;\n\t\tfor (int i=0; i<BUFFER_SIZE; ++i)\t\t{\n\t\t\tif (raindropLine[i].y <= HEIGHT)\t\t\t{\n\t\t\t\tgotoxy(raindropLine[i].x, raindropLine[i].y);\n\t\t\t\tset_color(FOREGROUND_GREEN);\t\t\t\t//\u8bbe\u7f6e\u5b57\u6bcd\u989c\u8272\n\t\t\t\tputchar(raindropLine[i].ch);\n\t\t\t}\n\t\t\tgotoxy(raindropLine[i].x, raindropLine[i].y - RAIN_LENGTH);\t//\u64e6\u9664\u8fc7\u957f\u7684\u5b57\u6bcd \n\t\t\tputchar(' ');\n\t\t\traindropLine[i].y++;\n\t\t\traindropLine[i].ch = rand() % 26 + 97;\n\t\t\tif (raindropLine[i].y > HEIGHT + RAIN_LENGTH)\t\t\t\t\t{\n\t\t\t\traindropLine[i].x = rand() % WIDTH;\n\t\t\t\traindropLine[i].y = rand() % HEIGHT;\n\t\t\t}\n\t\t\tif ( raindropLine[i].y <= HEIGHT) {\n\t\t\t\tgotoxy(raindropLine[i].x, raindropLine[i].y);\n\t\t\t\tset_color(FOREGROUND_GREEN|FOREGROUND_INTENSITY);\t//\u9ad8\u4eae\u6700\u4e0b\u65b9\u7684\u5b57\u6bcd\t\t\n\t\t\t\tputchar(raindropLine[i].ch);\n\t\t\t}\n\t\t}\n\t\tSleep(50);\n\t}\n\tgetchar();\n\treturn 0;\n}\n",
    "#include <QtTest>\n\n// add necessary includes here\n\nclass TestReadingFile : public QObject\n{\n    Q_OBJECT\n\npublic:\n    TestReadingFile();\n    ~TestReadingFile();\n\nprivate slots:\n    void test_case1(); // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0442\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u0430\n\n};\n\nTestReadingFile::TestReadingFile()\n{\n\n}\n\nTestReadingFile::~TestReadingFile()\n{\n\n}\n\nvoid TestReadingFile::test_case1()\n{\n    QString filePath = \"C:\\\\Qt\\\\cods\\\\Kurs_project\\\\test.txt\"; // \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u043f\u0443\u0442\u044c \u043a \u0432\u0430\u0448\u0435\u043c\u0443 \u0444\u0430\u0439\u043b\u0443\n    QFile file(filePath);\n\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        QFAIL(\"Could not open file\");\n    }\n\n    QTextStream in(&file);\n    QString line;\n    QStringList data;\n\n    QString expectedSurname = \"\u041a\u043e\u0437\u043b\u043e\u0432\"; // \u041e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f \u0444\u0430\u043c\u0438\u043b\u0438\u044f\n    QString expectedName = \"\u041f\u0435\u0442\u0440\"; // \u041e\u0436\u0438\u0434\u0430\u0435\u043c\u043e\u0435 \u0438\u043c\u044f\n    QString expectedPatronomic = \"\u0421\u0435\u0440\u0433\u0435\u0435\u0432\u0438\u0447\"; // \u041e\u0436\u0438\u0434\u0430\u0435\u043c\u043e\u0435 \u043e\u0442\u0447\u0435\u0441\u0442\u0432\u043e\n\n    // \u0427\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\n    while (!in.atEnd()) {\n        line = in.readLine();\n        data = line.split(\":\");\n        if (data.size() == 2) {\n            QString field = data[0].trimmed();\n            QString value = data[1].trimmed();\n            if (field == \"\u0424\u0430\u043c\u0438\u043b\u0438\u044f\") {\n                QCOMPARE(value, expectedSurname); // \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u0444\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441 \u043e\u0436\u0438\u0434\u0430\u0435\u043c\u044b\u043c\n            } else if (field == \"\u0418\u043c\u044f\") {\n                QCOMPARE(value, expectedName); // \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u0444\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441 \u043e\u0436\u0438\u0434\u0430\u0435\u043c\u044b\u043c\n            } else if (field == \"\u041e\u0442\u0447\u0435\u0441\u0442\u0432\u043e\") {\n                QCOMPARE(value, expectedPatronomic); // \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u0444\u0430\u043a\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441 \u043e\u0436\u0438\u0434\u0430\u0435\u043c\u044b\u043c\n            }\n            // \u0414\u043e\u0431\u0430\u0432\u044c\u0442\u0435 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0434\u043b\u044f \u0434\u0440\u0443\u0433\u0438\u0445 \u043f\u043e\u043b\u0435\u0439, \u0435\u0441\u043b\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e...\n        }\n    }\n\n    file.close(); // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u043f\u043e\u0441\u043b\u0435 \u0447\u0442\u0435\u043d\u0438\u044f\n}\n\nQTEST_APPLESS_MAIN(TestReadingFile) // \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u043a\u0438 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u0442\u0435\u0441\u0442\u043e\u0432\n\n#include \"tst_testreadingfile.moc\" // \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e moc-\u0444\u0430\u0439\u043b\u0430\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int x, y;\n    start:\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c: \";\n    cin >> x;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u043d\u0430\u043c\u0435\u043d\u0430\u0442\u0435\u043b\u044c: \";\n    cin >> y;\n\n    if (y == 0) {\n        cout << \"\u041d\u0430 0 \u0434\u0435\u043b\u0438\u0442\u044c \u043d\u0435\u043b\u044c\u0437\u044f!\\n\";\n        goto start;\n    }\n\n    cout << \"------C\u0447\u0438\u0442\u0430\u0435\u043c------\\n\";\n\n    bool answer = false;\n    int divisor = 1;    \n\n    if (x % y == 0) {\n        x /= y;\n        answer = true;\n    }\n    else {\n        while (divisor < y) {\n            //cout << \"error\";\n            if (x % divisor == 0 && y % divisor == 0) {\n                x /= divisor;\n                y /= divisor;\n            }            \n            divisor++;            \n        }\n    }\n\n    if (x < 0 && y < 0) {\n        x = -x;\n        y = -y;\n    }\n\n    if (answer) {\n        cout << \"\u041e\u0442\u0432\u0435\u0442: \" << x << endl;\n    }\n    else if (x > y) {\n        int answer = x / y;\n        x %= y;\n        string whole[2] = { \" \u0446\u0435\u043b\u0430\u044f\", \" \u0446\u0435\u043b\u044b\u0445\" };\n        int ending = 1;\n        if (answer % 10 == 1) ending = 0;\n        cout << \"\u041e\u0442\u0432\u0435\u0442: \" << answer << whole[ending] << \" \u0438 \" << x << \"/\" << y << endl;\n    }\n    else {\n        cout << \"\u041e\u0442\u0432\u0435\u0442: \" << x << \"/\" << y << endl;\n    }\n\n\n\n\n\n\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <time.h>\n#include <iomanip>\n#include <limits.h>\n\nusing namespace std;\n\nint searchMin(int* massiv, int massivSize, int startIndex, int& min);\nvoid initAndPrintMassiv(int* massiv, int massivSize);\nvoid searchMax(int* massiv, int massivSize);\nvoid searchMax(int massiv[][3], int massivSize, int secondSize);\nvoid searchMax(int massiv[][2][2], int massivSize, int secondSize, int thirdSize);\nvoid searchMax(int number1, int number2);\nvoid searchMax(int number1, int number2, int number3);\n\n\n\n\nint main()\n{\n    \n    setlocale(LC_ALL, \"RU\");\n    srand((int)time(NULL));\n    int const massivSize = 100;\n    int massiv[massivSize];\n    int min = INT_MAX;\n    initAndPrintMassiv(massiv, massivSize);\n    searchMin(massiv, massivSize, 0, min);\n    std::cout << \"\u00ec\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee = \" << min << endl;\n    return 0;\n}\n\nint searchMin(int* massiv, int massivSize, int startIndex, int& min)\n{\n    int localMin = 0;\n    if (startIndex + 9 == massivSize)\n    {\n        return 0;\n    }\n    for (int i = startIndex; i < startIndex + 10; i++)\n    {\n        localMin += massiv[i];\n    }\n    if (localMin < min)\n    {\n        min = localMin;\n    }\n   \n    return searchMin(massiv, massivSize, startIndex + 1, min);\n}\n\n\nvoid initAndPrintMassiv(int* massiv, int massivSize)\n{\n    for (int i = 0; i < massivSize; i++)\n    {\n        *(massiv + i) = rand() % 101;\n        std::cout << fixed << setw(4) << *(massiv + i) << \" \";\n        if (i % 10 == 9)\n        {\n            std::cout << endl;\n        }\n    }\n}\n//\u00e7\u00e0\u00e4\u00e0\u00f7\u00e0 2\nint const massivSize = 10;\nint const massivSize2 = 3;\nint const massivSize3 = 2;\nint massiv1[massivSize] = {1,2,3,4,5,6,7,8,9,10 };\nint massiv2[massivSize2][massivSize2] = { {8,7,6},{5,4,3},{2,1,9} };\nint massiv3[massivSize3][massivSize3][massivSize3] = { {{2,2},{3,3}},{{4,8},{8,7}} };\nint number1 = 2;\nint number2 = 4;\nint number3 = 6;\nvoid searchMax(int* massiv, int massivSize)\n{\n    std::cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e2 \u00ee\u00e4\u00ed\u00ee\u00ec\u00e5\u00f0\u00ed\u00ee\u00ec \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5\" << endl <<\n        \"    \";\n    int max = massiv[0];\n    int index = 0;\n    for (int i = 0; i < massivSize; i++)\n    {\n        cout << massiv[i] << \" \";\n        if (massiv[i] > max)\n        {\n            max = massiv[i];\n            index = i;\n        }\n    }\n    std::cout << endl << \"  \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e2 \u00ec\u00e0\u00f1\u00f1\u00f1\u00e8\u00e2\u00e5[\" << index << \"] = \" << max << endl << endl;\n}\n\nvoid searchMax(int massiv[][3], int massivSize, int secondSize)\n{\n    std::cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e2 \u00e4\u00e2\u00f3\u00f5\u00ec\u00e5\u00f0\u00ed\u00ee\u00ec \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5\" <<\n        endl << \"   Array:\" << endl << \"   \";\n    int max = massiv[0][0];\n    int index1 = 0;\n    int index2 = 0;\n    for (int i = 0; i < massivSize; i++)\n    {\n        for (int j = 0; j < secondSize; j++)\n        {\n            std::cout << massiv[i][j] << \" \";\n            if (massiv[i][j] > max)\n            {\n                max = massiv[i][j];\n                index1 = i;\n                index2 = j;\n            }\n        }\n        std::cout << endl << \"   \";\n    }\n    std::cout << \"\u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f0\u00e0\u00e2\u00e5\u00ed[\" << index1 << \"][\" << index2 << \"] = \" << max << endl << endl;\n}\n\nvoid searchMax(int massiv[][2][2], int massivSize, int secondSize, int thirdSize)\n{\n    std::cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5\" << endl;\n    int max = massiv[0][0][0];\n    int index1 = 0;\n    int index2 = 0;\n    int index3 = 0;\n    for (int i = 0; i < massivSize; i++)\n    {\n        for (int j = 0; j < secondSize; j++)\n        {\n            for (int k = 0; k < thirdSize; k++)\n            {\n                if (massiv[i][j][k] > max)\n                {\n                    max = massiv[i][j][k];\n                    index1 = i;\n                    index2 = j;\n                    index3 = k;\n                }\n            }\n        }\n    }\n    std::cout << \"   \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f0\u00e0\u00e2\u00e5\u00ed[\" << index1 << \"][\" << index2 << \"][\" <<\n        index3 << \"] = \" << max << endl << endl;\n}\n\nvoid searchMax(int number1, int number2)\n{\n    cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00ec\u00e5\u00e6\u00e4\u00f3 \u00e4\u00e2\u00f3\u00f5 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00f5\" << endl << \"   \" << number1;\n    if (number1 > number2)\n    {\n        cout << \" > \";\n    }\n    else if (number1 < number2)\n    {\n        cout << \" < \";\n    }\n    else\n    {\n        cout << \" = \";\n    }\n    cout << number2 << endl << endl;\n}\n\nvoid searchMax(int number1, int number2, int number3)\n{\n    cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00ec\u00e5\u00e6\u00e4\u00f3 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00ec\u00e8\" << endl;\n\n    int max = number1;\n    if (number1 > number2)\n    {\n        if (number1 >= number3)\n        {\n            max = number1;\n        }\n        else\n        {\n            max = number3;\n        }\n    }\n    else if (number1 < number2)\n    {\n        if (number2 >= number3)\n        {\n            max = number2;\n        }\n        else\n        {\n            max = number3;\n        }\n    }\n    else\n    {\n        if (number2 >= number3)\n        {\n            max = number2;\n        }\n        else\n        {\n            max = number3;\n        }\n    }\n\n    std::cout << \"   \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e5 \u00ec\u00e5\u00e6\u00e4\u00f3 : \" << number1 << \" \" << number2 << \" \" <<\n        nu",
    "#include <iostream>\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstruct Date {\n  int day, month, year;\n\n  Date(int d, int m, int y) : day(d), month(m), year(y) {}\n\n  bool isValidDate() {\n    if (year < 0)\n      return false;\n    if (month < 0 || month > 11)\n      return false;\n    if (day < 1 || day > daysInMonth(month, year))\n      return false;\n    return true;\n  }\n\n  void newDate(int d, int m, int y) {\n    day = d;\n    month = m;\n    year = y;\n  }\n\n  // void printDate() {\n  //   static const string months[] = {\n  //       \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n  //       \"August\", \"September\", \"October\", \"November\", \"December\"\n  //   };\n  //   cout << day << \" \" << months[month] << \", \" << year << endl;\n  // }\n\n  string printDate() {\n    // used static to run it faster. It is not going to be initialized each time\n    static const string months[] = {\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n        \"August\", \"September\", \"October\", \"November\", \"December\"\n    };\n    stringstream ss;\n    ss << day << \" \" << months[month] << \" \" << year;\n    return ss.str();\n  }\n\n  // The first const before Date& other indicates that the other parameter is passed as a reference to a constant and will not be changed inside the method. The second const used after the parentheses indicates that this method does not change the state of the current Date object for which it is called\n  bool operator<(const Date& other) const {\n    if (year != other.year)\n      return year < other.year;\n    if (month != other.month)\n      return month < other.month;\n    return day < other.day;\n  }\n\n  int daysInMonth(int month, int year) {\n    switch (month) {\n      case 0: \n      case 2: \n      case 4: \n      case 6:\n      case 7: \n      case 9: \n      case 11:\n        return 31;\n      case 3: \n      case 5: \n      case 8: \n      case 10:\n        return 30;\n      case 1:\n        return (isLeapYear(year)) ? 29 : 28;\n      default:\n        throw std::logic_error(\"Invalid month\");\n    }\n  }\n  bool isLeapYear(int y) const {\n    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\n  }\n\n  int getDayOfWeek() {\n    int d = day, m = month, y = year;\n    if (m < 3) {\n      m += 12;\n      y--;\n    }\n    int k = y % 100;\n    int j = y / 100;\n    int h = (d + (13 * (m+1)) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;\n    // h = 0 corresponds to Saturday, 1 to Sunday, and so on\n    return (h + 5) % 7;\n  }\n\n  int calculateDifference(const Date& other) const {\n    // Convert both dates to days since a reference date (e.g., January 1, 0 AD)\n    int days1 = day + 31 * (month - 1) + 365 * (year);\n    for (int i = 0; i < year; i++) {\n      if (isLeapYear(i))\n        days1++;\n    }\n\n    int days2 = other.day + 31 * (other.month - 1) + 365 * (other.year);\n    for (int i = 0; i < other.year; i++) {\n      if (other.isLeapYear(i))\n        days2++;\n    }\n\n    // Calculate the difference in days\n    return abs(days2 - days1);\n  }\n};\n\nint main() {\n  string daysOfWeek[] = {\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"};\n  Date d1(13, 3, 2024);\n  Date d2(26, 7, 2024);\n  Date d3(29, 1, 2024);\n  Date d4(12, 6, 2012);\n\n  d2.newDate(25, 7, 2024);\n\n  cout << d2.printDate() << \" is \" << daysOfWeek[d2.getDayOfWeek() - 2] << endl;\n  cout << d1.calculateDifference(d2) << \" days between \" << d1.printDate() << \" and \" << d2.printDate() << endl;\n\n  vector<Date> dates = {d1, d2, d3, d4};\n\n  sort(dates.begin(), dates.end());\n\n  cout << \"Sorted dates:\" << endl;\n  for (auto date : dates) {\n    cout << date.printDate() << endl;\n  }\n\n  return 0;\n}",
    "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"avb_ops_user.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/fs.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <cutils/properties.h>\n#include <fs_mgr.h>\n\n#include <libavb_ab/libavb_ab.h>\n\nusing android::fs_mgr::Fstab;\nusing android::fs_mgr::GetEntryForMountPoint;\nusing android::fs_mgr::ReadDefaultFstab;\nusing android::fs_mgr::ReadFstabFromFile;\n\n/* Open the appropriate fstab file and fallback to /fstab.device if\n * that's what's being used.\n */\nstatic bool open_fstab(Fstab* fstab) {\n  return ReadDefaultFstab(fstab) || ReadFstabFromFile(\"/fstab.device\", fstab);\n}\n\nstatic int open_partition(const char* name, int flags) {\n  char* path;\n  int fd;\n\n  /* Per https://android-review.googlesource.com/c/platform/system/core/+/674989\n   * Android now supports /dev/block/by-name/<partition_name> ... try that\n   * first.\n   */\n  path = avb_strdupv(\"/dev/block/by-name/\", name, NULL);\n  if (path != NULL) {\n    fd = open(path, flags);\n    avb_free(path);\n    if (fd != -1) {\n      return fd;\n    }\n  }\n\n  /* OK, so /dev/block/by-name/<partition_name> didn't work... so we're\n   * falling back to what we used to do before that:\n   *\n   * We can't use fs_mgr to look up |name| because fstab doesn't list\n   * every slot partition (it uses the slotselect option to mask the\n   * suffix) and |slot| is expected to be of that form, e.g. boot_a.\n   *\n   * We can however assume that there's an entry for the /misc mount\n   * point and use that to get the device file for the misc\n   * partition. From there we'll assume that a by-name scheme is used\n   * so we can just replace the trailing \"misc\" by the given |name|,\n   * e.g.\n   *\n   *   /dev/block/platform/soc.0/7824900.sdhci/by-name/misc ->\n   *   /dev/block/platform/soc.0/7824900.sdhci/by-name/boot_a\n   *\n   * If needed, it's possible to relax this assumption in the future\n   * by trawling /sys/block looking for the appropriate sibling of\n   * misc and then finding an entry in /dev matching the sysfs entry.\n   */\n\n  Fstab fstab;\n  if (!open_fstab(&fstab)) {\n    return -1;\n  }\n  auto record = GetEntryForMountPoint(&fstab, \"/misc\");\n  if (record == nullptr) {\n    return -1;\n  }\n  if (strcmp(name, \"misc\") == 0) {\n    path = strdup(record->blk_device.c_str());\n  } else {\n    size_t trimmed_len, name_len;\n    const char* end_slash = strrchr(record->blk_device.c_str(), '/');\n    if (end_slash == NULL) {\n      return -1;\n    }\n    trimmed_len = end_slash - record->blk_device.c_str() + 1;\n    name_len = strlen(name);\n    path = static_cast<char*>(calloc(trimmed_len + name_len + 1, 1));\n    strncpy(path, record->blk_device.c_str(), trimmed_len);\n    strncpy(path + trimmed_len, name, name_len);\n  }\n\n  fd = open(path, flags);\n  free(path);\n\n  return fd;\n}\n\nstatic AvbIOResult read_from_partition(AvbOps* ops,\n                                       const char* partition,\n                                       int64_t offset,\n                                       size_t num_bytes,\n                                       void* buffer,\n                                       size_t* out_num_read) {\n  int fd;\n  off_t where;\n  ssize_t num_read;\n  AvbIOResult ret;\n\n  fd = open_partition(partition, O_RDONLY);\n  if (fd == -1) {\n    ret = AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;\n    goto out;\n  }\n\n  if (offset < 0) {\n    uint64_t partition_size;\n    if (ioctl(fd, BLKGETSIZE64, &partition_size) != 0) {\n      avb_error(\"Error getting size of \\\"\", partition, \"\\\" partition.\\n\");\n      ret = AVB_IO_RESULT_ERROR_IO;\n      goto out;\n    }\n    offset = partition_size - (-offset);\n  }\n\n  where = lseek(fd, offset, SEEK_SET);\n  if (where == -1) {\n    avb_error(\"Error seeking to offset.\\n\");\n    ret = AVB_IO_RESULT_ERROR_IO;\n    goto out;\n  }\n  if (where != offset) {\n    avb_error(\"Error se",
    "// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"Robot.h\"\n\n#include <frc2/command/CommandScheduler.h>\n\nvoid Robot::RobotInit() {}\n\nvoid Robot::RobotPeriodic() {\n  frc2::CommandScheduler::GetInstance().Run();\n}\n\nvoid Robot::DisabledInit() {}\n\nvoid Robot::DisabledPeriodic() {}\n\nvoid Robot::DisabledExit() {}\n\nvoid Robot::AutonomousInit() {\n  m_autonomousCommand = m_container.GetAutonomousCommand();\n\n  if (m_autonomousCommand) {\n    m_autonomousCommand->Schedule();\n  }\n}\n\nvoid Robot::AutonomousPeriodic() {}\n\nvoid Robot::AutonomousExit() {}\n\nvoid Robot::TeleopInit() {\n  if (m_autonomousCommand) {\n    m_autonomousCommand->Cancel();\n  }\n}\n\nvoid Robot::TeleopPeriodic() {}\n\nvoid Robot::TeleopExit() {}\n\nvoid Robot::TestInit() {\n  frc2::CommandScheduler::GetInstance().CancelAll();\n}\n\nvoid Robot::TestPeriodic() {}\n\nvoid Robot::TestExit() {}\n\n#ifndef RUNNING_FRC_TESTS\nint main() {\n  return frc::StartRobot<Robot>();\n}\n#endif\n",
    "#include \"mainwindow.h\"\n#include \"Models/pointtopoint.h\"\n#include \"ui_mainwindow.h\"\n#include <spline.h>\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    h = 0.01;\n    ui->graph->setInteraction(QCP::iRangeZoom, true);\n    ui->graph->setInteraction(QCP::iRangeDrag, true);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::on_CalculationDerivatives_clicked()\n{\n    ui->textEdit->clear();\n    ui->textEdit->setPlainText(\"\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u043d\u043e\u0439:\");\n\n    double X = ui->pointGraph->text().toFloat();\n    double prevTmp = 0;\n    double tmp = PointToPoint::CalculationFormulaRigth(X, pow(10, -1));\n\n    ui->textEdit->setPlainText(ui->textEdit->toPlainText() + \"\\n\" + QString::number(tmp));\n    int i = 2;\n    do {\n        prevTmp = tmp;\n        tmp = PointToPoint::CalculationFormulaRigth(X, pow(10, -i));\n        ui->textEdit->setPlainText(ui->textEdit->toPlainText() + \"\\n\" + QString::number(tmp));\n        i++;\n    } while (prevTmp > tmp);\n\n    ui->textEdit->setPlainText(ui->textEdit->toPlainText() + \"\\n\" + \"\u041e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0448\u0430\u0433:\\t\" + \"10 \u0432 -\" + QString::number(i));\n}\n\nvoid MainWindow::on_CreateTable_clicked()\n{\n    ui->tablePoints->setRowCount(ui->NumberPoints->text().toInt());\n}\nvoid MainWindow::on_CreateGraph_clicked()\n{\n    for (int i = 0; i < ui->tablePoints->rowCount(); i++)\n        xs.push_back(ui->tablePoints->item(i, 0)->text().toFloat());\n\n    for (int i = 0; i < ui->tablePoints->rowCount(); i++)\n        ys.push_back(ui->tablePoints->item(i, 1)->text().toFloat());\n    PaintGraph paint(ui,xs,ys);\n    ui->graph->clearItems();\n    ui->graph->clearGraphs();\n    // if(ui->splineButton->isChecked()){\n    //     paint.PaintSpline();\n    //     paint.PaintMatrix();\n    // }\n    // if(ui->diffButton->isChecked()){\n    //     paint.PaintSpline();\n    //     paint.PaintFirstDiff();\n    //     paint.PaintSecondDiff();\n    // }\n\n    //     paint.PaintSpline();\n    //     paint.PaintMatrix();\n\n    //     paint.PaintSpline();\n    //     paint.PaintFirstDiff();\n    //     paint.PaintSecondDiff();\n}\n",
    "#include \"KeyScanner.h\"\n\n\nMatrixKeyPad::MatrixKeyPad(uint8_t *colume, uint8_t *row, uint8_t columns, uint8_t rows) {\n\tthis->columnPins = colume;\n\tthis->rowPins = row;\n\tthis->columns = columns;\n\tthis->rows = rows;\n\n\n\tfor (byte r=0; r<rows; r++) {\n\t\tpin_mode(rowPins[r],OUTPUT);\n\t\tpin_write(rowPins[r], LOW);\n\t}\n\n\tfor (byte i = 0; i < columns; i++)\n\t{\n\t\tpin_mode(columnPins[i], INPUT_PULLDOWN);\n\t}\n\t\n}\n\nvoid MatrixKeyPad::scanner() {\n\t// Serial.println(\"------\");\n\tfor (byte r=0; r<rows; r++) {\n\t\tdigitalWrite(rowPins[r], HIGH);\n\t\tfor (byte c=0; c<columns; c++) {\n\t\t\tlastStatus[r][c][0] = digitalRead(columnPins[c]);\n\t\t}\n\t\tdigitalWrite(rowPins[r], LOW);\n\t}\n}\n\n\nvoid MatrixKeyPad::update() {\n\n\tif (millis() - lastTime < delayTime) return;\n\tlastTime = millis();\n\tthis->scanner();\n\n\tfor (uint8_t r = 0; r < rows; r++)\n\t{\n\t\tfor (uint8_t c = 0; c < columns; c++)\n\t\t{\n\t\t\tif (lastStatus[r][c][0] != lastStatus[r][c][1]) {\n\t\t\t\tlastStatus[r][c][1] = lastStatus[r][c][0];\n\t\t\t\t// Serial.printf(\"key event %d:%d -> %d \\n\", r, c, lastStatus[r][c][0]);\n\t\t\t\tif (eventListener != NULL) {\n\t\t\t\t\teventListener({c, r, lastStatus[r][c][0]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid MatrixKeyPad::addEventListener(void (*listener)(KeyEvent)) {\n\tthis->eventListener = listener;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"mainwindow.h\"\n\n#include \"ui_mainwindow.h\"\n\nusing namespace MyNamespace;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent),\n      ui(new Ui::MainWindow),\n      controller(new Controller()) {\n  ui->setupUi(this);\n  ui->lineEdit->setPlaceholderText(\"Expression\");\n  connect(ui->pushButton_0, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_1, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_2, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_3, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_4, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_5, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_6, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_7, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_8, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_9, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_dot, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_plus, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_minus, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_div, SIGNAL(clicked()), this, SLOT(div_clicked()));\n  connect(ui->pushButton_mult, SIGNAL(clicked()), this, SLOT(mult_clicked()));\n  connect(ui->pushButton_sin, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_cos, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_tan, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_asin, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_acos, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_atan, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_sqrt, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_ln, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_log, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_mod, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_pow, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_op, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_cp, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_x, SIGNAL(clicked()), this,\n          SLOT(digits_and_funcs_clicked()));\n  connect(ui->pushButton_AC, SIGNAL(clicked()), this, SLOT(AC_clicked()));\n  connect(ui->pushButton_bs, SIGNAL(clicked()), this,\n          SLOT(backspace_clicked()));\n  connect(ui->pushButton_equal, SIGNAL(clicked()), this, SLOT(equal_clicked()));\n  connect(ui->pushButton_plot, SIGNAL(clicked()), this, SLOT(plot_clicked()));\n}\n\nMainWindow::~MainWindow() {\n  delete ui;\n  delete controller;\n}\n\nvoid MainWindow::digits_and_funcs_clicked() {\n  QPushButton *button = (QPushButton *)sender();\n  ui->lineEdit->setText(ui->lineEdit->text() + button->text());\n}\n\nvoid MainWindow::mult_clicked() {\n  ui->lineEdit->setText(ui->lineEdit->text() + \" * \");\n}\n\nvoid MainWindow::div_clicked() {\n  ui->lineEdit->setText(ui->lineEdit->text() + \" / \");\n}\n\nvoid MainWindow::AC_clicked() { ui->lineEdit->setText(\"\"); }\n\nvoid MainWindow::backspace_clicked() { ui->lineEdit->backspace(); }\n\nvoid MainWindow::equal_clicked() {\n  QString expression = ui->lineEdit->text();\n  if (expression.contains('x')) {\n    QMessageBox::critical(\n        this, \"Warning\",\n        QString::fromStdString(\"Use \\\"plot\\\" to work with functions\"));\n  } else if (!expression.isEmpty()) {\n    try {\n      controller->calculateValue(expression.toStdString());\n      ui->lineEdit->setText(QString::number(controller->getValue()));\n    } catch (std::string e) {\n      QMessageBox::critical(this, \"Warning\",\n                            QString::fromStdString(\"Invalid data: \" + e));\n    }\n  }\n}\n\nvoid MainWindow::plot_clicked() {\n  QString expression = ui->lineEdit->text();\n  if (!expression.isEmpty()) {\n    try {\n      controller->calculateGraph(expression.toStdString());\n      plotwindow = new PlotWindow(controller, expression);\n      plotwindow->setModal(true);\n      plotwindow->show();\n    } catch (std::string e) {\n      QMessageBox::critical(this, \"Warning\",\n                            QString::fromStdString",
    "#include \"brofile_private/browsers/chromium.hpp\"\n#include <filesystem>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <fstream>\n#include <nlohmann/json.hpp>\n#include <iostream>\n\nbf::chromium::chromium(const std::string &executable, const std::string &config_dir): browser_base(executable), config_dir(config_dir), incognito(false), new_window(false) {}\n\nbool bf::chromium::profiles_available() const {\n  return true;\n}\n\nstd::vector<bf::browser_profile_info> bf::chromium::get_profiles() const {\n  std::vector<bf::browser_profile_info> profiles;\n  std::filesystem::path path = std::filesystem::path(std::getenv(\"HOME\")) / \".config\" / config_dir;\n\n  auto local_state = nlohmann::json::parse(std::ifstream(path / \"Local State\"));\n  for (auto &[key, profile]: local_state[\"profile\"][\"info_cache\"].items()) {\n    profiles.push_back({\n      .name = profile[\"name\"],\n      .path = key\n    });\n  }\n\n  return profiles;\n}\n\nvoid bf::chromium::set_profile(const bf::browser_profile_info &profile) {\n  this->profile = profile.path;\n}\n\nbool bf::chromium::set_url(const std::string &url) {\n  this->url = url;\n  return true;\n}\n\nbool bf::chromium::set_new_window(bool new_window) {\n  this->new_window = new_window;\n  return true;\n}\n\nbool bf::chromium::set_incognito(bool incognito) {\n  this->incognito = incognito;\n  return true;\n}\n\nbool bf::chromium::open() {\n  pid_t pid = fork();\n  if (pid == 0) {\n    _open();\n  } else {\n    waitpid(pid, nullptr, 0);\n    return false;\n  }\n\n  return true;\n}\n\nvoid bf::chromium::_open() const {\n  std::string executable = get_executable();\n  std::vector<std::string> args = { executable };\n\n  if (new_window) {\n    args.push_back(\"--new-window\");\n  }\n\n  if (incognito) {\n    args.push_back(\"--incognito\");\n  }\n\n  if (!profile.empty()) {\n    args.push_back(\"--profile-directory=\" + profile);\n  }\n\n  if (!url.empty()) {\n    args.push_back(url);\n  }\n\n  char **argv = new char*[args.size() + 1];\n  for (size_t i = 0; i < args.size(); i++) {\n    argv[i] = new char[args[i].size() + 1];\n    std::strcpy(argv[i], args[i].c_str());\n  }\n  argv[args.size()] = nullptr;\n\n  execv(executable.c_str(), argv);\n}\n\nstd::string bf::chromium::get_browser_name() const {\n  if (config_dir == \"google-chrome\") {\n    return \"Google Chrome\";\n  } else {\n    return \"Chromium\";\n  }\n}",
    "// LeaveMeAlone Game by Netologia. All Gights Reserved.\n\n\n#include \"Player/LMADefaultCharacter.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/DecalComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\n\n\n\n\n// Sets default values\nALMADefaultCharacter::ALMADefaultCharacter()\n{\n \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSpringArmComponent = CreateDefaultSubobject<USpringArmComponent>(\"SpringArm\");\n//\tSpringArmComponent->SetupAttachment(GetRootComponent());\n\tSpringArmComponent->SetupAttachment(GetMesh(), \"cameraSocket\");\n\tSpringArmComponent->TargetArmLength = DefaultArmLength;\n\n\tCameraComponent = CreateDefaultSubobject<UCameraComponent>(\"CameraComponent\");\n\tCameraComponent->SetupAttachment(SpringArmComponent);\n\n\tSpringArmComponent->SetUsingAbsoluteLocation(true);\n\tSpringArmComponent->TargetArmLength = ArmLength;\n\tSpringArmComponent->SetRelativeRotation(FRotator(YRotation, 0.0f, 0.0f));\n\tSpringArmComponent->bDoCollisionTest = false;\n\tSpringArmComponent->bEnableCameraLag = true;\n\n\tCameraComponent->SetFieldOfView(FOV);\n\tCameraComponent->bUsePawnControlRotation = false;\n\n\tbUseControllerRotationPitch = false;\n\n\tbUseControllerRotationYaw = false;\n\n\tbUseControllerRotationRoll = false;\n\n\n\n}\n\n// Called when the game starts or when spawned\nvoid ALMADefaultCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (CursorMaterial)\n\t{\n\t\tCurrentCursor = UGameplayStatics::SpawnDecalAtLocation(GetWorld(), CursorMaterial, CursorSize, FVector(0));\n\t}\n}\n\n// Called every frame\nvoid ALMADefaultCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tAPlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\tif (PC)\n\t{\n\t\tFHitResult ResultHit;\n\t\tPC->GetHitResultUnderCursor(ECC_GameTraceChannel1, true, ResultHit);\n\t\tfloat FindRotatorResultYaw = UKismetMathLibrary::FindLookAtRotation(GetActorLocation(), ResultHit.Location).Yaw;\n\t\tSetActorRotation(FQuat(FRotator(0.0f, FindRotatorResultYaw, 0.0f)));\n\t\tif (CurrentCursor)\n\t\t{\n\t\t\tCurrentCursor->SetWorldLocation(ResultHit.Location);\n\t\t}\n\t}\n}\n\n\n// Called to bind functionality to input\nvoid ALMADefaultCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(\"MoveForward\", this, &ALMADefaultCharacter::MoveForward);\n\tPlayerInputComponent->BindAxis(\"MoveRight\", this, &ALMADefaultCharacter::MoveRight);\n\n\tPlayerInputComponent->BindAxis(\"CameraZoom\", this, &ALMADefaultCharacter::CameraZoom);\n}\n\nvoid ALMADefaultCharacter::MoveForward(float Value)\n{\n\tAddMovementInput(GetActorForwardVector(), Value);\n}\n\nvoid ALMADefaultCharacter::MoveRight(float Value)\n{\n\tAddMovementInput(GetActorRightVector(), Value);\n}\n\nvoid ALMADefaultCharacter::CameraZoom(float Value) \n{\n\tif (Value == 0 || !Controller)\n\t\treturn;\n\tconst float NewTargetArmLength = SpringArmComponent->TargetArmLength + Value * ZoomStep;\n\tSpringArmComponent->TargetArmLength = FMath::Clamp(NewTargetArmLength, MinZoomLenght, MaxZoomLenght);\n\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Game.hpp\"\n#include \"ThreadPool.hpp\"\n#include <getopt.h>\n\nconstexpr static struct option long_options[] = {\n        { \"help\",    no_argument,       nullptr, 'h' },\n        { \"serial\",    required_argument,      nullptr, 's' },\n        { \"parallel\", required_argument, nullptr, 'p'},\n        { nullptr,  0,                 nullptr, '\\0' }\n};\n\nint main(int argc, char*argv[]){\n    \n    int longidx, NumSimulations, mode;\n    \n    auto start = std::chrono::high_resolution_clock::now();\n    try{\n        longidx = getopt_long(argc, argv, \"hs:p:\", long_options, &longidx);\n        if(longidx == -1 || !optarg) throw InvalidArgument();\n        NumSimulations = (char) longidx == 'h'? 0: std::stoi(optarg),\n        mode = (char) longidx == 's'? 0: 1;\n\n        if((char) longidx == 'h'){\n            std::cerr << \"This is a help message\\n\";\n            exit(0);\n        }\n        else if((char) longidx != 's' && (char) longidx != 'p') throw InvalidArgument();\n        //else if(NumSimulations < 0 || NumSimulations > 200000) throw InvalidArgument();\n    }\n    catch( const InvalidArgument& err ){\n        std::cerr << \"Invalid arguements provided\\n\";\n        exit(1);\n    }\n    \n    \n    if(mode) std::cout << \"parallel\";\n    else std::cout << \"serial\";\n\n    playerHand user;\n    std::cin >> user.first >> user.second;\n\n\n    Game g(user, NumSimulations);\n    g.simulate();\n    g.printResults();\n    auto end = std::chrono::high_resolution_clock::now();\n\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n\n    std::cout << std::endl << (double)duration.count()/1000 << \"s\" << std::endl;\n\n    return 0;\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"Drones/BaseDroneCharacter.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/SceneComponent.h\"\n#include \"ActorComponents/HealthComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Components/SphereComponent.h\"\n#include \"Interfaces/InteractionInterface.h\"\n#include \"DrawDebugHelpers.h\"\n#include \"Projectiles/MyBaseProjectile.h\"\n#include \"ActorComponents/WeaponComponent.h\"\n\nABaseDroneCharacter::ABaseDroneCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tSphereCollision = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereCollision\"));\n\tSphereCollision->SetupAttachment(GetRootComponent());\n\tSphereCollision->SetSphereRadius(150.f);\n\n\tCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"Camera\"));\n\tCamera->SetupAttachment(GetRootComponent());\n\tCamera->bUsePawnControlRotation = true;\n\n\tHealthComponent = CreateDefaultSubobject<UHealthComponent>(TEXT(\"HealthComponent\"));\n\tWeaponComponent = CreateDefaultSubobject<UWeaponComponent>(TEXT(\"WeaponComponent\"));\n}\n\nvoid ABaseDroneCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (APlayerController* PlayerController = Cast<APlayerController>(GetController()))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* SubSystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\tSubSystem->ClearAllMappings();\n\t\t\tSubSystem->AddMappingContext(InputMappingContext, 0);\n\t\t}\n\t}\n\tHealthComponent->OnDeath.AddUObject(this, &ABaseDroneCharacter::Death);\n\tOnTakeAnyDamage.AddDynamic(HealthComponent, &UHealthComponent::MakeDamage);\n\n\tSphereCollision->OnComponentBeginOverlap.AddDynamic(this, &ABaseDroneCharacter::OnBeginOverlap);\n}\n\nvoid ABaseDroneCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\nvoid ABaseDroneCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tif (UEnhancedInputComponent* EnhancedInputComponent = CastChecked<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ABaseDroneCharacter::Move);\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ABaseDroneCharacter::Look);\n\t\tEnhancedInputComponent->BindAction(FireAction, ETriggerEvent::Triggered, this, &ABaseDroneCharacter::StartFire);\n\t}\n}\n\nvoid ABaseDroneCharacter::Move(const FInputActionValue& Value)\n{\n\tconst FVector MovementVector = Value.Get<FVector>();\n\n\tFVector Forward = GetActorForwardVector();\n\tForward.Z = 0;\n\tForward.Normalize();\n\n\tFVector Right = GetActorRightVector();\n\tRight.Z = 0;\n\tRight.Normalize();\n\n\tFVector Up{ 0, 0, 1 };\n\n\tAddMovementInput(Forward, MovementVector.X);\n\tAddMovementInput(Right, MovementVector.Y);\n\tAddMovementInput(Up, MovementVector.Z);\n}\n\nvoid ABaseDroneCharacter::Look(const FInputActionValue& Value)\n{\n\tconst FVector2D MovementVector = Value.Get<FVector2D>();\n\tAddControllerYawInput(MovementVector.X);\n\tAddControllerPitchInput(-MovementVector.Y);\n}\n\nvoid ABaseDroneCharacter::StartFire()\n{\n\tFTransform ProjectileTransform;\n\tGetFireTransform(ProjectileTransform);\n\tFire(ProjectileTransform);\n}\n\nvoid ABaseDroneCharacter::GetFireTransform(FTransform& FireTransform)\n{\n\tFVector HitLocation;\n\tGetTraceHitLocation(HitLocation);\n\n\tFVector SpawnLocation = GetActorLocation() + GetActorRightVector() * 50;\n\tFVector FireDirection = HitLocation - SpawnLocation;\n\tFRotator FireRotation = FireDirection.Rotation();\n\n\tFireTransform.SetLocation(SpawnLocation);\n\tFireTransform.SetRotation(FireRotation.Quaternion());\n}\n\nvoid ABaseDroneCharacter::GetTraceHitLocation(FVector& OutHitLocation)\n{\n\tFVector ViewLocation;\n\tFRotator ViewRotation;\n\tController->GetPlayerViewPoint(ViewLocation, ViewRotation);\n\n\tFHitResult HitResult;\n\tFVector FireDirection = ViewRotation.Vector();\n\tFVector TraceStart = ViewLocation;\n\tFVector TraceEnd = TraceStart + FireDirection * 5000.f;\n\n\tGetWorld()->LineTraceSingleByChannel(HitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility);\n\tOutHitLocation = TraceEnd;\n\tif (HitResult.bBlockingHit)\n\t{\n\t\tOutHitLocation = HitResult.ImpactPoint;\n\t\tDrawDebugLine(GetWorld(), TraceStart, OutHitLocation, FColor::Blue, false, 5);\n\t\tDrawDebugSphere(GetWorld(), OutHitLocation, 10, 16, FColor::Blue, false, 5);\n\t}\n}\n\nvoid ABaseDroneCharacter::Fire(const FTransform& SpawnTransform)\n{\n\tif (!WeaponComponent) return;\n\tWeaponComponent->Fire(SpawnTransform);\n}\n\nvoid ABaseDroneCharacter::Death()\n{\n\tDestroy();\n}\n\nvoid ABaseDroneCharacter::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tif (OtherActor && OtherActor->GetClass()->ImplementsInterface(UInteractionInterface::StaticClass",
    "/** Includes **/\n#include <Arduino.h>\n\n#include \"EscapeRoomTriggerDevice.hpp\"\n\n\n\n/** Constructors **/\nEscapeRoomTriggerDevice::EscapeRoomTriggerDevice(String type, String (*setConfigFunc)(String), String (*getStateFunc)(void))\n{\n\t/*\n\tConstructor\n\tArguments:\n\t\t@type (String): A short string describing the type of trigger device. (e.g. for a button, this could be \"BUT\", or for a string of candles could be \"LEDs\"). All devices with the same type should behave the same way programmatically.\n\t\t@setConfigFunc (function pointer with args (String) and return type String): A function pointer that sets the config of the trigger device using a string as the input. The function pointer must be able to parse the string to determine what config to use. If the config setup is successful, the function pointer must return \"\". If there was an error while setting the config of the activation device, the return string must be prefixed by \"ER:\" followed by an error message, and the config must not change.\n\t\t@getStateFunc (function pointer with args (void) and return type String): A function pointer that returns the current state of the trigger device as a string. If there was an error while reading the state of the trigger device, the return string must be prefixed by \"ER:\" followed by an error message.\n\tReturns: (no return for a constructor)\n\t*/\n\tType = type;\n\tID = -1;\n\tSendStateOnNextTransfer();\t// Set this to true to send the initial state of the trigger device when a connection is established \n\t_setConfigFunc = setConfigFunc;\n\t_getStateFunc = getStateFunc;\n}\n\n\n\n/** Class Methods **/\nbool EscapeRoomTriggerDevice::SetID(int id)\n{\n\tif (ID >= 0 || id < 1)\n\t{\n\t\treturn false;\n\t}\n\t\n\tID = id;\n\treturn true;\n}\n\nint EscapeRoomTriggerDevice::GetID()\n{\n\treturn ID;\n}\n\nString EscapeRoomTriggerDevice::GetType()\n{\n\treturn Type;\n}\n\nString EscapeRoomTriggerDevice::GetErrorString()\n{\n\treturn ErrorString;\n}\n\nString EscapeRoomTriggerDevice::SetConfig(String config)\n{\n\tif (_setConfigFunc == nullptr)\n\t{\n\t\t// Generate the error string\n\t\tErrorString = \"null SetConfigFunc\";\n\n\t\t// Queue up a reply to the cloud server to indicate an error occurred while setting the state\n\t\tSendStateOnNextTransfer();\n\n\t\treturn \"ER: \" + ErrorString;\n\t}\n\n\tString er = _setConfigFunc(config);\n\tif (er.startsWith(\"ER:\"))\n\t{\n\t\t// Generate the error string\n\t\tErrorString = er.substring(4);\n\t\t\n\t\t// Queue up a reply to the cloud server to indicate an error occurred while setting the state\n\t\tSendStateOnNextTransfer();\n\t\t\n\t\treturn er;\n\t}\n\n\treturn \"\";\n}\n\nString EscapeRoomTriggerDevice::GetState()\n{\n\tif (_getStateFunc == nullptr)\n\t{\n\t\t// Generate the error string\n\t\tErrorString = \"null GetStateFunc\";\n\t\t\n\t\t// Set the state as unknown\n\t\tMostRecentState = \"?\";\n\n\t\t// Queue up a reply to the cloud server to indicate an error occurred while setting the state\n\t\tSendStateOnNextTransfer();\n\n\t\treturn \"ER: \" + ErrorString;\n\t}\n\n\tString newState = _getStateFunc();\n\tif (newState.startsWith(\"ER:\"))\n\t{\n\t\t// Generate the error string\n\t\tErrorString = newState.substring(4);\n\t\t\n\t\t// Set the state as unknown\n\t\tMostRecentState = \"?\";\n\t\t\n\t\t// Queue up a reply to the cloud server to indicate an error occurred while setting the state\n\t\tSendStateOnNextTransfer();\n\n\t\treturn newState;\n\t}\n\n\tErrorString = \"\";\n\tMostRecentState = newState;\n\treturn MostRecentState;\n}\n\nString EscapeRoomTriggerDevice::GetStateAndClearRequest()\n{\n\tString ret = GetState();\n\tSendStateIsRequested = false;\n\treturn ret;\n}\n\nvoid EscapeRoomTriggerDevice::SendStateOnNextTransfer()\n{\n\tSendStateIsRequested = true;\n}\n\nbool EscapeRoomTriggerDevice::GetSendStateIsRequested()\n{\n\treturn SendStateIsRequested;\n}\n",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago)with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"backimglogin\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expence_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include \"Graph2.h\"\n\nusing namespace std;\n\nstruct Crew\n{\n\tCrew()\n\t{\n\n\t}\n\tCrew(unsigned int id, std::string name, std::string rank)\n\t\t: mIdx(id), mName(name), mRank(rank)\n\t{\n\n\t}\n\tCrew(const Crew& rhs)\n\t{\n\t\tthis->mIdx = rhs.mIdx;\n\t\tthis->mName = rhs.mName;\n\t\tthis->mRank = rhs.mRank;\n\t}\n\tCrew& operator=(const Crew& rhs)\n\t{\n\t\tthis->mIdx = rhs.mIdx;\n\t\tthis->mName = rhs.mName;\n\t\tthis->mRank = rhs.mRank;\n\t\treturn *this;\n\t}\n\t~Crew()\n\t{\n\n\t}\n\tbool operator==(const Crew& rhs)\n\t{\n\t\tbool det = (this->mIdx == rhs.mIdx) && (this->mName == rhs.mName) && (this->mRank == rhs.mName);\n\t\treturn det;\n\t}\n\n\tbool operator!=(const Crew& rhs)\n\t{\n\t\treturn !operator==(rhs);\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const Crew& rhs);\n\n\tunsigned int mIdx;\n\tstd::string mName;\n\tstd::string mRank;\n};\n\nostream& operator<<(ostream& os, const Crew& rhs)\n{\n\tos << \"ID : \" << rhs.mIdx << std::endl;\n\tos << \"Name : \" << rhs.mName << std::endl;\n\tos << \"Rank : \" << rhs.mRank << std::endl;\n\treturn os;\n}\n\nvoid putBrokenLines(int len)\n{\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tcout << \"-\";\n\t}\n\tcout << endl;\n}\n\nint main(void)\n{\n\n\tCrew cr0(20327, \"Janeway\", \"Captain\");\n\tCrew cr1(24936, \"Chakotay\", \"Commander\");\n\tCrew cr2(16350, \"Tuvok\", \"Lt. Commander\");\n\tCrew cr3(30125, \"Torres\", \"Lieutenant\");\n\tCrew cr4(31867, \"Paris\", \"Lieutenant\");\n\tCrew cr5(36923, \"Kim\", \"Ensign\");\n\tCrew cr6(50001, \"EMH Doctor\", \"N/A\");\n\tCrew cr7(70002, \"Neelix\", \"N/A\");\n\tCrew cr8(80001, \"Seven\", \"N/A\");\n\tCrew cr9(33476, \"Wildman\", \"Ensign\");\n\n\tGraph<10, Crew> crGraph;\n\n\tcrGraph.SetVertex(0, cr0);\n\tcrGraph.SetVertex(1, cr1);\n\tcrGraph.SetVertex(2, cr2);\n\tcrGraph.SetVertex(3, cr3);\n\tcrGraph.SetVertex(4, cr4);\n\tcrGraph.SetVertex(5, cr5);\n\tcrGraph.SetVertex(6, cr6);\n\tcrGraph.SetVertex(7, cr7);\n\tcrGraph.SetVertex(8, cr8);\n\tcrGraph.SetVertex(9, cr9);\n\n\tcrGraph.AddEdge(0, 1); crGraph.AddEdge(0, 2); crGraph.AddEdge(0, 4);\n\tcrGraph.AddEdge(0, 5); crGraph.AddEdge(0, 7); crGraph.AddEdge(0, 8);\n\t\n\tcrGraph.AddEdge(1, 0); crGraph.AddEdge(1, 2); crGraph.AddEdge(1, 3);\n\tcrGraph.AddEdge(1, 4); \n\n\tcrGraph.AddEdge(2, 0); crGraph.AddEdge(2, 1); crGraph.AddEdge(2, 9);\n\n\tcrGraph.AddEdge(3, 1); crGraph.AddEdge(3, 4);\n\n\tcrGraph.AddEdge(4, 0); crGraph.AddEdge(4, 1); crGraph.AddEdge(4, 3);\n\tcrGraph.AddEdge(4, 5);\n\n\tcrGraph.AddEdge(5, 0); crGraph.AddEdge(5, 4); crGraph.AddEdge(5, 6);\n\n\tcrGraph.AddEdge(6, 5);\n\n\tcrGraph.AddEdge(7, 0); crGraph.AddEdge(7, 8); crGraph.AddEdge(7, 9);\n\n\tcrGraph.AddEdge(8, 0); crGraph.AddEdge(8, 7);\n\n\tcrGraph.AddEdge(9, 2); crGraph.AddEdge(9, 7);\n\n\n\tcrGraph.ShowGraphEdgeInfo();\n\n\tcout << \"----- BFS Search of the Graph -----\" << endl;\n\tcout << \"Searching the given graph starting from vertex 0\" << endl;\n\tcrGraph.BFSShowGraph(0);\n\tputBrokenLines(30);\n\tcout << \"Searching the given graph starting from vertex 1\" << endl;\n\tcrGraph.BFSShowGraph(1);\n\tputBrokenLines(30);\n\tcout << \"Searching the given graph starting from vertex 5\" << endl;\n\tcrGraph.BFSShowGraph(5);\n\n\n\treturn 0;\n}\n",
    "#include \"DxSystem.h\"\n\n#pragma comment( lib, \"d3d11.lib\" )\n#pragma comment( lib, \"d3dcompiler.lib\" )\n\nID3D11Device*\t\t\tDxSystem::Device;\nIDXGISwapChain*\t\t\tDxSystem::SwapChain;\nID3D11DeviceContext*\tDxSystem::DeviceContext;\nID3D11RenderTargetView* DxSystem::RenderTargetView;\n\nID3D11Texture2D*            DxSystem::DepthStencilTexture;\nID3D11DepthStencilView*     DxSystem::DepthStencilView;\nID3D11ShaderResourceView*   DxSystem::ShaderResourceView;\n\nint DxSystem::ScreenWidth = 1920;\nint DxSystem::ScreenHeight = 1080;\n\nMatrix DxSystem::ViewMatrix;\nMatrix DxSystem::ProjectionMatrix;\n\n//****************************************************************\n//\n//\t\u521d\u671f\u5316\n//\n//****************************************************************\nbool DxSystem::Initialize(HWND hWnd, int width, int height)\n{\n\tCreateDevice(hWnd);\n\tInitializeRenderTarget();\n\n\tScreenWidth = width;\n\tScreenHeight = height;\n\n\tD3D11_RASTERIZER_DESC rasterizerDesc;\n\trasterizerDesc.FillMode = D3D11_FILL_SOLID;\n\trasterizerDesc.CullMode = D3D11_CULL_BACK;\n\trasterizerDesc.FrontCounterClockwise = true;\n\trasterizerDesc.DepthBias = 0;\n\trasterizerDesc.SlopeScaledDepthBias = 0;\n\trasterizerDesc.DepthClipEnable = true;\n\trasterizerDesc.ScissorEnable = false;\n\trasterizerDesc.MultisampleEnable = false;\n\trasterizerDesc.AntialiasedLineEnable = false;\n\trasterizerDesc.DepthBiasClamp = 0;\n\trasterizerDesc.SlopeScaledDepthBias = 0;\n\n\tID3D11RasterizerState * pState;\n\tDevice->CreateRasterizerState(&rasterizerDesc, &pState);\n\tDeviceContext->RSSetState(pState);\n\tpState->Release();\n\treturn true;\n}\n\n//****************************************************************\n//\n//\t\u30c7\u30d0\u30a4\u30b9\u751f\u6210\n//\n//****************************************************************\nHRESULT DxSystem::CreateDevice( HWND hWnd )\n{\n\tHRESULT hr = S_OK;\n\n\tUINT createDeviceFlags = 0;\n\t//createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;\n\n\t// \u6a5f\u80fd\u30ec\u30d9\u30eb\n\tD3D_FEATURE_LEVEL featureLevels[] = {\n\t\tD3D_FEATURE_LEVEL_11_0,\n\t\tD3D_FEATURE_LEVEL_10_1,\n\t\tD3D_FEATURE_LEVEL_10_0,\n\t};\n\tUINT numFeatureLevels = sizeof(featureLevels) / sizeof(featureLevels[0]);\n\n\tD3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_10_0;\n\n\t// \u30b9\u30ef\u30c3\u30d7\u30c1\u30a7\u30a4\u30f3\u306e\u8a2d\u5b9a\n\tDXGI_SWAP_CHAIN_DESC sd;\n\tZeroMemory(&sd, sizeof(sd));\n\tsd.BufferCount = 1;\n\tsd.BufferDesc.Width = ScreenWidth;\n\tsd.BufferDesc.Height = ScreenHeight;\n\tsd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\n\tsd.BufferDesc.RefreshRate.Numerator = 60;\n\tsd.BufferDesc.RefreshRate.Denominator = 1;\n\tsd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n\tsd.OutputWindow = hWnd;\n\tsd.SampleDesc.Count = 1;\n\tsd.SampleDesc.Quality = 0;\n\tsd.Windowed = TRUE;\n\n\t// \u30c7\u30d0\u30a4\u30b9\u751f\u6210\n\thr = D3D11CreateDeviceAndSwapChain(\n\t\tNULL,\n\t\tD3D_DRIVER_TYPE_HARDWARE,\n\t\tNULL,\n\t\tcreateDeviceFlags,\n\t\tfeatureLevels,\n\t\tnumFeatureLevels,\n\t\tD3D11_SDK_VERSION,\n\t\t&sd,\n\t\t&SwapChain,\n\t\t&Device,\n\t\t&featureLevel,\n\t\t&DeviceContext);\n\t\n\tif (FAILED(hr))\n\t{\n\t\treturn hr;\n\t}\n\n\treturn S_OK;\n}\n\nvoid DxSystem::Release()\n{\n\tif (DeviceContext) { DeviceContext->ClearState(); }\n\tif (RenderTargetView) { RenderTargetView->Release(); RenderTargetView = NULL; }\n\tif (SwapChain) { SwapChain->Release(); SwapChain = NULL; }\n\tif (DeviceContext) { DeviceContext->Release(); DeviceContext = NULL; }\n\tif (Device) { Device->Release(); Device = NULL; }\n}\n\n//****************************************************************\n//\n//\t\u30ec\u30f3\u30c0\u30fc\u30bf\u30fc\u30b2\u30c3\u30c8\u95a2\u9023\n//\n//****************************************************************\n//------------------------------------------------\n//\t\u521d\u671f\u5316\n//------------------------------------------------\nbool DxSystem::InitializeRenderTarget()\n{\n\t// \u30d0\u30c3\u30af\u30d0\u30c3\u30d5\u30a1\u53d6\u5f97\n\tID3D11Texture2D* BackBuffer = NULL;\n\tHRESULT hr = SwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&BackBuffer);\n\tif (FAILED(hr))\n\t{\n\t\treturn false;\n\t}\n\n\t// \u30ec\u30f3\u30c0\u30fc\u30bf\u30fc\u30b2\u30c3\u30c8\u30d3\u30e5\u30fc\u751f\u6210\n\thr = Device->CreateRenderTargetView(BackBuffer, NULL, &RenderTargetView);\n\tBackBuffer->Release();\n\tBackBuffer = NULL;\n\tif (FAILED(hr))\n\t{\n\t\treturn false;\n\t}\n\n\tCreateDepthStencil();\n\n\t// \u30ec\u30f3\u30c0\u30fc\u30bf\u30fc\u30b2\u30c3\u30c8\u30d3\u30e5\u30fc\u8a2d\u5b9a\n\tDeviceContext->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);\n\n\t// \u30d3\u30e5\u30fc\u30dd\u30fc\u30c8\u8a2d\u5b9a\n\tD3D11_VIEWPORT vp;\n\tvp.Width = (float)ScreenWidth;\n\tvp.Height = (float)ScreenHeight;\n\tvp.MinDepth = 0.0f;\n\tvp.MaxDepth = 1.0f;\n\tvp.TopLeftX = 0;\n\tvp.TopLeftY = 0;\n\tDeviceContext->RSSetViewports(1, &vp);\n\n\treturn true;\n}\n\n//------------------------------------------------\n//      \u6df1\u5ea6\u30b9\u30c6\u30f3\u30b7\u30eb\u30d0\u30c3\u30d5\u30a1\u751f\u6210\n//------------------------------------------------\nbool DxSystem::CreateDepthStencil()\n{\n\t// \u6df1\u5ea6\u30b9\u30c6\u30f3\u30b7\u30eb\u8a2d\u5b9a\n\tD3D11_TEXTURE2D_DESC td;\n\tZeroMemory(&td, sizeof(D3D11_TEXTURE2D_DESC));\n\ttd.Width = ScreenWidth;\n\ttd.Height = ScreenHeight;\n\ttd.MipLevels = 1;\n\ttd.ArraySize = 1;\n\ttd.Format = DXGI_FORMAT_R24G8_TYPELESS;\n\ttd.SampleDesc.Count = 1;\n\ttd.SampleDesc.Quality = 0;\n\ttd.Usage = D3D11_USAGE_DEFAULT;\n\ttd.BindFlags = D3D11_BIND_DEPTH_STENCIL | D3D11_BIND_SHADER_RESOURCE;\n\ttd.CPUAccessFlags = 0;\n\ttd.MiscFlags = 0;\n\n\t// \u6df1\u5ea6\u30b9\u30c6\u30f3\u30b7\u30eb\u30c6\u30af\u30b9\u30c1\u30e3\u751f\u6210\n\tHRESULT hr = Device->CreateTexture2D(&td, NULL, &DepthStencilTexture);\n\tif (FAILED(hr))\n\t{\n\t\treturn false;\n\t}\n\n\t// \u6df1\u5ea6\u30b9\u30c6\u30f3\u30b7\u30eb\u30d3\u30e5\u30fc\u8a2d\u5b9a\n\tD3D11_DEPTH_STENCIL_VIEW_DESC dsvd;\n\tZe",
    "#include <stdio.h>\n#include \"Stack.h\"\n#define MAX_LEN 4\n\nvoid prnMenu(){\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<\"* 1. \uc0bd\uc785    2. \uc0ad\uc81c    3. \ucd9c\ub825   4. \uc885\ub8cc *\"<<endl;\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<endl;\n\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uba54\ub274\ub97c \uace8\ub77c\uc8fc\uc138\uc694: \";\n}\n\nint main(){\n\t    int mode, selectNumber, tmpItem;\n\t\tLinkedList<int> *p;\n\t\tbool flag = false;\n\n\t\tcout<<\"\uc790\ub8cc\uad6c\uc870 \uc120\ud0dd(1: Stack, Other: Linked List): \";\n\t\tcin>>mode;\n\t\t\t\t\t\t    \n\t\tif(mode == 1)\n\t\t\tp = new Stack<int>();    // \uc815\uc218\ub97c \uc800\uc7a5\ud558\ub294 \uc2a4\ud0dd\n\t\t\t\n\t\telse\n\t\t\tp = new LinkedList<int>();\n\n\n\t\tdo{\n\t\t\tprnMenu();\n\t\t\tcin>>selectNumber;\n\t\t\t\n\t\t\tswitch(selectNumber){ \n\t\t\t\tcase 1:\n\t\t\t\t\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694: \";\n\t\t\t\t\tcin>>tmpItem;   \n                    if (p->GetSize() >= MAX_LEN) {\n                       cerr << \"List Max Size Reached!\" << endl;\n                       break;\n                    }\n                    p->Insert(tmpItem);\n\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0bd\uc785\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tif(p->Delete(tmpItem)==true)\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0ad\uc81c\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t\t\n\t\t\t\t\telse cout<<\"\ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc0ad\uc81c \uc2e4\ud328\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"\ud06c\uae30: \"<<p->GetSize()<<endl;\n\t\t\t\t\tp->Print();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tflag = true;     break;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tcout<<\"\uc798\ubabb \uc785\ub825\ud558\uc168\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) break;\n\t\t\t\n\t\t} while(1);\n\t\t\n\t\treturn 0;\n}\n\n",
    "#include <iostream>\n#include <cctype>\n#include \"Image_Class.h\"\n#include <stdexcept>\n#include <vector>\nusing namespace std;\n/*\n    program Description: this program applies simple filters to images and can specify it's extention\n\n    Author 1: Salah Hammad   => S26\n    ID1 : 20230194\n    // developed (gray scale - merge - detect image edge - lighten and darken)filters\n    ========================================================== \n    Author 2: Mohamed Ashraf Said Ibrahim   => S26\n    ID2: 20230320\n    // developed (Black and white - flip - resize - crop - Purple hue) filters\n    ==========================================================\n    Author 3: Mohamed Abd El nasser Mohamed Marghny    => S26\n    ID3: 20231146\n  ///  { Mohamed did not fulfill what was expected of him. He did not execute any code but instead used ChatGPT,  ///\n    which affected the team and did not help us at all. He did not carry out the required tasks,and if u have a look\n    at the filter (rotate) that he made u will see that he didn't follow the assginment instructions }\n    // developed (rotate) filter\n\n    last modification date: 4/14/2024\n    version: 3.0\n\n    //// Link to the Repo: https://github.com/0MohamedAshraf/Baby-Photoshop\n*/\n\n\n\n\n// Function to rotate the image clockwise by 90 degrees\nvoid rotate90(vector<vector<int>>& image) {\n    int n = image.size();\n    vector<vector<int>> rotated(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rotated[i][j] = image[n - j - 1][i];\n        }\n    }\n    image = rotated;\n}\n\n// Function to rotate the image clockwise by 180 degrees\nvoid rotate180(vector<vector<int>>& image) {\n    rotate90(image);\n    rotate90(image);\n}\n\n// Function to rotate the image clockwise by 270 degrees\nvoid rotate270(vector<vector<int>>& image) {\n    rotate180(image);\n    rotate90(image);\n}\n\n// rotate filter function\nvoid rotate(){\n    int n;\n    cout << \"Enter the size of the image (n x n): \";\n    cin >> n;\n\n    vector<vector<int>> image(n, vector<int>(n));\n    cout << \"Enter the elements of the image:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> image[i][j];\n        }\n    }\n\n    int choice;\n    cout << \"Enter the rotation angle (90, 180, or 270): \";\n    cin >> choice;\n\n    switch (choice) {\n        case 90:\n            rotate90(image);\n            break;\n        case 180:\n            rotate180(image);\n            break;\n        case 270:\n            rotate270(image);\n            break;\n        default:\n            cout << \"Invalid choice!\" << endl;\n            \n    }\n\n    cout << \"Rotated Image:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << image[i][j] << \" \";\n        }\n        cout << endl;\n    }    \n}\n// merge filter function \nvoid merge(string filename, string filename2, string new_img){\n\n    Image image1(filename);\n    Image image2(filename2);   \n\n    // Calculate the common dimensions between the two images\n    int commonWidth = min(image1.width, image2.width);\n    int commonHeight = min(image1.height, image2.height);\n\n    // Blend the images\n    // Image blendedImage(image1.width, image1.height);\n    for (int i = 0; i < commonWidth; ++i) {\n        for (int j = 0; j < commonHeight; ++j) {\n            for (int k = 0; k < image1.channels; ++k) {\n                // Calculate the average of the shared values between the two images\n                image1(i, j, k) = ((image1(i, j, k) + image2(i, j, k)) / 2);\n            }\n        }\n    }\n\n    // Save the blended image\n    image1.saveImage(new_img);    \n}\n\n// gray scale filter function\nvoid gray_scale(string filename, string new_img){\n    Image image(filename); // Creating an image object using the input file\n\n    for(int i = 0; i < image.width; ++i) {\n        for(int j = 0; j < image.height; ++j) {\n            unsigned int avg = 0;\n\n            for(int k = 0; k < image.channels; ++k) {\n                avg += image(i,j,k);\n            }\n            avg /= image.channels; // Modification here to be more general instead of always dividing by 3\n            for(int k = 0; k < image.channels; ++k) {\n                image(i,j,k) = avg;\n            }\n        }\n    }\n\n    // Save the image after modifications\n    image.saveImage(new_img);\n\n}\n\n// Black and White filter function \nvoid Black_White(string filename, string new_img){\n    Image Photo(filename);\n    for(int i = 0; i < Photo.width ;++i){\n\n        for(int j = 0; j < Photo.height;++j){\n            for(int k = 0; k < 3;++k){\n            }\n            if((Photo(i,j,0)+Photo(i,j,1)+Photo(i,j,2))/3 > 128){  // convert the image to gray scale and \n                                                                   // check if the pixel is bright or dark\n                                                                   // if the pixel is bright make it white \n                Photo(i,j,0) = 255;\n                Photo(i,j,1) = 255;\n                Photo(i,j,2) ",
    "#include \"piece.hpp\"\n#include \"colors.hpp\"\n#include \"tetris_config.hpp\"\n#include \"global_vars.hpp\"\n#include <vector>\n\nPiece::Piece(PieceKind type, Vec2 pos, const uint8_t& rot)\n    : // initializator list, calls the construtor for objects in the class\n    position { pos }\n    , rotation { rot }\n    , type { type } {\n    confirm();\n}\n\nPiece::~Piece() {}\n\nvoid Piece::lower() {\n    position.y++;\n    lowerLast = true;\n}\nvoid Piece::rotateClockwise() {\n    if (rotation + 1 != 4) {\n        rotation++;\n    } else {\n        rotation = 0;\n    }\n}\nvoid Piece::rotateCounterClockwise() {\n    if (rotation != 0) {\n        rotation--;\n    } else {\n        rotation = 3;\n    }\n}\n\nvoid Piece::confirm() {\n    lastPosition = position;\n    lastRotation = rotation;\n}\n\nvoid Piece::undo() {\n    position = lastPosition;\n    rotation = lastRotation;\n}\n\nvoid Piece::draw() {\n    std::vector<PiecePixel> pixels;\n    renderShape(pixels);\n\n    for (auto& p : pixels) {\n        if (p.value != 0) {\n            int p_x = p.pos.x + view_offset;\n            if (_cfg_overflow_enable == true || _cfg_scroll_enable == true) {\n                while (p_x < 0) {\n                    p_x += _cfg_width;\n                }\n                while (p_x >= _cfg_width) {\n                    p_x -= _cfg_width;\n                }\n            } else {\n                if (p_x < 0) {\n                    p_x = 0;\n                }\n                if (p_x >= _cfg_width) {\n                    p_x = _cfg_width - 1;\n                }\n            }\n            display.setColor(p_x, p.pos.y, colors[p.value]);\n        }\n    }\n}\n\nvoid Piece::renderShape(std::vector<PiecePixel>& pixels) const {\n    // load pixels\n\n    for (int32_t x = 0; x < Pieces[type][0].size(); x++) {\n        for (int32_t y = 0; y < Pieces[type].size(); y++) {\n\n            if (Pieces[type][y][x] == 1) {\n                pixels.push_back({ 1, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 2) {\n                pixels.push_back({ 2, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 3) {\n                pixels.push_back({ 3, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 4) {\n                pixels.push_back({ 4, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 5) {\n                pixels.push_back({ 5, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 6) {\n                pixels.push_back({ 6, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 7) {\n                pixels.push_back({ 7, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            }\n        }\n    }\n\n    // rotate pixels\n\n    if (type != Square) {\n        for (int i = 0; i < rotation; i++) { // rotate 90\u02da (https://stackoverflow.com/questions/4780119/2d-euclidean-vector-rotations)\n            for (auto& p : pixels) {\n                p.pos = Vec2 { -p.pos.y, p.pos.x };\n            }\n        }\n    }\n\n    // move pixels\n\n    for (auto& p : pixels) {\n\n        int32_t p_x = p.pos.x + PiecesCenters[type].x + position.x;\n\n        if (_cfg_overflow_enable == true) {\n\n            while (p_x < 0) {\n                p_x += _cfg_width;\n            }\n            while (p_x >= _cfg_width) {\n                p_x -= _cfg_width;\n            }\n        }\n        p.pos = Vec2 { p_x, p.pos.y + PiecesCenters[type].y + position.y };\n    }\n}",
    "#include \"Office.h\"\n\nOffice::Office(char name, int numWindows) {\n    deleteThisToo = 0;\n\n    queue = new Queue<Customer*>();\n    windows = new Window*[numWindows];\n    // create new windows for length of windows\n    for (int i = 0; i < numWindows; ++i) {\n        Window *w = new Window();\n        windows[i] = w;\n    }\n    officeName = name;\n    this->numWindows = numWindows;\n\n    // set all aux variables to 0\n    totalWaitTime = 0;\n    totalVisitors = 0;\n    longestWaitTime = 0;\n    visitsOver10 = 0;\n    timeCounter = 0;\n}\n\nOffice::Office(){}\n\nOffice::~Office() {\n    delete queue;\n    for(int i = 0; i < numWindows; ++i){\n        delete windows[i];\n    }\n    delete[] windows;\n}\n\nvoid Office::timeIncrement() {\n    ++timeCounter;\n\n    // check if any windows are open\n    int openWindow = firstEmptyWindow();\n\n    while ((openWindow != -1) && (!(queue->isEmpty()))) {\n        // send the student to an open window\n        sendStudentToWindow(openWindow);\n        // set to next variable\n        openWindow = firstEmptyWindow();\n    }\n    for(int i = 0; i < numWindows; ++i){\n        // increments window time\n        windows[i]->timeIncrement();\n    }\n    addToWaitTime();\n\n}\n\nvoid Office::addStudentToQueue(Customer* s) {\n\n    if(s->notDone()){\n        // updates student office\n        s->setCurrentOffice(officeName);\n        s->enterQueue(timeCounter); \n        queue->insert(s);\n        totalVisitors++;\n    }\n}\n\nint Office::getNumWindows() {\n    return numWindows;\n}\n\nint Office::getTotalWaitTime() {\n    return totalWaitTime;\n}\n\nint Office::getTotalVisitors() {\n    return totalVisitors;\n}\n\ndouble Office::getMeanWaitTime() {\n    // gets mean wait time by dividing total by visitors\n    if(totalVisitors == 0){\n        return 0;\n    }\n    return ((double) totalWaitTime / (double) totalVisitors);\n}\n\nint Office::getLongestWaitTime() {\n    return longestWaitTime;\n}\n\nint Office::getVisitsOver10() {\n    return visitsOver10;\n}\n\ndouble Office::getMeanIdleTime() { // gets the mean idle time from all windows' total idle times\n    int totalIdleTime = 0;\n    for (int i = 0; i < numWindows; ++i) {\n        // add idle time of window to total\n        totalIdleTime += windows[i]->getTotalIdleTime();\n    }\n    return ((double) totalIdleTime / (double) numWindows);\n}\n\nint Office::getLongestIdleTime() { // gets the longest idle time amongst all windows\n    int maxIdleTime = 0;\n    for (int i = 0; i < numWindows; ++i) {\n        // if the max idle time is greater, replace the old one\n        int currIdleTime = windows[i]->getTotalIdleTime();\n        if (currIdleTime > maxIdleTime) maxIdleTime = currIdleTime;\n    }\n    return maxIdleTime;\n}\n\nint Office::getTotalIdleOver5() { // returns the total number of windows with idles over 5\n    int counter = 0;\n    for (int i = 0; i < numWindows; ++i) {\n        // add idle time of window to total\n        counter += windows[i]->getNumIdlesOver5();\n    }\n    return counter;\n}\n\n\nint Office::firstEmptyWindow() {\n    \n    /* iterate through all windows return\n        - Return index of the first empty window\n        - Else return -1\n    */\n\n    for (int i = 0; i < numWindows; ++i) {\n        if (windows[i]->isEmpty()){\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nvoid Office::sendStudentToWindow(int windowNum) {\n    // removes a student from the queue and sends them to the first available window\n    if(queue->peek()->exitQueue(timeCounter) > longestWaitTime){\n        longestWaitTime = queue->peek()->exitQueue(timeCounter) - 1;\n    }\n    windows[windowNum]->approachWindow(queue->remove());\n}\n\nvoid Office::addToWaitTime() {\n    // get number of students in the array\n    // ex: if there are 3 students in line and 1 time has passed, then a total of 3 wait time has happened\n    totalWaitTime += queue->getSize();\n}\n\nvoid Office::prepStudentForQueue(Customer *c){ //adds student to the array and increases index\n    queuePrep[queuePrepIndex] = c;\n    ++queuePrepIndex;\n}\n\nvoid Office::makeQueuePrepArray(int sn){ //makes an array based on number of students\n    queuePrep = new Customer*[sn];\n    queuePrepIndex = 0;\n}\n \nvoid Office::addQueueFromOtherOffice(){ //This method is for when a student finishes and needs to be added to another queue when\n    for(int i = 0; i < queuePrepIndex; ++i){\n        if(queuePrep[i] == NULL){\n            break;\n        }\n        if(queuePrep[i]->getPrevOffice() == 'C'){\n            addStudentToQueue(queuePrep[i]);\n        }\n    }\n    for(int i = 0; i < queuePrepIndex; ++i){\n        if(queuePrep[i] == NULL){\n            break;\n        }\n        if(queuePrep[i]->getPrevOffice() == 'F'){\n            addStudentToQueue(queuePrep[i]);\n        }\n    }\n    for(int i = 0; i < queuePrepIndex; ++i){\n        if(queuePrep[i] == NULL){\n            break;\n        }\n        if(queuePrep[i]->getPrevOffice() == 'R'){\n            addStudentToQueue(queuePrep[i]);\n        }\n    }\n\n    for(int i = 0; i < queuePrepIndex; ++i){\n        if(queuePrep[i] == NULL){\n            break;\n        }\n        queue",
    "#include \"Snow.h\"\r\n\r\n \r\n\tvoid Snow::Initialize(ComPtr<ID3D11Device>& device, ComPtr<ID3D11DeviceContext>& context)\r\n\t{\r\n    auto meshdata = GeometryGenerator::MakeSphere(0.01f, 40, 40);\r\n\r\n\tvector<SnowVertex> snowVertices(meshdata.vertices.size());\r\n\r\n\tfor (int i = 0; i < snowVertices.size(); i++)\r\n\t{ \r\n        snowVertices[i].posModel = meshdata.vertices[i].position;\r\n\t}\r\n\t \r\n\tD3D11Utils::CreateVertexBuffer(device, snowVertices, m_vertexBuffer);\r\n\r\n\tassert(m_instanceData.size() > 0);\r\n\r\n\tm_instanceCount = UINT(m_instanceData.size());\r\n    D3D11Utils::CreateInstanceBuffer(device, m_instanceData, m_instanceBuffer);\r\n\r\n\tm_indexCount = UINT(meshdata.indices.size());\r\n    m_vertexCount = UINT(snowVertices.size());\r\n    D3D11Utils::CreateIndexBuffer(device, meshdata.indices, m_indexBuffer);\r\n\r\n\r\n    }  \r\n\r\n\tvoid Snow::Update(ComPtr<ID3D11Device>& device, ComPtr<ID3D11DeviceContext>& context)\r\n\t{\r\n\t}\r\n\r\n\tvoid Snow::Render(ComPtr<ID3D11DeviceContext>& context)\r\n\t{\r\n    ID3D11Buffer *const vertexBuffers[2] = {m_vertexBuffer.Get(),\r\n                                            m_instanceBuffer.Get()};\r\n    const UINT strides[2] = {sizeof(GrassVertex), sizeof(GrassInstance)};\r\n    const UINT offsets[2] = {0, 0};\r\n    context->IASetVertexBuffers(0, 2, vertexBuffers, strides, offsets);\r\n    context->IASetIndexBuffer(m_indexBuffer.Get(), DXGI_FORMAT_R32_UINT, 0);\r\n    context->DrawIndexedInstanced(m_indexCount, m_instanceCount, 0, 0, 0);\r\n\t}\r\n\r\n\r\n",
    "/*\n * @file        : httpresponse.cpp\n * @Author      : zhenxi\n * @Date        : 2024-03-12\n * @copyleft    : Apache 2.0\n */\n\n#include \"httpresponse.h\"\n\nconst std::unordered_map<std::string, std::string> HttpResponse::SUFFIX_TYPE = {\n    { \".html\",  \"text/html\" },\n    { \".xml\",   \"text/xml\" },\n    { \".xhtml\", \"application/xhtml+xml\" },\n    { \".txt\",   \"text/plain\" },\n    { \".rtf\",   \"application/rtf\" },\n    { \".pdf\",   \"application/pdf\" },\n    { \".word\",  \"application/nsword\" },\n    { \".png\",   \"image/png\" },\n    { \".gif\",   \"image/gif\" },\n    { \".jpg\",   \"image/jpeg\" },\n    { \".jpeg\",  \"image/jpeg\" },\n    { \".au\",    \"audio/basic\" },\n    { \".mpeg\",  \"video/mpeg\" },\n    { \".mpg\",   \"video/mpeg\" },\n    { \".avi\",   \"video/x-msvideo\" },\n    { \".gz\",    \"application/x-gzip\" },\n    { \".tar\",   \"application/x-tar\" },\n    { \".css\",   \"text/css \"},\n    { \".js\",    \"text/javascript \"},\n};\n\nconst std::unordered_map<int, std::string> HttpResponse::CODE_STATUS = {\n    { 200, \"OK\" },\n    { 400, \"Bad Request\" },\n    { 403, \"Forbidden\" },\n    { 404, \"Not Found\" },\n};\n\nvoid HttpResponse::clear() {\n    code_ = -1;\n    header_.clear();\n    if(contentFd_ > 0)\n        close(contentFd_);\n    contentComplete_ = false;\n    contentFd_ = -1;\n    contentLen_ = contentOffset_ = 0;\n}\n\nvoid HttpResponse::addHeader(const std::string &key, const std::string &value){\n    header_[key] = value;\n}\n\n// bool HttpResponse::addBody(std::string &str){\n//     if(contentComplete_)\n//         return false;\n//     addHeader(\"Content-Type\", \"text/plain\");\n//     addHeader(\"Content-Length\", std::to_string(str.size()));\n//     body_ = str;\n//     contentComplete_ = true;\n//     return true;\n// }\n\nbool HttpResponse::addBody(std::string &filepath){\n    if(contentComplete_){\n        LOG_DEBUG(\"Multiple Content\");\n        return false;\n    }\n    contentFd_ = open(filepath.data(), O_RDONLY);\n    // std::cout<<contentFd_<<std::endl;\n    if (contentFd_ == -1) {\n        LOG_DEBUG(\"Invalid Filepath\");\n        return false;\n    }\n    struct stat file_stat;\n    if (fstat(contentFd_, &file_stat) == -1) {\n        LOG_DEBUG(\"Error Filelength\");\n        return false;\n    }\n    contentLen_ = file_stat.st_size;\n    // std::cout<<contentLen_<<std::endl;\n    contentComplete_ = true;\n\n    std::string typeName = \"text/plain\";\n    std::string::size_type idx = filepath.find_last_of('.');\n    if(idx != std::string::npos) {\n        std::string suffix = filepath.substr(idx);\n        if(SUFFIX_TYPE.count(suffix) == 1) {\n            typeName = SUFFIX_TYPE.find(suffix)->second;\n        }\n    }\n    addHeader(\"Content-Type\", typeName);\n    addHeader(\"Content-Length\", std::to_string(contentLen_));\n    return true;\n}\n\nvoid HttpResponse::makeMessage(Buffer &buff, int code)\n{\n    // make status line\n    code_ = code;\n    std::string status;\n    if(CODE_STATUS.count(code_) == 1)\n        status = CODE_STATUS.find(code_)->second;\n    else {\n        code_ = 400;\n        status = CODE_STATUS.find(400)->second;\n    }\n    buff.addData(\"HTTP/1.1 \" + std::to_string(code_) + \" \" + status + \"\\r\\n\");\n\n    // make response headers\n    for(auto field: header_)\n        buff.addData(field.first + \": \" + field.second + \"\\r\\n\");\n\n    buff.addData(\"\\r\\n\");\n    // LOG_DEBUG(\"Response Header length:%d\\n%s\", buff.size(), buff.data());\n}\n\nint HttpResponse::contentFd() const{\n    return contentFd_;\n}\n\noff64_t HttpResponse::contentLen() const{\n    return contentLen_;\n}\n\noff64_t HttpResponse::contentOffset() const{\n    return contentOffset_;\n}\n\n\nvoid HttpResponse::contentSend(off64_t len){\n    contentOffset_ += len;\n}",
    "/**\n *  @filename   :   epd3in7.cpp\n *  @brief      :   Implements for e-paper library\n *  @author     :   Waveshare\n *\n *  Copyright (C) Waveshare     July 17 2020\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documnetation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to  whom the Software is\n * furished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS OR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include <stdlib.h>\n#include \"epd3in7.h\"\n#include \"imagedata.h\"\n\nstatic const UBYTE lut_4Gray_GC[] =\n{\n    0x2A,0x06,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1\n    0x28,0x06,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//2\n    0x20,0x06,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//3\n    0x14,0x06,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//4\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//5\n    0x00,0x02,0x02,0x0A,0x00,0x00,0x00,0x08,0x08,0x02,//6\n    0x00,0x02,0x02,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,//7\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//8\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//10\n    0x22,0x22,0x22,0x22,0x22\n};  \n\nstatic const UBYTE lut_1Gray_GC[] =\n{\n    0x2A,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1\n    0x05,0x2A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//2\n    0x2A,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//3\n    0x05,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//4\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//5\n    0x00,0x02,0x03,0x0A,0x00,0x02,0x06,0x0A,0x05,0x00,//6\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//7\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//8\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//10\n    0x22,0x22,0x22,0x22,0x22\n};  \n\nstatic const UBYTE lut_1Gray_DU[] =\n{\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//1\n    0x01,0x2A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x0A,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//3\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//5\n    0x00,0x00,0x05,0x05,0x00,0x05,0x03,0x05,0x05,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//7\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x22,0x22,0x22,0x22,0x22\n}; \n\nstatic const UBYTE lut_1Gray_A2[] =\n{\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //1\n0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //2\n0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //3\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //4\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //5\n0x00,0x00,0x03,0x05,0x00,0x00,0x00,0x00,0x00,0x00, //6\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //7\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //8\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //9\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //10\n0x22,0x22,0x22,0x22,0x22\n}; \n\nEpd::~Epd() {\n};\n\nEpd::Epd() {\n    reset_pin = RST_PIN;\n    dc_pin = DC_PIN;\n    cs_pin = CS_PIN;\n    busy_pin = BUSY_PIN;\n    width = EPD_WIDTH;\n    height = EPD_HEIGHT;\n};\n\nint Epd::Init(void) {\n    if (IfInit() != 0) {\n        return -1;\n    }\n    Reset();\n\n    SendCommand(0x12);\n    DelayMs(300);\n\n    SendCommand(0x46); \n    SendData(0xF7);\n    WaitUntilIdle();\n    SendCommand(0x47);\n    SendData(0xF7);\n    WaitUntilIdle(); \n\n    SendCommand(0x01); // setting gaet number\n    SendData(0xDF);\n    SendData(0x01);\n    SendData(0x00);\n\n    SendCommand(0x03); // set gate voltage\n    SendData(0x00);\n\n    SendCommand(0x04); // set source voltage\n    SendData(0x41);\n    SendData(0xA8);\n    SendData(0x32);\n\n    SendCommand(0x11); // set data entry sequence\n    SendData(0x03);\n\n    SendCommand(0x3C); // set border \n    SendData(0x00);\n\n    SendCommand(0x0C); // set booster strength\n    SendData(0xAE);\n    SendData(0xC7);\n    SendData(0xC3);\n    SendData(0xC0);\n    SendData(0xC0);  \n\n    SendCommand(0x18); // set internal sensor on\n    SendData(0x80);\n\n    SendCommand(0x2C); // set vcom value\n    SendData(0x44);\n\n    S",
    "#include \"Stitcher.h\"\n\n#include <opencv2/core/core.hpp>\n#include <opencv2/highgui.hpp>\n#include <fstream>\n\n\n#define MATCH_SIZE 40\n#define OFFSET 5\n#define OFFSET_Y 5\n#define DEBUG_TESTING\n\nusing std::cout;\nusing std::endl;\nusing std::vector;\n\n#define M_PI 3.1415926535897932384626433832795\n\nstatic double rad2Deg(double rad){return rad*(180/M_PI);}//Convert radians to degrees\nstatic double deg2Rad(double deg){return deg*(M_PI/180);}//Convert degrees to radians\n\n\nCStitcher::CStitcher(void)\n{\n//\tpClahe = cv::createCLAHE(3, cv::Size(16,16));\n\tpClahe = cv::createCLAHE(40, cv::Size(8,8));\n\n\tm_pDetector =  cv::BRISK::create(10,3);\n\tm_pDescriptor = cv::BRISK::create(10,3);\n\tm_pMatcher = cv::BFMatcher::create(cv::NORM_HAMMING, true);\n\tm_Name =\"Default\";\n}\n\n\nCStitcher::CStitcher(std::string name,\n\t\t\t\t\t cv::Ptr<cv::FeatureDetector> pDetector,\n\t\t\t\t\t cv::Ptr<cv::DescriptorExtractor> pExtractor,\n\t\t\t\t\t cv::Ptr<cv::DescriptorMatcher> pMatcher)\t:\n\t\t\tm_pDetector(pDetector),\n\t\t\tm_pDescriptor(pExtractor),\n\t\t\tm_pMatcher(pMatcher),\n\t\t\tm_Name(name)\n{\n\tpClahe = cv::createCLAHE(50, cv::Size(16,16));\n//\tpClahe = cv::createCLAHE(3, cv::Size(16,16));\n\tassert(m_pDetector);\n\tassert(m_pDescriptor);\n\tassert(m_pMatcher);\n}\n\nCStitcher::~CStitcher(void)\n{\n}\n\nint CStitcher::InitImageSequence(std::string videoNames, int maxFrames)\n{\n\tcv::Mat imageToLoad;\n\tstd::string currentName;\n\tcv::VideoCapture cap(videoNames);\n\tif (!cap.isOpened())\n\t\treturn -1;\n\n\tint cnt = 0;\n\n\twhile (cap.grab() && (static_cast<unsigned int>(maxFrames)>cnt))\n\t{\n\t\ttry\n\t\t{\n\t\t\tcap >> imageToLoad;\n\t\t\tif (imageToLoad.empty())\n\t\t\t\tcontinue;\n\n\t\t\tif (!imageToLoad.empty())\n\t\t\t{\n\t\t\t\tcv::Rect cropRect(OFFSET_Y, OFFSET, imageToLoad.cols-2*OFFSET_Y, imageToLoad.rows-2*OFFSET);\n\t\t\t\t// cv::imshow(\"image\", imageToLoad);\n\t\t\t\tm_ImageSequence.push_back(cv::Mat(imageToLoad, cropRect).clone());\n\t\t\t\t// cv::waitKey(40);\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tcatch (cv::Exception &e)\n\t\t{\n\t\t\tswitch (e.code)\n\t\t\t{\n\t\t\t\t// case \n\t\t\t\t\t//\tDo nothing - it's not an image;\n\t\t\t\t\t// break;\n\t\t\t\tdefault:\n\t\t\t\t\tstd::cerr << e.what() << std::endl;\n\t\t\t\t\tstd::cerr << \"Error code \" << e.code << endl; \n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << m_ImageSequence.size() << \" images loaded\" << std::endl;\n\n\treturn 0;\n}\n\nint CStitcher::MakeEnhancement(void)\n{\n\tcv::Mat summImage = cv::Mat::zeros(m_ImageSequence.begin()->size(),m_ImageSequence.begin()->type());\n\tcv::Mat weights = cv::Mat::zeros(m_ImageSequence.begin()->size(),CV_64F);\n\tfor (auto const & image : m_ImageSequence)\n\t{\n\t\tcv::Mat testImage = image;\n//\t\ttestImage.mul(weights);\n//\t\tcv::imshow(\"Before filtering\", testImage);\n//\t\tpClahe->apply(testImage, testImage);\n//\t\tcv::GaussianBlur(testImage, testImage, cv::Size(3,3),3);\n//\t\tcv::imshow(\"After filtering\", testImage);\n//\t\tcv::waitKey();\n//\t\tcv::destroyAllWindows();\n//\t\tm_FiltredSequence.insert(std::pair<std::string,cv::Mat>(it->first, testImage));\n\t\tm_FiltredSequence.push_back(cv::Mat(testImage));\n\t\tcv::imshow(\"filter\", testImage);\n\t\tcv::waitKey(40);\n\n\t}\n\tstd::cout << m_FiltredSequence.size() << \" images filtered\" << std::endl;\n\treturn 0;\n}\n\n\nCImageData  CStitcher::MatchImages(cv::Mat& image1, cv::Mat& image2)\n{\n\tvector<cv::DMatch> goodMatches;\n\tstd::vector<cv::KeyPoint> m_Keypoints1,\n\t\t\t\t\t\t\t  m_Keypoints2;\n\n\twhile (goodMatches.size() >500 || goodMatches.size()<20)\n\t{\n\t\tstd::vector<std::vector<cv::DMatch>> knnMatches;\n\t\tcv::Mat m_Descriptors1,\n\t\t\t\tm_Descriptors2;\n\n\t\tgoodMatches.clear();\n\t\tm_Keypoints1.clear();\n\t\tm_Keypoints2.clear();\n\n\t\tm_pDetector->detect(image1, m_Keypoints1);\n\t\tm_pDetector->detect(image2, m_Keypoints2);\n\t\tm_pDescriptor->compute(image1, m_Keypoints1, m_Descriptors1);\n\t\tm_pDescriptor->compute(image2, m_Keypoints2, m_Descriptors2);\n\t\tm_pMatcher->knnMatch(m_Descriptors1, m_Descriptors2, knnMatches,2);\n\t\tfor (auto match : knnMatches)\n\t\t{\n\t\t\tif (match[0].distance < 0.7 * match[1].distance)\n\t\t\t\tgoodMatches.push_back(match[0]);\n\t\t}\n\n\t\tcv::Ptr<cv::BRISK> ptr = m_pDetector.dynamicCast<cv::BRISK>();\n\t\tauto threshold = ptr->getThreshold();\n\t\tif (goodMatches.size()>1000)\n\t\t\tptr->setThreshold(std::min<float>(1000, threshold+10));\n\t\telse if (goodMatches.size()>500)\n\t\t\tptr->setThreshold(std::min<float>(1000, threshold+1));\n\t\telse if (goodMatches.size()<20)\n\t\t\tptr->setThreshold(std::max<float>(15, threshold-10));\n\t\telse if (goodMatches.size()<100)\n\t\t\tptr->setThreshold(std::max<float>(20, threshold-1));\n\t\t\n\t\tcout << goodMatches.size() << \" threshold set to \" << threshold << endl;\n\t}\n\tCImageData retData;\n\tretData.SetKeypoints(m_Keypoints1,m_Keypoints2);\n\tretData.SetMatches(goodMatches);\n\n#ifdef DEBUG_TESTING\n\t// cv::Mat outImage;\n\t// cv::drawMatches(image1,m_Keypoints1,image2,m_Keypoints2, goodMatches, outImage);\n//\tcv::drawMatches(image1,m_Keypoints1,image2,m_Keypoints2, symmMatches,outImage, cv::Scalar::all(-1), cv::Scalar::all(-1),\n//\t\tstd::vector<std::vector<char>>(), cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS | cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);\n\t// cv::imshow(m_Name,outImage);\n\t// cv::waitKey(40);\n#endif\n\n\treturn retData;\n}\n\n\nint ",
    "\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define V 5\n\n\nint minKey(int key[], bool mstSet[])\n{\n\t// Initialize min value\n\tint min = INT_MAX, min_index;\n\n\tfor (int v = 0; v < V; v++)\n\t\tif (mstSet[v] == false && key[v] < min)\n\t\t\tmin = key[v], min_index = v;\n\n\treturn min_index;\n}\n\n\nvoid printMST(int parent[], int graph[V][V])\n{\n\tcout << \"Edge \\tWeight\\n\";\n\tfor (int i = 1; i < V; i++)\n\t\tcout << parent[i] << \" - \" << i << \" \\t\"\n\t\t\t<< graph[i][parent[i]] << \" \\n\";\n}\n\n\nvoid primMST(int graph[V][V])\n{\n\t// Array to store constructed MST\n\tint parent[V];\n\n\t// Key values used to pick minimum weight edge in cut\n\tint key[V];\n\n\t// To represent set of vertices included in MST\n\tbool mstSet[V];\n\n\t// Initialize all keys as INFINITE\n\tfor (int i = 0; i < V; i++)\n\t\tkey[i] = INT_MAX, mstSet[i] = false;\n\n\tkey[0] = 0;\n\n\t// First node is always root of MST\n\tparent[0] = -1;\n\n\t// The MST will have V vertices\n\tfor (int count = 0; count < V - 1; count++) {\n\t\t\n\t\t// Pick the minimum key vertex from the\n\t\t// set of vertices not yet included in MST\n\t\tint u = minKey(key, mstSet);\n\n\t\t// Add the picked vertex to the MST Set\n\t\tmstSet[u] = true;\n\n\t\t// Update key value and parent index of\n\t\t// the adjacent vertices of the picked vertex.\n\t\t// Consider only those vertices which are not\n\t\t// yet included in MST\n\t\tfor (int v = 0; v < V; v++)\n\n\t\t\t// graph[u][v] is non zero only for adjacent\n\t\t\t// vertices of m mstSet[v] is false for vertices\n\t\t\t// not yet included in MST Update the key only\n\t\t\t// if graph[u][v] is smaller than key[v]\n\t\t\tif (graph[u][v] && mstSet[v] == false\n\t\t\t\t&& graph[u][v] < key[v])\n\t\t\t\tparent[v] = u, key[v] = graph[u][v];\n\t}\n\n\t// Print the constructed MST\n\tprintMST(parent, graph);\n}\n\n// Driver's code\nint main()\n{\n\tint graph[V][V] = { { 0, 2, 0, 6, 0 },\n\t\t\t\t\t\t{ 2, 0, 3, 8, 5 },\n\t\t\t\t\t\t{ 0, 3, 0, 0, 7 },\n\t\t\t\t\t\t{ 6, 8, 0, 0, 9 },\n\t\t\t\t\t\t{ 0, 5, 7, 9, 0 } };\n\n\t// Print the solution\n\tprimMST(graph);\n\n\treturn 0;\n}\n\n\n",
    "#include <iostream>\n\n\t\t/*EXERCICIO 01*/\n\n//using namespace std;\n//int main() {\n//\tfloat instalacao = 300.00;\n//\tfloat limpeza = 150.00;\n//\tfloat manutencao = 499.99;\n//\tint soma = instalacao + limpeza + manutencao;\n//\n//\tcout << soma;\n//\n//\treturn 0;\n//}\n\n\t/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/\n\t\t/*EXERCICIO 02*/\n\n//using namespace std;\n//int main() {\n//\tfloat SalarioHora = 35.00;\n//\tint HorasTrabalhadas = 8;\n//\tint mult = SalarioHora * HorasTrabalhadas;\n//\n//\tcout << mult;\n//\n//\treturn 0;\n//}\n\n\t/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/\n\t\t/*EXERCICIO 03*/\n\n//using namespace std;\n//int main() {\n//\tint CaixaBomBom = 16;\n//\tint Unidades = 27;\n//\tint mult = CaixaBomBom * Unidades;\n//\n//\tcout << mult;\n//\n//\treturn 0;\n//}\n\n\t/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/\n\t\t/*EXERCICIO 04*/\n\n//int CalculoCaixas(\n//\tint GarrafasVendidas, \n//\tint GarrafasPorCaixa\n//) {\n//\treturn GarrafasVendidas / GarrafasPorCaixa;\n//}\n//using namespace std;\n//int main()\n//\n//{\n//\tint GarrafasVendidas = 300;\n//\tint GarrafasPorCaixa = 20;\n//\tint CaixasUsadas = CalculoCaixas(GarrafasVendidas, GarrafasPorCaixa);\n//\n//\tcout << \"foram usadas \" << CaixasUsadas << \" caixas de agua\" << std::endl;\n//\n//\treturn 0;\n//}\n\n\t/*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/\n\t\t/*EXERCICIO 05*/\n\nusing namespace std;\nint main() {\n\tint CamisetasLoja = 120;\n\tint CamisetasCompradas = 50;\n\tint CamisetasVendidas = 80;\n\tfloat ValorCamiseta = 30.00;\n\tint mult = CamisetasVendidas * ValorCamiseta;\n\tint EstoqueFinal = CamisetasLoja - CamisetasVendidas + CamisetasCompradas;\n\n\tcout << \"O faturamento foi de \" << mult << \" Reais\";\n\tcout << \" e a loja agora possui \" << EstoqueFinal << \" camisetas no estoque\";\n\treturn 0\n};\n\n",
    "#include <genetic-algorithm/traveling_salesman.h>\n\n#include \"../stdafx.h\"\n\n#include <fstream>\n\nnamespace core\n{\n\n    //\n    // Basic IO\n    //\n    void TravelingSalesmanProblem::loadTownsFromFile(const std::string& fileName)\n    {\n        std::ifstream ftowns(fileName);\n        Town town{};\n        while (ftowns >> town.x >> town.y) {\n            m_towns.push_back(town);\n        }\n        ftowns.close();\n    }\n\n    void TravelingSalesmanProblem::saveTownsToFile(const std::string& fileName, const std::vector<Town>& townVector)\n    {\n        std::ofstream ftowns(fileName);\n        for (const auto& twn : townVector)\n        {\n            ftowns << twn.x << \"\\t\" << twn.y << std::endl;\n        };\n        ftowns.close();\n    }\n\n    //\n    // Objective functions\n    //\n    float TravelingSalesmanProblem::objective(const std::vector<Town>& route)\n    {\n        float sum_length = 0;\n\n        for (unsigned int ti = 0; ti < route.size() - 1; ti++)\n        {\n            Town t1 = route[ti];\n            Town t2 = route[ti + 1];\n            sum_length += sqrt(pow(t1.x - t2.x, 2) + pow(t1.y - t2.y, 2));\n        }\n        return sum_length;\n    }\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"card_view\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mainwindow.hpp\"\r\n\r\n#include <QFileDialog>\r\n#include <QImage>\r\n#include <QPixmap>\r\n\r\n#include \"fft.hpp\"\r\n#include \"playback.hpp\"\r\n\r\nusing namespace std;\r\n\r\nWaveScene::WaveScene(int x, int y, int w, int h, MainWindow *parent)\r\n    : QGraphicsScene(x, y, w, h, parent) {\r\n  m_parent = parent;\r\n}\r\n\r\nvoid WaveScene::mouseMoveEvent(QGraphicsSceneMouseEvent *e) {\r\n  if (!m_parent->sound()) {\r\n    return;\r\n  }\r\n  double duration = m_parent->sound()->duration();\r\n  int x = e->scenePos().x();\r\n  double time = x / width() * duration;\r\n  m_parent->timeLabel()->setText(QString::number(time));\r\n}\r\n\r\nWaveView::WaveView(int x, int y, int w, int h, MainWindow *parent)\r\n    : QGraphicsView(parent) {\r\n  m_scene = new WaveScene(x, y, w, h, parent);\r\n  m_scene->setBackgroundBrush(QColor(0, 0, 80));\r\n  init();\r\n  setMouseTracking(true);\r\n  setScene(m_scene);\r\n}\r\n\r\nvoid WaveView::init() {\r\n  m_scene->clear();\r\n  m_scene->addLine(0, m_scene->height() / 2, m_scene->width(),\r\n                   m_scene->height() / 2, QColor(100, 100, 200));\r\n}\r\n\r\nvoid WaveView::drawWaveForm(Sound *sound) {\r\n  int w = m_scene->width();\r\n  int h = m_scene->height();\r\n  double bias = h / 2.0;\r\n  double gain = h / 2.0;\r\n  double samplesPerPix = sound->nSamples() / w;\r\n  double *x = sound->x();\r\n  int nMargin = sound->nMargin();\r\n  double max, min;\r\n  for (int i = 0; i < w; i++) {\r\n    max = -1.0;\r\n    min = 1.0;\r\n    for (int n = i * samplesPerPix; n < (i + 1) * samplesPerPix; n++) {\r\n      if (x[(int)n + nMargin] > max) {\r\n        max = x[(int)n + nMargin];\r\n      }\r\n      if (x[(int)n + nMargin] < min) {\r\n        min = x[(int)n + nMargin];\r\n      }\r\n    }\r\n    m_scene->addLine(i, -min * gain + bias, i, -max * gain + bias,\r\n                     QColor(\"white\"));\r\n  }\r\n}\r\n\r\nTFScene::TFScene(int x, int y, int w, int h, MainWindow *parent)\r\n    : QGraphicsScene(x, y, w, h, parent) {\r\n  m_parent = parent;\r\n}\r\n\r\nvoid TFScene::mouseMoveEvent(QGraphicsSceneMouseEvent *e) {\r\n  if (!m_parent->sound()) {\r\n    return;\r\n  }\r\n  int fs = m_parent->sound()->fs();\r\n  double duration = m_parent->sound()->duration();\r\n  int y = e->scenePos().y();\r\n  int x = e->scenePos().x();\r\n  double freq = (height() - y) / height() * fs / 2.0;\r\n  double time = x / width() * duration;\r\n  m_parent->freqLabel()->setText(QString::number(freq));\r\n  m_parent->timeLabel()->setText(QString::number(time));\r\n}\r\n\r\nTFView::TFView(int x, int y, int w, int h, MainWindow *parent)\r\n    : QGraphicsView(parent) {\r\n  m_scene = new TFScene(x, y, w, h, parent);\r\n  m_scene->setBackgroundBrush(QColor(\"black\"));\r\n  m_data = new unsigned char[w * h * 3];\r\n  setMouseTracking(true);\r\n  setScene(m_scene);\r\n  m_erbA = 1000.0 * log(10.0) / (24.7 * 4.37);\r\n}\r\n\r\nTFView::~TFView() {\r\n  delete[] m_data;\r\n  if (m_scaledIdx) {\r\n    delete[] m_scaledIdx;\r\n  }\r\n}\r\n\r\nvoid TFView::drawTFMap(Window::WindowType windowType, int windowSize) {\r\n  int w = m_scene->width();\r\n  int h = m_scene->height();\r\n  int hopSize = m_parentSound->nSamples() / w;\r\n  if (m_flagModified) {\r\n    m_parentSound->stft(hopSize, windowType, windowSize);\r\n    m_flagModified = false;\r\n  }\r\n  complex<double> **spec = m_parentSound->spec();\r\n  double specMax = m_parentSound->specMax();\r\n  double specMin = m_parentSound->specMin();\r\n  double upper_dB, lower_dB;\r\n  upper_dB = 20.0 * log10(specMax);\r\n  // lower_dB = 20.0 * log10(specMin);\r\n  lower_dB = -100.0;\r\n  for (int x = 0; x < w; x++) {\r\n    for (int y = 0; y < h; y++) {\r\n      double2rgb((20.0 * log10(abs(spec[x][m_scaledIdx[y]])) - lower_dB) /\r\n                     (upper_dB - lower_dB),\r\n                 m_data + ((h - 1 - y) * w + x) * 3,       // R\r\n                 m_data + ((h - 1 - y) * w + x) * 3 + 1,   // G\r\n                 m_data + ((h - 1 - y) * w + x) * 3 + 2);  // B\r\n    }\r\n  }\r\n  QImage img(m_data, w, h, QImage::Format_RGB888);\r\n  QPixmap pixmap = QPixmap::fromImage(img);\r\n  m_scene->addPixmap(pixmap);\r\n}\r\n\r\nvoid TFView::setFreqScale(FreqScale type) {\r\n  int nFFT = m_parentSound->fft()->nFFT();\r\n  int fs = m_parentSound->fs();\r\n  switch (type) {\r\n    case FreqScale::Linear:\r\n      for (int k = 0; k < nFFT / 2; k++) {\r\n        m_scaledIdx[k] = k;\r\n      }\r\n      break;\r\n    case FreqScale::Log:\r\n      for (int k = 0; k < nFFT / 2; k++) {\r\n        m_scaledIdx[k] = (int)pow(nFFT / 2.0, (double)k / (nFFT / 2.0));\r\n      }\r\n      break;\r\n    case FreqScale::ERB:\r\n      for (int k = 0; k < nFFT / 2; k++) {\r\n        m_scaledIdx[k] =\r\n            (int)(erb2hz((double)k / (nFFT / 2.0) * (hz2erb(22050.0))) / fs *\r\n                  nFFT);\r\n      }\r\n      break;\r\n    case FreqScale::Bark:\r\n      for (int k = 0; k < nFFT / 2; k++) {\r\n        m_scaledIdx[k] =\r\n            (int)(bark2hz((double)k / (nFFT / 2.0) * (hz2bark(22050.0))) / fs *\r\n                  nFFT);\r\n      }\r\n      break;\r\n    case FreqScale::Mel:\r\n      for (int k = 0; k < nFFT / 2; k++) {\r\n        m_scaledIdx[k] =\r\n            (int)(mel2hz((double)k / (nFFT / 2.0) * (hz2mel(22050.0))) / fs *\r\n                  nFFT);\r\n    ",
    "#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <ranges>\n#include <sstream>\n#include <vector>\n\nstruct Point\n{\n    int val;\n    double x, y;\n    double distance;\n};\n\nstatic int64_t \nPointClassification(std::vector<Point>& points, size_t k, const Point& p)\n{\n    for (auto& point : points)\n    {\n        point.distance = sqrt((point.x - p.x) * (point.x - p.x) +\n                        (point.y - p.y) * (point.y - p.y));\n    }\n\n    std::ranges::sort(points, [](const auto& a, const auto& b) {\n        return a.distance < b.distance;\n        });\n\n    std::vector<int> frequency_count(3, 0); // Number of groups\n    std::span<Point> point_span{ points.data(), std::min(k, points.size()) };\n    for (auto& point : point_span)\n    {\n        if (point.val < frequency_count.size())\n        {\n            ++frequency_count[point.val];\n        }\n    }\n\n\n    auto max_iterator = std::ranges::max_element(frequency_count);\n    return std::distance(frequency_count.begin(), max_iterator);\n}\n\nstatic std::vector<std::string> \nParseLine(const std::string& str, char delimiter)\n{\n    std::istringstream iss(str);\n    std::string token;\n    std::vector<std::string> tokens;\n\n    while (getline(iss, token, delimiter))\n    {\n        tokens.push_back(token);\n    }\n    \n    return tokens;\n}\n\nint main()\n{\n    std::vector<Point> points;\n    std::ifstream file(\"data_points.txt\");\n    std::string line;\n\n    while (getline(file, line))\n    {\n        auto tokens = ParseLine(line, ',');\n        Point temp{};\n\n        temp.x = std::stod(tokens[0]);\n        temp.y = std::stod(tokens[1]);\n        temp.val = std::stoi(tokens[2]);\n        \n        points.push_back(temp);\n    }\n\n    Point p{};\n    std::cout << \"Enter x and y coordinates of the point to classify: \";\n    std::cin >> p.x >> p.y;\n\n    size_t k;\n    std::cout << \"Enter the number of nearest neighbours to consider: \";\n    std::cin >> k;\n\n    int64_t group = PointClassification(points, k, p);\n    std::cout << \"The point belongs to group \" << group << std::endl;\n\n    return 0;\n}\n\n",
    "// dear imgui: Renderer Backend for DirectX12\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'D3D12_GPU_DESCRIPTOR_HANDLE' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// Important: to compile on 32-bit systems, this backend requires code to be compiled with '#define ImTextureID ImU64'.\n// This is because we need ImTextureID to carry a 64-bit value and by default ImTextureID is defined as void*.\n// To build this on 32-bit systems:\n// - [Solution 1] IDE/msbuild: in \"Properties/C++/Preprocessor Definitions\" add 'ImTextureID=ImU64' (this is what we do in the 'example_win32_direct12/example_win32_direct12.vcxproj' project file)\n// - [Solution 2] IDE/msbuild: in \"Properties/C++/Preprocessor Definitions\" add 'IMGUI_USER_CONFIG=\"my_imgui_config.h\"' and inside 'my_imgui_config.h' add '#define ImTextureID ImU64' and as many other options as you like.\n// - [Solution 3] IDE/msbuild: edit imconfig.h and add '#define ImTextureID ImU64' (prefer solution 2 to create your own config file!)\n// - [Solution 4] command-line: add '/D ImTextureID=ImU64' to your cl.exe command-line (this is what we do in the example_win32_direct12/build_win32.bat file)\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX12: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX12: Change blending equation to preserve alpha in output buffer.\n//  2021-01-11: DirectX12: Improve Windows 7 compatibility (for D3D12On7) by loading d3d12.dll dynamically.\n//  2020-09-16: DirectX12: Avoid rendering calls with zero-sized scissor rectangle since it generates a validation layer warning.\n//  2020-09-08: DirectX12: Clarified support for building on 32-bit systems by redefining ImTextureID.\n//  2019-10-18: DirectX12: *BREAKING CHANGE* Added extra ID3D12DescriptorHeap parameter to ImGui_ImplDX12_Init() function.\n//  2019-05-29: DirectX12: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX12: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2019-03-29: Misc: Various minor tidying up.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-06-12: DirectX12: Moved the ID3D12GraphicsCommandList* parameter from NewFrame() to RenderDrawData().\n//  2018-06-08: Misc: Extracted imgui_impl_dx12.cpp/.h away from the old combined DX12+Win32 example.\n//  2018-06-08: DirectX12: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle (to ease support for future multi-viewport).\n//  2018-02-22: Merged into master with all Win32 code synchronized to other examples.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_dx12.h\"\n\n// DirectX\n#include <d3d12.h>\n#include <dxgi1_4.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX data\nstruct ImGui_ImplDX12_RenderBuffers;\nstruct ImGui_ImplDX12_Data\n{\n    ID3D12Device*               pd3dDevice;\n    ID3D12RootSignature*        pRootSignature;\n    ID3D12PipelineState*        pPipelineState;\n    DXGI_FORMAT                 RTVFormat;\n    ID3D12Resource*             pFontTextureResource;\n    D3D12_CPU_DESCRIPTOR_HANDLE hFontSrvCpuDescHandle;\n    D3D12_GPU_DESCRIPTOR_HANDLE hFontSrvGpuDescHandle;\n    ID3D12DescriptorHeap*       pd3dSrvDescHeap;\n    UINT                        numFramesInFlight;\n\n    ImGui_ImplDX12_RenderBuffers* pFrameResources;\n    UINT                        frameIndex;\n\n    ImGui_ImplDX12_Data()       { memset((void*)this, 0, sizeof(*this)); frameIndex = UINT_MAX; }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STR",
    "#include <Arduino.h>\n#include <LiquidCrystal.h>\n#include <Keypad.h>\n\nLiquidCrystal lcd(2, 3, A3, A2, A1, A0);\n\nconst int ROW_NUM = 4;\nconst int COLUMN_NUM = 4;\n\nchar keys[ROW_NUM][COLUMN_NUM] = {\n  {'1','2','3', 'A'},\n  {'4','5','6', 'B'},\n  {'7','8','9', 'C'},\n  {'*','0','#', 'D'}\n};\n\nbyte pin_rows[ROW_NUM] = {4, 5, 6, 7};\nbyte pin_column[COLUMN_NUM] = {8, 9, 10, 11};\n\nKeypad keypad = Keypad( makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM );\n\nchar password[] = {'3', '5', '9', '3'};\nchar input[] = {'-', '-', '-', '-'};\nchar key;\nint pos = 0;\n\nvoid setup(){\n  pinMode(A4, OUTPUT);\n  pinMode(A5, OUTPUT);\n\n  lcd.begin(16, 2);\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"Enter password:\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"----\");\n  lcd.setCursor(0, 1);\n}\n\nvoid loop(){\n  key = keypad.getKey();\n\n  if (key == '#') {\n    if (pos != 0) {\n      pos--;\n      input[pos] = '-';\n      lcd.moveCursorLeft();\n      lcd.print('-');\n      lcd.moveCursorLeft();\n    }    \n  }\n  else if (key == '*') {\n    if (pos == 4) {\n      lcd.clear();\n      lcd.setCursor(0, 0);\n\n      if (password[0] == input[0] &&\n          password[1] == input[1] &&\n          password[2] == input[2] &&\n          password[3] == input[3]) {\n            digitalWrite(A5, HIGH);\n            lcd.print(\"Correct password\");\n            delay(3000);\n            digitalWrite(A5, LOW);\n      }\n      else {\n        digitalWrite(A4, HIGH);\n        lcd.print(\"Wrong password!\");\n        delay(3000);\n        digitalWrite(A4, LOW);\n      }\n\n      for (int i = 0; i < 4; i++) {\n        input[i] = '-';\n      }\n\n      lcd.clear();\n      lcd.setCursor(0, 0);\n      lcd.print(\"Enter password:\");\n      lcd.setCursor(0, 1);\n      lcd.print(\"----\");\n      lcd.setCursor(0, 1);\n      pos = 0;\n    }    \n  }\n  else if (key) {\n    if (pos < 4) {\n      input[pos] = key;\n      pos++;\n      lcd.print(key);\n    }\n  }\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nclass Calendar\r\n{\r\npublic:\r\n    int year;\r\n    int month;\r\n    Calendar(int y, int m)\r\n    {\r\n        year=y;\r\n        month=m;\r\n    }\r\n\r\n    int getDaysInMonth()\r\n    {\r\n        if (month == 2)\r\n        {\r\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) //If the entered year is a leap year//\r\n                return 29; \r\n            else\r\n                return 28; //If the entered year is not leap year//\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) //Foe even months having 30 days\r\n            return 30;\r\n        else\r\n            return 31; //For odd months having 31 days\r\n    }\r\n\r\n    void displayCalendar()\r\n    {\r\n        cout << \"-----------------------------\" << endl;\r\n        cout << \"       \" << getMonthName() << \" \" << year << endl;\r\n        cout << \"-----------------------------\" << endl;\r\n        cout << \" Sun Mon Tue Wed Thu Fri Sat\" << endl;\r\n\r\n        int startingDay = getStartingDay();\r\n        int daysInMonth = getDaysInMonth();\r\n\r\n        int day = 1;\r\n\r\n        // Print leading spaces\r\n        for (int i = 0; i < startingDay; i++)\r\n        {\r\n            cout << setw(4) << \" \";\r\n        }\r\n\r\n        // Print the days of the month\r\n        for (int i = 1; i <= daysInMonth; i++)\r\n        {\r\n            cout << setw(4) << day++;\r\n            if ((i + startingDay) % 7 == 0 || i == daysInMonth)\r\n                cout << endl;\r\n        }\r\n\r\n        cout << \"-----------------------------\" << endl;\r\n    }\r\n\r\n    int getStartingDay()\r\n    {\r\n        // Zeller's Congruence algorithm for days of week\r\n        int h = (1 + getMonthCode() + getYearCode() + getCenturyCode()) % 7;\r\n        return (h == 0) ? 6 : h - 1; // Convert 0 (Saturday) to 6\r\n    }\r\n\r\n    int getMonthCode()\r\n    {\r\n        //Retrun values from getMonthCode \r\n        static int monthCodes[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5};\r\n        return monthCodes[month - 1];\r\n    }\r\n\r\n    int getYearCode()\r\n    {\r\n        int yearCode = year % 100;\r\n        return (yearCode + yearCode / 4) % 7;\r\n    }\r\n\r\n    int getCenturyCode()\r\n    {\r\n        static int centuryCodes[] = {0, 6, 4, 2};\r\n        int century = year / 100;\r\n        return centuryCodes[century % 4];\r\n    }\r\n\r\n    string getMonthName()\r\n    {\r\n        static string monthNames[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\r\n                                      \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n                                     };\r\n        return monthNames[month - 1];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    int year, month;\r\n    cout << \"Enter year : \";\r\n    cin >> year;\r\n    cout << \"month : \";\r\n    cin >> month;\r\n\r\n    Calendar cal(year, month);\r\n    cal.displayCalendar();\r\n\r\n\u00a0\u00a0\u00a0\u00a0return\u00a00;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n// timeout.cpp\n// ~~~~~~~~~~~\n//\n// Copyright (c) 2003-2023 Christopher M. Kohlhoff (chris at kohlhoff dot com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#include <boost/asio.hpp>\n#include <boost/asio/experimental/awaitable_operators.hpp>\n\nusing namespace boost::asio;\nusing namespace boost::asio::experimental::awaitable_operators;\nusing time_point = std::chrono::steady_clock::time_point;\nusing ip::tcp;\n\nawaitable<void> echo(tcp::socket& sock, time_point& deadline)\n{\n  char data[4196];\n  for (;;)\n  {\n    // \u6bcf\u6b21\u8bfb\u5199\u5faa\u73af\u7ed3\u675f\u540e\u5582\u72d7\u3002\u95f4\u9694\u5927\u4e8e\u5341\u79d2\u949f\u72d7\u5c31\u53eb\u4e86\u3002\n    deadline = std::chrono::steady_clock::now() + std::chrono::seconds(10);\n    auto n = co_await sock.async_read_some(buffer(data), use_awaitable);\n    co_await async_write(sock, buffer(data, n), use_awaitable);\n  }\n}\n\nawaitable<void> watchdog(time_point& deadline)\n{\n  steady_timer timer(co_await this_coro::executor);\n  auto now = std::chrono::steady_clock::now();\n  while (deadline > now)\n  {\n    timer.expires_at(deadline);\n    co_await timer.async_wait(use_awaitable);\n    now = std::chrono::steady_clock::now();\n  }\n  throw std::system_error(std::make_error_code(std::errc::timed_out));\n}\n\nawaitable<void> handle_connection(tcp::socket sock)\n{\n  time_point deadline{};\n  co_await (echo(sock, deadline) && watchdog(deadline));\n}\n\nawaitable<void> listen(tcp::acceptor& acceptor)\n{\n  for (;;)\n  {\n    co_spawn(\n        acceptor.get_executor(),\n        handle_connection(co_await acceptor.async_accept(use_awaitable)),\n        detached);\n  }\n}\n\nint t_main()\n{\n  io_context ctx;\n  tcp::acceptor acceptor(ctx, {tcp::v4(), 54321});\n  co_spawn(ctx, listen(acceptor), detached);\n  ctx.run();\n  return 0;\n}",
    "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include \"lc787.h\"\n\nusing namespace std;\n\ntemplate<typename T>\nvoid print(vector<T> vec) {\n    for (auto item: vec) {\n        cout << item << \" \";\n    }\n    cout << endl;\n}\n\ntemplate<typename T>\nvoid print(T t) {\n    cout << t << endl;\n}\n\n\nint main() {\n    Solution s;\n    vector<vector<int>> flights{{0, 1, 100},\n                                {1, 2, 100},\n                                {2, 0, 100},\n                                {1, 3, 600},\n                                {2, 3, 200}};\n    auto res = s.findCheapestPrice(4, flights, 0, 3, 1);\n    print(res);\n    flights = {{3, 4, 4},\n               {2, 5, 6},\n               {4, 7, 10},\n               {9, 6, 5},\n               {7, 4, 4},\n               {6, 2, 10},\n               {6, 8, 6},\n               {7, 9, 4},\n               {1, 5, 4},\n               {1, 0, 4},\n               {9, 7, 3},\n               {7, 0, 5},\n               {6, 5, 8},\n               {1, 7, 6},\n               {4, 0, 9},\n               {5, 9, 1},\n               {8, 7, 3},\n               {1, 2, 6},\n               {4, 1, 5},\n               {5, 2, 4},\n               {1, 9, 1},\n               {7, 8, 10},\n               {0, 4, 2},\n               {7, 2, 8}};\n    res = s.findCheapestPrice(10, flights, 6, 0, 7);\n    print(res);\n    return 0;\n}",
    "\ufeff#include <iostream>\n#include <exprtk.hpp>\n#include <matplot/matplot.h>\n#include <cmath>\n#include <iomanip>\n\nvoid InputData(double& StartOfRange, double& EndOfRange, double& X0, double& Y0, std::string& FunctionX, std::string& FunctionY, int& Option);\nstd::vector<double> GetK(std::string Function, double t, double x, double y, double H);\nvoid OutputGraphs(std::vector<std::vector<double>> Results, std::vector<double> TableH, int Option);\nvoid OutputResultsTable(std::vector<std::vector<double>> Results, std::vector<double> TableH);\ndouble GetFunctionValue(const std::string& Function, double t, double x, double y);\nstd::vector<std::vector<double>> RungeKuttaMethod(const std::string& FunctionX, const std::string& FunctionY,\n    double StartOfRange, double EndOfRange, double X0, double Y0, double H, std::vector<double>& TableH);\nstd::vector<std::vector<double>> RungeKuttaMethodWA(std::string& FunctionX, std::string& FunctionY,\n    double StartOfRange, double EndOfRange, double X0, double Y0, double Epsilon, std::vector<double>& TableH);\ndouble GetRealValue(double X, int Option);\nvoid OutputOptions();\nstd::vector<double> GetGlobalError(std::vector<std::vector<double>> Results, std::vector<double> TableH, int Option);\n\nint main()\n{\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n\n    //\u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0432 \u043e\u0431\u043e\u0438\u0445 \u0440\u0435\u0436\u0438\u043c\u0430\u0445\n    double StartOfRange, EndOfRange, X0, Y0;\n    std::string FunctionX;\n    std::string FunctionY;\n    std::vector<double> K; //\u041a\u043e\u0436\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b K 1-4\n    std::vector<std::vector<double>> Results; //\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b x \u0438 y\n    std::vector<double> TableH; //\u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0441 \u0448\u0430\u0433\u0430\u043c\u0438\n    std::vector<double> Error; //\u041d\u043e\u0440\u043c\u0430 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0439 \u043e\u0448\u0438\u0431\u043a\u0438\n    int Option; //\u0412\u044b\u0431\u0440\u0430\u043d\u043d\u0430\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u0430\n\n    double H; //\u0428\u0430\u0433 - \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u043f\u0435\u0440\u0432\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435\n\n    double Epsilon; //\u041f\u043e\u0433\u0440\u0435\u0449\u043d\u043e\u0441\u0442\u044c - \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432\u043e \u0432\u0442\u043e\u0440\u043e\u043c \u0440\u0435\u0436\u0438\u043c\u0435\n\n    OutputOptions();\n\n    int Choice;\n    std::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u0435\u0436\u0438\u043c \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: \" << std::endl;\n    std::cout << \"1) \u0421 \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c.\" << std::endl;\n    std::cout << \"2) \u0421 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u043c \u0448\u0430\u0433\u043e\u043c.\" << std::endl;\n    std::cout << \"\u0412\u0430\u0448 \u0432\u044b\u0431\u043e\u0440: \";\n    std::cin >> Choice;\n\n    switch (Choice)\n    {\n    case 1:\n        InputData(StartOfRange, EndOfRange, X0, Y0, FunctionX, FunctionY, Option);\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0448\u0430\u0433: \";\n        std::cin >> H;\n        Results = RungeKuttaMethod(FunctionX, FunctionY, StartOfRange, EndOfRange, X0, Y0, H, TableH);\n        OutputResultsTable(Results, TableH);\n        OutputGraphs(Results, TableH, Option);\n        Error = GetGlobalError(Results, TableH, Option);\n        std::cout << \"\u041d\u043e\u0440\u043c\u0430 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0439 \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u0438\\n1) \";\n        std::cout << Error[0] << \"\\n2) \" << Error[1] << std::endl;\n        break;\n    case 2:\n        InputData(StartOfRange, EndOfRange, X0, Y0, FunctionX, FunctionY, Option);\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u044c: \";\n        std::cin >> Epsilon;\n        Results = RungeKuttaMethodWA(FunctionX, FunctionY, StartOfRange, EndOfRange, X0, Y0, Epsilon, TableH);\n        OutputResultsTable(Results, TableH);\n        OutputGraphs(Results, TableH, Option);\n        Error = GetGlobalError(Results, TableH, Option);\n        std::cout << \"\u041d\u043e\u0440\u043c\u0430 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u043e\u0439 \u043f\u043e\u0433\u0440\u0435\u0448\u043d\u043e\u0441\u0442\u0438\\n 1) \";\n        std::cout << Error[0] << \"\\n2) \" << Error[1] << std::endl;\n        break;\n    default:\n        std::cout << \"\u0420\u0435\u0436\u0438\u043c \u043d\u0435 \u0431\u044b\u043b \u0432\u044b\u0431\u0440\u0430\u043d!\" << std::endl;\n        break;\n    }\n\n    return 0;\n}\n\n//\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u0432\u043e\u0434\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\nvoid InputData(double& StartOfRange, double& EndOfRange, double& X0, double& Y0, std::string& FunctionX, std::string& FunctionY, int& Option)\n{\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0447\u0430\u043b\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430: \";\n    std::cin >> StartOfRange;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043d\u0435\u0446 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430: \";\n    std::cin >> EndOfRange;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 x(0) = \";\n    std::cin >> X0;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 y(0) = \";\n    std::cin >> Y0;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e x`(t)=\";\n    std::cin >> FunctionX;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044e y`(t)=\";\n    std::cin >> FunctionY;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b: \";\n    std::cin >> Option;\n}\n\n//\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0433\u0440\u0430\u0444\u0438\u043a\u043e\u0432\nvoid OutputGraphs(std::vector<std::vector<double>> Results, std::vector<double> TableH, int Option)\n{\n    std::vector<double> x1;\n    std::vector<double> y1;\n    std::vector<double> x2;\n    std::vector<double> y2;\n    for (double i = TableH[0]; i < TableH[TableH.size() - 1]; i += 0.01)\n    {\n        x1.push_back(i);\n        y1.push_back(GetRealValue(i, Option));\n        x2.push_back(i);\n        y2.push_back(GetRealValue(i, Option + 1));\n    }\n    matplot::hold(matplot::on);\n    matplot::plot(TableH, Results[0])->line_width(2).color(\"blue\");\n    matplot::plot(x1, y1)->line_width(3).color(\"c\");\n    matplot::plot(TableH, Results[1])->line_width(2).color(\"red\");\n    matplot::plot(x2, y2)->line_width(3).color(\"g\");\n    matplot::hold(matplot::off);\n    matplot::show();\n}\n\n//\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\nvoid OutputResultsTable(std::vector<std::vector<double>> Results, std::vector<double> TableH)\n{\n    int Width = 12;\n    std::cout << std::left << std::setw(Width) <<",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/laser_scan.hpp\"\n#include \"geometry_msgs/msg/twist.hpp\"\n\nclass Patrol : public rclcpp::Node {\npublic:\n    Patrol() : Node(\"robot_patrol\"), direction_(0) {\n        callback_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n        // Initialize the publisher for the robot's velocity\n        velocity_publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(\"/cmd_vel\", 10);\n\n        // Initialize the subscriber for the laser scan data\n        rclcpp::QoS qos(10);\n        rclcpp::SubscriptionOptions options;\n        options.callback_group = callback_group_;\n\n    \n        laser_subscriber_ = this->create_subscription<sensor_msgs::msg::LaserScan>(\n            \"/scan\", qos, std::bind(&Patrol::laserCallback, this, std::placeholders::_1), options);\n\n        // Start the control loop timer\n        timer_ = this->create_wall_timer(\n            std::chrono::milliseconds(100), std::bind(&Patrol::controlLoop, this),callback_group_);\n    }\n\nprivate:\n    sensor_msgs::msg::LaserScan::SharedPtr latest_scan_;\n    bool has_new_scan_ = false;\n    double direction_;\n\n    void laserCallback(const sensor_msgs::msg::LaserScan::SharedPtr msg) {\n        RCLCPP_INFO(this->get_logger(), \"laserCallback called.\");\n        auto start = std::chrono::high_resolution_clock::now();\n\n    if (msg == nullptr || msg->ranges.empty()) {\n        RCLCPP_WARN(this->get_logger(), \"Invalid laser scan data received.\");\n        return;\n    }\n\n    latest_scan_ = msg;\n    has_new_scan_ = true;\n\n    auto end = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n\n    float closest_obstacle_distance = std::numeric_limits<float>::max();\n\n    for (float distance : msg->ranges) {\n        if (distance >= msg->range_min && distance <= msg->range_max) {\n            closest_obstacle_distance = std::min(closest_obstacle_distance, distance);\n        }\n    }\n\n    int front_readings_count = static_cast<int>((msg->angle_max - msg->angle_min) / msg->angle_increment) + 3;\n\n    int max_index = -1;\n    float max_distance = 0.0;\n\n    // Iterate through the front 180-degree readings to find the largest distance\n    for (int i = 0; i < front_readings_count; ++i) {\n        float distance = msg->ranges[i];\n        if (distance >= msg->range_min && distance <= msg->range_max && distance > max_distance) {\n            max_distance = distance;\n            max_index = i;\n        }\n    }\n\n    // Determine the direction to move\n    if (max_index!= -1) {\n        direction_ = msg->angle_min + max_index * msg->angle_increment;\n        RCLCPP_INFO(this->get_logger(), \"Obstacle detected. Index: %d, Distance: %.2f m, Direction angle: %.2f radians\", max_index, max_distance, direction_);\n    } else {\n        direction_ = 0.0;\n        RCLCPP_INFO(this->get_logger(), \"No obstacles detected. Moving straight.\");\n    }\n}\n\n    void controlLoop() {\n    if (!has_new_scan_ || latest_scan_ == nullptr) {\n        RCLCPP_WARN(this->get_logger(), \"No new scan data.\");\n        return;\n    }\n\n    geometry_msgs::msg::Twist cmd_vel_msg;\n    float linear_speed = 0.1;\n    float safety_distance = 0.5; // 33 cm\n\n      float closest_obstacle_distance = *std::min_element(latest_scan_->ranges.begin(), latest_scan_->ranges.end());\n        RCLCPP_DEBUG(this->get_logger(), \"Closest obstacle distance: %.2f m\", closest_obstacle_distance);\n\n        if (latest_scan_->ranges.empty()) {\n        RCLCPP_WARN(this->get_logger(), \"Scan data is empty.\");\n        return;\n    }\n\n    if (closest_obstacle_distance < safety_distance) {\n        // Move in a safe direction\n        float safe_direction_angle = direction_ + (M_PI / 2); // turn 90 degrees to the right\n        if (safe_direction_angle > M_PI) {\n            safe_direction_angle -= 2 * M_PI;\n        }\n        cmd_vel_msg.linear.x = 0.1; // Move slowly\n        cmd_vel_msg.angular.z = safe_direction_angle; // Turn towards the safe direction\n\n        RCLCPP_INFO(this->get_logger(), \"Obstacle too close. Moving in a safe direction with linear velocity: %.2f and angular velocity: %.2f\", cmd_vel_msg.linear.x, cmd_vel_msg.angular.z);\n    } else {\n        cmd_vel_msg.linear.x = linear_speed;\n        cmd_vel_msg.angular.z = 0.0; // Go straight\n\n        RCLCPP_INFO(this->get_logger(), \"Path is clear. Moving straight with linear velocity: %.2f\", linear_speed);\n    }\n\n    velocity_publisher_->publish(cmd_vel_msg);\n    has_new_scan_ = false; // Reset the flag\n}\n\n    rclcpp::CallbackGroup::SharedPtr callback_group_;\n    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr velocity_publisher_;\n    rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr laser_subscriber_;\n    rclcpp::TimerBase::SharedPtr timer_;\n};\n\nint main(int argc, char **argv) {\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<Patrol>();\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}\n\n\n",
    "\r\n#include \"../include/ImageBase.h\"\r\n#include \"../include/Functions.h\"\r\nextern \"C\"{\r\n    #include \"../include/image_ppm.h\"\r\n}\r\n\r\n\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <string>\r\n#include <filesystem>\r\n\r\n\r\nbool is_ppm(const std::string& extension) {\r\n    return extension == \".ppm\";\r\n}\r\n\r\nstd::string getLastDirectoryName(const std::string & path) {\r\n    std::filesystem::path chemin(path);\r\n    return chemin.filename().string();\r\n}\r\n\r\nstd::string getProgramFolderPath(std::string programName) {\r\n    return std::filesystem::canonical(std::filesystem::path(programName)).parent_path().parent_path().string();\r\n}\r\n\r\n\r\nvoid getImagesFromFolder(std::vector<std::string> & imagePaths, std::string folderPath) {\r\n    imagePaths.clear();\r\n    for (const auto& entry : std::filesystem::directory_iterator(folderPath)) {\r\n        if (entry.is_regular_file()) {\r\n            std::string file_extension = entry.path().extension().string();\r\n            if (is_ppm(file_extension)) {\r\n                imagePaths.push_back(entry.path().string());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid createDirectoryIfNotExists(const std::string & path) {\r\n    if (!std::filesystem::exists(path)) {\r\n        if (!std::filesystem::create_directories(path)) {\r\n            std::cerr << \"Erreur : Impossible de creer le repertoire \" << path << \"\\n\";\r\n        } else {\r\n            std::cout << \"Repertoire cree : \" << path << \"\\n\";\r\n        }\r\n    } else {\r\n        std::cout << \"Le repertoire existe deja : \" << path << \"\\n\";\r\n    }\r\n}\r\n\r\n\r\nvoid convertPpmToPgm(char * cNameImageIn, char* cNameImageOut){\r\n\r\n    int nH, nW, nTaille, nTaille3, nR, nG,nB;\r\n    OCTET *ImgIn, *ImgOut;\r\n\r\n    lire_nb_lignes_colonnes_image_ppm(cNameImageIn, &nH, &nW);\r\n\r\n        nTaille = nH * nW;\r\n        nTaille3 = nTaille * 3;\r\n\r\n    allocation_tableau(ImgIn, OCTET, nTaille3);\r\n    lire_image_ppm(cNameImageIn, ImgIn, nTaille);\r\n\r\n    allocation_tableau(ImgOut, OCTET, nTaille);\r\n\r\n    int k = 0;\r\n    for (int i = 0; i < nH; i++)\r\n    {\r\n        for (int j = 0; j < nW; j++)\r\n        {\r\n            k =  (i * nW + j) * 3;\r\n            nR = k;\r\n            nG = k+1;\r\n            nB = k+2;\r\n            ImgOut[i*nW+j] = 0.2126 * ImgIn[nR] + 0.7152 * ImgIn[nG] + 0.0722 * ImgIn[nB];\r\n\r\n        }\r\n    }\r\n    \r\n\r\n    ecrire_image_pgm(cNameImageOut, ImgOut, nH, nW);\r\n    free(ImgIn);\r\n    free(ImgOut);\r\n\r\n}\r\n\r\n\r\nint main(int argc, char const *argv[])\r\n{\r\n\tif (argc != 2) {\r\n\t\tprintf(\"Usage : directory\\n\");\r\n\t\treturn 1;\r\n\t}\r\n    char imageInPath[200],imageOutPath[200];\r\n    char cNameFolder[200];\r\n    std::string sNameFolder = argv[1];\r\n    std::string sNameclassString = getLastDirectoryName(sNameFolder);\r\n\r\n    std::string sNewfolderpath;\r\n    std::vector<std::string> imagePaths;\r\n    \r\n    std::strcpy(cNameFolder,sNameFolder.c_str());\r\n\r\n    sNewfolderpath = getProgramFolderPath(argv[0]) + \"/pgm/\"+ sNameclassString ;\r\n    createDirectoryIfNotExists(sNewfolderpath);\r\n\r\n    std::cout << \"Conversion ppm en pgm ...\" << \"\\n\";\r\n\r\n    getImagesFromFolder(imagePaths, cNameFolder);\r\n    for (int img_cpt = 0; img_cpt < imagePaths.size(); ++img_cpt) {\r\n        std::cout << \"Image \" << img_cpt+1 << \" sur \" << imagePaths.size() << \"\\n\";\r\n\r\n\r\n        std::string sImgInPath = sNameFolder + '/'+ sNameclassString +\" (\" + std::to_string(img_cpt+1) + \").ppm\";\r\n        std::strcpy(imageInPath, sImgInPath.c_str());\r\n        std::string sImgOutPath = sNewfolderpath + '/'+ sNameclassString  +\" (\" + std::to_string(img_cpt+1) + \").pgm\";\r\n        std::strcpy(imageOutPath, sImgOutPath.c_str());\r\n\r\n        convertPpmToPgm(imageInPath,imageOutPath);\r\n    }\r\n\r\n    std::cout << \"Fin..\" << \"\\n\";\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <string>\n#include <thread>\nusing namespace std;\n\n//I used a YouTube video to help me with the timer. https://www.youtube.com/watch?v=oEx5vGNFrLk&list=WL&index=8&t=512s\n//This class acts as the timer.\nclass Timer\n{\nprivate:\n    std::chrono::time_point<std::chrono::high_resolution_clock> START, STOP;\n    std::chrono::duration<float> TIME{};\n    bool isRunning;\n    float finalTime = 0.00f;\n\npublic:\n    Timer()\n    {\n        isRunning = false;\n    }\n    void start()\n    {\n        if(!isRunning)\n        {\n            START = std::chrono::high_resolution_clock::now();\n            isRunning = true;\n        }\n    }\n    void stop()\n    {\n        if(isRunning)\n        {\n            STOP = std::chrono::high_resolution_clock::now();\n            TIME = STOP - START;\n            finalTime = TIME.count();\n            isRunning = false;\n        }\n    }\n    float getTime() const\n    {\n        return finalTime;\n    }\n    ~Timer() = default;\n};\n\n//The following two functions are for merge sort and are taken from Professor's slides, \"6-Sorting\", #89 & #90.\nvoid merge(std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> &vec, int left, int mid, int right)\n{\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> X(n1);\n    std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> Y(n2);\n    for(int i = 0; i < n1; i++)\n    {\n        X[i] = vec[left + i];\n    }\n    for(int j = 0; j < n2; j++)\n    {\n        Y[j] = vec[mid + 1 + j];\n    }\n    int i = 0, j = 0, k = left;\n    while(i < n1 && j < n2)\n    {\n        if(std::get<2>(X[i]) <= std::get<2>(Y[j]))\n        {\n            vec[k] = X[i];\n            i++;\n        }\n        else\n        {\n            vec[k] = Y[j];\n            j++;\n        }\n        k++;\n    }\n    while(i < n1)\n    {\n        vec[k] = X[i];\n        i++;\n        k++;\n    }\n    while(j < n2)\n    {\n        vec[k] = Y[j];\n        j++;\n        k++;\n    }\n}\n\n// Merge sort function\nvoid mergeSort(std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> &vec, int left, int right)\n{\n    if(left < right)\n    {\n        int mid = left + (right - left) / 2;\n        mergeSort(vec, left, mid);\n        mergeSort(vec, mid + 1, right);\n        merge(vec, left, mid, right);\n    }\n}\n\n//The following two functions are for quick sort and are taken from Professor's slides, \"6-Sorting\", #122.\nint partition(std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> &vec, int low, int high)\n{\n    std::tuple<std::string, std::string, int, std::string, std::string> pivot = vec[low];\n    int up = low, down = high;\n    while(up < down)\n    {\n        for(int i = up; i < high; i++)\n        {\n            if(std::get<2>(vec[up]) > std::get<2>(pivot))\n            {\n                break;\n            }\n            up++;\n        }\n        for(int i = high; i > low; i--)\n        {\n             if(std::get<2>(vec[down]) < std::get<2>(pivot))\n             {\n                 break;\n             }\n             down--;\n        }\n        if(up < down)\n        {\n            std::swap(vec[up], vec[down]);\n        }\n    }\n    std::swap(vec[low], vec[down]);\n    return down;\n}\n\n//Quick sort function\nvoid quickSort(std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> &vec, int low, int high)\n{\n    if(low < high)\n    {\n        int pivot = partition(vec, low, high);\n        quickSort(vec, low, pivot - 1);\n        quickSort(vec, pivot + 1, high);\n    }\n}\n\n//Helper function for checking if a string exists anywhere in a name\nbool searchName(const string& name1, const string& name2) {\n    unsigned int len1 = name1.size();\n    unsigned int len2 = name2.size();\n    if(len2 >= len1) {\n        for(int i = 0; i < len2 - len1 + 1; i++) {\n            if (name2.substr(i, len1) == name1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    //This following chunk of code takes the 100k data points from playerList.txt and parses them into two separate vector, one for merge sort and one for quick sort.\n    //I used a YouTube video to help me with file i/o. https://www.youtube.com/watch?v=RHngWtyEtTs&list=WL&index=9&t=564s\n    //Name School Rank Position Division\n    std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> msPlayers;\n    std::vector<std::tuple<std::string, std::string, int, std::string, std::string>> qsPlayers;\n    std::string name, school, position, conference, tempRank, line;\n    int rank;\n    float msTime, qsTime;\n    std::ifstream inFile;\n    std::stringstream inLine;\n    inFile.open(\"playerList.txt\");\n    while(std::getline(inFile, line))\n    {\n        inLine.clear();\n        inLine.str(line);\n        std::getline(inLine, name, '_');\n        std::getline(inLine, school,",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"serial/serial.h\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"sensor_msgs/msg/joint_state.hpp\"\n\nserial::Serial _serial;\t\t\t\t// serial object\n\nclass MirobotWriteNode : public rclcpp::Node\n{\npublic:\n    MirobotWriteNode()\n        : Node(\"mirobot_write_node\")\n    {\n        js_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(\n            \"joint_states\", 10, std::bind(&MirobotWriteNode::joint_state_callback, this, std::placeholders::_1));\n\n        //TODO: home position reset\n\n    }\n\nprivate:\n    void joint_state_callback(const sensor_msgs::msg::JointState::SharedPtr msg)\n    {\n        std::string Gcode = \"\";\n        char angle0[10];\n        char angle1[10];\n        char angle2[10];\n        char angle3[10];\n        char angle4[10];\n        char angle5[10];\n\n        sprintf(angle0, \"%.2f\", msg->position[0]*57.296);\n        sprintf(angle1, \"%.2f\", msg->position[1]*57.296);\n        sprintf(angle2, \"%.2f\", msg->position[2]*57.296);\n        sprintf(angle3, \"%.2f\", msg->position[3]*57.296);\n        sprintf(angle4, \"%.2f\", msg->position[4]*57.296);\n        sprintf(angle5, \"%.2f\", msg->position[5]*57.296);\n        Gcode = (std::string)\"M50 G0 X\" + angle0 + \" Y\" + angle1 + \" Z\" + angle2 + \" A\" + angle3 + \"B\" + angle4 + \"C\" + angle5 + \" F3000\" + \"\\r\\n\";\n        \n        RCLCPP_INFO(this->get_logger(), \"%s\", Gcode.c_str());\n\n        _serial.write(Gcode.c_str());\n        result.data = _serial.read(_serial.available());\n    }\n\n    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr js_sub_;\n    std_msgs::msg::String result;\n};\n\nint main(int argc, char** argv)\n{\n    rclcpp::init(argc, argv);\n\n    auto mirobot_gcode_write_node = std::make_shared<MirobotWriteNode>();\n    \n    mirobot_gcode_write_node->declare_parameter(\"port_name\", \"/dev/ttyUSB0\");\n    mirobot_gcode_write_node->declare_parameter(\"baud_rate\", 115200);\n\n    auto port_name = mirobot_gcode_write_node->get_parameter(\"port_name\").as_string();\n    auto baud_rate = mirobot_gcode_write_node->get_parameter(\"baud_rate\").as_int();\n\n\ttry{\n        //TODO: port name into launch param\n\t\t_serial.setPort(port_name);\n\t\t_serial.setBaudrate(baud_rate);\n\n\t\tserial::Timeout to = serial::Timeout::simpleTimeout(1000);\n\t\t\n        _serial.setTimeout(to);\n\t\t_serial.open();\n\t\t_serial.write(\"M50\\r\\n\");\n\t\t\n        RCLCPP_INFO(mirobot_gcode_write_node->get_logger(), \"Port has been open successfully\");\n\t}\n\tcatch (serial::IOException& e){\n        RCLCPP_FATAL(mirobot_gcode_write_node->get_logger(), \"Unable to open port\");\n\t\treturn -1;\n\t}\n\n\tif (_serial.isOpen()){\n        using namespace std::chrono_literals;\n        rclcpp::sleep_for(1s);\n        RCLCPP_INFO(mirobot_gcode_write_node->get_logger(), \"Attach and wait for commands\");\n\t}\n\n    rclcpp::spin(mirobot_gcode_write_node);\n    rclcpp::shutdown();\n    \n    return 0;\n}\n",
    "#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#include <fstream>\n#include <iostream>\n#include \"csvstream.hpp\"\nusing namespace std;\n\nclass Classifier {\n  private:\n  int testing_post;\n  int training_post;     \n  set<string> word_list;   \n  map<pair<string, string>, double> likelihood_predict;\n  map<string, int> label_count;\n  map<string, int> word_count;\n  map<string, map<string, int>> word_label;\n  map<string, int> label_examples;\n  string training_file;\n  string testing_file;\n  bool debug;\n\n  public:\n  //default constructor\n  Classifier() \n  : testing_post(0), training_post(0) {}\n //need overloaded constructor with files passed in and debug mode\n  Classifier(string file_trained, string file_tested, \n  bool mode_debugged)\n   : testing_post(0), training_post(0), \n   training_file(file_trained), \n   testing_file(file_tested), debug(mode_debugged) {}\n\n   // EFFECTS: Return a set of unique whitespace delimited words.x\n  //From specs\n  set<string> unique_words(const string &str) {\n    istringstream source(str);\n    set<string> words;\n    string word;\n    while (source >> word) {\n        words.insert(word);\n    }\n    return words;\n  }\n\n  //Training Section\n  void training( ){\n        string word_bank;\n        csvstream csvin(training_file);\n        map<string, string> row;\n        \n        if(debug){\n            cout << \"training data:\" << \"\\n\";\n        }\n        while (csvin >> row) {\n            ++label_count[row[\"tag\"]];\n            set<string> words = unique_words(row[\"content\"]);\n            for(auto it = words.begin(); it != words.end(); ++it){\n                ++word_count[*it];\n                ++word_label[row[\"tag\"]][*it];\n            }\n\n            if(debug) {\n                cout << \"  label = \" << row[\"tag\"] \n                << \", content = \" << row[\"content\"] << \"\\n\";\n            }\n\n            ++training_post;\n            word_bank = word_bank + \" \" + row[\"content\"];\n        }\n\n        word_list = unique_words(word_bank);\n        cout << \"trained on \" << training_post \n        << \" examples\" << endl;\n        cout << endl;\n        if(debug) {\n         cout << \"vocabulary size = \" << \n         word_list.size() << endl;\n         cout << endl;\n        //execute debugging func\n        debugging();\n        cout << endl;\n        }\n        testing_data();\n    }\n\n  double prior(const string &labeled) {\n      double label_c = label_count[labeled] / \n      static_cast<double>(training_post);\n      return log(label_c);\n  }\n\n  double prediction_likelihood(const string &word, \n  const string &label) {\n    double W_label_C = 0;\n\n    //Use when w does not occur anywhere at all in the training set.\n    if(word_count[word] == 0) { \n        W_label_C = 1.0 / static_cast<double>(training_post);\n    } \n    //Use when w does not occur in posts labeled \n // but C does occur in the training data overall\n    else if(word_label[label][word] == 0) {  \n        W_label_C = static_cast<double>(word_count[word]) /\n         static_cast<double>(training_post);\n    } \n    //if neither the regular formula\n    else {\n      W_label_C = static_cast<double>(word_label[label][word]) / \n    static_cast<double>(label_count[label]);\n    }\n    return log(W_label_C);\n\n  }\n\n  double probability_score(const string &label, \n  set<string> words){\n    double log_probability;\n    for(auto i = words.begin(); i != words.end(); ++i){\n        log_probability += prediction_likelihood(*i, label);\n    }\n    return prior(label) + log_probability;\n  }\n\n  pair<string, double> highest_probability_score(set<string> \n  data){\n    map<string, double> label_score;\n    for(const auto &kv : label_count){\n       label_score[kv.first] = \n       probability_score(kv.first, data);\n    }\n    double max = (*label_score.begin()).second;\n    string best_label = (*label_score.begin()).first;\n    for(const auto &kv : label_score){\n        if(label_score[kv.first] > max){\n            max = label_score[kv.first];\n            best_label = kv.first;\n        }\n    }\n    return {best_label, max};\n  }\n  void debugging(){\n    cout << \"classes:\" << \"\\n\";\n    for (const auto &kv : label_count) {    \n        const auto &labeled = kv.first;\n        const auto &examples = kv.second;\n        cout << \"  \" << labeled << \", \" << examples << \n        \" examples, \" \n        << \"log-prior = \" << prior(labeled) << endl;\n    }\n    cout << \"classifier parameters:\" << endl;  \n    for (const auto &kv : word_label) {\n        const auto &label = kv.first;\n        for(const auto &second_kv : kv.second){\n            const auto &word = second_kv.first;\n            const auto &count = second_kv.second;\n            cout << \"  \" << label << \":\" << word << \n            \", count = \" << count \n            << \", log-likelihood = \" \n            << prediction_likelihood(word, label) << endl;\n        }\n    }\n  }\n\n  //Testing Data\n  void testing_data(){\n    int correct_predictions = 0;\n\n    cout << \"test data:\" << endl;\n    csvstream test(testing_file);\n    map<string, string> row;\n    while(test >>",
    "#include<iostream>\n#include<cstdlib>\nusing namespace std;\n\nvoid intro()\n{\n    cout<<\"\\t\\t\\t\\t\\t**********TRAVEL MANAGEMENT SYSTEM**********\"<<endl;\n    //Additional Code\n}\n \nclass Hotel  //HOTEL GENERALISED CLASS\n{\n    public:\n    string name;\n    string location;\n    int numberRooms;\n    int roomAvailable;\n    \n    public:\n    Hotel(string name = \"HOTEL\" , string location = \"AREA 51\" , int numberRooms = 404 , int roomAvailable = 121)\n    {\n       this->name=name;\n       this->location=location;\n       this->numberRooms=numberRooms;\n       this->roomAvailable=roomAvailable;\n    }\n    //void display();   \n    void mainMenu(); \n    // void rooms(); \n    // void add(); \n    // void edit(); \n    // ~ Hotel() {}\n};\n\nvoid Hotel::mainMenu()\n{\n    system(\"clear\");\n    cout<<\"\\t\\t\\t\\t\\t********** M E N U **********\"<<endl;\n    cout<<\"\\t\\t\\t\\t\\t1. BOOK A ROOM\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t2. CUSTOMER RECORD\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t3. ROOM ALLOTED\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t4. EDIT RECORD\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t5. EXIT\\t\\t\\t\\t\\t\\n\";\n\n}\n\nint main()\n{\n    intro();\n    cin.get();\n    Hotel hotel;\n    hotel.mainMenu();\n    //ex\n\n    return 0;\n}",
    "#include \"Model.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define BUFFER_OFFSET(i) ((char *)NULL + (i))\n\nvoid Model::createFromFile(std::string filename)\n{\n    tinygltf::Model model;\n    tinygltf::TinyGLTF loader;\n    std::string err;\n    std::string warn;\n\n    bool res = loader.LoadASCIIFromFile(&model, &err, &warn, filename);\n    if (!warn.empty())\n    {\n        std::cout << \"WARN: \" << warn << std::endl;\n    }\n\n    if (!err.empty())\n    {\n        std::cout << \"ERR: \" << err << std::endl;\n    }\n\n    if (!res)\n    {\n        std::cout << \"Failed to load model: \" << filename << std::endl;\n    }\n\n    glGenVertexArrays(1, &vertexArrayObjectId);\n    glBindVertexArray(vertexArrayObjectId);\n\n    std::map<int, GLuint> generatedBuffers;\n    for (size_t i = 0; i < model.bufferViews.size(); ++i)\n    {\n        const tinygltf::BufferView &bufferView = model.bufferViews[i];\n        const tinygltf::Buffer &buffer = model.buffers[bufferView.buffer];\n\n        GLuint vbo;\n        glGenBuffers(1, &vbo);\n        generatedBuffers[i] = vbo;\n        glBindBuffer(bufferView.target, vbo);\n        glBufferData(bufferView.target, bufferView.byteLength,\n                     &buffer.data.at(0) + bufferView.byteOffset, GL_STATIC_DRAW);\n    }\n\n    for (const auto &node : model.nodes)\n    {\n        if (node.mesh >= 0)\n        {\n            for (const auto &primitive : model.meshes[node.mesh].primitives)\n            {\n                if (primitive.indices < 0)\n                {\n                    continue;\n                }\n\n                tinygltf::Accessor indexAccessor = model.accessors[primitive.indices];\n\n                Element el;\n                el.mode = primitive.mode;\n                el.count = indexAccessor.count;\n                el.componentType = indexAccessor.componentType;\n                el.bufferOffset = indexAccessor.byteOffset;\n                el.bufferId = generatedBuffers[indexAccessor.bufferView];\n                elementsArray.push_back(el);\n\n                for (auto &attrib : primitive.attributes)\n                {\n                    tinygltf::Accessor accessor = model.accessors[attrib.second];\n\n                    int byteStride = accessor.ByteStride(model.bufferViews[accessor.bufferView]);\n                    glBindBuffer(GL_ARRAY_BUFFER, generatedBuffers[accessor.bufferView]);\n\n                    int size = 1;\n                    if (accessor.type != TINYGLTF_TYPE_SCALAR)\n                    {\n                        size = accessor.type;\n                    }\n\n                    int vaa = -1;\n                    if (attrib.first.compare(\"POSITION\") == 0)\n                        vaa = 0;\n                    if (attrib.first.compare(\"NORMAL\") == 0)\n                        vaa = 1;\n                    if (attrib.first.compare(\"TEXCOORD_0\") == 0)\n                        vaa = 2;\n                    if (vaa > -1)\n                    {\n                        glEnableVertexAttribArray(vaa);\n                        glVertexAttribPointer(vaa, size, accessor.componentType,\n                                              accessor.normalized ? GL_TRUE : GL_FALSE,\n                                              byteStride, BUFFER_OFFSET(accessor.byteOffset));\n                    }\n                }\n            }\n        }\n    }\n\n    glBindVertexArray(0);\n\n    for (auto it = generatedBuffers.cbegin(); it != generatedBuffers.cend();)\n    {\n        tinygltf::BufferView bufferView = model.bufferViews[it->first];\n        if (bufferView.target != GL_ELEMENT_ARRAY_BUFFER)\n        {\n            glDeleteBuffers(1, &generatedBuffers[it->first]);\n            generatedBuffers.erase(it++);\n        }\n        else\n        {\n            ++it;\n        }\n    }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <string.h>\n#include <time.h>\n#include <sys/time.h>\n#include <stdarg.h>\n#include \"log.h\"\n#include <pthread.h>\nusing namespace std;\n\nLog::Log()\n{\n    m_count = 0;\n    m_is_async = false;\n}\n\nLog::~Log()\n{\n    if (m_fp != NULL)\n    {\n        fclose(m_fp);\n    }\n}\n//\u5f02\u6b65\u9700\u8981\u8bbe\u7f6e\u963b\u585e\u961f\u5217\u7684\u957f\u5ea6\uff0c\u540c\u6b65\u4e0d\u9700\u8981\u8bbe\u7f6e\uff0c\u786e\u5b9alog\u6587\u4ef6\u7684\u540d\u79f0\u5462\u4e2a\uff0c\u521b\u5efa\u5e76\u6253\u5f00Log\u6587\u4ef6\nbool Log::init(const char *file_name, int close_log, int log_buf_size, int split_lines, int max_queue_size)\n{\n    //\u5982\u679c\u8bbe\u7f6e\u4e86max_queue_size,\u5219\u8bbe\u7f6e\u4e3a\u5f02\u6b65\n    if (max_queue_size >= 1)\n    {\n        m_is_async = true;\n        m_log_queue = new block_queue<string>(max_queue_size);\n        pthread_t tid;\n        //flush_log_thread\u4e3a\u56de\u8c03\u51fd\u6570,\u8fd9\u91cc\u8868\u793a\u521b\u5efa\u7ebf\u7a0b\u5f02\u6b65\u5199\u65e5\u5fd7\n        pthread_create(&tid, NULL, flush_log_thread, NULL);\n    }\n    \n    m_close_log = close_log;\n    m_log_buf_size = log_buf_size;\n    m_buf = new char[m_log_buf_size];\n    memset(m_buf, '\\0', m_log_buf_size);\n    m_split_lines = split_lines;\n\n    time_t t = time(NULL);\n    struct tm *sys_tm = localtime(&t);\n    struct tm my_tm = *sys_tm;\n\n    //\u4ece\u540e\u5f80\u524d\u627e\u5230\u7b2c\u4e00\u4e2a/\u7684\u4f4d\u7f6e\n    const char *p = strrchr(file_name, '/');\n    char log_full_name[256] = {0};\n\n    //\u76f8\u5f53\u4e8e\u81ea\u5b9a\u4e49\u65e5\u5fd7\u540d\n    //\u82e5\u8f93\u5165\u7684\u6587\u4ef6\u540d\u6ca1\u6709/\uff0c\u5219\u76f4\u63a5\u5c06\u65f6\u95f4+\u6587\u4ef6\u540d\u4f5c\u4e3a\u65e5\u5fd7\u540d\n    if (p == NULL)\n    {\n        snprintf(log_full_name, 255, \"%d_%02d_%02d_%s\", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, file_name);\n    }\n    else\n    {\n        strcpy(log_name, p + 1);\n        strncpy(dir_name, file_name, p - file_name + 1);\n        snprintf(log_full_name, 255, \"%s%d_%02d_%02d_%s\", dir_name, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, log_name);\n    }\n\n    m_today = my_tm.tm_mday;\n    \n    m_fp = fopen(log_full_name, \"a\");\n    if (m_fp == NULL)\n    {\n        return false;\n    }\n\n    return true;\n}\n\nvoid Log::write_log(int level, const char *format, ...) \n{\n    struct timeval now = {0, 0};\n    gettimeofday(&now, NULL);\n\n    time_t t = now.tv_sec;\n    struct tm *sys_tm = localtime(&t);\n    struct tm my_tm = *sys_tm;\n\n    char s[16] = {0};\n    switch (level)\n    {\n    case 0:\n        strcpy(s, \"[debug]:\");\n        break;\n    case 1:\n        strcpy(s, \"[info]:\");\n        break;\n    case 2:\n        strcpy(s, \"[warn]:\");\n        break;\n    case 3:\n        strcpy(s, \"[erro]:\");\n        break;\n    default:\n        strcpy(s, \"[info]:\");\n        break;\n    }\n    //\u5199\u5165\u4e00\u4e2alog\uff0c\u5bf9m_count++, m_split_lines\u6700\u5927\u884c\u6570\n    m_mutex.lock(); //\u907f\u514d\u591a\u7ebf\u7a0b\u7ade\u4e89\uff0c\u5904\u7406\u4e1a\u52a1\u903b\u8f91\u7684\u65f6\u5019\u9700\u8981\u5199\u65e5\u5fd7\n    m_count++;\n\n    //log\u5199\u6ee1\u6216\u8005\u65f6\u95f4\u4e0d\u5339\u914d\n    if (m_today != my_tm.tm_mday || m_count % m_split_lines == 0) //everyday log\n    {\n        \n        char new_log[256] = {0};\n        fflush(m_fp);\n        fclose(m_fp);\n        char tail[16] = {0};\n       \n        snprintf(tail, 16, \"%d_%02d_%02d_\", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday);\n       \n        if (m_today != my_tm.tm_mday)\n        {\n            snprintf(new_log, 255, \"%s%s%s\", dir_name, tail, log_name);\n            m_today = my_tm.tm_mday;\n            m_count = 0;\n        }\n        else\n        {   //\u8fbe\u5230\u4e00\u4e2a\u6587\u4ef6\u8bb0\u5f55\u7684\u6700\u5927\u65e5\u5fd7\u6570\u91cf\n            snprintf(new_log, 255, \"%s%s%s.%lld\", dir_name, tail, log_name, m_count / m_split_lines);\n        }\n        m_fp = fopen(new_log, \"a\");\n    }\n \n    m_mutex.unlock();\n\n    va_list valst;\n    va_start(valst, format);\n\n    string log_str;\n    m_mutex.lock();\n\n    //\u5199\u5165\u7684\u5177\u4f53\u65f6\u95f4\u5185\u5bb9\u683c\u5f0f\n    /*int snprintf(char *str, size_t size, const char *format, ...) \n    \u8bbe\u5c06\u53ef\u53d8\u53c2\u6570(...)\u6309\u7167 format \u683c\u5f0f\u5316\u6210\u5b57\u7b26\u4e32\uff0c\n    \u5e76\u5c06\u5b57\u7b26\u4e32\u590d\u5236\u5230 str \u4e2d\uff0csize \u4e3a\u8981\u5199\u5165\u7684\u5b57\u7b26\u7684\u6700\u5927\u6570\u76ee\uff0c\u8d85\u8fc7 size \u4f1a\u88ab\u622a\u65ad\u3002*/\n    int n = snprintf(m_buf, 48, \"%d-%02d-%02d %02d:%02d:%02d.%06ld %s \",\n                     my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday,\n                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);\n    \n    int m = vsnprintf(m_buf + n, m_log_buf_size - 1, format, valst);\n    m_buf[n + m] = '\\n';\n    m_buf[n + m + 1] = '\\0';\n    log_str = m_buf;\n\n    m_mutex.unlock();\n\n    if (m_is_async && !m_log_queue->full())\n    {\n        m_log_queue->push(log_str);\n    }\n    else\n    {\n        m_mutex.lock();  //\u540c\u6b65\u5199\n        fputs(log_str.c_str(), m_fp);\n        m_mutex.unlock();\n    }\n\n    va_end(valst);\n}\n\nvoid Log::flush(void)\n{\n    m_mutex.lock();\n    //\u5f3a\u5236\u5237\u65b0\u5199\u5165\u6d41\u7f13\u51b2\u533a\n    fflush(m_fp); //\u5237\u65b0I/O\u5e93\u63d0\u4f9b\u7684\u7f13\u51b2\u533a\n    m_mutex.unlock();\n}\n",
    "#define PY_ARRAY_UNIQUE_SYMBOL pbcvt_ARRAY_API\n#include <Eigen/Core>\n#include <opencv2/core.hpp>\n#include <opencv2/core/core.hpp>\n#include <pyboostcvconverter/pyboostcvconverter.hpp>\n#include <sophus/se3.hpp>\n#include <ORB_SLAM3/KeyFrame.h>\n#include <ORB_SLAM3/Converter.h>\n#include <ORB_SLAM3/Tracking.h>\n#include <ORB_SLAM3/MapPoint.h>\n#include <ORB_SLAM3/Thirdparty/Sophus/sophus/se3.hpp>\n#include \"ORBSlamPython.h\"\n\n\nstatic void* init_ar() {\n\n    Py_Initialize();\n\n    import_array();\n    return NULL;\n}\n\ntemplate <class Scalar>\ncv::Mat SE3ToCvMat(const Sophus::SE3<Scalar>& se3) {\n  // get 4x4 homogenous matrix\n  const Eigen::Matrix<Scalar, 4, 4> m = se3.matrix();\n  // convert to cv::Mat\n  cv::Mat cvMat(m.rows(), m.cols(), CV_32F);\n  for (int i = 0; i < m.rows(); ++i) {\n    for (int j = 0; j < m.cols(); ++j) {\n      cvMat.at<float>(i, j) = m(i, j);\n    }\n  }\n  return cvMat;\n}\n\ntemplate <class Scalar, int Rows, int Cols>\ncv::Mat eigenToCvMat(const Eigen::Matrix<Scalar, Rows, Cols>& eigenMat) {\n    cv::Mat cvMat(eigenMat.rows(), eigenMat.cols(), CV_32F);\n    for (int i = 0; i < eigenMat.rows(); ++i) {\n        for (int j = 0; j < eigenMat.cols(); ++j) {\n            cvMat.at<float>(i, j) = eigenMat(i, j);\n        }\n    }\n    return cvMat;\n}\n\n\nBOOST_PYTHON_MODULE(orbslam3)\n{\n    init_ar();\n\n    boost::python::to_python_converter<cv::Mat, pbcvt::matToNDArrayBoostConverter>();\n    pbcvt::matFromNDArrayBoostConverter();\n\n    boost::python::enum_<ORB_SLAM3::Tracking::eTrackingState>(\"TrackingState\")\n        .value(\"SYSTEM_NOT_READY\", ORB_SLAM3::Tracking::eTrackingState::SYSTEM_NOT_READY)\n        .value(\"NO_IMAGES_YET\", ORB_SLAM3::Tracking::eTrackingState::NO_IMAGES_YET)\n        .value(\"NOT_INITIALIZED\", ORB_SLAM3::Tracking::eTrackingState::NOT_INITIALIZED)\n        .value(\"OK\", ORB_SLAM3::Tracking::eTrackingState::OK)\n        .value(\"LOST\", ORB_SLAM3::Tracking::eTrackingState::LOST);\n    \n    boost::python::enum_<ORB_SLAM3::System::eSensor>(\"Sensor\")\n        .value(\"MONOCULAR\", ORB_SLAM3::System::eSensor::MONOCULAR)\n        .value(\"STEREO\", ORB_SLAM3::System::eSensor::STEREO)\n        .value(\"RGBD\", ORB_SLAM3::System::eSensor::RGBD);\n\n    boost::python::class_<ORBSlamPython, boost::noncopyable>(\"System\", boost::python::init<const char*, const char*, boost::python::optional<ORB_SLAM3::System::eSensor>>())\n        .def(boost::python::init<std::string, std::string, boost::python::optional<ORB_SLAM3::System::eSensor>>())\n        .def(\"initialize\", &ORBSlamPython::initialize)\n        .def(\"load_and_process_mono\", &ORBSlamPython::loadAndProcessMono)\n        .def(\"process_image_mono\", &ORBSlamPython::processMono)\n        .def(\"load_and_process_stereo\", &ORBSlamPython::loadAndProcessStereo)\n        .def(\"process_image_stereo\", &ORBSlamPython::processStereo)\n        .def(\"load_and_process_rgbd\", &ORBSlamPython::loadAndProcessRGBD)\n        .def(\"process_image_rgbd\", &ORBSlamPython::processRGBD)\n        .def(\"shutdown\", &ORBSlamPython::shutdown)\n        .def(\"is_running\", &ORBSlamPython::isRunning)\n        .def(\"reset\", &ORBSlamPython::reset)\n        .def(\"set_mode\", &ORBSlamPython::setMode)\n        .def(\"set_use_viewer\", &ORBSlamPython::setUseViewer)\n        .def(\"get_keyframe_points\", &ORBSlamPython::getKeyframePoints)\n        .def(\"get_trajectory_points\", &ORBSlamPython::getTrajectoryPoints)\n        .def(\"get_tracked_mappoints\", &ORBSlamPython::getTrackedMappoints)\n        .def(\"get_tracking_state\", &ORBSlamPython::getTrackingState)\n        .def(\"get_num_features\", &ORBSlamPython::getNumFeatures)\n        .def(\"get_num_matched_features\", &ORBSlamPython::getNumMatches)\n        .def(\"save_settings\", &ORBSlamPython::saveSettings)\n        .def(\"load_settings\", &ORBSlamPython::loadSettings)\n        .def(\"save_settings_file\", &ORBSlamPython::saveSettingsFile)\n        .staticmethod(\"save_settings_file\")\n        .def(\"load_settings_file\", &ORBSlamPython::loadSettingsFile)\n        .staticmethod(\"load_settings_file\");\n}\n\nORBSlamPython::ORBSlamPython(std::string vocabFile, std::string settingsFile, ORB_SLAM3::System::eSensor sensorMode)\n    : vocabluaryFile(vocabFile),\n    settingsFile(settingsFile),\n    sensorMode(sensorMode),\n    system(nullptr),\n    bUseViewer(false),\n    bUseRGB(true)\n{\n    \n}\n\nORBSlamPython::ORBSlamPython(const char* vocabFile, const char* settingsFile, ORB_SLAM3::System::eSensor sensorMode)\n    : vocabluaryFile(vocabFile),\n    settingsFile(settingsFile),\n    sensorMode(sensorMode),\n    system(nullptr),\n    bUseViewer(false),\n    bUseRGB(true)\n{\n\n}\n\nORBSlamPython::~ORBSlamPython()\n{\n}\n\nbool ORBSlamPython::initialize()\n{\n    system = std::make_shared<ORB_SLAM3::System>(vocabluaryFile, settingsFile, sensorMode, bUseViewer);\n    return true;\n}\n\nbool ORBSlamPython::isRunning()\n{\n    return system != nullptr;\n}\n\nvoid ORBSlamPython::reset()\n{\n    if (system)\n    {\n        system->Reset();\n    }\n}\n\nbool ORBSlamPython::loadAndProcessMono(std::string imageFile, double timestamp)\n{\n    if (!system)\n    {\n        return false;\n ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#include\"BNTree.h\"\nBSTNode* taoBSTNode(ItemType x) {\n\tBSTNode* p = new BSTNode;\n\tif (p == NULL)\n\t\treturn NULL; // Tr\u1ea3 v\u1ec1 NULL n\u1ebfu kh\u00f4ng th\u1ec3 t\u1ea1o BSTNode m\u1edbi\n\tp->data = x;\n\tp->Left = NULL;\n\tp->Right = NULL;\n\treturn p;\n}\n\n// Xu\u1ea5t n\u1ed9i dung c\u1ee7a BSTNode\nvoid showBSTNode(BSTNode* p) {\n\tprintf(\"%4d\", p->data);\u0111\n}\n\n\n// Kh\u1edfi t\u1ea1o danh s\u00e1ch\nvoid initBSTree(BSTree& BST) {\n\tBST.Root = NULL;\n}\n\n// Ki\u1ec3m tra ds r\u1ed7ng hay kh\u00f4ng\nint isEmpty(BSTree BST) {\n\tif (BST.Root == NULL)\n\t\treturn 1;// Tr\u1ea3 v\u1ec1 1 n\u1ebfu danh s\u00e1ch r\u1ed7ng, ng\u01b0\u1ee3c l\u1ea1i tr\u1ea3 v\u1ec1 0\n\telse\n\t\treturn 0;\n}\n\n// Duy\u1ec7t danh s\u00e1ch v\u00e0 in ra m\u00e0n h\u00ecnh\nvoid showNLR(BSTNode* Root) {\n\tif (!Root) {\n\t\treturn;\n\t}\n\tshowBSTNode(Root);\n\tshowNLR(Root->Left);\n\tshowNLR(Root->Right);\n}\n\n// Th\u00eam ph\u1ea7n t\u1eed v\u00e0o \u0111\u1ea7u danh s\u00e1ch\nint insertRoot(BSTNode*& Root, BSTNode* p) {\n\tif (!p)\n\t\treturn 0;\t//kh\u00f4ng t\u1ed3n t\u1ea1i p\n\tif (!Root) {\n\t\t//TH1 c\u00e2y r\u1ed7ng\n\t\tRoot = p;\n\t\treturn 1;\n\t}\n\telse if (Root->data == p->data) {\n\t\treturn 0;\t//b\u1ecb tr\u00f9ng gi\u00e1 tr\u1ecb\n\t}\n\telse if (Root->data > p->data) {\n\t\tinsertRoot(Root->Left, p);\t//th\u00eam tr\u00e1i\n\t}\n\telse\n\t{\n\t\tinsertRoot(Root->Right, p);\t//th\u00eam ph\u1ea3i\n\t}\n\treturn 1;\n}\n\n\n// T\u1ea1o danh s\u00e1ch t\u1ef1 \u0111\u1ed9ng v\u1edbi s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed n nh\u1eadp t\u1eeb b\u00e0n ph\u00edm\nvoid taodanhsachtudong(BSTree& BST) {\n\tint n;\n\tdo {\n\t\tprintf(\"Ban hay cho biet so phan tu: \");\n\t\tscanf_s(\"%d\", &n);\n\t} while (n <= 0);\n\tinitBSTree(BST);\n\tsrand(time(NULL));\n\tfor (int i = 0; i < n; i++) {\n\t\tItemType x = rand() % 99 + 1; // T\u1ea1o s\u1ed1 nguy\u00ean ng\u1eabu nhi\u00ean t\u1eeb 0 \u0111\u1ebfn 100\n\t\tBSTNode* p = taoBSTNode(x);\n\t\tinsertRoot(BST.Root, p);\n\t}\n}\n\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool solve(vector< vector<int> > v , int n,  int m , string a , string b , string c) {\n\t\n\t n = b.length();\n\t m = a.length();\n int z = c.length();\t\n\t\n\t//cout<<n<<\" \"<<m<<\" \"<<z<<\"\\n\\n\\n\";\n\t\t\n\tif(n+m != z) return false;\n\t\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= m; j++) {\n\t\t\tv[i][j] = false;\n\t\t\tif(i == 0 && j == 0) v[i][j] = true;\n\t\t\telse if(i == 0 && a[j-1] == c[j-1]) v[i][j] = v[i][j-1];\n\t\t\t\n\t\t\telse if(j == 0 && b[i-1] == c[i-1]) v[i][j] = v[i-1][j];\n\t\t\telse if(a[j-1] == c[i+j-1] && v[i][j-1] == true) v[i][j] = true;\n\t\t\telse if(b[i-1] == c[i+j-1] && v[i-1][j] == true) v[i][j] = true; \n\t\t\t\n\t//\t\tcout<<v[i][j]<<\"\\t\";\n\t\t}\n\t//\tcout<<\"\\n\\n\";\n\t}\n\treturn v[n][m];\n}\n\nint main()\n{\n\t\n\tint t, n , m;\n\t\n\tcin>>t;\n\t\n\twhile(t--){\n\t\tvector< vector<int> > v(10000 , vector<int>(10000));\n\t\tstring a ,b , c;\n\t\t\n\t\tcin>>a>>b>>c;\n\t//\tgetline(cin, a);\n\t//\tgetline(cin , a);\n\t//\tgetline(cin , b);\n\t//\tgetline(cin , c);\n\t\t(solve(v , n , m , a , b , c)) ? cout<<\"True\\n\" : cout<<\"False\\n\";\n\t}\n\treturn 0;\n}\n",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main() {\n    // \u0110\u1ecdc \u1ea3nh \u0111\u1ea7u v\u00e0o\n    Mat image = imread(\"input_image.jpg\", IMREAD_GRAYSCALE); //Ch\u00e8n \u0111\u01b0\u1eddng d\u1eabn c\u1ee7a \u1ea3nh c\u1ea7n Input v\u00e0o input_image.jpg\n    \n    if (image.empty()) {\n        cout << \"Kh\u00f4ng th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c \u1ea3nh!\\n\";\n        return -1;\n    }\n    \n    // T\u00ednh histogram\n    int histSize = 256; // S\u1ed1 l\u01b0\u1ee3ng bin c\u1ee7a histogram\n    float range[] = {0, 256}; // Ph\u1ea1m vi gi\u00e1 tr\u1ecb pixel\n    const float* histRange = {range};\n    Mat hist;\n    calcHist(&image, 1, 0, Mat(), hist, 1, &histSize, &histRange, true, false);\n    \n    // T\u00ednh histogram t\u00edch l\u0169y\n    Mat cumulative_hist = hist.clone();\n    for (int i = 1; i < histSize; ++i) {\n        cumulative_hist.at<float>(i) += cumulative_hist.at<float>(i - 1);\n    }\n    \n    // Chu\u1ea9n h\u00f3a histogram t\u00edch l\u0169y\n    cumulative_hist /= cumulative_hist.at<float>(histSize - 1);\n    cumulative_hist *= 255;\n    \n    // \u00c1nh x\u1ea1 l\u1ea1i c\u00e1c gi\u00e1 tr\u1ecb pixel ban \u0111\u1ea7u b\u1eb1ng histogram c\u00e2n b\u1eb1ng\n    Mat equalized_image = image.clone();\n    for (int y = 0; y < image.rows; ++y) {\n        for (int x = 0; x < image.cols; ++x) {\n            equalized_image.at<uchar>(y, x) = saturate_cast<uchar>(cumulative_hist.at<float>(image.at<uchar>(y, x)));\n        }\n    }\n    \n    // Hi\u1ec3n th\u1ecb \u1ea3nh g\u1ed1c v\u00e0 \u1ea3nh \u0111\u00e3 \u0111\u01b0\u1ee3c c\u00e2n b\u1eb1ng histogram\n    namedWindow(\"Original Image\", WINDOW_AUTOSIZE);\n    imshow(\"Original Image\", image);\n    \n    namedWindow(\"Equalized Image\", WINDOW_AUTOSIZE);\n    imshow(\"Equalized Image\", equalized_image);\n    \n    waitKey(0);\n    destroyAllWindows();\n    \n    return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//============================================================================\n// Name        : TP1-2024.cpp\n// Author      : Cristina Werenitzky\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Programa de prueba de Lista Enlazada\n//============================================================================\n\n#include<stdio.h>\n#include<stdlib.h>\n\n#include \"Lista.h\"  //Include del archivo de cabecera Lista.h - Tipificacion de lista y funciones \n\nitem posicionK(Lista *l, int k); // Funcion externa - Punto 3) - FALTA IMPLEMENTAR\nint contarPares(Lista *L);\nint main(){\n\n\n// -- PROGRAMA DE PRUEBA DE LISTA CON FUNCIONES QUE RETORNAN LA LISTA MODIFICADA\n\n    printf(\"\\nINICIO DEL PROGRAMA DE PRUEBA DE LISTA CON FUNCIONES QUE RETORNAN LA LISTA MODIFICADA\\n\");\n\n\tprintf(\"\\n1.Creo una lista, la inicializo en lista vacia y muestro la lista vacia por pantalla: \");\n\tLista L;\n\tL = crearLista();\n    mostrar(L);\n\n    printf(\"\\n2.Pruebo la funcion esListaVacia. Mensaje esperado 'Lista Vacia': \");\n    if(esListaVacia(L))\n\t\tprintf(\"Lista Vacia\\n\");\n\telse\n\t    printf(\"Lista NO Vacia\\n\");\n\n    printf(\"\\n3.Escribo la cantidad de elementos de una lista vacia (= 0): %d \\n\", longitud(L));\n\n    printf(\"\\n4.Escribo el valor del primer elemento de una lista vacia (= -99999): %d \\n\", primerElemento(L));\n\n    printf(\"\\n5.Inserto el valor 500 en la lista y muestro la lista por pantalla: \");\n\tL = insertar(L,500);\n    mostrar(L);\n\n\tprintf(\"\\n6.Pruebo la funcion esListaVacia. Mensaje esperado 'Lista NO Vacia': \");\n    if(esListaVacia(L))\n\t\tprintf(\"Lista Vacia\\n\");\n\telse\n\t\tprintf(\"Lista NO Vacia\\n\");\n\n\tprintf(\"\\n7.Borro un elemento de la lista y muestro por pantala. Se espera lista vacia: \");\n\tL = borrar(L);\n\tmostrar(L);\n\n\tprintf(\"\\n8.Inserto 5 elementos (10,17,22,45,74) en la lista y muestro la lista por pantalla: \");\n\tL = insertar(L,10);\n\tL = insertar(L,17);\n\tL = insertar(L,22);\n\tL = insertar(L,45);\n\tL = insertar(L,74);\n    mostrar(L);\n\n    printf(\"\\n9.Escribo la cantidad de elementos de la lista (= 5): %d \\n\", longitud(L));\n\n    printf(\"\\n10.Escribo el valor del primer elemento de la lista vacia (= 74): %d \\n\", primerElemento(L));\n\n\tprintf(\"\\n11.Borro un elemento de la lista y muestro la lista por pantalla: \");\n\tL = borrar(L);\n\tmostrar(L);\n\n    printf(\"\\n12.Busco si pertenece el valor 100 en la lista. Mensaje esperado 'NO Pertenece': \");\n    if(pertenece(L, 100))\n\t\tprintf(\"Pertenece\\n\");\n\telse\n\t    printf(\"NO Pertenece\\n\");\n\n    printf(\"\\n13.Busco si pertenece el valor 22 en la lista. Mensaje esperado: 'Pertenece': \");\n\n    if(pertenece(L, 22))\n    \t\tprintf(\"Pertenece\\n\");\n    \telse\n    \t    printf(\"NO Pertenece\\n\");\n\n    printf(\"\\n14.Inserto el valor 88  en la posicion 3 y muestro la lista por pantalla: \");\n    L = insertarK(L, 88, 3);\n    mostrar(L);\n\n    printf(\"\\n15.Inserto el valor 99  en la posicion 50 y muestro la lista por pantalla: \");\n    L = insertarK(L, 99, 50);\n    mostrar(L);\n\n    printf(\"\\n16.Inserto el valor 0  en la posicion -10 y muestro la lista por pantalla: \");\n    L = insertarK(L, 0, -10);\n    mostrar(L);\n\n    printf(\"\\n17.Inserto el valor 1  en la posicion 1 y muestro la lista por pantalla: \");\n    L = insertarK(L, 1, 1);\n    mostrar(L);\n\n    printf(\"\\n18.Busco el elemento que se encuentra en la posic\ufffdn 4 de la lista (= 88): %d\\n\", posicionK(&L, 4));\n\n    printf(\"\\n19.Muestro la lista luego de invocar a la funci\ufffdn externa posicionK: \");\n    mostrar(L);\n\n    printf(\"\\n20.Busco el elemento que se encuentra en la posic\ufffdn 50 de la lista (= -99999): %d\\n\", posicionK(&L, 50));\n\n    printf(\"\\n21.Muestro la lista luego de invocar a la funci\ufffdn externa posicionK: \");\n    mostrar(L);\n\n    printf(\"\\n22.Libero la memoria reservada en forma din\ufffdmica\\n\");\n    while(!esListaVacia(L))\n    \tL = borrar(L);\n\n    printf(\"\\nFIN DEL PROGRAMA DE PRUEBA DE LISTA CON FUNCIONES QUE RETORNA LA LISTA QUE RETORNAN LA LISTA MODIFICADA\\n\");\n// -----------------------------------------------------------------------------------------------------------------------\n\n    return 0;\n}\n\nitem posicionK(Lista *l, int k) {\n    // Guardo la direcci\u00f3n de la cabecera para no perderla luego de la funci\u00f3n\n    Lista cabeceraAux = *l;\n    // Inicializo el dato en -99999 por si no se encuentra el elemento en la posici\u00f3n buscada\n    int dato = -99999;\n    // Obtengo la longitud de la lista\n    int len = longitud(*l);\n\n    // Si la posici\u00f3n buscada 'k' supera la longitud de la lista o es menor a cero, retorno -99999 \n    if (k > len || k < 0) return dato;\n    // Recorro la lista\n    for (int i=0 ; i<len ; i++)\n    {\n        // Si (i+1) es igual a K, quiere decir que llegu\u00e9 a la posici\u00f3n deseada,\n        // entonces retorno el elemento de la cabecera donde estoy\n        if ((i+1) == k) return primerElemento(*l);\n        // Si aun no encontr\u00e9 el elemento, muevo la cabecera al elemento siguiente\n        // para poder acceder a su dato con la funci\u00f3n primerElemento()\n        *l = borrar(*l);\n    }\n    // Llevo la cabecera de nuevo a su posici\u00f3n, ya q",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"nive_store\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ejemplo_lab\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <QModbusDataUnit>\n#include <QModbusReply>\n#include <QDebug>\n\n\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    m_client = new QModbusTcpClient(this);\n    m_timerClient = new QTimer(this);\n\n    connect(m_client, &QModbusClient::stateChanged, this, &MainWindow::onStateChanged);//\u8fde\u63a5\u72b6\u6001\u53d1\u751f\u6539\u53d8\u65f6\u5904\u7406\u51fd\u6570\n    // \u5efa\u7acb\u8fde\u63a5\n    connect2modbus(MODBUS_SERVER_IP, MODBUS_SERVER_PORT);\n    // \u542f\u52a8\u5b9a\u65f6\u5668\n    m_client->setTimeout(200); // \u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u4e3a200\u6beb\u79d2\n    connect(m_timerClient, &QTimer::timeout, this, &MainWindow::onTimeOut);\n    m_timerClient->start(500); // \u8bbe\u7f6e\u8ba1\u65f6\u5668\u95f4\u9694\u4e3a500\u6beb\u79d2\n}\n\nMainWindow::~MainWindow()\n{\n    if (m_client) {\n        m_client->disconnectDevice();\n    }\n    delete ui;\n}\n/********************************************\n 2  * \u51fd\u6570\u540d\u79f0\uff1aConnect_to_modbus(QString IP_address,int Port)\n 3  * \u529f\u80fd\uff1a\u8fde\u63a5\u5230modbus\u8bbe\u5907\n 4  * \u5de5\u4f5c\u65b9\u5f0f\uff1a\n 5  * \u53c2\u6570\uff1a\n 6         \u53c2\u65701\uff1amodbus\u8bbe\u5907\u7684IP\u5730\u5740               QString \u7c7b\u578b\n 7         \u53c2\u65702\uff1amodbus\u8bbe\u5907\u7684\u7aef\u53e3\u53f7(\u4e00\u822c\u7528502)     int \u7c7b\u578b\n 8  * \u8fd4\u56de\u503c\uff1a\u6210\u529f\u8fd4\u56detrue\uff0c\u5931\u8d25\u8fd4\u56defasle\u3002\n 9  * \u5907\u6ce8\uff1a\n10  * \u4fee\u6539\u8bb0\u5f55\n11 *********************************************/\nbool MainWindow::connect2modbus(QString ipAddress, int port)\n{\n    if(!m_client){\n        return false;\n    }\n\n    if (m_client->state() != QModbusDevice::ConnectedState) {\n\n        //\u914d\u7f6emodbus tcp\u7684\u8fde\u63a5\u53c2\u6570 IP + Port   modbus\u534f\u8bae\u7684\u7aef\u53e3\u53f7\u4e3a502\n        m_client->setConnectionParameter(QModbusDevice::NetworkAddressParameter, ipAddress);\n        m_client->setConnectionParameter(QModbusDevice::NetworkPortParameter, port);\n\n        if (!m_client->connectDevice()) {\n            qDebug()<< \"\u8fde\u63a5modbus\u8bbe\u5907\u5931\u8d25\";\n            return false;\n        }\n        else {\n            qDebug()<< \"\u6210\u529f\u8fde\u63a5\u5230modbus\u8bbe\u5907\";\n            return true;\n        }\n    }\n    else {\n        m_client->disconnectDevice();\n        return false;\n    }\n}\n\n/********************************************\n2  * \u51fd\u6570\u540d\u79f0\uff1aonStateChanged()\n3  * \u529f\u80fd\uff1a\u76d1\u542cTCP\u8fde\u63a5\u7684\u72b6\u6001\uff0c\u82e5\u72b6\u6001\u53d1\u751f\u6539\u53d8\uff0c\u53d1\u51fa\u5bf9\u5e94\u7684\u4fe1\u53f7\n4  * \u5de5\u4f5c\u65b9\u5f0f\uff1a\n5  * \u53c2\u6570\uff1a\u65e0\u53c2\u6570\n6  * \u8fd4\u56de\u503c\uff1a\u65e0\u8fd4\u56de\u503c\n7  * \u5907\u6ce8\uff1a\n8  * \u4fee\u6539\u8bb0\u5f55:\n9 *********************************************/\nvoid MainWindow::onStateChanged()\n{\n    //\u8fde\u63a5\u72b6\u6001\u6539\u53d8\u65f6\u7684\u69fd\u51fd\u6570\n    if(m_client->state() == QModbusDevice::ConnectedState)\n    {\n        emit sigStateON();\n    }\n    else {\n        emit sigStateOFF();\n    }\n}\n\nvoid MainWindow::onReadingFinished()\n{\n    QModbusReply *reply = qobject_cast<QModbusReply*>(sender());\n    if (!reply) return;\n\n    if (reply->error() == QModbusDevice::NoError) {\n        const QModbusDataUnit modbusDataUnit = reply->result();\n        int registerStatus = modbusDataUnit.value(0);\n\n        if(registerStatus == 1){\n            qDebug()<<\"\u5207\u6362\u76f8\u673a\";\n            emit sigSwitchCamera();\n        }\n        if(registerStatus == 2){\n            emit sigMeasure();\n            qDebug()<<\"\u6d4b\u91cf\";\n        }\n\n    } else {\n        qDebug() << \"Read error: \" << reply->errorString();\n    }\n\n    reply->deleteLater();\n\n}\n\nvoid MainWindow::resetHoldingRegisters()\n{\n    // \u4ece\u5730\u5740REGISTER_ADDRESS\u5f00\u59cb\u5199\u51651\u4e2a\u5bc4\u5b58\u5668\n    QModbusDataUnit writeUnit(QModbusDataUnit::HoldingRegisters, REGISTER_ADDRESS, 1);\n    writeUnit.setValue(REGISTER_ADDRESS, 0); // \u8bbe\u7f6e\u5730\u5740REGISTER_ADDRESS\u7684\u503c\u4e3a0\n    QModbusReply *reply_init = m_client->sendWriteRequest(writeUnit, 1); // 1\u662f\u8bbe\u5907\u7684Modbus\u5730\u5740\n    if (reply_init) {\n        if (!reply_init->isFinished()) {\n            connect(reply_init, &QModbusReply::finished, this, &MainWindow::onWritingFinished);\n        } else {\n            // \u8bf7\u6c42\u5df2\u7ecf\u5b8c\u6210\uff0c\u5904\u7406\u7ed3\u679c\n            delete reply_init;\n        }\n    } else {\n        qDebug() << \"Write error\";\n    }\n\n\n}\n\nvoid MainWindow::onTimeOut()\n{\n    QModbusDataUnit readUnit(QModbusDataUnit::HoldingRegisters, REGISTER_ADDRESS, 1); // \u4ece\u5730\u57400\u5f00\u59cb\u8bfb\u53d610\u4e2a\u5bc4\u5b58\u5668\n    QModbusReply *reply = m_client->sendReadRequest(readUnit, 1); // 1\u662f\u8bbe\u5907\u7684Modbus\u5730\u5740\n    if (reply != nullptr) {\n        if (!reply->isFinished()) {\n            connect(reply, &QModbusReply::finished, this, &MainWindow::onReadingFinished);\n        } else {\n            delete reply;\n        }\n    } else {\n        qDebug() << \"Read error\";\n    }\n\n    // \u5f53\u56de\u590d\u5b8c\u6210\u65f6\uff0c\u5220\u9664reply\n    connect(reply, &QModbusReply::finished, reply, &QModbusReply::deleteLater);\n    // \u628a\u5bc4\u5b58\u5668\u7684\u503c\u91cd\u65b0\u8d4b\u503c\u4e3a0\n    resetHoldingRegisters();\n\n\n}\n\n\nvoid MainWindow::onWritingFinished()\n{\n    QModbusReply *reply = qobject_cast<QModbusReply*>(sender());\n    if (!reply) return;\n\n    if (reply->error() == QModbusDevice::NoError) {\n\n        // \u8fd9\u91cc\u53ef\u4ee5\u5b9e\u73b0\u76f8\u5e94\u7684\u5199\u5165\u5bc4\u5b58\u5668\u540e\u9700\u8981\u6267\u884c\u7684\u52a8\u4f5c\n//        qDebug() << \"Write successful\";\n    } else {\n        qDebug() << \"Write error: \" << reply->errorString();\n    }\n\n    reply->deleteLater();\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<stdio.h>\n#include<stdlib.h>\n#include<GL/glut.h>\ntypedef GLfloat point[3];\npoint v[] = { { -0.5, 0.3, -0.5 }, { -0.5, -0.5, -0.5 }, { 0.5, -0.5, -0.5 }, { 0.5, 0.3, -0.5 }, { -0.5, 0.3, 0.5 }, { -0.5, -0.5, 0.5 }, { 0.5, -0.5, 0.5 }, { 0.5, 0.3, 0.5 } };\npoint z[] = { { -0.5, -0.3, 0.3 }, { -0.5, -0.5, 0.3 }, { -0.3, -0.5, 0.3 }, { -0.3, -0.3, 0.3 }, { -0.5, -0.3, -0.3 }, { -0.5, -0.5, -0.3 }, { -0.3, -0.5, -0.3 }, { -0.3, -0.3, -0.3 } };\npoint h[] = { { 0, 0.6, 0.0 }, { -0.5, 0.3, -0.5 }, { 0.5, 0.3, -0.5 }, { -0.5, 0.3, 0.5 }, { 0.5, 0.3, 0.5 } };\npoint f[] = { { 0.0, 0.35, 0.0 }, { 0.0, 0.25, 0.0 }, { 0.025, 0.25, -0.025 }, { -0.025, 0.25, -0.025 }, { -0.025, 0.25, 0.025 }, { 0.025, 0.25, 0.025 } };\npoint fb[] = { { 0.025, 0.25, -0.025 }, { 0.025, 0.25, 0.025 }, { 0.2, 0.25, 0.05 }, { 0.2, 0.25, -0.05 }, { -0.025, 0.25, -0.025 }, { -0.025, 0.25, 0.025 }, { -0.2, 0.25, 0.05 }, { -0.2, 0.25, -0.05 }, { 0.025, 0.25, -0.025 }, { -0.025, 0.25, -0.025 }, { -0.05, 0.25, -0.2 }, { 0.05, 0.25, -0.2 }, { -0.025, 0.25, 0.025 }, { 0.025, 0.25, 0.025 }, { 0.05, 0.25, 0.2 }, { -0.05, 0.25, 0.2 } };\npoint sft[] = { { -0.5, -0.3, 0.3 }, { -0.3, -0.3, 0.3 }, { -0.3, -0.3, 0.25 }, { -0.5, -0.3, 0.25 }, { -0.5, -0.25, 0.3 }, { -0.3, -0.25, 0.3 }, { -0.3, -0.25, 0.25 }, { -0.5, -0.25, 0.25 } };\npoint srt[] = { { -0.5, -0.3, -0.3 }, { -0.3, -0.3, -0.3 }, { -0.3, -0.3, -0.25 }, { -0.5, -0.3, -0.25 }, { -0.5, -0.25, -0.3 }, { -0.3, -0.25, -0.3 }, { -0.3, -0.25, -0.25 }, { -0.5, -0.25, -0.25 } };\npoint sbk[] = { { -0.5, -0.3, 0.3 }, { -0.5, -0.2, 0.3 }, { -0.45, -0.2, 0.3 }, { -0.45, -0.3, 0.3 }, { -0.5, -0.3, -0.3 }, { -0.5, -0.2, -0.3 }, { -0.45, -0.2, -0.3 }, { -0.45, -0.3, -0.3 } };\npoint t[] = { { 0.4, -0.1, -0.2 }, { 0.4, 0.1, -0.2 }, { 0.4, 0.1, 0.2 }, { 0.4, -0.1, 0.2 } };\npoint ts[] = { { 0.4, 0.05, -0.05 }, { 0.4, 0.0, -0.05 }, { 0.4, 0.0, 0.05 }, { 0.4, 0.05, 0.05 }, { 0.5, 0.0, -0.05 }, { 0.5, -0.05, -0.05 }, { 0.5, -0.05, 0.05 }, { 0.5, 0.0, 0.05 } };;\npoint hfrt[] = { { -0.5, 0.3, 0.5 }, { 0.5, 0.3, 0.5 }, { 0.5, 0.25, 0.65 }, { -0.5, 0.25, 0.65 } };\n\nvoid sofa1();\nvoid house(point, point, point, point, point, point, point, point);\nvoid htop(point, point, point, point, point);\nvoid fan(point, point, point, point, point, point);\nvoid fblade(point, point, point, point, point, point, point, point, point, point, point, point, point, point, point, point);\nvoid grass();\nvoid tv(point, point, point, point);\nvoid tvs(point, point, point, point, point, point, point, point);\nvoid compound();\nvoid rainwater();\nvoid sump();\nvoid table();\nvoid teapot();\nvoid tree();\nvoid window();\nvoid housefront(point, point, point, point);\n\nint lightflag = 0;\nint housepolygon = 1;\nint orthoflag = 0;\nfloat sofa_d = 0.0;\nfloat sofa_w = 0.0;\nfloat sofa_a = 0.0;\nfloat sofa_s = 0.0;\nint mouseflag = 0;\nfloat fanspeed = 1.0;\nint back = 0;\nint flag = 0;\nint translate_sofa_flag = 0;\nfloat dy_c = 0.0;\nfloat dy_s = 1.0;\nGLfloat angle = 0;\nGLfloat theta[] = { 0.0, 0.0, 0.0 };\nGLint axis = 1;\nGLdouble viewer[] = { 0.0, 0.0, 2.0 };\n\nvoid mouse(int btn, int state, int x, int y)\n{\n\tif (mouseflag)\n\t{\n\t\tif (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN)axis = 0;\n\t\tif (btn == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)axis = 1;\n\t\tif (btn == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)axis = 2;\n\t\ttheta[axis] += 2.0;\n\t\tif (theta[axis] > 360.0)\n\t\t\ttheta[axis] -= 360.0;\n\t}\n\tglutPostRedisplay();\n}\n\nvoid spin()\n{\n\tangle = angle + fanspeed;\n\tif (angle >= 360)\n\t{\n\t\tangle = 0;\n\t}\n\tglutPostRedisplay();\n}\n\nvoid sofa1()\n{\n\tglColor3f(0.96, 0.64, 0.38);\n\tglPushMatrix();\n\tglTranslated(-0.4 + sofa_s, -0.425, 0 + sofa_d);\t\t//bottom\n\tglScaled(2, 1.5, 6);\n\tglutSolidCube(0.1);\n\tglPopMatrix();\n\n\tglColor3f(0.93, 0.84, 0.72);\n\tglPushMatrix();\n\tglTranslated(-0.4 + sofa_s, -0.3125, -0.25 + sofa_d);\t\t//back\n\tglScaled(2, 0.75, 1);\n\tglutSolidCube(0.1);\n\tglPopMatrix();\n\n\tglColor3f(0.93, 0.84, 0.72);\n\tglPushMatrix();\n\tglTranslated(-0.4 + sofa_s, -0.3125, 0.25 + sofa_d);\t\t//front\n\tglScaled(2, 0.75, 1);\n\tglutSolidCube(0.1);\n\tglPopMatrix();\n\n\tglColor3f(0.87, 0.72, 0.53);\n\tglPushMatrix();\n\tglTranslated(-0.475 + sofa_s, -0.275, 0 + sofa_d);\t\t\t//rest\n\tglScaled(0.5, 1.5, 4);\n\tglutSolidCube(0.1);\n\tglPopMatrix();\n}\nvoid myreshape(int w, int h)\n{\n\tglViewport(0, 0, w, h);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tif (w <= h)\n\t{\n\t\tif (orthoflag)\n\t\t\tglOrtho(-1.0, 1.0, -1.0*((GLfloat)h / (GLfloat)w), 1.0*((GLfloat)h / (GLfloat)w), -20.0, 20.0);\n\t\telse\n\t\t\tglFrustum(-1.0, 1.0, -1.0*(GLfloat)h / (GLfloat)w, 1.0*(GLfloat)h / (GLfloat)w, 1.0, 10.0);\n\t}\n\telse\n\t{\n\t\tif (orthoflag)\n\t\t\tglOrtho(-1.0*((GLfloat)w / (GLfloat)h), 1.0*((GLfloat)w / (GLfloat)h), -1.0, 1.0, -20.0, 20.0);\n\t\telse\n\t\t\tglFrustum(-1.0*(GLfloat)w / (GLfloat)h, 1.0*(GLfloat)w / (GLfloat)h, -1.0, 1.0, 1.0, 10.0);\n\t}\n\tglMatrixMode(GL_MODELVIEW);\n\tglutPostRedisplay();\n}\n\nvoid display()\n{\n\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tGLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };\n\tGLfloat mat_diffuse[] = { 0.5, 0.5, 0.5, 1.0 };\n\t",
    "#include <iostream>\n\nusing namespace std;\n\n// this function receives a character corresponding to the answer entered by the user in main() and makes sure it is\n// either 'y' or 'n'. If the answer is incorrect, the function keeps asking for the right answer until it is provided and\n// then returns it to main() along with the number of attempts taken to enter the correct answer.\nbool checkanswer(char& answer, int& attempts)\n{\n\n    cin >> answer;\n\n    while (answer != 'y' && answer != 'Y' && answer != 'n' && answer != 'N')\n    {\n        cout << \"Invalid input. Please enter y or n: \";\n        cin >> answer;\n        attempts++;\n    }\n\n\n    return true; // Return true if input is valid\n}\n\n\nint main()\n{\n// declare variable(s) to be used\n\n    char answer;\n    int attempts = 1;\n\n// ask the user if he would you like to continue\n\n    cout << \"Would you like to continue?\";\n\n// prompt the user to enter the answer\n\n    cout << \"\\nPlease enter y or n as an answer: \";    \n    \n// get the answer from the keyboard and store it in corresponding variable\n// determine which answer was entered by the user\n// must call the function to ensure the correct answer (y or n) is entered\n// display \"Yes\" or \"No\" according to the answer provided by the user\n\n     if (checkanswer(answer, attempts))\n    {\n        if (answer == 'y' || answer == 'Y')\n        {\n            cout << \"Yes\";\n        }\n        else\n        {\n            cout << \"No\";\n        }\n    }\n\n// display number of attempts\n\n    cout << \"\\nNumber of attempts: \" << attempts << endl;\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"facerecognition_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <cctype>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass User\r\n{\r\nprotected:\r\n    string username, email, password;\r\n\r\npublic:\r\n    User() : username(\"\"), email(\"\"), password(\"\") {}\r\n    void setUserName(string username)\r\n    {\r\n        this->username = username;\r\n    }\r\n    void setEmail(string email)\r\n    {\r\n        this->email = email;\r\n    }\r\n    void setPassword(string password)\r\n    {\r\n        this->password = password;\r\n    }\r\n    void caesarEncrypt()\r\n    {\r\n        string encryptedText;\r\n        int textLength = static_cast<int>(password.length());\r\n\r\n        for (int i = 0; i < textLength; ++i)\r\n        {\r\n            int shift = 3;\r\n            char c = password[i];\r\n            if (isalpha(c))\r\n            {\r\n                char base = isupper(c) ? 'A' : 'a';\r\n                encryptedText += static_cast<char>(((c - base + shift) % 26) + base);\r\n            }\r\n            else\r\n            {\r\n                encryptedText += c;\r\n            }\r\n        }\r\n\r\n        password = encryptedText;\r\n    }\r\n\r\n    string getEncryptedPassword() const\r\n    {\r\n        return password;\r\n    }\r\n    string getUsername()\r\n    {\r\n        return username;\r\n    }\r\n    string getEmail()\r\n    {\r\n        return email;\r\n    }\r\n};\r\n\r\nclass Post\r\n{\r\n    string postId;\r\n    int likes = 0;\r\n    int views = 0;\r\n    string content;\r\n    string *comments;\r\n\r\n    int commentsnum = 0;\r\n\r\npublic:\r\n    Post()\r\n    {\r\n        comments = new string[100];\r\n    }\r\n    void setId(string postId)\r\n    {\r\n        this->postId = postId;\r\n    }\r\n    void addLikes()\r\n    {\r\n        likes++;\r\n    }\r\n    void addViews()\r\n    {\r\n        views++;\r\n    }\r\n    int getLikes()\r\n    {\r\n        return likes;\r\n    }\r\n    int getViews()\r\n    {\r\n        return views;\r\n    }\r\n    int getCommentsNum()\r\n    {\r\n        return commentsnum;\r\n    }\r\n    void addComments(string comment)\r\n    {\r\n        comments[commentsnum] = comment;\r\n        commentsnum++;\r\n    }\r\n    void setContent(string content)\r\n    {\r\n        this->content = content;\r\n    }\r\n    void display()\r\n    {\r\n        cout << \"Likes: \" << likes << endl;\r\n        cout << \"Comments: \" << commentsnum << endl;\r\n\r\n        for (int i = 0; i < commentsnum; i++)\r\n        {\r\n            cout << comments[i] << endl;\r\n        }\r\n    }\r\n    string getId()\r\n    {\r\n        return postId;\r\n    }\r\n    string getContent()\r\n    {\r\n        return content;\r\n    }\r\n};\r\n\r\nint postCount = 0;\r\nclass Business;\r\nclass Regular : public User\r\n{\r\n    static Post *feed;\r\n    static const int MAX_FEED_SIZE = 10;\r\n    friend class Business;\r\n\r\npublic:\r\n    static int countfeed;\r\n\r\n    Regular() : User()\r\n    {\r\n        feed = new Post[MAX_FEED_SIZE];\r\n    }\r\n    void addPosts()\r\n    {\r\n         countfeed++;\r\n        if (countfeed > 10)\r\n        {\r\n            cout << \"Server Crashhh:(\" << endl;\r\n            return;\r\n        }    \r\n        postCount++;\r\n\r\n        if (postCount > 5)\r\n        {\r\n            cout << \"You are Regular User you can add only 5 posts and you have reached your limit\" << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \"Describe your Post\" << endl;\r\n            cout << \"content: \";\r\n            string content;\r\n            getline(cin, content);\r\n            feed[postCount-1].setContent(content);\r\n            feed[postCount-1].setId(username);\r\n\r\n    \r\n        }\r\n    }\r\n    void display()\r\n    {\r\n        for (int i = 0; i < postCount; i++)\r\n        {\r\n            cout << \"Posted by: \" << feed[i].getId() << \"    content: \" << feed[i].getContent() << endl;\r\n            feed[i].display();\r\n        }\r\n    }\r\n    void forYou()\r\n    {\r\n        for (int i = 0; i < postCount; i++)\r\n        {\r\n            cout << \"Posted by: \" << feed[i].getId() << \"    content: \" << feed[i].getContent() << endl;\r\n            feed[i].display();\r\n            char choice;\r\n            cout << \"Do you want to like this post? (y/n)/(Y/N): \";\r\n            cin >> choice;\r\n            cin.ignore();\r\n            if (choice == 'y' || choice == 'Y')\r\n            {\r\n                feed[i].addLikes();\r\n            }\r\n            cout << \"Do you want to comment on this post? (y/n), (Y/N): \";\r\n            cin >> choice;\r\n            cin.ignore();\r\n            if (choice == 'y' || choice == 'Y')\r\n            {\r\n                cout << \"Enter the comment: \";\r\n                string comm;\r\n                getline(cin, comm);\r\n                feed[i].addComments(comm);\r\n            }\r\n            cout << endl\r\n                 << endl;\r\n        }\r\n    }\r\n};\r\nPost *Regular::feed;\r\nclass Business : public User\r\n{\r\npublic:\r\n    void promote()\r\n    {\r\n        int count = 0;\r\n        if (count > 10)\r\n        {\r\n            cout << \"You have reached your limit :(\" << endl;\r\n            return;\r\n        }\r\n        char choice;\r\n        for (int i = 0; i < postCount; i++)\r\n        {\r\n            Regular::feed[i].display();\r\n            cout << \"Do You want to promote this post?(y/n), (Y/N): \";\r\n            ci",
    "/****************************************************************************\n** Meta object code from reading C++ file 'NetGame.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.4.1)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"C:/chess/Chess/NetGame.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'NetGame.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.4.1. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nstruct qt_meta_stringdata_NetGame_t {\n    QByteArrayData data[4];\n    char stringdata[42];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_NetGame_t, stringdata) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_NetGame_t qt_meta_stringdata_NetGame = {\n    {\nQT_MOC_LITERAL(0, 0, 7), // \"NetGame\"\nQT_MOC_LITERAL(1, 8, 17), // \"slotNewConnection\"\nQT_MOC_LITERAL(2, 26, 0), // \"\"\nQT_MOC_LITERAL(3, 27, 14) // \"slotDataArrive\"\n\n    },\n    \"NetGame\\0slotNewConnection\\0\\0slotDataArrive\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_NetGame[] = {\n\n // content:\n       7,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       2,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags\n       1,    0,   24,    2, 0x0a /* Public */,\n       3,    0,   25,    2, 0x0a /* Public */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid NetGame::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        NetGame *_t = static_cast<NetGame *>(_o);\n        switch (_id) {\n        case 0: _t->slotNewConnection(); break;\n        case 1: _t->slotDataArrive(); break;\n        default: ;\n        }\n    }\n    Q_UNUSED(_a);\n}\n\nconst QMetaObject NetGame::staticMetaObject = {\n    { &Board::staticMetaObject, qt_meta_stringdata_NetGame.data,\n      qt_meta_data_NetGame,  qt_static_metacall, Q_NULLPTR, Q_NULLPTR}\n};\n\n\nconst QMetaObject *NetGame::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *NetGame::qt_metacast(const char *_clname)\n{\n    if (!_clname) return Q_NULLPTR;\n    if (!strcmp(_clname, qt_meta_stringdata_NetGame.stringdata))\n        return static_cast<void*>(const_cast< NetGame*>(this));\n    return Board::qt_metacast(_clname);\n}\n\nint NetGame::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = Board::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 2)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 2;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 2)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 2;\n    }\n    return _id;\n}\nQT_END_MOC_NAMESPACE\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include \"Stack.h\"\n#define MaxLength 5\nvoid prnMenu(){\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<\"* 1. \uc0bd\uc785    2. \uc0ad\uc81c    3. \ucd9c\ub825   4. \uc885\ub8cc *\"<<endl;\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<endl;\n\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uba54\ub274\ub97c \uace8\ub77c\uc8fc\uc138\uc694: \";\n}\n\nint main(){\n\t    int mode, selectNumber, tmpItem;\n\t\tLinkedList<int> *p;\n\t\tbool flag = false;\n\n\t\tcout<<\"\uc790\ub8cc\uad6c\uc870 \uc120\ud0dd(1: Stack, Other: Linked List): \";\n\t\tcin>>mode;\n\t\t\t\t\t\t    \n\t\tif(mode == 1)\n\t\t\tp = new Stack<int>();    // \uc815\uc218\ub97c \uc800\uc7a5\ud558\ub294 \uc2a4\ud0dd\n\t\t\t\n\t\telse\n\t\t\tp = new LinkedList<int>();\n\n\n\t\tdo{\n\t\t\tprnMenu();\n\t\t\tcin>>selectNumber;\n\t\t\t\n\t\t\tswitch(selectNumber){ \n\t\t\t\tcase 1:\n\t\t\t\t\tif(p->GetSize() == MaxLength){\n\t\t\t\t\t\tcout << \"\ub9ac\uc2a4\ud2b8 \ucd5c\ub300 \uae38\uc774\uc5d0 \ub3c4\ub2ec\ud588\uc2b5\ub2c8\ub2e4. \ucd94\uac00 \uc2e4\ud328\" << endl;\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694: \";\n\t\t\t\t\tcin>>tmpItem;    p->Insert(tmpItem);\n\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0bd\uc785\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 2:\n\t\t\t\t\tif(p->Delete(tmpItem)==true)\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0ad\uc81c\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t\t\n\t\t\t\t\telse cout<<\"\ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc0ad\uc81c \uc2e4\ud328\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"\ud06c\uae30: \"<<p->GetSize()<<endl;\n\t\t\t\t\tp->Print();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tflag = true;     break;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tcout<<\"\uc798\ubabb \uc785\ub825\ud558\uc168\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) break;\n\t\t\t\n\t\t} while(1);\n\t\t\n\t\treturn 0;\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int TOTAL_SEATS = 80;\nconst int ROW_SIZE = 7;\nconst int LAST_ROW_SIZE = 3;\n\n// Function to display the seats\nvoid displaySeats(const vector<bool> &seats)\n{\n    cout << \"Seat Availability: \\n\";\n    for (int i = 0; i < TOTAL_SEATS; ++i)\n    {\n        if (seats[i])\n        {\n            cout << \"X \";\n        }\n        else\n        {\n            cout << i + 1 << \" \";\n        }\n        if ((i + 1) % ROW_SIZE == 0)\n        {\n            cout << endl;\n        }\n    }\n}\n\n// Function to book seats\nvoid bookSeats(vector<bool> &seats, int numSeats)\n{\n    int booked = 0;\n    for (int i = 0; i < TOTAL_SEATS; ++i)\n    {\n        if (!seats[i])\n        {\n            int j = i;\n            int count = 0;\n            while (j < TOTAL_SEATS && !seats[j] && count < numSeats)\n            {\n                ++j;\n                ++count;\n            }\n            if (count == numSeats)\n            {\n                for (int k = i; k < j; ++k)\n                {\n                    seats[k] = true;\n                    ++booked;\n                }\n                cout << \"Booked seats: \";\n                for (int k = i; k < j; ++k)\n                {\n                    cout << k + 1 << \" \";\n                }\n                cout << endl;\n                break;\n            }\n            else\n            {\n                i = j;\n            }\n        }\n    }\n    if (booked < numSeats)\n    {\n        cout << \"Sorry, required number of seats not available.\\n\";\n    }\n}\n\nint main()\n{\n    vector<bool> seats(TOTAL_SEATS, false);\n    int numSeats;\n    char choice;\n    do\n    {\n        cout << \"Enter the number of seats to book: \";\n        cin >> numSeats;\n        bookSeats(seats, numSeats);\n        displaySeats(seats);\n        cout << \"Do you want to book more seats? (y/n): \";\n        cin >> choice;\n    } while (choice == 'y' || choice == 'Y');\n    return 0;\n}\n",
    "\ufeff// ConsoleApplication1.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\n//\n\n#include <iostream>\n#include <string>\n#include <fstream>\n#include \"list.h\"\n\nusing namespace std;\n\nint main()\n{\n    List list;\n    int stop = 0;\n    int n{};\n    \n    \n    \n    while (stop != 1) {\n\n        int key;\n        cout << \"1-create and write, 2-load, 3-add, 4-delete, 5-edit,6-search,7-stop\" << endl;\n        cin >> key;\n        if (key == 1) {\n            while (true) {\n                cout << \"n= \";\n                if (!(cin >> n)) {\n                    cout << \"Error: n must be an integer. Please try again.\" << endl;\n                    cin.clear();\n                    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                }\n                else\n                    break;\n            }\n            MiTech* arr = new MiTech[n];\n            list.create(arr, n);\n            list.write(arr, n);\n            delete[]arr;\n\n        }\n        if (key == 2) {\n\n            list.load(n);\n\n        }\n        if (key==3) {\n            cout << \"n= \";\n            int n;\n            cin >> n;\n            MiTech* arr1 = new MiTech[n];\n            if (n < 1)\n                return 0;\n            for (int i = 0; i < n; i++) {\n                cout << \"type= \";\n                string type;\n                cin >> type;\n                arr1[i].settype(type);\n                cout << \"country= \";\n                string country;\n                cin >> country;\n                arr1[i].setcountry(country);\n\n                int amount;\n                while (true) {\n                    cout << \"amount= \";\n                    if (!(cin >> amount)) {\n                        cout << \"Error: Amount must be an integer. Please try again.\" << endl;\n                        cin.clear();\n                        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                    }\n                    else {\n                        arr1[i].setamount(amount);\n                        break;\n                    }\n                }\n            }\n            list.add(arr1, n);\n            cout << \"added arr:\" << endl;\n            for (int i = 0; i < n; i++)\n                cout << arr1[i].type() << \" \" << arr1[i].country() << \" \" << arr1[i].amount() << endl;\n            delete[]arr1;\n\n        }\n        if (key==4) {\n            cout << \"enter id: \";\n            int id;\n            cin >> id;\n            if (id > n)\n                return 0;\n            list.remove(id);\n            \n        }\n        if (key == 5) {\n            cout << \"enter id: \";\n            int id;\n            cin >> id;\n            if (id > n)\n                return 0;\n            list.edit(id);\n            \n        }\n        if (key == 6) {\n            cout << \"what do you need to search\" << endl;\n            cout << \"1-type, 2-country, 3-amount\" << endl;\n            int k;\n            cin >> k;\n\n            list.search(k);\n        }\n        if (key == 7)\n            stop = 1;\n    }\n    return 0;\n}",
    "#include <cmath>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stdlib.h>\n#include <time.h>\n#include <limits>\n#include <random>\n#include <boost/numeric/ublas/matrix.hpp>\n#include <fstream>\n#include <stdint.h>\n\nclass NeuralNetwork {\n  /* A simple neural network. The code is written with the help of the \n     book \"Neural networks and deep learning\" by Michael Nielsen\n     ================================================================\n     neuralnetworksanddeeplearning.com\n     ================================================================\n     n contains the number of layers (input layer, output \n     layer and all hidden layers), vector layers contains the number \n     of nodes in each layer. Outputs vector contains vectors of outputs of \n     each layer. Vector deltas contains the errors for each layer. \n     Vector zs contains the weighted inputs for each layer.  Vector dCdb \n     contains the gradient of the cost function wrt biases. Vector dCdw\n     contains matrices of derivatives of the cost function wrt elements \n     of the weight matrices. eta is the learning rate.\n     Method feedforward returns an output of the network for a given input.\n     Method sigma contains the activation function (sigmoid in this case). \n     Its derivative is in method sigma_prime. Method dCda returns the vector\n     corresponding to the gradient of the cost function wrt output layer \n     activations. compute_errors computes the errors using the backpropagation\n     method. Method compute_gradient computes the derivatives dCdb and dCdw. \n     Method sgd_step calculates the new iteration of the weights and biases\n     using the stochastic gradient method. The input minibatch of the samples \n     is used. The output of the network after learning can be checked by \n     using method control. \n     The length of vectors layers and outputs is n. The length of vectors\n     biases, weights, deltas, zs, dCdb, dCdw is n-1. */\nprivate:\n  unsigned int n;\n  std::vector<std::size_t> layers;\n  std::vector<std::vector<double> > outputs;\n  std::vector<std::vector<double> > biases;\n  std::vector<boost::numeric::ublas::matrix<double> > weights;\n  std::vector<std::vector<double> > deltas;\n  std::vector<std::vector<double> > zs;\n  std::vector<std::vector<double> > dCdb;\n  std::vector<boost::numeric::ublas::matrix<double> > dCdw;\n  double eta;\npublic:\n  NeuralNetwork();\n  NeuralNetwork(std::size_t);\n  NeuralNetwork(std::size_t, std::vector<std::size_t>);\n  std::vector<double> feedforward(std::vector<double>);\n  double sigma(double);\n  double sigma_prime(double);\n  std::vector<double> dCda(std::vector<double>, std::vector<double>);\n  void compute_errors(std::vector<double>,std::vector<double>);\n  void compute_gradient();\n  void sgd_step(std::vector<std::vector<double> >,std::vector<std::vector<double> >);\n  std::vector<double> control(std::vector<double>);\n};\n\nNeuralNetwork::NeuralNetwork() {\n  n = 3;\n  eta = 4;\n  for(std::size_t i=0; i<n; ++i)\n    layers.push_back(n);\n}\n\nNeuralNetwork::NeuralNetwork(std::size_t _n_, std::vector<std::size_t> _layers_) {\n  if(_layers_.size()==_n_) {\n    n = _n_;\n    layers = _layers_;\n    eta = 4;\n    /* Allocate the output vector of the input \n       layer (aka input of the network). */\n    std::vector<double> a;\n    for(std::size_t j=0; j<_layers_[0]; ++j) {\n      a.push_back(0.0);\n    }\n    outputs.push_back(a);\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    /* Notice how the loop starts with i=1. */\n    for(std::size_t i=1; i<_n_; ++i) {\n      /* Creates a n1 x n2 matrix filled with normally distributed\n\t numbers of mean 0 and standard deviation 1/sqrt(m) where m\n\t is the number of inputs to the particular neuron (in this \n\t case all neurons are connected to all neurons in the next\n\t layer and therefore this number is const for all the \n\t neurons in the current layer). */\n      std::normal_distribution<double> dis(0, 1.0/sqrt(_layers_[i-1]));\n      std::size_t n1 = _layers_[i-1], n2 = _layers_[i];\n      boost::numeric::ublas::matrix<double> M(n1,n2);\n      boost::numeric::ublas::matrix<double> dM(n1,n2);\n      for(std::size_t j=0; j<n1; ++j) {\n\tfor(std::size_t k=0; k<n2; ++k) {\n\t  M(j,k) = dis(gen);\n\t  dM(j,k) = 0.0;\n\t}\n      }\n      weights.push_back(M);\n      dCdw.push_back(dM);\n      std::vector<double> v;\n      std::vector<double> w;\n      for(std::size_t j=0; j<_layers_[i]; ++j) {\n\tv.push_back(dis(gen));\n\tw.push_back(0.0);\n      }\n      biases.push_back(v);\n      dCdb.push_back(w);\n      outputs.push_back(w);\n      deltas.push_back(w);\n      zs.push_back(w);\n    }\n  }\n  else\n    throw \"Neural network was not initialized correctly!\";\n}\n\nstd::vector<double> NeuralNetwork::feedforward(std::vector<double> input) {\n  std::vector<double> a_prev;\n  std::vector<double> a;\n  a_prev = input;\n  for(std::size_t i=1; i<layers.size(); ++i) {\n    a = outputs[i];\n    for(std::size_t j=0; j<layers[i]; ++j) {\n      double sum = 0.0;\n      for(s",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXLEN = 255;\n\nstruct sproduct\n{\n    char name[MAXLEN];\n    int cost;\n    int quantity;\n    int date;\n};\n\nsproduct arr[MAXLEN];\n\nint product_index = 0;\n\nint menu();\nvoid readFromFile(const char* fileName);\nvoid saveToFile(const char* fileName);\nvoid addNew();\nvoid del();\nvoid sortToFile();\nvoid changeToFile();\nvoid textToScreen(int product_index);\nvoid textForAddandSort(int index);\n\nint main()\n{\n    while (true)\n    {\n        switch (menu())\n        {\n        case 1:\n            readFromFile(\"file.dat\");\n            break;\n        case 2:\n            saveToFile(\"file.dat\");\n            break;\n        case 3:\n            addNew();\n            break;\n        case 4:\n            del();\n            break;\n        case 5:\n            sortToFile();\n            break;\n        case 6:\n            changeToFile();\n            break;\n        case 7:\n            return 0;\n        default:\n            cout << \"Wrong choice\" << endl;\n        }\n    }\n}\n\nint menu()\n{\n    cout << \"\\n\";\n    int ans;\n    cout << \"make choice\\n\" << \"1 - reading file\\n\" << \"2 - write file\\n\" << \"3 - adding an entry\\n\" << \"4 - deleting an entry\\n\" << \"5 - sort file\\n\"\n    << \"6 - change file\\n\" << \"7 - leave from program\\n\";\n    cin >> ans;\n    return ans;\n}\nvoid readFromFile(const char* fileName)\n{\n    ifstream fin;\n    fin.open(fileName, ios::binary);\n    if (!fin)\n    {\n        cout << \"File not found\";\n    }\n    else\n    {\n        sproduct product;\n        product_index = 0;\n        while (true)\n        {\n           fin.read((char*)&product, sizeof(product));\n           if (fin.eof())\n                break;\n            arr[product_index] = product;\n            product_index++;\n        }\n        fin.close();\n        cout << \"Data read from file\\n\";\n        textToScreen(product_index);\n    }\n}\n\nvoid saveToFile(const char* fileName)\n{\n    ofstream fout;\n    fout.open(fileName, ios::binary);\n    if (!fout)\n    {\n        cout << \"File not found\";\n    }\n    else\n    {\n        fout.write((char*)arr, sizeof(sproduct) * product_index);\n        fout.close();\n        cout << \"Data saved\\n\";\n    }\n}\n\nvoid textForAddandSort(int index)\n{\n    cout << \"Nazva productu:  \";\n    cin >> arr[index].name, MAXLEN;\n    cout << \"Vvedit vartist:  \";\n    cin >> arr[index].cost;\n    cout << \"Vvedite kilkist:  \";\n    cin >> arr[index].quantity;\n    cout << \"Vvedite datu:  \";\n    cin >> arr[index].date;\n}\n\nvoid addNew()\n{\n    cout << \"Adding a new entry\\n\\n\";\n    cout << \"Writing down the number \" << product_index + 1 << \"\\n\";\n    textForAddandSort(product_index);\n    product_index++;\n    cout << \"\\n\";\n    textToScreen(product_index);\n}\n\nvoid del()\n{\n    int d;\n    cout << \"Select the entry number to be deleted \";\n    cin >> d;\n    for (int i = d - 1; i < product_index; i++)\n    {\n        arr[i] = arr[i + 1];\n    }\n    product_index--;\n\n    cout << \"\\n\";\n    textToScreen(product_index);\n}\n\nvoid sortToFile()\n{\n    char changeChar;\n    int changeInt;\n    for (int j = 0; j < product_index; j++)\n    {\n        for (int i = 0; i < product_index - 1; i++)\n        {\n            if (arr[i].cost > arr[i + 1].cost)\n            {\n                swap(arr[i], arr[i + 1]);\n            }\n        }\n    }\n\n    textToScreen(product_index);\n}\n\nvoid changeToFile()\n{\n    int c;\n    cout << \"Select the entry number to be change \";\n    cin >> c;\n\n    cout << \"Change entry\\n\\n\";\n    cout << \"Writing down the number \" << c << \"\\n\";\n    cout << \"Nazva productu:  \";\n    textForAddandSort(c - 1);\n\n    cout << \"\\n\";\n    textToScreen(product_index);\n}\n\nvoid textToScreen(int product_index)\n{\n    for (int i = 0; i < product_index; i++)\n    {\n        cout << i + 1 << \"\\t\" << arr[i].name << \"\\t\" << arr[i].cost << \"\\t\" << arr[i].quantity << \"\\t\" << arr[i].date << endl;\n    }\n    cout << \"\\n\";\n}\n",
    "#include <iostream>\n#include <sys/stat.h>\n#include <QString>\n#include <stdio.h>\n#include <errno.h>\n#include <QDebug>\n\nusing namespace std;\n\nint main()\n{\n    string path;\n    cout << \"\u0412\u043a\u0430\u0436\u0456\u0442\u044c \u0448\u043b\u044f\u0445, \u0434\u0435 \u0431\u0443\u0434\u0435 \u0441\u0442\u0432\u043e\u0440\u0435\u043d\u043e Pipe \u0444\u0430\u0439\u043b: \";\n    cin >> path;\n\n    QString qPath = QString::fromStdString(path);\n\n    qDebug() << \"\u0428\u043b\u044f\u0445 \u0434\u043e \u0442\u0440\u0443\u0431\u0438\" << qPath;\n\n    int result = mkfifo(qPrintable(qPath), 0666);\n\n    if (result == -1)\n    {\n        qDebug() << \"\u041f\u043e\u043c\u0438\u043b\u043a\u0430 \u0441\u0442\u0432\u043e\u0440\u0435\u043d\u043d\u044f \u0442\u0440\u0443\u0431\u0438! \u041a\u043e\u0434:\" << errno;\n        qDebug() << \"================\";\n        switch (errno)\n        {\n        case EACCES:\n            qDebug() << \"\u041e\u0434\u0438\u043d \u0456\u0437 \u043a\u0430\u0442\u0430\u043b\u043e\u0433\u0456\u0432 \u0443 pathname \u043d\u0435 \u043d\u0430\u0434\u0430\u0432 \u0434\u043e\u0437\u0432\u043e\u043b\u0443 \u043d\u0430 \u043f\u043e\u0448\u0443\u043a (\u0432\u0438\u043a\u043e\u043d\u0430\u043d\u043d\u044f)!\";\n            break;\n        case EDQUOT:\n            qDebug() << \"\u041a\u0432\u043e\u0442\u0430 \u043a\u043e\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430 \u0434\u0438\u0441\u043a\u043e\u0432\u0438\u0445 \u0431\u043b\u043e\u043a\u0456\u0432 \u0430\u0431\u043e inodes \u0443 \u0444\u0430\u0439\u043b\u043e\u0432\u0456\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u0456 \u0432\u0438\u0447\u0435\u0440\u043f\u0430\u043d\u0430!\";\n            break;\n        case EEXIST:\n            qDebug() << \"\u0428\u043b\u044f\u0445 \u0432\u0436\u0435 \u0456\u0441\u043d\u0443\u0454. \u0426\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0454 \u0432\u0438\u043f\u0430\u0434\u043e\u043a, \u043a\u043e\u043b\u0438 pathname \u0454 \u0441\u0438\u043c\u0432\u043e\u043b\u0456\u0447\u043d\u0438\u043c \u043f\u043e\u0441\u0438\u043b\u0430\u043d\u043d\u044f\u043c, \u0432\u0438\u0441\u044f\u0447\u0438\u043c \u0447\u0438 \u043d\u0456!\";\n            break;\n        case EROFS:\n            qDebug() << \"Pathname \u0432\u0456\u0434\u043d\u043e\u0441\u0438\u0442\u044c\u0441\u044f \u0434\u043e \u0444\u0430\u0439\u043b\u043e\u0432\u043e\u0457 \u0441\u0438\u0441\u0442\u0435\u043c\u0438, \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0457 \u043b\u0438\u0448\u0435 \u0434\u043b\u044f \u0447\u0438\u0442\u0430\u043d\u043d\u044f.\";\n            break;\n        }\n\n        return 1;\n    }\n\n    FILE* file = fopen(qPrintable(qPath), \"r\");\n    if(file == nullptr) return 1;\n    \n    char* buff = new char[512];\n\n    fscanf(file, \"%s\", buff);\n\n    qDebug(\"%s\", buff);\n\n    fclose(file);\n    delete[] buff;\n\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Copyright 2012, 2019 Austin Robot Technology, Piyush Khandelwal, Joshua Whitley\n// All rights reserved.\n//\n// Software License Agreement (BSD License 2.0)\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n// * Redistributions of source code must retain the above copyright\n//   notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n//   copyright notice, this list of conditions and the following\n//   disclaimer in the documentation and/or other materials provided\n//   with the distribution.\n// * Neither the name of {copyright_holder} nor the names of its\n//   contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n#include <yaml-cpp/yaml.h>\n\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <string>\n#include <utility>\n\n#include <rclcpp/rclcpp.hpp>\n\n#include \"velodyne_pointcloud/calibration.hpp\"\n\n#ifdef HAVE_NEW_YAMLCPP\n\nnamespace YAML\n{\n\n// The >> operator disappeared in yaml-cpp 0.5, so this function is\n// added to provide support for code written under the yaml-cpp 0.3 API.\ntemplate<typename T>\nvoid operator>>(const YAML::Node & node, T & i)\n{\n  i = node.as<T>();\n}\n\n}  // namespace YAML\n\n#endif  // HAVE_NEW_YAMLCPP\n\nnamespace velodyne_pointcloud\n{\n\nconstexpr char NUM_LASERS[] = \"num_lasers\";\nconstexpr char DISTANCE_RESOLUTION[] = \"distance_resolution\";\nconstexpr char LASERS[] = \"lasers\";\nconstexpr char LASER_ID[] = \"laser_id\";\nconstexpr char ROT_CORRECTION[] = \"rot_correction\";\nconstexpr char VERT_CORRECTION[] = \"vert_correction\";\nconstexpr char DIST_CORRECTION[] = \"dist_correction\";\nconstexpr char TWO_PT_CORRECTION_AVAILABLE[] =\n  \"two_pt_correction_available\";\nconstexpr char DIST_CORRECTION_X[] = \"dist_correction_x\";\nconstexpr char DIST_CORRECTION_Y[] = \"dist_correction_y\";\nconstexpr char VERT_OFFSET_CORRECTION[] = \"vert_offset_correction\";\nconstexpr char HORIZ_OFFSET_CORRECTION[] = \"horiz_offset_correction\";\nconstexpr char MAX_INTENSITY[] = \"max_intensity\";\nconstexpr char MIN_INTENSITY[] = \"min_intensity\";\nconstexpr char FOCAL_DISTANCE[] = \"focal_distance\";\nconstexpr char FOCAL_SLOPE[] = \"focal_slope\";\n\n/** Read calibration for a single laser. */\nvoid operator>>(const YAML::Node & node, std::pair<int, LaserCorrection> & correction)\n{\n  node[LASER_ID] >> correction.first;\n  node[ROT_CORRECTION] >> correction.second.rot_correction;\n  node[VERT_CORRECTION] >> correction.second.vert_correction;\n  node[DIST_CORRECTION] >> correction.second.dist_correction;\n\n#ifdef HAVE_NEW_YAMLCPP\n\n  if (node[TWO_PT_CORRECTION_AVAILABLE]) {\n    node[TWO_PT_CORRECTION_AVAILABLE] >>\n    correction.second.two_pt_correction_available;\n  } else {\n#else\n\n  if (const YAML::Node * pName = node.FindValue(TWO_PT_CORRECTION_AVAILABLE)) {\n    *pName >> correction.second.two_pt_correction_available;\n  } else {\n#endif\n    correction.second.two_pt_correction_available = false;\n  }\n\n  node[DIST_CORRECTION_X] >> correction.second.dist_correction_x;\n  node[DIST_CORRECTION_Y] >> correction.second.dist_correction_y;\n  node[VERT_OFFSET_CORRECTION] >> correction.second.vert_offset_correction;\n\n#ifdef HAVE_NEW_YAMLCPP\n\n  if (node[HORIZ_OFFSET_CORRECTION]) {\n    node[HORIZ_OFFSET_CORRECTION] >>\n    correction.second.horiz_offset_correction;\n  } else {\n#else\n\n  if (const YAML::Node * pName = node.FindValue(HORIZ_OFFSET_CORRECTION)) {\n    *pName >> correction.second.horiz_offset_correction;\n  } else {\n#endif\n    correction.second.horiz_offset_correction = 0;\n  }\n\n  float max_intensity_float = 255.0;\n\n#ifdef HAVE_NEW_YAMLCPP\n\n  if (node[MAX_INTENSITY]) {\n    node[MAX_INTENSITY] >> max_intensity_float;\n  }\n\n#else\n\n  if (const YAML::Node * pName = node.FindValue(MAX_INTENSITY)) {\n    *pName >> max_intensity_float;\n  }\n\n#endif\n\n  correction.second.max_intensity = ::floorf(max_intensity_float);\n\n  float min_intensity_float = 0.0;\n\n#ifdef HAVE_NEW_YAMLCPP\n\n  if (node[MIN_INTENSITY]) {\n    node[MIN_INTENSITY] >> min_intensity_float;\n  }\n\n#else\n\n  if (const YAML::Node * pName = node",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n *   SPDX-FileCopyrightText: 2021 Aleix Pol Gonzalez <aleixpol@blue-systems.com>\n *\n *   SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\n#include <QCommandLineParser>\n#include <QGuiApplication>\n#include <QPainter>\n#include <QRasterWindow>\n#include <QTimer>\n#include <QWindow>\n\n#include <QMetaEnum>\n\n#include <LayerShellQt/window.h>\n#include <iostream>\n#include <qguiapplication.h>\n#include <qnamespace.h>\n#include <qstringliteral.h>\n\nusing namespace LayerShellQt;\n\nQStringList enumsToStringList(QMetaEnum metaEnum)\n{\n    QStringList ret;\n    ret.reserve(metaEnum.keyCount());\n    for (int i = 0; i < metaEnum.keyCount(); ++i) {\n        ret.append(metaEnum.key(i));\n    }\n    return ret;\n}\n\ntemplate<typename T>\nT stringToEnum(QMetaEnum metaEnum, const QString &str)\n{\n    T ret = {};\n    const auto splitted = str.split(QLatin1Char('|'), Qt::SkipEmptyParts);\n    for (const auto &value : splitted) {\n        ret |= T(metaEnum.keyToValue(qPrintable(value)));\n    }\n    return ret;\n}\n\nclass BasicWindow : public QRasterWindow\n{\n    void paintEvent(QPaintEvent *) override\n    {\n        QPainter p(this);\n        p.fillRect(QRect(0, 0, width(), height()), Qt::red);\n    }\n};\n\nint main(int argc, char **argv)\n{\n    QGuiApplication app(argc, argv);\n\n    const auto layerMetaEnum = QMetaEnum::fromType<Window::Layer>();\n    const auto anchorMetaEnum = QMetaEnum::fromType<Window::Anchor>();\n    const QRect primaryDisplaySize = QGuiApplication::primaryScreen()->geometry();\n    \n    QCommandLineParser parser;\n    QCommandLineOption marginsOption(QStringLiteral(\"margins\"), QStringLiteral(\"Window margins\"), QStringLiteral(\"pixels\"), QStringLiteral(\"0\"));\n    QCommandLineOption scopeOption(QStringLiteral(\"scope\"), QStringLiteral(\"Window scope\"), QStringLiteral(\"namespace\"), QStringLiteral(\"normal\"));\n    QCommandLineOption anchorsOption(QStringLiteral(\"anchors\"),\n                                     QStringLiteral(\"Either \") + enumsToStringList(anchorMetaEnum).join(QLatin1String(\"|\")),\n                                     QStringLiteral(\"anchors\"),\n                                     QStringLiteral(\"AnchorTop|AnchorBottom|AnchorLeft|AnchorRight\"));\n    QCommandLineOption layerOption(QStringLiteral(\"layer\"),\n                                   QStringLiteral(\"One of \") + enumsToStringList(layerMetaEnum).join(QLatin1String(\"|\")),\n                                   QStringLiteral(\"layer\"),\n                                   QStringLiteral(\"LayerTop\"));\n    QCommandLineOption widthOption(QStringLiteral(\"width\"), QStringLiteral(\"Width of the window\"), QStringLiteral(\"pixels\"), QStringLiteral(\"0\"));\n    QCommandLineOption heightOption(QStringLiteral(\"height\"), QStringLiteral(\"Height of the window\"), QStringLiteral(\"pixels\"), QStringLiteral(\"0\"));\n    QCommandLineOption timeOption(QStringLiteral(\"time\"), QStringLiteral(\"Time the program stays alive\"), QStringLiteral(\"Time(ms)\"));\n\n\n    parser.addOptions({marginsOption, scopeOption, anchorsOption, layerOption, widthOption, heightOption, timeOption});\n    parser.addHelpOption();\n    parser.process(app);\n    \n    BasicWindow window;\n\n    LayerShellQt::Window *layerShell = LayerShellQt::Window::get(&window);\n    layerShell->setLayer(Window::LayerTop);\n    layerShell->setAnchors(Window::AnchorTop);\n    window.setWidth(primaryDisplaySize.width());\n    window.setHeight(30);\n\n\n    if (parser.isSet(marginsOption)) {\n        int margins = parser.value(marginsOption).toInt();\n        layerShell->setMargins({margins, margins, margins, margins});\n    }\n\n    if (parser.isSet(scopeOption)) {\n        layerShell->setScope(parser.value(scopeOption));\n    }\n    if (parser.isSet(layerOption)) {\n        layerShell->setLayer(Window::Layer(layerMetaEnum.keyToValue(qPrintable(parser.value(layerOption)))));\n    }\n    if (parser.isSet(anchorsOption)) {\n        layerShell->setAnchors(stringToEnum<Window::Anchors>(anchorMetaEnum, parser.value(anchorsOption)));\n    }\n    if (parser.isSet(widthOption)) {\n        window.setWidth(parser.value(widthOption).toInt());\n    }\n    if (parser.isSet(heightOption)) {\n        window.setHeight(parser.value(heightOption).toInt());\n    }\n    if (parser.isSet(timeOption)){\n        QTimer::singleShot(parser.value(timeOption).toInt(), &app, &QGuiApplication::quit);\n    }\n    \n    window.show();\n    \n    // NOTE: No idea what this stuff is, but its part of the sample code. \n    //BasicWindow window2;\n    //window2.resize(800, 400);\n    //window2.show();\n\n    return app.exec();\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\n\nbool setArray(int** &arr, int& rows, int &columns) {\n    cout << \"Enter number of rows: \";\n    cin >> rows;\n    cout << \"Enter number of columns: \";\n    cin >> columns;\n    if (rows < 1 || columns < 1) {\n        cout << \"Invalid input. Please enter positive numbers.\" << endl;\n        return false;\n    }\n    arr = new int*[rows];\n    for(int i = 0; i < rows; ++i)\n        arr[i] = new int[columns];\n\n    for (int j = 0; j < columns; ++j) {\n        cout << \"Enter column number \" << j + 1 << \": \";\n        for (int i = 0; i < rows; ++i) {\n            cout << \"\\nEnter element \" << i + 1 << \": \";\n            cin >> arr[i][j];\n        }\n    }\n    return true;\n}\n\nvoid printArray(int** arr, int rows, int columns) {\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < columns; ++j) {\n            cout << arr[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid findEqualPositiveNegativeRawColumn(int** arr, int rows, int columns, int& lastEqualRow, int& lastEqualColumn) {\n    lastEqualRow = 0;\n    lastEqualColumn = 0;\n\n    // Check each row\n    for (int i = 0; i < rows; ++i) {\n        int positiveCount = 0;\n        int negativeCount = 0;\n        for (int j = 0; j < columns; ++j) {\n            if (arr[i][j] > 0) {\n                positiveCount++;\n            } else if (arr[i][j] < 0) {\n                negativeCount++;\n            }\n\n        }\n        if (positiveCount == negativeCount && positiveCount != 0) {\n            lastEqualRow = i + 1;\n        }\n    }\n\n    // Check each column\n    for (int j = 0; j < columns; ++j) {\n        int positiveCount = 0;\n        int negativeCount = 0;\n        for (int i = 0; i < rows; ++i) {\n            if (arr[i][j] > 0) {\n                positiveCount++;\n            }\n            else if (arr[i][j] < 0) {\n                negativeCount++;\n            }\n        }\n        if (positiveCount == negativeCount && positiveCount != 0) {\n            lastEqualColumn = j + 1;\n        }\n    }\n}\n\nvoid printResult(int lastEqualRow, int lastEqualColumn) {\n    cout << \"Last row with equal positive and negative numbers: \" << lastEqualRow << endl;\n    cout << \"Last column with equal positive and negative numbers: \" << lastEqualColumn << endl;\n}\n\nint main() {\n    char choice;\n    do {\n        int** arr = nullptr;\n        int rows, columns, lastEqualRow, lastEqualColumn;\n\n        if(!setArray(arr, rows, columns)) {\n            choice = 'y';\n            continue;\n        }\n        printArray(arr, rows, columns);\n        findEqualPositiveNegativeRawColumn(arr, rows, columns, lastEqualRow, lastEqualColumn);\n        printResult(lastEqualRow, lastEqualColumn);\n        for(int i = 0; i < rows; ++i)\n            delete[] arr[i];\n        delete[] arr; // Free allocated memory\n\n        cout << \"Do you want to continue? (y/n): \";\n        cin >> choice;\n    } while (choice == 'y' || choice == 'Y');\n\n    return 0;\n}",
    "#include <Novice.h>\n#include <stdlib.h>\n\nconst char kWindowTitle[] = \"5147_Side_Step\";\n\n// Windows\u30a2\u30d7\u30ea\u3067\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u30dd\u30a4\u30f3\u30c8(main\u95a2\u6570)\nint WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {\n\n\t// \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u521d\u671f\u5316\n\tNovice::Initialize(kWindowTitle, 1280, 720);\n\n\t// \u30ad\u30fc\u5165\u529b\u7d50\u679c\u3092\u53d7\u3051\u53d6\u308b\u7bb1\n\tchar keys[256] = {0};\n\tchar preKeys[256] = {0};\n\n\tint titleGhd =\n\t\tNovice::LoadTexture(\"./resources/title/titleScreen.png\");\n\n\tint titleName[2] = {\n\tNovice::LoadTexture(\"./resources/title/titleName.png\"),\n\tNovice::LoadTexture(\"./resources/title/titleName1.png\") };\n\n\tint leftRun[3] = {\n\tNovice::LoadTexture(\"./resources/running/leftRunning0.png\"),\n\tNovice::LoadTexture(\"./resources/running/leftRunning1.png\"),\n\tNovice::LoadTexture(\"./resources/running/leftRunning2.png\") };\n\n\tint rightRun[3] = {\n\tNovice::LoadTexture(\"./resources/running/rightRunning0.png\"),\n\tNovice::LoadTexture(\"./resources/running/rightRunning1.png\"),\n\tNovice::LoadTexture(\"./resources/running/rightRunning2.png\") };\n\n\tint fuelGhd[3] = {\n\tNovice::LoadTexture(\"./resources/fuel/fuel0.png\"),\n\tNovice::LoadTexture(\"./resources/fuel/fuelBack0.png\"),\n\tNovice::LoadTexture(\"./resources/fuel/fuelBack1.png\") };\n\n\tint gaugePointGhd =\n\t\tNovice::LoadTexture(\"./resources/point/point0.png\");\n\n\tint obstacleGhd =\n\t\tNovice::LoadTexture(\"./resources/obstacle/obstacle0.png\");\n\n\tint doorGhd =\n\t\tNovice::LoadTexture(\"./resources/door/GoalDoorSprite.png\");\n\n\tint overGhd =\n\t\tNovice::LoadTexture(\"./resources/over/GameOverSprite.png\");\n\n\tint clearGhd =\n\t\tNovice::LoadTexture(\"./resources/clear/ClearSprite.png\");\n\n\t//===================================================================================================================\n\t//BGM\n\t//===================================================================================================================\n\tint soundHandle1 = Novice::LoadAudio(\"./sound/Journey.mp3\");\n\t//int soundHandle2 = Novice::LoadAudio(\"./sound/164855__zonkmachine.mp3\");\n\n\tint voiceHandle1 = 0;\n\t//int voiceHandle2 = 0;\n\n\t//===================================================================================================================\n\n\tstruct Vector2 {\n\t\tfloat x, y;\n\t\tfloat size;\n\t};\n\n\tstruct Title {\n\t\tfloat x, y;\n\t};\n\n\tstruct Background {\n\t\tVector2 pos;\n\t\tfloat width, height;\n\t};\n\n\tstruct Player {\n\t\tVector2 pos;\n\t\tfloat x, y;\n\t\tfloat speed;\n\t\tbool isSpeed;\n\t};\n\n\tstruct Fuel {\n\t\tVector2 pos;\n\t\tfloat x, y;\n\t\tint sizeX, sizeY;\n\t\tfloat speed;\n\t};\n\n\tstruct Hit {\n\t\tVector2 pos;\n\t\tVector2 size;\n\t\tfloat x, y;\n\t};\n\n\tstruct GaugeP {\n\t\tVector2 pos;\n\t\tfloat x, y;\n\t\tfloat speed;\n\t\tbool isAlive;\n\t};\n\n\tstruct Obstacle {\n\t\tVector2 pos;\n\t\tfloat x, y;\n\t\tfloat speed;\n\t\tbool isAlive;\n\t};\n\n\tstruct Door {\n\t\tVector2 pos;\n\t\tfloat x, y;\n\t};\n\n\tstruct GameTime {\n\t\tVector2 pos;\n\t\tfloat x, y;\n\t\tfloat sizeX, sizeY;\n\t};\n\n\t//===================================================================================================================\n\n\tTitle title[2];\n\ttitle[0].x = 0, title[0].y = 0;\n\ttitle[1].x = 400, title[1].y = 450;\n\n\tBackground background[3];\n\tbackground[0].pos.x = 0, background[0].pos.y = 0;\n\tbackground[0].width = 1280, background[0].height = 720;\n\n\tbackground[1].pos.x = 1080, background[1].pos.y = 0;\n\n\tbackground[2].pos.x = 1105, background[2].pos.y = 245;\n\tbackground[2].width = 150, background[2].height = 280;\n\n\n\tBackground fuelBack;\n\tfuelBack.pos.x = 1080, fuelBack.pos.y = 0;\n\n\tBackground overScreen;\n\toverScreen.pos.x = 0, overScreen.pos.y = 0;\n\n\tBackground clearScreen;\n\tclearScreen.pos.x = 0, clearScreen.pos.y = 0;\n\n\tPlayer player;\n\tplayer.pos.x = 50, player.pos.y = 620;\n\tplayer.speed = 8;\n\tplayer.isSpeed = true;\n\n\tFuel fuel;\n\tfuel.pos.x = 1105, fuel.pos.y = 230;\n\n\tFuel gauge1;\n\tgauge1.pos.x = 1110, gauge1.pos.y = 249;\n\tgauge1.sizeX = 140, gauge1.sizeY = 300;\n\tgauge1.speed = 0.3f;\n\n\tFuel transBox;\n\ttransBox.pos.x = 1110, transBox.pos.y = 530;\n\ttransBox.sizeX = 140, transBox.sizeY = 300;\n\n\n\tHit headHit;\n\theadHit.pos.x = player.pos.x;\n\theadHit.pos.y = player.pos.y;\n\theadHit.size.x = 25, headHit.size.y = 24;\n\n\tHit bodyHit;\n\tbodyHit.pos.x = player.pos.x;\n\tbodyHit.pos.y = player.pos.y;\n\tbodyHit.size.x = 33, bodyHit.size.y = 65;\n\n\tGaugeP gaugeP[2];\n\tfor (int p = 0; p < 2; p++) {\n\t\tgaugeP[p].pos.x = float(rand() % 1016 + 256); gaugeP[p].pos.y = 0;\n\t\tgaugeP[p].speed = 6;\n\t\tgaugeP[p].isAlive = false;\n\t}\n\n\tHit pointHit[2];\n\tfor (int p = 0; p < 2; p++) {\n\t\tpointHit[p].pos.x = gaugeP[p].pos.x;\n\t\tpointHit[p].pos.y = gaugeP[p].pos.y;\n\t\tpointHit[p].size.x = 32, pointHit[p].size.y = 32;\n\t}\n\n\n\tObstacle obstacle[5];\n\tfor (int i = 0; i < 5; i++) {\n\t\tobstacle[i].pos.x = float(rand() % 1016); obstacle[i].pos.y = 0;\n\t\tobstacle[i].speed = float(rand() % 8 + 9);\n\t\tobstacle[i].isAlive = false;\n\t}\n\n\tHit obHit[5];\n\tfor (int i = 0; i < 5; i++) {\n\t\tobHit[i].pos.x = obstacle[i].pos.x;\n\t\tobHit[i].pos.y = obstacle[i].pos.y;\n\t\tobHit[i].size.x = 60, obHit[i].size.y = 52;\n\t}\n\n\n\tDoor door;\n\tdoor.pos.x = float(rand() % 1016);\n\tdoor.pos.y = 624;\n\n\tHit doorHit;\n\tdoorHit.pos.x = door.pos.x;\n\tdoorHit.pos.y = door.pos.y;\n\tdoorHit.size.x = 84, doorHit.size.y = ",
    "#include \"cppmicroservices/Bundle.h\"\n#include \"cppmicroservices/BundleActivator.h\"\n#include \"cppmicroservices/BundleImport.h\"\n#include \"cppmicroservices/BundleContext.h\"\n#include \"cppmicroservices/BundleResource.h\"\n#include \"cppmicroservices/BundleResourceStream.h\"\n#include \"cppmicroservices/Constants.h\"\n#include \"cppmicroservices/ServiceEvent.h\"\n\nusing namespace cppmicroservices;\n\n/**\n * This class implements a simple bundle that utilizes the CppMicroServices's\n * event mechanism to listen for service events. Upon receiving a service event,\n * it prints out the event's details.\n */\nclass Activator : public BundleActivator\n{\nprivate:\n    /**\n     * Implements BundleActivator::Start(). Prints a message and adds a member\n     * function to the bundle context as a service listener.\n     *\n     * @param context the framework context for the bundle.\n     */\n    void Start(BundleContext context)\n    {\n        auto bundle = context.GetBundle();\n        auto headers = bundle.GetHeaders();\n\n        cppmicroservices::ServiceProperties props;\n        \n        props[\"VendorName\"] = std::string(\"%{VendorName}\");\n        props[\"Version\"] = 0;\n\n        // \u5f53\u8282\u70b9\u670d\u52a1\u7c7b (...NodeService) \u7684\u5b9a\u4e49\u5b8c\u6210\u65f6\uff0c\u9700\u8981\u5728\u6fc0\u6d3b\u5668 (Activator) \u4e2d\u6ce8\u518c\u6b64\u670d\u52a1\u3002\n        // \u53ea\u6709\u5f53\u8282\u70b9\u670d\u52a1\u7c7b\u88ab\u6210\u529f\u6ce8\u518c, aubo_scope \u624d\u80fd\u52a0\u8f7d\u8be5\u8282\u70b9\u3002\n\n        // \u5b89\u88c5\u8282\u70b9\u670d\u52a1\u7c7b\u7684\u6ce8\u518c\u65b9\u6cd5\u5982\u4e0b\n\tprops[\"Name\"] = std::string(typeid(\u8fd9\u91cc\u9700\u8981\u66ff\u6362\u4e3a\u5b89\u88c5\u8282\u70b9node\u7c7b\u7684\u7c7b\u540d).name());\n        context.RegisterService<arcs::aubo_scope::InstallationNodeService>(\n           std::make_shared<...InstallationNodeService>(), props);\n\n        // \u7a0b\u5e8f\u8282\u70b9\u670d\u52a1\u7c7b\u7684\u6ce8\u518c\u65b9\u6cd5\u5982\u4e0b\n\tprops[\"Name\"] = std::string(typeid(\u8fd9\u91cc\u9700\u8981\u66ff\u6362\u4e3a\u7a0b\u5e8f\u8282\u70b9Contribution\u7c7b\u7684\u7c7b\u540d).name());\n        context.RegisterService<arcs::aubo_scope::ProgramNodeService>(\n           std::make_shared<...ProgramNodeService>(), props);\n\n    }\n\n    /**\n     * Implements BundleActivator::Stop(). Prints a message and removes the\n     * member function from the bundle context as a service listener.\n     *\n     * @param context the framework context for the bundle.\n     */\n    void Stop(BundleContext /*context*/) {}\n};\n\nCPPMICROSERVICES_EXPORT_BUNDLE_ACTIVATOR(Activator)\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\nclass Hotel {\r\npublic:\r\n    int id;\r\n    string name; \r\n    string type;\r\n    string rating;\r\n    string location;\r\n    int establish_year;\r\n    int staff_quantity;\r\n    int room_quantity;\r\n    static char Location[];\r\n\r\npublic:\r\n    void setData() \r\n\t{\r\n    cout<<\"Enter Id = \";\r\n\tcin>>id;\r\n\tcout<<\"Enter Name = \";\r\n\tcin>>name;\r\n\tcout<<\"Enter Type = \";\r\n\tcin>>type;\r\n\tcout<<\"Enter Rating = \";\r\n\tcin>>rating;\r\n\tcout<<\"Enter Location = \";\r\n\tcin>>location;\r\n\tcout<<\"Enter Establish_year = \";\r\n\tcin>>establish_year;\r\n\tcout<<\"Enter Staff_quantity = \";\r\n\tcin>>staff_quantity;\r\n\tcout<<\"Enter Room_quantity = \";\r\n\tcin>>room_quantity;\r\n    }\r\nvoid getData()\r\n{\r\n\tcout<<\"Id = \"<<id<<endl\r\n\t    <<\"Name = \"<<name<<endl\r\n\t    <<\"Type = \"<<type<<endl\r\n\t    <<\"Rating = \"<<rating<<endl\r\n\t    <<\"Location = \"<<location<<endl\r\n\t    <<\"Establish_year = \"<<establish_year<<endl\r\n\t    <<\"Staff_quantity = \"<<staff_quantity<<endl\r\n\t    <<\"Room_quantity = \"<<room_quantity<<endl;\r\n}\r\n\r\nstatic void data()\r\n{\r\n\tcout << \"Location: \" << Location << endl;\r\n}\r\n};\r\nint main() \r\n{\r\n    int N;\r\n    cout << \"Enter the number of hotels: \";\r\n    cin >> N;\r\n\r\n    Hotel hotels[N];\r\n\r\n    for (int i=0;i<N;++i) \r\n\t{\r\n        cout << \"\\nEnter details for Hotel \"<<i+1<<\":\"<<endl;\r\n        hotels[i].setData();\r\n    }\r\n\r\n    cout << \"\\nHotel Information:\\n\" << endl;\r\n    for (int i = 0; i < N; ++i) \r\n\t{\r\n        cout << \"Details of Hotel \" << i +1<<\":\"<<endl;\r\n        hotels[i].getData();\r\n        cout << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"login_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"fuell.hpp\"\n\n#define FDC1004_ADRESS 0b1010000 << 1\n\n\n\nusing namespace mbed;\n\nFDC1004::FDC1004(mbed::I2C& i2c) :\n    _i2c(i2c)\n    //_alert(PC_12, PinMode::PullNone),\n      \n    //interrupt_triggered(true),//true\n    //high_limit_reached(false)\n{\n   \n}\n\nuint16_t FDC1004::get_MEAS1_MSB(){\n    return get_register(0x00);\n}\nuint16_t FDC1004::get_MEAS1_LSB(){\n    return get_register(0x01);\n}\nuint16_t FDC1004::get_MEAS2_MSB(){\n    return get_register(0x02);\n}\nuint16_t FDC1004::get_MEAS2_LSB(){\n    return get_register(0x03);\n}\nuint16_t FDC1004::get_MEAS3_MSB(){\n    return get_register(0x04);\n}\nuint16_t FDC1004::get_MEAS3_LSB(){\n    return get_register(0x05);\n}\nuint16_t FDC1004::get_MEAS4_MSB(){\n    return get_register(0x06);\n}\nuint16_t FDC1004::get_MEAS4_LSB(){\n    return get_register(0x07);\n}\nuint16_t FDC1004::get_CONF_MEAS1(){\n    return get_register(0x08);\n}\nuint16_t FDC1004::get_CONF_MEAS2(){\n    return get_register(0x09);\n}\nuint16_t FDC1004::get_CONF_MEAS3(){\n    return get_register(0x0A);\n}\nuint16_t FDC1004::get_CONF_MEAS4(){\n    return get_register(0x0B);\n}\nuint16_t FDC1004::get_config_register(){\n    return get_register(0x0C);\n}\nuint16_t FDC1004::get_OFFSET_CAL_CIN1(){\n    return get_register(0x0D);\n}\nuint16_t FDC1004::get_OFFSET_CAL_CIN2(){\n    return get_register(0x0E);\n}\nuint16_t FDC1004::get_OFFSET_CAL_CIN3(){\n    return get_register(0x0F);\n}\nuint16_t FDC1004::get_OFFSET_CAL_CIN4(){\n    return get_register(0x10);\n}\nuint16_t FDC1004::get_GAIN_CAL_CIN1(){\n    return get_register(0x11);\n}\nuint16_t FDC1004::get_GAIN_CAL_CIN2(){\n    return get_register(0x12);\n}\nuint16_t FDC1004::get_GAIN_CAL_CIN3(){\n    return get_register(0x13);\n}\nuint16_t FDC1004::get_GAIN_CAL_CIN4(){\n    return get_register(0x14);\n}\nuint16_t FDC1004::get_MANUFACTURER_ID(){\n    return get_register(0xFE);\n}\nuint16_t FDC1004::get_DEVICE_ID(){\n    return get_register(0xFF);\n}\n\nuint16_t FDC1004::get_register(char registeraddress){\n\n    //printf(\"FDC1004::%s\\r\\n\", __func__);\n    uint8_t FDC1004Address = 0b1010000 << 1;\n    \n    char data[2];\n    int rc = _i2c.write(FDC1004Address, &registeraddress, 1, false);//<==true davor\n    if (rc != 0){\n\n        printf(\"Fehler i2c write\\r\\n\");\n    }\n    rc = _i2c.read(FDC1004Address, data, 2);\n    if (rc != 0){\n\n        printf(\"Fehler i2c read\\r\\n\");\n    }\n\n    uint16_t value = data[1];\n    value = value | (data[0] << 8);\n\n    return value;\n}\n\n\nuint32_t FDC1004::getMeasure1(){\n\n    uint16_t meas1_1 = get_MEAS1_MSB();\n    uint16_t meas1_2 = get_MEAS1_LSB();\n    uint32_t complete_measure_binary1 = meas1_2 >> 8;\n    complete_measure_binary1 += meas1_1 << 8;\n    return complete_measure_binary1;\n}\n\nuint32_t FDC1004::getMeasure2(){\n\n    uint16_t meas2_1 = get_MEAS2_MSB();\n    uint16_t meas2_2 = get_MEAS2_LSB();\n    uint32_t complete_measure_binary2 = meas2_2 >> 8;\n    complete_measure_binary2 += meas2_1 << 8;\n    return complete_measure_binary2;\n}\nuint32_t FDC1004::getMeasure3(){\n\n    uint16_t meas3_1 = get_MEAS3_MSB();\n    uint16_t meas3_2 = get_MEAS3_LSB();\n    uint32_t complete_measure_binary3 = meas3_2 >> 8;\n    complete_measure_binary3 += meas3_1 << 8;\n    return complete_measure_binary3;\n}\nuint32_t FDC1004::getMeasure4(){\n\n    uint16_t meas4_1 = get_MEAS4_MSB();\n    uint16_t meas4_2 = get_MEAS4_LSB();\n    uint32_t complete_measure_binary4 = meas4_2 >> 8;\n    complete_measure_binary4 += meas4_1 << 8;\n    return complete_measure_binary4;\n}\n\n\nvoid FDC1004::reset(){\n\n    uint16_t value = 0;\n    set_config_register_bit(value, 15, 1);\n}\n\nvoid FDC1004::set_repeated_measurements(bool set){\n\n    uint16_t value = 0;\n\n    if(set){set_config_register_bit(value, 8, 1);}else{set_config_register_bit(value, 8, 0);}\n\n}\n\n\n/*\nbool FDC1004::set_measurement_offset_capacitance(FDC1004::Register measureConfigReg, uint8_t offset){\n\n    uint16_t value = get_register((char)measureConfigReg);\n    if(offset > 31 || offset < 0){\n        //printf(\"Offset im falschen Bereich, maximal 31\");\n        return false;\n    }\n\n    //uint16_t capdac = 0;\n    value |= (offset << 5);\n    write_register(measureConfigReg, value);\n    return true;\n\n}\n\n*/\n\nbool FDC1004::set_measurement_channel_config(FDC1004::Register measureConfigReg, FDC1004::Channel channelA, FDC1004::Channel channelB, uint8_t capdacValue)\n{\n    // uint16_t value = get_register((char)measureConfigReg);\n    uint16_t value = 0x00;\n    value |= ((uint16_t)channelA << 13);\n    value |= ((uint16_t)channelB << 10);\n\n    bool success = true;\n\n    if (channelB == FDC1004::Channel::CAPDAC){\n\n        if(capdacValue > 31){\n\n            //printf(\"Offset im falschen Bereich, maximal 31\");\n            return false;\n        }\n        value |= (capdacValue << 5);\n    }\n\n    write_register(measureConfigReg, value);\n    return success;   \n}\n\nvoid FDC1004::set_measurement_rate(FDC1004::MeasurementRate rate){\n\n\n    uint16_t value = get_config_register();\n\n    value &= ~(0x03 << 10);\n    value |= ((uint8_t)rate) << 10;\n\n    if(rate == FDC1004::MeasurementRate::Rate100){\n        set_config_regis",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* TRAFFIC LIGHT SIMULATION\n   PROGRAMMED AND DESIGNED BY ADAM HAUGEN\n*/\n\n#include <simplecpp>\n\nint const MAX_CARS = 3;\nchar input;\nbool flag = true;\nint loopVal = 0;\n\n// Update variables to stagger cars\nint xPos = 350, yPos = 650;\n\n// Sets Traffic light to Green\nvoid greenLight(Circle &light, int x)\n{\n    light.setColor(COLOR(\"Green\"));\n    if (x == 0)\n        light.moveTo(300, 160);\n    else\n        light.moveTo(900, 760);\n}\n\n//Sets traffic light to Red\nvoid redLight(Circle &light, int x)\n{\n    light.setColor(COLOR(\"Red\"));\n    if (x == 0)\n        light.moveTo(300, 40);\n    else\n        light.moveTo(900, 640);\n}\n\n//sets traffic light to Yellow\nvoid yellowLight(Circle &light, int x)\n{\n    light.setColor(COLOR(\"Yellow\"));\n    if (x == 0)\n        light.moveTo(300, 100);\n    else\n        light.moveTo(900, 700);\n}\n\nmain_program\n{\n    //boolean value for calling yellow light\n    bool called = false;\n\n    //Create window\n    initCanvas(\"Traffic Light Sim\", 1000, 1000);\n\n    struct Car\n    {\n        Rectangle body;\n    };\n\n    //creates the intersection\n    Rectangle ewRoad(500, 500, 1000, 200);\n    ewRoad.setColor(COLOR(\"#8c8c8c\"));\n    ewRoad.setFill();\n    Rectangle nwRoad(500, 500, 200, 1000);\n    nwRoad.setColor(COLOR(\"#8c8c8c\"));\n    nwRoad.setFill();\n\n    Car carArrayNS[MAX_CARS];\n    Car carArrayEW[MAX_CARS];\n\n    // N/S Traffic Light\n    Rectangle r1(300, 100, 100, 200);\n    r1.setColor(COLOR(255, 204, 0));\n    r1.setFill();\n    Circle b1(300, 40, 26);\n    b1.setColor(COLOR(\"black\"));\n    b1.setFill();\n    Circle b2(300, 100, 26);\n    b2.setColor(COLOR(\"black\"));\n    b2.setFill();\n    Circle b3(300, 160, 26);\n    b3.setColor(COLOR(\"black\"));\n    b3.setFill();\n    Circle c1(300, 40, 25);\n    c1.setColor(COLOR(\"Red\"));\n    c1.setFill();\n\n    Text t1(300, 220, \"N/S Traffic Light\");\n\n    // E/W Traffic Light\n    Rectangle r2(900, 700, 100, 200);\n    Circle b4(900, 640, 26);\n    b4.setColor(COLOR(\"black\"));\n    b4.setFill();\n    Circle b5(900, 700, 26);\n    b5.setColor(COLOR(\"black\"));\n    b5.setFill();\n    Circle b6(900, 760, 26);\n    b6.setColor(COLOR(\"black\"));\n    b6.setFill();\n    r2.setColor(COLOR(255, 204, 0));\n    r2.setFill();\n    Circle c2(900, 640, 25);\n    c2.setColor(COLOR(\"Red\"));\n    c2.setFill();\n\n    Text t2(900, 820, \"E/W Traffic Light\");\n\n    //initialize and stagger NS cars\n    for (int i = 0; i < 3; i++)\n    {\n        carArrayNS[i].body = Rectangle(500, yPos, 50, 75);\n        carArrayNS[i].body.setColor(COLOR(\"blue\"));\n        carArrayNS[i].body.setFill();\n        carArrayNS[i].body.hide();\n        yPos += 150;\n    }\n\n    // Initialize and stagger EW cars\n    for (int i = 0; i < 3; i++)\n    {\n        carArrayEW[i].body = Rectangle(xPos, 500, 75, 50);\n        carArrayEW[i].body.setColor(COLOR(\"green\"));\n        carArrayEW[i].body.setFill();\n        carArrayEW[i].body.hide();\n        xPos -= 150;\n    }\n\n   //main loop that asks user for input and simulates the intersection\n    while (flag)\n    {\n        xPos = 350;\n        yPos = 650;\n        called = false; //reset yellow light flag\n\n        //reset NS car locations to starting position\n        for (int i = 0; i < 3; i++)\n        {\n            carArrayNS[i].body.moveTo(500, yPos);\n            carArrayNS[i].body.hide();\n            yPos += 150;\n        }\n\n        //reset EW car locations to starting position\n        for (int i = 0; i < 3; i++)\n        {\n            carArrayEW[i].body.moveTo(xPos, 500);\n            carArrayEW[i].body.hide();\n            xPos -= 150;\n        }\n\n        // Ask for traffic density\n        cout << \"Enter the traffic density: (h = heavy, m = medium, l = light): \";\n        cin >> input;\n\n        switch (input)\n        {\n        //heavy traffic\n        case 'h':\n            //show all vehicles\n            carArrayNS[0].body.show();\n            carArrayNS[1].body.show();\n            carArrayNS[2].body.show();\n            carArrayEW[0].body.show();\n            carArrayEW[1].body.show();\n            carArrayEW[2].body.show();\n\n            //set light to green\n            wait(1);\n            greenLight(c1, 0);\n            wait(0.5);\n\n            //moves NS Cars, when last car gets across road, change light to yellow.\n            while (carArrayNS[2].body.getY() >= -35)\n            {\n                carArrayNS[0].body.move(0, -15);\n                carArrayNS[1].body.move(0, -15);\n                carArrayNS[2].body.move(0, -15);\n                if (carArrayNS[2].body.getY() <= 300 && !called)\n                {\n                    yellowLight(c1, 0);\n                    called = true;\n                }\n                wait(0.1);\n            }\n            //when final car leaves screen, light turns red\n            redLight(c1, 0);\n            wait(1);\n            greenLight(c2, 1);\n            called = false;\n            wait(0.5);\n\n            //moves EW Cars, when last car gets across road, change light to yellow.\n            while (carArrayEW[2].body.getX() <= 1035)\n            {\n                carArrayEW[0].body.move",
    "\ufeff#include <Windows.h>\r\n#include <mmsystem.h>\r\n#pragma comment(lib, \"winmm.lib\")\r\n#define TIMER_ID 1\r\nint i = 0;\r\nDWORD g_dwOriginalVolume;\r\nextern \"C\" {\r\n    __declspec(dllexport) void __stdcall PlayMusic();\r\n}\r\nTCHAR g_szMusicFilePath1[] = TEXT(\"D:\\\\\u6d4f\u89c8\u5668\u4e0b\u8f7d\\\\hulu.wav\");\r\n\r\nvoid SetSystemVolume(DWORD dwVolume);\r\n\r\n\r\nLRESULT CALLBACK ChildWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n    switch (uMsg) {\r\n    case WM_CREATE:\r\n        break;\r\n    case WM_CLOSE:\r\n        ShowWindow(hwnd, SW_HIDE);\r\n        break;\r\n    case WM_DESTROY:\r\n        PostQuitMessage(0);\r\n        break;\r\n    default:\r\n        return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n    return 0;\r\n}\r\n\r\nLRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n    switch (uMsg) {\r\n    case WM_CREATE:\r\n        PlayMusic();\r\n        SetTimer(hwnd, TIMER_ID, 1000, NULL);\r\n        break;\r\n\r\n    case WM_TIMER:\r\n        if (wParam == TIMER_ID) {\r\n            HWND childWnd = CreateWindow(\r\n                L\"ChildWindowClass\",\r\n                L\"\u5b50\u7a97\u53e3\",\r\n                WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX,\r\n                50 + i * 20, 50 + i * 20,700, 500,\r\n                hwnd,\r\n                NULL,\r\n                (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),\r\n                NULL\r\n            );\r\n            if (childWnd == NULL) {\r\n                MessageBox(hwnd, L\"\u65e0\u6cd5\u521b\u5efa\u5b50\u7a97\u53e3\uff01\", L\"\u9519\u8bef\", MB_OK | MB_ICONERROR);\r\n            }\r\n            SetForegroundWindow(childWnd);\r\n\r\n            // \u5c06\u5b50\u7a97\u53e3\u805a\u7126\r\n            SetFocus(childWnd);\r\n            SetSystemVolume(0xFFFF);\r\n            i = (i + 1) % 100; // \u91cd\u7f6ei\u7684\u503c\uff0c\u907f\u514d\u65e0\u9650\u521b\u5efa\u7a97\u53e3\r\n        }\r\n        break;\r\n\r\n    case WM_CLOSE:\r\n        DestroyWindow(hwnd);\r\n        break;\r\n\r\n    case WM_DESTROY:\r\n        PostQuitMessage(0);\r\n        break;\r\n\r\n    default:\r\n        return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n    return 0;\r\n}\r\n\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) {\r\n    WNDCLASS wndcls, childWndCls;\r\n\r\n    // \u6ce8\u518c\u4e3b\u7a97\u53e3\u7c7b\r\n    wndcls.cbClsExtra = 0;\r\n    wndcls.cbWndExtra = 0;\r\n    wndcls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\r\n    wndcls.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wndcls.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    wndcls.hInstance = hInstance;\r\n    wndcls.lpfnWndProc = MainWndProc;\r\n    wndcls.lpszClassName = L\"MainWindowClass\";\r\n    wndcls.lpszMenuName = NULL;\r\n    wndcls.style = CS_HREDRAW | CS_VREDRAW;\r\n    RegisterClass(&wndcls);\r\n\r\n    // \u6ce8\u518c\u5b50\u7a97\u53e3\u7c7b\r\n    childWndCls.cbClsExtra = 0;\r\n    childWndCls.cbWndExtra = 0;\r\n    childWndCls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\r\n    childWndCls.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    childWndCls.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    childWndCls.hInstance = hInstance;\r\n    childWndCls.lpfnWndProc = ChildWndProc;\r\n    childWndCls.lpszClassName = L\"ChildWindowClass\";\r\n    childWndCls.lpszMenuName = NULL;\r\n    childWndCls.style = CS_HREDRAW | CS_VREDRAW;\r\n    RegisterClass(&childWndCls);\r\n\r\n    HWND hwnd = CreateWindow(\r\n        L\"MainWindowClass\", L\"\u6211\u7684\u7b2c\u4e00\u4e2a\u7a97\u53e3\",\r\n        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\r\n        NULL, NULL, hInstance, NULL);\r\n\r\n    if (hwnd == NULL) {\r\n        return 0;\r\n    }\r\n\r\n    ShowWindow(hwnd,1);\r\n    UpdateWindow(hwnd);\r\n\r\n    MSG msg;\r\n    while (GetMessage(&msg, NULL, 0, 0)) {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n\r\n    return 0;\r\n}\r\nvoid __stdcall PlayMusic() {\r\n    // \u4f7f\u7528PlaySound\u51fd\u6570\u64ad\u653e\u97f3\u4e50\r\n    // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u97f3\u4e50\u6587\u4ef6\u7684\u8def\u5f84\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u8c03\u7528PlaySound\u7684\u65b9\u5f0f\r\n    PlaySound(g_szMusicFilePath1, NULL, SND_ASYNC | SND_FILENAME | SND_LOOP);\r\n\r\n\r\n}\r\nvoid SetSystemVolume(DWORD dwVolume) {\r\n    // \u83b7\u53d6\u7cfb\u7edf\u9ed8\u8ba4\u97f3\u9891\u8bbe\u5907\r\n    HMIXER hMixer;\r\n    MIXERLINE ml;\r\n    MIXERCONTROL mc;\r\n    MIXERLINECONTROLS mlc;\r\n    MIXERCONTROLDETAILS mcd;\r\n    DWORD dwControlID;\r\n    MIXERCONTROLDETAILS_UNSIGNED value;\r\n\r\n    if (mixerOpen(&hMixer, 0, 0, 0, MIXER_OBJECTF_MIXER) == MMSYSERR_NOERROR) {\r\n        ml.cbStruct = sizeof(MIXERLINE);\r\n        ml.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;\r\n\r\n        if (mixerGetLineInfo(reinterpret_cast<HMIXEROBJ>(hMixer), &ml, MIXER_GETLINEINFOF_COMPONENTTYPE) == MMSYSERR_NOERROR) {\r\n            mlc.cbStruct = sizeof(MIXERLINECONTROLS);\r\n            mlc.dwLineID = ml.dwLineID;\r\n            mlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;\r\n            mlc.cControls = 1;\r\n            mlc.cbmxctrl = sizeof(MIXERCONTROL);\r\n            mlc.pamxctrl = &mc;\r\n\r\n            if (mixerGetLineControls(reinterpret_cast<HMIXEROBJ>(hMixer), &mlc, MIXER_GETLINECONTROLSF_ONEBYTYPE) == MMSYSERR_NOERROR) {\r\n                dwControlID = mc.dwControlID;\r\n                mcd.cbStruct = sizeof(MIXERCONTROLDETAILS);\r\n                mcd.dwControlID = dwControlID;\r\n                mcd.cChannels = 1;\r\n                mcd.cMultipleItems = 0;\r\n                mcd.cbDetails = si",
    "#include <stdio.h>\n#define MAX_SIZE 10\n#include \"Stack.h\"\n\nvoid prnMenu(){\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<\"* 1. \uc0bd\uc785    2. \uc0ad\uc81c    3. \ucd9c\ub825   4. \uc885\ub8cc *\"<<endl;\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<endl;\n\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uba54\ub274\ub97c \uace8\ub77c\uc8fc\uc138\uc694: \";\n}\n\nint main(){\n\t    int mode, selectNumber, tmpItem;\n\t\tLinkedList<int> *p;\n\t\tbool flag = false;\n\n\t\tcout<<\"\uc790\ub8cc\uad6c\uc870 \uc120\ud0dd(1: Stack, Other: Linked List): \";\n\t\tcin>>mode;\n\t\t\t\t\t\t    \n\t\tif(mode == 1)\n\t\t\tp = new Stack<int>();    // \uc815\uc218\ub97c \uc800\uc7a5\ud558\ub294 \uc2a4\ud0dd\n\t\t\t\n\t\telse\n\t\t\tp = new LinkedList<int>();\n\n\n\t\tdo{\n\t\t\tprnMenu();\n\t\t\tcin>>selectNumber;\n\t\t\t\n\t\t\tswitch(selectNumber){ \n\t\t\t\tcase 1:\n\t\t\t\t\tif(p->GetSize() == MAX_SIZE){\n\t\t\t\t\t\tcout << \"\uc785\ub825 \uc2e4\ud328! \ucd5c\ub300 \uc0ac\uc774\uc988\uc785\ub2c8\ub2e4.\" << endl;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694: \";\n\t\t\t\t\t\tcin>>tmpItem;    p->Insert(tmpItem);\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0bd\uc785\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif(p->Delete(tmpItem)==true)\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0ad\uc81c\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t\t\n\t\t\t\t\telse cout<<\"\ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc0ad\uc81c \uc2e4\ud328\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"\ud06c\uae30: \"<<p->GetSize()<<endl;\n\t\t\t\t\tp->Print();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tflag = true;     break;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tcout<<\"\uc798\ubabb \uc785\ub825\ud558\uc168\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) break;\n\t\t\t\n\t\t} while(1);\n\t\t\n\t\treturn 0;\n}\n\n",
    "#include <iostream>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Nodo {\n    T data;\n    Nodo* next;\n};\n\ntemplate<typename T>\nclass List {\nprivate:\n    Nodo<T>* head;\npublic:\n    List();\n    T front();\n    T back();\n    void push_front(T dt);\n    void push_back(T dt);\n    T pop_front();\n    T pop_back();\n    T operator[](int i);\n    bool empty();\n    int size();\n    void clear();\n    void sort();\n    void reverse();\n    void print();\n    ~List();\n};\n\ntemplate<typename T>\nList<T>::List() {\n    head = NULL;\n}\n\ntemplate<typename T>\nT List<T>::front() {\n    if(empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    return head->data;\n}\n\ntemplate<typename T>\nT List<T>::back() {\n    if(empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    Nodo<T>* temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    return temp->data;\n}\n\ntemplate<typename T>\nvoid List<T>::push_front(T dt) {\n    Nodo<T>* nuevoNodo = new Nodo<T>;\n    nuevoNodo->data = dt;\n    nuevoNodo->next = head;\n    head = nuevoNodo;\n}\n\ntemplate<typename T>\nvoid List<T>::push_back(T dt) {\n    Nodo<T>* nuevoNodo = new Nodo<T>;\n    Nodo<T>* temp = head;\n    nuevoNodo->data = dt;\n    nuevoNodo->next = NULL;\n    if (head == NULL) {\n        head = nuevoNodo;\n    }\n    else {\n        while (temp->next != NULL) {\n            temp = temp->next;\n        }\n        temp->next = nuevoNodo;\n    }\n}\n\ntemplate<typename T>\nT List<T>::pop_front() {\n    if(empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    Nodo<T>* temp = head;\n    T data = head->data;\n    head = head->next;\n    delete temp;\n    return data;\n}\n\ntemplate<typename T>\nT List<T>::pop_back() {\n    if(empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    if (head->next == NULL) {\n        T data = head->data;\n        delete head;\n        head = NULL;\n        return data;\n    }\n    else {\n        Nodo<T>* temp = head;\n        while (temp->next->next != NULL) {\n            temp = temp->next;}\n        T data = temp->next->data;\n        delete temp->next;\n        temp->next = NULL;\n        return data;\n    }\n}\n\ntemplate<typename T>\nT List<T>::operator[](int i) {\n    if (empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    Nodo<T>* temp = head;\n    int index = 0;\n    while (temp != NULL) {\n        if (index == i) {\n            return temp->data;\n        }\n        temp = temp->next;\n        index++;\n    }\n    throw out_of_range(\"\u00cdndice fuera de rango\");\n}\n\ntemplate<typename T>\nbool List<T>::empty() {\n    return head == NULL;\n}\n\ntemplate<typename T>\nint List<T>::size() {\n    int i = 0;\n    Nodo<T>* temp = head;\n    while (temp != NULL) {\n        i++;\n        temp = temp->next;\n    }\n    return i;\n}\n\ntemplate<typename T>\nvoid List<T>::clear() {\n    while (head != NULL) {\n        Nodo<T>* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\ntemplate<typename T>\nvoid List<T>::sort() {\n    if(empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    Nodo<T>* temp = head;\n    while (temp != NULL) {\n        Nodo<T>* temp2 = temp->next;\n        while (temp2 != NULL) {\n            if (temp->data > temp2->data) {\n                T aux = temp->data;\n                temp->data = temp2->data;\n                temp2->data = aux;\n            }\n            temp2 = temp2->next;\n        }\n        temp = temp->next;\n    }\n}\n\ntemplate<typename T>\nvoid List<T>::reverse() {\n    if(empty()) {\n        throw logic_error(\"Lista vacia\");\n    }\n    Nodo<T>* anterior = NULL;\n    Nodo<T>* actual = head;\n    Nodo<T>* siguiente = NULL;\n    while (actual != NULL) {\n        siguiente = actual->next;\n        actual->next = anterior;\n        anterior = actual;\n        actual = siguiente;\n    }\n    head = anterior;\n}\n\ntemplate<typename T>\nList<T>::~List() {\n    clear();\n}\n\ntemplate<typename T>\nvoid List<T>::print() {\n    if(empty()) {\n        cout << \"Lista vacia\" << endl;\n        return;\n    }\n    Nodo<T>* temp = head;\n    while (temp != NULL) {\n        cout << temp->data << \" \";\n        temp = temp->next;\n    }\n}\nint main() {\n\n    // Ejemplo de uso de las funciones de la clase List\n    List<int> intList;\n    cout << \"Lista vacia? \" << (intList.empty() ? \"Si\" : \"No\") << endl;\n\n    intList.push_back(1);\n    intList.push_back(3);\n    intList.push_back(2);\n    intList.push_back(5);\n    intList.push_back(4);\n    intList.push_back(6);\n\n    cout << \"Lista de enteros: \";\n    intList.print();\n    cout << endl;\n\n    cout << \"Tamano de la lista: \" << intList.size() << endl;\n\n    cout << \"Primer elemento: \" << intList.front() << endl;\n    cout << \"Ultimo elemento: \" << intList.back() << endl;\n\n    cout << \"Elemento en el indice 2: \" << intList[2] << endl;\n\n    cout << \"Eliminando el primer elemento: \" << intList.pop_front() << endl;\n    cout << \"Lista despues de eliminar el primer elemento: \";\n    intList.print();\n    cout << endl;\n\n    cout << \"Eliminando el ultimo elemento: \" << intList.pop_back() << endl;\n    cout << \"Lista despues de eliminar el ultimo elemento: \";\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"yes_no_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//HEX\r\n\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\nstruct Node {\r\n\tint x;\r\n\tint y;\r\n\tNode* next;\r\n\tNode(int x, int y) :x(x), y(y), next(nullptr){}\r\n};\r\n\r\nstruct List {\r\n\tNode* head;\r\n\r\n\tList(): head(nullptr){}\r\n\r\n\tbool isEmpty() const {\r\n\t\treturn head == nullptr;\r\n\t}\r\n\r\n\tNode* front() {\r\n\t\treturn head;\r\n\t}\r\n\r\n\tvoid addFront(int x, int y) {\r\n\t\tNode* newNode = new Node(x, y);\r\n\t\tnewNode->next = head;\r\n\t\thead = newNode;\r\n\t}\r\n\r\n\tvoid removeFront() {\r\n\t\tif (!isEmpty()) {\r\n\t\t\tNode* tmp = head;\r\n\t\t\thead = head->next;\r\n\t\t\tdelete tmp;\r\n\t\t}\r\n\t}\r\n\r\n\t~List() {\r\n\t\twhile (!isEmpty())\r\n\t\t\tremoveFront();\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct Board {\r\n\tchar** boardData;\r\n\tint boardSize;\r\n\r\n\t//constructor\r\n\texplicit Board(int size) : boardSize(size) {\r\n\t\tboardData = new char* [boardSize];\r\n\t\tfor (int i = 0; i < boardSize; i++) {\r\n\t\t\tboardData[i] = new char[boardSize];\r\n\t\t}\r\n\t}\r\n\r\n\t//copy constructor\r\n\tBoard(const Board& other) : boardSize(other.boardSize) {\r\n\t\tboardData = new char* [boardSize];\r\n\t\tfor (int i = 0; i < boardSize; i++) {\r\n\t\t\tboardData[i] = new char[boardSize];\r\n\t\t\tfor (int j = 0; j < boardSize; j++)\r\n\t\t\t\tboardData[j][i] = other.boardData[j][i];\r\n\t\t}\r\n\t}\r\n\r\n\tBoard& operator=(const Board& other) {\r\n\t\tif (this != &other) {\r\n\t\t\tfor (int i = 0; i < boardSize; i++)\r\n\t\t\t\tdelete[] boardData[i];\r\n\r\n\t\t\tdelete[] boardData;\r\n\r\n\t\t\tboardSize = other.boardSize;\r\n\t\t\tboardData = new char* [boardSize];\r\n\t\t\tfor (int i = 0; i < boardSize; i++) {\r\n\t\t\t\tboardData[i] = new char[boardSize];\r\n\t\t\t\tfor (int j = 0; j < boardSize; j++)\r\n\t\t\t\t\tboardData[i][j] = other.boardData[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tvoid print() const {\r\n\t\tfor (int i = 0; i < boardSize; i++) {\r\n\t\t\tfor (int j = 0; j < boardSize; j++) {\r\n\t\t\t\tcout << boardData[j][i];\r\n\t\t\t}\r\n\t\t\tcout << endl;\r\n\t\t}\r\n\t}\r\n\r\n\t~Board() {\r\n\t\tfor (int i = 0; i < boardSize; i++) {\r\n\t\t\tdelete[] boardData[i];\r\n\t\t}\r\n\t\tdelete[] boardData;\r\n\t}\r\n};\r\n\r\n\r\nvoid pawns_number(Board* board) {\t//info about quantity of all pawns in board [0;121]\r\n\tint sum = 0;\r\n\t//go throught all fields and increment 'sum' when I find char r or b\r\n\r\n\tfor (int i = 0; i < board->boardSize; i++) {\r\n\t\tfor (int ii = 0; ii < board->boardSize; ii++) {\r\n\t\t\tif (board->boardData[ii][i] == 'r' || board->boardData[ii][i] == 'b')\r\n\t\t\t\tsum++;\r\n\t\t}\r\n\t}\r\n\tif(sum>=0 && sum<=121)\r\n\t\tcout << sum;\r\n}\r\nvoid is_board_correct(Board* board) {\t//whether the number of red pawns is appropriate in relation to the number of blue pawns\r\n\tint red = 0;\r\n\tint blue = 0;\r\n\t//count red and blue pawns by going throught all fields, and then check the condition\r\n\tfor (int i = 0; i < board->boardSize; i++) {\r\n\t\tfor (int ii = 0; ii < board->boardSize; ii++) {\r\n\t\t\tif (board->boardData[ii][i] == 'r')\r\n\t\t\t\tred++;\r\n\t\t\telse if (board->boardData[ii][i] == 'b')\r\n\t\t\t\tblue++;\r\n\t\t}\r\n\t}\r\n\r\n\tif (red == blue || (red - 1) == blue) cout << \"YES\";\r\n\telse cout << \"NO\";\r\n}\r\n\r\n\r\n\r\n#define RIGHT 1\r\n#define LEFT 2\r\n#define UP 3\r\n#define DOWN 4\r\n\r\nbool traverse_the_board(Board* board, int row, int col, int direction, bool* whoWin) {\r\n\tif (row >= 0 && row < board->boardSize && col >= 0 && col < board->boardSize) {\t//warunek wejscia w funkcje\r\n\r\n\r\n\t\tif (direction = RIGHT) {\r\n\t\t\t//tutaj my\u0153l\u00ea nad wywo\u00b3aniem jeszcze raz funkcji rekurencyjnie ze zmienionymi koordynatami row i col je\u00bfeli znajd\u00ea 'r' i gdy dojd\u00ea do kraw\u00eadzi to zmieni\u00e6 whoWin na true\r\n\t\t}\r\n\t\tif (direction = LEFT) {\r\n\r\n\t\t}\r\n\t\tif (direction = UP) {\r\n\r\n\t\t}\r\n\t\tif (direction = DOWN) {\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid is_game_over(Board* board) {\r\n\r\n\tbool redWins = false;\r\n\tbool blueWins = false;\r\n\r\n\t//przechodzenie przez tablic\u00ea dla red\r\n\tfor (int i = 0; i < board->boardSize; i++) {\r\n\t\t\t//lawa czesc:\r\n\t\tif (board->boardData[i][0] == 'r') {\r\n\t\t\tfor (int j = 0; j < board->boardSize; j++) {\r\n\t\t\t\ttraverse_the_board(board, i, j, RIGHT, &redWins);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t//prawa czesc:\r\n\t\tif (board->boardData[i][board->boardSize-1] == 'r') {\r\n\t\t\tfor (int j = 0; j < board->boardSize; j++) {\r\n\t\t\t\ttraverse_the_board(board, i, j, LEFT, &redWins);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//przechodzenie przez tablic\u00ea dla blue\r\n\tfor (int i = 0; i < board->boardSize; i++) {\r\n\t\t//gorna czesc:\r\n\t\tif (board->boardData[0][i] == 'b') {\r\n\t\t\tfor (int j = 0; j < board->boardSize; j++) {\r\n\t\t\t\ttraverse_the_board(board, j, i, DOWN, &blueWins);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//dolna czesc:\r\n\t\tif (board->boardData[board->boardSize-1][i] == 'b') {\r\n\t\t\tfor (int j = 0; j < board->boardSize; j++) {\r\n\t\t\t\ttraverse_the_board(board, j, i, UP, &blueWins);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tif (redWins) cout << \"YES RED\";\r\n\telse if (blueWins) cout << \"YES BLUE\";\r\n\telse cout << \"NO\";\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nint read_size(char* buffer) {\r\n\tint i = 0;\r\n\twhile (buffer[i] == ' ') {\r\n\t\ti++;\r\n\t}\r\n\treturn ((i-1)/3)+1;\r\n}\r\n\r\nconst int sizeOfLine = 75;\r\n\r\nchar** read_board(int size) {\r\n\tchar buffer[sizeOfLine];\r\n\tchar** board = new char*[size];\t//tablica wska\u0178nik\u00f3w\r\n\r\n\tfor (int i = 0; i < size; i++) {\r\n\t\tboard[i] = new char[size];\t//tworzymy dla ka\u00bfdego wska\u0178nika tablic\u00ea element\u00f3w (charow), /",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass SimpleAccount {\nprotected:\n    string owner_name;\n    double initial_balance;\n    double interest_rate;\n    int years_existence;\n\npublic:\n    SimpleAccount(string name, double balance, double rate, int years)\n        : owner_name(name), initial_balance(balance), interest_rate(rate), years_existence(years) {}\n\n    virtual double calculateBalance() {\n        return initial_balance * (1 + interest_rate / 100 * years_existence);\n    }\n\n    virtual void printAccount() {\n        cout << \"Owner: \" << owner_name << endl;\n        cout << \"Initial Balance: $\" << initial_balance << endl;\n        cout << \"Interest Rate: \" << interest_rate << \"%\" << endl;\n        cout << \"Years Existence: \" << years_existence << endl;\n        cout << \"Balance: $\" << calculateBalance() << endl;\n    }\n};\n\nclass PrivilegedAccount : public SimpleAccount {\nprivate:\n    double credit_interest_rate;\n\npublic:\n    PrivilegedAccount(string name, double balance, double rate, int years, double credit_rate)\n        : SimpleAccount(name, balance, rate, years), credit_interest_rate(credit_rate) {}\n\n    double calculateBalance() override {\n        double base_balance = SimpleAccount::calculateBalance();\n        double available_credit = base_balance * (credit_interest_rate / 100);\n        return base_balance + available_credit;\n    }\n\n    void printAccount() override {\n        SimpleAccount::printAccount();\n        cout << \"Credit Interest Rate: \" << credit_interest_rate << \"%\" << endl;\n        cout << \"Available Credit: $\" << calculateBalance() - initial_balance << endl;\n    }\n};\n\nint main() {\n    SimpleAccount simple(\"John Doe\", 1000.0, 5.0, 3);\n    simple.printAccount();\n    cout << endl;\n\n    PrivilegedAccount privileged(\"Jane Smith\", 2000.0, 6.0, 5, 10.0);\n    privileged.printAccount();\n    cout << endl;\n\n    // Static polymorphism\n    cout << \"Using static polymorphism:\" << endl;\n    SimpleAccount* account1 = &simple;\n    SimpleAccount* account2 = &privileged;\n\n    account1->printAccount();\n    cout << endl;\n    account2->printAccount();\n    cout << endl;\n\n    // Dynamic polymorphism\n    cout << \"Using dynamic polymorphism:\" << endl;\n    SimpleAccount* accounts[2];\n    accounts[0] = &simple;\n    accounts[1] = &privileged;\n\n    for (int i = 0; i < 2; ++i) {\n        accounts[i]->printAccount();\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "#include<iostream.h>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nvoid checking();\r\nstatic int rooms=5, non_ac=3, ac=2, n=1, ac1=0, nac1=0,nac2=0, nac3=0, ac2=0, roomno=0;\r\nclass common\r\n{ private :\r\nfriend class calculator;\r\npublic:\r\nchar name[100],address[100];\r\n\r\nint s;\r\nint key,days,k,p;\r\nvoid intro();\r\nint asking();\r\nint choice();\r\nvoid personal();\r\nint detailed();\r\nint  rent(int );\r\nvoid clear_screen();\r\n};\r\nclass ac_room:public common\r\n{\r\npublic:\r\n};\r\nclass non_acroom:public common\r\n{\r\npublic:\r\n};\r\nvoid main()\r\n{ clrscr();\r\nnon_acroom nar[3];\r\nac_room ar[2];\r\ncommon c;\r\nint z,t;\r\nc.intro();\r\ndo\r\n{  int a=c.asking();\r\n   if(a==1)\r\n   {int b=c.choice();\r\n       if(b==1)\r\n       {\r\n\t  if(ac1==0)\r\n\t  { roomno=201;\r\n\t   ar[0].personal();\r\n\t   n=ar[0].rent(b);\r\n\t   ac1=1;\r\n\t  }\r\n\t  else if (ac2==0)\r\n\t  {roomno=202;\r\n\t   ar[1].personal();\r\n\t   n=ar[1].rent(b);\r\n\t   ac2=1;\r\n\r\n\t  }\r\n\t  else\r\n\t  { cout<<\"*******sorry no ac room is available at that time******* \"<<endl;\r\n\t     c.clear_screen();\r\n\t     cout<<\"for continue :   press 1\"<<endl;\r\n\t     cout<<endl<<endl;\r\n\t     cin>>z;\r\n\t     if(z==1)\r\n\t     n=1;\r\n\t     else\r\n\t     n=0;\r\n\r\n\t  }\r\n       }\r\n       else if (b==2)\r\n       {  if(nac1==0)\r\n\t  {  roomno=301;\r\n\t   nar[0].personal();\r\n\t   n= nar[0].rent(b);\r\n\t   nac1=1;\r\n\r\n\t  }\r\n\t  else if (nac2==0)\r\n\t  {roomno=302;\r\n\t   nar[1].personal();\r\n\t   n=nar[1].rent(b);\r\n\t   nac2=1;\r\n\r\n\t  }\r\n\t  else if (nac3==0)\r\n\t  { roomno=303;\r\n\t   nar[2].personal();\r\n\t   n=nar[2].rent(b);\r\n\t   nac3=1;\r\n\t  }\r\n\t  else\r\n\t  { cout<<\"******* sorry no non ac room is available at that time******** \"<<endl;\r\n\t    c.clear_screen();\r\n\t    cout<<\"for continue :   press 1\"<<endl;\r\n\t     cin>>z;\r\n\t     cout<<endl<<endl;\r\n\t     if(z==1)\r\n\t     n=1;\r\n\t     else\r\n\t     n=0;\r\n\r\n\t  }\r\n       }\r\n       else\r\n       {\r\n\t cout<<\"wrong entry \"<<endl;\r\n\t cout<<\"for again :press 1 \"<<endl;\r\n\t cout<<\"for quit press any key (from 2 to 9)\"<<endl;\r\n\t cin>>z;\r\n\t if(z==1)\r\n\t {n=1;}\r\n\t else\r\n\t {n=0;}\r\n       }\r\n\r\n   }\r\n   else if(a==2)\r\n   {\r\n     n= c.detailed();\r\n   }\r\n   else if (a==3)\r\n   {\r\n   cout<<\"enter room type: \"<<endl;\r\ncout<<\"for ac : press 1\"<<endl<<\"for non ac :  press 2\"<<endl;\r\ncin>>z;\r\nif(z==1)\r\n{  cout<<\"enter your room no\"<<endl;\r\ncin>>roomno;\r\nif(roomno==201)\r\n{ ac1=0;\r\nac++;\r\nrooms++;\r\n\r\ncout<<\"so your booking is cancel for room no 201 \";\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncin>>t;\r\ncout<<endl;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse if(roomno==202)\r\n{ ac2=0;\r\nac++;\r\nrooms++;\r\n\r\ncout<<\"so your booking is cancel for room no 202 \";\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncout<<endl;\r\ncin>>t;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse\r\n{cout<<\"your room no is wrong\";\r\nn=0;\r\n}\r\n}\r\nelse if(z==2)\r\n{\r\n cout<<\"enter your room no\"<<endl;\r\ncin>>roomno;\r\nif(roomno==301)\r\n{ nac1=0;\r\ncout<<\"*****so your booking is cancel for room no 301****** \";\r\nnac1++;\r\nrooms++;\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncin>>t;\r\ncout<<endl;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse if(roomno==302)\r\n{ nac2=0;\r\nnac2++;\r\nrooms++;\r\n\r\ncout<<\"so your booking is cancel for room no 302 \";\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncout<<endl<<endl;\r\ncin>>t;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse if(roomno==303)\r\n{ nac3=0;\r\ncout<<\"******so your booking is cancel for room no 303***** \";\r\nnac3++;\r\nrooms++;\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\"<<endl;\r\ncin>>t;\r\ncout<<endl<<endl;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse\r\n{cout<<\"your room no is wrong\"<<endl;\r\nn=0;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse if (a==4)\r\n{\r\n cout<<\"enter room number\"<<endl;\r\n cin>>roomno;\r\n if(roomno==201)\r\n {\r\n   if(ac1==1)\r\n   {\r\n   cout<<\"name   :   \"<<ar[0].name   <<endl;\r\n   cout<<\"address  :  \"<<ar[0].address<<endl;\r\n   cout<<\"booking  :  \"<<ar[0].days<<\" days \"<<endl;\r\n    c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n    n=0;\r\n\r\n   }\r\n   else\r\n   {cout<<\"sorry ,this is empty room \"<<endl;\r\n    c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n    n=0;\r\n   }\r\n }\r\nelse if(roomno==202)\r\n {\r\n   if(ac2==1)\r\n   {\r\n   cout<<\"name   :   \"<<ar[1].name   <<endl;\r\n   cout<<\"address  :  \"<<ar[1].address<<endl;\r\n   cout<<\"booking  :  \"<<ar[1].days<<\" days \"<<endl;\r\n       c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n    n=0;\r\n\r\n   }\r\n   else\r\n   {cout<<\"sorry ,this is empty room \"<<endl;\r\n       c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n",
    "#include <wchar.h>\n#include <iostream>\n#include <audioclientactivationparams.h>\n\n#include \"LoopbackCapture.h\"\n\n#define BITS_PER_BYTE 8\n\nHRESULT CLoopbackCapture::SetDeviceStateErrorIfFailed(HRESULT hr)\n{\n    if (FAILED(hr))\n    {\n        m_DeviceState = DeviceState::Error;\n    }\n    return hr;\n}\n\nCLoopbackCapture::CLoopbackCapture() {\n    // The app can also call m_AudioClient->GetMixFormat instead to get the capture format.\n    // 16 - bit PCM format.\n    m_CaptureFormat.wFormatTag = WAVE_FORMAT_PCM;\n    m_CaptureFormat.nChannels = 2;\n    m_CaptureFormat.nSamplesPerSec = 48000;\n    m_CaptureFormat.wBitsPerSample = 16;\n    m_CaptureFormat.nBlockAlign = m_CaptureFormat.nChannels * m_CaptureFormat.wBitsPerSample / BITS_PER_BYTE;\n    m_CaptureFormat.nAvgBytesPerSec = m_CaptureFormat.nSamplesPerSec * m_CaptureFormat.nBlockAlign;\n\n    BYTE empty_data = {1};\n    m_emptyData.data = &empty_data;\n    m_emptyData.length = 0;\n}\n\nHRESULT CLoopbackCapture::InitializeLoopbackCapture()\n{\n    // Create events for sample ready or user stop\n    RETURN_IF_FAILED(m_SampleReadyEvent.create(wil::EventOptions::None));\n\n    // Initialize MF\n    RETURN_IF_FAILED(MFStartup(MF_VERSION, MFSTARTUP_LITE));\n\n    // Register MMCSS work queue\n    DWORD dwTaskID = 0;\n    RETURN_IF_FAILED(MFLockSharedWorkQueue(L\"Capture\", 0, &dwTaskID, &m_dwQueueID));\n\n    // Set the capture event work queue to use the MMCSS queue\n    m_xSampleReady.SetQueueID(m_dwQueueID);\n\n    // Create the completion event as auto-reset\n    RETURN_IF_FAILED(m_hActivateCompleted.create(wil::EventOptions::None));\n\n    // Create the capture-stopped event as auto-reset\n    RETURN_IF_FAILED(m_hCaptureStopped.create(wil::EventOptions::None));\n\n    return S_OK;\n}\n\nCLoopbackCapture::~CLoopbackCapture()\n{\n    if (m_dwQueueID != 0)\n    {\n        MFUnlockWorkQueue(m_dwQueueID);\n    }\n}\n\nHRESULT CLoopbackCapture::ActivateAudioInterface(DWORD processId, bool includeProcessTree)\n{\n    return SetDeviceStateErrorIfFailed([&]() -> HRESULT\n        {\n            AUDIOCLIENT_ACTIVATION_PARAMS audioclientActivationParams = {};\n            audioclientActivationParams.ActivationType = AUDIOCLIENT_ACTIVATION_TYPE_PROCESS_LOOPBACK;\n            audioclientActivationParams.ProcessLoopbackParams.ProcessLoopbackMode = includeProcessTree ?\n                PROCESS_LOOPBACK_MODE_INCLUDE_TARGET_PROCESS_TREE : PROCESS_LOOPBACK_MODE_EXCLUDE_TARGET_PROCESS_TREE;\n            audioclientActivationParams.ProcessLoopbackParams.TargetProcessId = processId;\n\n            PROPVARIANT activateParams = {};\n            activateParams.vt = VT_BLOB;\n            activateParams.blob.cbSize = sizeof(audioclientActivationParams);\n            activateParams.blob.pBlobData = (BYTE*)&audioclientActivationParams;\n\n            wil::com_ptr_nothrow<IActivateAudioInterfaceAsyncOperation> asyncOp;\n            RETURN_IF_FAILED(ActivateAudioInterfaceAsync(VIRTUAL_AUDIO_DEVICE_PROCESS_LOOPBACK, __uuidof(IAudioClient), &activateParams, this, &asyncOp));\n\n            // Wait for activation completion\n            m_hActivateCompleted.wait();\n\n            return m_activateResult;\n        }());\n}\n\nvoid CLoopbackCapture::SetAudioFormat(WORD channels, DWORD sampleRate, WORD bitsPerSample){\n    m_CaptureFormat.wFormatTag = WAVE_FORMAT_PCM;\n    m_CaptureFormat.nChannels = channels;\n    m_CaptureFormat.nSamplesPerSec = sampleRate;\n    m_CaptureFormat.wBitsPerSample = bitsPerSample;\n    m_CaptureFormat.nBlockAlign = m_CaptureFormat.nChannels * m_CaptureFormat.wBitsPerSample / BITS_PER_BYTE;\n    m_CaptureFormat.nAvgBytesPerSec = m_CaptureFormat.nSamplesPerSec * m_CaptureFormat.nBlockAlign;\n}\n\n//\n//  ActivateCompleted()\n//\n//  Callback implementation of ActivateAudioInterfaceAsync function.  This will be called on MTA thread\n//  when results of the activation are available.\n//\nHRESULT CLoopbackCapture::ActivateCompleted(IActivateAudioInterfaceAsyncOperation* operation)\n{\n    m_activateResult = SetDeviceStateErrorIfFailed([&]()->HRESULT\n        {\n            // Check for a successful activation result\n            HRESULT hrActivateResult = E_UNEXPECTED;\n            wil::com_ptr_nothrow<IUnknown> punkAudioInterface;\n            RETURN_IF_FAILED(operation->GetActivateResult(&hrActivateResult, &punkAudioInterface));\n            RETURN_IF_FAILED(hrActivateResult);\n\n            // Get the pointer for the Audio Client\n            RETURN_IF_FAILED(punkAudioInterface.copy_to(&m_AudioClient));\n\n            // Initialize the AudioClient in Shared Mode with the user specified buffer\n            RETURN_IF_FAILED(m_AudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED,\n                AUDCLNT_STREAMFLAGS_LOOPBACK | AUDCLNT_STREAMFLAGS_EVENTCALLBACK,\n                200000,\n                AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM,\n                &m_CaptureFormat,\n                nullptr));\n\n            // Get the maximum size of the AudioClient Buffer\n            RETURN_IF_FAILED(m_AudioClient->GetBufferSize(&m_BufferFrames));\n\n            // Get the capture client\n      ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <string>\n#include <iostream>\n#include <cctype>\n\nbool stringIsNumber(std::string stringToCheck) {\n\tfor (int i = 0; i < stringToCheck.length(); i++) {\n\t\tif (!isdigit(stringToCheck[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint stringToChange(std::string change) {\n\tint result = 0;\n\n\t// Search for \"$\" and \".\" and removes them\n\tstd::size_t found = change.find(\"$\");\n\n\tif (found != std::string::npos) {\n\t\tchange.erase(change.begin() + found);\n\t}\n\n\tfound = change.find(\".\");\n\tif (found != std::string::npos) {\n\t\tchange.erase(change.begin() + found);\n\t}\n\n\tbool isNumber = stringIsNumber(change);\n\n\tif (!isNumber) {\n\t\tstd::cout << \"There was an error converting the string to a number\" << std::endl;\n\t\texit(1);\n\t}\n\n\treturn stoi(change);\n}\n\nint main() {\n\t// Format [\"$12.30\"]\n\tstd::string change;\n\t\n\tstd::cout << \"(Format: $12.30)\" << std::endl;\n\tstd::cout << \"Please input the cash amount: \";\n\tstd::cin >> change;\n\n\tint changeAsInt = stringToChange(change);\n\n\tint quarters, dimes, nickles, pennies;\n\tquarters = dimes = nickles = pennies = 0;\n\n\twhile (changeAsInt > 0) {\n\t\tif (changeAsInt >= 100) {\n\t\t\tint tempVal = changeAsInt / 100;\n\t\t\tquarters = tempVal * 4;\n\t\t\tchangeAsInt -= tempVal * 100;\n\t\t}\n\t\telse if (changeAsInt >= 10) {\n\t\t\tdimes = changeAsInt / 10;\n\t\t\tchangeAsInt -= dimes * 10;\n\t\t}\n\t\telse if (changeAsInt >= 5) {\n\t\t\tnickles = changeAsInt / 5;\n\t\t\tchangeAsInt -= nickles * 5;\n\t\t}\n\t\telse if (changeAsInt >= 1) {\n\t\t\tpennies = changeAsInt;\n\t\t\tchangeAsInt -= changeAsInt;\n\t\t}\n\t}\n\n\t//std::cout << \"Cash: \" << change << std::endl;\n\tstd::cout << \"Quarters: \" << quarters << \", Dimes: \" << dimes << \", Nickles: \" << nickles << \", Pennies: \" << pennies << std::endl;\n\n\n\treturn 0;\n}",
    "#include<iostream>\nusing namespace std;\nconst char *nombre_archivo = \"archivo.dat\";\nstruct Estudiante{\n\tint codigo;\n\tchar nombre[50];\n\tchar apellidos[50];\n\tint telefono;\n};\n\nvoid Leer();\nvoid Crear();\nvoid Actualizar();\nvoid Borrar();\nmain(){\n\tLeer();\n\tCrear();\n\tBorrar();\n\tActualizar();\n\t\n\tsystem(\"Pause\");\n}\nvoid Leer(){\n\tsystem(\"cls\");\n\tFILE* archivo = fopen(nombre_archivo,\"rb\");\n\tif(!archivo){\n\t\tarchivo = fopen(nombre_archivo,\"w+b\");\n\t}\n\tEstudiante estudiante;\n\tint id=0;\n\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\tcout<<\"---------------------------\"<<endl;\n\tcout<<\"ID\"<<\"|\"<<\"Codigo\"<<\"|\"<<\"Nombres\"<<\"|\"<<\"Apellidos\"<<\"|\"<<\"Telefono\"<<endl;\n\tdo{\n\t\tcout<<id<<\"|\"<<estudiante.codigo<<\"|\"<<estudiante.nombre<<\"|\"<<estudiante.apellidos<<\"|\"<<estudiante.telefono<<endl;\n\t\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\t\tid+=1;\n\t}while(feof(archivo)==0);\n\tfclose(archivo);\n}\n\t\n\t\nvoid Crear(){\n\tFILE* archivo = fopen(nombre_archivo,\"a+b\");\n\tchar res;\n\tEstudiante estudiante;\n\tdo{\n\t\tfflush(stdin);\n\t\t\n\t\tcout<<\"Ingrese Codigo: \";\n\t\tcin>>estudiante.codigo;\n\t\tcin.ignore();\n\t\t\n\t\tcout<<\"Ingrese Nombres: \";\n\t\tcin.getline(estudiante.nombre,50);\n\t\t\n\t\tcout<<\"Ingrese Apellidos: \";\n\t\tcin.getline(estudiante.apellidos,50);\n\t\t\n\t\tcout<<\"Ingrese Telefono: \";\n\t\tcin>>estudiante.telefono;\n\t\t\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\tcout<<\"Desea Ingresar Otro Estudiante (S/N): \";\n\t\tcin>>res;\n\t}while(res=='s' || res=='S');\n\tfclose(archivo);\n\tLeer();\n}\nvoid Actualizar(){\n\t\n\tFILE* archivo = fopen(nombre_archivo,\"r+b\");\n\tEstudiante estudiante;\n\tint id=0;\n\tcout<<\"Ingrese el ID desea modificar: \";\n\tcin>>id;\n\tfseek(archivo,id * sizeof(Estudiante),SEEK_SET);\n\t\t\n\t\tcout<<\"Ingrese Codigo: \";\n\t\tcin>>estudiante.codigo;\n\t\tcin.ignore();\n\t\t\n\t\tcout<<\"Ingrese Nombres: \";\n\t\tcin.getline(estudiante.nombre,50);\n\t\t\n\t\tcout<<\"Ingrese Apellidos: \";\n\t\tcin.getline(estudiante.apellidos,50);\n\t\t\n\t\tcout<<\"Ingrese Telefono: \";\n\t\tcin>>estudiante.telefono;\n\t\t\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\n\tfclose(archivo);\n\tLeer();\n}\nvoid Borrar(){\n\tconst char *nombre_archivo_temp = \"archivo_temp.dat\";\n\tFILE* archivo = fopen(nombre_archivo,\"rb\");\n\tFILE* archivo_temp = fopen(nombre_archivo_temp,\"w+b\");\n\tEstudiante estudiante;\n\tint id=0,id_n=0;\n\tcout<<\"Ingrese el ID a Eliminar: \";\n\tcin>>id;\n\twhile(fread(&estudiante,sizeof(Estudiante),1,archivo)){\n\t\tif (id_n!=id){\n\t\t\tfread(&estudiante,sizeof(Estudiante),1,archivo_temp);\n\t\t}\n\t\tid_n++;\n\t}\n\tfclose(archivo);\n\tfclose(archivo_temp);\n\n\t\n\tarchivo_temp = fopen(nombre_archivo_temp,\"rb\");\n\tarchivo = fopen(nombre_archivo,\"wb\");\n\twhile(fread(&estudiante,sizeof(Estudiante),1,archivo_temp)){\n\t\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\t\t\n\t}\n\tfclose(archivo);\n\tfclose(archivo_temp);\n\tLeer();\n}\n",
    "#include \"sound.hpp\"\n\n#include <climits>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\nSound::Sound(string fname) {\n  ifstream fin;\n  char tag[4];\n  int buf4;\n  short buf2;\n  int blockSize;\n  m_x = nullptr;\n  cerr << \"Read file: \" << fname << endl;\n  fin.open(fname, ios::in | ios::binary);\n  if (!fin) {\n    cerr << \"Cannot open file: \" << fname << endl;\n    return;\n  }\n  fin.read(tag, 4);  // \"RIFF\"\n  if (strncmp(tag, \"RIFF\", 4)) {\n    cerr << \"File is not RIFF format.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf4, 4);  // RIFF\u30c1\u30e3\u30f3\u30af\u30b5\u30a4\u30ba\n  fin.read(tag, 4);            // \"WAVE\"\n  if (strncmp(tag, \"WAVE\", 4)) {\n    cerr << \"File is not WAVE format.\" << endl;\n    return;\n  }\n  fin.read(tag, 4);  // \"fmt \"\n  if (strncmp(tag, \"fmt \", 4)) {\n    cerr << \"fmt chunk is invalid.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf4, 4);  // fmt\u30c1\u30e3\u30f3\u30af\u30b5\u30a4\u30ba\n  if (buf4 != 16) {\n    cerr << \"Unsupported format.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf2, 2);  // \u97f3\u58f0\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\n  fin.read((char *)&buf2, 2);  // \u30c1\u30e3\u30cd\u30eb\u6570\n  m_nChannels = buf2;\n  fin.read((char *)&buf4, 4);  // \u30b5\u30f3\u30d7\u30eb\u30ec\u30fc\u30c8\n  m_fs = buf4;\n  cerr << m_fs << \" Hz\" << endl;\n  fin.read((char *)&buf4, 4);  // bytes / sec\n  fin.read((char *)&buf2, 2);  // \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\n  blockSize = buf2;\n  fin.read((char *)&buf2, 2);  // \u30d3\u30c3\u30c8\u6df1\u5ea6\n  fin.read(tag, 4);            // \"data\"\n  if (strncmp(tag, \"data\", 4)) {\n    cerr << \"data chunk not found.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf4, 4);  // data\u30c1\u30e3\u30f3\u30af\u30b5\u30a4\u30ba\n  m_nSamples = buf4 / blockSize;\n  m_duration = (double)m_nSamples / m_fs;\n  cerr << m_duration << \" sec\" << endl;\n  m_x = new double[m_nSamples];\n  for (int n = 0; n < m_nSamples; n++) {\n    fin.read((char *)&buf2, 2);\n    m_x[n] = (double)(buf2 + (SHRT_MAX + 1.0) + 0.5) / (SHRT_MAX + 1.0) - 1.0;\n  }\n  fin.close();\n  // m_fft = new FFT(16, Window::Gaussian, m_fs);\n}\n\nSound::~Sound() {\n  if (m_x != nullptr) {\n    delete[] m_x;\n  }\n}\n\nint main(int argc, char **argv) {\n  string fname = \"/home/ymsn325/audio/ichimoji_PF02_0501_033.wav\";\n  Sound sound(fname);\n  int nFFT = 2048;\n  double fs = 44100.0;\n  FFT fft(nFFT, Window::Gaussian, fs);\n  double x[nFFT];\n  complex<double> X[nFFT];\n  double f = 1000.0;\n  for (int n = 0; n < nFFT; n++) {\n    x[n] = sin(2.0 * M_PI * f * n / fs);\n  }\n  fft.exec(x, X);\n  for (int k = 0; k < nFFT; k++) {\n    cout << abs(X[k]) << endl;\n  }\n  return 0;\n}",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <locale.h>\r\n#include <stdlib.h> // Para a fun\u00e7\u00e3o system()\r\nint main() {\r\n\tsetlocale(LC_ALL, \"Portuguese\"); // Configura a localiza\u00e7\u00e3o para Portugu\u00eas\r\n\r\n\t\r\n    char username[20];\r\n    char password[20];\r\n    int accessLevel = 0; // 0: n\u00edvel padr\u00e3o, 1: n\u00edvel de usu\u00e1rio, 2: n\u00edvel de administrador\r\n\r\n    // Solicita o nome de usu\u00e1rio e senha\r\n    printf(\"Digite o nome de usu\u00e1rio: \");\r\n    scanf(\"%s\", username);\r\n    printf(\"Digite a senha: \");\r\n    scanf(\"%s\", password);\r\n\r\n    // Verifica as credenciais\r\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, \"admin123\") == 0) {\r\n        accessLevel = 2; // N\u00edvel de administrador\r\n    } else if (strcmp(username, \"usuario1\") == 0 && strcmp(password, \"senha123\") == 0) {\r\n        accessLevel = 1; // N\u00edvel de funcion\u00e1rio regular\r\n    } else if (strcmp(username, \"visitante\") == 0 && strcmp(password, \"visitante123\") == 0) {\r\n        accessLevel = 0; // N\u00edvel de convidado\r\n    } else {\r\n        accessLevel = -1; // Credenciais inv\u00e1lidas\r\n    }\r\n\r\n    // Exibe a mensagem apropriada com base no n\u00edvel de acesso\r\n    switch (accessLevel) {\r\n        case 2:\r\n            printf(\"Bem-vindo, administrador %s! Acesso concedido total.\\n\", username);\r\n            break;\r\n        case 1:\r\n            printf(\"Bem-vindo, funcion\u00e1rio regular %s! Acesso concedido limitado.\\n\", username);\r\n            break;\r\n        case 0:\r\n            printf(\"Bem-vindo, visitante %s! Acesso extremamente limitado.\\n\", username);\r\n            break;\r\n        default:\r\n            printf(\"Credenciais inv\u00e1lidas. Acesso negado.\\n\");\r\n    }\r\n    \r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n\r\n",
    "class Solution {\npublic:\n    int countStudents(vector<int>& students, vector<int>& sandwiches) {\n        bool noChange = true;\n        int top = 0, delCount = 0;\n        while(noChange){\n            noChange = true;\n            if(delCount * 2 > students.size()){\n                erase_if(students, [](int x) {return (x == -1) ? true : false;});\n                erase_if(sandwiches, [](int x) {return (x == -1) ? true : false;});\n                delCount = 0;\n                top = 0;\n            }\n            for(int i = 0; i < students.size() && top < sandwiches.size(); i++){\n                if(students[i] == sandwiches[top]){\n                    students[i] = -1;\n                    sandwiches[top++] = -1;\n                    delCount++;\n                    noChange = false;\n                }\n                else if(students[i] == -1) continue;\n            }\n            if(top == sandwiches.size()) return 0;\n            if(noChange){\n                erase_if(students, [](int x) { return (x == -1) ? true : false;});\n                top = 0; delCount = 0;\n                break;\n            }\n            else{\n                noChange = true;\n            }\n        }\n        return students.size();\n    }\n};\n",
    "#include <iostream>\n\n#include \"Stale.h\"\n\nint main() {\n    char ch;\n    int nastepnaLinia = FALSE;\n    int inputPlansza = TRUE;\n    int iloscB = 0, iloscR = 0;\n\n    int iloscIinii = 0;\n    int kolumna = 0;\n    int zmiennaLinii = 0;\n\n    char hexWTablicy[MAXSIZE][MAXSIZE];\n\n    //wypelnienie tablicy pustymi polami\n    for (int i = 0; i < MAXSIZE; i++){\n        for (int j = 0; j < MAXSIZE; j++){\n            hexWTablicy[j][i] = ' ';\n        }\n    }\n\n    //wypelnianie planszy na tablice 2d\n\n    while (inputPlansza){\n        ch = std::cin.get();\n\n        if (ch == '-'){\n            if (nastepnaLinia) nastepnaLinia = FALSE;\n        }\n        else if (ch == '<'){\n            if (nastepnaLinia){\n                iloscIinii = zmiennaLinii;\n                nastepnaLinia = FALSE;\n            }\n            kolumna++;\n\n        }\n        else if (ch == 'b'){\n            iloscB ++ ;\n            hexWTablicy[kolumna-1][zmiennaLinii] = 'b';\n        }\n        else if (ch == 'r') {\n            iloscR ++ ;\n            hexWTablicy[kolumna-1][zmiennaLinii] = 'r';\n        }\n        else if (ch == '\\n') {\n            kolumna = 0;\n            zmiennaLinii++;\n            nastepnaLinia = TRUE;\n        }\n        else if (ch == '>'){\n            if (hexWTablicy[kolumna-1][zmiennaLinii] != 'r' && hexWTablicy[kolumna-1][zmiennaLinii] != 'b') hexWTablicy[kolumna-1][zmiennaLinii] = 'n';\n        }\n\n        if (iloscIinii != 0 && iloscIinii*2+1 == zmiennaLinii) inputPlansza = FALSE;\n    }\n\n    std::cout << iloscIinii << std::endl << std::endl;\n    std::cout << iloscB+iloscR << std::endl << std::endl;\n\n    for (int i = 0; i < MAXSIZE; i++){\n        for (int j = 0; j < MAXSIZE; j++){\n            std::cout << hexWTablicy[j][i] << ' ';\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <time.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n\n//ROS\n#include <ros/ros.h>\n#include <std_msgs/Bool.h>\n#include <std_msgs/Int8.h>\n#include <std_msgs/String.h> \n#include <geometry_msgs/Pose.h>\n#include <moveit/move_group_interface/move_group_interface.h>\n#include <tf/tf.h>\n#include <tf/LinearMath/Matrix3x3.h>\n#include <tf/LinearMath/Vector3.h>\n#include <tf/transform_listener.h>\n#include <tf/transform_broadcaster.h>\n\n// Custom msg & srv\n#include <detection_msgs/Detection2DTrig.h>\n#include <detection_msgs/Det3D.h>\n#include <detection_msgs/Det3DArray.h>\n#include <detection_msgs/StringArray.h>\n\n#include <walker_msgs/Detection2DTrigger.h>\n#include <walker_msgs/Det3D.h>\n#include <walker_msgs/Det3DArray.h>\n\n#include <visualization_msgs/MarkerArray.h>\n\n//gripper\n#include <actionlib/client/simple_action_client.h>\n#include <control_msgs/GripperCommandActionGoal.h>\n#include <control_msgs/GripperCommandAction.h>\n#include <control_msgs/GripperCommandGoal.h>\n\nusing namespace std;\nclass warehouse_action\n{\nprivate:\n    std_msgs::Bool grip;\n    const string PLANNING_GROUP = \"tm_arm\";\n    char command;\n    const vector<double> home_p = {-M_PI_2, -M_PI_4, M_PI*2/3, -1.309, M_PI, 0.000};\n    const vector<double> home_p_2 = {-M_PI_2, -M_PI_4, M_PI*2/3, -1.309, M_PI_2, 0.000};\n    const vector<double> home_r = {M_PI, M_PI/3, -M_PI_4*3, 1.309, -M_PI_2, 0.0};\n    const vector<double> middle1_a = {-M_PI, -M_PI_4, M_PI*2/3, -1.309, M_PI, 0.000};\n    const vector<double> middle1_b = {-2.552, -0.527, 2.218, -1.679, 1.009, 0.000};\n    const vector<double> middle2_a = {0, -M_PI_4, M_PI*2/3, -1.309, M_PI, 0.000};\n    const vector<double> middle2_b = {3.344, -1.023, 2.259, -1.218, 1.285, 0.000};\n    const vector<double> middler_p = {M_PI_2, -M_PI/3, M_PI_4*3, -1.309, -M_PI_2, 0.0};\n    const vector<double> middlep_r = {0.000, 0.000, 0.000, 0.000, -M_PI_2, 0.0};\n    const vector<double> position_s = {0, M_PI/3, -M_PI_4*3, 1.309, 0.000, 0.000}; //M_PI_4*3\n\n    const vector<double> joint_sh_scan = {-M_PI_2, -M_PI_4, M_PI*2/3, -1.309, 2.800, 0.000};\n\n    // const vector<double> joint_wh_scan3 = {-0.305, 0.485, 1.635, -1.953, 0.293, 0.160};\n    // const vector<double> joint_wh_scan2 = {-0.772, -0.048, 2.320, -2.200, 0.758, 0.056};\n    // const vector<double> joint_wh_scan1 = {-1.564, 0.014, 2.261, -2.227, 1.549, 0.003};\n\n    const vector<double> joint_wh_scan2 = {-0.362, 0.002, 2.369, -2.270, 0.350, 0.133};\n    const vector<double> joint_wh_scan1 = {-1.564, -0.518, 2.621, -2.082, M_PI_2, 0.000};\n\n    const vector<double> joint_place1 = {-3.133, 0.180, 2.279, -2.450, 1.545, 0.000};\n    const vector<double> joint_place1_mid = {-3.133, -0.282, 2.255, -2.234, 1.547, 0.002};\n    const vector<double> joint_place2 = {-2.583, 0.183, 2.462, -2.644, 1.019, 0.000};\n    const vector<double> joint_place2_mid = {-2.822, -0.355, 2.231, -2.045, 1.473, 0.016};\n    const vector<double> joint_place3 = {-0.020, 0.269, -1.979, -1.416, 1.551, 3.130};\n    const vector<double> joint_place3_mid = {-0.028, 0.410, -1.616, -1.813, 1.544, 3.041};\n    const vector<double> joint_place4 = {3.181, -0.120,2.709, -2.586, 1.454, 0.034};\n    const vector<double> joint_place4_mid = {3.344, -1.023, 2.259, -1.218, 1.285, 0.028};\n    const vector<double> joint_place5 = {0.012, 0.647, -2.194, -1.579, 1.552, 3.040};\n    const vector<double> joint_place5_mid = {0.002, 0.755, -1.787, -2.089, 1.533, 3.035};\n\n    const vector<double> joint_place_tag = {-1.558, -0.568, 2.070, -1.501, 1.555, 0.000};\n\n    float *x_tmp, *y_tmp, *z_tmp;\n    int count = 0, target_amount = 0, target_number = 0;\n    bool find = false, grab = false, collect = false, reach = false;\n    std_msgs::Int8 replacement_finished;\n    detection_msgs::Det3DArray target_bias;\n    detection_msgs::Det3D bias;\npublic:\n    warehouse_action(ros::NodeHandle nh);\n    void dope_callback(walker_msgs::Det3DArray msg);\n    void det_callback(detection_msgs::Det3DArray msg);\n    void mis_callback(detection_msgs::StringArray msg);\n    void loc_callback(std_msgs::Int8 msg);\n    void Position_Manager();\n\n\n    ros::Publisher gripper_pub;\n    ros::Publisher mis_pub;\n    ros::Publisher prod_pub;\n    ros::Publisher replace_finish_pub;\n    ros::Subscriber dope_sub;\n    ros::Subscriber det_sub;\n    ros::Subscriber mis_sub;\n    ros::Subscriber loc_sub;\n    geometry_msgs::Pose current_pose, tag_pose;\n    detection_msgs::StringArray mis_list, sa, prod_list;\n    walker_msgs::Det3DArray dope_list;\n};\n\nwarehouse_action::warehouse_action(ros::NodeHandle nh)\n{  \n    ros::AsyncSpinner spinner(1); \n    spinner.start();\n\n    x_tmp = new float[10] ();\n    y_tmp = new float[10] ();\n    z_tmp = new float[10] ();\n\n    gripper_pub = nh.advertise<std_msgs::Bool>(\"/gripper_controller/cmd_gripper\", 1);\n    prod_pub = nh.advertise<detection_msgs::StringArray>(\"/product/information\", 1);\n    replace_finish_pub = nh.advertise<std_msgs::Int8>(\"/replacement_finished\", 1);\n    dope_sub = nh.subscribe(\"/det3",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"pixelstats\"\n\n#include <android-base/logging.h>\n#include <pixelstats/SysfsCollector.h>\n#include <pixelstats/UeventListener.h>\n\n#include <thread>\n\n#include <pixelstats/SysfsCollector.h>\n#include <pixelstats/UeventListener.h>\n\nusing android::hardware::google::pixel::SysfsCollector;\nusing android::hardware::google::pixel::UeventListener;\n\n#define BLOCK_STATS_LENGTH 17\n#define UFSHC_PATH(filename) \"/dev/sys/block/bootdevice/\" #filename\n#define UFS_ERR_PATH(err_type) UFSHC_PATH(err_stats/) #err_type\nconst struct SysfsCollector::SysfsPaths sysfs_paths = {\n    .SlowioReadCntPath = UFSHC_PATH(slowio_read_cnt),\n    .SlowioWriteCntPath = UFSHC_PATH(slowio_write_cnt),\n    .SlowioUnmapCntPath = UFSHC_PATH(slowio_unmap_cnt),\n    .SlowioSyncCntPath = UFSHC_PATH(slowio_sync_cnt),\n    .CycleCountBinsPath = \"/sys/class/power_supply/battery/cycle_counts\",\n    .UFSLifetimeA = UFSHC_PATH(health_descriptor/life_time_estimation_a),\n    .UFSLifetimeB = UFSHC_PATH(health_descriptor/life_time_estimation_b),\n    .UFSLifetimeC = UFSHC_PATH(health_descriptor/life_time_estimation_c),\n    .F2fsStatsPath = \"/sys/fs/f2fs/\",\n    .ImpedancePath = \"/sys/devices/platform/audiometrics/speaker_impedance\",\n    .CodecPath =     \"/sys/devices/platform/audiometrics/codec_state\",\n    .EEPROMPath = \"/dev/battery_history\",\n    .MitigationPath = \"/sys/devices/virtual/pmic/mitigation\",\n    .MitigationDurationPath = \"/sys/devices/virtual/pmic/mitigation/irq_dur_cnt\",\n    .BrownoutReasonProp = \"vendor.brownout_reason\",\n    .BrownoutLogPath = \"/data/vendor/mitigation/lastmeal.txt\",\n    .SpeakerTemperaturePath = \"/sys/devices/platform/audiometrics/speaker_temp\",\n    .SpeakerExcursionPath = \"/sys/devices/platform/audiometrics/speaker_excursion\",\n    .SpeakerHeartBeatPath = \"/sys/devices/platform/audiometrics/speaker_heartbeat\",\n    .UFSErrStatsPath = {\n        UFS_ERR_PATH(pa_err_count),\n        UFS_ERR_PATH(dl_err_count),\n        UFS_ERR_PATH(nl_err_count),\n        UFS_ERR_PATH(tl_err_count),\n        UFS_ERR_PATH(dme_err_count),\n        UFS_ERR_PATH(fatal_err_count),\n        UFS_ERR_PATH(auto_hibern8_err_count)\n    },\n    .BlockStatsLength = BLOCK_STATS_LENGTH,\n    .AmsRatePath = \"/sys/devices/platform/audiometrics/ams_rate_read_once\",\n    .MitigationPath = \"/sys/devices/virtual/pmic/mitigation\",\n    .ThermalStatsPaths = {\n        \"/sys/devices/platform/100a0000.BIG/trip_counter\",\n        \"/sys/devices/platform/100a0000.MID/trip_counter\",\n        \"/sys/devices/platform/100a0000.LITTLE/trip_counter\",\n        \"/sys/devices/platform/100b0000.G3D/trip_counter\",\n        \"/sys/devices/platform/100b0000.TPU/trip_counter\",\n        \"/sys/devices/platform/100b0000.AUR/trip_counter\",\n    },\n    .CCARatePath = \"/sys/devices/platform/audiometrics/cca_count_read_once\",\n    .TempResidencyAndResetPaths = {\n        {\n            \"/sys/kernel/metrics/thermal/tr_by_group/tmu/stats\",\n            \"/sys/kernel/metrics/thermal/tr_by_group/tmu/stats_reset\"\n        },\n        {\n            \"/sys/kernel/metrics/thermal/tr_by_group/spmic/stats\",\n            \"/sys/kernel/metrics/thermal/tr_by_group/spmic/stats_reset\"\n        }\n    },\n    .ResumeLatencyMetricsPath = \"/sys/kernel/metrics/resume_latency/resume_latency_metrics\",\n    .LongIRQMetricsPath = \"/sys/kernel/metrics/irq/long_irq_metrics\",\n    .StormIRQMetricsPath = \"/sys/kernel/metrics/irq/storm_irq_metrics\",\n    .IRQStatsResetPath = \"/sys/kernel/metrics/irq/stats_reset\",\n    .ModemPcieLinkStatsPath = \"/sys/devices/platform/11920000.pcie/link_stats\",\n    .WifiPcieLinkStatsPath = \"/sys/devices/platform/14520000.pcie/link_stats\",\n    .GMSRPath = \"/sys/class/power_supply/maxfg/gmsr\",\n    .TotalCallCountPath = \"/sys/devices/platform/audiometrics/call_count\"\n};\n\nconst struct UeventListener::UeventPaths ueventPaths = {\n        .AudioUevent = \"/devices/virtual/amcs/amcs\",\n        .TypeCPartnerUevent = \"PRODUCT_TYPE=\"};\n\nint main() {\n    LOG(INFO) << \"starting PixelStats\";\n\n    UeventListener ueventListener(ueventPaths);\n    std::thread listenThread(&UeventListener::ListenForever, &ueventListener);\n    listenThread.detach();\n\n    SysfsCollector collector(sysfs_paths);\n    collector.collect();  // This blocks forever.\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Item {\n    string name;\npublic:\n    Item(const string& name) : name(name) {}\n    string getName() const { return name; }\n};\n\nclass Customer {\n    string name;\n    int age;\npublic:\n    Customer(const string& name, int age) : name(name), age(age) {}\n    void buyItem(const Item& item) {\n        cout << name << \" buying \" << item.getName() << endl;\n    }\n};\n\nclass Shop {\n    vector<Customer*> customers;\n    vector<Item> items;\npublic:\n    void addObserver(Customer* customer) {\n        customers.push_back(customer);\n    }\n    void removeObserver(Customer* customer) {\n        customers.erase(remove(customers.begin(), customers.end(), customer), customers.end());\n    }\n    void addItem(const Item& item) {\n        items.push_back(item);\n    }\n    void sellItem(const Item& item) {\n        for (auto& customer : customers) {\n            customer->buyItem(item);\n        }\n    }\n};\n\nint main() {\n    Shop shop;\n\n    Customer customer1(\"Petro\", 30);\n    Customer customer2(\"Maria\", 25);\n\n    shop.addObserver(&customer1);\n    shop.addObserver(&customer2);\n\n    Item item1(\"PC\");\n    Item item2(\"ball\");\n\n    shop.addItem(item1);\n    shop.addItem(item2);\n\n    shop.sellItem(item1);\n\n    shop.removeObserver(&customer1);\n\n    shop.sellItem(item2);\n\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <android-base/strings.h>\n#include <gtest/gtest.h>\n#include <resolv_stats_test_utils.h>\n#include <stats.pb.h>\n\nnamespace android::net {\n\nTEST(ResolvStatsUtils, NetworkDnsEventEq) {\n    NetworkDnsEventReported event1;\n    // Following fields will not be verified during the test in proto NetworkDnsEventReported.\n    // So don't need to config those values: event_type, return_code, latency_micros,\n    // hints_ai_flags, res_nsend_flags, network_type, private_dns_modes.\n    constexpr char event2[] = R\"Event(\n             NetworkDnsEventReported {\n             dns_query_events:\n             {\n               dns_query_event:[\n                {\n                 rcode: 3,\n                 type: 28,\n                 cache_hit: 1,\n                 ip_version: 1,\n                 protocol: 3,\n                 retry_times: 28,\n                 dns_server_index: 0,\n                 connected: 1,\n                 latency_micros: 5,\n                },\n                {\n                 rcode: 0,\n                 type: 1,\n                 cache_hit: 1,\n                 ip_version: 1,\n                 protocol: 1,\n                 retry_times: 56,\n                 dns_server_index: 1,\n                 connected: 0,\n                 latency_micros: 0,\n                }\n               ]\n             }\n        })Event\";\n\n    // TODO: Add integration test to verify Level 1 fields of NetworkDnsEventReported.\n    // Level 1 fields, including event_type, return_code, hints_ai_flags, network_type, etc.\n    DnsQueryEvent* dnsQueryEvent1 = event1.mutable_dns_query_events()->add_dns_query_event();\n    dnsQueryEvent1->set_rcode(NS_R_NXDOMAIN);\n    dnsQueryEvent1->set_type(NS_T_AAAA);\n    dnsQueryEvent1->set_cache_hit(CS_NOTFOUND);\n    dnsQueryEvent1->set_ip_version(IV_IPV4);\n    dnsQueryEvent1->set_protocol(PROTO_DOT);\n    dnsQueryEvent1->set_retry_times(28);\n    dnsQueryEvent1->set_dns_server_index(0);\n    dnsQueryEvent1->set_connected(1);\n    dnsQueryEvent1->set_latency_micros(5);\n    DnsQueryEvent* dnsQueryEvent2 = event1.mutable_dns_query_events()->add_dns_query_event();\n    dnsQueryEvent2->set_rcode(NS_R_NO_ERROR);\n    dnsQueryEvent2->set_type(NS_T_A);\n    dnsQueryEvent2->set_cache_hit(CS_NOTFOUND);\n    dnsQueryEvent2->set_ip_version(IV_IPV4);\n    dnsQueryEvent2->set_protocol(PROTO_UDP);\n    dnsQueryEvent2->set_retry_times(56);\n    dnsQueryEvent2->set_dns_server_index(1);\n    dnsQueryEvent2->set_connected(0);\n    dnsQueryEvent2->set_latency_micros(5);\n    EXPECT_THAT(event1, NetworkDnsEventEq(fromNetworkDnsEventReportedStr(event2)));\n}\n\n}  // namespace android::net\n",
    "// This provided code will run on Leetcode but to run on any code editor, Provide a main function creating a matrix and call the\n//  'maximalRectangle()' method by providing the matrix as a parameter. It will execute. \n\n\nclass Solution {\npublic:\n\n    int maxRect(vector<int>& heights, int maxm) {\n        int len = heights.size();\n\n        vector<int>left(len);\n        vector<int>right(len);\n        stack<int>myStackL;\n        stack<int>myStackR;\n\n        for(int i = 0; i < len; i++){\n            if(myStackL.empty()){\n                left[i] = 0;\n                myStackL.push(i);\n            }\n\n            else{\n                while((!myStackL.empty()) && heights[myStackL.top()] >= heights[i]){\n                    myStackL.pop();\n                }\n                left[i] = (myStackL.empty()) ? 0 : myStackL.top() + 1;\n                myStackL.push(i);\n            }    \n        }\n\n\n\n        for(int i = len - 1; i >= 0; i--){\n            if(myStackR.empty()){\n                right[i] = len - 1;\n                myStackR.push(i);\n            }\n\n            else{\n                while((!myStackR.empty()) && heights[myStackR.top()] >= heights[i]){\n                    myStackR.pop();\n                }\n                right[i] = (myStackR.empty()) ? len - 1 : myStackR.top() - 1;\n                myStackR.push(i);\n            }    \n        }\n\n        int maxArea = 0;\n\n        for(int i = 0; i < len; i++){\n            int currArea = (right[i] - left[i] + 1) * heights[i];\n            maxArea = max(currArea, maxArea);\n        }\n\n        return max(maxArea, maxm);\n    }\n\n    int maximalRectangle(vector<vector<char>>& matrix) {\n         int len = matrix[0].size();\n        int maxRes = 0;\n        vector<int>count(len);\n        for(int i = 0; i < len; i++){\n            count[i] = 0;\n        }\n        \n        int row = matrix.size();\n        int col = matrix[0].size();\n        for(int i = 0; i < row; i++){\n            for(int j = 0; j < col; j++){\n                if(matrix[i][j] == '1'){\n                    count[j] += 1;\n                }\n                else{\n                    count[j] = 0;\n                }\n            }\n            \n            maxRes = maxRect(count, maxRes);\n        }\n        \n        return maxRes;\n    }\n};",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Producto.h\"\n#include <iostream>\n\nusing namespace std;\n\nProducto::Producto(int idProducto, const string& nombre, const string& tipo, int cantidad, const string& categoria, int a\u00f1o, double precio, Proveedor* proveedor)\n    : idProducto(idProducto), nombre(nombre), tipo(tipo), cantidad(cantidad), categoria(categoria), a\u00f1o(a\u00f1o), precio(precio), proveedor(proveedor) {}\n\nint Producto::getIdProducto() const {\n    return idProducto;\n}\n\nstring Producto::getNombre() const {\n    return nombre;\n}\n\nstring Producto::getTipo() const {\n    return tipo;\n}\n\nint Producto::getCantidad() const {\n    return cantidad;\n}\n\nstring Producto::getCategoria() const {\n    return categoria;\n}\n\nint Producto::getA\u00f1o() const {\n    return a\u00f1o;\n}\n\ndouble Producto::getPrecio() const {\n    return precio;\n}\n\nProveedor* Producto::getProveedor() const {\n    return proveedor;\n}\n\nvoid Producto::setIdProducto(int newIdProducto) {\n    idProducto = newIdProducto;\n}\n\nvoid Producto::setNombre(const string& newNombre) {\n    nombre = newNombre;\n}\n\nvoid Producto::setTipo(const string& newTipo) {\n    tipo = newTipo;\n}\n\nvoid Producto::setCantidad(int newCantidad) {\n    cantidad = newCantidad;\n}\n\nvoid Producto::setCategoria(const string& newCategoria) {\n    categoria = newCategoria;\n}\n\nvoid Producto::setA\u00f1o(int newA\u00f1o) {\n    a\u00f1o = newA\u00f1o;\n}\n\nvoid Producto::setPrecio(double newPrecio) {\n    precio = newPrecio;\n}\n\nvoid Producto::setProveedor(Proveedor* newProveedor) {\n    proveedor = newProveedor;\n}\n\nvoid Producto::mostrarInformacion() const {\n    cout << \"ID Producto: \" << idProducto << \"\\nNombre: \" << nombre << \"\\nTipo: \" << tipo << \"\\nCantidad: \" << cantidad << \"\\nCategor\u00eda: \" << categoria << \"\\nA\u00f1o: \" << a\u00f1o << \"\\nPrecio: \" << precio << std::endl;\n    proveedor->mostrarInformacion();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"firebase_realtime\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\nconst int MAX_COLUMNS = 6;\r\n\r\n//structure for keeping track of final turnaroundtime and waitingtime while in recursion\r\nstruct result{\r\n\tint* turnaroundTime;\r\n\tint* waitingTime;\r\n}r;\r\n\r\n//allocating structure for dynamic memory\r\nvoid allocateResultArrays(int size) {\r\n    r.turnaroundTime = new int[size];\r\n    r.waitingTime = new int[size];\r\n}\r\n\r\n//deallocating for preventing memory leaks\r\nvoid deallocateResultArrays() {\r\n    delete[] r.turnaroundTime;\r\n    delete[] r.waitingTime;\r\n}\r\n\r\n//sorting algorithm for the sorted arrival time\r\nvoid bubbleSort(int process[][MAX_COLUMNS], int size) {\r\n    for (int i = 0; i < size - 1; i++) \r\n        for (int j = 0; j < size - i - 1; j++) \r\n            if (process[j][1] > process[j + 1][1]) \r\n                for (int k = 0; k < MAX_COLUMNS; k++) \r\n                    swap(process[j][k], process[j + 1][k]);\r\n}\r\n\r\n//polymorphism function for printing table and gantt chart into txt via file handling\r\nvoid avgTime(int process[][MAX_COLUMNS], int size, int tempBurst[], ofstream& outFile){\r\n\tint total_wt = 0, total_tat = 0;\r\n\t\r\n\toutFile << \"\\n\\nProcess\\t\"<< \"AT\"<< \"  \\tBT \" << \"  \\tFT \" << \"     TAT \" << \" \\tWT\\n\";\r\n\t\r\n\tfor (int i=0; i<size; i++) { \r\n    \ttotal_tat += r.turnaroundTime[i];\r\n        total_wt += r.waitingTime[i];  \r\n        outFile<< process[i][0] << \"\\t\" << process[i][1] <<\"\\t\"<< tempBurst[i] << \"\\t\" \r\n\t\t<< process[i][3] <<\"\\t\" << r.turnaroundTime[i] <<\"\\t\" << r.waitingTime[i] <<endl; \r\n    } \r\n \toutFile << \"\\nAverage turn around time = \" << (float)total_tat / size; \r\n    outFile << \"\\nAverage waiting time = \" << (float)total_wt / size; \r\n}\r\n\r\n//polymorphism function for displaying table and gantt chart into console\r\nvoid avgTime(int process[][MAX_COLUMNS], int size, int tempBurst[]){\r\n\tint total_wt = 0, total_tat = 0;\r\n\t\r\n\tcout << \"Process\\t\"<< \"AT\"<< \"  \\tBT \" << \"  \\tFT \" << \"     TAT \" << \" \\tWT\\n\";\r\n\t\r\n\tfor (int i=0; i<size; i++) { \r\n    \ttotal_tat += r.turnaroundTime[i];\r\n        total_wt += r.waitingTime[i];  \r\n        cout<< process[i][0] << \"\\t\" << process[i][1] <<\"\\t\"<< tempBurst[i] << \"\\t\" << process[i][3] <<\"\\t\" \r\n\t\t<< r.turnaroundTime[i] <<\"\\t\" << r.waitingTime[i] <<endl; \r\n    } \r\n \tcout << \"\\nAverage turn around time = \" << (float)total_tat / size; \r\n    cout << \"\\nAverage waiting time = \" << (float)total_wt / size; \r\n}\r\n\r\n//srtf preemptive function that recursively calls itself until all remaining BurstTime is zero\r\nvoid srtf(int process[][MAX_COLUMNS], int timer, int tempBurst[], int size, int remainingTime[]) {\r\n    int minIndex = -1;\r\n    int minRemainingTime = INT_MAX;\r\n\r\n    for (int i = 0; i < size; ++i) {\r\n        if (process[i][1] <= timer && remainingTime[i] > 0 && remainingTime[i] < minRemainingTime) {\r\n            minRemainingTime = remainingTime[i];\r\n            minIndex = i;\r\n        }\r\n    }\r\n\r\n    if (minIndex == -1) {\r\n        // If no process can be executed now, find the next arrival time\r\n        int nextArrival = INT_MAX;\r\n        for (int i = 0; i < size; ++i) {\r\n            if (process[i][1] > timer && process[i][1] < nextArrival) {\r\n                nextArrival = process[i][1];\r\n            }\r\n        }\r\n        // If there is a next arrival time, move the timer to that time\r\n        if (nextArrival != INT_MAX) {\r\n            srtf(process, nextArrival, tempBurst, size, remainingTime);\r\n        }\r\n        return;\r\n    }\r\n\r\n    int executionTime = min(1, remainingTime[minIndex]);\r\n    process[minIndex][2] -= executionTime;\r\n    timer += executionTime;\r\n    process[minIndex][3] = timer;\r\n    process[minIndex][4] = process[minIndex][3] - process[minIndex][1];\r\n    process[minIndex][5] = process[minIndex][4] - tempBurst[minIndex];\r\n\r\n    cout << \"Process \" << process[minIndex][0] << \" executed when time is \" << timer << endl;\r\n\r\n    if (process[minIndex][2] == 0) {\r\n        r.turnaroundTime[minIndex] = process[minIndex][3] - process[minIndex][1];\r\n        r.waitingTime[minIndex] = process[minIndex][5];\r\n    }\r\n    remainingTime[minIndex] = process[minIndex][2];\r\n\r\n    // Sort processes based on remaining burst time\r\n    bubbleSort(process, size);\r\n\r\n    srtf(process, timer, tempBurst, size, remainingTime);\r\n}\r\n\r\n//priority preemptive function that recursively calls itself until all remaining BurstTime is zero\r\nvoid prio(int process[][MAX_COLUMNS], int priority[], int timer, int tempBurst[], int size) {\r\n    bool allProcessesDone = true;\r\n    int minPriorityIndex = -1;\r\n    int minPriority = INT_MAX;\r\n\r\n    // Find the minimum priority process that has arrived and not yet completed\r\n    for (int i = 0; i < size; ++i) {\r\n        if (process[i][2] > 0 && process[i][1] <= timer) {\r\n            allProcessesDone = false;\r\n\r\n            if (priority[i] < minPriority) {\r\n                minPriority = priority[i];\r\n                minPriorityIndex = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // If no process can be executed now, find the next arrival time\r\n    if (minPriority",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"practic6\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/glut.h>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nconst GLsizei ARROW_LINE_LENGTH = 8;\r\nconst GLsizei DISTANCE_BETWEEN_AXIS_AND_CHAR = 15;\r\nconst float INCREASE_IN_CURVES_FOR_SMOOTHNESS = 0.01;\r\n\r\n// pop-up window sizes\r\nGLsizei windowWidth = 500;\r\nGLsizei windowHeight = 500;\r\n\r\n// parametres y-axis\r\nGLfloat beginingYAxisY = 0;\r\nGLfloat endingYAxisY = windowHeight;\r\nGLfloat widthYAxis = (windowWidth / 2);\r\n\r\n// parametres of x-axis\r\nGLfloat beginingXAxisX = 0;\r\nGLfloat endingXAxisX = windowWidth;\r\nGLfloat heightXAxis = (windowHeight / 2);\r\n\r\n// flags when something is drawn or not\r\nGLboolean areControlLinesDrawn = GL_TRUE;\r\nGLboolean areControlPointsDrawn = GL_TRUE;\r\nGLboolean areFunctionsDrawn = GL_FALSE;\r\n\r\n// colors of the Bezier curve\r\nGLfloat curveRedColor = 1.0f;\r\nGLfloat curveBlueColor = 0.0f;\r\nGLfloat curveGreenColor = 0.0f;\r\n\r\n// colors of the control lines\r\nGLfloat lineRedColor = 0.0f;\r\nGLfloat lineBlueColor = 1.0f;\r\nGLfloat lineGreenColor = 0.0f;\r\n\r\nchar coordinateAxesSymbols[] = { 'x', 'y', 'T', 'T' };\r\nint charactersXCoordinates[] = { endingXAxisX - DISTANCE_BETWEEN_AXIS_AND_CHAR, widthYAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR,\r\n\t\t\t\t\t\t\t\t beginingXAxisX + DISTANCE_BETWEEN_AXIS_AND_CHAR, widthYAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR };\r\nint charactersYCoordinates[] = { heightXAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR, endingYAxisY - DISTANCE_BETWEEN_AXIS_AND_CHAR,\r\n\t\t\t\t\t\t\t\t heightXAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR, beginingYAxisY + DISTANCE_BETWEEN_AXIS_AND_CHAR };\r\n\r\nstruct Point\r\n{\r\n\tGLfloat x;\r\n\tGLfloat y;\r\n\r\n\tPoint(GLfloat x, GLfloat y) :x(x), y(y) {}\r\n\r\n\tPoint() = default;\r\n};\r\n\r\nvector<Point> controlPoints;\r\nvector<Point> xFuncPoints;\r\nvector<Point> yFuncPoints;\r\n\r\nvoid init()\r\n{\r\n\tglClearColor(0.0, 0.0, 0.0, 0.0);\r\n\r\n\t// reduce jagged edges\r\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\tglEnable(GL_BLEND);\r\n\tglEnable(GL_LINE_SMOOTH);\r\n\tglHint(GL_LINE_SMOOTH_HINT, GL_LINEAR);\r\n\tglEnable(GLUT_MULTISAMPLE);\r\n}\r\n\r\nvoid drawPoint(Point point)\r\n{\r\n\tglBegin(GL_POINTS);\r\n\tglVertex2f(point.x, point.y);\r\n\tglEnd();\r\n\tglFlush();\r\n}\r\n\r\nvoid drawLine(Point first, Point second)\r\n{\r\n\tglBegin(GL_LINES);\r\n\tglVertex2f(first.x, first.y);\r\n\tglVertex2f(second.x, second.y);\r\n\tglEnd();\r\n\tglFlush();\r\n}\r\n\r\nvoid drawCoordinateSystem()\r\n{\r\n\t//white\r\n\tglColor3f(1.0, 1.0, 1.0);\r\n\r\n\tPoint leftPointOfXAxis(beginingXAxisX, heightXAxis);\r\n\tPoint rightPointOfXAxis(endingXAxisX, heightXAxis);\r\n\tPoint bottomPointOfYAxis(widthYAxis, beginingYAxisY);\r\n\tPoint upperPointOfYAxis(widthYAxis, endingYAxisY);\r\n\r\n\t// draw coordinate axes\r\n\tdrawLine(leftPointOfXAxis, rightPointOfXAxis);\r\n\tdrawLine(bottomPointOfYAxis, upperPointOfYAxis);\r\n\r\n\t// draw all the arrows\r\n\tdrawLine({ endingXAxisX, heightXAxis }, { endingXAxisX - ARROW_LINE_LENGTH, heightXAxis + ARROW_LINE_LENGTH });\r\n\tdrawLine({ endingXAxisX, heightXAxis }, { endingXAxisX - ARROW_LINE_LENGTH, heightXAxis - ARROW_LINE_LENGTH });\r\n\tdrawLine({ beginingXAxisX, heightXAxis }, { beginingXAxisX + ARROW_LINE_LENGTH, heightXAxis + ARROW_LINE_LENGTH });\r\n\tdrawLine({ beginingXAxisX, heightXAxis }, { beginingXAxisX + ARROW_LINE_LENGTH, heightXAxis - ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, endingYAxisY }, { widthYAxis + ARROW_LINE_LENGTH, endingYAxisY - ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, endingYAxisY }, { widthYAxis - ARROW_LINE_LENGTH, endingYAxisY - ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, beginingYAxisY }, { widthYAxis + ARROW_LINE_LENGTH, beginingYAxisY + ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, beginingYAxisY }, { widthYAxis - ARROW_LINE_LENGTH, beginingYAxisY + ARROW_LINE_LENGTH });\r\n\r\n\t// print symbols\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tglRasterPos2i(charactersXCoordinates[i], charactersYCoordinates[i]);\r\n\t\tglutBitmapCharacter(GLUT_BITMAP_9_BY_15, coordinateAxesSymbols[i]);\r\n\t\t\r\n\t}\r\n}\r\n\r\nvoid computeXFuncPoints()\r\n{\r\n\tint size = controlPoints.size();\r\n\txFuncPoints.resize(size);\r\n\r\n\tfor (int i = 1; i <= size; i++)\r\n\t{\r\n\t\txFuncPoints[i - 1].y = (windowHeight / 2) - i * ((windowHeight / 2) / (size + 1));\r\n\t\t// x coordinate is the same\r\n\t\txFuncPoints[i - 1].x = controlPoints[i - 1].x;\r\n\t}\r\n}\r\n\r\nvoid computeYFuncPoints()\r\n{\r\n\tint size = (int)controlPoints.size();\r\n\tyFuncPoints.resize(size);\r\n\r\n\tfor (int i = 1; i <= size; i++)\r\n\t{\r\n\t\tyFuncPoints[i - 1].x = (windowWidth / 2) - i * ((windowWidth / 2) / (size + 1));\r\n\t\t// y coordinate stays the same\r\n\t\tyFuncPoints[i - 1].y = controlPoints[i - 1].y;\r\n\t}\r\n}\r\n\r\n// calculate point for some t\r\nPoint computeBezierPoint(int r, int index, double valueT, vector<Point>& points)\r\n{\r\n\tif (r == 0)\r\n\t\treturn points[index];\r\n\r\n\tPoint p1 = computeBezierPoint(r - 1, index, valueT, points);\r\n\tPoint p2 = computeBezierPoint(r - 1, index + 1, valueT, points);\r\n\r\n\tPoint newPt;\r\n\tnewPt.x = (1 - valueT) * p1.x + valueT * p2.x;\r\n\tnewPt.y = (1 - valueT) * p1.y + valueT * p2.y;\r\n\r\n\treturn newPt;\r\n}\r\n\r\n// this is where we draw the curve\r\nvoid computeBezier(vector<Point>& points)\r\n{\r\n\tglColor3f(curveR",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nint text_c;\nvector<vector<int>> input_bin;\nvector<vector<vector<int>>> sBoxes =\n{\n    {\n        {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},\n        {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},\n        {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},\n        {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}\n    },\n    {\n        {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n        {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},\n        {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},\n        {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}\n    },\n    {\n        {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},\n        {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n        {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},\n        {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}\n    },\n    {\n        {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n        {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},\n        {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n        {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}\n    },\n    {\n        {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n        {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n        {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n        {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}\n    },\n    {\n        {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n        {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n        {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n        {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}\n    },\n    {\n        {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},\n        {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n        {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n        {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}\n    },\n    {\n        {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n        {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},\n        {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},\n        {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}\n    }\n};\n\nvector<int> ebit =\n{\n    32, 1, 2, 3, 4, 5,\n    4, 5, 6, 7, 8, 9,\n    8, 9, 10, 11, 12, 13,\n    12, 13, 14, 15, 16, 17,\n    16, 17, 18, 19, 20, 21,\n    20, 21, 22, 23, 24, 25,\n    24, 25, 26, 27, 28, 29,\n    28, 29, 30, 31, 32, 1\n};\nvector<int> permutation =\n{\n    16, 7, 20, 21,\n    29, 12, 28, 17,\n    1, 15, 23, 26,\n    5, 18, 31, 10,\n    2, 8, 24, 14,\n    32, 27, 3, 9,\n    19, 13, 30, 6,\n    22, 11, 4, 25\n};\n\nvector<int> inverseinitialpermutation =\n{\n    40, 8, 48, 16, 56, 24, 64, 32,\n    39, 7, 47, 15, 55, 23, 63, 31,\n    38, 6, 46, 14, 54, 22, 62, 30,\n    37, 5, 45, 13, 53, 21, 61, 29,\n    36, 4, 44, 12, 52, 20, 60, 28,\n    35, 3, 43, 11, 51, 19, 59, 27,\n    34, 2, 42, 10, 50, 18, 58, 26,\n    33, 1, 41, 9, 49, 17, 57, 25\n};\n\nvector<vector<int>> text_to_binary_vector(const string& text)\n{\n    vector<vector<int>> binary_2d_vector;\n\n    for (size_t i = 0; i < text.size(); i += 8)\n    {\n        vector<int> binary_row;\n\n        for (size_t j = i; j < i + 8 && j < text.size(); j++)\n        {\n            bitset<8> binary_representation(text[j]);\n\n            // Append the binary representation of the character to the row\n            for (int k = 7; k >= 0; k--)\n            {\n                binary_row.push_back(binary_representation[k]);\n            }\n        }\n\n        binary_2d_vector.push_back(binary_row);\n    }\n\n    // Display the binary_2d_vector\n    for (const auto& row : binary_2d_vector)\n    {\n        for (int bit : row)\n        {\n            cout << bit;\n        }\n        cout << endl;\n    }\n\n    return binary_2d_vector;\n}\n\nint determineRow(int ar2dValue)\n{\n    if (ar2dValue == 0)\n        return 0;\n    else if (ar2dValue == 1)\n        return 1;\n    else if (ar2dValue == 2)\n        return 2;\n    else if (ar2dValue == 3)\n        return 3;\n    // Add more conditions if needed\n    else\n        return -1; // Invalid input\n}\nint determineColumn(const vector<int>& ar2dValues)\n{\n    int coll = 0;\n    for (int i = 1; i < 5; ++i)\n    {\n        coll <<= 1;\n        coll |= ar2dValues[i];\n    }\n    return coll;\n}\nint getSBoxValue(int row, int col, int row3d)\n{\n    return sBoxes[row3d][row][col];\n}\nvector<int> initialvector =\n{\n    1, 0, 1, 1, 0, 1, 0, 1,\n    1, 1, 1, 0, 1, 0, 1, 1,\n    0, 1, 0, 1, 1, 1, 0, 1,\n    1, 1, 0, 1, 0, 0, 1, 1,\n    1, 0, 1, 1, 0, 1, 1, 1,\n    0, 1, 0, 1, 1, 1, 0, 1,\n    0, 0, 1, 1, 1, 0, 1, 0,\n    1, 1, 0, 1, 1, 0, 0, 1\n};\nvector<vector<int>> Cipher2d(100, vector<int>(64, 0));\nvector<int>initialvector1=initialvector;\n\nchar binaryToAscii(const std::vector<int>& bits)\n{\n    if (bits.size() != 8)\n    {\n        // Ensure the input has exactly 8 bits\n        std::cerr << \"Error: Input must be an 8-bit binary sequence.\" << std::endl;\n        return '\\0'; // Retur",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\nint SumFinder(int arr[], int* adr);\nint MaxFinder(int arr[3]);\nint MaxFinder(int arr[3][4]);//\u00ed\u00e5 \u00ef\u00ee\u00ed\u00ff\u00eb \u00ea\u00e0\u00ea \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00f2\u00fc \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00e1\u00e5\u00e7 \u00f3\u00ea\u00e0\u00e7\u00e0\u00ed\u00e8\u00ff \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0\u00e0\nint MaxFinder(int arr[3][4][3]);\nint main()\n{\n\tsetlocale(LC_ALL, \"ru\");\n\tsrand(time(NULL));\n\t//\u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 1\n\tconst int size = 100;\n\tint arr[size];\n\tint iter = 0;\n\tint* adr = &iter;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tarr[i] = rand() % 100;\n\t}\n\t//cout << \"\u00cc\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00e0\u00ff \u00f1\u00f3\u00ec\u00ec\u00e0 - \" << SumFinder(arr,adr);\n\t//\u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 2\n\tint arr2[3]{ -2,4,8 };\n\tint arr3[3][4];\n\tint arr4[3][4][3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tarr3[i][j] = rand() % 100;\n\t\t}\n\t\t\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tarr4[i][j][k] = rand() % 100;\n\t\t\t}\n\t\t}\n\t}\n\tcout << MaxFinder(arr2) << endl;\n\tcout << MaxFinder(arr3) << endl;\n\tcout << MaxFinder(arr4) << endl;\n\treturn 0;\n}\n\nint SumFinder(int arr[], int* adr)//\u00e2 \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1\u00e8\u00ff \u00ef\u00ee\u00f7\u00e5\u00ec\u00f3 \u00f2\u00ee \u00ed\u00e8\u00ea\u00e0\u00ea \u00ed\u00e5 \u00f5\u00ee\u00f7\u00e5\u00f2 \u00e7\u00e0\u00ea\u00e0\u00ed\u00f7\u00e8\u00e2\u00e0\u00f2\u00fc\u00f1\u00ff \u00f5\u00ee\u00f2\u00fc \u00ff \u00e8 \u00f1\u00ea\u00e0\u00e7\u00e0\u00eb \u00ea\u00ee\u00e3\u00e4\u00e0 \u00e2\u00ee\u00e7\u00e2\u00f0\u00e0\u00f9\u00e0\u00f2\u00fc \u00e7\u00e0\u00ea\u00e0\u00ed\u00f7\u00e8\u00e2\u00e0\u00f2\u00fc\n{\n\tint sum = 0;\n\tint iter = *adr;\n\tif (iter == 91)\n\t{\n\t\treturn sum;\n\t}\n\n\tfor (int i = 99; i != 89; i--)\n\t{\n\t\tsum += arr[i - iter];\n\t}\n\titer++;\n\tcout << iter << endl;\n\t\n\tif (sum > SumFinder(arr,&iter))\n\t{\n\t\tsum = SumFinder(arr,&iter);\n\t\treturn sum;\n\t}\n\t\n\t\n}\n\nint MaxFinder(int arr[3])\n{\n\tint max = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nint MaxFinder(int arr[3][4])\n{\n\tint max = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (arr[i][j] > max)\n\t\t\t{\n\t\t\t\tmax = arr[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\n\nint MaxFinder(int arr[3][4][3])\n{\n\tint max = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tif (arr[i][j][k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = arr[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nstruct node\n{\n    int data;\n    struct node * next;\n    struct node * prev;\n};\nstruct node * head = NULL;\n\nvoid basaEkle(int data)\n{\n    struct node * newnode = new node();\n    newnode->data = data;\n    if (head== NULL)\n    {\n        newnode->next = NULL;\n        newnode->prev =NULL;\n        head = newnode;\n    }\n    else\n    {\n        newnode->prev= NULL;\n        newnode->next = head;\n        head->prev = newnode;\n        head = newnode;\n    }\n}\nvoid sonaEkle(int data)\n{\n    struct node * newnode = new node();\n    newnode->data = data;\n    if(head == NULL)\n    {\n        newnode->next = NULL;\n        newnode->prev = NULL;\n        head = newnode;\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp != NULL)\n        {\n            if (temp->next == NULL)\n            {\n                temp->next = newnode;\n                newnode->prev = temp;\n                newnode->next = NULL;\n                return;\n            }\n            temp = temp->next;\n        }\n    }\n}\nvoid ArayaEkle(int data,int sira)\n{\n    struct node * newnode = new node();\n    newnode->data = data;\n    if(head == NULL)\n    {\n        newnode->next = NULL;\n        newnode->prev = NULL;\n        head = newnode;\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp!=NULL)\n        {\n            if (temp->data == sira)\n            {\n                struct node * temp2 = temp->prev;\n                struct node *temp3  = temp;\n                temp2->next = newnode;\n                newnode->prev = temp2;\n                newnode->next =temp3;\n                temp3->prev = newnode;\n                break;\n            }\n\n            temp = temp->next;\n        }\n\n\n    }\n}\nvoid BastanSil()\n{\n    if (head == NULL)\n    {\n        cout<<\"Liste bos oldugu icin silinemedi\";\n    }\n    else\n    {\n        struct node * temp = head->next;\n        temp->prev = NULL;\n        delete head;\n        head = temp;\n    }\n}\n\n\nvoid SondanSil()\n{\n    if (head == NULL)\n    {\n        cout<<\"Liste bos oldugu icin silinemedi\";\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp !=NULL)\n        {\n            if(temp->next->next ==NULL)\n            {\n                delete temp->next;\n                temp->next = NULL;\n                break;\n\n            }\n            temp = temp->next;\n        }\n    }\n\n}\n\n\nvoid AradanSil(int silinecekSayi)\n{\n    if (head == NULL)\n    {\n        cout<<\"Liste bos oldugu icin silinemedi\";\n\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp != NULL)\n        {\n            if(temp->data == silinecekSayi)\n            {\n                struct node * temp2 = temp->prev;\n                struct node * temp3 = temp->next;\n                temp2->next = temp3;\n                temp3->prev =temp2;\n                delete temp;\n                cout<<endl<<\" Secilen sayi silindi\";\n                break;\n            }\n            temp = temp->next;\n        }\n    }\n\n\n}\n\n\nvoid Yazdir()\n{\n    if(head == NULL)\n    {\n        cout<<endl<<\"Liste bos\";\n\n    }\n    else\n    {\n        cout<<endl<<endl;\n        struct node * temp = head;\n        while(temp!=NULL)\n        {\n            cout<<temp->data<<\" \";\n            temp = temp->next;\n        }\n\n\n    }\n}\n\nint main()\n{\n    int sayi ,sayi2, secim;\n    while(1)\n        {\n            cout<<endl<<\"1- Basa ekle\"<<endl;\n            cout<<\"2- Sona ekle\"<<endl;\n            cout<<\"3- Araya ekle\"<<endl;\n            cout<<\"4- Bastan Sil\"<<endl;\n            cout<<\"5- Sondan Sil\"<<endl;\n            cout<<\"6- Aradan Sil\"<<endl;\n            cout<<\"7- Yazdir\"<<endl;\n            cout<<\"8- Cikis\"<<endl;\n            cin>>secim;\n            switch(secim)\n            {\n            case 1:\n                {\n                    cout<<endl<<\"Basa eklenecek sayiyi giriniz : \" ;\n                    cin>>sayi;\n                    basaEkle(sayi);\n                    break;\n                }\n            case 2:\n                {\n                    cout<<endl<<\"Sona eklenecek sayiyi giriniz : \" ;\n                    cin>>sayi;\n                    sonaEkle(sayi);\n                    break;\n                }\n            case 3:\n                {\n                    cout<<endl<<\"Araya eklenecek sayiyi giriniz : \" ;\n                    cin>>sayi;\n                    cout<<endl<<\"Hangi say\u00fddan \u00f6nce eklenecek : \" ;\n                    cin>>sayi2;\n                    ArayaEkle(sayi,sayi2);\n                    break;\n                }\n            case 4:\n                {\n                    cout<<endl<<\"Bastaki eleman silindi\" ;\n                    BastanSil();\n                    break;\n                }\n            case 5:\n                {\n                    cout<<endl<<\"Sondaki eleman silindi\" ;\n                    SondanSil();\n                    break;\n                }\n            case 6:\n                {\n                    cout<<endl<<\"Silinecek eleman\u00fd girin\" ;\n                    cin>>sayi;\n                    AradanSil(sayi",
    "//\n//  MemoryBackup.cpp\n//\n//  Created by MJ (Ruit) on 4/19/20.\n//\n\n#include \"MemoryBackup.h\"\n\n\nMemoryBackup::MemoryBackup()\n{\n  _address = 0;\n  _size = 0;\n  _orig_code.clear();\n}\n\nMemoryBackup::MemoryBackup(const ProcMap &map, uintptr_t address, size_t backup_size)\n{\n  _address = 0;\n  _size = 0;\n  _orig_code.clear();\n\n  if (!map.isValid() || address == 0 || backup_size < 1)\n    return;\n\n  _address = map.startAddress+address;\n  if (_address == 0)\n    return;\n\n  _size = backup_size;\n\n  _orig_code.resize(backup_size);\n\n  // backup current content\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);\n}\n\nMemoryBackup::MemoryBackup(uintptr_t absolute_address, size_t backup_size)\n{\n  _address = 0;\n  _size = 0;\n  _orig_code.clear();\n\n  if (absolute_address == 0 || backup_size < 1)\n    return;\n\n  _address = absolute_address;\n\n  _size = backup_size;\n\n  _orig_code.resize(backup_size);\n\n  // backup current content\n  KittyMemory::memRead(&_orig_code[0], reinterpret_cast<const void *>(_address), backup_size);\n}\n\nMemoryBackup::~MemoryBackup()\n{\n  // clean up\n  _orig_code.clear();\n}\n\nbool MemoryBackup::isValid() const\n{\n  return (_address != 0 && _size > 0 && _orig_code.size() == _size);\n}\n\nsize_t MemoryBackup::get_BackupSize() const\n{\n  return _size;\n}\n\nuintptr_t MemoryBackup::get_TargetAddress() const\n{\n  return _address;\n}\n\nbool MemoryBackup::Restore()\n{\n  if (!isValid()) return false;\n  \n  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size);\n}\n\nstd::string MemoryBackup::get_CurrBytes() const\n{\n  if (!isValid()) return \"\";\n  \n  return KittyMemory::read2HexStr(reinterpret_cast<const void *>(_address), _size);\n}\n\nstd::string MemoryBackup::get_OrigBytes() const\n{\n  if (!isValid()) return \"\";\n  \n  return KittyMemory::read2HexStr(_orig_code.data(), _orig_code.size());\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <limits>\n\ntemplate <typename T>\nvoid ErrorInputCheck(T& input) {\n    while (std::cin.fail()) {\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        \n        std::cout << \"ERROR: Invalid Input (Try again): \";\n        std::cin >> input;\n        std::cout << \"------------------------------\" << std::endl;\n    }\n}\n\ndouble Calculate(std::vector<std::pair<double, int>>& grades) {\n    double qualityPoints = std::accumulate(grades.begin(), grades.end(), 1, [](double a, std::pair<double, int>& b){\n        return a + b.first * b.second;\n    });\n\n    double creditHours = std::accumulate(grades.begin(), grades.end(), 0, [](double a, std::pair<double, int>& b){\n        return a + b.second;\n    });\n\n    double result = qualityPoints / creditHours;\n    \n    return result;\n}\n\nstd::vector<std::pair<double, int>> Input() {\n    int len = 0;\n\n    std::cout << \"Enter the amount of classes you're taking: \";\n    std::cin >> len;\n    ErrorInputCheck(len);\n\n    std::vector<std::pair<double, int>> grades{};\n    for (int i = 1; i <= len; i++) {\n        double grade{};\n        double credit{};\n\n        std::cout << \"Enter the grade for grade \" << i << \": \";\n        std::cin >> grade;\n        ErrorInputCheck(grade);\n\n        std::cout << \"Enter the credit for grade \" << i << \": \";\n        std::cin >> credit;\n        ErrorInputCheck(credit);\n        std::cout << \"------------------------------\" << std::endl;\n\n        grades.push_back({grade, credit});\n    }\n\n    return grades;\n}\n\nint main() {\n    std::string end{};\n\n    while (end != \"q\") {\n        std::vector<std::pair<double, int>> grades = Input();\n\n        std::cout << \"Gpa Result: \";\n        std::cout << Calculate(grades) << std::endl;\n        std::cout << std::endl;\n\n        std::cout << \"Quit? (q): \";\n        std::cin >> end;\n        std::cout << std::endl;\n    }\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass DietType {\r\npublic:\r\n    struct DietPlan {\r\n        string vegbreakfast;\r\n        int breakfastCalories;\r\n        string veglunch;\r\n        int lunchCalories;\r\n        string vegsnacks;\r\n        int snacksCalories;\r\n        string vegdinner;\r\n        int dinnerCalories;\r\n        string nonvegbreakfast;\r\n        string nonveglunch;\r\n        string nonvegsnacks;\r\n        string nonvegdinner;\r\n    };\r\n\r\npublic:\r\n    DietType() {\r\n        // Set default values for all variables\r\n        dietPlan.vegbreakfast = \"Oatmeal with fruits\";\r\n        dietPlan.breakfastCalories = 300;\r\n        dietPlan.veglunch = \"Vegetable salad with tofu\";\r\n        dietPlan.lunchCalories = 400;\r\n        dietPlan.vegsnacks = \"Carrot sticks with hummus\";\r\n        dietPlan.snacksCalories = 150;\r\n        dietPlan.vegdinner = \"Quinoa with mixed vegetables\";\r\n        dietPlan.dinnerCalories = 450;\r\n        dietPlan.nonvegbreakfast = \"Scrambled eggs with whole grain toast\";\r\n        dietPlan.nonveglunch = \"Grilled chicken breast with brown rice\";\r\n        dietPlan.nonvegsnacks =  \"Greek yogurt with almonds\";\r\n        dietPlan.nonvegdinner = \"Baked salmon with steamed vegetables\" ;\r\n    }\r\n\r\n    virtual void printDietPlan() const = 0;\r\n\r\npublic:\r\n    DietPlan dietPlan;\r\n};\r\n\r\nclass VegDiet : public DietType {\r\npublic:\r\n    VegDiet(string goal) : goal(goal) {\r\n        // Adjust calories based on goal\r\n        if (goal == \"Lose\") {\r\n            dietPlan.breakfastCalories -= 100;\r\n            dietPlan.lunchCalories -= 100;\r\n            dietPlan.snacksCalories -= 50;\r\n            dietPlan.dinnerCalories -= 100;\r\n        } else if (goal == \"Gain\") {\r\n            dietPlan.breakfastCalories += 100;\r\n            dietPlan.lunchCalories += 100;\r\n            dietPlan.snacksCalories += 50;\r\n            dietPlan.dinnerCalories += 100;\r\n        }\r\n    }\r\n\r\n    void printDietPlan() const override {\r\n        cout << \"----- Veg Diet Plan -----\" << endl;\r\n        cout << \"Breakfast: \" << dietPlan.vegbreakfast << \" (Calories: \" << dietPlan.breakfastCalories << \")\" << endl;\r\n        cout << \"Lunch: \" << dietPlan.veglunch << \" (Calories: \" << dietPlan.lunchCalories << \")\" << endl;\r\n        cout << \"Snacks: \" << dietPlan.vegsnacks << \" (Calories: \" << dietPlan.snacksCalories << \")\" << endl;\r\n        cout << \"Dinner: \" << dietPlan.vegdinner << \" (Calories: \" << dietPlan.dinnerCalories << \")\" << endl;\r\n    }\r\n\r\npublic:\r\n    string goal;\r\n};\r\n\r\nclass NonVegDiet : public DietType {\r\npublic:\r\n    NonVegDiet(string goal) : goal(goal) {\r\n        // Adjust calories based on goal\r\n        if (goal == \"Lose\") {\r\n            dietPlan.breakfastCalories -= 100;\r\n            dietPlan.lunchCalories -= 100;\r\n            dietPlan.snacksCalories -= 50;\r\n            dietPlan.dinnerCalories -= 100;\r\n        } else if (goal == \"Gain\") {\r\n            dietPlan.breakfastCalories += 100;\r\n            dietPlan.lunchCalories += 100;\r\n            dietPlan.snacksCalories += 50;\r\n            dietPlan.dinnerCalories += 100;\r\n        }\r\n    }\r\n\r\n    void printDietPlan() const override {\r\n        cout << \"----- Non Veg Diet Plan -----\" << endl;\r\n        cout << \"Breakfast: \" << dietPlan.nonvegbreakfast << \" (Calories: \" << dietPlan.breakfastCalories << \")\" << endl;\r\n        cout << \"Lunch: \" << dietPlan.nonveglunch << \" (Calories: \" << dietPlan.lunchCalories << \")\" << endl;\r\n        cout << \"Snacks: \" << dietPlan.nonvegsnacks << \" (Calories: \" << dietPlan.snacksCalories << \")\" << endl;\r\n        cout << \"Dinner: \" << dietPlan.nonvegdinner << \" (Calories: \" << dietPlan.dinnerCalories << \")\" << endl;\r\n    }\r\n\r\npublic:\r\n    string goal;\r\n};\r\n\r\n\r\nint main() {\r\n    char dietChoice;\r\n    cout << \"Are you vegetarian or non-vegetarian? (V/N): \";\r\n    cin >> dietChoice;\r\n\r\n    string goal;\r\n    cout << \"Select your weight goal (Maintain/Lose/Gain): \";\r\n    cin >> goal;\r\n\r\n    DietType *dietType;\r\n\r\n    if (dietChoice == 'V' || dietChoice == 'v') {\r\n        dietType = new VegDiet(goal);\r\n    } else if (dietChoice == 'N' || dietChoice == 'n') {\r\n        dietType = new NonVegDiet(goal);\r\n    } else {\r\n        cout << \"Invalid choice!\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    dietType->printDietPlan();\r\n\r\n    delete dietType;\r\n\r\n    return 0;\r\n}\r\n",
    " #include \"smath.hpp\"\n \n namespace smath \n {\n    // Vector2 + operator overload\n    Vector2 operator+(const Vector2& v1, const Vector2& v2) {\n        return {v1.x + v2.x, v1.y + v2.y};\n    }\n\n    // Vector2 - operator overload\n    Vector2 operator-(const Vector2& v1, const Vector2& v2) {\n        return {v1.x - v2.x, v1.y - v2.y};\n    }\n\n    // Vector2 * operator overload\n    Vector2 operator*(const Vector2& v, double scalar) {\n        return {v.x * scalar, v.y * scalar};\n    }\n\n    // Vector2 * operator overload (2 vectors element-wise multiplication)\n    Vector2 operator*(const Vector2& v1, const Vector2& v2) {\n        return {v1.x * v2.x, v1.y * v2.y};\n    }\n\n    // Vector2 / operator overload\n    Vector2 operator/(const Vector2& v, double scalar) {\n        return {v.x / scalar, v.y / scalar};\n    }\n\n    // Vector2 / operator overload (2 vectors element-wise division)\n    Vector2 operator/(const Vector2& v1, const Vector2& v2) {\n        return {v1.x / v2.x, v1.y / v2.y};\n    }\n\n\n    // Vector3 + operator overload\n    Vector3 operator+(const Vector3& v1, const Vector3& v2) {\n        return {v1.x + v2.x, v1.y + v2.y, v1.z + v2.z};\n    }\n\n    // Vector3 - operator overload\n    Vector3 operator-(const Vector3& v1, const Vector3& v2) {\n        return {v1.x - v2.x, v1.y - v2.y, v1.z - v2.z};\n    }\n\n    // Vector3 * operator overload\n    Vector3 operator*(const Vector3& v, double scalar) {\n        return {v.x * scalar, v.y * scalar, v.z * scalar};\n    }\n\n    // Vector3 * operator overload (2 vectors element-wise multiplication)\n    Vector3 operator*(const Vector3& v1, const Vector3& v2) {\n        return {v1.x * v2.x, v1.y * v2.y, v1.z * v2.z};\n    }\n\n    // Vector3 / operator overload\n    Vector3 operator/(const Vector3& v, double scalar) {\n        return {v.x / scalar, v.y / scalar, v.z / scalar};\n    }\n\n    // Vector3 / operator overload (2 vectors element-wise division)\n    Vector3 operator/(const Vector3& v1, const Vector3& v2) {\n        return {v1.x / v2.x, v1.y / v2.y, v1.z / v2.z};\n    }\n\n\n    // Vector4 + operator overload\n    Vector4 operator+(const Vector4& v1, const Vector4& v2) {\n        return {v1.x + v2.x, v1.y + v2.y, v1.z + v2.z, v1.w + v2.w};\n    }\n\n    // Vector4 - operator overload\n    Vector4 operator-(const Vector4& v1, const Vector4& v2) {\n        return {v1.x - v2.x, v1.y - v2.y, v1.z - v2.z, v1.w - v2.w};\n    }\n\n    // Vector4 * operator overload\n    Vector4 operator*(const Vector4& v, double scalar) {\n        return {v.x * scalar, v.y * scalar, v.z * scalar, v.w * scalar};\n    }\n\n    // Vector4 * operator overload (2 vectors element-wise multiplication)\n    Vector4 operator*(const Vector4& v1, const Vector4& v2) {\n        return {v1.x * v2.x, v1.y * v2.y, v1.z * v2.z, v1.w * v2.w};\n    }\n\n    // Vector4 / operator overload\n    Vector4 operator/(const Vector4& v, double scalar) {\n        return {v.x / scalar, v.y / scalar, v.z / scalar, v.w / scalar};\n    }\n\n    // Vector4 / operator overload (2 vectors element-wise division)\n    Vector4 operator/(const Vector4& v1, const Vector4& v2) {\n        return {v1.x / v2.x, v1.y / v2.y, v1.z / v2.z, v1.w / v2.w};\n    }\n\n\n    // Vector2 Cout operator overload\n    std::ostream& operator<<(std::ostream& os, const Vector2& v) {\n        os << \"(\" << v.x << \", \" << v.y << \")\" << std::endl;\n        return os;\n    }\n\n    // Vector3 Cout operator overload\n    std::ostream& operator<<(std::ostream& os, const Vector3& v) {\n        os << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\" << std::endl;\n        return os;\n    }\n\n    // Vector4 Cout operator overload\n    std::ostream& operator<<(std::ostream& os, const Vector4& v) {\n        os << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \", \" << v.w << \")\" << std::endl;\n        return os;\n    }\n\n    std::istream& operator>>(std::istream& is, Vector2& v) {\n        is >> v.x >> v.y;\n        return is;\n    }\n\n    std::istream& operator>>(std::istream& is, Vector3& v) {\n        is >> v.x >> v.y >> v.z;\n        return is;\n    }\n\n    std::istream& operator>>(std::istream& is, Vector4& v) {\n        is >> v.x >> v.y >> v.z >> v.w;\n        return is;\n    }\n\n\n    // Matrix2 + operator overload\n    Matrix2 operator+(const Matrix2& m1, const Matrix2& m2) {\n        return {m1.m00 + m2.m00, m1.m01 + m2.m01, m1.m10 + m2.m10, m1.m11 + m2.m11};\n    }\n\n    // Matrix2 - operator overload\n    Matrix2 operator-(const Matrix2& m1, const Matrix2& m2) {\n        return {m1.m00 - m2.m00, m1.m01 - m2.m01, m1.m10 - m2.m10, m1.m11 - m2.m11};\n    }\n\n    // Matrix2 * operator overload\n    Matrix2 operator*(const Matrix2& m, double scalar) {\n        return {m.m00 * scalar, m.m01 * scalar, m.m10 * scalar, m.m11 * scalar};\n    }\n\n    // Matrix2 * operator overload (2 matrices element-wise multiplication)\n    Matrix2 operator*(const Matrix2& m1, const Matrix2& m2) {\n        return {m1.m00 * m2.m00, m1.m01 * m2.m01, m1.m10 * m2.m10, m1.m11 * m2.m11};\n    }\n\n    // Matrix2 / operator overload\n    Matrix2 operator/(const Matrix2& m, double scalar) {\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int quantidade;\r\n    double preco_unitario;\r\n\r\n    // DIGITE A QUANTIDADE DE SORVETES COMPRADOS ENTRE AS ASPAS\r\n    cout << \" 0 \";\r\n    cin >> quantidade;\r\n\r\n    if (quantidade <= 25) {\r\n        preco_unitario = 1.50;\r\n    }\r\n    else {\r\n        preco_unitario = 1.25;\r\n    }\r\n\r\n    double total = quantidade * preco_unitario;\r\n    cout << \"O total a pagar \u00e9: R$\" << total << endl;\r\n\r\n    return 0;\r\n}\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    // DIGITE UM NUMERO \r\n    int numero;\r\n    cout << \"Digite um n\u00famero: \";\r\n    cin >> numero;\r\n\r\n    if (numero > 10) {\r\n        numero = numero + 10 * 2;\r\n    }\r\n    else {\r\n        numero = numero + 9 * 3 - 8;\r\n    }\r\n\r\n    cout << \"Resultado: \" << numero << endl;\r\n\r\n    return 0;\r\n}\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int numero;\r\n    cout << \"Digite um n\u00famero: \";\r\n    cin >> numero;\r\n\r\n    if (numero > 0) {\r\n        cout << \"O n\u00famero \u00e9 positivo.\" << endl;\r\n    }\r\n    else if (numero < 0) {\r\n        cout << \"O n\u00famero \u00e9 negativo.\" << endl;\r\n    }\r\n    else {\r\n        cout << \"O n\u00famero \u00e9 zero.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int num1, num2;\r\n    cout << \"Digite o primeiro n\u00famero: \";\r\n    cin >> num1;\r\n    cout << \"Digite o segundo n\u00famero: \";\r\n    cin >> num2;\r\n\r\n    if (num1 > num2) {\r\n        cout << \"O primeiro n\u00famero \u00e9 maior.\" << endl;\r\n    }\r\n    else if (num2 > num1) {\r\n        cout << \"O segundo n\u00famero \u00e9 maior.\" << endl;\r\n    }\r\n    else {\r\n        cout << \"Os n\u00fameros s\u00e3o iguais.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    //DIGITE AS NOTAS \r\n    double nota1, nota2;\r\n    cout << \"Digite a primeira nota: \";\r\n    cin >> nota1;\r\n    cout << \"Digite a segunda nota: \";\r\n    cin >> nota2;\r\n\r\n    double media = (nota1 + nota2) / 2;\r\n    cout << \"A m\u00e9dia \u00e9: \" << media << endl;\r\n\r\n    if (media >= 7) {\r\n        cout << \"Aprovado\" << endl;\r\n    }\r\n    else {\r\n        cout << \"Reprovado\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* WiFi Example\n * Copyright (c) 2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"mbed.h\"\n#include \"TCPSocket.h\"\n\n#define WIFI_IDW0XX1    2\n\n#if (defined(TARGET_DISCO_L475VG_IOT01A) || defined(TARGET_DISCO_F413ZH))\n#include \"ISM43362Interface.h\"\nISM43362Interface wifi(MBED_CONF_APP_WIFI_SPI_MOSI, MBED_CONF_APP_WIFI_SPI_MISO, MBED_CONF_APP_WIFI_SPI_SCLK, MBED_CONF_APP_WIFI_SPI_NSS, MBED_CONF_APP_WIFI_RESET, MBED_CONF_APP_WIFI_DATAREADY, MBED_CONF_APP_WIFI_WAKEUP, false);\n\n#else // External WiFi modules\n\n#if MBED_CONF_APP_WIFI_SHIELD == WIFI_IDW0XX1\n#include \"SpwfSAInterface.h\"\nSpwfSAInterface wifi(MBED_CONF_APP_WIFI_TX, MBED_CONF_APP_WIFI_RX);\n#endif // MBED_CONF_APP_WIFI_SHIELD == WIFI_IDW0XX1\n\n#endif\n\nconst char *sec2str(nsapi_security_t sec)\n{\n    switch (sec) {\n        case NSAPI_SECURITY_NONE:\n            return \"None\";\n        case NSAPI_SECURITY_WEP:\n            return \"WEP\";\n        case NSAPI_SECURITY_WPA:\n            return \"WPA\";\n        case NSAPI_SECURITY_WPA2:\n            return \"WPA2\";\n        case NSAPI_SECURITY_WPA_WPA2:\n            return \"WPA/WPA2\";\n        case NSAPI_SECURITY_UNKNOWN:\n        default:\n            return \"Unknown\";\n    }\n}\n\nint scan_demo(WiFiInterface *wifi)\n{\n    WiFiAccessPoint *ap;\n\n    printf(\"Scan:\\n\");\n\n    int count = wifi->scan(NULL,0);\n    printf(\"%d networks available.\\n\", count);\n\n    /* Limit number of network arbitrary to 15 */\n    count = count < 15 ? count : 15;\n\n    ap = new WiFiAccessPoint[count];\n    count = wifi->scan(ap, count);\n    for (int i = 0; i < count; i++)\n    {\n        printf(\"Network: %s secured: %s BSSID: %hhX:%hhX:%hhX:%hhx:%hhx:%hhx RSSI: %hhd Ch: %hhd\\n\", ap[i].get_ssid(),\n               sec2str(ap[i].get_security()), ap[i].get_bssid()[0], ap[i].get_bssid()[1], ap[i].get_bssid()[2],\n               ap[i].get_bssid()[3], ap[i].get_bssid()[4], ap[i].get_bssid()[5], ap[i].get_rssi(), ap[i].get_channel());\n    }\n\n    delete[] ap;\n    return count;\n}\n\nvoid http_demo(NetworkInterface *net)\n{\n    TCPSocket socket;\n    nsapi_error_t response;\n\n    printf(\"Sending HTTP request to www.example.com...\\n\");\n\n    // Open a socket on the network interface, and create a TCP connection to www.arm.com\n    socket.open(net);\n    response = socket.connect(\"www.example.com\", 80);\n    if(0 != response) {\n        printf(\"Error connecting: %d\\n\", response);\n        socket.close();\n        return;\n    }\n\n    // Send a simple http request\n    char sbuffer[] = \"GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n\";\n    nsapi_size_t size = strlen(sbuffer);\n    response = 0;\n    while(size)\n    {\n        response = socket.send(sbuffer+response, size);\n        if (response < 0) {\n            printf(\"Error sending data: %d\\n\", response);\n            socket.close();\n            return;\n        } else {\n            size -= response;\n            // Check if entire message was sent or not\n            printf(\"sent %d [%.*s]\\n\", response, strstr(sbuffer, \"\\r\\n\")-sbuffer, sbuffer);\n        }\n    }\n\n    // Recieve a simple http response and print out the response line\n    char rbuffer[64];\n    response = socket.recv(rbuffer, sizeof rbuffer);\n    if (response < 0) {\n        printf(\"Error receiving data: %d\\n\", response);\n    } else {\n        printf(\"recv %d [%.*s]\\n\", response, strstr(rbuffer, \"\\r\\n\")-rbuffer, rbuffer);\n    }\n\n    // Close the socket to return its memory and bring down the network interface\n    socket.close();\n}\n\nint main()\n{\n    int count = 0;\n\n    printf(\"WiFi example\\n\\n\");\n\n    count = scan_demo(&wifi);\n    if (count == 0) {\n        printf(\"No WIFI APNs found - can't continue further.\\n\");\n        return -1;\n    }\n\n    printf(\"\\nConnecting to %s...\\n\", MBED_CONF_APP_WIFI_SSID);\n    int ret = wifi.connect(MBED_CONF_APP_WIFI_SSID, MBED_CONF_APP_WIFI_PASSWORD, NSAPI_SECURITY_WPA_WPA2);\n    if (ret != 0) {\n        printf(\"\\nConnection error\\n\");\n        return -1;\n    }\n\n    printf(\"Success\\n\\n\");\n    printf(\"MAC: %s\\n\", wifi.get_mac_address());\n    printf(\"IP: %s\\n\", wifi.get_ip_address());\n    printf(\"Netmask: %s\\n\", wifi.get_netmask());\n    printf(\"Gateway: %s\\n\", wifi.get_gateway());\n    printf(\"RSSI: %d\\n\\n\", wifi.get_rssi());\n\n    http_demo(&wifi);\n\n    wifi.disconnect();\n\n    printf(\"\\nDone\\n\");\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/**\n * @file templated_functions.cpp\n * @author Abigale Kim (abigalek)\n * @brief Tutorial code for templated functions.\n */\n\n// Includes std::cout (printing) for demo purposes.\n#include <iostream>\n\n// Templates are a language feature in C++ that allow you to write code that\n// can work with multiple data types, without actually specifying those types.\n// In C++, you can create both templated functions and templated classes. We'll\n// talk about templated functions in this file.\n\n// Here is a basic templated function that adds two numbers.\n// Syntax note: You will see code with both template<class T> and\n// template<typename T>. Although these statements are equivalent, there are\n// differences between the class and typename keywords. This blog article covers\n// this difference, but you won't need to know this for the class:\n// https://mariusbancila.ro/blog/2021/03/15/typename-or-class/\ntemplate <typename T> T add(T a, T b) { return a + b; }\n\n// It is possible to pass multiple type names via templates into functions.\n// This function will print both of these values out.\ntemplate<typename T, typename U>\nvoid print_two_values(T a, U b) {\n  std::cout << a << \" and \" << b << std::endl;\n}\n\n// It is also possible to create specialized templated functions, that do\n// different things for different types. Take the following contrived example,\n// which prints the type if its a float type, but just prints hello world for\n// all other types.\ntemplate <typename T> void print_msg() { std::cout << \"Hello world!\\n\"; }\n\n// Specialized templated function, specialized on the float type.\ntemplate <> void print_msg<float>() {\n  std::cout << \"print_msg called with float type!\\n\";\n}\n\n// Lastly, template parameters do not have to be classes. Take this basic (yet\n// very contrived) function that takes in a bool as a template parameter and\n// does different things to the argument depending on the boolean argument.\ntemplate <bool T> int add3(int a) {\n  if (T) {\n    return a + 3;\n  }\n\n  return a;\n}\n\nint main() {\n  // First, let's see the add function called on both ints and floats.\n  std::cout << \"Printing add<int>(3, 5): \" << add<int>(3, 5) << std::endl;\n  std::cout << \"Printing add<float>(2.8, 3.7): \" << add<float>(2.8, 3.7)\n            << std::endl;\n\n  // It is also possible for a templated function to interpret the type of its\n  // arguments, although if you're a beginner in modern C++, it's preferred you\n  // don't do this because then you might not be sure of the types being passed\n  // into your functions.\n  std::cout << \"Printing add(3, 5): \" << add(3, 5) << std::endl;\n\n  // Second, let's see the print_two_values function being called with two\n  // different types.\n  std::cout << \"Printing print_two_values<int, float>(3, 3.2): \";\n  print_two_values<int, float>(3, 3.2);\n\n  // Let's see what happens when we called print_msg with and without the float\n  // type being passed in. As expected, the first call to print_msg prints out\n  // the general output, while the second one, with the float argument,\n  // recognizes its type parameter and calls the specialized function.\n  std::cout << \"Calling print_msg<int>(): \";\n  print_msg<int>();\n  std::cout << \"Calling print_msg<float>(): \";\n  print_msg<float>();\n\n  // add3 has the specified behavior for both a true and false templated\n  // argument, as we can see here.\n  std::cout << \"Printing add3<true>(3): \" << add3<true>(3) << std::endl;\n  std::cout << \"Printing add3<false>(3): \" << add3<false>(3) << std::endl;\n\n  // Lastly, it's important to note that most of these are contrived examples,\n  // and it is possible to code some of these functions (e.g. passing a boolean\n  // as an argument instead of a templated argument) without using templates.\n  // However, in the class, you'll be seeing code similar to this in the\n  // codebase, so it's good to understand templated functions in these contexts!\n\n  return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "//\n// Copyright (C) 2014-2016 LunarG, Inc.\n// Copyright (C) 2015-2016 Google, Inc.\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//\n//    Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//\n//    Redistributions in binary form must reproduce the above\n//    copyright notice, this list of conditions and the following\n//    disclaimer in the documentation and/or other materials provided\n//    with the distribution.\n//\n//    Neither the name of 3Dlabs Inc. Ltd. nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n// COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n//\n// Visit the nodes in the glslang intermediate tree representation to\n// translate them to SPIR-V.\n//\n\n#include \"spirv.hpp\"\n#include \"GlslangToSpv.h\"\n#include \"SpvBuilder.h\"\nnamespace spv {\n    #include \"GLSL.std.450.h\"\n    #include \"GLSL.ext.KHR.h\"\n    #include \"GLSL.ext.EXT.h\"\n#ifdef AMD_EXTENSIONS\n    #include \"GLSL.ext.AMD.h\"\n#endif\n#ifdef NV_EXTENSIONS\n    #include \"GLSL.ext.NV.h\"\n#endif\n}\n\n#ifdef ENABLE_OPT\n    #include \"spirv-tools/optimizer.hpp\"\n    #include \"message.h\"\n    #include \"SPVRemapper.h\"\n#endif\n\n#ifdef ENABLE_OPT\nusing namespace spvtools;\n#endif\n\n// Glslang includes\n#include \"../glslang/MachineIndependent/localintermediate.h\"\n#include \"../glslang/MachineIndependent/SymbolTable.h\"\n#include \"../glslang/Include/Common.h\"\n#include \"../glslang/Include/revision.h\"\n\n#include <fstream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <stack>\n#include <string>\n#include <vector>\n\nnamespace {\n\nnamespace {\nclass SpecConstantOpModeGuard {\npublic:\n    SpecConstantOpModeGuard(spv::Builder* builder)\n        : builder_(builder) {\n        previous_flag_ = builder->isInSpecConstCodeGenMode();\n    }\n    ~SpecConstantOpModeGuard() {\n        previous_flag_ ? builder_->setToSpecConstCodeGenMode()\n                       : builder_->setToNormalCodeGenMode();\n    }\n    void turnOnSpecConstantOpMode() {\n        builder_->setToSpecConstCodeGenMode();\n    }\n\nprivate:\n    spv::Builder* builder_;\n    bool previous_flag_;\n};\n}\n\n//\n// The main holder of information for translating glslang to SPIR-V.\n//\n// Derives from the AST walking base class.\n//\nclass TGlslangToSpvTraverser : public glslang::TIntermTraverser {\npublic:\n    TGlslangToSpvTraverser(unsigned int spvVersion, const glslang::TIntermediate*, spv::SpvBuildLogger* logger,\n        glslang::SpvOptions& options);\n    virtual ~TGlslangToSpvTraverser() { }\n\n    bool visitAggregate(glslang::TVisit, glslang::TIntermAggregate*);\n    bool visitBinary(glslang::TVisit, glslang::TIntermBinary*);\n    void visitConstantUnion(glslang::TIntermConstantUnion*);\n    bool visitSelection(glslang::TVisit, glslang::TIntermSelection*);\n    bool visitSwitch(glslang::TVisit, glslang::TIntermSwitch*);\n    void visitSymbol(glslang::TIntermSymbol* symbol);\n    bool visitUnary(glslang::TVisit, glslang::TIntermUnary*);\n    bool visitLoop(glslang::TVisit, glslang::TIntermLoop*);\n    bool visitBranch(glslang::TVisit visit, glslang::TIntermBranch*);\n\n    void finishSpv();\n    void dumpSpv(std::vector<unsigned int>& out);\n\nprotected:\n    spv::Decoration TranslateInterpolationDecoration(const glslang::TQualifier& qualifier);\n    spv::Decoration TranslateAuxiliaryStorageDecoration(const glslang::TQualifier& qualifier);\n    spv::BuiltIn TranslateBuiltInDecoration(glslang::TBuiltInVariable, bool memberDeclaration);\n    spv::ImageFormat TranslateImageFormat(const glslang::TType& type);\n    spv::SelectionControlMask TranslateSelectionControl(const glslang::TIntermSelection&) const;\n    spv::SelectionControlMask TranslateSwitchControl(const glslang::TIntermSwitch&) const;\n    spv::LoopControlMask TranslateLoopControl(const glslang::TIntermLoop&, unsigned int& dependencyLength) const;\n    spv::StorageClass TranslateStorageClass(const glslang::TType&);\n    spv::Id createSpvVariable(const glslang::TIntermSymbol*);\n    spv::Id getSampledType(const glslang::TSampler&);\n    spv::Id getInvert",
    "#include <GL/glut.h>\r\n\r\nfloat rotate_y = 0;\r\nfloat rotate_x = 0;\r\nfloat scale = 600.0f; \r\n\r\nvoid display() {\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n    glLoadIdentity();\r\n    glRotatef(rotate_x, 1.0, 0.0, 0.0);\r\n    glRotatef(rotate_y, 0.0, 1.0, 0.0);\r\n    \r\n    //IMAGEN TRASERA\r\n    glColor3f(0.2, 0.2, 1.0); \r\n    glBegin(GL_TRIANGLES);\r\n\tglVertex3f(199.00/scale, 20.00/scale, 8.00/scale);//1\r\n\tglVertex3f(161.00/scale, 20.00/scale, 8.00/scale);\r\n\tglVertex3f(180.00/scale, 39.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(160.00/scale, 21.00/scale, 8.00/scale);//2\r\n\tglVertex3f(179.00/scale, 40.00/scale, 8.00/scale);\r\n\tglVertex3f(141.00/scale, 59.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(159.00/scale, 21.00/scale, 8.00/scale);//3\r\n\tglVertex3f(139.00/scale, 59.00/scale, 8.00/scale);\r\n\tglVertex3f(121.00/scale, 59.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(180.00/scale, 41.00/scale, 8.00/scale);//4\r\n\tglVertex3f(141.00/scale, 60.00/scale, 8.00/scale);\r\n\tglVertex3f(180.00/scale, 99.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(140.00/scale, 61.00/scale, 8.00/scale);//5\r\n\tglVertex3f(101.00/scale, 100.00/scale, 8.00/scale);\r\n\tglVertex3f(179.00/scale, 100.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(139.00/scale, 61.00/scale, 8.00/scale);//6\r\n\tglVertex3f(121.00/scale, 61.00/scale, 8.00/scale);\r\n\tglVertex3f(101.00/scale, 99.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(100.00/scale, 99.00/scale, 8.00/scale);//7\r\n\tglVertex3f(95.00/scale, 41.00/scale, 8.00/scale);\r\n\tglVertex3f(119.00/scale, 60.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(101.00/scale, 101.00/scale, 8.00/scale);//8\r\n\tglVertex3f(179.00/scale, 101.00/scale, 8.00/scale);\r\n\tglVertex3f(110.00/scale, 159.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(179.00/scale, 103.00/scale, 8.00/scale);//9\r\n\tglVertex3f(112.00/scale, 158.00/scale, 8.00/scale);\r\n\tglVertex3f(188.00/scale, 148.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(111.00/scale, 160.00/scale, 8.00/scale);//10\r\n\tglVertex3f(189.00/scale, 150.00/scale, 8.00/scale);\r\n\tglVertex3f(160.00/scale, 218.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(190.00/scale, 151.00/scale, 8.00/scale);//11\r\n\tglVertex3f(161.00/scale, 220.00/scale, 8.00/scale);\r\n\tglVertex3f(199.00/scale, 219.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(110.00/scale, 161.00/scale, 8.00/scale);//12\r\n\tglVertex3f(159.00/scale, 220.00/scale, 8.00/scale);\r\n\tglVertex3f(111.00/scale, 279.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(161.00/scale, 221.00/scale, 8.00/scale);//13\r\n\tglVertex3f(199.00/scale, 241.00/scale, 8.00/scale);\r\n\tglVertex3f(189.00/scale, 318.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(160.00/scale, 221.00/scale, 8.00/scale);//14\r\n\tglVertex3f(111.00/scale, 280.00/scale, 8.00/scale);\r\n\tglVertex3f(189.00/scale, 319.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(111.00/scale, 281.00/scale, 8.00/scale);//15\r\n\tglVertex3f(121.00/scale, 339.00/scale, 8.00/scale);\r\n\tglVertex3f(189.00/scale, 320.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(110.00/scale, 280.00/scale, 8.00/scale);//16\r\n\tglVertex3f(40.00/scale, 240.00/scale, 8.00/scale);\r\n\tglVertex3f(119.00/scale, 339.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(190.00/scale, 321.00/scale, 8.00/scale);//17\r\n\tglVertex3f(121.00/scale, 340.00/scale, 8.00/scale);\r\n\tglVertex3f(170.00/scale, 379.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(120.00/scale, 341.00/scale, 8.00/scale);//18\r\n\tglVertex3f(130.00/scale, 300.00/scale, 8.00/scale);\r\n\tglVertex3f(169.00/scale, 380.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(169.00/scale, 381.00/scale, 8.00/scale);//19\r\n\tglVertex3f(131.00/scale, 400.00/scale, 8.00/scale);\r\n\tglVertex3f(140.00/scale, 518.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(170.00/scale, 381.00/scale, 8.00/scale);//20\r\n\tglVertex3f(179.00/scale, 400.00/scale, 8.00/scale);\r\n\tglVertex3f(141.00/scale, 519.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(180.00/scale, 401.00/scale, 8.00/scale);//21\r\n\tglVertex3f(142.00/scale, 520.00/scale, 8.00/scale);\r\n\tglVertex3f(180.00/scale, 520.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(181.00/scale, 401.00/scale, 8.00/scale);//22\r\n\tglVertex3f(181.00/scale, 520.00/scale, 8.00/scale);\r\n\tglVertex3f(219.00/scale, 520.00/scale, 8.00/scale);\r\n\t\r\n\r\n\t\r\n\t//IMAGEN DELANTERA\r\n\tglColor3f(0.0, 0.0, 0.0); \r\n\tglBegin(GL_TRIANGLES);\r\n\tglVertex3f(199.00/scale, 20.00/scale, -8.00/scale);//1\r\n\tglVertex3f(161.00/scale, 20.00/scale, -8.00/scale);\r\n\tglVertex3f(180.00/scale, 39.00/scale, -8.00/scale);\r\n\t\r\n\tglVertex3f(160.00/scale, 21.00/scale, -8.00/scale);//2\r\n\tglVertex3f(179.00/scale, 40.00/scale, -8.00/scale);\r\n\tglVertex3f(141.00/scale, 59.00/scale, -8.00/scale);\r\n\t\r\n\tglVertex3f(159.00/scale, 21.00/scale, -8.00/scale);//3\r\n\tglVertex3f(139.00/scale, 59.00/scale, -8.00/scale);\r\n\tglVertex3f(121.00/scale, 59.00/scale, -8.00/scale);\r\n\t\r\n\tglVertex3f(180.00/scale, 41.00/scale, -8.00/scale);//4\r\n\tglVertex3f(141.00/scale, 60.00/scale, -8.00/scale);\r\n\tglVertex3f(180.00/scale, 99.00/scale, -8.00/scale);\r\n\t\t\r\n\tglVertex3f(140.00/scale, 61.00/scale, -8.00/scale);//5\r\n\tglVertex3f(101.00/scale, 100.00/scale, -8.00/scale);\r\n\tglVertex3f(179.00/scale, 100.00/scale, -8.00",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\ntemplate <typename T>\r\nstruct Node {\r\n    T data;\r\n    Node *next;\r\n\r\n    Node() {};\r\n};\r\n\r\ntemplate <typename T>\r\nclass forward_list {\r\nprivate:\r\n    Node<T> *head;\r\n\r\npublic:\r\n    forward_list(): head(NULL) {}\r\n\r\n    // primer elemento\r\n    T front() {\r\n        if (empty()) {\r\n            return 0;\r\n        }\r\n        return head->data;\r\n    }\r\n\r\n    // \u00faltimo elemento\r\n    T back() {\r\n        if (empty()) {\r\n            return 0;\r\n        }\r\n\r\n        Node<T> *temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        return temp->data;\r\n    }\r\n\r\n    // agregar un elemento al inicio\r\n    void push_front(T data) {\r\n        Node<T> *temp = new Node<T>;\r\n        temp->data = data;\r\n        temp->next = head;\r\n        head = temp;\r\n    }\r\n\r\n    // agregar un elemento al final\r\n    void push_back(T data) {\r\n        if (empty()) {\r\n            push_front(data);\r\n            return;\r\n        }\r\n\r\n        Node<T> *node = new Node<T>;\r\n        node->data = data;\r\n        Node<T> *temp = head;\r\n        while (temp->next != NULL)\r\n            temp = temp->next;\r\n        temp->next = node;\r\n        node->next = NULL;\r\n    }\r\n\r\n    // eliminar el primer elemento\r\n    void pop_front() {\r\n        Node<T> *temp = head;\r\n        head = head->next;\r\n        delete temp;\r\n    }\r\n\r\n    // eliminar el \u00faltimo elemento\r\n    void pop_back() {\r\n        if (head->next == NULL) {\r\n            delete head;\r\n            head = NULL;\r\n        }\r\n\r\n        Node<T> *temp = head;\r\n        while (temp->next->next != NULL)\r\n            temp = temp->next;\r\n        delete temp->next;\r\n        temp->next = NULL;\r\n    }\r\n\r\n    T operator[](int index) {\r\n        if (index < 0 || index >= size()) {\r\n            return 0;\r\n        }\r\n\r\n        Node<T> *temp = head;\r\n        for (int i = 0; i < index; ++i)\r\n            temp = temp->next;\r\n        return temp->data;\r\n    }\r\n\r\n    // comprobar si est\u00e1 vac\u00edo\r\n    bool empty() {\r\n        return head == NULL;\r\n    }\r\n\r\n    // calcular tama\u00f1o\r\n    int size() {\r\n        int count = 0;\r\n        Node<T> *temp = head;\r\n        while (temp != NULL)\r\n        {\r\n            count++;\r\n            temp = temp->next;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    // eliminar todos los elementoss\r\n    void clear() {\r\n        while (!empty())\r\n            pop_front();\r\n    }\r\n\r\n    void sort() {\r\n        Node<T> *temp = head;\r\n        while (temp) {\r\n            Node<T> *min = temp;\r\n            Node<T> *r = temp->next;\r\n\r\n            while (r) {\r\n                if (min->data > r->data)\r\n                    min = r;\r\n                r = r->next;\r\n            }\r\n\r\n            T x = temp->data;\r\n            temp->data = min->data;\r\n            min->data = x;\r\n            temp = temp->next;\r\n        }\r\n    }\r\n\r\n    // Invierte el orden de los elementos\r\n    void reverse() {\r\n        Node<T> *current = head;\r\n        Node<T> *prev = NULL;\r\n        Node<T> *next = NULL;\r\n\r\n        while (current != NULL) {\r\n            next = current->next;\r\n            current->next = prev;\r\n            prev = current;\r\n            current = next;\r\n        }\r\n        head = prev;\r\n    }\r\n\r\n    // destructor\r\n    ~forward_list() {\r\n        while (head != NULL) {\r\n            Node<T> *temp = head;\r\n            head = head->next;\r\n            delete temp;\r\n        }\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <limits>\n#include <sstream>\n#include <random>\n#include \"Utility.h\"\n\n\n\n\nvoid helloWorld() {\n\tprintMessage(\"Hello World of C++.\");\n\n}\nstd::vector<int> generateRandomNumbers(int size) {\n\tstd::vector<int> randomNumbers;\n\tstd::srand(std::time(nullptr));\n\n\tfor (int i = 0; i < 12; i++) {\n\t\tint number = std::rand() % 100;\n\t\trandomNumbers.push_back(number);\n\t}\n\n\treturn randomNumbers;\n}\n\nvoid swap(std::vector<int>& vector, int firstIndex, int secondIndex) {\n\tint temp = vector[firstIndex];\n\tvector[firstIndex] = vector[secondIndex];\n\tvector[secondIndex] = temp;\n}\n\n\nvoid insertionSort(std::vector<int>& vector) {\n\tfor (int i = 0; i < vector.size() - 1; i++) {\n\n\t\tfor (int j = i + 1; j < vector.size(); j++) {\n\t\t\tif (vector[i] < vector[j]) {\n\t\t\t\tswap(vector, i, j);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nint findSmallestNumber(std::vector<int> vector) {\n\tint smallest = std::numeric_limits<int>::max();\n\tfor (int num : vector) {\n\t\tif (num < smallest) {\n\t\t\tsmallest = num;\n\t\t}\n\t}\n\treturn smallest;\n}\n\n\n\n\n",
    "\ufeff#include <iostream>\n#include <mutex>\n#include <thread>\n\nclass Data {\nprivate:\n   \npublic:\n    std::mutex g_mutex;\n    int count = 5;\n    bool selector = true;\n    Data(int new_count, bool new_selector) : count{ new_count }, selector{new_selector} {\n        \n    }\n    void show() {\n\n        std::cout << count << \"  \" << selector << std::endl;\n    }\n\n};\n\nvoid lock_swap(Data& obj1, Data& obj2) {\n\n    std::lock(obj1.g_mutex, obj2.g_mutex);\n    std::lock_guard<std::mutex> lk1(obj1.g_mutex, std::adopt_lock);\n    std::lock_guard<std::mutex> lk2(obj2.g_mutex, std::adopt_lock);\n\n    int tmp1 = std::move(obj1.count);\n    obj1.count = std::move(obj2.count);\n    obj2.count = std::move(tmp1);\n\n    bool tmp2 = std::move(obj1.selector);\n    obj1.selector = std::move(obj2.selector);\n    obj2.selector = std::move(tmp2);\n}\n\nvoid unique_swap(Data& obj1, Data& obj2) {\n\n    std::unique_lock<std::mutex> mutexLockGuard1(obj1.g_mutex, std::defer_lock);\n    std::unique_lock<std::mutex> mutexLockGuard2(obj2.g_mutex, std::defer_lock);\n    std::lock(mutexLockGuard1, mutexLockGuard2);\n\n    int tmp1 = std::move(obj1.count);\n    obj1.count = std::move(obj2.count);\n    obj2.count = std::move(tmp1);\n\n    bool tmp2 = std::move(obj1.selector);\n    obj1.selector = std::move(obj2.selector);\n    obj2.selector = std::move(tmp2);\n\n}\n\nvoid scoped_swap(Data& obj1, Data& obj2) {\n\n    std::scoped_lock mutexLockGuard(obj1.g_mutex, obj2.g_mutex);\n\n    int tmp1 = std::move(obj1.count);\n    obj1.count = std::move(obj2.count);\n    obj2.count = std::move(tmp1);\n\n    bool tmp2 = std::move(obj1.selector);\n    obj1.selector = std::move(obj2.selector);\n    obj2.selector = std::move(tmp2);\n\n}\n\nint main()\n{\n    setlocale(LC_ALL, \"russian\");\n\n    Data el1(4,true);\n    Data el2(9,false);\n\n    std::cout << \"\u0414\u043e \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438: \";\n    el1.show();\n    el2.show();\n\n    unique_swap(el1, el2);\n\n    std::cout << \"unique_swap: \";\n    el1.show();\n    el2.show();\n\n    scoped_swap(el1, el2);\n\n    std::cout << \"scoped_swap: \";\n    el1.show();\n    el2.show();\n\n    lock_swap(el1, el2);\n\n    std::cout << \"lock_swap: \";\n    el1.show();\n    el2.show();\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"project_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\n\r\nusing namespace std;\r\n\r\n\r\nint main() {\r\n    srand(time(NULL));\r\n    cout << \"Welcome to the Pokemon Battle Game\"<<endl;\r\n    cout << \"Choose one Pokemon to battle\"<<endl;\r\n    cout << \"Your options are 1) Pikachu  2)charlizard 3)Bulbasaur\" <<endl;\r\n    cout << \"You can only choose one\"<<endl;\r\n    int i;\r\n    cin >> i;\r\n    int cpu;\r\n    if(i == 1){\r\n        cout << \"Alright So you Choose Pikachu\"<<endl;\r\n    }\r\n    else if (i==2){\r\n        cout << \"Alright so you choose Charlizard\"<<endl;\r\n    }\r\n    else{\r\n        cout << \" Alright so you choose Bulbasaur\"<<endl;\r\n    }\r\n    cpu = rand()%3+1;\r\n    //cpu choosing pokemon\r\n     if(cpu == 1){\r\n        cout << \"Alright So CPU Choose Pikachu\"<<endl;\r\n    }\r\n    else if (cpu==2){\r\n        cout << \"Alright so CPU choose Charlizard\"<<endl;\r\n    }\r\n    else{\r\n        cout << \" Alright so CPU choose Bulbasaur\"<<endl;\r\n    }\r\n    //if the pokemon is same\r\n    if(i == cpu){\r\n        cout << \"You both have selected the same pokemon\"<<endl;\r\n        cout << \"So it is a draw\";\r\n    }\r\n    else if(i==1){\r\n        if(cpu==2){\r\n            cout << \"You have choosen Pikachu\"<<endl;\r\n            cout << \"CPU have choosen charlizard\"<<endl;\r\n            cout << \"Pikachu uses thuberbold but it was useless against charllizard\"<<endl;\r\n            cout << \"Charlizard uses fireball and defeats pikachu\";\r\n        }\r\n        if(cpu==3){\r\n            cout << \"You have Choosen Pikachu\"<<endl;\r\n            cout << \"Cpu have choosen balbasaur\"<<endl;\r\n            cout<<\"pikachu thunderbolts has no effect on balbasaur\"<<endl;\r\n            cout << \"balbasaur uses plantation and wins the match\";\r\n        }\r\n\r\n    }\r\n    else if(i==2){\r\n        if(cpu==1){\r\n\r\n            cout<<\"Charlizard uses fireball and won the match\";\r\n        }\r\n        if(cpu == 3){\r\n\r\n            cout<<\"Charlizard uses fireball and won the match\";\r\n        }\r\n\r\n    }\r\n    else if(i==3){\r\n        if(cpu==1){\r\n\r\n            cout<<\"Pikachu uses thuderbolt but doesnot work\"<<endl;\r\n            cout << \"Balbasaur uses plantation and won the match\";\r\n        }\r\n        if(cpu == 2){\r\n\r\n\r\n            cout << \"Balbasaur attacks didnot worked to charlizard\"<<endl;\r\n            cout << \"Charlizard finishes the match with the fireball attack\";\r\n        }\r\n    }\r\n\r\n\r\n    return 0;\r\n}\r\n",
    "#include<stdio.h>\r\n#include<stdlib.h>\r\n#include\"solver.h\"\r\n\r\nint main()\r\n{\r\n    char cmd, cmd1, cmd2;\r\n    printf(\"WELCOME TO EQUATION CALC!\\nVersion Beta 1.0\\nSolve any equations of upto the 3rd degree!\\nEnjoy!\\n\\n\");\r\n\r\n    while(1) {\r\n        printf(\"Please enter a command ('h' for help):\");\r\n        scanf(\" %c\", &cmd);\r\n        if (cmd == 'q' || cmd == 'Q') {\r\n            system(\"cls\");\r\n            printf(\"Bye! Have A Great Time!\\n\\nEquation Calc Beta 1.0\\n\");\r\n            break;\r\n        }\r\n\r\n        else if (cmd == 'm' || cmd == 'M') {\r\n            printf(\"Muggles! Enter a valid input!\\n\");\r\n            continue;\r\n        }\r\n\r\n        else if (cmd == 'h' || cmd == 'H') {\r\n            printf(\"q = quit the program\\nc = clear screen\\ns = Start the program\\n\");\r\n            continue;\r\n        }\r\n\r\n        else if (cmd == 'c' || cmd == 'C') {\r\n            system(\"cls\");\r\n            continue;\r\n        }\r\n\r\n        else if (cmd == 's' || cmd == 'S') {\r\n            while(1) {\r\n                printf(\"What type of equation do you want to solve?\\n 1~2\\n'q' to go to home screen or 'c' to clear screen:\");\r\n                scanf(\" %c\", &cmd1);\r\n                if (cmd1 == 'q' || cmd1 == 'Q') {\r\n                    printf(\"Exiting to home screen. . . . \\n\");\r\n                    break;\r\n                }\r\n\r\n                else if (cmd1 == 'c' || cmd1 == 'C') {\r\n                    system(\"cls\");\r\n                    continue;\r\n                }\r\n\r\n                else if (cmd1 == '1') {\r\n                    printf(\"How many unknowns? 1~2:\");\r\n                    scanf(\" %c\", &cmd2);\r\n                    if (cmd2 == '1') {\r\n                        sol11();\r\n                    }\r\n                    else if (cmd2 == '2') {\r\n                        sol12();\r\n                    }\r\n                }\r\n\r\n                else if (cmd1 == '2') {\r\n                    sol21();\r\n                }\r\n            }\r\n        }\r\n\r\n        else {\r\n            printf(\"Invalid input!\\n\");\r\n            continue;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"desafio_calculadora\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mainwindow.h\"\n\n#include \"ui_mainwindow.h\"\n\nextern \"C\" {\n#include \"../s21_smartcalc.h\"\n}\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent), ui(new Ui::MainWindow) {\n  ui->setupUi(this);\n\n  ui->tabWidget->setTabText(0, \"Calculator v1.0\");\n  ui->tabWidget->setTabText(1, \"Credit and deposit\");\n\n  ui->result_show->setReadOnly(true);\n  ui->mouth_pay->setReadOnly(true);\n  ui->full_sum->setReadOnly(true);\n  ui->pereplata->setReadOnly(true);\n\n  QString style =\n      \"QDoubleSpinBox {\"\n      \"background-color: rgb(10, 186, 181);\"  // \u0444\u043e\u043d\n      \"border-radius: 5px;\"                   // \u0443\u0433\u043b\u043e\u0432\n      \"color: rgb(0, 0, 0);\"                  // \u0442\u0435\u043a\u0441\u0442\n      \"font-size: 20px;\"                      // \u0448\u0440\u0438\u0444\u0442\u0430\n      \"}\";\n\n  ui->x_show->setStyleSheet(style);\n  ui->sum_cred->setStyleSheet(style);\n  ui->time->setStyleSheet(style);\n  ui->pecent->setStyleSheet(style);\n\n  connect(ui->frog, SIGNAL(clicked()), this, SLOT(touch_me()));\n\n  connect(ui->p_0, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_1, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_2, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_3, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_4, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_5, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_6, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_7, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_8, SIGNAL(clicked()), this, SLOT(digits_press()));\n  connect(ui->p_9, SIGNAL(clicked()), this, SLOT(digits_press()));\n\n  connect(ui->arcos, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->arcsin, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->artan, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->sin, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->cos, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->tan, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->ln, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->log, SIGNAL(clicked()), this, SLOT(trig_press()));\n  connect(ui->sqrt, SIGNAL(clicked()), this, SLOT(trig_press()));\n\n  connect(ui->div, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->mul, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->stepen, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->sub, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->sum, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->scob_l, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->scob_w, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->perem, SIGNAL(clicked()), this, SLOT(bin_press()));\n  connect(ui->mod, SIGNAL(clicked()), this, SLOT(bin_press()));\n}\n\nMainWindow::~MainWindow() { delete ui; }\n\nvoid MainWindow::digits_press() {\n  QPushButton *digits = (QPushButton *)sender();\n\n  ui->result_show->setText(ui->result_show->text() + digits->text());\n}\n\nvoid MainWindow::bin_press() {\n  QPushButton *bin = (QPushButton *)sender();\n\n  ui->result_show->setText(ui->result_show->text() + bin->text());\n}\n\nvoid MainWindow::trig_press() {\n  QPushButton *trig = (QPushButton *)sender();\n\n  ui->result_show->setText(ui->result_show->text() + trig->text() + \"(\");\n}\n// \u0442\u0443\u0442 \u043e\u0441\u043d\u043e\u0432\u043d\u043e\u0435\nvoid MainWindow::on_ent_clicked() {\n  double x = 0;\n  x = ui->x_show->text().toDouble();\n  std::string str = ui->result_show->text().toStdString();\n  char *stroka = (char *)str.c_str();\n  if (check_input(stroka) == 0) {\n    double res = parser(stroka, x);\n    QString result = QString::number(res);\n    ui->result_show->setText(result);\n  } else\n    ui->result_show->setText(\"ERROR\");\n}\n\nvoid MainWindow::on_CLEAR_clicked() { ui->result_show->setText(\"\"); }\n\nvoid MainWindow::on_dote_clicked() {\n  if (ui->result_show->text().isEmpty() ||\n      ui->result_show->text().back() != '.')\n    ui->result_show->setText(ui->result_show->text() + \".\");\n}\n\nvoid MainWindow::on_graph_clicked() {\n  std::string str = ui->result_show->text().toStdString();\n  char *gr_str = (char *)str.c_str();\n  if (check_input(gr_str) == 0) {\n    double Ymax = ui->y_max->text().toDouble(),\n           Ymin = ui->y_min->text().toDouble();\n    double min = ui->x_min->text().toDouble();\n    double max = ui->x_max->text().toDouble();\n    if (Ymax != 0 && Ymin != 0 && max != 0 && min != 0 && max > min &&\n        Ymax > Ymin) {\n      double yy = 0;\n      int N = 10000;\n      if (max <= 5 || min >= -5) N = 100;\n      double h = (max - min) / N;\n\n      QVector<double> x(N), y(N);\n      int i = 0;\n      for (double X = min; X <= max;) {\n        x[i] = X;\n        yy = parser(gr_str, X);\n        yy > Ymax || yy < Ymin ? y[i] = qQNaN() : y[i] = yy;\n        X += h;\n        i++;\n      }\n      ui->widget->clearGraphs();\n      ui->widget->addGraph();\n      ui->widget->graph(0)->setData(x, y);\n      ui->widget->xAxis->setLabel(\"x\");\n      ui->widget->yAxis->setLabel(\"y\");\n      ui->widget->xAxis->setRange",
    "#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n/*\n00 01 02\n10 11 12\n20 21 22\n\n\n\uc0c1 \ud558 \uc88c \uc6b0\n-1 1 0 0\n0 0 -1 1\n*/\n\nstruct Square {\n\tint y; int x; int n;\n};\n\nstruct POS {\n\tint y, x;\n\tint isNotValid;\n\tint number;\n};\nvector<POS> v;\n\nint dy[] = { -1,1,0,0 };\nint dx[] = { 0,0,-1,1 };\n\nint arr[14][14];\nint N, M, K;\nPOS exitPos;\n\n//\ud68c\uc804 \uad6c\ud604\nvoid rotation(int y, int x, int w) {\n\tint copyArr[50][50] = { 0 , };\n\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcopyArr[i][j] = arr[y + i][x + j];\n\t\t}\n\t}\n\n\tint rotationArr[50][50] = { 0, };\n\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tif (copyArr[i][j] < 10 && copyArr[i][j] != -1 && copyArr[i][j] != 0) copyArr[i][j]--;\n\t\t\trotationArr[j][w - i - 1] = copyArr[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tarr[y + i][x + j] = rotationArr[i][j];\n\t\t\tif (arr[y + i][x + j] >= 10) {\n\t\t\t\tv[(arr[y + i][x + j] / 10) - 1].y = y + i;\n\t\t\t\tv[(arr[y + i][x + j] / 10) - 1].x = x + j;\n\t\t\t}\n\t\t\tif (arr[y + i][x + j] == -1) {\n\t\t\t\texitPos.y = y + i;\n\t\t\t\texitPos.x = x + j;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\n\n//\uc815\uc0ac\uac01\ud615 \ubf51\uae30\nSquare squareSelect() {\n\n\tfor (int n = 2; n <= 10; n++) {\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tint isExit = 0;\n\t\t\t\tint isPeople = 0;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor (int ii = i; ii < i + n; ii++) {\n\t\t\t\t\tfor (int jj = j; jj < j + n; jj++) {\n\t\t\t\t\t\tif (ii < 0 || ii >= N || jj < 0 || jj >= N) {\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (arr[ii][jj] == -1) isExit = 1;\n\t\t\t\t\t\tfor (int p = 0; p < v.size(); p++) {\n\t\t\t\t\t\t\tif (v[p].isNotValid == 1) continue;\n\t\t\t\t\t\t\tif (ii == v[p].y&&jj == v[p].x) {\n\t\t\t\t\t\t\t\tisPeople++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag)break;\n\t\t\t\t}\n\n\t\t\t\tif (isExit&&isPeople) {\n\t\t\t\t\tSquare s;\n\t\t\t\t\ts.y = i;\n\t\t\t\t\ts.x = j;\n\t\t\t\t\ts.n = n;\n\t\t\t\t\treturn s;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSquare s;\n\ts.y = 0;\n\ts.x = 0;\n\ts.n = 0;\n\treturn s;\n}\n\nvoid check() {\n\tfor (int n = 2; n <= 2; n++) {\n\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tint isExit = 0;\n\t\t\t\tint isPeople = 0;\n\t\t\t\tfor (int ii = i; ii < i + n; ii++) {\n\t\t\t\t\tfor (int jj = j; jj < j + n; jj++) {\n\t\t\t\t\t\tprintf(\"[%d, %d] \", ii, jj);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n//\ucd08\uae30\ud654\nvoid init() {\n\tmemset(arr, 0, sizeof(arr));\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &arr[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < M; i++) {\n\t\tint y, x;\n\t\tscanf(\"%d %d\", &y, &x);\n\t\tarr[y - 1][x - 1] = (i + 1) * 10;\n\t\tv.push_back({ y - 1,x - 1,0,(i + 1) * 10 });\n\t}\n\n\n\tscanf(\"%d %d\", &exitPos.y, &exitPos.x);\n\texitPos.y--;\n\texitPos.x--;\n\tarr[exitPos.y][exitPos.x] = -1;\n}\nint ret = 0;\n\nint distanceCal(int y, int x) {\n\treturn abs(exitPos.y - y) + abs(exitPos.x - x);\n}\n\nbool safeZone(int y, int x) {\n\treturn 0 < y || y < N || 0 < x || x < N;\n}\nvoid play() {\n\t//\uc774\ub3d9\n\tint finishFlag = 0;\n\twhile (K--) {\n\t\tint outCount = 0;\n\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].isNotValid == 1) {\n\t\t\t\toutCount++;\n\t\t\t}\n\t\t}\n\t\tif (outCount == v.size()) {\n\t\t\tfinishFlag = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\toutCount = 0;\n\t\t\tfor (int j = 0; j < v.size(); j++) {\n\t\t\t\tif (v[j].isNotValid == 1) {\n\t\t\t\t\toutCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint cy = v[i].y;\n\t\t\tint cx = v[i].x;\n\n\t\t\tif (v[i].isNotValid == 1) {\n\t\t\t\toutCount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (outCount == v.size()) break;\n\t\t\tint beforeShortDistance = distanceCal(cy, cx);\n\n\t\t\tfor (int d = 0; d < 4; d++) {\n\n\t\t\t\tint ny = cy + dy[d];\n\t\t\t\tint nx = cx + dx[d];\n\t\t\t\tif (!safeZone(ny, nx)) continue;\n\t\t\t\tif (arr[ny][nx] == 0 || arr[ny][nx] == -1) {\n\t\t\t\t\tint afterShortDistance = distanceCal(ny, nx);\n\t\t\t\t\tif (beforeShortDistance > afterShortDistance) {\n\t\t\t\t\t\tif (arr[ny][nx] == -1) {\n\t\t\t\t\t\t\tv[i].isNotValid = 1;\n\t\t\t\t\t\t\tarr[v[i].y][v[i].x] = 0;\n\t\t\t\t\t\t\tret++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarr[ny][nx] = arr[cy][cx];\n\t\t\t\t\t\tarr[cy][cx] = 0;\n\t\t\t\t\t\tv[i].y = ny;\n\t\t\t\t\t\tv[i].x = nx;\n\t\t\t\t\t\tret++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (finishFlag)break;\n\n\n\n\t\tSquare square = squareSelect();\n\t\trotation(square.y, square.x, square.n);\n\n \t}\n\n}\nint main(void) {\n\n\tint TC = 1;\n\tfor (int tc = 1; tc <= TC; tc++) {\n\t\tinit();\n\n\n\t\tplay();\n\n\t\tprintf(\"%d\\n\", ret);\n\t\tprintf(\"%d %d\\n\", exitPos.y + 1, exitPos.x + 1);\n\t}\n\treturn 0;\n}",
    "#include\"bag.h\"\n#include <cstdlib>\n#include <time.h>\n#include <iostream>\n#include <fstream>\n\nint main() {\n    Bag user_bag;\n    string user_pick;\n    int user_bag_size;\n    cout << \"Would you like to set the size of the bag? (Y/N)\\n\";\n    cin >> user_pick;\n    if (user_pick == \"Y\" or \"y\")\n    {\n        cout << \"\\nWhat size is your bag?\\n\";\n        cin >> user_bag_size;\n        user_bag.set_bag_size(user_bag_size);\n    }\n    else if (user_pick == \"N\" or \"n\")\n    {\n        \n    }\n    else\n    {\n        return 0;\n    }\n\n    srand(time(0));\n    for (int i = 0; i < user_bag.get_bag_size(); i++) \n    {\n        cout << \"6965969696969696969\\n\\n\";\n        int hold = rand() % 6;\n        if (hold = 1) {\n            string new_color  = \"Black\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 2) {\n            string new_color  = \"Green\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 3) {\n            string new_color  = \"Blue\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 4) {\n            string new_color  = \"Purple\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 5) {\n            string new_color  = \"Red\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n    }\n\n    for (int j = 0; j < user_bag.get_bag_size(); j++) \n    {\n        int hold = rand() % 4;\n        if (hold = 1) {\n            string new_size  = \"L\";\n            user_bag.bag[j].set_marble_size(new_size);     \n        }\n        else if (hold = 2) {\n            string new_size  = \"S\";\n            user_bag.bag[j].set_marble_size(new_size);     \n        }\n        else if (hold = 3) {\n            string new_size  = \"M\";\n            user_bag.bag[j].set_marble_size(new_size);     \n        }\n    }\n\n    for (int k = 0; k < user_bag.get_bag_size(); k++) \n    {\n        cout << user_bag.bag[k].get_marble_color() << \"\\n\";\n        cout << user_bag.bag[k].get_marble_size() << \"\\n\\n\";\n    }\n    //return 0;\n}",
    "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define im {ios_base::sync_with_stdio(false);}\n#define gay {cin.tie(NULL);}\n\nconst string PAIR_LEFT = \"(\";\nconst string PAIR_RIGHT = \")\";\n\nconst string IT_LEFT = \"\";\nconst string IT_RIGHT = \"\";\n\n// const string IT_LEFT = \"[\";\n// const string IT_RIGHT = \"]\";\n\n// const string PAIR_LEFT = \"{\";\n// const string PAIR_RIGHT = \"}\";\n// const string IT_LEFT = \"{\";\n// const string IT_RIGHT = \"}\";\n\n// benq - print any container + pair\ntemplate<typename T, typename = void> struct is_iterable : false_type {};\ntemplate<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << PAIR_LEFT << p.f << \", \" << p.s << PAIR_RIGHT; }\ntemplate<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {\n    cout << IT_LEFT; \n    for (auto it = v.begin(); it != v.end();) {\n        cout << *it;\n        if (++it != v.end()) cout << \", \";\n    }\n    return cout << IT_RIGHT;\n}\ntemplate<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {\n    cin >> p.first;\n    return cin >> p.second;\n}\ntemplate<typename T>\nistream& operator >>(istream &cin, vector<T> &v) {\n  for (auto &x: v) cin >> x;\n  return cin;\n}\ntemplate<typename T> void debug(string s, T x) {cerr << \"\\033[1;34m\" << s << \"\\033[0;32m = \\033[35m\" << x << \"\\033[0m\\n\";}\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) {for (int i=0, b=0; i<(int)s.size(); i++) if (s[i] == '(' || s[i] == '{') b++; else\r\n        if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {cerr << \"\\033[1;34m\" << s.substr(0, i) << \"\\033[0;32m = \\033[35m\" << x << \"\\033[31m | \"; debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}\r\ntemplate<typename T> void debug_nameless(T x) {cerr << \"\\033[35m\" << x << \"\\033[0m\\n\";}\ntemplate<typename T, typename... Args> void debug_nameless(T x, Args... args) {cerr << \"\\033[35m\" << x << \"\\033[31m | \"; debug_nameless(args...);}\r\n\n#define pr(...) debug(#__VA_ARGS__, __VA_ARGS__)\n#define prs(...) debug_nameless(__VA_ARGS__)\nconst bool local_ = true;\n/* #else\n#define pr(...) 135\n#define prs(...) 135\nconst bool local_ = false;\n#endif */\n\nconst bool run = local_ ? 0 : 1;\nvoid solve(int tc = 0) {\n  int k, q;\n  cin >> k >> q;\n  vector<int> rule(k);\n  vector<int> people(q);\n  cin >> rule;\n  cin >> people;\n  for(int j = 0; j < people.size(); j++) {\n    int row = people.at(j);\n    while(1) {\n      int remove = 0;\n      for(int i = 0; i < k; i++) {\n        if(rule.at(i) <= row)\n          row--;\n      }\n      // pr(row);\n      if(row < rule.at(0)) {\n        break;\n      }\n    }\n    cout << row << \" \";\n  }  \n} \n\nint main() {\n        auto begin = std::chrono::high_resolution_clock::now();\n    \n    im gay\n\n    cout << setprecision(15) << fixed;\n    cerr << setprecision(4) << fixed;\n            \n    int tc = 1;\n    // if (local_)\n    // if (!run)\n    cin >> tc;\n    for (int t = 0; t < tc; t++) {\n        pr(t); prs(string(50, '-'));\n        solve(t);\n        prs(string(50, '-') + \"\\n\");\n    }\n    \n        auto end = std::chrono::high_resolution_clock::now();\n        cerr << setprecision(4) << fixed;\n        cerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;\n}\n",
    "#include \"LongNumber.h\"\n\n#include <unordered_map>\n\nnamespace\n{\n\tstd::unordered_map<char, TYPE> charToTYPE =\n\t{\n\t\t{'0', 0},\n\t\t{'1', 1},\n\t\t{'2', 2},\n\t\t{'3', 3},\n\t\t{'4', 4},\n\t\t{'5', 5},\n\t\t{'6', 6},\n\t\t{'7', 7},\n\t\t{'8', 8},\n\t\t{'9', 9},\n\t};\n\n\tstd::unordered_map<TYPE, char> typeToChar =\n\t{\n\t\t{0, '0'},\n\t\t{1, '1'},\n\t\t{2, '2'},\n\t\t{3, '3'},\n\t\t{4, '4'},\n\t\t{5, '5'},\n\t\t{6, '6'},\n\t\t{7, '7'},\n\t\t{8, '8'},\n\t\t{9, '9'},\n\t};\n}\n\nLongNumber::LongNumber()\n\t: _negative(false)\n{\n}\n\nLongNumber::LongNumber(const LongNumber& n)\n\t: _data(n._data)\n\t, _negative(n._negative)\n{\n}\n\nLongNumber::LongNumber(LongNumber&& n) noexcept\n\t: _data(std::move(n._data))\n\t, _negative(n._negative)\n{\n}\n\nLongNumber::LongNumber(std::string s)\n{\n\tif (s.size() == 0)\n\t{\n\t\treturn;\n\t}\n\telse if (s[0] == '-')\n\t{\n\t\t_negative = true;\n\t}\n\n\tfor (long long i = s.size() - 1; i >= (int)(s[0] == '-'); i--)\n\t{\n\t\t_data.push_back(charToTYPE[s[i]]);\n\t}\n\n\t_checkZero(*this);\n}\n\nLongNumber& LongNumber::operator=(const LongNumber& n)\n{\n\t_data = n._data;\n\t_negative = n._negative;\n\n\treturn *this;\n}\n\nLongNumber& LongNumber::operator=(LongNumber&& n) noexcept\n{\n\t_data = std::move(n._data);\n\t_negative = n._negative;\n\n\treturn *this;\n}\n\nLongNumber LongNumber::operator+(const LongNumber& n) const\n{\n\tif (_negative && !n._negative)\n\t{\n\t\treturn n - (-(*this));\n\t}\n\tif (!_negative && n._negative)\n\t{\n\t\treturn *this - (-n);\n\t}\n\n\tLongNumber result;\n\n\tif (_negative && n._negative)\n\t{\n\t\tresult._negative = true;\n\t}\n\n\tsize_t minSize = std::min(_data.size(), n._data.size());\n\tsize_t maxSize = std::min(_data.size(), n._data.size());\n\n\tBIG_TYPE resVal = 0;\n\tTYPE quot = 0;\n\tTYPE rem = 0;\n\n\tfor (size_t i = 0; i < minSize; i++)\n\t{\n\t\tresVal = static_cast<BIG_TYPE>(_data[i])\n\t\t\t+ static_cast<BIG_TYPE>(n._data[i]) + \n\t\t\tstatic_cast<BIG_TYPE>(quot);\n\t\tquot = resVal / (_getMaxTypeValue() + 1);\n\t\trem = resVal % (_getMaxTypeValue() + 1);\n\t\t\n\t\tresult._data.push_back(rem);\n\t}\n\n\tfor (size_t i = minSize; i < _data.size(); i++)\n\t{\n\t\tresVal = static_cast<BIG_TYPE>(_data[i]) +\n\t\t\tstatic_cast<BIG_TYPE>(quot);\n\t\tquot = resVal / (_getMaxTypeValue() + 1);\n\t\trem = resVal % (_getMaxTypeValue() + 1);\n\t\t\n\t\tresult._data.push_back(rem);\n\t}\n\n\tfor (size_t i = minSize; i < n._data.size(); i++)\n\t{\n\t\tresVal = static_cast<BIG_TYPE>(n._data[i]) +\n\t\t\tstatic_cast<BIG_TYPE>(quot);\n\t\tquot = resVal / (_getMaxTypeValue() + 1);\n\t\trem = resVal % (_getMaxTypeValue() + 1);\n\n\t\tresult._data.push_back(rem);\n\t}\n\n\tresult._data.push_back(quot);\n\t_checkZero(result);\n\n\treturn result;\n}\n\nvoid LongNumber::operator+=(const LongNumber& n)\n{\n\t*this = *this + n;\n}\n\nLongNumber LongNumber::operator-(const LongNumber& n) const\n{\n\tif (_negative && !n._negative)\n\t{\n\t\treturn (-(*this)) + n;\n\t}\n\tif (!_negative && n._negative)\n\t{\n\t\treturn *this + (-n);\n\t}\n\n\tLongNumber result;\n\n\tif (!_negative && !n._negative)\n\t{\n\t\tif (*this < n)\n\t\t{\n\t\t\tresult = n - *this;\n\t\t\tresult._negative = true;\n\t\t\treturn result;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tresult._negative = false;\n\t\t}\n\t}\n\n\tif (_negative && n._negative)\n\t{\n\t\tif (n._absIsGreater(*this))\n\t\t{\n\t\t\tresult = n - *this;\n\t\t\tresult._negative = false;\n\t\t\treturn result;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult._negative = true;\n\t\t}\n\t}\n\n\tsize_t minSize = std::min(_data.size(), n._data.size());\n\tsize_t maxSize = std::min(_data.size(), n._data.size());\n\n\tBIG_TYPE fut = 0;\n\tBIG_TYPE val = 0;\n\tBIG_TYPE curDataVal = 0;\n\n\tfor (size_t i = 0; i < minSize; i++)\n\t{\n\t\tcurDataVal = static_cast<BIG_TYPE>(_data[i]) - fut;\n\t\t\n\n\t\tif (curDataVal >= n._data[i])\n\t\t{\n\t\t\tval = curDataVal - n._data[i];\n\t\t\tfut = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfut = 1;\n\t\t\tval = static_cast<BIG_TYPE>(curDataVal) + _getMaxTypeValue() + 1\n\t\t\t\t- static_cast<BIG_TYPE>(n._data[i]);\n\t\t}\n\t\tresult._data.push_back(val);\n\t}\n\n\tfor (size_t i = minSize; i < _data.size(); i++)\n\t{\n\t\tcurDataVal = static_cast<BIG_TYPE>(_data[i]) - fut;\n\n\t\tif (curDataVal >= 0)\n\t\t{\n\t\t\tval = curDataVal;\n\t\t\tfut = 0;\n\t\t}\n\t\telse {\n\t\t\tval = curDataVal + _getMaxTypeValue();\n\t\t\tfut = 1;\n\t\t}\n\n\t\tresult._data.push_back(val);\n\t}\n\n\t_checkZero(result);\n\n\treturn result;\n}\n\nvoid LongNumber::operator-=(const LongNumber& n)\n{\n\t*this = *this - n;\n}\n\nLongNumber LongNumber::operator*(const LongNumber& n)\n{\n\tLongNumber result;\n\tBIG_TYPE val = 0;\n\tBIG_TYPE quot = 0;\n\tBIG_TYPE rem = 0;\n\n\tfor (size_t i = 0; i < n._data.size(); i++)\n\t{\n\t\tLongNumber tempResult;\n\t\tfor (size_t j = 0; j < _data.size(); j++)\n\t\t{\n\t\t\tval = static_cast<BIG_TYPE>(_data[j]) *\n\t\t\t\tstatic_cast<BIG_TYPE>(n._data[i]) + quot;\n\t\t\tquot = val / (_getMaxTypeValue() + 1);\n\t\t\trem = val % (_getMaxTypeValue() + 1);\n\t\t\ttempResult._data.push_back(rem);\n\t\t}\n\t\twhile (quot > 0)\n\t\t{\n\t\t\trem = quot % (_getMaxTypeValue() + 1);\n\t\t\tquot /= (_getMaxTypeValue() + 1);\n\t\t\ttempResult._data.push_back(rem);\n\t\t}\n\t\t_checkZero(tempResult);\n\t\tstd::vector<TYPE> empty(i);\n\t\ttempResult._data.insert(tempResult._data.begin(), empty.begin(), empty.end());\n\t\tresult += tempResult;\n\t}\n\n\tresult._negative = _negative != n._negative;\n\t_checkZero(result);\n\treturn result;\n}\n\nvoid LongNumber::operator*=(const LongNumber& n)\n{\n\t*this = *this * n;\n}\n\nLongN",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Pawns/Bird.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"InputMappingContext.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputAction.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"GameFramework/FloatingPawnMovement.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n\n\n// Sets default values\nABird::ABird()\n{\n \t// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBirdCapsule = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"BirdCapsule\"));\n\tSetRootComponent(BirdCapsule);\n\tBirdCapsule->SetCapsuleRadius(10.f);\n\tBirdCapsule->SetCapsuleHalfHeight(20.f);\n\t\n\tBirdMesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"BirdMesh\"));\n\tBirdMesh->SetupAttachment(GetRootComponent());\n\n\tBirdSpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"BirdSpringArm\"));\n\tBirdSpringArm->SetupAttachment(GetRootComponent());\n\tBirdSpringArm->TargetArmLength = 300.f;\n\tBirdSpringArm->bInheritPitch = true;\n\tBirdSpringArm->bInheritYaw = true;\n\tBirdSpringArm->bUsePawnControlRotation = true;\n\t\n\tBirdCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"BirdCamera\"));\n\tBirdCamera->SetupAttachment(BirdSpringArm);\n\t\n\tFloatingMovement = CreateDefaultSubobject<UFloatingPawnMovement>(TEXT(\"Floating Movement\"));\n\t\n\tAutoPossessPlayer = EAutoReceiveInput::Player0;\n}\n\n// Called when the game starts or when spawned\nvoid ABird::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\nvoid ABird::MoveForward(const FInputActionInstance& Instance)\n{\n\tAddMovementInput(GetActorForwardVector(), Instance.GetValue().Get<float>());\n}\n\nvoid ABird::MoveRight(const FInputActionInstance& Instance)\n{\n\tAddMovementInput(GetActorRightVector(), Instance.GetValue().Get<float>());\n}\n\nvoid ABird::Look(const FInputActionInstance& Instance)\n{\n\tAddControllerYawInput(Instance.GetValue().Get<FVector2D>().X);\n\tAddControllerPitchInput(Instance.GetValue().Get<FVector2D>().Y * -1.f);\n}\n\n// Called every frame\nvoid ABird::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid ABird::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\tUEnhancedInputComponent* Input = Cast<UEnhancedInputComponent>(PlayerInputComponent);\n\n\tif (ULocalPlayer* LocalPlayer = Cast<ULocalPlayer>(GEngine->GetGamePlayer(GetWorld(), 0)->PlayerController->GetLocalPlayer()))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* InputSystem = LocalPlayer->GetSubsystem<UEnhancedInputLocalPlayerSubsystem>())\n\t\t{\n\t\t\tif (!InputMapping.IsNull())\n\t\t\t{\n\t\t\t\tInputSystem->AddMappingContext(InputMapping.LoadSynchronous(), 0);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"SetupPlayerInputComponent FAILED\"));\n\t}\n\t\n\t// You can bind to any of the trigger events here by changing the \"ETriggerEvent\" enum value\n\tif(MoveForwardAction)\n\t{\n\t\tInput->BindAction(MoveForwardAction, ETriggerEvent::Triggered, this, &ABird::MoveForward);\t\n\t}\n\n\tif(MoveRightAction)\n\t{\n\t\tInput->BindAction(MoveRightAction, ETriggerEvent::Triggered, this, &ABird::MoveRight);\n\t}\n\n\tif(LookAction)\n\t{\n\t\tInput->BindAction(LookAction, ETriggerEvent::Triggered, this, &ABird::Look);\n\t}\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"signin\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"sensorsAPI.h\"\n\n\nSensorsAPI::SensorsAPI(const char* apiURL, const char* apiKey, const char* deviceId, TaskHandle_t task1) {\n  //copy deviceId to API url. Stayed with char arrays\n  int bufferSize = strlen(apiURL) + strlen(deviceId) + 1;\n  char* concatString = new char[ bufferSize ];\n  strcpy( concatString, apiURL );\n  strcat( concatString, deviceId );\n\n  this->_apiURL = concatString;\n  this->_apiKey = apiKey;\n  this->_t1 = task1;\n  this->taskCreated = 0;\n  this->_debug = false;\n}\n\nvoid SensorsAPI::enableDebugging() {\n  this->_debug = true;\n}\nvoid SensorsAPI::debug(String msg) {\n  if (this->_debug) {\n    Serial.println(msg);\n  }\n}\n\nbool SensorsAPI::isRequestFinished() {\n  return this->_requestSent;\n}\n\nvoid SensorsAPI::deleteRequestTask() {\n  vTaskDelete(this->_t1);\n  this->_requestSent = false;\n  this->debug(\"Deleted send POST task\");\n}\n\nvoid SensorsAPI::_sendAsyncPost(void* pvParameter) {\n  SensorsAPI* SensorsAPIInstance = (SensorsAPI *) pvParameter;\n  TaskHandle_t xHandle = NULL;\n  SensorsAPIInstance->debug(\"starting _sendAsyncPost running on core \");\n  SensorsAPIInstance->debug(String(xPortGetCoreID()));\n  //SensorsAPIInstance->_requestSent = false;\n  while (1) {\n    if(WiFi.status()== WL_CONNECTED && !SensorsAPIInstance->_requestSent) {\n      HTTPClient http;\n\n      http.begin(SensorsAPIInstance->_apiURL);  \t\n      http.addHeader(\"x-api-key\", SensorsAPIInstance->_apiKey);\n\n      int startTime = millis();\n      int httpResponseCode = http.POST(SensorsAPIInstance->_req);\n      SensorsAPIInstance->debug(\"Finished in:  \");\n      SensorsAPIInstance->debug(String(millis() - startTime));\n\n      SensorsAPIInstance->debug(\"response code: \");\n      SensorsAPIInstance->debug(String(httpResponseCode));\n      if(httpResponseCode>0){\n        String response = http.getString(); \n        Serial.println(response);           //Print request answer\n      }\n     SensorsAPIInstance-> _requestSent = true;\n    }\n    //wait for the kill. Can't kill task here from here because memory will be not freed.\n    delay(500);\n  }\n}\n\nint SensorsAPI::sendReadings(JsonDocument &req) {\n  this->debug(\"\\nMain task running on core \");\n  this->debug(String(xPortGetCoreID()));\n\n  this->debug(\"Core1 time: \");\n  this->debug(String(millis()));\n\n  String requestBody;\n  serializeJson(req, requestBody);\n  _req = requestBody;\n\n  taskCreated = millis();\n  xTaskCreatePinnedToCore(\n    this->_sendAsyncPost, /* Task function. */\n    \"Task1\",   /* name of task. */\n    30000,     /* Stack size of task */\n    (void *)this,      /* parameter of the task */\n    1,         /* priority of the task */\n    &_t1,    /* Task handle to keep track of created task */\n    0\n  );        /* pin task to core 0 */\n  \n  this->debug(\"Core1 time after creating new task: \");\n  this->debug(String(millis()));\n  \n  return 0;\n}\n\n//LEGACY METHOD. First version of method with manual JSON building. Created for tests with single value. Better to use sendReadings instead(). This one is blocking CPU\nint SensorsAPI::sendReading(float tempC) {\n  if(WiFi.status()== WL_CONNECTED) {\n    HTTPClient http;\n\n    http.begin(_apiURL);  \t\n    http.addHeader(\"x-api-key\", _apiKey);\n\n    String requestBody1, requestBody2, requestBody3;\n    requestBody1 = String(\"{\\\"temp1\\\": \");\n    requestBody2 = String();\n    requestBody3 = String();\n    requestBody2 = requestBody1 + tempC;\n    requestBody3 = requestBody2 + \"}\";\n    int httpResponseCode = http.POST(requestBody3);\n\n    this->debug(\"response code: \");\n    this->debug(String(httpResponseCode));\n    if(httpResponseCode>0){\n      String response = http.getString(); \n      this->debug(response);\n    }\n\n    return httpResponseCode;\n\n  } else {\n    this->debug(\"WiFi Disconnected\");\n  }\n  return 0;\n}\n",
    "#include \"../common.hpp\"\n#include <sys/types.h>\n#include <md5.h>\n\nbool is_filled(char pass[8])\n{\n    for(int i = 0; i < 8; i++)\n    {\n        if(pass[i] == '\\0') \n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid md5_hash(char *input, char *output)\n{\n    MD5Context context;\n    MD5Init(&context);\n    MD5Update(&context, (uint8_t *)input, strlen(input));\n    MD5End(&context, output);\n}\n\nauto part_1([[maybe_unused]] std::string input)\n{\n    auto input1 = input.substr(0, input.size() - 1);\n    const char *s = input1.c_str();\n    char buf[50];\n\n    char md5[33];\n    size_t pass_size = 0;\n    std::stringstream pass;\n\n    for(uint32_t i = 0; i < INT_MAX && pass_size < 8; i++)\n    {\n        sprintf(buf, \"%s%u\", s, i);\n        md5_hash(buf, md5);\n        if(strncmp(\"00000\", md5, 5) == 0)\n        {\n            pass << md5[5];\n            pass_size++;\n        }\n    }\n\n    return pass.str(); \n}\n\nauto part_2([[maybe_unused]] std::string input)\n{\n    auto input1 = input.substr(0, input.size() - 1);\n    const char *s = input1.c_str();\n    char buf[50];\n\n    char md5[33];\n    char pass[8] = {0};\n\n    for(uint32_t i = 0; i < INT_MAX && !is_filled(pass); i++)\n    {\n        sprintf(buf, \"%s%u\", s, i);\n        md5_hash(buf, md5);\n        if(strncmp(\"00000\", md5, 5) == 0)\n        {\n            int pos = md5[5] - '0';\n            if(pass[pos] == '\\0' && pos < 8)\n            {\n                pass[pos] = md5[6];\n            }\n        }\n    }\n\n    return std::string(pass, 8);\n}\n\nint main(int argc, char **argv)\n{\n    auto args = get_args(argc, argv);\n    auto input = read_all_text(args.front());\n    std::cout << \"Part 1: \" << part_1(input) << std::endl\n              << \"Part 2: \" << part_2(input) << std::endl \n              << std::endl;\n\n    return 0;\n}\n",
    "//\n//  Jetclustering_example.cpp\n//  \n//\n//  Created by Yasmin Sarhan on 4/2/24.\n//\n#include <iostream>\n#include <vector>\n#include <random>\n#include <chrono>\n#include \"fastjet/ClusterSequence.hh\"\n\nusing namespace std;\nusing namespace fastjet;\n\nvector<PseudoJet> generate_particles(int num_particles) {\n    vector<PseudoJet> particles;\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_real_distribution<> dis_px(-100.0, 100.0);\n    uniform_real_distribution<> dis_py(-0.1, 0.1);\n    uniform_real_distribution<> dis_energy(50.0, 150.0);\n\n    for (int i = 0; i < num_particles; ++i) {\n        double px = dis_px(gen);\n        double py = dis_py(gen);\n        double pz = 0.0; // Assuming particles are in the transverse plane\n        double energy = dis_energy(gen);\n        particles.push_back(PseudoJet(px, py, pz, energy));\n    }\n    return particles;\n}\n\ndouble run_jet_clustering(int num_particles) {\n    // Generate particles\n    vector<PseudoJet> particles = generate_particles(num_particles);\n\n    // Choose a jet definition\n    double R = 0.7;\n    JetDefinition jet_def(antikt_algorithm, R);\n\n    // Record start time\n    auto start_time = chrono::high_resolution_clock::now();\n\n// Run clustering, extract jets\n    ClusterSequence cs(particles, jet_def);\n    vector<PseudoJet> jets = sorted_by_pt(cs.inclusive_jets());\n\n    // Record end time\n    auto end_time = chrono::high_resolution_clock::now();\n\n    // Calculate runtime\n    chrono::duration<double> runtime = end_time - start_time;\n\n    // Print out some info\n    cout << \"Clustered with \" << jet_def.description() << endl;\n\n    // Print the jets\n    cout << \"        pt y phi\" << endl;\n    for (unsigned i = 0; i < jets.size(); ++i) {\n        cout << \"jet \" << i << \": \" << jets[i].pt() << \" \" << jets[i].rap() << \" \" << jets[i].phi() << endl;\n        vector<PseudoJet> constituents = jets[i].constituents();\n        for (unsigned j = 0; j < constituents.size(); ++j) {\n            cout << \"    constituent \" << j << \"'s pt: \" << constituents[j].pt() << endl;\n        }\n    }\n\n    // Return runtime\n    return runtime.count();\n}\n\nint main() {\n    int num_particles = 100; // Change this number to specify the number of particles\n    double runtime = run_jet_clustering(num_particles);\n    cout << \"Runtime: \" << runtime << \" seconds\" << endl;\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Arduino.h\"\n#include <WifiManager.h>\n#include <HTTPClient.h>\n#include <WiFi.h>\n\n#include \"esp32cam.h\"\n\nesp32cam::Resolution initialResolution;\n\nWiFiManager wm;\n\n//TODO: this probably isn't the right URL but idk\nconst char* serverUrl = \"http://alex-is-cool:5000/upload\";\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(2000);\n  Serial.println(\"serial initialized\");\n\n  {\n    using namespace esp32cam;\n\n    initialResolution = Resolution::find(1024, 768);\n\n    Config cfg;\n    cfg.setPins(pins::AiThinker);\n    cfg.setResolution(initialResolution);\n    cfg.setJpeg(80);\n\n    bool ok = Camera.begin(cfg);\n    if (!ok) {\n      Serial.println(\"camera initialize failure\");\n      delay(5000);\n      ESP.restart();\n    }\n    Serial.println(\"camera initialize success\");\n  }\n\n  bool res = wm.autoConnect(\"EspSketchCam\", \"urMomLol\");\n  if (!res) {\n    Serial.println(\"Failed to connect to WiFi\");\n    ESP.restart();\n  } else {\n    Serial.println(\"Connected to WiFi\");\n  }\n\n  Serial.println(\"tcp server started\");\n}\n\nvoid loop() {\n  delay(1000);\n  Serial.println(\"Capturing image... Say cheese!\");\n\n  // capture image to send\n  using namespace esp32cam;\n  auto frame = Camera.capture();\n  if (frame == nullptr) {\n    Serial.println(\"Failed to capture image\");\n    return;\n  }\n\n  if ((WiFi.status() == WL_CONNECTED)) { //Check the current connection status\n    HTTPClient http;\n\n    http.begin(serverUrl); //Specify the URL\n    http.addHeader(\"Content-Type\", \"application/octet-stream\"); //Specify content-type header \n\n    int httpResponseCode = http.POST((uint8_t*)frame->data(), frame->size());   //Send the actual POST request\n\n    if (httpResponseCode>0) {\n      String response = http.getString();   //Get the response to the request\n      Serial.println(httpResponseCode);   //Print return code\n      Serial.println(response);           //Print request answer\n    } else {\n      Serial.print(\"Error on sending POST: \");\n      Serial.println(httpResponseCode);\n    }\n\n    http.end(); //Free resources\n  }\n\n  // print ip\n  Serial.println(WiFi.localIP());\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nint termal();\nint joaquim();\nint bombom();\nint agua();\nint camisa();\n\nint main() {\n    termal();\n    joaquim();\n    bombom();\n    agua();\n    camisa();\n\n    return 0;\n}\n\nint termal() {\n    int instalacao = 300;\n    int limpeza = 150;\n    float manutencao = 499.99;\n\n    float total = instalacao + limpeza + manutencao;\n\n    cout << \"Questao 1: \";\n    cout << total;\n\n    // Retornando um valor inteiro\n    return 0;\n};\n\nint joaquim() {\n    int horasPorDia = 8;\n    float moneyPorHora = 35.00;\n\n    float moneyPorDia = moneyPorHora * horasPorDia;\n\n    cout << \"\\n\";\n    cout << \"Questao 2: \";\n    cout << moneyPorDia;\n\n    return 0;\n};\n\nint bombom() {\n    int unidadesPorCaixa = 27;\n    int caixasCompradas = 16;\n\n    int bombonsComprados = caixasCompradas * unidadesPorCaixa;\n\n    cout << \"\\n\";\n    cout << \"Questao 3: \";\n    cout << bombonsComprados;\n\n    return 0;\n}\n\nint agua() {\n    int garrafasVendidas = 300;\n    int garrafasPorCaixa = 20;\n\n    int caixasUsadas = garrafasVendidas / garrafasPorCaixa;\n\n    cout << \"\\n\";\n    cout << \"Questao 4: \";\n    cout << caixasUsadas;\n\n    return 0;\n}\n\nint camisa() {\n    int camisasCompradas = 120;\n    int camisasVendidas = 80;\n    float precoCamisa = 30.00;\n    int camisasCompradasDnv = 50;\n\n    int camisasRestantes = camisasCompradas + camisasCompradasDnv - camisasVendidas;\n    float faturamento = camisasVendidas * precoCamisa;\n\n    cout << \"\\n\";\n    cout << \"Questao 5: \";\n    cout << \"\\n\";\n    cout << \"\\n\";\n    cout << \"faturamento = \";\n    cout << faturamento;\n    cout << \"\\n\";\n    cout << \"camisas restantes = \";\n    cout << camisasRestantes;\n\n    cout << \"\\n\";\n    return 0;\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutterproject\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* -*- c++ -*- */\n/*\n * Copyright 2020 Free Software Foundation, Inc.\n *\n * This file is part of GNU Radio\n *\n * SPDX-License-Identifier: GPL-3.0-or-later\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"tcp_sink_impl.h\"\n#include <gnuradio/io_signature.h>\n\n#include <chrono>\n#include <sstream>\n#include <thread>\n\nnamespace gr {\nnamespace network {\n\ntcp_sink::sptr tcp_sink::make(\n    size_t itemsize, size_t veclen, const std::string& host, int port, int sinkmode)\n{\n    return gnuradio::make_block_sptr<tcp_sink_impl>(\n        itemsize, veclen, host, port, sinkmode);\n}\n\n/*\n * The private constructor\n */\ntcp_sink_impl::tcp_sink_impl(\n    size_t itemsize, size_t veclen, const std::string& host, int port, int sinkmode)\n    : gr::sync_block(\"tcp_sink\",\n                     gr::io_signature::make(1, 1, itemsize * veclen),\n                     gr::io_signature::make(0, 0, 0)),\n      d_itemsize(itemsize),\n      d_veclen(veclen),\n      d_host(host),\n      d_port(port),\n      d_sinkmode(sinkmode),\n      d_thread_running(false),\n      d_stop_thread(false),\n      d_listener_thread(NULL),\n      d_start_new_listener(false),\n      d_initial_connection(true)\n{\n    d_block_size = d_itemsize * d_veclen;\n    freq_flag = 0;\n    start_flag = 0;\n    s_cycle=0;\n    meanVec_flag = 0;\n    ch_flag = 0;\n    s1 = fopen(\"/home/usrp/Documents/sendersidefile.bin\", \"wb\");\n    oneCount = 0;\n    chCounter = 0;\n    chCounter1 = 0;\n    meanVecCount=0;\n    one_last_flag = 0;\n    single_time_freq_flag = 0;\n    last_flag_for_meanvec = 0;\n    last_flag_for_ch = 0;\n    local_freq = 0;\n\n    local_meanVec = (gr_complex*) malloc (sizeof(gr_complex)*16384);\n    local_ch_idx = (gr_complex*) malloc (sizeof(gr_complex)*16384);\n    local_ch_cen = (gr_complex*) malloc (sizeof(gr_complex)*16384);\n    local_ch_mag = (gr_complex*) malloc (sizeof(gr_complex)*16384);\n    local_ch_bw = (gr_complex*) malloc (sizeof(gr_complex)*16384);\n    \n}\n\nbool tcp_sink_impl::start()\n{\n    if (d_sinkmode == TCPSINKMODE_CLIENT) {\n        // In this mode, we're connecting to a remote TCP service listener\n        // as a client.\n        d_logger->info(\"[TCP Sink] connecting to {:s} on port {:d}\", d_host, d_port);\n\n        asio::error_code err;\n        d_tcpsocket = new asio::ip::tcp::socket(d_io_context);\n\n        std::string s_port = std::to_string(d_port);\n        asio::ip::tcp::resolver resolver(d_io_context);\n        asio::ip::tcp::resolver::query query(\n            d_host, s_port, asio::ip::resolver_query_base::passive);\n\n        d_endpoint = *resolver.resolve(query, err);\n\n        if (err) {\n            throw std::runtime_error(\n                std::string(\"[TCP Sink] Unable to resolve host/IP: \") + err.message());\n        }\n\n        if (d_host.find(\":\") != std::string::npos)\n            d_is_ipv6 = true;\n        else {\n            // This block supports a check that a name rather than an IP is provided.\n            // the endpoint is then checked after the resolver is done.\n            if (d_endpoint.address().is_v6())\n                d_is_ipv6 = true;\n            else\n                d_is_ipv6 = false;\n        }\n\n        d_tcpsocket->connect(d_endpoint, err);\n        if (err) {\n            throw std::runtime_error(std::string(\"[TCP Sink] Connection error: \") +\n                                     err.message());\n        }\n\n        d_connected = true;\n\n        asio::socket_base::keep_alive option(true);\n        d_tcpsocket->set_option(option);\n    } else {\n        // In this mode, we're starting a local port listener and waiting\n        // for inbound connections.\n        d_start_new_listener = true;\n        d_is_ipv6 = false;\n        d_listener_thread = new std::thread([this] { run_listener(); });\n    }\n\n    return true;\n}\n\nvoid tcp_sink_impl::run_listener()\n{\n    d_thread_running = true;\n\n    while (!d_stop_thread) {\n        // this will block\n        if (d_start_new_listener) {\n            d_start_new_listener = false;\n            connect(d_initial_connection);\n            d_initial_connection = false;\n        } else\n            std::this_thread::sleep_for(std::chrono::microseconds(10));\n    }\n\n    d_thread_running = false;\n}\n\nvoid tcp_sink_impl::accept_handler(asio::ip::tcp::socket* new_connection,\n                                   const asio::error_code& error)\n{\n    if (!error) {\n        d_logger->info(\"Client connection received.\");\n\n        // Accept succeeded.\n        d_tcpsocket = new_connection;\n\n        asio::socket_base::keep_alive option(true);\n        d_tcpsocket->set_option(option);\n        d_connected = true;\n\n    } else {\n        d_logger->error(\"Error code {:s} accepting TCP session.\", error.message());\n\n        // Boost made a copy so we have to clean up\n        delete new_connection;\n\n        // safety settings.\n        d_connected = false;\n        d_tcpsocket = NULL;\n    }\n}\n\nvoid tcp_sink_impl::connect(bool initial_connection)\n{\n    d_logger->info(\"Waiting for connection on port {:d}\", d_port);\n\n    if (initial_connection) {\n        if",
    "#include \"Contact.h\"\r\n\r\n// Constructors\r\nContact::Contact()\r\n{\r\n\tfirst_name = \"\";\r\n\tlast_name = \"\";\r\n\tmobile_number = \"\";\r\n\temail_address = \"\";\r\n\taddress = nullptr;\r\n}\r\n\r\nContact::Contact(std::string first_name, std::string last_name, std::string mobile_number, std::string email_address, Address *address)\r\n{\r\n\tset_first_name(first_name);\r\n\tset_last_name(last_name);\r\n\tset_mobile_number(mobile_number);\r\n\tset_email_address(email_address);\r\n\tset_address(address);\r\n}\r\n\r\n// Setters\r\nvoid Contact::set_first_name(std::string first_name)\r\n{\r\n\tif (first_name.size() != 0)\r\n\t\tthis->first_name = first_name;\r\n}\t\r\nvoid Contact::set_last_name(std::string last_name)\r\n{\r\n\tif (last_name.size() != 0)\r\n\t\tthis->last_name = last_name;\r\n}\r\nvoid Contact::set_mobile_number(std::string mobile_number)\r\n{\r\n\tif (mobile_number.size() != 0 && mobile_number.size() == 11)\r\n\t\tthis->mobile_number = mobile_number;\r\n}\r\nvoid Contact::set_email_address(std::string email_address)\r\n{\r\n\tif (email_address.size() != 0)\r\n\t\tthis->email_address = email_address;\r\n}\r\nvoid Contact::set_address(Address *address)\r\n{\r\n\tif (address != nullptr){\r\n\t\tthis->address = address;\r\n\t}\r\n\t\t\r\n}\r\n\r\n// Getters\r\nstd::string Contact::get_first_name() const { return first_name; }\r\nstd::string Contact::get_last_name() const { return last_name; }\r\nstd::string Contact::get_mobile_number() const { return mobile_number; }\r\nstd::string Contact::get_email_address() const { return email_address; }\r\nAddress* Contact::get_address() const { return address; }\r\n\r\n// equals() method to test if passed contact is equal to *this\r\nbool Contact::equals(Contact contact)\r\n{\r\n\tif (this->first_name == contact.first_name && this->last_name == contact.last_name && this->mobile_number == contact.mobile_number && this->email_address == contact.email_address && this->address->equals(*contact.address))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid Contact::print_contact()\r\n{\r\n\tstd::cout << \"\\nName: \" << first_name << \" \" << last_name << std::endl;\r\n\tstd::cout << \"Mobile Number: \" << mobile_number << std::endl;\r\n\tstd::cout << \"Email Address: \" << email_address << std::endl;\r\n\tstd::cout << \"Address: \" << address->get_house() << \", \" << address->get_street() << \", \" << address->get_city() << \", \" << address->get_country() << std::endl;\r\n}\r\n\r\n// Return a deep copy of *this\r\nContact* Contact::copy_contact()\r\n{\r\n\tContact* copiedContact = new Contact();\r\n\tcopiedContact->first_name = this->first_name;\r\n\tcopiedContact->last_name = this->last_name;\r\n\tcopiedContact->mobile_number = this->mobile_number;\r\n\tcopiedContact->email_address = this->email_address;\r\n\tcopiedContact->address = new Address(this->address->get_house(), \r\n\t\tthis->address->get_street(), \r\n\t\tthis->address->get_city(), \r\n\t\tthis->address->get_country());\r\n\treturn copiedContact;\r\n}\r\n\r\n// Overload cin for Contact\r\nstd::istream& operator>>(std::istream& in, Contact& contact)\r\n{\r\n\tstd::cout << \"\\nEnter first name: \";\r\n\tin >> contact.first_name;\r\n\tstd::cout << \"Enter last name: \";\r\n\tin >> contact.last_name;\r\n\tstd::cout << \"Enter mobile number: \";\r\n\tin >> contact.mobile_number;\r\n\tstd::cout << \"Enter email address: \";\r\n\tin >> contact.email_address;\r\n\tstd::cout << \"\\nEnter address: \" << std::endl;\r\n\tif (contact.address == nullptr) {\r\n        contact.address = new Address();\r\n    }\r\n\t// Will use overloaded cin for Address\r\n\tin >> *(contact.address);\r\n\treturn in;\r\n}\r\n",
    "\ufeff#include <iostream>\n\nusing namespace std;\n\nclass Point {\nprotected:\n    int x;\n    int y;\npublic:\n    Point() : x(0), y(0) {\n        printf(\"Point()\\n\");\n    }\n    Point(int x, int y) : x(x), y(y) {\n        printf(\"Point(int x, int y)\\n\");\n    }\n    Point(const Point& p) : x(p.x), y(p.y) {\n        printf(\"Point(const Point& p)\\n\");\n    }\n    ~Point() {\n        printf(\"x=%d, y=%d\\n~Point()\\n\", x, y);\n    }\n    void setValues(int x, int y) {\n        printf(\"setValues(int x, int y)\\n\");\n        this->x = x;\n        this->y = y;\n    }\n    void resetValues();\n};\n\nvoid Point::resetValues() {\n    printf(\"resetValues()\\n\");\n    x = 0;\n    y = 0;\n}\n\nclass NewPointWithMove : public Point {\npublic:\n    void move(int deltaX, int deltaY) {\n        printf(\"move(int deltaX, int deltaY)\\n\");\n        x = x + deltaX;\n        y = y + deltaY;\n    }\n};\n\nclass Circle : public Point {\nprivate:\n    int radius;\npublic:\n    Circle() : radius(1) {\n        printf(\"Circle()\\n\");\n    }\n    Circle(int x, int y, int radius) : Point(x, y), radius(radius) {\n        printf(\"Circle(int x, int y, int radius)\\n\");\n    }\n    Circle(const Circle& c) : Point(c), radius(c.radius) {\n        printf(\"Circle(const Circle & c)\\n\");\n    }\n    ~Circle() {\n        printf(\"radius=%d\\n~Circle()\\n\", radius);\n    }\n    void setValues(int x, int y, int radius) {\n        printf(\"setValues(int x, int y, int radius)\\n\");\n        this->x = x;\n        this->y = y;\n        this->radius = radius;\n    }\n    void resetValues() {\n        printf(\"Circle resetValues()\\n\");\n        x = 0;\n        y = 0;\n        radius = 1;\n    }\n    void radiusChange(int deltaRadius) {\n        printf(\"radiusChange(int deltaRadius)\\n\");\n        radius = radius + deltaRadius;\n    }\n};\n\nclass Section {\nprivate:\n    Point p1;\n    Point p2;\npublic:\n    Section() {\n        printf(\"Section()\\n\");\n    }\n    Section(int x1, int y1, int x2, int y2) : p1(x1, y1), p2(x2, y2) {\n        printf(\"Section(int x1, int y1, int x2, int y2)\\n\");\n    }\n    Section(const Section& s) : p1(s.p1), p2(s.p2) {\n        printf(\"Section(const Section& s)\\n\");\n    }\n    ~Section() {\n        printf(\"~Section()\\n\");\n    }\n    void reset() {\n        printf(\"reset()\\n\");\n        p1 = Point();\n        p2 = Point();\n    }\n};\n\nclass Rectangle {\nprivate:\n    Point* p;\n    int width;\n    int height;\npublic:\n    Rectangle() {\n        printf(\"Rectangle()\\n\");\n        p = new Point;\n        width = 0;\n        height = 0;\n    }\n    Rectangle(int x, int y, int width, int height) {\n        printf(\"Rectangle(int x, int y, int width, int height)\\n\");\n        p = new Point(x, y);\n        this->width = width;\n        this->height = height;\n    }\n    Rectangle(const Rectangle& r) {\n        printf(\"Rectangle(const Rectangle& r)\\n\");\n        p = new Point(*(r.p));\n        width = r.width;\n        height = r.height;\n    }\n    ~Rectangle() {\n        printf(\"width=%d, height=%d\\n~Rectangle()\\n\", width, height);\n        delete p;\n    }\n};\n\n\nint main() {\n\n    Rectangle* r1 = new Rectangle;\n    Rectangle* r2 = new Rectangle(1, 1, 4, 4);\n    Rectangle* r3 = new Rectangle(*r2);\n\n    delete r1;\n    delete r2;\n    delete r3;\n\n    system(\"pause\");\n    return 0;\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"magic8_decision_maker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Server.hpp\"\n\n/******************************************************************/\n/********************|MAIN FUNCTION           |********************/\n/******************************************************************/\nbool checkPort(std::string port)\n{\n    if (port.find_first_not_of(\"0123456789\") == std::string::npos\\\n        && (std::atoi(port.c_str()) >= 1024 && std::atoi(port.c_str()) <= 65535))\n        return (true);\n    return (false);\n}\n\nint main(int ac, char **av)\n{\n\tServer irc_server;\n\n    std::cout<<GRE<<\"\u25a0\"<<WHI<<\" Server is starting...\"<<std::endl;\n\ttry\n\t{\n\t\t if (ac != 3)\n            throw(std::invalid_argument(\"\\033[38:5:208m\u25a0 \\e[0;37musage : ./ircserv \\\"PORT\\\" \\\"SERVER PASSWORD\\\" \"));\n        else if (!checkPort(av[1]))\n            throw(std::invalid_argument(\"\\033[38:5:208m\u25a0 \\e[0;37merror :port : must be between \\e[1;31m1024 \\e[0;37mand \\e[1;31m65535\\e[0;37m \"));\n        else if (std::strlen(av[2]) > 20)\n            throw(std::invalid_argument(\"\\033[38:5:208m\u25a0 \\e[0;37merror :password : must be less than or equal to \\e[1;31m20 \\e[0;37mcharacters \"));\n\t\tsignal(SIGINT, Server::SignalHandler);\n\t\tsignal(SIGQUIT, Server::SignalHandler);\n\t\tirc_server.init(std::atoi(av[1]), av[2]);\n\t}\n\tcatch(const std::exception& e)\n\t{\n\t\tirc_server.closesFds();\n\t\tstd::cerr<<e.what()<<std::endl;\n\t}\n    std::cout<<RED<<\"\u25a0\"<<WHI<<\" The Server Closed !\"<<std::endl;\n\treturn (0);\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <gtest/gtest.h>\n#include <gmock/gmock.h>\n#include \"RedisClient.hpp\"\n#include \"MockRedis.hpp\"\n#include <iostream>\n#include <sw/redis++/redis++.h>\n\nusing namespace std;\nusing namespace testing;\n\nclass RedisClientTest_UT2 : public ::testing::Test {\n  protected:\n    std::shared_ptr<RedisClient> test_instance;\n    static void SetUpTestCase() {\n\n    }\n\n    static void TearDownTestCase() {\n\n    }\n\n    virtual void SetUp() {\n      ConnectionOptions opts2;\n      opts2.host = \"127.0.0.1\";\n      opts2.port = 6379;\n      opts2.socket_timeout = std::chrono::milliseconds(500);\n      auto redis_ = new sw::redis::Redis(opts2);\n      test_instance = std::make_shared<RedisClient>(redis_);\n      mock_redis = new MockRedis();\n    }\n\n    virtual void TearDown() {\n      delete mock_redis;\n    }\n};\n\nTEST_F(RedisClientTest_UT2, perform_002) {\n  const std::vector<std::string> send_messages {\n    \"Message 1\",\n    \"Message 2\",\n    \"Message 3\",\n    \"Message 4\",\n    \"Message 5\",\n  };\n  std::vector<std::string> receive_messages;\n\n  std::function<void (const std::string &)> callback = [&](std::string msg) {\n      // Process message of MESSAGE type.\n      cout << \"main: callback => receive msg: \" << msg << endl;\n      receive_messages.push_back(msg);\n  };\n  const string channel = \"test_channel\";\n\n  EXPECT_CALL(*mock_redis, publish(_, _)).WillRepeatedly([&](const sw::redis::StringView &channel, const sw::redis::StringView &message){\n    throw std::runtime_error(\"fack exception\"); return -1L;\n  });\n\n  EXPECT_THROW({\n    // test_instance->subscribe(channel, callback);\n    test_instance->publish(channel, send_messages[0]);\n  }, std::runtime_error);\n}",
    "// ------------------------------------------------------------------------------------\n// Author: spexcher\n// Name: Gourab Modak\n// email: spexcher@gmail.com\n// Linktree: https://linktr.ee/spexcher/\n// Github: https://github.com/spexcher/\n// linkedin : https://www.linkedin.com/in/gourabmodak/\n// ------------------------------------------------------------------------------------\n#include <bits/stdc++.h>\n#include <chrono>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate <typename T>\nusing oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <class key, class value, class cmp = less_equal<key>>\nusing omap = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate <typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n#define ll long long\n#define ull unsigned long long\n#define lld long double\n#define eb emplace_back\n#define pb push_back\n#define ppb pop_back\n#define sqrt(x) sqrtl((x))\n#define ceil(x) ceill((x))\n#define abs(x) labs((x))\n#define floor(x) floorl((x))\n#define ceildiv(a, b) ((a + b - 1) / b)\n#define vi vector<int>\n#define vll vector<ll>\n#define vvb vector<vector<bool>>\n#define vvc vector<vector<char>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define vvi vector<vector<int>>\n#define vvll vector<vector<ll>>\n#define vvb vector<vector<bool>>\n#define vvpii vector<vector<pii>>\n#define vvpll vector<vector<pll>>\n#define vpii vector<pii>\n#define vpll vector<pll>\n#define si set<int>\n#define sll set<ll>\n#define sc set<char>\n#define mii map<int, int>\n#define mll map<ll, ll>\n#define mci map<char, int>\n#define mcll map<char, ll>\n#define pqi priority_queue<int>\n#define pqll priority_queue<ll>\ntemplate <class T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nusing max_heap = priority_queue<T>;\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sortall(x) sort(all(x))\n#define ff first\n#define ss second\n#define spre(x) cout << fixed << setprecision(x)\n#define PI 3.1415926535897932384626\n#define infinity 1e18\n#define py cout << \"YES\\n\"\n#define pm cout << \"-1\\n\"\n#define pn cout << \"NO\\n\"\n#define pm cout << \"-1\\n\"\n#define pl cout << \"\\n\"\n#define nl \"\\n\"\n#define sp \" \"\n#define print(x) cout << x << \"\\n\"\n#define deb(x) cout << #x << \"=\" << x << endl\n#define upper(s1) transform(s1.begin(), s1.end(), s1.begin(), ::toupper)\n#define lower(s1) transform(s1.begin(), s1.end(), s1.begin(), ::tolower)\n#define maxe(v) *max_element(v.begin(), v.end())\n#define mine(v) *min_element(v.begin(), v.end())\n#define unq(v) v.resize(distance(v.begin(), unique(all(v))))\n#define getunique(v)                  \\\n  {                                   \\\n    sort(all(v));                     \\\n    v.erase(unique(all(v)), v.end()); \\\n  }\n#define sum(v) accumulate(all(v), 0)\n#define sz(x) (ll) x.size()\n#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define gc getchar_unlocked\n#define fo(i, n) for (int i = 0; i < n; i++)\n#define Fo(i, k, n) \\\n  for (int i = k; k <= n ? i <= n : i >= n; k <= n ? i += 1 : i -= 1)\n#define FoS(i, k, n, step) \\\n  for (int i = k; k <= n ? i <= n : i >= n; k <= n ? i += step : i -= step)\n#define setbits(n) __builtin_popcountll(n)\n#define counttz(n) __builtin_ctzll(n)\n#define countlz(n) __builtin_clzll(n)\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define fast_io                      \\\n  startTime = clock();               \\\n  ios_base::sync_with_stdio(false);  \\\n  cin.tie(NULL);                     \\\n  cout.tie(NULL);                    \\\n  cout << fixed << setprecision(25); \\\n  cerr << fixed << setprecision(10)\nclock_t startTime;\n// i/p o/p overloads\ntemplate <typename typC, typename typD>\nistream &operator>>(istream &cin, pair<typC, typD> &a) { return cin >> a.first >> a.second; }\ntemplate <typename typC>\nistream &operator>>(istream &cin, vector<typC> &a)\n{\n  for (auto &x : a)\n    cin >> x;\n  return cin;\n}\ntemplate <typename typC, typename typD>\nostream &operator<<(ostream &cout, const pair<typC, typD> &a) { return cout << a.first << ' ' << a.second; }\ntemplate <typename typC, typename typD>\nostream &operator<<(ostream &cout, const vector<pair<typC, typD>> &a)\n{\n  for (auto &x : a)\n    cout << x << '\\n';\n  return cout;\n}\ntemplate <typename typC>\nostream &operator<<(ostream &cout, const vector<typC> &a)\n{\n  int n = a.size();\n  if (!n)\n    return cout;\n  cout << a[0];\n  for (int i = 1; i < n; i++)\n    cout << ' ' << a[i];\n  return cout;\n}\ntemplate <class Fun>\nclass y_combinator_result\n{\n  Fun fun_;\n\npublic:\n  template <class T>\n  explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun",
    "#include \"../include/board.h\"\n#include \"../include/socket.h\"\n\nusing board = std::array<std::array<char, 10>, 10>;\nusing pairOfTwoBoards = std::pair<board, board>;\nusing pairOfTwoCharacters = std::pair<char, char>;\n\nclass PlayerProcess\n{\nprivate:\n    int _pid;\npublic:\n    PlayerProcess(const std::string& command)\n    {\n        _pid = fork();\n        if (_pid == 0) {\n            execl(command.c_str(), command.c_str(), nullptr);\n        }\n    }\n};\n\nclass Judge\n{\nprivate:\n    pairOfTwoArmadas _armadas;\npublic:\n    const std::string& create_process(const std::string& command) \n    { \n        PlayerProcess player{command}; \n        return command;\n    }\n    int bind_judge(SocketJudge& socketJudge)\n    {\n        int bindResult = socketJudge.bind();\n        return bindResult;\n    }\n    int listen_player(SocketJudge& socketJudge, SocketPlayer& socketPlayer)\n    {\n        int listenResult = socketJudge.listen(socketPlayer);\n        return listenResult;\n    }\n    int accept_player(SocketJudge& socketJudge, SocketPlayer& socketPlayer)\n    {\n        int acceptResult = socketJudge.accept(socketPlayer);\n        return acceptResult;\n    }\n    pairOfTwoCharacters read_from_player_socket(SocketJudge& socketJudge, SocketPlayer& socketPlayer)\n    {\n        pairOfTwoCharacters twoChars = socketJudge.read(socketPlayer);\n        return twoChars;\n    }\n    void write_to_player_socket(SocketJudge& socketJudge, SocketPlayer& socketPlayer, pairOfTwoCharacters& twoCharacters)\n    {\n        socketJudge.write(socketPlayer, twoCharacters);\n    }\n\n\n};\n\nint main(int argc, char *argv[])\n{\n    constexpr uint16_t port{8080};\n    std::string ipaddr{\"127.0.0.1\"};\n    Judge judge;\n    std::string player1 = judge.create_process(\"player1\");\n    std::string player2 = judge.create_process(\"player2\");\n    SocketJudge socketJudge;\n    SocketPlayer socketPlayer;\n    int bindResult = judge.bind_judge(socketJudge);\n    int listenResult = judge.listen_player(socketJudge, socketPlayer);\n    int acceptResult = judge.accept_player(socketJudge, socketPlayer);\n    pairOfTwoCharacters readResult = judge.read_from_player_socket(socketJudge, socketPlayer);\n    judge.write_to_player_socket(socketJudge, socketPlayer, readResult);\n    return 0;\n}",
    "\ufeff#include <iostream>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <iomanip>\n#include <math.h>\n#include <vector>\n\n\nusing namespace std;\nint main() {\n    string depTime;\n    string arrTime;\n\n    cout << \"Please, enter departure time: \"; cin >> depTime;\n    cout << \"Please, enter arrival time: \"; cin >> arrTime;\n\n    while (depTime.size() != 5 || arrTime.size() != 5 ||\n        !isdigit(depTime[0]) || !isdigit(depTime[1]) || !isdigit(depTime[3]) || !isdigit(depTime[4]) ||\n        !isdigit(arrTime[0]) || !isdigit(arrTime[1]) || !isdigit(arrTime[3]) || !isdigit(arrTime[4])\n        || depTime[2] != ':' || arrTime[2] != ':') {\n        cout << \"Wrong values! Repeat your input: \" << \"\\n\";\n        cin >> depTime;\n        cin >> arrTime;\n    }\n\n    string depHours = depTime.substr(0, 2);\n    string arrHours = arrTime.substr(0, 2);\n    string depMinutes = depTime.substr(3, 2);\n    string arrMinutes = arrTime.substr(3, 2);\n\n    int dHours = stoi(depHours);\n    int aHours = stoi(arrHours);\n    int dMinutes = stoi(depMinutes);\n    int aMinutes = stoi(arrMinutes);\n\n    int tHours = 0;\n    int tMinutes = 0;\n\n\n    if (dHours < aHours && dMinutes < aMinutes) {\n        tHours = aHours - dHours;\n        tMinutes = aMinutes - dMinutes;\n    }\n    else if (aHours < dHours) {\n    tHours = (24 - dHours) + aHours;\n        tMinutes = aMinutes - dMinutes;\n    }\n    else if (dHours == aHours) {\n        tHours = 24 - 1; \n        tMinutes = aMinutes - dMinutes;\n    }\n    else {\n        tHours = aHours - dHours;\n        if (dMinutes > aMinutes) {\n            tHours--; \n            tMinutes = 60 - (dMinutes - aMinutes);\n        }\n        else {\n        tMinutes = aMinutes - dMinutes;\n    }\n    }\n    if (tMinutes < 0) {\n        tMinutes *= -1;\n    }\n\n\n    }\n    cout << \"Trip was: \" << tHours << \" h. \" << tMinutes << \" min.\";\n}\n",
    "\ufeff#include <iostream>\n\nusing namespace std;\n\nclass String {\nprivate:\n    static int objectCount; \n    char* str; \n    int length; \n\npublic:\n    String() : String(80) {}\n\n    String(int size) : length(size) {\n        str = new char[length + 1];\n        objectCount++;\n    }\n\n    String(const char* s) {\n        length = 0;\n        while (s[length] != '\\0') {\n            length++;\n        }\n        str = new char[length + 1];\n        for (int i = 0; i < length; i++) {\n            str[i] = s[i];\n        }\n        str[length] = '\\0';\n        objectCount++;\n    }\n\n    ~String() {\n        delete[] str;\n        objectCount--;\n    }\n\n    void input() {\n        cout << \"Enter a string: \";\n        cin.getline(str, length);\n    }\n\n    void display() const {\n        cout << \"String: \" << str << endl;\n    }\n\n    static int getObjectCount() {\n        return objectCount;\n    }\n};\n\nint String::objectCount = 0;\n\nint main() {\n    String s1;\n    s1.input();\n    s1.display();\n\n    String s2(50);\n    s2.input();\n    s2.display();\n\n    String s3(\"Hello, world!\");\n    s3.display();\n\n    cout << \"Number of created string objects: \" << String::getObjectCount() << endl;\n\n    return 0;\n}\n\n",
    "#include <bits/stdc++.h>\n#define e \"\\n\"\n#define ll long long\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\nusing namespace std;\n\nstruct Node {\n    int value;\n    Node* left;\n    Node* right;\n    Node(int val) : value(val), left(nullptr), right(nullptr) {}\n};\n\n\n\nclass BST {\nprivate:\n    Node* root;\n    int width, height, n;\n    vector<pair<int, int>> bombs;\n    vector<pair<int, int>> goals;\n\n    Node* insert(Node* node, int value, int x, int y) {\n        if (node == nullptr) {\n            if (isSafe(x, y)) {\n                return new Node(value);\n            }\n            else {\n                return nullptr;\n            }\n        }\n        if (value < node->value) {\n            node->left = insert(node->left, value, x - 1, y + 1);\n        }\n        else {\n            node->right = insert(node->right, value, x + 1, y + 1);\n        }\n        return node;\n    }\n\n    // not a bomb or out of bounds ?\n    bool isSafe(int x, int y) {\n        if (x < 0 || x >= width || y < 0 || y >= height) return false;\n        for (auto& bomb : bombs) {\n            if (bomb.first == x && bomb.second == y) return false;\n        }\n        return true;\n    }\n\n    // all goals are reached ?\n    bool checkGoals(Node* node, int x, int y) {\n        if (node == nullptr) return true;\n        for (auto& goal : goals) {\n            if (goal.first == x && goal.second == y) {\n                goals.erase(remove(goals.begin(), goals.end(), goal), goals.end());\n            }\n        }\n        return checkGoals(node->left, x - 1, y + 1) && checkGoals(node->right, x + 1, y + 1);\n    }\n\npublic:\n    BST(int w, int h, int num, vector<pair<int, int>> b, vector<pair<int, int>> g)\n        : root(nullptr), width(w), height(h), n(num), bombs(b), goals(g) {}\n\n    void buildTree() {\n        for (int i = 1; i <= n; ++i) {\n            root = insert(root, i, (width - 1) / 2, 0);\n            if (root == nullptr) {\n                cout << \"Lost,,,Bomb hit or out of bounds\" << e;\n                return;\n            }\n            if (goals.empty()) {\n                cout << \"Won,,,All goals reached\" << e;\n                return;\n            }\n        }\n        if (!checkGoals(root, (width - 1) / 2, 0)) {\n            cout << \"Lost,,,Not all goals reached\" << e;\n        }\n        else {\n            cout << \"Won,,,All goals reached\" << e;\n        }\n    }\n};\n\nint main() {\n    FAST;\n    int width, height, n, bombsCount, goalsCount;\n    cin >> width >> height >> n >> bombsCount >> goalsCount;\n    vector<pair<int, int>> bombs(bombsCount), goals(goalsCount);\n    for (int i = 0; i < bombsCount; ++i) {\n        cin >> bombs[i].first >> bombs[i].second;\n    }\n    for (int i = 0; i < goalsCount; ++i) {\n        cin >> goals[i].first >> goals[i].second;\n    }\n    BST tree(width, height, n, bombs, goals);\n    tree.buildTree();\n    return 0;\n}\n",
    "#include \"parser.hpp\"\n\nextern string lex_str;\n\nvoid parse(FILE *fp) {\n    TokenType token;\n    while((token = getToken(fp)) != E_O_F) {\n        switch (token) \n        {\n        case FN:\n            parse_functions_def(fp, &token);\n            break;\n        case VAR:\n            \n            break;\n        case NEWLINE:\n            break;\n        default:\n            assert(0 && \"Encountered unexpected syntax\");\n            break;\n        }\n    }\n}\n\nstatic void match_token(FILE *fp, TokenType expected, TokenType *curr_token) {\n    if (*curr_token == expected) *curr_token = getToken(fp);\n    else EXIT_ON_SYNTAX_ERROR(\"Syntax error: Expected token %d but got token %d\\n\", expected, *curr_token);\n}\n\n//Parsing function defs\nstatic void parse_functions_def(FILE *fp, TokenType *token) {\n    parse_func_proto(fp, token);\n    parse_func_body(fp, token);\n}\n\nstatic void parse_func_body(FILE *fp, TokenType *token) {\n    match_token(fp, L2NDBRACKET, token);\n    while(true) {\n        switch (*token)\n        {\n        case VAR:\n            /* code */\n            break;\n        \n        default:\n            break;\n        }\n    }\n}\n\nstatic void parse_func_proto(FILE *fp, TokenType *token) {\n    match_token(fp, IDENTIFIER, token);\n    match_token(fp, L1STBRACKET, token);\n    parse_func_param_proto(fp, token);\n}\n\nstatic void parse_func_param_proto(FILE *fp, TokenType *token) {\n    while(true) {\n        if(*token != VAR) EXIT_ON_SYNTAX_ERROR(\"Syntax error: Expected token %d but got token %d\\n\", VAR, *token);\n        \n        *token = getToken(fp);\n        \n        if(*token != IDENTIFIER) EXIT_ON_SYNTAX_ERROR(\"Syntax error: Expected token %d but got token %d\\n\", IDENTIFIER, *token);\n\n        *token = getToken(fp);\n\n        if(*token == R1STBRACKET) {\n            *token = getToken(fp);\n            break;\n        } else if(*token != COMMA) EXIT_ON_SYNTAX_ERROR(\"Syntax error: Expected token %d or %d but got token %d\\n\", R1STBRACKET, COMMA, *token);\n    }\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n###############################################################################\n# If you use PhysiCell in your project, please cite PhysiCell and the version #\n# number, such as below:                                                      #\n#                                                                             #\n# We implemented and solved the model using PhysiCell (Version x.y.z) [1].    #\n#                                                                             #\n# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #\n#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #\n#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #\n#     DOI: 10.1371/journal.pcbi.1005991                                       #\n#                                                                             #\n# See VERSION.txt or call get_PhysiCell_version() to get the current version  #\n#     x.y.z. Call display_citations() to get detailed information on all cite-#\n#     able software used in your PhysiCell application.                       #\n#                                                                             #\n# Because PhysiCell extensively uses BioFVM, we suggest you also cite BioFVM  #\n#     as below:                                                               #\n#                                                                             #\n# We implemented and solved the model using PhysiCell (Version x.y.z) [1],    #\n# with BioFVM [2] to solve the transport equations.                           #\n#                                                                             #\n# [1] A Ghaffarizadeh, R Heiland, SH Friedman, SM Mumenthaler, and P Macklin, #\n#     PhysiCell: an Open Source Physics-Based Cell Simulator for Multicellu-  #\n#     lar Systems, PLoS Comput. Biol. 14(2): e1005991, 2018                   #\n#     DOI: 10.1371/journal.pcbi.1005991                                       #\n#                                                                             #\n# [2] A Ghaffarizadeh, SH Friedman, and P Macklin, BioFVM: an efficient para- #\n#     llelized diffusive transport solver for 3-D biological simulations,     #\n#     Bioinformatics 32(8): 1256-8, 2016. DOI: 10.1093/bioinformatics/btv730  #\n#                                                                             #\n###############################################################################\n#                                                                             #\n# BSD 3-Clause License (see https://opensource.org/licenses/BSD-3-Clause)     #\n#                                                                             #\n# Copyright (c) 2015-2018, Paul Macklin and the PhysiCell Project             #\n# All rights reserved.                                                        #\n#                                                                             #\n# Redistribution and use in source and binary forms, with or without          #\n# modification, are permitted provided that the following conditions are met: #\n#                                                                             #\n# 1. Redistributions of source code must retain the above copyright notice,   #\n# this list of conditions and the following disclaimer.                       #\n#                                                                             #\n# 2. Redistributions in binary form must reproduce the above copyright        #\n# notice, this list of conditions and the following disclaimer in the         #\n# documentation and/or other materials provided with the distribution.        #\n#                                                                             #\n# 3. Neither the name of the copyright holder nor the names of its            #\n# contributors may be used to endorse or promote products derived from this   #\n# software without specific prior written permission.                         #\n#                                                                             #\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" #\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   #\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #\n# POSSIBILITY OF SUCH DAMAGE.                                                 #\n#                                    ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"ErrorHandling.h\"\n\nint StartParameters() {\n    string p;\n    while (true) {\n        getline(cin, p);\n        try {\n            if (cin.fail()) {\n                ClearCin();\n                throw runtime_error(\" \u012evesties klaida, bandykite dar kart\u0105 \");\n            }\n            if (p.empty() || any_of(p.begin(), p.end(), [](char c) { return !(isdigit(c)) || isspace(c); })) {\n                throw invalid_argument(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba raid\u017ei\u0173)\");\n            }\n            int num = stoi(p);\n            if (num <= 0 || num > 2147483646) {\n                throw out_of_range(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba raid\u017ei\u0173)\");\n            }\n            return num;\n        }\n        catch (const runtime_error& e){\n            cerr << e.what() << endl;\n        }\n        catch (const invalid_argument& e) {\n            cerr << e.what() << endl;\n        }\n        catch (const out_of_range& e) {\n            cerr << e.what() << endl;\n        }\n    }\n}\nstring StringParameters(){\n    string p;\n    while(true){\n        getline(cin, p);\n        try{\n            if (cin.fail()) {\n                ClearCin();\n                throw runtime_error(\" \u012evesties klaida, bandykite dar kart\u0105 \");\n            }\n            if(p.empty() || p.size() > 25 || any_of(p.begin(), p.end(), [](char c) { return isdigit(c) || isspace(c); })) {\n                throw invalid_argument(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba skai\u010di\u0173)\");\n            }\n        return p;\n        }\n        catch (const runtime_error& e){\n            cerr << e.what() << endl;\n        }\n        catch (const invalid_argument& e) {\n            cerr << e.what() << endl;\n        }\n    }\n}\n\nint GradingParameters(){\n    string p;\n    while (true) {\n        getline(cin, p);\n        try {\n            if (cin.fail()) {\n                ClearCin();\n                throw runtime_error(\" \u012fvesties klaida, bandykite dar kart\u0105 \");\n            }\n            if (p.empty() || any_of(p.begin(), p.end(), [](char c) { return !(isdigit(c)) || isspace(c); })) {\n                throw invalid_argument(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba raid\u017ei\u0173)\");\n            }\n            int num = stoi(p);\n            if (num < 0 || num > 11) {\n                throw out_of_range(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba raid\u017ei\u0173)\");\n            }\n            return num;\n        }\n        catch (const runtime_error& e){\n            cerr << e.what() << endl;\n        }\n        catch (const invalid_argument& e) {\n            cerr << e.what() << endl;\n        }\n        catch (const out_of_range& e) {\n            cerr << e.what() << endl;\n        }\n    }\n}\nint ExamParameters(){\n    string p;\n    while (true) {\n        getline(cin, p);\n        try {\n            if (cin.fail()) {\n                ClearCin();\n                throw runtime_error(\" \u012evesties klaida, bandykite dar kart\u0105 \");\n            }\n            if (p.empty() || any_of(p.begin(), p.end(), [](char c) { return !(isdigit(c)) || isspace(c); })) {\n                throw invalid_argument(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba raid\u017ei\u0173)\");\n            }\n            int num = stoi(p);\n            if (num < 0 || num > 10) {\n                throw out_of_range(\"Netinkamas \u012fvesties formatas, bandykite dar kart\u0105 (patikrinkite ar n\u0117ra tarp\u0173 arba raid\u017ei\u0173)\");\n            }\n            return num;\n        }\n        catch (const runtime_error& e){\n            cerr << e.what() << endl;\n        }\n        catch (const invalid_argument& e) {\n            cerr << e.what() << endl;\n        }\n        catch (const out_of_range& e) {\n            cerr << e.what() << endl;\n        }\n    }\n}\n\nvoid ClearCin(){\n\n    cin.clear();\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n}\n",
    "//====================================================================================================\n// Filename:\tXMath.cpp\n// Created by:\tPeter Chan\n//====================================================================================================\n\n#include \"Precompiled.h\"\n#include \"XMath.h\"\n\nusing namespace X;\nusing namespace X::Math;\n\n//====================================================================================================\n// Constants\n//====================================================================================================\n\nconst float Math::kPi\t\t\t= 3.14159265358979f;\nconst float Math::kTwoPi\t\t= 6.28318530717958f;\nconst float Math::kPiByTwo\t\t= 1.57079632679489f;\nconst float Math::kRootTwo\t\t= 1.41421356237309f;\nconst float Math::kRootThree\t= 1.73205080756887f;\nconst float Math::kDegToRad\t\t= kPi / 180.0f;\nconst float Math::kRadToDeg\t\t= 180.0f / kPi;\n\n//====================================================================================================\n// Function Definitions\n//====================================================================================================\n\nQuaternion X::Math::QuaternionLookRotation(const Vector3& forward, const Vector3& up)\n{\n\tVector3 z = Normalize(forward);\n\tVector3 x = Normalize(Cross(up, z));\n\tVector3 y = Normalize(Cross(z, x));\n\tMatrix4 mat\n\t(\n\t\tx.x, x.y, x.z, 0.0f,\n\t\ty.x, y.y, y.z, 0.0f,\n\t\tz.x, z.y, z.z, 0.0f,\n\t\t0.0f, 0.0f, 0.0f, 1.0f\n\t);\n\n\t// TODO: Need matrix to quaternion\n\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\treturn Quaternion();\n}\n\n//----------------------------------------------------------------------------------------------------\n\nQuaternion X::Math::QuaternionRotationAxis(const Vector3& axis, float rad)\n{\n\tconst float c = cos(rad * 0.5f);\n\tconst float s = sin(rad * 0.5f);\n\tconst Math::Vector3 a = Math::Normalize(axis);\n\treturn Quaternion(a.x * s, a.y * s, a.z * s, c);\n}\n\n//----------------------------------------------------------------------------------------------------\n\nMatrix4 X::Math::MatrixRotationAxis(const Vector3& axis, float rad)\n{\n\tconst Vector3 u = Normalize(axis);\n\tconst float x = u.x;\n\tconst float y = u.y;\n\tconst float z = u.z;\n\tconst float s = sin(rad);\n\tconst float c = cos(rad);\n\n\treturn Matrix4\n\t(\n\t\tc + (x * x * (1.0f - c)),\n\t\tx * y * (1.0f - c) + z * s,\n\t\tx * z * (1.0f - c) - y * s,\n\t\t0.0f,\n\n\t\tx * y * (1.0f - c) - z * s,\n\t\tc + (y * y * (1.0f - c)),\n\t\ty * z * (1.0f - c) + x * s,\n\t\t0.0f,\n\n\t\tx * z * (1.0f - c) + y * s,\n\t\ty * z * (1.0f - c) - x * s,\n\t\tc + (z * z * (1.0f - c)),\n\t\t0.0f,\n\n\t\t0.0f,\n\t\t0.0f,\n\t\t0.0f,\n\t\t1.0f\n\t);\n}\n\n//----------------------------------------------------------------------------------------------------\n\nMatrix4 X::Math::MatrixRotationQuaternion(const Quaternion& q)\n{\n\treturn Matrix4\n\t(\n\t\t1.0f - (2.0f * q.y * q.y) - (2.0f * q.z * q.z),\n\t\t(2.0f * q.x * q.y) + (2.0f * q.z * q.w),\n\t\t(2.0f * q.x * q.z) - (2.0f * q.y * q.w),\n\t\t0.0f,\n\n\t\t(2.0f * q.x * q.y) - (2.0f * q.z * q.w),\n\t\t1.0f - (2.0f * q.x * q.x) - (2.0f * q.z * q.z),\n\t\t(2.0f * q.y * q.z) + (2.0f * q.x * q.w),\n\t\t0.0f,\n\n\t\t(2.0f * q.x * q.z) + (2.0f * q.y * q.w),\n\t\t(2.0f * q.y * q.z) - (2.0f * q.x * q.w),\n\t\t1.0f - (2.0f * q.x * q.x) - (2.0f * q.y * q.y),\n\t\t0.0f,\n\n\t\t0.0f,\n\t\t0.0f,\n\t\t0.0f,\n\t\t1.0f\n\t);\n}\n\n//----------------------------------------------------------------------------------------------------\n\nQuaternion X::Math::Slerp(Quaternion q0, Quaternion q1, float t)\n{\n\t// Find the dot product\n\tfloat dot = (q0.x * q1.x) + (q0.y * q1.y) + (q0.z * q1.z) + (q0.w * q1.w);\n\n\t// Determine the direction of the rotation.\n\tif (dot < 0.0f)\n\t{\n\t\tdot = -dot;\n\t\tq1.x = -q1.x;\n\t\tq1.y = -q1.y;\n\t\tq1.z = -q1.z;\n\t\tq1.w = -q1.w;\n\t}\n\telse if (dot > 0.999f)\n\t{\n\t\treturn Normalize(Lerp(q0, q1, t));\n\t}\n\n\tfloat theta = acosf(dot);\n\tfloat sintheta = sinf(theta);\n\tfloat scale0 = sinf(theta * (1.0f - t)) / sintheta;\n\tfloat scale1 = sinf(theta * t) / sintheta;\n\n\t// Perform the slerp\n\treturn Quaternion\n\t(\n\t\t(q0.x * scale0) + (q1.x * scale1),\n\t\t(q0.y * scale0) + (q1.y * scale1),\n\t\t(q0.z * scale0) + (q1.z * scale1),\n\t\t(q0.w * scale0) + (q1.w * scale1)\n\t);\n}\n\n//----------------------------------------------------------------------------------------------------\n\nX::Math::Vector3 X::Math::GetBarycentric(const Vector2& a, const Vector2& b, const Vector2& c, const Vector2& point)\n{\n\tX::Math::Vector3 lambda;\n\tfloat denom = (b.y - c.y) * (a.x - c.x) + (c.x - b.x) * (a.y - c.y);\n\tlambda.x = ((b.y - c.y) * (point.x - c.x) + (c.x - b.x) * (point.y - c.y)) / denom;\n\tlambda.y = ((c.y - a.y) * (point.x - c.x) + (a.x - c.x) * (point.y - c.y)) / denom;\n\tlambda.z = 1.0f - lambda.x - lambda.y;\n\treturn lambda;\n}\n\n//----------------------------------------------------------------------------------------------------\n\nbool X::Math::PointInTriangle(const Vector2& point, const Vector2& a, const Vector2& b, const Vector2& c)\n{\n\tX::Math::Vector3 barycentric = GetBarycentric(a, b, c, point);\n\treturn\n\t\tbarycentric.x >= 0.0f && barycentric.x <= 1.",
    "#include \"command_util.h\"\n\n#include <QProcess>\n#include <QTextStream>\n#include <QStandardPaths>\n#include <QDebug>\n\nQString CommandUtil::sudoExec(const QString &cmd, QStringList args, QByteArray data)\n{\n    args.push_front(cmd);\n\n    QString result(\"\");\n\n    try {\n        result = CommandUtil::exec(\"pkexec\", args, data);\n    } catch (QString &ex) {\n        qCritical() << ex;\n    }\n\n    return result;\n}\n\nQString CommandUtil::exec(const QString &cmd, QStringList args, QByteArray data)\n{\n    QProcess* process = new QProcess;\n\n    process->start(cmd, args);\n\n    if (! data.isEmpty()) {\n        process->write(data);\n        process->waitForBytesWritten();\n        process->closeWriteChannel();\n    }\n\n    process->waitForFinished();\n\n    QTextStream stdOut(process->readAllStandardOutput());\n\n    QString err = process->errorString();\n\n    process->kill();\n    process->close();\n\n    if (process->error() != QProcess::UnknownError)\n        throw err;\n\n    return stdOut.readAll().trimmed();\n}\n\nbool CommandUtil::isExecutable(const QString &cmd)\n{\n    return !QStandardPaths::findExecutable(cmd).isEmpty();\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// Code sample from Filippo Ramaciotti\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtx/matrix_cross_product.hpp>\n#include <glm/gtx/matrix_operation.hpp>\n#include <glm/gtc/epsilon.hpp>\n#include <glm/gtx/string_cast.hpp>\n#include <glm/gtx/euler_angles.hpp>\n#include <cstdio>\n#include <vector>\n#include <utility>\n\nnamespace test_eulerAngleX\n{\n\tint test()\n\t{\n\t\tint Error = 0;\n\n\t\tfloat const Angle(glm::pi<float>() * 0.5f);\n\t\tglm::vec3 const X(1.0f, 0.0f, 0.0f);\n\n\t\tglm::vec4 const Y(0.0f, 1.0f, 0.0f, 1.0f);\n\t\tglm::vec4 const Y1 = glm::rotate(glm::mat4(1.0f), Angle, X) * Y;\n\t\tglm::vec4 const Y2 = glm::eulerAngleX(Angle) * Y;\n\t\tglm::vec4 const Y3 = glm::eulerAngleXY(Angle, 0.0f) * Y;\n\t\tglm::vec4 const Y4 = glm::eulerAngleYX(0.0f, Angle) * Y;\n\t\tglm::vec4 const Y5 = glm::eulerAngleXZ(Angle, 0.0f) * Y;\n\t\tglm::vec4 const Y6 = glm::eulerAngleZX(0.0f, Angle) * Y;\n\t\tglm::vec4 const Y7 = glm::eulerAngleYXZ(0.0f, Angle, 0.0f) * Y;\n\t\tError += glm::all(glm::epsilonEqual(Y1, Y2, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Y1, Y3, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Y1, Y4, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Y1, Y5, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Y1, Y6, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Y1, Y7, 0.00001f)) ? 0 : 1;\n\n\t\tglm::vec4 const Z(0.0f, 0.0f, 1.0f, 1.0f);\n\t\tglm::vec4 const Z1 = glm::rotate(glm::mat4(1.0f), Angle, X) * Z;\n\t\tglm::vec4 const Z2 = glm::eulerAngleX(Angle) * Z;\n\t\tglm::vec4 const Z3 = glm::eulerAngleXY(Angle, 0.0f) * Z;\n\t\tglm::vec4 const Z4 = glm::eulerAngleYX(0.0f, Angle) * Z;\n\t\tglm::vec4 const Z5 = glm::eulerAngleXZ(Angle, 0.0f) * Z;\n\t\tglm::vec4 const Z6 = glm::eulerAngleZX(0.0f, Angle) * Z;\n\t\tglm::vec4 const Z7 = glm::eulerAngleYXZ(0.0f, Angle, 0.0f) * Z;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z2, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z3, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z4, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z5, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z6, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z7, 0.00001f)) ? 0 : 1;\n\n\t\treturn Error;\n\t}\n}//namespace test_eulerAngleX\n\nnamespace test_eulerAngleY\n{\n\tint test()\n\t{\n\t\tint Error = 0;\n\n\t\tfloat const Angle(glm::pi<float>() * 0.5f);\n\t\tglm::vec3 const Y(0.0f, 1.0f, 0.0f);\n\n\t\tglm::vec4 const X(1.0f, 0.0f, 0.0f, 1.0f);\n\t\tglm::vec4 const X1 = glm::rotate(glm::mat4(1.0f), Angle, Y) * X;\n\t\tglm::vec4 const X2 = glm::eulerAngleY(Angle) * X;\n\t\tglm::vec4 const X3 = glm::eulerAngleYX(Angle, 0.0f) * X;\n\t\tglm::vec4 const X4 = glm::eulerAngleXY(0.0f, Angle) * X;\n\t\tglm::vec4 const X5 = glm::eulerAngleYZ(Angle, 0.0f) * X;\n\t\tglm::vec4 const X6 = glm::eulerAngleZY(0.0f, Angle) * X;\n\t\tglm::vec4 const X7 = glm::eulerAngleYXZ(Angle, 0.0f, 0.0f) * X;\n\t\tError += glm::all(glm::epsilonEqual(X1, X2, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X3, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X4, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X5, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X6, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X7, 0.00001f)) ? 0 : 1;\n\n\t\tglm::vec4 const Z(0.0f, 0.0f, 1.0f, 1.0f);\n\t\tglm::vec4 const Z1 = glm::eulerAngleY(Angle) * Z;\n\t\tglm::vec4 const Z2 = glm::rotate(glm::mat4(1.0f), Angle, Y) * Z;\n\t\tglm::vec4 const Z3 = glm::eulerAngleYX(Angle, 0.0f) * Z;\n\t\tglm::vec4 const Z4 = glm::eulerAngleXY(0.0f, Angle) * Z;\n\t\tglm::vec4 const Z5 = glm::eulerAngleYZ(Angle, 0.0f) * Z;\n\t\tglm::vec4 const Z6 = glm::eulerAngleZY(0.0f, Angle) * Z;\n\t\tglm::vec4 const Z7 = glm::eulerAngleYXZ(Angle, 0.0f, 0.0f) * Z;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z2, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z3, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z4, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z5, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z6, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(Z1, Z7, 0.00001f)) ? 0 : 1;\n\n\t\treturn Error;\n\t}\n}//namespace test_eulerAngleY\n\nnamespace test_eulerAngleZ\n{\n\tint test()\n\t{\n\t\tint Error = 0;\n\n\t\tfloat const Angle(glm::pi<float>() * 0.5f);\n\t\tglm::vec3 const Z(0.0f, 0.0f, 1.0f);\n\n\t\tglm::vec4 const X(1.0f, 0.0f, 0.0f, 1.0f);\n\t\tglm::vec4 const X1 = glm::rotate(glm::mat4(1.0f), Angle, Z) * X;\n\t\tglm::vec4 const X2 = glm::eulerAngleZ(Angle) * X;\n\t\tglm::vec4 const X3 = glm::eulerAngleZX(Angle, 0.0f) * X;\n\t\tglm::vec4 const X4 = glm::eulerAngleXZ(0.0f, Angle) * X;\n\t\tglm::vec4 const X5 = glm::eulerAngleZY(Angle, 0.0f) * X;\n\t\tglm::vec4 const X6 = glm::eulerAngleYZ(0.0f, Angle) * X;\n\t\tglm::vec4 const X7 = glm::eulerAngleYXZ(0.0f, 0.0f, Angle) * X;\n\t\tError += glm::all(glm::epsilonEqual(X1, X2, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X3, 0.00001f)) ? 0 : 1;\n\t\tError += glm::all(glm::epsilonEqual(X1, X4, 0.0000",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <functional>\n#include <memory>\n#include <thread>\n\n#include \"geometry_msgs/msg/detail/point__struct.hpp\"\n#include \"geometry_msgs/msg/detail/quaternion__struct.hpp\"\n#include \"geometry_msgs/msg/twist.hpp\"\n#include \"nav_msgs/msg/detail/odometry__struct.hpp\"\n#include \"rclcpp/utilities.hpp\"\n#include \"rclcpp_action/rclcpp_action.hpp\"\n#include \"robot_patrol/action/go_to_pose.hpp\"\n#include \"tf2/LinearMath/Matrix3x3.h\"\n#include \"tf2/LinearMath/Quaternion.h\"\n#include \"tf2/LinearMath/Vector3.h\"\n#include <cmath>\n#include <geometry_msgs/msg/point.h>\n#include <nav_msgs/msg/odometry.hpp>\n#include <rclcpp/rclcpp.hpp>\nusing namespace std::chrono_literals;\n/*\n    This is the action server that subscribe to /odom topic and also move robot\n    therefore, there are 3 main IOs\n    1. subscribe to /odom topic with a subscriber\n    2. publish to /cmd_vel topic with a publisher\n    3. Action server.\n\n    The callbacks\n    1. subscriber needs 1 callback, odom_callback\n    2. publisher needs 1 callback. need a timer to control its speed.\n   server's callbacks.\n    3. Action server needs 3 callbacks: handle_goal,\n   handle_cancel,handle_accepted.\n\n    Question: Do I need Callback groups?\n    I think, Yes for subsciber only. because\n    1) for a subscriber, do it\n    2) Actopm server?\n        After reading, I think Action servers need no callback group because\n        1. There is no callback group option in the action_server.option\n        2. execute() is being done in a new detached thread. Thus might now slow\n            down the main thread.\n*/\n\nclass GoToPoseActionServer : public rclcpp::Node {\npublic:\n  using GoToPose = robot_patrol::action::GoToPose;\n  using GoalHandleMove = rclcpp_action::ServerGoalHandle<GoToPose>;\n\n  explicit GoToPoseActionServer(\n      const rclcpp::NodeOptions &options = rclcpp::NodeOptions())\n      : Node(\"go_to_pose_action_server\", options) {\n    using namespace std::placeholders;\n    /*timer_callback_group_ = this->create_callback_group(\n        rclcpp::CallbackGroupType::MutuallyExclusive);*/\n    odom1_callback_group_ = this->create_callback_group(\n        rclcpp::CallbackGroupType::MutuallyExclusive);\n    rclcpp::SubscriptionOptions options1;\n    options1.callback_group = odom1_callback_group_;\n    subscription1_ = this->create_subscription<nav_msgs::msg::Odometry>(\n        \"/odom\", 10,\n        std::bind(&GoToPoseActionServer::odom_callback, this,\n                  std::placeholders::_1),\n        options1);\n\n    this->action_server_ = rclcpp_action::create_server<GoToPose>(\n        this, \"go_to_pose\",\n        std::bind(&GoToPoseActionServer::handle_goal, this, _1, _2),\n        std::bind(&GoToPoseActionServer::handle_cancel, this, _1),\n        std::bind(&GoToPoseActionServer::handle_accepted, this, _1));\n\n    publisher_ =\n        this->create_publisher<geometry_msgs::msg::Twist>(\"cmd_vel\", 10);\n\n    /*timer1_ = this->create_wall_timer(\n        100ms, std::bind(&GoToPoseActionServer::timer1_callback, this),\n        timer_callback_group_);*/\n  }\n\nprivate:\n  rclcpp_action::Server<GoToPose>::SharedPtr action_server_;\n  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr publisher_;\n  // rclcpp::TimerBase::SharedPtr timer1_;\n  rclcpp::CallbackGroup::SharedPtr\n      odom1_callback_group_; //, timer_callback_group_;\n  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr subscription1_;\n  geometry_msgs::msg::Twist ling;\n  geometry_msgs::msg::Point desire_pos_, current_pos_;\n  geometry_msgs::msg::Quaternion desire_angle_, current_angle_;\n  double yaw_rad = 0., pitch_rad = 0., roll_rad = 0., req_yaw_rad = 0.,\n         target_yaw_rad = 0.;\n\n  void move_robot(geometry_msgs::msg::Twist &msg) { publisher_->publish(msg); }\n  bool check_reached_goal_angle(float delta_error = 0.1) {\n    float delta_theta = std::abs(yaw_rad - target_yaw_rad);\n    return delta_theta < delta_error; // IN GOAL return true else false;\n  }\n  bool check_reached_goal_pos(const geometry_msgs::msg::Point goal,\n                              const geometry_msgs::msg::Point current_pos,\n                              float delta_error = 0.1) {\n\n    // print_2Dposition(goal, \"GOAL\");\n    // print_2Dposition(current_pos, \"CURRENT_POS\");\n\n    float delta_x = std::abs(goal.x - current_pos.x);\n    float delta_y = std::abs(goal.y - current_pos.y);\n    bool result = false;\n    RCLCPP_INFO(this->get_logger(),\n                \"[desire, current]=['%f','%f'] vs ['%f',%f]\", goal.x, goal.y,\n                current_pos.x, current_pos.y);\n\n    if (delta_x <= delta_error) {\n      if (delta_y <= delta_error) {\n        RCLCPP_INFO(this->get_logger(), \"IN GOAL[dx,dy,error]=['%f','%f','%f']\",\n                    delta_x, delta_y, delta_error);\n        result = true;\n      } else {\n        RCLCPP_INFO(this->get_logger(), \"[DY,ERROR]=['%f','%f']\", delta_y,\n                    delta_error);\n      }\n    } else {\n      RCLCPP_INFO(this->get_logger(), \"[DX,ERROR]=['%f','%f']\", delta_x,\n                  delta_error);\n    }\n\n    return result;\n  }\n  /*timer call",
    "#include \"yaml-cpp/node/node.h\"\n#include \"yaml-cpp/emitter.h\"\n#include \"yaml-cpp/node/convert.h\"\n#include \"yaml-cpp/node/detail/impl.h\"\n#include \"yaml-cpp/node/emit.h\"\n#include \"yaml-cpp/node/impl.h\"\n#include \"yaml-cpp/node/iterator.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n#include <sstream>\n\nnamespace {\n\n// malloc/free based allocator just for testing custom allocators on stl containers\ntemplate <class T>\nclass CustomAllocator : public std::allocator<T> {\n  public:\n    typedef std::size_t     size_type;\n    typedef std::ptrdiff_t  difference_type;\n    typedef T*              pointer;\n    typedef const T*        const_pointer;\n    typedef T&              reference;\n    typedef const T&        const_reference;\n    typedef T               value_type;\n    template<class U> struct rebind { typedef CustomAllocator<U> other; };\n    CustomAllocator() : std::allocator<T>() {}\n    CustomAllocator(const CustomAllocator& other) : std::allocator<T>(other) {}\n    template<class U> CustomAllocator(const CustomAllocator<U>& other) : std::allocator<T>(other) {}\n    ~CustomAllocator() {}\n    size_type max_size() const { return (std::numeric_limits<std::ptrdiff_t>::max)()/sizeof(T); }\n    pointer allocate(size_type num, const void* /*hint*/ = 0) {\n      if (num > std::size_t(-1) / sizeof(T)) throw std::bad_alloc();\n      return static_cast<pointer>(malloc(num * sizeof(T)));\n    }\n    void deallocate(pointer p, size_type /*num*/) { free(p); }\n};\n\ntemplate <class T> using CustomVector = std::vector<T,CustomAllocator<T>>;\ntemplate <class T> using CustomList = std::list<T,CustomAllocator<T>>;\ntemplate <class K, class V, class C=std::less<K>> using CustomMap = std::map<K,V,C,CustomAllocator<std::pair<const K,V>>>;\ntemplate <class K, class V, class H=std::hash<K>, class P=std::equal_to<K>> using CustomUnorderedMap = std::unordered_map<K,V,H,P,CustomAllocator<std::pair<const K,V>>>;\n\n}  // anonymous namespace\n\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\n#define EXPECT_THROW_REPRESENTATION_EXCEPTION(statement, message) \\\n  ASSERT_THROW(statement, RepresentationException);               \\\n  try {                                                           \\\n    statement;                                                    \\\n  } catch (const RepresentationException& e) {                    \\\n    EXPECT_EQ(e.msg, message);                                    \\\n  }\n\nnamespace YAML {\nnamespace {\nTEST(NodeTest, SimpleScalar) {\n  Node node = Node(\"Hello, World!\");\n  EXPECT_TRUE(node.IsScalar());\n  EXPECT_EQ(\"Hello, World!\", node.as<std::string>());\n}\n\nTEST(NodeTest, IntScalar) {\n  Node node = Node(15);\n  EXPECT_TRUE(node.IsScalar());\n  EXPECT_EQ(15, node.as<int>());\n}\n\nTEST(NodeTest, SimpleAppendSequence) {\n  Node node;\n  node.push_back(10);\n  node.push_back(\"foo\");\n  node.push_back(\"monkey\");\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(3, node.size());\n  EXPECT_EQ(10, node[0].as<int>());\n  EXPECT_EQ(\"foo\", node[1].as<std::string>());\n  EXPECT_EQ(\"monkey\", node[2].as<std::string>());\n  EXPECT_TRUE(node.IsSequence());\n}\n\nTEST(NodeTest, SequenceElementRemoval) {\n  Node node;\n  node[0] = \"a\";\n  node[1] = \"b\";\n  node[2] = \"c\";\n  node.remove(1);\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(2, node.size());\n  EXPECT_EQ(\"a\", node[0].as<std::string>());\n  EXPECT_EQ(\"c\", node[1].as<std::string>());\n}\n\nTEST(NodeTest, SequenceElementRemovalSizeCheck) {\n  Node node;\n  node[0] = \"a\";\n  node[1] = \"b\";\n  node[2] = \"c\";\n  EXPECT_EQ(3, node.size());\n  node.remove(1);\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(2, node.size());\n  EXPECT_EQ(\"a\", node[0].as<std::string>());\n  EXPECT_EQ(\"c\", node[1].as<std::string>());\n}\n\nTEST(NodeTest, SequenceFirstElementRemoval) {\n  Node node;\n  node[0] = \"a\";\n  node[1] = \"b\";\n  node[2] = \"c\";\n  node.remove(0);\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(2, node.size());\n  EXPECT_EQ(\"b\", node[0].as<std::string>());\n  EXPECT_EQ(\"c\", node[1].as<std::string>());\n}\n\nTEST(NodeTest, SequenceFirstElementRemovalSizeCheck) {\n  Node node;\n  node[0] = \"a\";\n  node[1] = \"b\";\n  node[2] = \"c\";\n  EXPECT_EQ(3, node.size());\n  node.remove(0);\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(2, node.size());\n  EXPECT_EQ(\"b\", node[0].as<std::string>());\n  EXPECT_EQ(\"c\", node[1].as<std::string>());\n}\n\nTEST(NodeTest, SequenceLastElementRemoval) {\n  Node node;\n  node[0] = \"a\";\n  node[1] = \"b\";\n  node[2] = \"c\";\n  node.remove(2);\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(2, node.size());\n  EXPECT_EQ(\"a\", node[0].as<std::string>());\n  EXPECT_EQ(\"b\", node[1].as<std::string>());\n}\n\nTEST(NodeTest, SequenceLastElementRemovalSizeCheck) {\n  Node node;\n  node[0] = \"a\";\n  node[1] = \"b\";\n  node[2] = \"c\";\n  EXPECT_EQ(3, node.size());\n  node.remove(2);\n  EXPECT_TRUE(node.IsSequence());\n  EXPECT_EQ(2, node.size());\n  EXPECT_EQ(\"a\", node[0].as<std::string>());\n  EXPECT_EQ(\"b\", node[1].as<std::string>());\n}\n\nTEST(NodeTest, NodeAssignment) {\n  Node node1;\n  Node node2;\n  node1[1] = 1;\n  node1[2] = 2;\n  node1[3] = 3;\n  node2 = node1;\n  EXPECT_E",
    "#include <stdio.h>\n#include \"Stack.h\"\n\nvoid prnMenu(){\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<\"* 1. \uc0bd\uc785    2. \uc0ad\uc81c    3. \ucd9c\ub825   4. \uc885\ub8cc *\"<<endl;\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<endl;\n\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uba54\ub274\ub97c \uace8\ub77c\uc8fc\uc138\uc694: \";\n}\n\nint main(){\n\t    int mode, selectNumber, tmpItem;\n\t\tLinkedList<int> *p;\n\t\tbool flag = false;\n\n\t\tcout<<\"\uc790\ub8cc\uad6c\uc870 \uc120\ud0dd(1: Stack, Other: Linked List): \";\n\t\tcin>>mode;\n\t\t\t\t\t\t    \n\t\tif(mode == 1)\n\t\t\tp = new Stack<int>();    // \uc815\uc218\ub97c \uc800\uc7a5\ud558\ub294 \uc2a4\ud0dd\n\t\t\t\n\t\telse\n\t\t\tp = new LinkedList<int>();\n\n\n\t\tdo{\n\t\t\tprnMenu();\n\t\t\tcin>>selectNumber;\n\t\t\t\n\t\t\tswitch(selectNumber){ \n\t\t\t\tcase 1:\n\t\t\t\t\tif (p->GetSize() != MAX_SIZE){\n\t\t\t\t\t\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694: \";\n\t\t\t\t\t\tcin>>tmpItem;    p->Insert(tmpItem);\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0bd\uc785\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"\ucd5c\ub300 \ub178\ub4dc \uac1c\uc218\ub97c \ub118\uaca8\uc11c \uc800\uc7a5\uc5d0 \uc2e4\ud328\ud588\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tif(p->Delete(tmpItem)==true)\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0ad\uc81c\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t\t\n\t\t\t\t\telse cout<<\"\ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc0ad\uc81c \uc2e4\ud328\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"\ud06c\uae30: \"<<p->GetSize()<<endl;\n\t\t\t\t\tp->Print();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tflag = true;     break;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tcout<<\"\uc798\ubabb \uc785\ub825\ud558\uc168\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) break;\n\t\t\t\n\t\t} while(1);\n\t\t\n\t\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <stdio.h>\n#include \"Stack.h\"\n#define MAXSIZE 10\n\nvoid prnMenu(){\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<\"* 1. \uc0bd\uc785    2. \uc0ad\uc81c    3. \ucd9c\ub825   4. \uc885\ub8cc *\"<<endl;\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<endl;\n\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uba54\ub274\ub97c \uace8\ub77c\uc8fc\uc138\uc694: \";\n}\n\nint main(){\n\t  int mode, selectNumber, tmpItem;\n\t\tLinkedList<int> *p;\n\t\tbool flag = false;\n\n\t\tcout<<\"\uc790\ub8cc\uad6c\uc870 \uc120\ud0dd(1: Stack, Other: Linked List): \";\n\t\tcin>>mode;\n\t\t\t\t\t\t    \n\t\tif(mode == 1)\n\t\t\tp = new Stack<int>();    // \uc815\uc218\ub97c \uc800\uc7a5\ud558\ub294 \uc2a4\ud0dd\n\t\t\t\n\t\telse\n\t\t\tp = new LinkedList<int>();\n\n\n\t\tdo{\n\t\t\tprnMenu();\n\t\t\tcin>>selectNumber;\n\t\t\t\n\t\t\tswitch(selectNumber){ \n\t\t\t\tcase 1:\n          if(p->GetSize() == MAXSIZE){\n            cout << \"full : Max Size is \" << MAXSIZE << endl; break;\n          }\n\t\t\t\t\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694: \";\n\t\t\t\t\tcin>>tmpItem;    \n          p->Insert(tmpItem);\n\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0bd\uc785\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tif(p->Delete(tmpItem)==true)\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0ad\uc81c\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t\t\n\t\t\t\t\telse cout<<\"\ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc0ad\uc81c \uc2e4\ud328\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"\ud06c\uae30: \"<<p->GetSize()<<endl;\n\t\t\t\t\tp->Print();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tflag = true;\n          break;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tcout<<\"\uc798\ubabb \uc785\ub825\ud558\uc168\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) break;\n\t\t\t\n\t\t} while(1);\n\t\t\n\t\treturn 0;\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n\n\nconst sf::Uint8 audioData   = 1;\nconst sf::Uint8 endOfStream = 2;\n\n\n////////////////////////////////////////////////////////////\n/// Specialization of audio recorder for sending recorded audio\n/// data through the network\n////////////////////////////////////////////////////////////\nclass NetworkRecorder : public sf::SoundRecorder\n{\npublic:\n\n    ////////////////////////////////////////////////////////////\n    /// Constructor\n    ///\n    /// \\param host Remote host to which send the recording data\n    /// \\param port Port of the remote host\n    ///\n    ////////////////////////////////////////////////////////////\n    NetworkRecorder(const sf::IpAddress& host, unsigned short port) :\n    m_host(host),\n    m_port(port)\n    {\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// Destructor\n    ///\n    /// \\see SoundRecorder::~SoundRecorder()\n    ///\n    ////////////////////////////////////////////////////////////\n    ~NetworkRecorder()\n    {\n        // Make sure to stop the recording thread\n        stop();\n    }\n\nprivate:\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onStart\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onStart()\n    {\n        if (m_socket.connect(m_host, m_port) == sf::Socket::Done)\n        {\n            std::cout << \"Connected to server \" << m_host << std::endl;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onProcessSamples\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onProcessSamples(const sf::Int16* samples, std::size_t sampleCount)\n    {\n        // Pack the audio samples into a network packet\n        sf::Packet packet;\n        packet << audioData;\n        packet.append(samples, sampleCount * sizeof(sf::Int16));\n\n        // Send the audio packet to the server\n        return m_socket.send(packet) == sf::Socket::Done;\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onStop\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual void onStop()\n    {\n        // Send a \"end-of-stream\" packet\n        sf::Packet packet;\n        packet << endOfStream;\n        m_socket.send(packet);\n\n        // Close the socket\n        m_socket.disconnect();\n    }\n\n    ////////////////////////////////////////////////////////////\n    // Member data\n    ////////////////////////////////////////////////////////////\n    sf::IpAddress  m_host;   ///< Address of the remote host\n    unsigned short m_port;   ///< Remote port\n    sf::TcpSocket  m_socket; ///< Socket used to communicate with the server\n};\n\n\n////////////////////////////////////////////////////////////\n/// Create a client, connect it to a running server and\n/// start sending him audio data\n///\n////////////////////////////////////////////////////////////\nvoid doClient(unsigned short port)\n{\n    // Check that the device can capture audio\n    if (!sf::SoundRecorder::isAvailable())\n    {\n        std::cout << \"Sorry, audio capture is not supported by your system\" << std::endl;\n        return;\n    }\n\n    // Ask for server address\n    sf::IpAddress server;\n    do\n    {\n        std::cout << \"Type address or name of the server to connect to: \";\n        std::cin  >> server;\n    }\n    while (server == sf::IpAddress::None);\n\n    // Create an instance of our custom recorder\n    NetworkRecorder recorder(server, port);\n\n    // Wait for user input...\n    std::cin.ignore(10000, '\\n');\n    std::cout << \"Press enter to start recording audio\";\n    std::cin.ignore(10000, '\\n');\n\n    // Start capturing audio data\n    recorder.start(44100);\n    std::cout << \"Recording... press enter to stop\";\n    std::cin.ignore(10000, '\\n');\n    recorder.stop();\n}\n",
    "/*\n* MFRC522.cpp - Library to use ARDUINO RFID MODULE KIT 13.56 MHZ WITH TAGS SPI W AND R BY COOQROBOT.\n* NOTE: Please also check the comments in MFRC522.h - they provide useful hints and background information.\n* Released into the public domain.\n*/\n\n#include <Arduino.h>\n#include \"MFRC522.h\"\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Functions for setting up the Arduino\n/////////////////////////////////////////////////////////////////////////////////////\n/**\n * Constructor.\n */\nMFRC522::MFRC522(): MFRC522(SS, UINT8_MAX) { // SS is defined in pins_arduino.h, UINT8_MAX means there is no connection from Arduino to MFRC522's reset and power down input\n} // End constructor\n\n/**\n * Constructor.\n * Prepares the output pins.\n */\nMFRC522::MFRC522(\tbyte resetPowerDownPin\t///< Arduino pin connected to MFRC522's reset and power down input (Pin 6, NRSTPD, active low). If there is no connection from the CPU to NRSTPD, set this to UINT8_MAX. In this case, only soft reset will be used in PCD_Init().\n\t\t\t\t): MFRC522(SS, resetPowerDownPin) { // SS is defined in pins_arduino.h\n} // End constructor\n\n/**\n * Constructor.\n * Prepares the output pins.\n */\nMFRC522::MFRC522(\tbyte chipSelectPin,\t\t///< Arduino pin connected to MFRC522's SPI slave select input (Pin 24, NSS, active low)\n\t\t\t\t\tbyte resetPowerDownPin\t///< Arduino pin connected to MFRC522's reset and power down input (Pin 6, NRSTPD, active low). If there is no connection from the CPU to NRSTPD, set this to UINT8_MAX. In this case, only soft reset will be used in PCD_Init().\n\t\t\t\t) {\n\t_chipSelectPin = chipSelectPin;\n\t_resetPowerDownPin = resetPowerDownPin;\n} // End constructor\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Basic interface functions for communicating with the MFRC522\n/////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Writes a byte to the specified register in the MFRC522 chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nvoid MFRC522::PCD_WriteRegister(\tPCD_Register reg,\t///< The register to write to. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\t\tbyte value\t\t\t///< The value to write.\n\t\t\t\t\t\t\t\t) {\n\tSPI.beginTransaction(SPISettings(MFRC522_SPICLOCK, MSBFIRST, SPI_MODE0));\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t// Select slave\n\tSPI.transfer(reg);\t\t\t\t\t\t// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.\n\tSPI.transfer(value);\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t// Release slave again\n\tSPI.endTransaction(); // Stop using the SPI bus\n} // End PCD_WriteRegister()\n\n/**\n * Writes a number of bytes to the specified register in the MFRC522 chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nvoid MFRC522::PCD_WriteRegister(\tPCD_Register reg,\t///< The register to write to. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\t\tbyte count,\t\t\t///< The number of bytes to write to the register\n\t\t\t\t\t\t\t\t\tbyte *values\t\t///< The values to write. Byte array.\n\t\t\t\t\t\t\t\t) {\n\tSPI.beginTransaction(SPISettings(MFRC522_SPICLOCK, MSBFIRST, SPI_MODE0));\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t// Select slave\n\tSPI.transfer(reg);\t\t\t\t\t\t// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.\n\tfor (byte index = 0; index < count; index++) {\n\t\tSPI.transfer(values[index]);\n\t}\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t// Release slave again\n\tSPI.endTransaction(); // Stop using the SPI bus\n} // End PCD_WriteRegister()\n\n/**\n * Reads a byte from the specified register in the MFRC522 chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nbyte MFRC522::PCD_ReadRegister(\tPCD_Register reg\t///< The register to read from. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\t) {\n\tbyte value;\n\tSPI.beginTransaction(SPISettings(MFRC522_SPICLOCK, MSBFIRST, SPI_MODE0));\t// Set the settings to work with SPI bus\n\tdigitalWrite(_chipSelectPin, LOW);\t\t\t// Select slave\n\tSPI.transfer(0x80 | reg);\t\t\t\t\t// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.\n\tvalue = SPI.transfer(0);\t\t\t\t\t// Read the value back. Send 0 to stop reading.\n\tdigitalWrite(_chipSelectPin, HIGH);\t\t\t// Release slave again\n\tSPI.endTransaction(); // Stop using the SPI bus\n\treturn value;\n} // End PCD_ReadRegister()\n\n/**\n * Reads a number of bytes from the specified register in the MFRC522 chip.\n * The interface is described in the datasheet section 8.1.2.\n */\nvoid MFRC522::PCD_ReadRegister(\tPCD_Register reg,\t///< The register to read from. One of the PCD_Register enums.\n\t\t\t\t\t\t\t\tbyte count,\t\t\t///< The number of bytes to read\n\t\t\t\t\t\t\t\tbyte *values,\t\t///< Byte array to store the values in.\n\t\t\t\t\t\t\t\tbyte rxAlign\t\t///< Only bit positions rxAlign..7 in values[0] are updated.\n\t\t\t\t\t\t\t\t) {\n\tif (count == 0) {\n\t\treturn;\n\t}\n\t//Serial.print(F(\"Reading \")); \tSerial.print(count); Serial.println(F(\" bytes from register.\"));\n\tbyte address = 0x80 | reg;\t\t\t\t// MSB == ",
    "//Simone Scheuer - CS162 - Program1\n//This program is designed to preform a mathematics quiz game, players will answer multipication addition and subtraction problems using numbers one through twenty.\n//The program randomly generates questions and allows two inputs before a 'life' is subtracted, the program intentionally excludes questions with negative answers.\n\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint main() {\n\n\t//seed random generation, and preset all variables to avoid bugs.\t\n\tsrand(time(0));\n\tint question_number = 0, number_range = 0;\n\tint player_answer = 0;\n\tint player_life = 5, num1 = 0, num2 = 0;\n\tint operator_choice = 0, correct_answer = 0;\n\tint game_score = 0, num_questions = 0;\n\tint start_command = 0, temp_var = 0, attempts = 0;\n\tbool answered_correctly = false;\n\tchar operator_symbol;\n\n\t//print formatted welcome messsage.\n\tcout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n\t\t<< \"\t\tWelcome to my math quiz!\t\t\\n\"\n\t\t<< \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n\t\t<< \"  You will be asked to solve simple arithmetic problems!\\n\"\n\t\t<< \"\tYou'll have two chances for each problem,\\n\"\n\t\t<< \"      But if you fail twice, you'll lose a life!\\n\"\n\t\t<< \"  You begin with 5 lives and if you run out- Game Over!\\n\"\n\t\t<< \"                Example: 5 + 7 = ?\\n\"\n\t\t<< \"                  Your Answer: 12\\n\"\n\t\t<< \"No answers will be negative, so enter -1 to exit anytime!\\n\" \n\t\t<< \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n\t\t<< \"Enter a positive number to be your max!\\n\"\n\t\t<< \"Ex: Enter 20 for equations with numbers 0-20!\\n\"\n\t\t<< \"Enter range: \";\n\tcin  >> number_range; \t\n\tcout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n\t\t<<\"Enter 1 to begin! \\n\";\n\n\t//create a loop to handle start command, error check, and allow for exit. \n\tcout << \"Enter here:  \";\n\tcin >> start_command;\n\n\twhile (start_command != 1 && start_command != -1) {\n\t\tcout << \"Please enter 1 to begin or -1 to quit!\\n\";\n\t\tcout << \"Enter: \";\n\t\tcin >> start_command;\n\t}\n\n\tif (start_command == -1) {\n\t\tcout << \"Why'd you even try and play in the first place bozo?\\n\";\n\t\treturn 0;\n\t}\n\n\t//initialize question generation loop when player is living, generate random values, select operator, calculate correct answer.\n\twhile (player_life > 0) {\n\n\t\tquestion_number += 1;\n\t\t//reset special variables each loop.\n\t\tattempts = 0;\n\t\tplayer_answer = 0;\n\n\t\tnum1 = rand() % number_range;\n\t\tnum2 = rand() % number_range;\n\t\toperator_choice = rand() % 3;\n\n\t\tif (operator_choice == 0) {\n\t\t\tcorrect_answer = num1 + num2;\n\t\t\toperator_symbol = '+';\n\n\t\t} else if (operator_choice == 1) {\n\t\t\tcorrect_answer = num1 - num2;\n\t\t\toperator_symbol = '-';\n\t\t\t//if the result is negative swap num1 and num2 to avoid negatives.\n\t\t\tif (correct_answer < 0) {\n\t\t\t\ttemp_var = num1;\n\t\t\t\tnum1 = num2;\n\t\t\t\tnum2 = temp_var;\n\t\t\t\tcorrect_answer = num1 - num2;\n\t\t\t\toperator_symbol = '-';\n\t\t\t}\n\n\t\t} else if (operator_choice == 2) {\n\t\t\tcorrect_answer = num1 * num2;\n\t\t\toperator_symbol = '*';\n\t\t}\n\n\t\tanswered_correctly = false;\n\n\t\t//initialize question answering loop while player has lives, the answer is not correct, and the player is not exiting.\n\t\twhile (attempts < 2 && !answered_correctly && player_answer != -1) {\n\t\t\tcout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"\n\t\t\t\t<< \"What is \" << num1 << \" \" << operator_symbol << \" \" << num2 << \"?\\n\"\n\t\t\t\t<< \"Your Answer: \";\n\t\t\tcin >> player_answer;\n\t\t\tcout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n\n\n\t\t\tif (player_answer == -1)\n\t\t\t{\n\t\t\t\tcout << \"Exiting the game! Thanks for playing!\\n\"\n\t\t\t\t\t<< \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif ( player_answer == correct_answer) {\n\t\t\t\tcout << \"Correct! Good Job!\\n\"\n\t\t\t\t\t<< \"Current lives: \" << player_life << \"/5\\n\";\n\n\t\t\t\tif (attempts == 0) {\n\t\t\t\t\tgame_score += 2;\n\t\t\t\t} else {\n\t\t\t\t\tgame_score +=1;\n\t\t\t\t}\n\n\t\t\t\tanswered_correctly = true;\n\n\t\t\t} else {\n\t\t\t\tattempts ++;\n\t\t\t\tif (attempts == 2)  { \n\t\t\t\t\tcout << \"Wrong again! lose a life! The correct answer was: \" << correct_answer << \".\\n\";\n\t\t\t\t\tplayer_life --;\n\t\t\t\t\tcout << \"Current lives: \" << player_life << \"/5\\n\";\n\n\t\t\t\t} else { \n\t\t\t\t\tcout << \"Wrong answer, try again!:\\n\"\n\t\t\t\t\t\t<< \"Attempts remaining: 1\\n\";\n\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\n\t//verify valid game-over and print score\t\n\tif (player_life == 0)\n\t{\n\t\tcout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n\";\n\t\tcout << \"Game Over! Your score was: \"  << game_score  << \".  You answered \" << question_number << \" Questions! \\n\\n\";\n\t\tcout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n\t}\n\treturn 0;\n\n}\n",
    "#include <stdio.h>\n#include \"LinkedList.h\"\n#include \"Stack.h\"\n\nvoid prnMenu(){\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<\"* 1. \uc0bd\uc785    2. \uc0ad\uc81c    3. \ucd9c\ub825   4. \uc885\ub8cc *\"<<endl;\n\tcout<<\"*******************************************\"<<endl;\n\tcout<<endl;\n\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uba54\ub274\ub97c \uace8\ub77c\uc8fc\uc138\uc694: \";\n}\n\nint main(){\n\t    int mode, selectNumber, tmpItem;\n\t\tLinkedList<int> *p;\n\t\tbool flag = false;\n\n\t\tcout<<\"\uc790\ub8cc\uad6c\uc870 \uc120\ud0dd(1: Stack, Other: Linked List): \";\n\t\tcin>>mode;\n\t\t\t\t\t\t    \n\t\tif(mode == 1)\n\t\t\tp = new Stack<int>();    // \uc815\uc218\ub97c \uc800\uc7a5\ud558\ub294 \uc2a4\ud0dd\n\t\t\t\n\t\telse\n\t\t\tp = new LinkedList<int>();\n\n\n\t\tdo{\n\t\t\tprnMenu();\n\t\t\tcin>>selectNumber;\n\t\t\t\n\t\t\tswitch(selectNumber){ \n\t\t\t\tcase 1:\n\t\t\t\t\tcout<<\"\uc6d0\ud558\uc2dc\ub294 \uac12\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694: \";\n\t\t\t\t\tcin>>tmpItem;    p->Insert(tmpItem);\n\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0bd\uc785\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 2:\n\t\t\t\t\tif(p->Delete(tmpItem)==true)\n\t\t\t\t\t\tcout<<tmpItem<<\"\uac00 \uc0ad\uc81c\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\t\t\n\t\t\t\t\telse cout<<\"\ube44\uc5b4\uc788\uc2b5\ub2c8\ub2e4. \uc0ad\uc81c \uc2e4\ud328\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\tcout<<\"\ud06c\uae30: \"<<p->GetSize()<<endl;\n\t\t\t\t\tp->Print();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tflag = true;     break;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tcout<<\"\uc798\ubabb \uc785\ub825\ud558\uc168\uc2b5\ub2c8\ub2e4.\"<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) break;\n\t\t\t\n\t\t} while(1);\n\t\t\n\t\treturn 0;\n}\n\n",
    "/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include \"../../SDL_internal.h\"\n\n/* An implementation of mutexes using the Symbian API. */\n\n#include <e32std.h>\n\n#include \"SDL_thread.h\"\n#include \"SDL_systhread_c.h\"\n\nstruct SDL_mutex\n{\n    TInt handle;\n};\n\nextern TInt CreateUnique(TInt (*aFunc)(const TDesC &aName, TAny *, TAny *), TAny *, TAny *);\n\nstatic TInt NewMutex(const TDesC &aName, TAny *aPtr1, TAny *)\n{\n    return ((RMutex *)aPtr1)->CreateGlobal(aName);\n}\n\n/* Create a mutex */\nSDL_mutex *SDL_CreateMutex(void)\n{\n    RMutex rmutex;\n\n    TInt status = CreateUnique(NewMutex, &rmutex, NULL);\n    if (status != KErrNone) {\n        SDL_SetError(\"Couldn't create mutex.\");\n        return NULL;\n    }\n    SDL_mutex *mutex = new /*(ELeave)*/ SDL_mutex;\n    mutex->handle = rmutex.Handle();\n    return mutex;\n}\n\n/* Free the mutex */\nvoid SDL_DestroyMutex(SDL_mutex *mutex)\n{\n    if (mutex) {\n        RMutex rmutex;\n        rmutex.SetHandle(mutex->handle);\n        rmutex.Signal();\n        rmutex.Close();\n        delete (mutex);\n        mutex = NULL;\n    }\n}\n\n/* Lock the mutex */\nint SDL_LockMutex(SDL_mutex *mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */\n{\n    if (mutex == NULL) {\n        return 0;\n    }\n\n    RMutex rmutex;\n    rmutex.SetHandle(mutex->handle);\n    rmutex.Wait();\n\n    return 0;\n}\n\n/* Try to lock the mutex */\n#if 0\nint SDL_TryLockMutex(SDL_mutex *mutex)\n{\n    if (mutex == NULL)\n    {\n        return 0;\n    }\n\n    // Not yet implemented.\n    return 0;\n}\n#endif\n\n/* Unlock the mutex */\nint SDL_UnlockMutex(SDL_mutex *mutex) SDL_NO_THREAD_SAFETY_ANALYSIS /* clang doesn't know about NULL mutexes */\n{\n    if (mutex == NULL) {\n        return 0;\n    }\n\n    RMutex rmutex;\n    rmutex.SetHandle(mutex->handle);\n    rmutex.Signal();\n\n    return 0;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n",
    "// Author: Nemuel Wainaina\n\n#include <iostream>\n#include <windows.h>\n\nHWND nextClipboardViewer;\n\nLRESULT __stdcall ClipboardViewerProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {\n    switch(msg) {\n        case WM_DRAWCLIPBOARD: {\n            if(OpenClipboard(hWnd)) {\n                HANDLE clipboardData = GetClipboardData(CF_TEXT);\n                if(clipboardData != NULL) {\n                    char* clipboardText = static_cast<char*>(GlobalLock(clipboardData));\n                    if(clipboardText != NULL) {\n                        std::cout << clipboardText << std::endl;\n                    }\n                    GlobalUnlock(clipboardData);\n                }\n                CloseClipboard();\n            }\n            SendMessage(nextClipboardViewer, msg, wParam, lParam);\n            break;\n        }\n        case WM_CHANGECBCHAIN: {\n            if((HWND)wParam == nextClipboardViewer) {\n                nextClipboardViewer = (HWND)lParam;\n            } else {\n                SendMessage(nextClipboardViewer, msg, wParam, lParam);\n            }\n            break;\n        }\n        default:\n            return DefWindowProc(hWnd, msg, wParam, lParam);\n    }\n\n    return 0;\n}\n\nint main() {\n    WNDCLASSW wc = {};\n    wc.lpfnWndProc = ClipboardViewerProc;\n    wc.hInstance = GetModuleHandle(NULL);\n    wc.lpszClassName = L\"ClipboardViewer\";\n    RegisterClassW(&wc);\n\n    HWND hWndViewer = CreateWindowExW(\n        0, L\"ClipboardViewer\", L\"Clipboard Viewer\",\n        0, 0, 0, 0, 0, HWND_MESSAGE, NULL, GetModuleHandle(NULL), NULL);\n    nextClipboardViewer = SetClipboardViewer(hWndViewer);\n\n    MSG msg;\n    while(GetMessage(&msg, NULL, 0, 0)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n\n    ChangeClipboardChain(hWndViewer, nextClipboardViewer);\n    DestroyWindow(hWndViewer);\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <map>\r\n\r\nstruct dat {\r\n\tint val;\r\n\tint sum;\r\n};\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tvector<dat> data;\r\n\tmap<int, int> values;\r\n\tlong long prev, next, delt, cur, result, sum, rez_sum, rez_delt, beg_v, end_v;\r\n\tcur = 0;\r\n\tresult = 0;\r\n\r\n\tdat cur_dat;\r\n\tcin >> prev;\r\n\tcin >> next;\r\n\tdelt = next - prev;\r\n\tsum = delt;\r\n\tcur_dat.sum = sum;\r\n\tcur_dat.val = prev;\r\n\tdata.push_back(cur_dat);\r\n\tvalues[delt]++;\r\n\r\n\twhile (cur != -2000000000) {\r\n\t\tcin >> cur;\r\n\t\tif (cur == -2000000000) break;\r\n\r\n\t\tprev = next;\r\n\t\tnext = cur;\r\n\t\tdelt = next - prev;\r\n\r\n\t\tcur_dat.sum += delt;\r\n\t\tcur_dat.val = prev;\r\n\r\n\t\tdata.push_back(cur_dat);\r\n\t\tvalues[delt]++;\r\n\t}\r\n\r\n\trez_sum = data.back().sum;\r\n\trez_delt = data.back().val - data.front().val;\r\n\tbeg_v = data.front().val;\r\n\tend_v = data.back().val;\r\n\t//cout << \"rez_sum:\" << rez_sum << \"; rez_delt:\" << rez_delt << \"; beg_v:\" << beg_v << \"; end_v:\" << end_v << endl;\r\n\t//cout << \"sum first:\" << data.front().sum << \"; val first:\" << data.front().val << endl;\r\n\r\n\tif (rez_sum != rez_delt) result = 6; //6\r\n\telse if (rez_delt == 0) result = 1;//1\r\n\telse if (end_v > beg_v) {\r\n\t\tif (values.size() > 1) result = 3;//3 \r\n\t\telse result = 2;//2\r\n\t}\r\n\telse if (end_v < beg_v) {\r\n\t\tif (values.size() > 1) result = 5;//5 \r\n\t\telse result = 4;//4\r\n\t}\r\n\r\n\tswitch (result) {\r\n\tcase 0:cout << \"wrong data\"; break;\r\n\tcase 1:cout << \"CONSTANT\"; break;\r\n\tcase 2:cout << \"ASCENDING\"; break;\r\n\tcase 3:cout << \"WEAKLY ASCENDING\"; break;\r\n\tcase 4:cout << \"DESCENDING\"; break;\r\n\tcase 5:cout << \"WEAKLY DESCENDING\"; break;\r\n\tcase 6:cout << \"RANDOM\"; break;\r\n\t}\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"navigator_test2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n    tests/test_methods_and_attributes.cpp -- constructors, deconstructors, attribute access,\n    __str__, argument and return value conventions\n\n    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#include \"constructor_stats.h\"\n#include \"pybind11_tests.h\"\n\n#if !defined(PYBIND11_OVERLOAD_CAST)\ntemplate <typename... Args>\nusing overload_cast_ = pybind11::detail::overload_cast_impl<Args...>;\n#endif\n\nclass ExampleMandA {\npublic:\n    ExampleMandA() { print_default_created(this); }\n    explicit ExampleMandA(int value) : value(value) { print_created(this, value); }\n    ExampleMandA(const ExampleMandA &e) : value(e.value) { print_copy_created(this); }\n    explicit ExampleMandA(std::string &&) {}\n    ExampleMandA(ExampleMandA &&e) noexcept : value(e.value) { print_move_created(this); }\n    ~ExampleMandA() { print_destroyed(this); }\n\n    std::string toString() const { return \"ExampleMandA[value=\" + std::to_string(value) + \"]\"; }\n\n    void operator=(const ExampleMandA &e) {\n        print_copy_assigned(this);\n        value = e.value;\n    }\n    void operator=(ExampleMandA &&e) noexcept {\n        print_move_assigned(this);\n        value = e.value;\n    }\n\n    // NOLINTNEXTLINE(performance-unnecessary-value-param)\n    void add1(ExampleMandA other) { value += other.value; }         // passing by value\n    void add2(ExampleMandA &other) { value += other.value; }        // passing by reference\n    void add3(const ExampleMandA &other) { value += other.value; }  // passing by const reference\n    void add4(ExampleMandA *other) { value += other->value; }       // passing by pointer\n    void add5(const ExampleMandA *other) { value += other->value; } // passing by const pointer\n\n    void add6(int other) { value += other; }        // passing by value\n    void add7(int &other) { value += other; }       // passing by reference\n    void add8(const int &other) { value += other; } // passing by const reference\n    // NOLINTNEXTLINE(readability-non-const-parameter) Deliberately non-const for testing\n    void add9(int *other) { value += *other; }        // passing by pointer\n    void add10(const int *other) { value += *other; } // passing by const pointer\n\n    void consume_str(std::string &&) {}\n\n    ExampleMandA self1() { return *this; }              // return by value\n    ExampleMandA &self2() { return *this; }             // return by reference\n    const ExampleMandA &self3() const { return *this; } // return by const reference\n    ExampleMandA *self4() { return this; }              // return by pointer\n    const ExampleMandA *self5() const { return this; }  // return by const pointer\n\n    int internal1() const { return value; }        // return by value\n    int &internal2() { return value; }             // return by reference\n    const int &internal3() const { return value; } // return by const reference\n    int *internal4() { return &value; }            // return by pointer\n    const int *internal5() { return &value; }      // return by const pointer\n\n    py::str overloaded() { return \"()\"; }\n    py::str overloaded(int) { return \"(int)\"; }\n    py::str overloaded(int, float) { return \"(int, float)\"; }\n    py::str overloaded(float, int) { return \"(float, int)\"; }\n    py::str overloaded(int, int) { return \"(int, int)\"; }\n    py::str overloaded(float, float) { return \"(float, float)\"; }\n    py::str overloaded(int) const { return \"(int) const\"; }\n    py::str overloaded(int, float) const { return \"(int, float) const\"; }\n    py::str overloaded(float, int) const { return \"(float, int) const\"; }\n    py::str overloaded(int, int) const { return \"(int, int) const\"; }\n    py::str overloaded(float, float) const { return \"(float, float) const\"; }\n\n    static py::str overloaded(float) { return \"static float\"; }\n\n    int value = 0;\n};\n\nstruct TestProperties {\n    int value = 1;\n    static int static_value;\n\n    int get() const { return value; }\n    void set(int v) { value = v; }\n\n    static int static_get() { return static_value; }\n    static void static_set(int v) { static_value = v; }\n};\nint TestProperties::static_value = 1;\n\nstruct TestPropertiesOverride : TestProperties {\n    int value = 99;\n    static int static_value;\n};\nint TestPropertiesOverride::static_value = 99;\n\nstruct TestPropRVP {\n    UserType v1{1};\n    UserType v2{1};\n    static UserType sv1;\n    static UserType sv2;\n\n    const UserType &get1() const { return v1; }\n    const UserType &get2() const { return v2; }\n    UserType get_rvalue() const { return v2; }\n    void set1(int v) { v1.set(v); }\n    void set2(int v) { v2.set(v); }\n};\nUserType TestPropRVP::sv1(1);\nUserType TestPropRVP::sv2(1);\n\n// Test None-allowed py::arg argument policy\nclass NoneTester {\npublic:\n    int answer = 42;\n};\nint none1(const NoneTester &obj) { return obj.answer; }\nint none2(NoneTester *obj) { return obj ? obj->answer : -1; }\nint none3(std::shared_ptr<NoneTester> &obj) {",
    "/**\n * AP Computer Science Principles: Performance Task 2023/2024\n * @author Benjamin Atkinson\n * @date 4/9/2024\n * \n * Controls:\n *  W to move up\n *  S to move down\n *  A to move left\n *  D to move right\n *  Space to show tower overlay\n *  E to place a tower\n */\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory>\n#include <utility>\n#include <conio.h>\n#include <chrono>\n#include <thread>\n\nusing byte = unsigned char;\nusing usize = unsigned long long;\n\ntemplate <typename T> class vector2 {\npublic:\n\tT x, y;\n\n\tvector2():\n\t\tvector2(0, 0)\n\t{}\n\tvector2(T &&x_, T &&y_):\n\t\tx(std::move(x_)),\n\t\ty(std::move(y_))\n\t{}\n\n\tbool operator == (const vector2 &rhs) const {\n\t\treturn (this->x == rhs.x) && (this->y == rhs.y);\n\t}\n\tvector2 &operator += (const vector2 &rhs) {\n\t\tthis->x += rhs.x;\n\t\tthis->y += rhs.y;\n\t\treturn *this;\n\t}\n\tvector2 &operator -= (const vector2 &rhs) {\n\t\tthis->x -= rhs.x;\n\t\tthis->y -= rhs.y;\n\t\treturn *this;\n\t}\n\ttemplate <typename U> vector2 &operator *= (const U &rhs) {\n\t\tthis->x *= rhs;\n\t\tthis->y *= rhs;\n\t\treturn *this;\n\t}\n\ttemplate <typename U> vector2 &operator /= (const U &rhs) {\n\t\tthis->x /= rhs;\n\t\tthis->y /= rhs;\n\t\treturn *this;\n\t}\n\tvector2 operator + (const vector2 &rhs) const {\n\t\treturn vector2(this->x + rhs.x, this->y + rhs.y);\n\t}\n\tvector2 operator - (const vector2 &rhs) const {\n\t\treturn vector2(this->x - rhs.x, this->y - rhs.y);\n\t}\n\ttemplate <typename U> vector2 operator * (const U &rhs) const {\n\t\treturn vector2(this->x * rhs, this->y * rhs);\n\t}\n\ttemplate <typename U> vector2 operator / (const U &rhs) const {\n\t\treturn vector2(this->x / rhs, this->y / rhs);\n\t}\n};\n\nnamespace ansi {\n\tconst char *prefix = \"\\033[\";\n\tconst char *suffix = \"m\";\n\n\tnamespace id {\n\t\tconst byte\n\t\t\treset = 0,\n\t\t\tbold = 1,\n\t\t\titalic = 3,\n\t\t\tunderline = 4,\n\t\t\tinverse = 7,\n\t\t\thidden = 8,\n\t\t\tstrikethrough = 9,\n\t\t\tgray = 30,\t\t\t\tgray_bg = 40,\t\t\t\tgray_bright = 90,\t\t\t\tgray_bg_bright = 100,\n\t\t\tred = 31,\t\t\t\tred_bg = 41,\t\t\t\tred_bright = 91,\t\t\t\tred_bg_bright = 101,\n\t\t\tgreen = 32,\t\t\t\tgreen_bg = 42,\t\t\t\tgreen_bright = 92,\t\t\t\tgreen_bg_bright = 102,\n\t\t\tyellow = 33,\t\t\tyellow_bg = 43,\t\t\t\tyellow_bright = 93,\t\t\t\tyellow_bg_bright = 103,\n\t\t\tblue = 34,\t\t\t\tblue_bg = 44,\t\t\t\tblue_bright = 94,\t\t\t\tblue_bg_bright = 104,\n\t\t\tpurple = 35,\t\t\tpurple_bg = 45,\t\t\t\tpurple_bright = 95,\t\t\t\tpurple_bg_bright = 105,\n\t\t\tcyan = 36,\t\t\t\tcyan_bg = 46,\t\t\t\tcyan_bright = 96,\t\t\t\tcyan_bg_bright = 106,\n\t\t\twhite = 37,\t\t\t\twhite_bg = 47,\t\t\t\twhite_bright = 97,\t\t\t\twhite_bg_bright = 107;\n\t}\n\n\tnamespace code {\n\t\tconst char\n\t\t\t*reset = \"\\033[0m\",\n\t\t\t*bold = \"\\033[1m\",\n\t\t\t*italic = \"\\033[3m\",\n\t\t\t*underline = \"\\033[4m\",\n\t\t\t*inverse = \"\\033[7m\",\n\t\t\t*hidden = \"\\033[8m\",\n\t\t\t*strikethrough = \"\\033[9m\",\n\t\t\t*gray = \"\\033[30m\",\t\t*gray_bg = \"\\033[40m\",\t\t*gray_bright = \"\\033[90m\",\t\t*gray_bg_bright = \"\\033[100m\",\n\t\t\t*red = \"\\033[31m\",\t\t*red_bg = \"\\033[41m\",\t\t*red_bright = \"\\033[91m\",\t\t*red_bg_bright = \"\\033[101m\",\n\t\t\t*green = \"\\033[32m\",\t*green_bg = \"\\033[42m\",\t\t*green_bright = \"\\033[92m\",\t\t*green_bg_bright = \"\\033[102m\",\n\t\t\t*yellow = \"\\033[33m\",\t*yellow_bg = \"\\033[43m\",\t*yellow_bright = \"\\033[93m\",\t*yellow_bg_bright = \"\\033[103m\",\n\t\t\t*blue = \"\\033[34m\",\t\t*blue_bg = \"\\033[44m\",\t\t*blue_bright = \"\\033[94m\",\t\t*blue_bg_bright = \"\\033[104m\",\n\t\t\t*purple = \"\\033[35m\",\t*purple_bg = \"\\033[45m\",\t*purple_bright = \"\\033[95m\",\t*purple_bg_bright = \"\\033[105m\",\n\t\t\t*cyan = \"\\033[36m\",\t\t*cyan_bg = \"\\033[46m\",\t\t*cyan_bright = \"\\033[96m\",\t\t*cyan_bg_bright = \"\\033[106m\",\n\t\t\t*white = \"\\033[37m\",\t*white_bg = \"\\033[47m\",\t\t*white_bright = \"\\033[97m\",\t\t*white_bg_bright = \"\\033[107m\";\n\t}\n}\n\nnamespace math {\n\ttemplate <typename T> T min(T a, T b) {\n\t\treturn a * (a < b) + b * (a >= b);\n\t}\n\n\ttemplate <typename T> T max(T a, T b) {\n\t\treturn a * (a > b) + b * (a <= b);\n\t}\n\n\ttemplate <typename T> T clamp(T v, T a, T b) {\n\t\treturn min<T>(max<T>(v, a), b);\n\t}\n}\n\nnamespace random {\n\tvoid seed(const unsigned int &s) {\n\t\tsrand(s);\n\t}\n\n\tint next(const int min, const int max) {\n\t\treturn min - 1 + (rand() % (max - min));\n\t}\n}\n\nstruct pixel {\n\tbyte symbol, style;\n};\n\nusing bitmap = std::vector<std::vector<pixel>>;\n\nenum entity_type: byte {\n\tENEMY_1 = 0,\n\tFRIENDLY_1 = 64,\n\tATTACK_1 = 128,\n};\n\nstruct entity {\n\tentity_type type;\n\tbyte dist;\n\tvector2<byte> pos, size, model_offset;\n\tbitmap bmp;\n};\n\nenum tile: byte {\n\tPATH = ' ',\t\t\t// space where enemies can walk\n\tDIRT = '#',\t\t\t// space where you can place towers\n};\n\nenum path_dir: byte {\n\tDW = 0,\n\tFW = 1,\n\tUW = 2,\n};\n\nenum cursor_state: byte {\n\tMOVE = 0,\n\tBUILD = 1,\n};\n\n\nclass game {\npublic:\n\tbool should_close = false;\n\tstd::thread input_thr;\n\tint input = 0;\n\n\tgame():\n\t\tinput_thr(std::thread([this]() {\n\t\t\twhile(!should_close) input = getch();\n\t\t}))\n\t{}\n\n\t~game() {\n\t\tinput_thr.join();\n\t}\n\n\tconst vector2<byte> screen_size = vector2<byte>(51, 12);\n\n\tconst vector2<byte> map_size = vector2<byte>(screen_size.x - 2, screen_size.y - 4);\n\tstd::vector<std::vector<tile>> map = std::vector<std::vector<tile>>(map_size.y, std::vector<tile>(map_size.x, tile::DIRT));\n\n\tconst vector2<byte> pa",
    "module spreadsheet;\n\nimport invalid_coordinate;\nimport <stdexcept>;\nimport <utility>;\nimport <iostream>;\nimport <format>;\n\nusing namespace std;\n\nSpreadsheet::Spreadsheet(size_t width, size_t height)\n{\n\tcout << \"Normal constructor\" << endl;\n\n\tif (width > MaxWidth) {\n\t\tthrow invalid_argument{ format(\"The given width {} is greater than the maximum {}.\",\n\t\t\twidth, MaxWidth) };\n\t}\n\tif (height > MaxHeight) {\n\t\tthrow invalid_argument{ format(\"The given height {} is greater than the maximum {}.\",\n\t\t\theight, MaxHeight) };\n\t}\n\n\tm_cells = new SpreadsheetCell*[width] {};\t// Array is zero-initialized!\n\n\t// Don't initialize the m_width and m_height members in the ctor-\n\t// initializer. These should only be initialized when the above\n\t// m_matrix allocation succeeds!\n\tm_width = width;\n\tm_height = height;\n\n\ttry {\n\t\tfor (size_t i{ 0 }; i < m_width; i++) {\n\t\t\tm_cells[i] = new SpreadsheetCell[m_height];\n\t\t}\n\t} catch (...) {\n\t\tcleanup();\n\t\t// Nest any caught exception inside a bad_alloc exception.\n\t\tthrow_with_nested(bad_alloc{});\n\t}\n}\n\nSpreadsheet::~Spreadsheet()\n{\n\tcleanup();\n}\n\nvoid Spreadsheet::cleanup() noexcept\n{\n\tfor (size_t i{ 0 }; i < m_width; i++) {\n\t\tdelete[] m_cells[i];\n\t}\n\tdelete[] m_cells;\n\tm_cells = nullptr;\n\tm_width = m_height = 0;\n}\n\nSpreadsheet::Spreadsheet(const Spreadsheet& src)\n\t: Spreadsheet{ src.m_width, src.m_height }\n{\n\tcout << \"Copy constructor\" << endl;\n\n\t// The ctor-initializer of this constructor delegates first to the\n\t// non-copy constructor to allocate the proper amount of memory.\n\n\t// The next step is to copy the data.\n\tfor (size_t i{ 0 }; i < m_width; i++) {\n\t\tfor (size_t j{ 0 }; j < m_height; j++) {\n\t\t\tm_cells[i][j] = src.m_cells[i][j];\n\t\t}\n\t}\n}\n\nvoid Spreadsheet::verifyCoordinate(size_t x, size_t y) const\n{\n\tif (x >= m_width || y >= m_height) {\n\t\tthrow InvalidCoordinate{ x, y, MaxWidth, MaxHeight };\n\t}\n}\n\nvoid Spreadsheet::setCellAt(size_t x, size_t y, const SpreadsheetCell& cell)\n{\n\tverifyCoordinate(x, y);\n\tm_cells[x][y] = cell;\n}\n\nSpreadsheetCell& Spreadsheet::getCellAt(size_t x, size_t y)\n{\n\tverifyCoordinate(x, y);\n\treturn m_cells[x][y];\n}\n\nvoid Spreadsheet::swap(Spreadsheet& other) noexcept\n{\n\tstd::swap(m_width, other.m_width);\n\tstd::swap(m_height, other.m_height);\n\tstd::swap(m_cells, other.m_cells);\n}\n\nvoid swap(Spreadsheet& first, Spreadsheet& second) noexcept\n{\n\tfirst.swap(second);\n}\n\nSpreadsheet& Spreadsheet::operator=(const Spreadsheet& rhs)\n{\n\tcout << \"Copy assignment operator\" << endl;\n\n\t// Copy-and-swap idiom\n\tSpreadsheet temp{ rhs }; // Do all the work in a temporary instance\n\tswap(temp); // Commit the work with only non-throwing operations\n\treturn *this;\n}\n\n// Move constructor\nSpreadsheet::Spreadsheet(Spreadsheet&& src) noexcept\n{\n\tcout << \"Move constructor\" << endl;\n\n\tswap(*this, src);\n}\n\n// Move assignment operator\nSpreadsheet& Spreadsheet::operator=(Spreadsheet&& rhs) noexcept\n{\n\tcout << \"Move assignment operator\" << endl;\n\n\tswap(*this, rhs);\n\treturn *this;\n}\n",
    "// main.cpp - All code execution and termination occurs in this file.\n\n#include <array>\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"student.h\"\n#include \"roster.h\"\n#include \"degree.h\"\n\nint main() {\n    // Student data array\n    const std::string studentData[] = {\n            \"1,John,Doe,JohnDoe123@gm ail.com,21,29,36,40,SECURITY\",\n            \"2,Jane,Doe,Doe_Jane3@gmailcom,5,21,30,42,SOFTWARE\",\n            \"3,Bob,Burger,Burger_flippin_master101yahoo.com,16,31,10,34,NETWORK\",\n            \"4,Spongebob,Squarepants,Squarepants.Sponge@comcast.net,20,40,52,65,SOFTWARE\",\n            \"5,Peter,Griffin,birdtheword@outlook.com,18,32,31,36,NETWORK\"\n    };\n\n    // Parse student data\n    std::vector<std::array<std::string, 9>> dataByCategory;\n    int start = 0;\n    for (std::string data : studentData) {\n        int numParameters = 0;\n        std::array<std::string, 9> parameters = {};\n        for (int i = 0; i < data.length(); i++) {\n            if (data[i] == ',') {\n                std::string parameter = data.substr(start, i - start);\n                start = i + 1;\n                parameters[numParameters] = parameter;\n                numParameters++;\n            } else if ((data[i] != ',') && (data.length() - i == 1)) {\n                std::string parameter = data.substr(start, (data.length()) - start);\n                start = 0;\n                parameters[numParameters] = parameter;\n                numParameters = 0;\n            }\n        }\n        dataByCategory.push_back(parameters);\n    }\n\n    // Create a roster class instance with 5 student objects\n    Roster *classRoster = new Roster(5);\n\n    // Create student objects\n    for (int i = 0; i < 5; i++) {\n        classRoster->add(\n                dataByCategory[i][0],  // studentID\n                dataByCategory[i][1],  // firstName\n                dataByCategory[i][2],  // lastName\n                dataByCategory[i][3],  // emailAddress\n                std::stoi(dataByCategory[i][4]),  // age\n                std::stoi(dataByCategory[i][5]), // daysInCourse1\n                std::stoi(dataByCategory[i][6]),  // daysInCourse2\n                std::stoi(dataByCategory[i][7]), // daysInCourse3\n                dataByCategory[i][8] // degreeProgram\n                );\n    }\n\n\n    // Print class roster\n    classRoster->printAll();\n    std::cout << std::endl;\n    // Print invalid emails\n    classRoster->printInvalidEmails();\n    std::cout << std::endl;\n    // Print average days in course\n    for (int i = 0; i < 5; i++) {\n        classRoster->printAverageDaysInCourse(classRoster->getStudentID(i));\n    }\n    std::cout << std::endl;\n    // Print students with SOFTWARE degree program\n    classRoster->printByDegreeProgram(DegreeProgram::SOFTWARE);\n    std::cout << std::endl;\n    // Remove student A3\n    classRoster->remove(\"A3\");\n    std::cout << std::endl;\n    // Print updated full roster\n    classRoster->printAll();\n    std::cout << std::endl;\n    // Expected error (A3 no longer exists)\n    classRoster->remove(\"A3\");\n    // Call destructor and clean allocated memory\n    delete classRoster;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fomohome\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// echo_server.cpp\n// ~~~~~~~~~~~~~~~\n//\n// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)\n//\n// Distributed under the Boost Software License, Version 1.0. (See accompanying\n// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#include <asio/co_spawn.hpp>\n#include <asio/detached.hpp>\n#include <asio/io_context.hpp>\n#include <asio/ip/tcp.hpp>\n#include <asio/signal_set.hpp>\n#include <asio/write.hpp>\n#include <cstdio>\n\nusing asio::ip::tcp;\nusing asio::awaitable;\nusing asio::co_spawn;\nusing asio::detached;\nusing asio::use_awaitable;\nnamespace this_coro = asio::this_coro;\n\n#if defined(ASIO_ENABLE_HANDLER_TRACKING)\n# define use_awaitable \\\n  asio::use_awaitable_t(__FILE__, __LINE__, __PRETTY_FUNCTION__)\n#endif\n\nawaitable<void> echo(tcp::socket socket)\n{\n  try\n  {\n    char data[1024];\n    for (;;)\n    {\n      std::size_t n = co_await socket.async_read_some(asio::buffer(data), use_awaitable);\n      co_await async_write(socket, asio::buffer(data, n), use_awaitable);\n    }\n  }\n  catch (std::exception& e)\n  {\n    std::printf(\"echo Exception: %s\\n\", e.what());\n  }\n}\n\nawaitable<void> listener()\n{\n  auto executor = co_await this_coro::executor;\n  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});\n  for (;;)\n  {\n    tcp::socket socket = co_await acceptor.async_accept(use_awaitable);\n    co_spawn(executor, echo(std::move(socket)), detached);\n  }\n}\n\nint main()\n{\n  try\n  {\n    asio::io_context io_context(1);\n\n    asio::signal_set signals(io_context, SIGINT, SIGTERM);\n    signals.async_wait([&](auto, auto){ io_context.stop(); });\n\n    co_spawn(io_context, listener(), detached);\n\n    io_context.run();\n  }\n  catch (std::exception& e)\n  {\n    std::printf(\"Exception: %s\\n\", e.what());\n  }\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Student Name: Carson McDonald\n// Teacher : Dr. Tyson McMillan\n// Date: 4/11/2024\n// A program to practice working with multidimensional arrays.\n// In this program I used two single dimension arrays to store weather for two\n// different cities for 7 days. Then fed it to a multidimensional array that was\n// used to ouput the data collected.\n#include <iostream>\nusing namespace std;\n\nint main() {\n  const int CITY = 2;          // There are 2 cities.\n  const int WEEK = 7;          // There are 7 days in a week.\n  int temperature[CITY][WEEK]; // This is the array that will be used to present\n                               // the temperature.\n  int cityOne[7]; // This is the array that will be used to hold the temperature\n                  // for city one.\n  int cityTwo[7]; // This is the array that will be used to hold the temperature\n                  // for city two.\n  string City_One = \"Dallas\"; // This is the name of the first city.\n  string City_Two = \"Austin\"; // This is the name of the second city.\n  cout << \"Welcome to the Weather Program! \" << endl;\n  // Part 1.\n  // These are the the Cities that I looked up Austin and Dallas. And the\n  // temperatuers for each day of the week.\n  cout << \"Temperatures for \" << City_One << \":\" << endl;\n  int cityOneActualTemp[] = {79, 81, 83, 80, 86, 88, 84};\n  for (int i = 0; i < 7; i++) {\n    cout << City_One << \", Day \" << i + 1 << \": \" << cityOneActualTemp[i]\n         << endl;\n  }\n  cout << \"Temperatures for \" << City_Two << \":\" << endl;\n  int cityTwoActualTemp[] = {83, 83, 83, 85, 86, 87, 88};\n  for (int i = 0; i < 7; i++) {\n    cout << City_Two << \", Day \" << i + 1 << \": \" << cityTwoActualTemp[i]\n         << endl;\n  }\n  // Part 2.\n  // Prompt user for input of temperatues for two different cities.\n  // Input temperatures for City One (Dallas).\n  cout << \"Enter temperatures for \" << City_One << \": \" << endl;\n  for (int j = 0; j < WEEK;\n       ++j) { // Setting the loop to start at 0 and increment by 1 til it\n              // reaches the value of WEEK.\n    cout << City_One << \", Day \" << j + 1 << \": \";\n    cin >> cityOne[j];\n  }\n\n  // Input temperatures for City Two(Austin.\n  cout << \"Enter temperatures for \" << City_Two << \":\" << endl;\n  for (int j = 0; j < WEEK;\n       ++j) { // Setting the loop to start at 0 and increment by 1 til it\n              // reaches the value of WEEK.\n    cout << City_Two << \", Day \" << j + 1 << \": \";\n    cin >> cityTwo[j];\n  }\n\n  // Assigning the data to the temperature array.\n  for (int j = 0; j < WEEK; ++j) {\n    temperature[0][j] = cityOne[j];\n    temperature[1][j] = cityTwo[j];\n  }\n\n  cout << \"\\n\\nDisplaying Values:\\n\";\n\n  // Accessing the values from the temperature array.\n  for (int i = 0; i < 1; ++i) { // Setting the loop to start at 0 and increment\n                                // by 1 til it reaches the value of CITY.\n    cout << \"City: \" << City_One << endl\n         << \"Temperatures for the week:\" << endl;\n    for (int j = 0; j < WEEK;\n         ++j) { // Setting the loop to start at 0 and increment by 1 til it\n                // reaches the value of WEEK.\n      cout << City_One << \", Day \" << j + 1 << \" : \" << temperature[i][j]\n           << endl;\n    }\n  }\n  for (int i = 1; i < 2; ++i) { // Setting the loop to start at 0 and increment\n                                // by 1 til it reaches the value of CITY.\n    cout << \"City: \" << City_Two << endl\n         << \"Temperatures for the week:\" << endl;\n    for (int j = 0; j < WEEK;\n         ++j) { // Setting the loop to start at 0 and increment by 1 til it\n                // reaches the value of WEEK.\n      cout << City_Two << \", Day \" << j + 1 << \" : \" << temperature[i][j]\n           << endl;\n    }\n  }\n  cout << \"Thank you for using the Weather Program! \" << endl;\n  return 0;\n}",
    "#include<iostream>\n#include<cstdlib>\n#include<ctype.h>\nusing namespace std;\nclass Bank{\n\tprivate:\n\t\t//String name;\n\t\tlong long acc;\n\t\tchar type[10];\n\t\tint pin;\n\t\tlong lo\n\t\tlong long amt;\n\tpublic:\n\t\tvoid setval(){\n\t\t\t/*cout<<\"\\nEnter the name: \";\n\t\t\tcin.ignore();\n\t\t\tgetline(cin,name);*/\n\t\t\t\n\t\t\tcout<<\"\\nEnter the account number: \";\n\t\t\tcin>>acc;\n\t\t\tif(acc<=0){\n\t\t\t\tcout<<\"\\nEnter positive account number\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tcout<<\"\\nEnter the account type: \";\n\t\t\tcin>>type;\n\t\t\t\n\t\t\tcout<<\"\\nEnter the 4-digit pin number: \";\n\t\t\tcin>>pin;\n\t\t\tif(pin<1000 || pin>9999)\n\t\t\t{\n\t\t\t\tcout<<\"\\nInvalid pin. Enter 4-digit pin\";\n\t\t\t}\n\t\t\t\n\t\t\tcout<<\"\\nEnter the balance: \";\n\t\t\tcin>>tot;\n\t\t\t\n\t\t}\n\t  void deposit()\n\t\t{\n\t\t\tint epin;\n\t\t\tcout<<\"\\nEnter the PIN: \";\n\t\t\tcin>>epin;\n\t\t\tif(epin!=pin)\n\t\t\t{\n\t\t\t\tcout<<\"\\nInvalid Pin\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcout<<\"\\nEnter the deposit amount: \";\n\t\t\tcin>>amt;\n\t\t\tif(amt<=0){\n\t\t\t\tcout<<\"\\nEnter positive deposit amt\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttot+=amt;\n\t\t\tcout<<\"\\nDeposited successfully\";\n\t\t\tcout<<\"Total bal: \"<<tot;\n\t\t\t\n\t\t}\n\t\tvoid withdraw()\n\t\t{\n\t\t\tint epin;\n\t\t\tcout<<\"\\nEnter the PIN: \";\n\t\t\tcin>>epin;\n\t\t\tif(epin!=pin)\n\t\t\t{\n\t\t\t\tcout<<\"\\nInvalid Pin\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcout<<\"\\nEnter the withdrawal amount: \";\n\t\t\tcin>>amt;\n\t\t\tif(amt<=0 || amt>tot){\n\t\t\t\tcout<<\"\\nInsufficient balance\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttot-=amt;\n\t\t\tcout<<\"\\nWithdrawal successfully\";\n\t\t\tcout<<\"Total bal: \"<<tot;\n\t\t\t\n\t\t}\n\t\tvoid bal()\n\t\t{\n\t\t\t\tint epin;\n\t\t\tcout<<\"\\nEnter the PIN: \";\n\t\t\tcin>>epin;\n\t\t\tif()\n\t\t\t{\n\t\t\t\tcout<<\"\\nInvalid Pin\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//cout<<\"\\nName: \"<<name;\n\t\t\tcout<<\"\\nBalance: \"<<tot;\n\t\t}\n\t\tvoid chaPIN(){\n\t\t\tint epin,npin;\n\t\t\tcout<<\"\\nEnter the PIN: \";\n\t\t\tcin>>epin;\n\t\t\tif(epin!=pin)\n\t\t\t{\n\t\t\t\tcout<<\"\\nInvalid Pin\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcout<<\"\\nEnter the 4-digit pin number: \";\n\t\t\tcin>>npin;\n\t\t\tif(npin<1000 || npin>9999)\n\t\t\t{\n\t\t\t\tcout<<\"\\nInvalid pin. Enter 4-digit pin\";\n\t\t\t}\n\t\t\tpin=npin;\n\t\t\tcout<<\"\\nPIN changed successfully\";\n\t\t} \n};\nint main()\n{\n\tBank b;\n\tint choice;\n\twhile(1)\n\t{\n\t\tcout<<\"\\nWELCOME\";\n\t\tcout<<\"\\nEnter the option: \";\n\t\tcout<<\"\\n1.Enter details\";\n\t\tcout<<\"\\n2.deposit\";\n\t\tcout<<\"\\n3.withdraw\";\n\t\tcout<<\"\\n4.Balance enquiry\";\n\t\tcout<<\"\\n5.Change pin\";\n\t\tcin>>choice;\n\t\tswitch(choice)\n\t\t{\n\t\t\t;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tb.bal();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tb.chaPIN();\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\texit(1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcout<<\"\\nEnter the right option\";\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n",
    "#include \"art.h\"\n\n#include <iostream>\nusing namespace std;\n\n#include \"core/Input.h\"\n\n#include \"complex.h\"\n#include \"transform.h\"\n\nnamespace fft\n{\n\nart::art()\n{\n  uiRenderer = new Vision::ImGuiRenderer(m_DisplayWidth, m_DisplayHeight, m_DisplayScale);\n  renderer = new Vision::Renderer2D(m_DisplayWidth, m_DisplayHeight, m_DisplayScale);\n  camera = new Vision::OrthoCamera(m_DisplayWidth, m_DisplayHeight, 15.0f);\n}\n\nart::~art()\n{\n  delete uiRenderer;\n  delete renderer;\n  delete camera;\n}\n\nvoid art::OnUpdate(float timestep)\n{\n  glClearColor(0.1f, 0.2f, 0.1f, 1.0f);\n  glClear(GL_COLOR_BUFFER_BIT);\n\n  // camera\n  if (Vision::Input::KeyDown(SDL_SCANCODE_P))\n    camera->Update(timestep);\n\n  // render\n  renderer->Begin(camera);\n\n  // draw trace\n  for (int i = 0; i < static_cast<int>(tracePoints.size()) - 1; i++)\n  {\n    renderer->DrawLine(tracePoints[i], tracePoints[(i + 1)], glm::vec4(0.5f, 0.5f, 0.5f, 1.0f), 0.1f);\n  }\n  if (tracePoints.size() > 0)\n    renderer->DrawPoint(tracePoints.back(), glm::vec4(1.0f), 0.2f);\n\n  // show our points\n  for (int i = 0; i < positions.size(); i++)\n  {\n    renderer->DrawPoint(positions[i], glm::vec4(1.0f), 0.2f);\n  }\n\n  ShowFFT(freqs, SDL_GetTicks() * 2.0f * M_PI / 4000.0f, 0);\n  renderer->End();\n\n  // render ui\n  uiRenderer->Begin();\n  if (ImGui::Begin(\"Settings\"))\n  {\n    if (ImGui::Button(\"Clear Points (c)\") || Vision::Input::KeyPress(SDL_SCANCODE_C))\n    {\n      positions.clear();\n      freqs.clear();\n      tracePoints.clear();\n    }\n\n    if (ImGui::Button(\"Clear Trace (t)\") || Vision::Input::KeyPress(SDL_SCANCODE_T))\n    {\n      tracePoints.clear();\n    }\n\n    if (ImGui::Button(\"Stop DFT (d)\") || Vision::Input::KeyDown(SDL_SCANCODE_D))\n    {\n      freqs.clear();\n    }\n\n    if (ImGui::Button(\"Run DFT (space)\") || Vision::Input::KeyPress(SDL_SCANCODE_SPACE))\n    {\n      tracePoints.clear();\n      freqs = transform::dft(positions);\n    }\n  }\n  ImGui::End();\n  uiRenderer->End();\n\n  // add points\n  if (Vision::Input::MousePress(SDL_BUTTON_LEFT) && !Vision::Input::KeyDown(SDL_SCANCODE_P))\n    positions.push_back(camera->GetMouseInWorldSpace());\n}\n\nvoid art::OnResize()\n{\n  uiRenderer->Resize(m_DisplayWidth, m_DisplayHeight);\n  renderer->Resize(m_DisplayWidth, m_DisplayHeight);\n  camera->SetWindowSize(m_DisplayWidth, m_DisplayHeight);\n}\n\nvoid art::ShowFFT(std::vector<glm::vec2> &amps, float phase, std::size_t numberCircles)\n{\n  // 1) track our position in the complex plane as we add circles\n  glm::vec2 position = {0.0f, 0.0f};\n\n  // 2) determine how many circles to draw (if set 0, draw all)\n  int numFreqs = static_cast<int>(numberCircles ? glm::min(numberCircles, amps.size()) : amps.size());\n\n  // 3) iterate over all desired circles\n  for (int circle = 0; circle < numFreqs; circle++)\n  {\n    // 4) for each freq, determine the effect it has on our position (freq * e^i*phase*k)\n    int actualFreq = (circle % 2 == 0) ? circle / 2 : numFreqs - (circle+1) / 2;\n    float displayFreq = (circle % 2 == 0) ? circle / 2 : - (circle + 1) / 2;\n\n    glm::vec2 delta = complex::mult(amps[actualFreq], complex::exp(phase * displayFreq));\n    \n    // 5) calculate the new position\n    glm::vec2 newPos = position + delta;\n\n    // 6) draw a new circle using this information.\n    if (circle != 0) // don't draw the first circle\n    {\n      float radius = glm::length(delta);\n      renderer->DrawCircle(position, glm::vec4(1.0f), radius, 0.025f);\n      renderer->DrawLine(position, newPos, glm::vec4(1.0f), 0.05f);\n    }\n\n    // 7) update the position\n    position = newPos;\n  }\n\n  tracePoints.push_back(position);\n}\n\n}",
    "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <valarray>\n\n//Exercise1\nvoid PrintDynamicArray(std::vector<int> arr) {\n    std::cout << \"(\";\n\n    for (size_t i = 0; i < arr.size(); ++i) {\n        std::cout << arr[i];\n        if (i != arr.size() - 1) {\n            std::cout << \", \";\n        }\n    }\n\n    std::cout << \")\" << std::endl;\n}\n//Exercise2\nstd::vector<int> Fibonacci(unsigned int amount) {\n    std::vector<int> fibSeq;\n    if (amount == 0) {\n        return fibSeq;\n    }\n\n    fibSeq.push_back(0);\n    if (amount == 1) {\n        return fibSeq;\n    }\n\n    fibSeq.push_back(1);\n\n    for (unsigned int i = 2; i < amount; ++i) {\n        int nextFib = fibSeq[i - 1] + fibSeq[i - 2];\n        fibSeq.push_back(nextFib);\n    }\n\n    return fibSeq;\n}\n//Exercise3\nint Maximum(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return std::numeric_limits<int>::min();\n    }\n    int max = numbers[0];\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n    }\n\n    return max;\n}\n\n//Exercise4\nstruct Results\n{\n    float mean, median, variance, standardDeviation, min, max;\n};\n\nResults AnalyzeData(std::vector<float> data) {\n    Results results{};\n\n    if (data.empty()) {\n        results.mean = results.median = results.variance = results.standardDeviation = results.min = results.max = NAN;\n        return results;\n    }\n\n    float sum = 0.0f;\n    for (float value : data) {\n        sum += value;\n    }\n    results.mean = sum / data.size();\n\n    std::sort(data.begin(), data.end());\n    if (data.size() % 2 == 0) {\n        results.median = (data[data.size() / 2 - 1] + data[data.size() / 2]) / 2.0f;\n    } else {\n        results.median = data[data.size() / 2];\n    }\n\n    float mean = results.mean;\n    float variance = 0.0f;\n    for (float value : data) {\n        variance += (value - mean) * (value - mean);\n    }\n    results.variance = variance / data.size();\n\n    results.standardDeviation = std::sqrt(results.variance);\n\n    results.min = *std::min_element(data.begin(), data.end());\n    results.max = *std::max_element(data.begin(), data.end());\n\n    return results;\n}\nint main() {\n    //Exercise1\n    std::vector<int> test2 = {1, 2, 3, 4, 5};\n    std::cout << \"Exercise1\"<< std::endl;\n    PrintDynamicArray(test2);\n    std::cout << \"\"<< std::endl;\n\n\n    //Exercise2\n    std::cout << \"Exercise2\"<< std::endl;\n    unsigned int amount = 10;\n    std::vector<int> fibonacciSequence = Fibonacci(amount);\n\n    for (int num : fibonacciSequence) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"\"<< std::endl;\n\n\n    //Exercise3\n    std::cout << \"Exercise3\"<< std::endl;\n    std::vector<int> test3 = {-1, 2, 3, 4, -5};\n    int max = Maximum(test3);\n    std::cout << max << std::endl;\n    std::cout << \"\"<< std::endl;\n\n\n    //Exercise4\n    std::cout << \"Exercise4\"<< std::endl;\n    std::vector<float> test5 = {-1.5, 2.9, 3.9, 4.4, -5.5,7.7777,55.2};\n\n    Results results = AnalyzeData(test5);\n\n    std::cout << \"\\nResults:\\n\";\n    std::cout << \"Mean: \" << results.mean << std::endl;\n    std::cout << \"Median: \" << results.median << std::endl;\n    std::cout << \"Variance: \" << results.variance << std::endl;\n    std::cout << \"Standard Deviation: \" << results.standardDeviation << std::endl;\n    std::cout << \"Min: \" << results.min << std::endl;\n    std::cout << \"Max: \" << results.max << std::endl;\n\n    return 0;\n\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n * Copyright 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"BTAudioProviderSessionCodecsDB\"\n\n#include \"BluetoothAudioSupportedCodecsDB.h\"\n\n#include <android-base/logging.h>\n\nnamespace android {\nnamespace bluetooth {\nnamespace audio {\n\nusing ::android::hardware::bluetooth::audio::V2_0::AacObjectType;\nusing ::android::hardware::bluetooth::audio::V2_0::AacParameters;\nusing ::android::hardware::bluetooth::audio::V2_0::AacVariableBitRate;\nusing ::android::hardware::bluetooth::audio::V2_0::AptxParameters;\nusing ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;\nusing ::android::hardware::bluetooth::audio::V2_0::ChannelMode;\nusing ::android::hardware::bluetooth::audio::V2_0::CodecType;\nusing ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;\nusing ::android::hardware::bluetooth::audio::V2_0::LdacParameters;\nusing ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;\nusing ::android::hardware::bluetooth::audio::V2_0::SampleRate;\nusing ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;\nusing ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;\nusing ::android::hardware::bluetooth::audio::V2_0::SbcChannelMode;\nusing ::android::hardware::bluetooth::audio::V2_0::SbcNumSubbands;\nusing ::android::hardware::bluetooth::audio::V2_0::SbcParameters;\n\n// Default Supported PCM Parameters\nstatic const PcmParameters kDefaultSoftwarePcmCapabilities = {\n    .sampleRate = static_cast<SampleRate>(\n        SampleRate::RATE_44100 | SampleRate::RATE_48000 |\n        SampleRate::RATE_88200 | SampleRate::RATE_96000 |\n        SampleRate::RATE_16000 | SampleRate::RATE_24000),\n    .channelMode =\n        static_cast<ChannelMode>(ChannelMode::MONO | ChannelMode::STEREO),\n    .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |\n                                                BitsPerSample::BITS_24 |\n                                                BitsPerSample::BITS_32)};\n\n// Default Supported Codecs\n// SBC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(MONO|STEREO)\n//      all blocks | subbands 8 | Loudness\nstatic const SbcParameters kDefaultOffloadSbcCapability = {\n    .sampleRate = SampleRate::RATE_44100,\n    .channelMode = static_cast<SbcChannelMode>(SbcChannelMode::MONO |\n                                               SbcChannelMode::JOINT_STEREO),\n    .blockLength = static_cast<SbcBlockLength>(\n        SbcBlockLength::BLOCKS_4 | SbcBlockLength::BLOCKS_8 |\n        SbcBlockLength::BLOCKS_12 | SbcBlockLength::BLOCKS_16),\n    .numSubbands = SbcNumSubbands::SUBBAND_8,\n    .allocMethod = SbcAllocMethod::ALLOC_MD_L,\n    .bitsPerSample = BitsPerSample::BITS_16,\n    .minBitpool = 2,\n    .maxBitpool = 53};\n\n// AAC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(STEREO)\nstatic const AacParameters kDefaultOffloadAacCapability = {\n    .objectType = AacObjectType::MPEG2_LC,\n    .sampleRate = SampleRate::RATE_44100,\n    .channelMode = ChannelMode::STEREO,\n    .variableBitRateEnabled = AacVariableBitRate::ENABLED,\n    .bitsPerSample = BitsPerSample::BITS_16};\n\n// LDAC: mSampleRate:(44100|48000|88200|96000), mBitsPerSample:(16|24|32),\n//       mChannelMode:(DUAL|STEREO)\nstatic const LdacParameters kDefaultOffloadLdacCapability = {\n    .sampleRate = static_cast<SampleRate>(\n        SampleRate::RATE_44100 | SampleRate::RATE_48000 |\n        SampleRate::RATE_88200 | SampleRate::RATE_96000),\n    .channelMode = static_cast<LdacChannelMode>(LdacChannelMode::DUAL |\n                                                LdacChannelMode::STEREO),\n    .qualityIndex = LdacQualityIndex::QUALITY_HIGH,\n    .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |\n                                                BitsPerSample::BITS_24 |\n                                                BitsPerSample::BITS_32)};\n\n// aptX: mSampleRate:(44100|48000), mBitsPerSample:(16), mChannelMode:(STEREO)\nstatic const AptxParameters kDefaultOffloadAptxCapability = {\n    .sampleRate = static_cast<SampleRate>(SampleRate::RATE_44100 |\n                                          SampleRate::RATE_48000),\n    .channelMode = ChannelMode::STEREO,\n    .bitsPerSample = BitsPerSample::BITS_16,\n};\n\n// aptX HD: mSampleRate:(44100|48000), mBitsPerSample:(24),\n//          mChannelMode:(STEREO)\nstatic const AptxParameters kDefaultOffloadAptxHdCapability = {\n    .sampleRate = static_cast<SampleRate>(SampleRate::RATE_44100 |\n                                      ",
    "\ufeff#include <iostream>\n#include \"binarySearchTree.h\"\n\n#include <set>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n\nlong long generateRandLong() {\n\tlong long number = 0;\n\tint lengthNumber = rand() % 5 + 11;\n\tfor (int i = 0; i < lengthNumber; i++) {\n\t\tnumber = number * 10 + rand() % 10;\n\t}\n\treturn number;\n}\n\nbool testBinarySearchTree()\n{\n\tsrand(time(NULL));\n\tconst int iters = 30000;\n\tconst int keysAmount = iters * 2;\n\tconst int itersToRangeQueries = 1000;\n\tvector<Data> data(keysAmount);\n\tvector<Data> dataToInsert(iters);\n\tvector<Data> dataToErase(iters);\n\tvector<Data> dataToFind(iters);\n\tvector<pair<Data, Data>> dataToRangeQueries;\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tdataToInsert[i] = Data(generateRandLong() % keysAmount);\n\t\tdataToErase[i] = Data(generateRandLong() % keysAmount);\n\t\tdataToFind[i] = Data(generateRandLong() % keysAmount);\n\t}\n\tfor (int i = 0; i < itersToRangeQueries; i++)\n\t{\n\t\tData minData = Data();\n\t\tData maxData = Data();\n\t\tif (maxData < minData)\n\t\t{\n\t\t\tswap(minData, maxData);\n\t\t}\n\t\tdataToRangeQueries.push_back({ minData, maxData });\n\t}\n\tBinarySearchTree myTree;\n\tclock_t myStart = clock();\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tmyTree.insert(dataToInsert[i]);\n\t}\n\tint myInsertSize = myTree.size();\n\tint myTreeHeight = myTree.height();\n\tint optimalTreeHeight = log2(myInsertSize) + 1;\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tmyTree.erase(dataToErase[i]);\n\t}\n\tint myEraseSize = myInsertSize - myTree.size();\n\tint myFoundAmount = 0;\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tif (myTree.find(dataToFind[i]))\n\t\t{\n\t\t\tmyFoundAmount++;\n\t\t}\n\t}\n\tclock_t myEnd = clock();\n\tfloat myTime = (float(myEnd - myStart)) / CLOCKS_PER_SEC;\n\n\tset<Data> stlTree;\n\tclock_t stlStart = clock();\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tstlTree.insert(dataToInsert[i]);\n\t}\n\tint stlInsertSize = stlTree.size();\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tstlTree.erase(dataToErase[i]);\n\t}\n\tint stlEraseSize = stlInsertSize - stlTree.size();\n\tint stlFoundAmount = 0;\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tif (stlTree.find(dataToFind[i]) != stlTree.end())\n\t\t{\n\t\t\tstlFoundAmount++;\n\t\t}\n\t}\n\tclock_t stlEnd = clock();\n\tfloat stlTime = (float(stlEnd - stlStart)) / CLOCKS_PER_SEC;\n\tclock_t myRangeStart = clock();\n\tint myRangeFoundAmount = 0;\n\tfor (int i = 0; i < itersToRangeQueries; i++)\n\t{\n\t\tmyRangeFoundAmount += myTree.findInRange(dataToRangeQueries[i].first, dataToRangeQueries[i].second);\n\t}\n\tclock_t myRangeEnd = clock();\n\tfloat myRangeTime = (float(myRangeEnd - myRangeStart)) / CLOCKS_PER_SEC;\n\tclock_t stlRangeStart = clock();\n\tint stlRangeFoundAmount = 0;\n\tfor (int i = 0; i < itersToRangeQueries; i++)\n\t{\n\t\tconst auto& low = stlTree.lower_bound(dataToRangeQueries[i].first);\n\t\tconst auto& up = stlTree.upper_bound(dataToRangeQueries[i].second);\n\t\tstlRangeFoundAmount += distance(low, up);\n\t}\n\tclock_t stlRangeEnd = clock();\n\tfloat stlRangeTime = (float(stlRangeEnd - stlRangeStart)) / CLOCKS_PER_SEC;\n\tcout << \"My BinaryTree: height = \" << myTreeHeight << \", optimal height = \" <<  optimalTreeHeight << endl;\n\tcout << \"Time: \" << myTime << \", size: \" << myInsertSize << \" - \" << myEraseSize << \", found amount : \" << myFoundAmount << endl;\n\tcout << \"Range time: \" << myRangeTime << \", range found amount: \" << myRangeFoundAmount\t<< endl << endl;\n\tcout << \"STL Tree:\" << endl;\n\tcout << \"Time: \" << stlTime << \", size: \" << stlInsertSize << \" - \" << stlEraseSize << \", found amount: \" << stlFoundAmount << endl;\n\tcout << \"Range time: \" << stlRangeTime << \", range found amount: \" << stlRangeFoundAmount << endl << endl;\n\tif (myInsertSize == stlInsertSize && myEraseSize == stlEraseSize && myFoundAmount == stlFoundAmount && myRangeFoundAmount == stlRangeFoundAmount)\n\t{\n\t\tcout << \"The lab is completed\" << endl;\n\t\treturn true;\n\t}\n\tcerr << \":(\" << endl;\n\treturn false;\n}\n\nusing namespace std;\n\nint main()\n{\n\ttestBinarySearchTree();\n}\n",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <\"mbedtls/aes.h\">\r\n\r\nvoid encrypt(const unsigned char *input, const unsigned char *key, const unsigned char *iv, unsigned char *output, size_t length, int mode) {\r\n    mbedtls_aes_context aes_ctx;\r\n\r\n    mbedtls_aes_init(&aes_ctx);\r\n\r\n    mbedtls_aes_setkey_enc(&aes_ctx, key, 128);\r\n\r\n    if (mode == MBEDTLS_AES_ENCRYPT) {\r\n        mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, input, output);\r\n    } else {\r\n        mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_DECRYPT, input, output);\r\n    }\r\n\r\n    mbedtls_aes_free(&aes_ctx);\r\n}\r\n\r\nint main() {\r\n    const unsigned char key[16] = \"0123456789abcdef\";\r\n    const unsigned char iv[16] = \"1234567890123456\";\r\n    const unsigned char input[16] = \"Hello, Padding!\";\r\n    unsigned char encrypted_output[16];\r\n    unsigned char decrypted_output[16];\r\n\r\n    // ECB mode\r\n    encrypt(input, key, iv, encrypted_output, sizeof(input), MBEDTLS_AES_ENCRYPT);\r\n    encrypt(encrypted_output, key, iv, decrypted_output, sizeof(encrypted_output), MBEDTLS_AES_DECRYPT);\r\n    printf(\"ECB Original: %s\\n\", input);\r\n    printf(\"ECB Encrypted: \");\r\n    for (size_t i = 0; i < sizeof(input); i++) {\r\n        printf(\"%02x\", encrypted_output[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    printf(\"ECB Decrypted: %s\\n\", decrypted_output);\r\n\r\n    // CBC mode\r\n    encrypt(input, key, iv, encrypted_output, sizeof(input), MBEDTLS_AES_ENCRYPT);\r\n    encrypt(encrypted_output, key, iv, decrypted_output, sizeof(encrypted_output), MBEDTLS_AES_DECRYPT);\r\n    printf(\"\\nCBC Original: %s\\n\", input);\r\n    printf(\"CBC Encrypted: \");\r\n    for (size_t i = 0; i < sizeof(input); i++) {\r\n        printf(\"%02x\", encrypted_output[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    printf(\"CBC Decrypted: %s\\n\", decrypted_output);\r\n\r\n    // CFB mode\r\n    encrypt(input, key, iv, encrypted_output, sizeof(input), MBEDTLS_AES_ENCRYPT);\r\n    encrypt(encrypted_output, key, iv, decrypted_output, sizeof(encrypted_output), MBEDTLS_AES_DECRYPT);\r\n    printf(\"\\nCFB Original: %s\\n\", input);\r\n    printf(\"CFB Encrypted: \");\r\n    for (size_t i = 0; i < sizeof(input); i++) {\r\n        printf(\"%02x\", encrypted_output[i]);\r\n    }\r\n    printf(\"\\n\");\r\n    printf(\"CFB Decrypted: %s\\n\", decrypted_output);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <cstdlib>\n#include <cstdio>\n#include <chrono>\n#include <thread>\n#include <stdexcept>\n#include <cmath>\n#include <cfloat>\n#include \"sample_tester.h\"\n#define SLEEP std::this_thread::sleep_for(std::chrono::milliseconds(rand()%10));\n\nclass CTestData {\npublic:\n    APolygon m_Polygon;\n    double m_TriangMin;\n    const char *m_TriangCnt;\n};\n\n//=============================================================================================================================================================\nstd::initializer_list<CTestData> g_Data =\n        {\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{0,  0},\n                                                                          {10, 10},\n                                                                          {25, 10},\n                                                                          {40, 0}}),        114.095716037, \"2\"},\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{0,  0},\n                                                                          {0,  10},\n                                                                          {10, 10},\n                                                                          {10, 0}}),        54.1421356237, \"2\"},\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{0,  10},\n                                                                          {10, 20},\n                                                                          {20, 20},\n                                                                          {30, 10},\n                                                                          {20, 0},\n                                                                          {10, 0}}),        138.92922227,  \"14\"},\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{0,  0},\n                                                                          {5,  100},\n                                                                          {10, 0},\n                                                                          {5,  98}}),       398.504780189, \"1\"},\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{10000, 0},\n                                                                          {6544,  7561},\n                                                                          {2550,  9669},\n                                                                          {-5210, 8535},\n                                                                          {-9794, 2016},\n                                                                          {-7526, -6584},\n                                                                          {-5428, -8398},\n                                                                          {-1707, -9853},\n                                                                          {5817,  -8133},\n                                                                          {8256,  -5641}}), 153417.876879, \"1430\"},\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{2870,  -201},\n                                                                          {6334,  1403},\n                                                                          {2688,  -2184},\n                                                                          {1334,  -2207},\n                                                                          {2254,  -2782},\n                                                                          {-3498, -9044},\n                                                                          {415,   -3534},\n                                                                          {0,     0},\n                                                                          {0,     10000},\n                                                                          {10000, 5000}}),  84367.7711704, \"13\"},\n                {std::make_shared<CPolygon>(std::initializer_list<CPoint>{{-5054, 6201},\n                                                                          {7967,  6042},\n                                                                          {5285,  8488},\n                                                                          {-1139, 9934},\n                                                                          {-6318, 7751},\n                                                                          {-9411, 3380},\n                                                                          {-8098, -5866},\n                                                                          {-5497, -8353},\n                                                                          {2075,  -9782},\n                                                                          {7039,  -7102}}), 139509.911946, \"168\"},\n                {std::make_shared<CPolygon>(std::initializer_li",
    "/****************************************************************************\r\n** Meta object code from reading C++ file 'mainwindow.h'\r\n**\r\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.0)\r\n**\r\n** WARNING! All changes made in this file will be lost!\r\n*****************************************************************************/\r\n\r\n#include \"../../FoodOrderingSystem/mainwindow.h\"\r\n#include <QtCore/qmetatype.h>\r\n\r\n#if __has_include(<QtCore/qtmochelpers.h>)\r\n#include <QtCore/qtmochelpers.h>\r\n#else\r\nQT_BEGIN_MOC_NAMESPACE\r\n#endif\r\n\r\n\r\n#include <memory>\r\n\r\n#if !defined(Q_MOC_OUTPUT_REVISION)\r\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\r\n#elif Q_MOC_OUTPUT_REVISION != 68\r\n#error \"This file was generated using the moc from 6.5.0. It\"\r\n#error \"cannot be used with the include files from this version of Qt.\"\r\n#error \"(The moc has changed too much.)\"\r\n#endif\r\n\r\n#ifndef Q_CONSTINIT\r\n#define Q_CONSTINIT\r\n#endif\r\n\r\nQT_WARNING_PUSH\r\nQT_WARNING_DISABLE_DEPRECATED\r\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\r\nnamespace {\r\n\r\n#ifdef QT_MOC_HAS_STRINGDATA\r\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {};\r\nstatic constexpr auto qt_meta_stringdata_CLASSMainWindowENDCLASS = QtMocHelpers::stringData(\r\n    \"MainWindow\",\r\n    \"on_SignInButton_clicked\",\r\n    \"\"\r\n);\r\n#else  // !QT_MOC_HAS_STRING_DATA\r\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {\r\n    uint offsetsAndSizes[6];\r\n    char stringdata0[11];\r\n    char stringdata1[24];\r\n    char stringdata2[1];\r\n};\r\n#define QT_MOC_LITERAL(ofs, len) \\\r\n    uint(sizeof(qt_meta_stringdata_CLASSMainWindowENDCLASS_t::offsetsAndSizes) + ofs), len \r\nQ_CONSTINIT static const qt_meta_stringdata_CLASSMainWindowENDCLASS_t qt_meta_stringdata_CLASSMainWindowENDCLASS = {\r\n    {\r\n        QT_MOC_LITERAL(0, 10),  // \"MainWindow\"\r\n        QT_MOC_LITERAL(11, 23),  // \"on_SignInButton_clicked\"\r\n        QT_MOC_LITERAL(35, 0)   // \"\"\r\n    },\r\n    \"MainWindow\",\r\n    \"on_SignInButton_clicked\",\r\n    \"\"\r\n};\r\n#undef QT_MOC_LITERAL\r\n#endif // !QT_MOC_HAS_STRING_DATA\r\n} // unnamed namespace\r\n\r\nQ_CONSTINIT static const uint qt_meta_data_CLASSMainWindowENDCLASS[] = {\r\n\r\n // content:\r\n      11,       // revision\r\n       0,       // classname\r\n       0,    0, // classinfo\r\n       1,   14, // methods\r\n       0,    0, // properties\r\n       0,    0, // enums/sets\r\n       0,    0, // constructors\r\n       0,       // flags\r\n       0,       // signalCount\r\n\r\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\r\n       1,    0,   20,    2, 0x08,    1 /* Private */,\r\n\r\n // slots: parameters\r\n    QMetaType::Void,\r\n\r\n       0        // eod\r\n};\r\n\r\nQ_CONSTINIT const QMetaObject MainWindow::staticMetaObject = { {\r\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\r\n    qt_meta_stringdata_CLASSMainWindowENDCLASS.offsetsAndSizes,\r\n    qt_meta_data_CLASSMainWindowENDCLASS,\r\n    qt_static_metacall,\r\n    nullptr,\r\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMainWindowENDCLASS_t,\r\n        // Q_OBJECT / Q_GADGET\r\n        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,\r\n        // method 'on_SignInButton_clicked'\r\n        QtPrivate::TypeAndForceComplete<void, std::false_type>\r\n    >,\r\n    nullptr\r\n} };\r\n\r\nvoid MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\r\n{\r\n    if (_c == QMetaObject::InvokeMetaMethod) {\r\n        auto *_t = static_cast<MainWindow *>(_o);\r\n        (void)_t;\r\n        switch (_id) {\r\n        case 0: _t->on_SignInButton_clicked(); break;\r\n        default: ;\r\n        }\r\n    }\r\n    (void)_a;\r\n}\r\n\r\nconst QMetaObject *MainWindow::metaObject() const\r\n{\r\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\r\n}\r\n\r\nvoid *MainWindow::qt_metacast(const char *_clname)\r\n{\r\n    if (!_clname) return nullptr;\r\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSMainWindowENDCLASS.stringdata0))\r\n        return static_cast<void*>(this);\r\n    return QMainWindow::qt_metacast(_clname);\r\n}\r\n\r\nint MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\r\n{\r\n    _id = QMainWindow::qt_metacall(_c, _id, _a);\r\n    if (_id < 0)\r\n        return _id;\r\n    if (_c == QMetaObject::InvokeMetaMethod) {\r\n        if (_id < 1)\r\n            qt_static_metacall(this, _c, _id, _a);\r\n        _id -= 1;\r\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\r\n        if (_id < 1)\r\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\r\n        _id -= 1;\r\n    }\r\n    return _id;\r\n}\r\nQT_WARNING_POP\r\n",
    "#include <include/graph.h>\n\n// containers\n#include <set>\n#include <queue>\n\n// exceptions\n#include <stdexcept>\n\nnamespace graph_utils\n{\n\ngraph::graph(const graph_t& graph)\n{\n    set_graph(graph);\n}\n\nvoid graph::set_graph(const graph_t &graph) noexcept\n{\n    if (!graph.size())\n        return;\n    _graph = graph;\n}\n\ngraph_t graph::get_graph() const noexcept\n{\n    return _graph;\n}\n\npath_t graph::bfs(std::string_view start, std::string_view end)\n{\n    if (!_graph.size())\n        throw std::runtime_error(\"You should fill the graph first\");\n\n    std::queue<std::string> queue;\n    std::set<std::string> visited_nodes;\n    parent_t parents;\n\n    queue.push(start.data());\n    while (!queue.empty())\n    {\n        std::string &current_node = queue.front();\n        if (current_node == end)\n            return backtrace(parents, start, end);\n\n        // if current_node doesn't exist in visited_nodes\n        if (visited_nodes.find(current_node) == visited_nodes.end())\n        {\n            for (const auto& neighbor : _graph.at(current_node))\n            {\n                if (visited_nodes.find(neighbor) == visited_nodes.end())\n                {\n                    queue.push(neighbor);\n                    parents.insert({neighbor, current_node});\n                }\n            }\n\n            // add current_node to visited_nodes to avoid revisiting it (to prevent from loops)\n            visited_nodes.insert(current_node);\n\n        }\n        // poping current_node from the queue\n        queue.pop();\n    }\n\n    return { };\n}\n\npath_t graph::backtrace(const parent_t &relations, std::string_view start, std::string_view end)\n{\n    path_t final_path;\n\n    std::string node = end.data();\n    final_path.push_back(node);\n    for (std::string_view parent = relations.at(node); parent != start; node = parent, parent = relations.at(node))\n        final_path.push_back(parent.data());\n\n    final_path.push_back(start.data());\n    \n    // reverse the path and then return it (to be from start to end not reverse)\n    return {final_path.rbegin(), final_path.rend()};\n}\n\n} // namespace graph_utils",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Easing.h\"\n\n/* --- Sine --- */\nfloat EaseInSine(float t) {\n    return 1.0f - cosf((t * static_cast<float>(M_PI)) / 2.0f);\n}\n\nfloat EaseOutSine(float t) {\n    return sinf((t * static_cast<float>(M_PI)) / 2.0f);\n}\n\nfloat EaseInOutSine(float t) {\n    return -(cosf(static_cast<float>(M_PI) * t) - 1.0f) / 2.0f;\n}\n\n/* --- Quad --- */\nfloat EaseInQuad(float t) {\n    return t * t;\n}\n\nfloat EaseOutQuad(float t) {\n    return 1.0f - (1.0f - t) * (1.0f - t);\n}\n\nfloat EaseInOutQuad(float t) {\n    return t < 0.5f\n        ? 2.0f * t * t\n        : 1.0f - powf(-2.0f * t + 2.0f, 2.0f) / 2.0f;\n}\n\n/* --- Cubic --- */\nfloat EaseInCubic(float t) {\n    return t * t * t;\n}\n\nfloat EaseOutCubic(float t) {\n    return 1.0f - powf(1.0f - t, 3.0f);\n}\n\nfloat EaseInOutCubic(float t) {\n    return t < 0.5f\n        ? 4.0f * t * t * t\n        : 1.0f - powf(-2.0f * t + 2.0f, 3.0f) / 2.0f;\n}\n\n/* --- Quart --- */\nfloat EaseInQuart(float t) {\n    return t * t * t * t;\n}\n\nfloat EaseOutQuart(float t) {\n    return 1.0f - powf(1.0f - t, 4.0f);\n}\n\nfloat EaseInOutQuart(float t) {\n    return t < 0.5f\n        ? 8.0f * t * t * t * t\n        : 1.0f - powf(-2.0f * t + 2.0f, 4.0f) / 2.0f;\n}\n\n/* --- Quint --- */\nfloat EaseInQuint(float t) {\n    return t * t * t * t * t;\n}\n\nfloat EaseOutQuint(float t) {\n    return 1.0f - powf(1.0f - t, 5.0f);\n}\n\nfloat EaseInOutQuint(float t) {\n    return t < 0.5f\n        ? 16.0f * t * t * t * t * t\n        : 1.0f - powf(-2.0f * t + 2.0f, 5.0f) / 2.0f;\n}\n\n/* --- Expo --- */\nfloat EaseInExpo(float t) {\n    return t == 0.0f\n        ? 0.0f\n        : powf(2.0f, 10.0f * t - 10.0f);\n}\n\nfloat EaseOutExpo(float t) {\n    return t == 1.0f\n        ? 1.0f\n        : 1.0f - powf(2.0f, -10.0f * t);\n}\n\nfloat EaseInOutExpo(float t) {\n    return t == 0.0f\n        ? 0.0f\n        : t == 1.0f\n        ? 1.0f\n        : t < 0.5f\n        ? powf(2.0f, 20.0f * t - 10.0f) / 2.0f\n        : (2.0f - powf(2.0f, -20.0f * t + 10.0f)) / 2.0f;\n}\n\n/* --- Circ --- */\nfloat EaseInCirc(float t) {\n    return 1.0f - sqrtf(1.0f - powf(t, 2.0f));\n}\n\nfloat EaseOutCirc(float t) {\n    return sqrtf(1.0f - powf(t - 1.0f, 2.0f));\n}\n\nfloat EaseInOutCirc(float t) {\n    return t < 0.5f\n        ? (1.0f - sqrtf(1.0f - powf(2.0f * t, 2.0f))) / 2.0f\n        : (sqrtf(1.0f - powf(-2.0f * t + 2.0f, 2.0f)) + 1.0f) / 2.0f;\n}\n\n/* --- Back --- */\nfloat EaseInBack(float t) {\n    const float c1 = 1.70158f;\n    const float c2 = c1 + 1.0f;\n    return c2 * t * t * t - c1 * t * t;\n}\n\nfloat EaseOutBack(float t) {\n    const float c1 = 1.70158f;\n    const float c2 = c1 + 1.0f;\n    return 1.0f + c2 * powf(t - 1.0f, 3.0f) + c1 * powf(t - 1.0f, 2.0f);\n}\n\nfloat EaseInOutBack(float t) {\n    const float c1 = 1.70158f;\n    const float c3 = c1 * 1.525f;\n    return t < 0.5f\n        ? (powf(2.0f * t, 2.0f) * ((c3 + 1) * 2.0f * t - c3)) / 2.0f\n        : (powf(2.0f * t - 2.0f, 2.0f) * ((c3 + 1.0f) * (t * 2.0f - 2.0f) + c3) + 2.0f) / 2.0f;\n}\n\n/* --- Elastic --- */\nfloat EaseInElastic(float t) {\n    const float c4 = (2.0f * static_cast<float>(M_PI)) / 3.0f;\n    return t == 0.0f\n        ? 0.0f\n        : t == 1.0f\n        ? 1.0f\n        : -powf(2.0f, 10.0f * t - 10.0f) * sinf((t * 10.0f - 10.75f) * c4);\n}\n\nfloat EaseOutElastic(float t) {\n    const float c4 = (2.0f * static_cast<float>(M_PI)) / 3.0f;\n    return t == 0.0f\n        ? 0.0f\n        : t == 1.0f\n        ? 1.0f\n        : powf(2.0f, -10.0f * t) * sinf((t * 10.0f - 0.75f) * c4) + 1.0f;\n}\n\nfloat EaseInOutElastic(float t) {\n    const float c5 = (2.0f * static_cast<float>(M_PI)) / 4.5f;\n    return t == 0.0f\n        ? 0.0f\n        : t == 1.0f\n        ? 1.0f\n        : t < 0.5f\n        ? -(powf(2.0f, 20.0f * t - 10.0f) * sinf((20.0f * t - 11.125f) * c5)) / 2.0f\n        : (powf(2.0f, -20.0f * t + 10.0f) * sinf((20.0f * t - 11.125f) * c5)) / 2.0f + 1.0f;\n}\n\n/* --- Bounce --- */\nfloat EaseInBounce(float t) {\n    const float n1 = 7.5625f;\n    const float d1 = 2.75f;\n    float t2 = 0.0f;\n    float t3 = 0.0f;\n\n    t3 = (1.0f - t);\n\n    if (t3 < 1.0f / d1) {\n        return 1.0f - (n1 * t3 * t3);\n\n    } else if (t3 < 2.0f / d1) {\n        t2 = t3 - 1.5f / d1;\n        return 1.0f - (n1 * t2 * t2 + 0.75f);\n\n    } else if (t3 < 2.5f / d1) {\n        t2 = t3 - 2.25f / d1;\n        return 1.0f - (n1 * t2 * t2 + 0.9375f);\n\n    } else {\n        t2 = t3 - 2.625f / d1;\n        return 1.0f - (n1 * t2 * t2 + 0.984375f);\n    }\n}\n\nfloat EaseOutBounce(float t) {\n    const float n1 = 7.5625f;\n    const float d1 = 2.75f;\n    float t2 = 0.0f;\n\n    if (t < 1.0f / d1) {\n        return n1 * t * t;\n\n    } else if (t < 2.0f / d1) {\n        t2 = t - 1.5f / d1;\n        return n1 * t2 * t2 + 0.75f;\n\n    } else if (t < 2.5f / d1) {\n        t2 = t - 2.25f / d1;\n        return n1 * t2 * t2 + 0.9375f;\n\n    } else {\n        t2 = t - 2.625f / d1;\n        return n1 * t2 * t2 + 0.984375f;\n    }\n}\n\nfloat EaseInOutBounce(float t) {\n    const float n1 = 7.5625f;\n    const float d1 = 2.75f;\n    float t2 = 0.0f;\n    float t3 = 0.0f;\n\n    if (t < 0.5) {\n        t3 = (1.0f - t * 2.0f);\n\n        if (t3 < 1.",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n/*\n{ Sample program\n  in TINY language\n  compute factorial\n}\n\nread x; {input an integer}\nif 0<x then {compute only if x>=1}\n  fact:=1;\n  repeat\n    fact := fact * x;\n    x:=x-1\n  until x=0;\n  write fact {output factorial}\nend\n*/\n\n// sequence of statements separated by ;\n// no procedures - no declarations\n// all variables are integers\n// variables are declared simply by assigning values to them :=\n// if-statement: if (boolean) then [else] end\n// repeat-statement: repeat until (boolean)\n// boolean only in if and repeat conditions < = and two mathematical expressions\n// math expressions integers only, + - * / ^\n// I/O read write\n// Comments {}\n\n////////////////////////////////////////////////////////////////////////////////////\n// Strings /////////////////////////////////////////////////////////////////////////\n\nbool Equals(const char* a, const char* b)\n{\n    return strcmp(a, b)==0;\n}\n\nbool StartsWith(const char* a, const char* b)\n{\n    int nb=strlen(b);\n    return strncmp(a, b, nb)==0;\n}\n\nvoid Copy(char* a, const char* b, int n=0)\n{\n    if(n>0) {strncpy(a, b, n); a[n]=0;}\n    else strcpy(a, b);\n}\n\nvoid AllocateAndCopy(char** a, const char* b)\n{\n    if(b==0) {*a=0; return;}\n    int n=strlen(b);\n    *a=new char[n+1];\n    strcpy(*a, b);\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// Input and Output ////////////////////////////////////////////////////////////////\n\n#define MAX_LINE_LENGTH 10000\n\nstruct InFile\n{\n    FILE* file;\n    int cur_line_num;\n\n    char line_buf[MAX_LINE_LENGTH];\n    int cur_ind, cur_line_size;\n\n    InFile(const char* str) {file=0; if(str) file=fopen(str, \"r\"); cur_line_size=0; cur_ind=0; cur_line_num=0;}\n    ~InFile(){if(file) fclose(file);}\n\n    void SkipSpaces()\n    {\n        while(cur_ind<cur_line_size)\n        {\n            char ch=line_buf[cur_ind];\n            if(ch!=' ' && ch!='\\t' && ch!='\\r' && ch!='\\n') break;\n            cur_ind++;\n        }\n    }\n\n    bool SkipUpto(const char* str)\n    {\n        while(true)\n        {\n            SkipSpaces();\n            while(cur_ind>=cur_line_size) {if(!GetNewLine()) return false; SkipSpaces();}\n\n            if(StartsWith(&line_buf[cur_ind], str))\n            {\n                cur_ind+=strlen(str);\n                return true;\n            }\n            cur_ind++;\n        }\n        return false;\n    }\n\n    bool GetNewLine()\n    {\n        cur_ind=0; line_buf[0]=0;\n        if(!fgets(line_buf, MAX_LINE_LENGTH, file)) return false;\n        cur_line_size=strlen(line_buf);\n        if(cur_line_size==0) return false; // End of file\n        cur_line_num++;\n        return true;\n    }\n\n    char* GetNextTokenStr()\n    {\n        SkipSpaces();\n        while(cur_ind>=cur_line_size) {if(!GetNewLine()) return 0; SkipSpaces();}\n        return &line_buf[cur_ind];\n    }\n\n    void Advance(int num)\n    {\n        cur_ind+=num;\n    }\n};\n\nstruct OutFile\n{\n    FILE* file;\n    OutFile(const char* str) {file=0; if(str) file=fopen(str, \"w\");}\n    ~OutFile(){if(file) fclose(file);}\n\n    void Out(const char* s)\n    {\n        fprintf(file, \"%s\\n\", s); fflush(file);\n    }\n};\n\n////////////////////////////////////////////////////////////////////////////////////\n// Compiler Parameters /////////////////////////////////////////////////////////////\n\nstruct CompilerInfo\n{\n    InFile in_file;\n    OutFile out_file;\n    OutFile debug_file;\n\n    CompilerInfo(const char* in_str, const char* out_str, const char* debug_str)\n            : in_file(in_str), out_file(out_str), debug_file(debug_str)\n    {\n    }\n};\n\n////////////////////////////////////////////////////////////////////////////////////\n// Scanner /////////////////////////////////////////////////////////////////////////\n\n#define MAX_TOKEN_LEN 40\n\nenum TokenType{\n    IF, THEN, ELSE, END, REPEAT, UNTIL, READ, WRITE,\n    ASSIGN, EQUAL, LESS_THAN,\n    PLUS, MINUS, TIMES, DIVIDE, POWER,\n    SEMI_COLON,\n    LEFT_PAREN, RIGHT_PAREN,\n    LEFT_BRACE, RIGHT_BRACE,\n    ID, NUM,\n    ENDFILE, ERROR\n};\n\n// Used for debugging only /////////////////////////////////////////////////////////\nconst char* TokenTypeStr[]=\n        {\n                \"If\", \"Then\", \"Else\", \"End\", \"Repeat\", \"Until\", \"Read\", \"Write\",\n                \"Assign\", \"Equal\", \"LessThan\",\n                \"Plus\", \"Minus\", \"Times\", \"Divide\", \"Power\",\n                \"SemiColon\",\n                \"LeftParen\", \"RightParen\",\n                \"LeftBrace\", \"RightBrace\",\n                \"ID\", \"Num\",\n                \"EndFile\", \"Error\"\n        };\n\nstruct Token\n{\n    TokenType type;\n    char str[MAX_TOKEN_LEN+1];\n\n    Token(){str[0]=0; type=ERROR;}\n    Token(TokenType _type, const char* _str) {type=_type; Copy(str, _str);}\n};\n\nconst Token reserved_words[]=\n        {\n                Token(IF, \"if\"),\n                Token(THEN, \"then\"),\n                Token(ELSE, \"else\"),\n                Token(END, \"end\"),\n                Token(REPEAT, \"repeat\"),\n                Token(UNTIL, \"unti",
    "\ufeff#include \"Country.h\"\n#include \"CountryDatabase.h\"\n#include <iostream>\n#include <string>\n\nint main() {\n    Country* countries = new Country[10];\n    int size = 0;\n    int capacity = 10;\n    int choice;\n\n    do {\n        std::cout << \"\\nCountry Database Menu:\\n\";\n        std::cout << \"1. Add country\\n\";\n        std::cout << \"2. Remove country\\n\";\n        std::cout << \"3. Edit country\\n\";\n        std::cout << \"4. Search country\\n\";\n        std::cout << \"5. Print all countries\\n\";\n        std::cout << \"6. Save to file\\n\";\n        std::cout << \"7. Load from file\\n\";\n        std::cout << \"8. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n        std::cin.ignore(); // Clear the input buffer\n\n        switch (choice) {\n        case 1:\n            std::cout << \"Enter id,name,capital,population,area\";\n            CountryDatabase::addCountry(countries, size, capacity);\n            break;\n        case 2: {\n            int id;\n            std::cout << \"Enter the ID of the country to remove: \";\n            std::cin >> id;\n            CountryDatabase::removeCountry(countries, size, id);\n            break;\n        }\n        case 3: {\n            int id;\n            std::cout << \"Enter the ID of the country to edit: \";\n            std::cin >> id;\n            CountryDatabase::editCountry(countries, size, id);\n            break;\n        }\n        case 4: {\n            std::string name;\n            std::cout << \"Enter the name of the country to search: \";\n            std::getline(std::cin, name);\n            CountryDatabase::searchCountry(countries, size, name);\n            break;\n        }\n        case 5:\n            CountryDatabase::printCountries(countries, size);\n            break;\n        case 6: {\n            std::string filename;\n            std::cout << \"Enter the filename to save to: \";\n            std::getline(std::cin, filename);\n            CountryDatabase::saveToFile(countries, size, filename);\n            break;\n        }\n        case 7: {\n            std::string filename;\n            std::cout << \"Enter the filename to load from: \";\n            std::getline(std::cin, filename);\n            CountryDatabase::loadFromFile(countries, size, capacity, filename);\n            break;\n        }\n        case 8:\n            std::cout << \"Exiting the program.\\n\";\n            break;\n        default:\n            std::cout << \"Invalid choice. Please try again.\\n\";\n        }\n    } while (choice != 8);\n\n    delete[] countries;\n    return 0;\n}",
    "#include \"iostream\"\n#include \"string\"\n#include <fstream>\nusing namespace std;\n\n\nconst unsigned char examsAmount = 3;\nconst unsigned char testsAmount = 5;\nint studentsAmount = 0;\nconst unsigned char studentsArrayLen = 60;\nconst unsigned char dishesArrayLen = 60;\nconst unsigned char groupArrayLen = 30;\n\n\nstruct Student{\n    string fullName;\n    string gender;\n    int group;\n    int id = 0;\n    int exams[examsAmount];\n    int tests[testsAmount];\n    float averageGrade;\n};\n\n\n//main funcs;\n\nvoid clearStream() {\n    cin.clear();\n    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n\nvoid showMenu(){\n    cout << \"1. add new student\\n\";\n    cout << \"2. edit student info\\n\";\n    cout << \"3. show students\\n\";\n    cout << \"4. show students in group\\n\";\n    cout << \"5. show top 3 student\\n\";\n    cout << \"6. show students amount by gender\\n\";\n    cout << \"7. show students's grades info\\n\";\n    cout << \"8. show Ks' students\\n\";\n    cout << \"9. add students to file\\n\\n\";\n    cout << \"IDZ\\n\";\n    cout << \"10. show canteen menu\\n\";\n    cout << \"11. top 3 best dishes\\n\";\n    cout << \"12. price less then you choose\\n\";\n    cout << \"13. make an order\\n\";\n    cout << \"14. add dish\\n\";\n}\n\n\n\n// declarations\nvoid addStudentToArray(Student student, Student *students);\nint countStudents(Student *students);\nint showStudentsByGroup(int groupNum, Student *students, Student *group);\nbool isNormalGender(string gender);\nint countStudents(Student *students);\nfloat avg( int *exams, int *tests);\nStudent findStudent(int group, int id, Student *students);\n\n// STUDENTS--------------------------------------------------------------------------------------------\n\nbool isNormalGender(string gender){\n    if ( gender == \"M\" || gender == \"F\"){\n        return true;\n    }\n    return false;\n}\n\nint countStudents(Student *students){\n    studentsAmount = 0;\n    for (int i = 0; i < studentsArrayLen; i++){\n        if (!(students + i)->fullName.empty()){\n            studentsAmount ++;\n        }\n    }\n    return studentsAmount;\n}\n\n\nfloat avg( int *exams, int *tests){\n    float sum = 0;\n    float res = 0;\n    for (int i = 0; i < examsAmount; i++){\n        sum += float(*(exams + i));\n    }\n    for (int i = 0; i < testsAmount; i++){\n        sum += float(*(tests + i));\n    }\n    res=sum/(examsAmount+testsAmount);\n    return (res);\n}\n\n\nStudent findStudent(int group, int id, Student *students){\n    studentsAmount = countStudents(students);\n    for (int i = 0; i < studentsAmount; i++ ){\n        if ( (( students + i )->group == group) &&  (( students + i )->id == id) ) {\n            return *( students + i );\n        }\n    }\n    return Student();\n}\n\n\nvoid showStudentInfo(Student student){\n    cout << \"fullname: \" << student.fullName <<\"\\n\";\n    cout << \"group: \" << student.group <<\"\\n\";\n    cout << \"id: \" << student.id <<\"\\n\";\n    cout << \"gender: \" << student.gender <<\"\\n\";\n    cout << \"Exams: \\n\";\n    for ( int i = 0; i < examsAmount; i ++ ){\n        cout << student.exams[i] << \" \";\n    }\n\n    cout << \"tests: \\n\";\n    for ( int i = 0; i < testsAmount; i ++ ){\n        cout << student.tests[i] << \" \";\n    }\n\n    cout << \"avg Grade: \" << student.averageGrade;\n    cout << \"\\n\";\n}\n\n\nStudent* getAddress(int group, int id, Student *students){\n\n    for (int i = 0; i < countStudents(students); i++){\n\n        if ((students + i)->id == id && (students + i)->group == group){\n            return (students + i);\n        }\n    }\n    return nullptr;\n}\n\n\nvoid editStudent(Student *student, string parametr){ //#2\n    string genderParam;\n\n    if ( parametr == \"fullname\" ){\n        cout << \"enter new data: \"; getline(cin, student->fullName);\n\n    }else if( parametr == \"gender\" ){\n        cout << \"enter new data: \"; cin >> genderParam; clearStream();\n        if ( isNormalGender(genderParam) ){\n            student->gender = genderParam;\n        }else{\n            cout << \"unidentified gender, select M or F\";\n        }\n\n    }else if( parametr == \"group\" ){\n        cout << \"enter new data: \"; cin >> student->group; clearStream();\n\n    }else if( parametr == \"id\" ){\n        cout << \"enter new data: \"; cin >> student->id; clearStream();\n\n\n    }else if( parametr == \"exams marks\" ){\n        cout << \"enter new data: \";\n        for ( int i = 0; i < examsAmount; i++){\n            cin >> student->exams[i];\n        }\n        clearStream();\n        student->averageGrade = avg(student->exams, student->tests);\n\n    }else if( parametr == \"tests marks\" ){\n        cout << \"enter new data: \";\n        for ( int i = 0; i < testsAmount; i++){\n            cin >> student->tests[i];\n        }\n        clearStream();\n        student->averageGrade = avg(student->exams, student->tests);\n\n    }else{\n        cout << \"this parameter does not exist\";\n    }\n}\n\n\n\nvoid addStudents2File(Student *students){\n    ofstream out;\n    out.open(\"/Users/sofiatimosenko/Desktop/studentsList.txt\");\n    if (out.is_open())\n    {\n        for ( int i = 0; i < countStudents(students); i++ ){\n            out << (students + i)->ful",
    "#include <cstdio>\r\n#include <cstdint>\r\n#include <limits>\r\n#include <GL/glew.h>\r\n#include <GLFW/glfw3.h>\r\n\r\nbool game_running = false;\r\nint move_dir = 0;\r\nbool fire_pressed = 0;\r\n\r\n#define GL_ERROR_CASE(glerror)\\\r\n    case glerror: snprintf(error, sizeof(error), \"%s\", #glerror)\r\n\r\ninline void gl_debug(const char *file, int line) {\r\n    GLenum err;\r\n    while((err = glGetError()) != GL_NO_ERROR){\r\n        char error[128];\r\n\r\n        switch(err) {\r\n            GL_ERROR_CASE(GL_INVALID_ENUM); break;\r\n            GL_ERROR_CASE(GL_INVALID_VALUE); break;\r\n            GL_ERROR_CASE(GL_INVALID_OPERATION); break;\r\n            GL_ERROR_CASE(GL_INVALID_FRAMEBUFFER_OPERATION); break;\r\n            GL_ERROR_CASE(GL_OUT_OF_MEMORY); break;\r\n            default: snprintf(error, sizeof(error), \"%s\", \"UNKNOWN_ERROR\"); break;\r\n        }\r\n\r\n        fprintf(stderr, \"%s - %s: %d\\n\", error, file, line);\r\n    }\r\n}\r\n\r\n#undef GL_ERROR_CASE\r\n\r\nvoid validate_shader(GLuint shader, const char *file = 0){\r\n    static const unsigned int BUFFER_SIZE = 512;\r\n    char buffer[BUFFER_SIZE];\r\n    GLsizei length = 0;\r\n\r\n    glGetShaderInfoLog(shader, BUFFER_SIZE, &length, buffer);\r\n\r\n    if(length>0){\r\n        printf(\"Shader %d(%s) compile error: %s\\n\", shader, (file? file: \"\"), buffer);\r\n    }\r\n}\r\n\r\nbool validate_program(GLuint program){\r\n    static const GLsizei BUFFER_SIZE = 512;\r\n    GLchar buffer[BUFFER_SIZE];\r\n    GLsizei length = 0;\r\n\r\n    glGetProgramInfoLog(program, BUFFER_SIZE, &length, buffer);\r\n\r\n    if(length>0){\r\n        printf(\"Program %d link error: %s\\n\", program, buffer);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nvoid error_callback(int error, const char* description)\r\n{\r\n    fprintf(stderr, \"Error: %s\\n\", description);\r\n}\r\n\r\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){\r\n    switch(key){\r\n    case GLFW_KEY_ESCAPE:\r\n        if(action == GLFW_PRESS) game_running = false;\r\n        break;\r\n    case GLFW_KEY_RIGHT:\r\n        if(action == GLFW_PRESS) move_dir += 1;\r\n        else if(action == GLFW_RELEASE) move_dir -= 1;\r\n        break;\r\n    case GLFW_KEY_LEFT:\r\n        if(action == GLFW_PRESS) move_dir -= 1;\r\n        else if(action == GLFW_RELEASE) move_dir += 1;\r\n        break;\r\n    case GLFW_KEY_SPACE:\r\n        if(action == GLFW_RELEASE) fire_pressed = true;\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\n}\r\n\r\n/* Algorithm \"xor\" from p. 4 of Marsaglia, \"Xorshift RNGs\" */\r\nuint32_t xorshift32(uint32_t* rng)\r\n{\r\n    uint32_t x = *rng;\r\n    x ^= x << 13;\r\n    x ^= x >> 17;\r\n    x ^= x << 5;\r\n    *rng = x;\r\n    return x;\r\n}\r\n\r\ndouble random(uint32_t* rng)\r\n{\r\n    return (double)xorshift32(rng) / std::numeric_limits<uint32_t>::max();\r\n}\r\n\r\nstruct Buffer\r\n{\r\n    size_t width, height;\r\n    uint32_t* data;\r\n};\r\n\r\nstruct Sprite\r\n{\r\n    size_t width, height;\r\n    uint8_t* data;\r\n};\r\n\r\nstruct Alien\r\n{\r\n    size_t x, y;\r\n    uint8_t type;\r\n};\r\n\r\nstruct Bullet\r\n{\r\n    size_t x, y;\r\n    int dir;\r\n};\r\n\r\nstruct Player\r\n{\r\n    size_t x, y;\r\n    size_t life;\r\n};\r\n\r\n#define GAME_MAX_BULLETS 128\r\n\r\nstruct Game\r\n{\r\n    size_t width, height;\r\n    size_t num_aliens;\r\n    size_t num_bullets;\r\n    Alien* aliens;\r\n    Player player;\r\n    Bullet bullets[GAME_MAX_BULLETS];\r\n};\r\n\r\nstruct SpriteAnimation\r\n{\r\n    bool loop;\r\n    size_t num_frames;\r\n    size_t frame_duration;\r\n    size_t time;\r\n    Sprite** frames;\r\n};\r\n\r\nenum AlienType: uint8_t\r\n{\r\n    ALIEN_DEAD   = 0,\r\n    ALIEN_TYPE_A = 1,\r\n    ALIEN_TYPE_B = 2,\r\n    ALIEN_TYPE_C = 3\r\n};\r\n\r\nvoid buffer_clear(Buffer* buffer, uint32_t color)\r\n{\r\n    for(size_t i = 0; i < buffer->width * buffer->height; ++i)\r\n    {\r\n        buffer->data[i] = color;\r\n    }\r\n}\r\n\r\nbool sprite_overlap_check(\r\n    const Sprite& sp_a, size_t x_a, size_t y_a,\r\n    const Sprite& sp_b, size_t x_b, size_t y_b\r\n)\r\n{\r\n    // NOTE: For simplicity we just check for overlap of the sprite\r\n    // rectangles. Instead, if the rectangles overlap, we should\r\n    // further check if any pixel of sprite A overlap with any of\r\n    // sprite B.\r\n    if(x_a < x_b + sp_b.width && x_a + sp_a.width > x_b &&\r\n       y_a < y_b + sp_b.height && y_a + sp_a.height > y_b)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid buffer_draw_sprite(Buffer* buffer, const Sprite& sprite, size_t x, size_t y, uint32_t color)\r\n{\r\n    for(size_t xi = 0; xi < sprite.width; ++xi)\r\n    {\r\n        for(size_t yi = 0; yi < sprite.height; ++yi)\r\n        {\r\n            if(sprite.data[yi * sprite.width + xi] &&\r\n               (sprite.height - 1 + y - yi) < buffer->height &&\r\n               (x + xi) < buffer->width)\r\n            {\r\n                buffer->data[(sprite.height - 1 + y - yi) * buffer->width + (x + xi)] = color;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid buffer_draw_number(\r\n    Buffer* buffer,\r\n    const Sprite& number_spritesheet, size_t number,\r\n    size_t x, size_t y,\r\n    uint32_t color)\r\n{\r\n    uint8_t digits[64];\r\n    size_t num_digits = 0;\r\n\r\n    size_t current_number = number;\r\n    do\r\n    ",
    "#include <iostream>\n#include <math.h>\n#include <iomanip>\n\n/*\n    [] declarar variable tipo string Para el dia de la semana;\n    [] declarar variable tipo int para la comparacion de dia de la semana con su numero;\n    [] configurar el ingreso de dato del usuario;\n    [] con una condicion asignarle a la variable del numero del dia el valor segun corresponda;\n    [] con un switch comparae el valor guardado en la variable tipo int\n    [] mostrar resultado segun comparacion;\n\n\n*/\n\n\nusing namespace std;\n\nstring Dia;\n\n\n\nint main(){\n    cout << \"Dia de la semana: \";\n    cin >> Dia;\n    int Ndia;\n        if (Dia==\"Lunes\" || Dia==\"lunes\"){\n\n        Ndia=1;\n\n    } else if(Dia==\"Martes\" || Dia==\"mertes\"){\n\n        Ndia=2;\n    } else if (Dia==\"Miercoles\"|| Dia==\"miercoles\"){\n\n\n        Ndia=3;\n    } else if (Dia==\"Jueves\" || Dia==\"jueves\"){\n\n\n        Ndia=4;\n    } else if (Dia==\"Viernes\"|| Dia==\"viernes\"){\n\n\n\n        Ndia=5;\n    } else if (Dia==\"Sabado\" || Dia==\"sabado\"){\n\n\n        Ndia=6;\n    } else {\n\n        Ndia=7;\n    }\n    switch (Ndia){\n\ncase 4:\n        cout<<\"Hoy es jueves tenes programaacion a las 14hs\";\n\n    break;\n\n\ncase 5:\n    cout << \"Hoy es viernes, Tenes progamacion aa las 14hs\";\n    break;\n\ndefault:\n    cout << \"Hoy es \" << Dia << \" Safamos de programaci\u00f3n\";\n    break;\n\n}\n\nreturn 0;\n}\n\n\n\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct RBT {\r\n    int key;\r\n    int color; //merah bervalue 1, hitam bervalue 0\r\n\r\n    struct RBT* left;\r\n    struct RBT* right;\r\n    struct RBT* parent;\r\n};\r\n\r\n//fungsi untuk membuat node\r\nstruct RBT* createNode(int key) {\r\n    struct RBT* newNode = (struct RBT*)malloc(sizeof(struct RBT));\r\n    newNode->key = key;\r\n    newNode->color = 1; //selalu berwarna merah (angka 1) saat pertama kali dibuat\r\n    \r\n    //pointer diset ke NULL semua\r\n    newNode->parent = NULL;\r\n    newNode->left = NULL;\r\n    newNode->right = NULL;\r\n    //mengembalikan alamat dari node yang telah dibuat\r\n    return newNode;\r\n}\r\n\r\n//fungsi untuk melakukan left rotation\r\nstruct RBT* leftRotation(struct RBT* root, struct RBT* node) {\r\n    struct RBT* rightNode = node->right; //anak kanan dari node saat ini akan disimpan dalam rightNode\r\n    node->right = rightNode->left; // anak kanan dari node akan menyimpan anak kiri dari rightNode\r\n    \r\n\t//jika anak kiri dari rightNode tidak kosong, maka akan dihubungkan dengan parentnya\r\n\tif (rightNode->left != NULL) {\r\n        rightNode->left->parent = node;\r\n    }\r\n    \r\n    //lalu menghubungkan rightNode dengan parent dari node\r\n    rightNode->parent = node->parent;\r\n    \r\n    if (node->parent == NULL) {\r\n        root = rightNode; //jika jika parent dari node kosong, artinya node sekarang adalah root, maka rightNode yang akan menjadi root baru\r\n    } else if (node == node->parent->left) {\r\n        node->parent->left = rightNode; //jika node saat ini merupakan anak kiri dari parent, maka dapat mengubah anak kiri parent menjadi rightNode\r\n    } else {\r\n        node->parent->right = rightNode;//jika node kini adalah anak kanan dari parent, maka mengubah anak kanan parent menjadi rightNode\r\n    }\r\n    //kondisi saat ini berarti rightNode sekarang merupakan parent dari node, sehingga kita menghubungkan node->parent ke rightNode, dan anak kiri rightNode menjadi node\r\n    rightNode->left = node;\r\n    node->parent = rightNode;\r\n    \r\n    //kemudian mengembalikan kembali alamat root untuk mengupdate rootnya\r\n    return root;\r\n}\r\n\r\n//fungsi untuk melakukan right rotation\r\nstruct RBT* rightRotation(struct RBT* root, struct RBT* node) {\r\n    struct RBT* leftNode = node->left; //anak kiri dari node disimpan dalam leftNode\r\n    node->left = leftNode->right; //anak kanan dari leftNode akan menjadi anak kiri dari node\r\n    \r\n    //jika anak kanan dari leftNode tidak kosong, anak kanan leftNode akan dihubungkan ke parent baru yaitu node\r\n    if (leftNode->right != NULL) {\r\n    \tleftNode->right->parent = node;\r\n    }\r\n    \r\n    //menguhubungkan leftNode dengan parent dari node\r\n    leftNode->parent = node->parent;\r\n    \r\n    if (node->parent == NULL) {\r\n        root = leftNode; //jika parent node kosong, maka leftNode akan menjadi root baru\r\n    } else if (node == node->parent->left) {\r\n        node->parent->left = leftNode; //jika node berada di posisi anak kiri dari parent, maka leftNode yang akan menggantikannya\r\n    } else {\r\n        node->parent->right = leftNode; //jika node berada di posisi anak kanan parent, maka leftNode akan menjadi anak kanan baru dari parent\r\n    }\r\n    \r\n    //sekarang leftNode manjadi parent dari node, sehingga diperlukan update sebagai berikut\r\n    leftNode->right = node; //node menjadi anak kanan dari leftNode\r\n    node->parent = leftNode; //parent dari node adalah leftNode\r\n    \r\n    //mengupdate root\r\n    return root;\r\n}\r\n\r\n//fungsi untuk mengupdate tree, sehingga warna dan tree tidak memiliki violation sama sekali\r\nstruct RBT* update(struct RBT* root, struct RBT* node) {\r\n\t//akan mengulang proses jika node masih memiliki parent yang berwarna merah\r\n    while (node->parent != NULL && node->parent->color == 1) {\r\n    \t//mengisi node uncle dengan mengecek apakah uncle tersebut merupakan anak kiri atau kanan dari grandparent (node->parent->parent)\r\n    \tstruct RBT* uncle = (node->parent->parent->right == node->parent)? node->parent->parent->left : node->parent->parent->right;\r\n    \t//jika node saat ini memiliki uncle dan unclenya berwarna merah, maka hanya perlu mengupdate warna saja\r\n    \tif (uncle != NULL && uncle->color == 1) {\r\n            node->parent->color = 0;\r\n            uncle->color = 0;\r\n            node->parent->parent->color = 1;\r\n            //grandparent akan menjadi node terbaru untuk menghilangkan violation yang masih ada\r\n            node = node->parent->parent;\r\n        } \r\n        //jika parent node saat ini adalah anak kiri dari grandparent\r\n\t\telse if (node->parent == node->parent->parent->left) {\r\n\t\t\t//dan jika node berada di anak kanan parent, hal ini menjadi left righ case dan membutuhkan double rotation\r\n            if (node == node->parent->right) {\r\n                node = node->parent;\r\n                root = leftRotation(root, node);\r\n            }\r\n            //selanjutnya adalah left left case dengan melakukan rotasi dan mewarnai node untuk menghilangkan violation\r\n            node->parent->color = 0;\r\n       ",
    "#include \"steamVR.h\"\n#include <string>\n#include <algorithm>\n\nbool setActiveJSON(std::string relativeFilePath)\n{\n\tvr::EVRInputError iError = vr::VRInputError_None;\n\tstd::string fullManifestPath;\n\tbool retVal = true;\n\n\t//----\n\t// Gets the current exe path, strips the file name and\n\t// adds the relative file path\n\t//----\n\tchar tPath[MAX_PATH];\n\tint bytes = GetModuleFileName(NULL, tPath, MAX_PATH);\n\tif (bytes == 0) {\n\t\tretVal = false;\n\t}\n\telse {\n\t\tstd::string exePath(tPath);\n\t\tstd::replace(exePath.begin(), exePath.end(), '\\\\', '/');\n\t\tint pos = exePath.rfind('/') + 1;\n\t\tif (pos > -1) {\n\t\t\texePath.erase(pos);\n\t\t\tfullManifestPath = exePath + relativeFilePath;\n\t\t\tif (GetFileAttributes(fullManifestPath.c_str()) == INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tretVal = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tretVal = false;\n\t\t}\n\t}\n\n\tif (retVal) {\n\t\tif (fullManifestPath.length() > 0) {\n\t\t\tiError = vr::VRInput()->SetActionManifestPath(fullManifestPath.c_str());\n\t\t}\n\t}\n\treturn retVal;\n}\n\nbool setActionHandlesGame(inputController* input)\n{\n\tvr::EVRInputError iError = vr::VRInputError_None;\n\n\tiError = vr::VRInput()->GetActionSetHandle(\"/actions/game\", &input->game.setHandle);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/movement\", &input->game.movement);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/rotate\", &input->game.rotate);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/lefthand\", &input->game.lefthand);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/lefthandpalm\", &input->game.lefthandpalm);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/righthand\", &input->game.righthand);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/righthandpalm\", &input->game.righthandpalm);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/button_y\", &input->game.button_y);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/button_x\", &input->game.button_x);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/button_a\", &input->game.button_a);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/button_b\", &input->game.button_b);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/left_trigger\", &input->game.left_trigger);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/left_bumper\", &input->game.left_bumper);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/left_stick_click\", &input->game.left_stick_click);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/left_anim\", &input->game.left_anim);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/right_trigger\", &input->game.right_trigger);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/right_bumper\", &input->game.right_bumper);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/right_stick_click\", &input->game.right_stick_click);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/right_anim\", &input->game.right_anim);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/menu_start\", &input->game.menu_start);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/in/menu_select\", &input->game.menu_select);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/out/haptic_left\", &input->game.haptic_left);\n\tiError = vr::VRInput()->GetActionHandle(\"/actions/game/out/haptic_right\", &input->game.haptic_right);\n\n\treturn true;\n}\n",
    "#include\"facerecognizer.h\"\n\nusing namespace cv;\nusing namespace std;\nusing namespace Ort;\n\nFaceEmbdding::FaceEmbdding(string model_path)\n{\n    /// OrtStatus* status = OrtSessionOptionsAppendExecutionProvider_CUDA(sessionOptions, 0);   ///\u5982\u679c\u4f7f\u7528cuda\u52a0\u901f\uff0c\u9700\u8981\u53d6\u6d88\u6ce8\u91ca\n\n    sessionOptions.SetGraphOptimizationLevel(ORT_ENABLE_BASIC);\n    /// std::wstring widestr = std::wstring(model_path.begin(), model_path.end());  ////windows\u5199\u6cd5\n    /// ort_session = new Session(env, widestr.c_str(), sessionOptions); ////windows\u5199\u6cd5\n    ort_session = new Session(env, model_path.c_str(), sessionOptions); ////linux\u5199\u6cd5\n\n    size_t numInputNodes = ort_session->GetInputCount();\n    size_t numOutputNodes = ort_session->GetOutputCount();\n    AllocatorWithDefaultOptions allocator;\n    for (int i = 0; i < numInputNodes; i++)\n    {\n        input_names.push_back(ort_session->GetInputName(i, allocator)); /// \u4f4e\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        ////AllocatedStringPtr input_name_Ptr = ort_session->GetInputNameAllocated(i, allocator);  /// \u9ad8\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        ////input_names.push_back(input_name_Ptr.get()); /// \u9ad8\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        Ort::TypeInfo input_type_info = ort_session->GetInputTypeInfo(i);\n        auto input_tensor_info = input_type_info.GetTensorTypeAndShapeInfo();\n        auto input_dims = input_tensor_info.GetShape();\n        input_node_dims.push_back(input_dims);\n    }\n    for (int i = 0; i < numOutputNodes; i++)\n    {\n        output_names.push_back(ort_session->GetOutputName(i, allocator)); /// \u4f4e\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        ////AllocatedStringPtr output_name_Ptr= ort_session->GetInputNameAllocated(i, allocator);\n        ////output_names.push_back(output_name_Ptr.get()); /// \u9ad8\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        Ort::TypeInfo output_type_info = ort_session->GetOutputTypeInfo(i);\n        auto output_tensor_info = output_type_info.GetTensorTypeAndShapeInfo();\n        auto output_dims = output_tensor_info.GetShape();\n        output_node_dims.push_back(output_dims);\n    }\n\n    this->input_height = input_node_dims[0][2];\n    this->input_width = input_node_dims[0][3];\n    ////\u5728\u8fd9\u91cc\u5c31\u76f4\u63a5\u5b9a\u4e49\u4e86\uff0c\u6ca1\u6709\u50cfpython\u7a0b\u5e8f\u91cc\u7684\u90a3\u6837normed_template = TEMPLATES.get(template) * crop_size\n    this->normed_template.emplace_back(Point2f(38.29459984, 51.69630032));\n    this->normed_template.emplace_back(Point2f(73.53180016, 51.50140016));\n    this->normed_template.emplace_back(Point2f(56.0252,     71.73660032));\n    this->normed_template.emplace_back(Point2f(41.54929968, 92.36549952));\n    this->normed_template.emplace_back(Point2f(70.72989952, 92.20409968));\n}\n\nvoid FaceEmbdding::preprocess(Mat srcimg, const vector<Point2f> face_landmark_5)\n{\n    Mat crop_img;\n    warp_face_by_face_landmark_5(srcimg, crop_img, face_landmark_5, this->normed_template, Size(112, 112));\n    /*vector<uchar> inliers(face_landmark_5.size(), 0);\n    Mat affine_matrix = cv::estimateAffinePartial2D(face_landmark_5, this->normed_template, cv::noArray(), cv::RANSAC, 100.0);\n    Mat crop_img;\n    Size crop_size(112, 112);\n    warpAffine(srcimg, crop_img, affine_matrix, crop_size, cv::INTER_AREA, cv::BORDER_REPLICATE);*/\n\n    vector<cv::Mat> bgrChannels(3);\n    split(crop_img, bgrChannels);\n    for (int c = 0; c < 3; c++)\n    {\n        bgrChannels[c].convertTo(bgrChannels[c], CV_32FC1, 1 / 127.5, -1.0);\n    }\n\n    const int image_area = this->input_height * this->input_width;\n    this->input_image.resize(3 * image_area);\n    size_t single_chn_size = image_area * sizeof(float);\n    memcpy(this->input_image.data(), (float *)bgrChannels[2].data, single_chn_size);\n    memcpy(this->input_image.data() + image_area, (float *)bgrChannels[1].data, single_chn_size);\n    memcpy(this->input_image.data() + image_area * 2, (float *)bgrChannels[0].data, single_chn_size);\n}\n\nvector<float> FaceEmbdding::detect(Mat srcimg, const vector<Point2f> face_landmark_5)\n{\n    this->preprocess(srcimg, face_landmark_5);\n\n    std::vector<int64_t> input_img_shape = {1, 3, this->input_height, this->input_width};\n    Value input_tensor_ = Value::CreateTensor<float>(memory_info_handler, this->input_image.data(), this->input_image.size(), input_img_shape.data(), input_img_shape.size());\n\n    Ort::RunOptions runOptions;\n    vector<Value> ort_outputs = this->ort_session->Run(runOptions, this->input_names.data(), &input_tensor_, 1, this->output_names.data(), output_names.size());\n\n    float *pdata = ort_outputs[0].GetTensorMutableData<float>(); /// \u5f62\u72b6\u662f(1, 512)\n    const int len_feature = ort_outputs[0].GetTensorTypeAndShapeInfo().GetShape()[1];\n    vector<float> embedding(len_feature);\n    memcpy(embedding.data(), pdata, len_feature*sizeof(float));\n    return embedding;\n}",
    "// Copyright \u00a9 2024 Yury Popov (@djphoenix).\n\n#include <nanobind/nanobind.h>\n#include <nanobind/stl/variant.h>\n\n#include \"ctc_loss/ctc_loss.h\"\n\nnamespace nb = nanobind;\nusing namespace nb::literals;\n\nusing namespace mlx::core;\n\nNB_MODULE(_ext, m) {\n    m.doc() = \"C++ and metal extensions for MLX CTC Loss\";\n\n    m.def(\n        \"ctc_loss\",\n        &ctc_loss,\n        \"log_probs\"_a,\n        \"targets\"_a,\n        \"input_lengths\"_a,\n        \"target_lengths\"_a,\n        nb::kw_only(),\n        \"blank\"_a = int(0),\n        \"stream\"_a = nb::none(),\n        R\"(\n        The Connectionist Temporal Classification loss\n\n        Calculates loss between a continuous (unsegmented) time series and a target sequence. CTCLoss sums over the\n        probability of possible alignments of input to target, producing a loss value which is differentiable\n        with respect to each input node. The alignment of input to target is assumed to be \"many-to-one\", which\n        limits the length of the target sequence such that it must be <= the input length.\n\n        Args:\n            log_probs (array):\n                The logarithmized probabilities of the outputs (e.g. obtained with `mlx::core::log_softmax`)\n                of size `(T, N, C)`, where\n                `T = input length`, `N = batch size`, and\n                `C = number of classes` (including blank)\n\n            targets (array):\n                Target sequences of size `(N, S)`, where\n                `N = batch size` and `S = max target length`.\n                Each element in the target sequence is a class index.\n                Target index cannot be blank (default=0).\n                Targets are padded to the length of the longest sequence, and stacked.\n\n            input_lengths (array):\n                Lengths of the inputs of size `(N)`, where `N = batch size` (must each be <= `T`).\n                Lengths are specified for each sequence to achieve masking under the assumption that\n                sequences are padded to equal lengths.\n\n            input_lengths (array):\n                Lengths of the targets of size `(N)`, where `N = batch size` (must each be <= `S`).\n                Lengths are specified for each sequence to achieve masking under the assumption that\n                sequences are padded to equal lengths.\n\n            blank (int):\n                blank label. Default `0`.\n\n        Returns:\n            array: `(N)`, where `N = batch size`\n        )\"\n    );\n}\n",
    "#include \"bunit.hpp\"\n\nnamespace BUnit {\n\nstatic inline const char *GetBranchWhetherHintCompleterStr(uint8_t v) {\n    if (v > 3) {\n        return \"\";\n    }\n    return (const char *[]){\".sptk\", \".spnt\", \".dptk\", \".dpnt\"}[v];\n}\nstatic inline const char *GetSequentialPrefetchHintCompleterStr(uint8_t v) {\n    if (v > 1) {\n        return \"\";\n    }\n    return (const char *[]){\".few\", \".many\"}[v];\n}\nstatic inline const char *GetBranchCacheDeallocHintCompleterStr(uint8_t v) {\n    if (v > 1) {\n        return \"\";\n    }\n    return (const char *[]){\"\", \".clr\"}[v];\n}\n\nDECLINST(UnimplInst) {\n    fprintf(stderr, \"unimpl branch op=%d\\n\", format->common.op);\n    cpu->halt = true;\n}\nDECLINST(UnimplInstOp4) {\n    fprintf(stderr, \"unimpl branch op=4 btype=%d\\n\", format->b1.btype);\n    cpu->halt = true;\n}\n\n\n// op = 4 //\n\nDECLINST(BrCond) {\n    uint64_t tempIP = AlignIP(cpu->regs.ip + SignExt(((format->b1.s << 20) | format->b1.imm20b) << 4, 25));\n    \n    printf(\"(qp %d) br.cond%s%s%s 0x%lx\\n\", format->b1.qp, \n        GetBranchWhetherHintCompleterStr(format->b1.wh),\n        GetSequentialPrefetchHintCompleterStr(format->b1.p),\n        GetBranchCacheDeallocHintCompleterStr(format->b1.d),\n        tempIP\n        );\n    if (cpu->regs.pr[format->b1.qp].val) {\n        cpu->branched = true;\n        cpu->regs.ip = tempIP;\n        if ((cpu->regs.psr.it && cpu->UnimplementedVirtualAddress(tempIP)) ||\n            (!cpu->regs.psr.it && cpu->UnimplementedVirtualAddress(tempIP))) {\n            cpu->UnimplementedInstructionAddressTrap(0, tempIP);\n        }\n        if (cpu->regs.psr.tb) {\n            cpu->TakenBranchTrap();\n        }\n    }\n}\n\nDECLINST(IPRelBrType) {\n    static HandleFn op4handle[8] = {\n        BrCond,        UnimplInstOp4, UnimplInstOp4, UnimplInstOp4,\n        UnimplInstOp4, UnimplInstOp4, UnimplInstOp4, UnimplInstOp4,\n    };\n\n    op4handle[format->b1.btype](format, cpu);\n}\n\n// 4.5 page 324\n//                  [op]\nHandleFn handletable[8] = {\n    UnimplInst,  UnimplInst, UnimplInst, UnimplInst, \n    IPRelBrType, UnimplInst, UnimplInst, UnimplInst,\n};\n\n\n} // BUnit\n",
    "#include \"traversability_mapping/System.hpp\"\n// check pose of 0th frame continously.\n// mutex for localmaps's gridmap.\n\nnamespace traversability_mapping\n{\n\n    System::System()\n    {\n        std::cout << \"Called traversability system constructor\" << std::endl;\n        pointCloudBuffer_ = std::make_shared<PointCloudBuffer>();\n        keyFrameUpdateQueue_ = std::make_shared<UpdateQueue>();\n    }\n\n    void System::addNewKeyFrame(const double timestamp,\n                                long unsigned int kfID,\n                                long unsigned int mapID,\n                                sensor_msgs::msg::PointCloud2 &sensorPointCloud)\n    {\n        // std::cout << \"traversability_mapping::System::addNewKeyFrame with id: \" << kfID << \" and ts: \" << timestamp << std::endl;\n        // Add the keyframe to the local map\n        if (localMapsSet_.find(mapID) != localMapsSet_.end())\n        {\n            if (allKeyFramesSet_.find(kfID) == allKeyFramesSet_.end())\n            {\n                allKeyFramesSet_[kfID] = mapID;\n                localMapsSet_[mapID]->addNewKeyFrame(timestamp, kfID, sensorPointCloud, mapID);\n                // std::cout << \"ADDING KEYFRAME TO MAP!!!!\" << mapID << std::endl;\n                if (localMapsSet_[mapID] != localMap_)\n                    setCurrentMap(mapID);\n            }\n            else\n            {\n                std::cout << \"They keyframe with this ID: \" << kfID << \" has already been added. Not adding again\" << std::endl;\n            }\n        }\n        else\n        {\n            std::cout << \"Local Map not initialized. Not adding the keyframe.\" << std::endl;\n        }\n        // std::cout << \"Added new KeyFrame with ID: \" << kfID << std::endl;\n    }\n\n    void System::addNewKeyFrame(const double timestamp,\n                                long unsigned int kfID,\n                                long unsigned int mapID)\n    {\n        sensor_msgs::msg::PointCloud2 sensorPointCloud = pointCloudBuffer_->getClosestPointCloud(timestamp);\n        // std::cout << \"Got closest pointcloud for: \" << kfID << std::endl;\n        auto pcl_sec = sensorPointCloud.header.stamp.sec + (sensorPointCloud.header.stamp.nanosec * pow(10, -9));\n        // std::cout << \"Difference in closest pcl ts is: \" << timestamp - pcl_sec << std::endl;\n        addNewKeyFrame(timestamp, kfID, mapID, sensorPointCloud);\n\n        /**\n        //test\n        std::cout << \"Testing ADD\" << std::endl;\n        unsigned long long sec = static_cast<unsigned long long>(std::floor(timestamp));\n        unsigned long long nanosec = static_cast<unsigned long long>((timestamp - sec) * pow(10, 9));\n        addNewKeyFrame(sec + nanosec, static_cast<int>(kfID), mapID);\n        */\n    }\n\n    void System::addNewKeyFrame(const unsigned long long timestamp,\n                                int kfID,\n                                long unsigned int mapID)\n    {\n        const unsigned long long timestampSecond = timestamp / 1e9;\n        const unsigned long long timestampNanoSec = timestamp % (unsigned long long)1e9;\n        double timestampDouble = timestampSecond * 1e9 + timestampNanoSec;\n        if (kfID < 0)\n        {\n            std::string errorMsg = \"The given KF ID was negative. Please make sure the keyFrame IDs are positive. KF ID: \" + std::to_string(kfID);\n            throw std::runtime_error(errorMsg);\n        }\n        long unsigned int kfIDlong = static_cast<long unsigned int>(kfID);\n\n        sensor_msgs::msg::PointCloud2 sensorPointCloud = pointCloudBuffer_->getClosestPointCloud(timestampDouble);\n        // std::cout << \"Got closest pointcloud for: \" << kfID << std::endl;\n        // auto pcl_sec = sensorPointCloud.header.stamp.sec + (sensorPointCloud.header.stamp.nanosec * pow(10, -9));\n        // std::cout << \"Difference in closest pcl ts is: \" << timestamp - pcl_sec << std::endl;\n        addNewKeyFrame(timestampDouble, kfIDlong, mapID, sensorPointCloud);\n    }\n\n    void System::addNewKeyFrame(const unsigned long long timestamp,\n                                int kfID,\n                                long unsigned int mapID,\n                                sensor_msgs::msg::PointCloud2 sensorPointCloud)\n    {\n        const unsigned long long timestampSecond = timestamp / 1e9;\n        const unsigned long long timestampNanoSec = timestamp % (unsigned long long)1e9;\n        double timestampDouble = timestampSecond * 1e9 + timestampNanoSec;\n        if (kfID < 0)\n        {\n            std::string errorMsg = \"The given KF ID was negative. Please make sure the keyFrame IDs are positive. KF ID: \" + std::to_string(kfID);\n            throw std::runtime_error(errorMsg);\n        }\n        long unsigned int kfIDlong = static_cast<long unsigned int>(kfID);\n        addNewKeyFrame(timestampDouble, kfIDlong, mapID, sensorPointCloud);\n    }\n\n    void System::updateKeyFrame(long unsigned int kfID,\n                                Sophus::SE3f &poseSLAM)\n    {\n        // std::cout << \"traversability_mapping::System::updateKeyFrame with id",
    "\n\n#include \"Include/command/command.h\"\n#include \"Include/transport/packager.hpp\"\n#include \"Include/transport/connector.hpp\"\n#include \"Include/helper/base.hpp\"\n\nenum class Commands\n{\n\n    SLEEP = 11,\n    SOCKET = 2540,\n    SHELL = 1,\n    EXIT = 99,\n\n};\n\nint CodeShell = 1;\nint CodeFS = 2;\nint CodeSleep = 3;\nint CodeProcList = 4;\n\nconst int SessionType = 0x7;\nconst int SessionNewSession = 0x1;\nconst int SessionRemove = 0x2;\nconst int SessionSendCommand = 0x3;\nconst int SessionReceiveCommand = 0x4;\n#define CodeSendCommnad 1\n\nvoid CommandExecute::ProcList(QString TaskID, bool FromProcessManager)\n{\n}\n\nauto NewPackageCommand(const QString &TeamserverName, Body_t Body) -> void\n{\n    auto Package = new _Package;\n    auto Head = Head_t{\n        .Event = SessionType,\n        .User = Teamserver->User.toStdString(),\n        .Time = QTime::currentTime().toString(\"hh:mm:ss\").toStdString(),\n    };\n\n    Package->Head = Head;\n    Package->Body = Body;\n    Connect->SendPackage(Package);\n    qDebug(\"Sending Commnad ->\");\n\n    delete Package;\n\n}\n\n\nvoid CommandExecute::InitialiseBody(QString TaskID, CommandsCode CommandID, Body_t &Body)\n{\n    QJsonObject Info;\n    Info.insert(\"TaskID\", TaskID);\n    Info.insert(\"TargetID\", this->CommandsInstance->Target->TargetData->ID);\n    Info.insert(\"CommandID\", QString::number(static_cast<int>(CommandID)));\n\n    Body.SubEvent = CodeSendCommnad;\n    Body.Info = Info;\n}\n\nvoid CommandExecute::ProcModule(QString TaskID, int SubCommand, QString Args)\n{\n    qDebug(\"in Execute.ProcModule\");\n    qDebug(\"%s\", qPrintable(TaskID));\n    qDebug(\"%s\", qPrintable(this->CommandsInstance->Target->TargetData->ID));\n    qDebug(\"%s\", qPrintable(QString::number(static_cast<int>(CommandsCode::SHELL))));\n    qDebug(\"%s\", qPrintable(QString::number(SubCommand)));\n    qDebug(\"%s\", qPrintable(Args));\n\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::SHELL, Body);\n\n    Body.Info.insert(\"Args\", Args);\n    Body.Info.insert(\"ProcCommand\", QString::number(SubCommand));\n\n    qDebug(\"Body.SubEvent %d\", static_cast<int>(Body.SubEvent));\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\n\nvoid CommandExecute::Sleep(QString TaskID, QString seconds)\n{\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::SLEEP, Body);\n    qDebug(\"seconds: %s\", qPrintable(seconds));\n\n    Body.Info.insert(\"Args\", seconds);\n\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\n\nvoid CommandExecute::ShellcodeInject(QString TaskID, QString TargetPID, QString Path)\n{\n    auto Content = FileRead(Path);\n    if (Content.isEmpty()){\n\n        return;\n}\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::INJECT_SHELLCODE, Body);\n\n    Body.Info.insert(\"Binary\", QString::fromUtf8(Content.toBase64()));\n    Body.Info.insert(\"PID\", TargetPID);\n\n\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\nvoid CommandExecute::ProxyStart(QString TaskID, QString CallBackHostName, QString AgentConnectPort, QString ProxyListenerPort)\n{\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::PROXY_START, Body);\n\n    // Directly setting the values in the QJsonObject\n    Body.Info.insert(\"CallBackHostName\", CallBackHostName);\n    Body.Info.insert(\"AgentConnectPort\", AgentConnectPort);\n    Body.Info.insert(\"ProxyListenerPort\", ProxyListenerPort);\n\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\n\nvoid CommandExecute::ProxyStop(QString TaskID, QString CallBackHostName, QString AgentConnectPort, QString ProxyListenerPort)\n{\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::PROXY_STOP, Body);\n\n    // Inserting the proxy details directly into the QJsonObject\n    Body.Info.insert(\"CallBackHostName\", CallBackHostName);\n    Body.Info.insert(\"AgentConnectPort\", AgentConnectPort);\n    Body.Info.insert(\"ProxyListenerPort\", ProxyListenerPort);\n\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\nvoid CommandExecute::AddCallBackDomain(QString TaskID, QString CallBackDomain)\n{\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::ADD_DOMAIN, Body);\n\n    // Using QJsonObject to insert the callback domain directly\n    Body.Info.insert(\"CallBackDomain\", CallBackDomain);\n\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\nvoid CommandExecute::DeleteCallBackDomain(QString TaskID, QString CallBackDomain)\n{\n    Body_t Body;\n    InitialiseBody(TaskID, CommandsCode::DELETE_DOMAIN, Body);\n\n    Body.Info.insert(\"CallBackDomain\", CallBackDomain);\n\n    NewPackageCommand(Teamserver->User, Body);\n}\n\n\nvoid CommandExecute::ListCallBackDomain(QString TaskID)\n{\n\n    Body_t Body = {0};\n    InitialiseBody(TaskID, CommandsCode::LIST_DOMAIN, Body);\n    NewPackageCommand(Teamserver->User, Body);\n\n\n}\n\nvoid CommandExecute::SelfKill(QString TaskID)\n{\n\n    Body_t Body = {0};\n    InitialiseBody(TaskID, CommandsCode::SELF_KILL, Body);\n    NewPackageCommand(Teamserver->User, Body);\n\n\n}\n\n\nvoid CommandExecute::SelfWipe(QString TaskID)\n{\n\n    Body_t Body = {0};\n    InitialiseBody(TaskID, CommandsCode::SELF_WIPE, Body);\n    NewPackageCommand(Teamserver->User, Body);\n\n\n}\n\nvoid CommandExecute::Se",
    "/**\n *\n * This file is part of patchLib.\n * \n * patchLib is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * patchLib is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with patchLib.  If not, see <http://www.gnu.org/licenses/>.\n * \n *******************************************************************************************\n */\n\n//******************************************************************************************\n// patchLib - Win32 Example\n//\n// This is an example using patchLib v3 with Win32 controls.\n// This file does not contain any actual patching code or examples!\n//******************************************************************************************\n\n#include <Windows.h>\n#include \"resource.h\"\n\n#include \"../../patchLibv3/patchLib.h\"\n#include \"../../patchLibv3/include/CMusic.h\"\n#include \"../../patchLibv3/include/CWindow.h\"\n#include \"../../patchLibv3/include/CScroller.h\"\n\n// Scroller Message\nstd::string g_vScrollerMessage = \\\n\t\"This is an example Keygen application template! Enter a name and a serial will auto-gen as you type!\";\n\n// Editbox Handles\nHWND g_vNameHwnd\t= NULL;\nHWND g_vSerialHwnd\t= NULL;\n\n// Original Window Proc\nWNDPROC g_vOrigWndProc = NULL;\n\n\n/**\n * DoMusicFunction\n *\n * Toggles the music for the application.\n */\nbool __stdcall DoMusicFunction( CChild* pChild )\n{\n\tUNREFERENCED_PARAMETER( pChild );\n\n\tCPatchLib::instance()->GetMusicObject()->Pause();\n\treturn 0;\n}\n\n/**\n * DoCopyFunction\n *\n * Called when the copy button is pressed.\n */\nbool __stdcall DoCopyFunction( CChild* pChild )\n{\n\tUNREFERENCED_PARAMETER( pChild );\n\n\t// Open clipboard and empty it.\n\tif( !OpenClipboard( CPatchLib::instance()->GetWindowObject()->GetHwnd() ) )\n\t\treturn 0;\n\tEmptyClipboard();\n\n\t// Get serial text length.\n\tint nLength = GetWindowTextLength( g_vSerialHwnd );\n\tif( nLength == 0 ) return 0;\n\n\t// Create handle for clipboard copy.\n\tHGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, ( nLength + 1 ) * sizeof( TCHAR ) );\n\tif( !hGlobal )\n\t{\n\t\tCloseClipboard();\n\t\treturn 0;\n\t}\n\n\t// Get serial text.\n\tchar* pszSerial = new char[ nLength + 1 ];\n\tGetWindowText( g_vSerialHwnd, pszSerial, nLength + 1 );\n\n\t// Copy to global memory.\n\tLPVOID lpLockPtr = GlobalLock( hGlobal );\n\tmemcpy( lpLockPtr, pszSerial, nLength * sizeof( TCHAR ) );\n\tGlobalUnlock( hGlobal );\n\n\t// Set clipboard data.\n\tSetClipboardData( CF_TEXT, hGlobal );\n\n\t// Cleanup..\n\tCloseClipboard();\n\tdelete pszSerial;\n\t\n\treturn 0;\n}\n\n/**\n * DoExitFunction\n *\n * Called when the exit button is pressed.\n */\nbool __stdcall DoExitFunction( CChild* pChild )\n{\n\tUNREFERENCED_PARAMETER( pChild );\n\n\tSendMessage( CPatchLib::instance()->GetWindowObject()->GetHwnd(), WM_CLOSE, 0, 0 );\n\treturn 0;\n}\n\n/**\n *\n * Serial Generation Example\n * \n * The serials produced by this generation example are not\n * valid for any software. This is simply for show.\n *\n */\nbool DoSerial( void )\n{\n\t// Get name text size.\n\tint nNameLength = GetWindowTextLength( g_vNameHwnd );\n\n\t// Name must be at least 6 chars long.\n\tif( nNameLength < 6 )\n\t{\n\t\tSetWindowText( g_vSerialHwnd, \"Name must be at least 6 chars long!\" );\n\t\treturn false;\n\t}\n\n\t// Generate (fake) serial code.\n\tchar szAlphaNumeric[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\";\n\tstd::string strSerial = \"AAAA\";\n\n\tfor( int x = 0; x < nNameLength; x++ )\n\t{\n\t\tint nRandPos = rand() % ( sizeof( szAlphaNumeric ) - 1 );\n\t\tstrSerial += szAlphaNumeric[ nRandPos ];\n\t}\n\n\tSetWindowText( g_vSerialHwnd, strSerial.c_str() );\n\n\treturn true;\n}\n\n/**\n *\n * Win32 Subclass Example (Name box window proc.)\n *\n * Handles auto-generation of serials when the edit control\n * has text written to it.\n *\n */\nLRESULT CALLBACK NameEditCallback( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\n{\n\t// Pass messages through and listen for WM_CHAR..\n\tLRESULT lResult = CallWindowProc( g_vOrigWndProc, hWnd, uMsg, wParam, lParam );\n\n\t// Generate serial from new name.\n\tif( uMsg == WM_CHAR )\n\t\tDoSerial();\n\n\treturn lResult;\n}\n\n\n/**\n *\n * WinMain - Entry point..\n *\n */\nint __stdcall WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd )\n{\n\tUNREFERENCED_PARAMETER( hPrevInstance );\n\tUNREFERENCED_PARAMETER( lpCmdLine );\n\tUNREFERENCED_PARAMETER( nShowCmd );\n\n\tboost::shared_ptr< CPatchLib > patchLib = CPatchLib::instance();\n\n\t// Attach application instance.\n\tpatchLib->AttachApplication( hInstance );\n\n\t// Initialize patchLib.\n\tif( patchLib->Initialize( IDR_TEMPLATE, NULL ) )\n\t{\n\t\t// Set our scroller message.\n\t\t( ( CScroller*) patchLib->GetWindowObject()->GetChild( \"scrollTest1\" ) )->SetText( g_vScrolle",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"trt_logger.hpp\"\n#include \"NvInfer.h\"\n#include <cstdlib>\n\nusing namespace std;\n\nnamespace logger {\n\nLevel Logger::m_level = Level::INFO;\n\nLogger::Logger(Level level) {\n    m_level = level;\n    m_severity = get_severity(level);\n}\n\nLogger::Severity Logger::get_severity(Level level) {\n    switch (level) {\n        case Level::FATAL: return Severity::kINTERNAL_ERROR;\n        case Level::ERROR: return Severity::kERROR;\n        case Level::WARN:  return Severity::kWARNING;\n        case Level::INFO:  return Severity::kINFO;\n        case Level::VERB:  return Severity::kVERBOSE;\n        default:           return Severity::kVERBOSE;\n    }\n}\n\nLevel Logger::get_level(Severity severity) {\n    string str;\n    switch (severity) {\n        case Severity::kINTERNAL_ERROR: return Level::FATAL;\n        case Severity::kERROR:          return Level::ERROR;\n        case Severity::kWARNING:        return Level::WARN;\n        case Severity::kINFO:           return Level::INFO;\n        case Severity::kVERBOSE:        return Level::VERB;\n    }\n}\n\nvoid Logger::log (Severity severity, const char* msg) noexcept{\n    if (severity <= get_severity(Level::WARN)\n        || m_level >= Level::DEBUG)\n        __log_info(get_level(severity), \"%s\", msg);\n}\n\nvoid Logger::__log_info(Level level, const char* format, ...) {\n    char msg[1000];\n    va_list args;\n    va_start(args, format);\n    int n = 0;\n    \n    switch (level) {\n        case Level::DEBUG: n += snprintf(msg + n, sizeof(msg) - n, DGREEN \"[debug]\" CLEAR); break;\n        case Level::VERB:  n += snprintf(msg + n, sizeof(msg) - n, PURPLE \"[verb]\" CLEAR); break;\n        case Level::INFO:  n += snprintf(msg + n, sizeof(msg) - n, YELLOW \"[info]\" CLEAR); break;\n        case Level::WARN:  n += snprintf(msg + n, sizeof(msg) - n, BLUE \"[warn]\" CLEAR); break;\n        case Level::ERROR: n += snprintf(msg + n, sizeof(msg) - n, RED \"[error]\" CLEAR); break;\n        default:           n += snprintf(msg + n, sizeof(msg) - n, RED \"[fatal]\" CLEAR); break;\n    }\n\n    n += vsnprintf(msg + n, sizeof(msg) - n, format, args);\n\n    va_end(args);\n\n    if (level <= m_level) \n        fprintf(stdout, \"%s\\n\", msg);\n\n    if (level <= Level::ERROR) {\n        fflush(stdout);\n        exit(0);\n    }\n}\n\nshared_ptr<Logger> create_logger(Level level) {\n    return make_shared<Logger>(level);\n}\n\n} //->namespace logger\n",
    "#include \"schemasystem.h\"\n#include \"utils.hpp\"\n#include <cstring>\n\nvoid CSchemaSystemTypeScope::FindDeclaredClass(SchemaClassInfoData_t*& pClassInfo, const char* pszClassName)\n{\n#if defined _WIN32 && _M_X64\n    CallVFunc<void, 2, SchemaClassInfoData_t*&, const char*>(this, pClassInfo, pszClassName);\n#else\n    pClassInfo = CallVFunc<SchemaClassInfoData_t*, 2, const char*>(this, pszClassName);\n#endif\n}\n\nCSchemaSystemTypeScope* CSchemaSystem::FindTypeScopeForModule(const char* szpModuleName)\n{\n    return CallVFunc<CSchemaSystemTypeScope*, 13, const char*, void*>(this, szpModuleName, nullptr);\n}\n\nCSchemaSystemTypeScope* CSchemaSystem::GetServerTypeScope()\n{\n    static CSchemaSystemTypeScope* pServerTypeScope = FindTypeScopeForModule(WIN_LINUX(\"server.dll\", \"libserver.so\"));\n\n    return pServerTypeScope;\n}\n\nint32_t CSchemaSystem::GetServerOffset(const char* pszClassName, const char* pszPropName)\n{\n    SchemaClassInfoData_t* pClassInfo = nullptr;\n    GetServerTypeScope()->FindDeclaredClass(pClassInfo, pszClassName);\n    if (pClassInfo)\n    {\n        for (int i = 0; i < pClassInfo->m_iFieldsCount; i++)\n        {\n            auto& pFieldData = pClassInfo->m_pFieldsData[i];\n\n            if (std::strcmp(pFieldData.m_pszName, pszPropName) == 0)\n            {\n                return pFieldData.m_iOffset;\n            }\n        }\n    }\n\n    return -1;\n}",
    "// Copyright 2017 Citra Emulator Project\n// Licensed under GPLv2 or any later version\n// Refer to the license.txt file included.\n\n#include <QComboBox>\n#include <QFuture>\n#include <QIntValidator>\n#include <QRegularExpression>\n#include <QString>\n#include <QtConcurrent/QtConcurrentRun>\n#include \"citra_qt/main.h\"\n#include \"citra_qt/multiplayer/direct_connect.h\"\n#include \"citra_qt/multiplayer/message.h\"\n#include \"citra_qt/multiplayer/validation.h\"\n#include \"citra_qt/uisettings.h\"\n#include \"core/hle/service/cfg/cfg.h\"\n#include \"network/network.h\"\n#include \"network/network_settings.h\"\n#include \"ui_direct_connect.h\"\n\nenum class ConnectionType : u8 { TraversalServer, IP };\n\nDirectConnectWindow::DirectConnectWindow(Core::System& system_, QWidget* parent)\n    : QDialog(parent, Qt::WindowTitleHint | Qt::WindowCloseButtonHint | Qt::WindowSystemMenuHint),\n      ui(std::make_unique<Ui::DirectConnect>()), system{system_} {\n\n    ui->setupUi(this);\n\n    // setup the watcher for background connections\n    watcher = new QFutureWatcher<void>;\n    connect(watcher, &QFutureWatcher<void>::finished, this, &DirectConnectWindow::OnConnection);\n\n    ui->nickname->setValidator(validation.GetNickname());\n    ui->nickname->setText(UISettings::values.nickname);\n    if (ui->nickname->text().isEmpty() && !NetSettings::values.citra_username.empty()) {\n        // Use Citra Web Service user name as nickname by default\n        ui->nickname->setText(QString::fromStdString(NetSettings::values.citra_username));\n    }\n    ui->ip->setValidator(validation.GetIP());\n    ui->ip->setText(UISettings::values.ip);\n    ui->port->setValidator(validation.GetPort());\n    ui->port->setText(UISettings::values.port);\n\n    // TODO(jroweboy): Show or hide the connection options based on the current value of the combo\n    // box. Add this back in when the traversal server support is added.\n    connect(ui->connect, &QPushButton::clicked, this, &DirectConnectWindow::Connect);\n}\n\nDirectConnectWindow::~DirectConnectWindow() = default;\n\nvoid DirectConnectWindow::RetranslateUi() {\n    ui->retranslateUi(this);\n}\n\nvoid DirectConnectWindow::Connect() {\n    if (!ui->nickname->hasAcceptableInput()) {\n        NetworkMessage::ErrorManager::ShowError(NetworkMessage::ErrorManager::USERNAME_NOT_VALID);\n        return;\n    }\n    if (const auto member = Network::GetRoomMember().lock()) {\n        // Prevent the user from trying to join a room while they are already joining.\n        if (member->GetState() == Network::RoomMember::State::Joining) {\n            return;\n        } else if (member->IsConnected()) {\n            // And ask if they want to leave the room if they are already in one.\n            if (!NetworkMessage::WarnDisconnect()) {\n                return;\n            }\n        }\n    }\n    if (!ui->ip->hasAcceptableInput()) {\n        NetworkMessage::ErrorManager::ShowError(NetworkMessage::ErrorManager::IP_ADDRESS_NOT_VALID);\n        return;\n    }\n    if (!ui->port->hasAcceptableInput()) {\n        NetworkMessage::ErrorManager::ShowError(NetworkMessage::ErrorManager::PORT_NOT_VALID);\n        return;\n    }\n\n    // Store settings\n    UISettings::values.nickname = ui->nickname->text();\n    UISettings::values.ip = ui->ip->text();\n    UISettings::values.port =\n        !ui->port->text().isEmpty() ? ui->port->text() : UISettings::values.port;\n\n    // attempt to connect in a different thread\n    QFuture<void> f = QtConcurrent::run([&] {\n        if (auto room_member = Network::GetRoomMember().lock()) {\n            auto port = UISettings::values.port.toUInt();\n            room_member->Join(ui->nickname->text().toStdString(),\n                              Service::CFG::GetConsoleIdHash(system),\n                              ui->ip->text().toStdString().c_str(), port, 0,\n                              Network::NoPreferredMac, ui->password->text().toStdString().c_str());\n        }\n    });\n    watcher->setFuture(f);\n    // and disable widgets and display a connecting while we wait\n    BeginConnecting();\n}\n\nvoid DirectConnectWindow::BeginConnecting() {\n    ui->connect->setEnabled(false);\n    ui->connect->setText(tr(\"Connecting\"));\n}\n\nvoid DirectConnectWindow::EndConnecting() {\n    ui->connect->setEnabled(true);\n    ui->connect->setText(tr(\"Connect\"));\n}\n\nvoid DirectConnectWindow::OnConnection() {\n    EndConnecting();\n\n    if (auto room_member = Network::GetRoomMember().lock()) {\n        if (room_member->GetState() == Network::RoomMember::State::Joined ||\n            room_member->GetState() == Network::RoomMember::State::Moderator) {\n\n            close();\n        }\n    }\n}\n",
    "#include \"LEDController.h\"\n#include <queue>\n\nstatic Preferences preferences;\n\n// Information about the default program values\nconst uint8_t DEFAULT_BRIGHTNESS = 150;\nconst uint16_t DEFAULT_TEMPERATURE = 4500;\n\n// Information about the colours the LEDs will flash when setting a mode\nconst CRGB MODE_BRIGHTNESS_COLOUR = CRGB(0, 0, 255); // blue\nconst CRGB MODE_TEMPERATURE_COLOUR = CRGB(255, 0, 255); // purple\nconst CRGB MODE_DIRECTION_COLOUR = CRGB(0, 255, 0); // green\nconst uint16_t MODE_FLASH_DURATION = 500; // 0.5s\n\n// Event Operation\nenum EventOperations{BrightnessOperation = 1, TemperatureOperation = 2, DirectionOperation = 3, PowerOperation = 4};\n\nstatic CRGB LEDs[LED_COUNT];\n\n// Define a struct to represent an event\nstruct LEDEvent {\n    EventOperations name;\n    uint16_t parameter;\n\n    LEDEvent(EventOperations name, int parameter)\n            : name(name), parameter(parameter) {}\n};\n\nstd::queue<LEDEvent> LedEvents;\n\nvoid LEDController::Process(){\n    // Process the event queue\n    while (!LedEvents.empty()) {\n        LEDEvent ev = LedEvents.front(); // Get the operation at the front of the queue\n        LedEvents.pop(); // Remove the operation from the queue\n\n        switch (ev.name){\n            case BrightnessOperation:\n                BrightnessEvent(ev.parameter);\n                break;\n            case TemperatureOperation:\n                TemperatureEvent(ev.parameter);\n                break;\n\n            case DirectionOperation:\n                DirectionEvent(ev.parameter);\n                break;\n\n            case PowerOperation:\n                PowerEvent(ev.parameter);\n                break;\n            default:\n                break;\n        }\n    }\n}\n\nvoid LEDController::begin(){\n    // Set variable values\n    // LED Variables\n\n    currentDirection = 0;\n\n    // Initialize the LED ring\n    CFastLED::addLeds<CHIPSET, LED_PIN, GRB>(LEDs, LED_COUNT);\n\n    // Retrieve variables\n    preferences.begin(\"storage\", false);\n    currentBrightness = preferences.getUChar(\"brightness\", DEFAULT_BRIGHTNESS);\n    uint16_t retrievedTemperature = preferences.getUShort(\"temperature\", DEFAULT_TEMPERATURE);\n    preferences.end();\n\n    TRACELN(\"Loaded State\")\n    TRACE(\"Brightness: \")\n    TRACE(currentBrightness)\n    TRACE(\"\\nTemperature: \")\n    TRACE(retrievedTemperature)\n    TRACE(\"\\n\\n\")\n\n    if (retrievedTemperature >= 1000 && retrievedTemperature <= 12000){\n        currentTemperature = retrievedTemperature;\n    }\n    else{\n        currentTemperature = DEFAULT_TEMPERATURE;\n    }\n\n    currentMode = ModeBrightness;\n    setTemperature(currentTemperature);\n    setBrightness(currentBrightness);\n}\n\nvoid LEDController::TemperatureEvent(uint16_t kelvin) {\n\n    TRACELN(\"Temperature: \")\n    TRACE(kelvin)\n    TRACE(\"\\n\")\n    // Sets kelvin temperature value between 700 and 12000\n    if (kelvin < 700 || kelvin > 12000) {\n        return;\n    }\n\n    uint16_t temp;\n    temp = uint16_t(kelvin / 100.0);\n    int red, green, blue;\n    // Calculate Red\n    if (temp <= 66) {\n        red = 255;\n    } else {\n        red = temp - 60;\n        red = int(329.698727446 * (pow(red, -0.1332047592)));\n        red = std::min(std::max(red, 0), 255);\n    }\n\n    // Calculate Green\n    if (temp <= 66) {\n        green = temp;\n        green =  int(99.4708025861 * log(green) - 161.1195681661);\n        green = std::min(std::max(int(green), 0), 255);\n    } else {\n        green = temp - 60;\n        green =  int(288.1221695283 * (pow(green, -0.0755148492)));\n        green = std::min(std::max(green, 0), 255);\n    }\n\n    // Calculate Blue\n    if (temp >= 66) {\n        blue = 255;\n    } else if (temp <= 19) {\n        blue = 0;\n    } else {\n        blue = temp - 10;\n        blue = int(138.5177312231 * log(blue) - 305.0447927307);\n        blue = std::min(std::max(blue, 0), 255);\n    }\n\n    for(auto & led : LEDs) {\n        // let's set an led value\n        led = CRGB(red, green, blue);\n    }\n\n    currentTemperature = kelvin;\n    FastLED.show();\n    saveState();\n}\nvoid LEDController::BrightnessEvent(uint16_t brightness){\n    TRACE(\"Brightness: \")\n    TRACE(brightness)\n    TRACE(\"\\n\")\n    if (brightness >= 0 && brightness <= 255) {\n        FastLED.setBrightness(brightness);\n        FastLED.show();\n        currentBrightness = brightness;\n        saveState();\n    }\n}\n\nvoid LEDController::DirectionEvent(uint16_t direction) {\n    // direction value 0 to 26\n    TRACE(\"Direction: \")\n    TRACE(direction)\n    TRACE(\"\\n\")\n\n    uint8_t position;\n\n    if (direction == 0){ // turn on all LEDs\n        for(auto & LED : LEDs) {\n            LED = CRGB(255,255,255);\n        }\n    }\n    else{\n        // turn off all LEDs\n        for(auto & LED : LEDs) {\n            // let's set an led value\n            LED = CRGB(0,0,0);\n        }\n\n        // turn on 5 inner LEDs\n        for(uint8_t i = 0; i < 5; i++) {\n            // let's set an led value\n            position = i + direction;\n            if (position >= 26) position = position - 26;\n            LEDs[position] = CRGB(255,255,2",
    "#include \"Ant.h\"\n#include <iostream>\n\ndouble pow(double base, int exponent)\n{\n    double res = 1;\n    for (int i = 0; i < exponent; i++)\n    {\n        res *= base;\n    }\n    return res;\n}\n\nAnt::Ant(int deadline, int numberOfLibraries)\n    : m_signedIn(numberOfLibraries), m_deadline(deadline)\n{\n    m_totalValue = 0;\n}\n\nint Ant::mutate(std::vector<Library> &libraries, int deadline, bool localSearch)\n{\n\t// if localSearch == true, then we only mutate neighbors\n    int bestValue = totalValue(libraries, deadline);\n    int iterations = 0;\n\n    for (int i = 0; (i < (localSearch ? m_path.size() - 1 : 1000)) && iterations < (localSearch ? 10 : 50); i++)\n    {\n        int idx1, idx2;\n        if (localSearch)\n        {\n            idx1 = i;\n            idx2 = i + 1;\n            std::swap(m_path[idx1], m_path[idx2]);\n        }\n        else\n        {\n            idx1 = rand() % m_path.size();\n            idx2 = rand() % m_path.size();\n            std::swap(m_path[idx1], m_path[idx2]);\n        }\n\n        int total = totalValue(libraries, deadline);\n\n        if (total > bestValue)\n        {\n            bestValue = total;\n            ++iterations;\n            i = 0;\n        }\n        else\n        {\n            std::swap(m_path[idx1], m_path[idx2]);\n        }\n    }\n    totalValue(libraries, deadline);\n    return bestValue;\n}\n\nint Ant::totalValue(std::vector<Library> &libraries, int deadline)\n{\n    int total{};\n    std::unordered_set<int> scanned;\n    for (auto &lib : m_path)\n    {\n        int numOfScanned = libraries[lib].getNumberOfBooksScanned(deadline);\n        deadline -= libraries[lib].getSignUpTime();\n        int scannedFromThisLib{};\n        for (auto &[bookIdx, bookValue] : libraries[lib].getAllBooks())\n        {\n            if (!scanned.count(bookIdx))\n            {\n                scanned.insert(bookIdx);\n                total += bookValue;\n                if (++scannedFromThisLib >= numOfScanned)\n                    break;\n            }\n        }\n    }\n    m_totalValue = total;\n    return m_totalValue;\n}\n\nvoid Ant::calculatePheromonesDeltas(std::vector<Library> &libraries, int bestValue, int deadline)\n{\n    int totalValue = getTotalValue();\n    for (int i = 0; i < m_path.size() - 1; i++)\n    {\n        deltaPheromones[std::make_pair(i, m_path[i])] += (1 / (1 + (double)(bestValue - totalValue) /\n                                                                                 std::min(totalValue, bestValue)));\n    }\n    std::unordered_set<int> scanned;\n    for (auto &lib : m_path)\n    {\n        int numOfScanned = libraries[lib].getNumberOfBooksScanned(deadline);\n        deadline -= libraries[lib].getSignUpTime();\n        int scannedFromThisLib{};\n        for (auto &[bookIdx, bookValue] : libraries[lib].getAllBooks())\n        {\n            if (!scanned.count(bookIdx))\n            {\n                scanned.insert(bookIdx);\n                bookDeltaPheromones[bookIdx] += (1 / (1 + (double)(bestValue - totalValue) / std::min(bestValue, totalValue))) / 1000;\n                if (++scannedFromThisLib >= numOfScanned)\n                    break;\n            }\n        }\n    }\n}\n\nvoid Ant::clear(int deadline)\n{\n    m_deadline = deadline;\n    for (auto &it : m_signedIn)\n        it = false;\n    m_path.clear();\n    m_totalValue = 0;\n    deltaPheromones.clear();\n    for (auto &it : bookDeltaPheromones)\n        it = 0;\n}\n\nstd::map<std::pair<int, int>, std::pair<double, int>> Ant::pheromones;\nstd::map<std::pair<int, int>, double> Ant::deltaPheromones;\n\nstd::vector<std::pair<double, int>> Ant::bookPheromones;\nstd::vector<double> Ant::bookDeltaPheromones;\n",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n\nclass Book {\npublic:\n    Book(int id, const string& name, const ::string& author, int year) :\n        bookID(id), bookName(name), author(author), yearPublished(year) {}\n\n    int getBookID() const { return bookID; }\n    string getBookName() const { return bookName; }\n    string getAuthor() const { return author; }\n    int getYearPublished() const { return yearPublished; }\n\n    void setBookName(const string& name) { bookName = name; }\n    void setAuthor(const string& authorName) { author = authorName; }\n    void setYearPublished(int year) { yearPublished = year; }\n\n    void displayBookInfo() const {\n        cout << \"Book ID: \" << bookID << endl;\n        cout << \"Book Name: \" << bookName << endl;\n        cout << \"Author: \" << author << endl;\n        cout << \"Year Published: \" << yearPublished << endl;\n    }\n\nprivate:\n    int bookID;\n    string bookName;\n    string author;\n    int yearPublished;\n};\n\nclass Library {\npublic:\n    Library(const string& filename) : fileName(filename) {\n        loadBooksFromFile();\n    }\n    ~Library() {\n        saveBooksToFile();\n    }\n\n    void addBook() {\n        int id, year;\n        string name, author;\n\n        cout << \"Enter Book ID: \";\n        cin >> id;\n        cin.ignore();\n        cout << \"Enter Book Name: \";\n        getline(cin, name);\n        cout << \"Enter Author: \";\n        getline(cin, author);\n        cout << \"Enter Year Published: \";\n        cin >> year;\n\n        books.push_back(Book(id, name, author, year));\n        cout << \"Book added successfully!\\n\";\n    }\n\n    void displayAllBooks() {\n        if (books.empty()) {\n            cout << \"No books in the library.\\n\";\n            return;\n        }\n        for (const auto& book : books) {\n            book.displayBookInfo();\n            cout << endl;\n        }\n    }\n\n    void searchBook() {\n        cout << \"Enter book name or author to search: \";\n        string term;\n        cin.ignore();\n        getline(cin, term);\n\n        auto indices = searchBooks(term);\n        if (indices.empty()) {\n            cout << \"No books found.\\n\";\n            return;\n        }\n        for (int index : indices) {\n            books[index].displayBookInfo();\n            cout << endl;\n        }\n    }\n\n    void deleteBook() {\n        cout << \"Enter book ID to delete: \";\n        int id;\n        cin >> id;\n        int index = searchBook(id);\n        if (index == -1) {\n            cout << \"Book not found!\\n\";\n            return;\n        }\n        books.erase(books.begin() + index);\n        cout << \"Book deleted successfully!\\n\";\n    }\n\nprivate:\n    vector<Book> books;\n    string fileName;\n\n    void saveBooksToFile() {\n        ofstream file(fileName);\n        if (!file) {\n            cerr << \"Failed to open file for writing.\\n\";\n            return;\n        }\n        for (const auto& book : books) {\n            file << book.getBookID() << ',' << book.getBookName() << ','\n                 << book.getAuthor() << ',' << book.getYearPublished() << '\\n';\n        }\n        file.close();\n    }\n\n    void loadBooksFromFile() {\n        ifstream file(fileName);\n        if (!file) {\n            cerr << \"Failed to open file for reading.\\n\";\n            return;\n        }\n        string line, name, author;\n        int id, year;\n        while (getline(file, line)) {\n            istringstream iss(line);\n            getline(iss, name, ',');\n            getline(iss, author, ',');\n            iss >> id >> year;\n            books.emplace_back(id, name, author, year);\n        }\n        file.close();\n    }\n\n    int searchBook(int bookID) {\n        for (size_t i = 0; i < books.size(); ++i) {\n            if (books[i].getBookID() == bookID) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    vector<int> searchBooks(const string& term) {\n        vector<int> indices;\n        for (size_t i = 0; i < books.size(); ++i) {\n            if (books[i].getBookName().find(term) != string::npos ||\n                books[i].getAuthor().find(term) != string::npos) {\n                indices.push_back(i);\n            }\n        }\n        return indices;\n    }\n};\n\nint main() {\n    Library myLibrary(\"library.txt\");\n    int choice;\n\n    do {\n        cout << \"\\n1. Add Book\\n\";\n        cout << \"2. Display All Books\\n\";\n        cout << \"3. Search for a Book\\n\";\n        cout << \"4. Delete a Book\\n\";\n        cout << \"5. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                myLibrary.addBook();\n                break;\n            case 2:\n                myLibrary.displayAllBooks();\n                break;\n            case 3:\n                myLibrary.searchBook();\n                break;\n            case 4:\n                myLibrary.deleteBook();\n                break;\n            case 5:\n                cout << \"Exiting program.\\n\";\n                break;\n            default:\n   ",
    "#include \"netvars.hpp\"\n#include \"../sdk.hpp\"\n//antario if i remember correctly\n\nnamespace netvar_manager {\n\tusing netvar_key_value_map = std::unordered_map< uint32_t, uintptr_t >;\n\tusing netvar_table_map = std::unordered_map< uint32_t, netvar_key_value_map >;\n\tvoid initialize_props(netvar_table_map& table_map);\n\n\tuintptr_t get_net_var(const uint32_t table,\n\t\tconst uint32_t prop) {\n\t\tstatic netvar_table_map map = {};\n\t\tif (map.empty())\n\t\t\tinitialize_props(map);\n\n\t\tif (map.find(table) == map.end())\n\t\t\treturn 0;\n\n\t\tnetvar_key_value_map& table_map = map.at(table);\n\t\tif (table_map.find(prop) == table_map.end())\n\t\t\treturn 0;\n\n\t\treturn table_map.at(prop);\n\t}\n\n\tuintptr_t find_in_datamap(datamap_t* map, uint32_t name_hash) {\n\t\twhile (map) {\n\t\t\tfor (int i = 0; i < map->data_num_fields; i++) {\n\t\t\t\tif (!map->data_desc[i].field_name)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (fnv::hash(map->data_desc[i].field_name) == name_hash)\n\t\t\t\t\treturn map->data_desc[i].field_offset[TD_OFFSET_NORMAL];\n\n\t\t\t\tif (map->data_desc[i].field_type == FIELD_EMBEDDED && map->data_desc[i].td)\n\t\t\t\t\tif (const uintptr_t offset = find_in_datamap(map->data_desc[i].td, name_hash); offset != 0)\n\t\t\t\t\t\treturn offset;\n\t\t\t}\n\t\t\tmap = map->base_map;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid add_props_for_table(netvar_table_map& table_map, const uint32_t table_name_hash, const std::string& table_name, recv_table* table, const bool dump_vars, std::map< std::string, std::map< uintptr_t, std::string > >& var_dump, const size_t child_offset = 0) {\n\t\tfor (auto i = 0; i < table->props_count; ++i) {\n\t\t\tauto& prop = table->props[i];\n\n\t\t\tif (prop.data_table && prop.elements_count > 0) {\n\t\t\t\tif (std::string(prop.prop_name).substr(0, 1) == std::string(\"0\"))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tadd_props_for_table(table_map, table_name_hash, table_name, prop.data_table, dump_vars, var_dump, prop.offset + child_offset);\n\t\t\t}\n\n\t\t\tauto name = std::string(prop.prop_name);\n\n\t\t\tif (name.substr(0, 1) != \"m\" /*&& name.substr( 0, 1 ) != \"b\"*/)\n\t\t\t\tcontinue;\n\n\t\t\tconst auto name_hash = fnv::hash(prop.prop_name);\n\t\t\tconst auto offset = uintptr_t(prop.offset) + child_offset;\n\n\t\t\ttable_map[table_name_hash][name_hash] = offset;\n\n\t\t\tif (dump_vars)\n\t\t\t\tvar_dump[table_name][offset] = prop.prop_name;\n\t\t}\n\t}\n\n\tvoid initialize_props(netvar_table_map& table_map) {\n\t\tconst auto dump_vars = true;  //true if netvar dump\n\n\t\tstd::map< std::string, std::map< uintptr_t, std::string > > var_dump;\n\t\tfor (auto client_class = interfaces::client->get_all_classes();\n\t\t\tclient_class;\n\t\t\tclient_class = client_class->next_ptr) {\n\t\t\tconst auto table = reinterpret_cast<recv_table*>(client_class->recvtable_ptr);\n\t\t\tconst auto table_name = table->table_name;\n\t\t\tconst auto table_name_hash = fnv::hash(table_name);\n\n\t\t\tif (table == nullptr)\n\t\t\t\tcontinue;\n\n\t\t\tadd_props_for_table(table_map, table_name_hash, table_name, table, dump_vars, var_dump);\n\t\t}\n\t}\n}",
    "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n// \u5b9a\u4e49\u4e00\u4e2av3\u7684\u5411\u91cf\nstruct Vector3 {\n    /* data */\n    float x, y, z;\n\n    /* function */\n    Vector3(float x_, float y_, float z_)\n        : x(x_), y(y_), z(z_) {}\n    Vector3 operator-(const Vector3& v3);\n    Vector3 operator+(const Vector3& v3);\n    float& operator[](int index);\n};\n\nVector3 Vector3::operator-(const Vector3& v3) {\n    return Vector3(\n        this->x - v3.x,\n        this->y - v3.y,\n        this->z - v3.z);\n}\n\nVector3 Vector3::operator+(const Vector3& v3) {\n    return Vector3(\n        this->x + v3.x,\n        this->y + v3.y,\n        this->z + v3.z);\n}\n\nfloat& Vector3::operator[](int index) {\n    if (index == 0)\n        return x;\n    else if (index == 1)\n        return y;\n    else if (index == 2)\n        return z;\n    else {\n        throw std::out_of_range(\"Index out of range in Vector3::operator[]. Index should be 0, 1, 2.\");\n    }\n}\n\n// \u5b9a\u4e49\u4e00\u4e2aAABB\u5305\u56f4\u76d2\nstruct AABB {\n    /* data */\n    Vector3 min, max;\n\n    /* function */\n    AABB(const Vector3& min_, const Vector3& max_)\n        : min(min_), max(max_) {}\n};\n\n// \u5b9a\u4e49\u4e00\u4e2a\u4e09\u89d2\u5f62\u7ed3\u6784\nstruct Triangle {\n    /* data */\n    Vector3 vertices[3];\n\n    /* function */\n    AABB boundingBox() const {\n        Vector3 min(\n            std::min({vertices[0].x, vertices[1].x, vertices[2].x}),\n            std::min({vertices[0].y, vertices[1].y, vertices[2].y}),\n            std::min({vertices[0].z, vertices[1].z, vertices[2].z}));\n        Vector3 max(\n            std::max({vertices[0].x, vertices[1].x, vertices[2].x}),\n            std::max({vertices[0].y, vertices[1].y, vertices[2].y}),\n            std::max({vertices[0].z, vertices[1].z, vertices[2].z}));\n        return AABB(min, max);\n    }\n};\n\n// \u5b9a\u4e49BVH\u7ed3\u70b9\nstruct BVHNode {\n    /* data */\n    AABB boundingBox;\n    BVHNode* leftChild;\n    BVHNode* rightChild;\n    std::vector<Triangle> triangles;\n\n    /* function */\n    BVHNode(const AABB& bbox)\n        : boundingBox(bbox), leftChild(nullptr), rightChild(nullptr) {}\n};\n\n// \u6784\u5efaBVH\nBVHNode* buildBVH(std::vector<Triangle>& triangles) {\n    // \u7a7a\u4e09\u89d2\u5224\u65ad\n    if (triangles.empty())\n        return nullptr;\n\n    // \u8ba1\u7b97\u5305\u56f4\u76d2\n    AABB bbox = triangles[0].boundingBox();\n    for (auto tri : triangles) {\n        AABB triBox = tri.boundingBox();\n        bbox.min = Vector3(\n            std::min(bbox.min.x, triBox.min.x),\n            std::min(bbox.min.y, triBox.min.y),\n            std::min(bbox.min.z, triBox.min.z));\n        bbox.max = Vector3(\n            std::max(bbox.max.x, triBox.max.x),\n            std::max(bbox.max.y, triBox.max.y),\n            std::max(bbox.max.z, triBox.max.z));\n    }\n\n    // \u5982\u679c\u4e09\u89d2\u5f62\u6570\u91cf\u5c0f\u4e8e\u7b49\u4e8e1\uff0c \u5219\u521b\u5efa\u53f6\u5b50\u7ed3\u70b9\n    if (triangles.size() <= 1) {\n        BVHNode* leaf = new BVHNode(bbox);\n        leaf->triangles = std::move(triangles);\n        return leaf;\n    }\n\n    // \u627e\u5230\u6700\u957f\u7684\u8fb9\n    Vector3 extent = bbox.max - bbox.min;\n    int longestAxis = (extent.x > extent.y && extent.x > extent.z) ? 0 : (extent.y > extent.z) ? 1\n                                                                                               : 2;\n    float splitPosition = (bbox.min[longestAxis] + bbox.max[longestAxis]) * 0.5f;\n\n    // \u5206\u5272\u4e09\u89d2\u5f62\n    std::vector<Triangle> leftTriangles, rightTriangles;\n    for (auto tri : triangles) {\n        AABB triBox = tri.boundingBox();\n        float triCenter = (triBox.min[longestAxis] + triBox.max[longestAxis]) * 0.5f;\n\n        if (triCenter <= splitPosition) {\n            leftTriangles.push_back(tri);\n        } else {\n            rightTriangles.push_back(tri);\n        }\n    }\n\n    // \u9012\u5f52\u6784\u5efa\u5de6\u53f3\u5b50\u6811\n    BVHNode* node = new BVHNode(bbox);\n    node->leftChild = buildBVH(leftTriangles);\n    node->rightChild = buildBVH(rightTriangles);\n    return node;\n}\n\n// \u663e\u793a\u4e09\u89d2\u5f62\u548c\u5305\u56f4\u76d2\u4fe1\u606f\nvoid displayTriangle(const Triangle& tri) {\n    std::cout << \"Triangle vertices:\" << std::endl;\n    for (int i = 0; i < 3; ++i) {\n        std::cout << \"  Vertex \" << i << \": (\" << tri.vertices[i].x << \", \" << tri.vertices[i].y << \", \" << tri.vertices[i].z << \")\" << std::endl;\n    }\n    AABB bbox = tri.boundingBox();\n    std::cout << \"Bounding box: \" << std::endl;\n    std::cout << \"  Min: (\" << bbox.min.x << \", \" << bbox.min.y << \", \" << bbox.min.z << \")\" << std::endl;\n    std::cout << \"  Max: (\" << bbox.max.x << \", \" << bbox.max.y << \", \" << bbox.max.z << \")\" << std::endl;\n}\n\n// \u663e\u793aBVH\u8282\u70b9\u548c\u5305\u56f4\u76d2\u4fe1\u606f\nvoid displayBVHNode(BVHNode* node, int depth = 0) {\n    if (node == nullptr)\n        return;\n    std::cout << \"BVHNode at depth \" << depth << \":\" << std::endl;\n    std::cout << \"Bounding box: \" << std::endl;\n    std::cout << \"  Min: (\" << node->boundingBox.min.x << \", \" << node->boundingBox.min.y << \", \" << node->boundingBox.min.z << \")\" << std::endl;\n    std::cout << \"  Max: (\" << node->boundingBox.max.x << \", \" << node->boundingBox.max.y << \", \" << node->boundingBox.max.z << \")\" << std::endl;\n    std::cout << \"Number of triangles: \" << node->triangles.size() << std::endl;\n    if (node->leftChild != nullptr || node->rightChild != nullptr) {\n        std::cout << \"Left child:\" << std::endl;\n  ",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: BP_PalClimbingComponent\n\n#include \"Basic.hpp\"\n\n#include \"BP_PalClimbingComponent_classes.hpp\"\n#include \"BP_PalClimbingComponent_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.Cancel Ray Check\n// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)\n\nvoid UBP_PalClimbingComponent_C::Cancel_Ray_Check()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"Cancel Ray Check\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.CenterRayCast\n// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// bool                                    IsHit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// struct FVector                          HitPos                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UBP_PalClimbingComponent_C::CenterRayCast(bool* IsHit, struct FVector* HitPos)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"CenterRayCast\");\n\n\tParams::BP_PalClimbingComponent_C_CenterRayCast Parms{};\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tif (IsHit != nullptr)\n\t\t*IsHit = Parms.IsHit;\n\n\tif (HitPos != nullptr)\n\t\t*HitPos = std::move(Parms.HitPos);\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.CheckClimbingMode\n// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)\n\nvoid UBP_PalClimbingComponent_C::CheckClimbingMode()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"CheckClimbingMode\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.CheckUpToTop\n// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)\n// Parameters:\n// bool                                    Finish                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UBP_PalClimbingComponent_C::CheckUpToTop(bool* Finish)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"CheckUpToTop\");\n\n\tParams::BP_PalClimbingComponent_C_CheckUpToTop Parms{};\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\tif (Finish != nullptr)\n\t\t*Finish = Parms.Finish;\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.ClimbingMainUpdate\n// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UBP_PalClimbingComponent_C::ClimbingMainUpdate(double DeltaTime)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"ClimbingMainUpdate\");\n\n\tParams::BP_PalClimbingComponent_C_ClimbingMainUpdate Parms{};\n\n\tParms.DeltaTime = DeltaTime;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.ClimbUpAtTopEvent\n// (BlueprintCallable, BlueprintEvent)\n\nvoid UBP_PalClimbingComponent_C::ClimbUpAtTopEvent()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"ClimbUpAtTopEvent\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.DelayCanClimbing\n// (BlueprintCallable, BlueprintEvent)\n\nvoid UBP_PalClimbingComponent_C::DelayCanClimbing()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BP_PalClimbingComponent_C\", \"DelayCanClimbing\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function BP_PalClimbingComponent.BP_PalClimbingComponent_C.DiagonalRayCast\n// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// bool                                    IsUp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// bool                                    IsRight                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// bool                                    IsHit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// struct FVector                          HitPoint                         ",
    "\r\n#include \"errors/commandline_errors.hpp\"\r\n#include <fstream>\r\n\r\nvoid ensure_lack_of_input_files(const std::vector<std::string>& input_files) {\r\n    if (!input_files.empty()){\r\n        throw CommandLineError {\r\n            \"input files were given but they wheren't needed, \\n\"\r\n            \"(please keep in mind that if you use version or help flag \\n\"\r\n            \"you are not expected to give any input file what so ever)\"\r\n        };\r\n    }\r\n}\r\n\r\nvoid ensure_lack_of_output_files(const std::vector<std::string>& output_files) {\r\n    if (!output_files.empty()) {\r\n        throw CommandLineError {\r\n           \"output files were given but they wheren't needed, \\n\"\r\n            \"(please keep in mind that you will get an output only \\n\"\r\n            \"when compiling, wich means you only need to specify \\n\"\r\n            \"output files if you use the compilation flag)\"\r\n        };\r\n    }\r\n}\r\n\r\nvoid ensure_source_file_is_open(const std::fstream& input_file, const std::string& file_name){\r\n    if (!input_file.is_open()) {\r\n        throw CommandLineError {\r\n            \"file \" + file_name + \" either is missing or is inaccessible \\n\"\r\n            \"(please double-check the name of the file and make sure the \\n\"\r\n            \"path to that file is fully and correctly specified)\"\r\n        };\r\n    }\r\n}\r\n\r\nvoid ensure_version_flag_is_the_only_one(\r\n    int current_flag_index, int arg_counter, const std::vector<std::string>& input_files, \r\n    const std::vector<std::string>& output_files, const CommandLineController::Mode mode\r\n){\r\n    if (\r\n        !input_files.empty()  || !output_files.empty() || \r\n        current_flag_index + 1 < arg_counter || \r\n        mode != CommandLineController::Mode::unspecified\r\n    ) \r\n    throw CommandLineError { \r\n        \"if you use the version flag (-v / --version) that's supposed to be the only one\" \r\n    };\r\n}\r\n\r\nvoid ensure_help_flag_is_the_only_one(\r\n    int current_flag_index, int arg_counter, const std::vector<std::string>& input_files, \r\n    const std::vector<std::string>& output_files, const CommandLineController::Mode mode\r\n){\r\n    if (\r\n        !input_files.empty()  || !output_files.empty() || \r\n        current_flag_index + 1 < arg_counter || \r\n        mode != CommandLineController::Mode::unspecified\r\n    ) \r\n    throw CommandLineError { \r\n        \"if you use the help flag (-h / --help) that's supposed to be the only one\" \r\n    };\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <dwmapi.h>\r\n#include \"main.h\"\r\n\r\n//declarar DLLs\r\nHHOOK hhk = NULL;\r\nHINSTANCE hInst = NULL;\r\n\r\nvoid _PoL(HWND hwnd, const char* Option)\r\n{\r\n        //politica de renderizado y transisiones\r\n    if (strcmp(Option, \"Enable\") == 0)\r\n    {\r\n        DWMNCRENDERINGPOLICY rNCRP = DWMNCRP_ENABLED;\r\n        BOOL tpol = FALSE;\r\n        DwmSetWindowAttribute(hwnd, DWMWA_NCRENDERING_POLICY, &rNCRP, sizeof(rNCRP));\r\n        DwmSetWindowAttribute(hwnd, DWMWA_TRANSITIONS_FORCEDISABLED, &tpol, sizeof(tpol));\r\n    }\r\n    else if (strcmp(Option, \"Disable\") == 0)\r\n    {\r\n        DWMNCRENDERINGPOLICY NCRP = DWMNCRP_DISABLED;\r\n        BOOL lpol = TRUE;\r\n        DwmSetWindowAttribute(hwnd, DWMWA_NCRENDERING_POLICY, &NCRP, sizeof(NCRP));\r\n        DwmSetWindowAttribute(hwnd, DWMWA_TRANSITIONS_FORCEDISABLED, &lpol, sizeof(lpol));\r\n    }\r\n}\r\n\r\n//definir gancho\r\nLRESULT CALLBACK GetWinProc(int cCode, WPARAM wParam, LPARAM lParam) {\r\n    if (cCode == HSHELL_WINDOWCREATED) {\r\n        HWND hwnd = (HWND)wParam;\r\n\r\n    //Deshabilitar renderizado y transiciones\r\n    _PoL(hwnd, \"Disable\");\r\n\r\n    //exclude explorer\r\n    WCHAR className[32]; // WCHAR en lugar de TCHAR para manejar cadenas amplias\r\n    GetClassNameW(hwnd, className, sizeof(className)/sizeof(className[0])); // Usar GetClassNameW para obtener el nombre de clase\r\n\r\n    // Compara el nombre de clase con el de la ventana de Explorer\r\n    if (wcscmp(className, L\"CabinetWClass\") == 0) { // Usar wcscmp para comparar cadenas amplias\r\n        _PoL(hwnd, \"Enable\"); // Habilitar la pol\u00edtica\r\n    }\r\n    }\r\n    // Llama al siguiente gancho en la cadena\r\n    return CallNextHookEx(hhk, cCode, wParam, lParam);\r\n}\r\n\r\n\r\n\r\nextern \"C\" DLL_EXPORT BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\r\n{\r\n    switch (fdwReason)\r\n    {\r\n        case DLL_PROCESS_ATTACH:\r\n            // attach from process\r\n            hInst = (HINSTANCE) hinstDLL;\r\n            break;\r\n\r\n        case DLL_PROCESS_DETACH:\r\n            // detach from process\r\n            break;\r\n\r\n        case DLL_THREAD_ATTACH:\r\n            // attach to thread\r\n            break;\r\n\r\n        case DLL_THREAD_DETACH:\r\n            // detach from thread\r\n            break;\r\n    }\r\n    return TRUE; // succesful\r\n}\r\n\r\nvoid SetHook()\r\n{\r\n    //instalar gancho\r\n    hhk = SetWindowsHookEx(WH_SHELL, (HOOKPROC)GetWinProc, hInst, 0);\r\n}\r\n\r\nvoid RemoveHook()\r\n{\r\n    //remover gancho\r\n    UnhookWindowsHookEx(hhk);\r\n}\r\n\r\n\r\n",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include \"hand.hpp\"\n#include \"Player.hpp\"\n#include \"Dealer.hpp\"\n#include \"test.hpp\"\n#include \"Button.hpp\"\n#include \"Client.h\"\n\nusing sf::Texture;\nusing sf::Sprite;\n\nint main(void)\n{\n    WSADATA wsaData;\n    SOCKET clientSocket;\n    sockaddr_in serverAddr;\n\n    initCreateConnect(wsaData, clientSocket, serverAddr);\n\n    string message;\n \n    // Prompt user for input\n    message = promptForInput();\n\n    // Send user input to server\n    sendToServer(message, clientSocket);\n\n    // Close socket\n    closeSocket(clientSocket);\n\n    srand((unsigned int)time(NULL));\n\n    Test t; \n    t.runTests(); \n\n    sf::RenderWindow window(sf::VideoMode(1920, 1080), \"BLACKJACK\");\n\n    Texture b;\n    b.loadFromFile(\"Cards/background.png\");\n\n    Sprite background(b);\n    background.setScale(1.5f, 1.5f);\n\n    Texture x1;\n    x1.loadFromFile(\"Cards/card back black.png\");\n\n    //this is a set position for the backcard and I think we should keep it in main in the future because we can control when we want to remove it\n    Sprite backCard(x1);\n    backCard.setScale(0.26f, 0.26f);\n    backCard.setPosition(950, 50);\n\n\n    Deck gDeck;\n    Player player(gDeck);\n    Dealer dealer(gDeck);\n\n\n    //\n    \n    Texture HitTexture; \n    HitTexture.loadFromFile(\"Cards/redHitButton.png\");\n    HitButton Hit(HitTexture); \n   \n\n  \n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n            {\n                window.close();\n            }\n\n          //  if (player.canSplit())\n            //{\n                \n            \n            //}\n           \n        }\n\n        window.clear();\n        window.draw(background);\n\n        window.draw(Hit); \n        dealer.displayHand(window);\n        window.draw(backCard);\n\n        player.displayHand(window);\n        window.display();\n    }\n    return 0;\n}\n\n",
    "#include \"benchmark/benchmark.h\"\n#include \"../include/qf/datamodels/option.hpp\"\n#include \"../include/qf/pricing/options/option_pricer.hpp\"\n#include <chrono>\n#include \"qf/datamodels/option.hpp\"\n\nBlackScholesPricer blackScholesPricer;\nOption option(100.0, 100.0, 1.0, 0.2, 0.05, 0.0, OptionType::Type::CALL, OptionType::Type::PUT, std::chrono::system_clock::now());\nstd::vector<Option> options(1000, option);\nstd::vector<double> results(options.size());\n\nstatic void BM_BlackScholesPricer(benchmark::State& state) {\n    for (auto _ : state) {\n        blackScholesPricer.price(option);\n    }\n}\n\nstatic void BM_MultiBlackScholesPricer(benchmark::State& state) {\n    for (auto _ : state) {\n        for (const auto& option : options) {\n            blackScholesPricer.price(option);\n        }\n    }\n}\n\nstatic void BM_ParallelBlackScholesPricer(benchmark::State& state) {\n    for (auto _ : state) {\n        blackScholesPricer.prices(options, results);  \n    }\n}\n        \n\nBENCHMARK(BM_BlackScholesPricer);\nBENCHMARK(BM_MultiBlackScholesPricer);\nBENCHMARK(BM_ParallelBlackScholesPricer);",
    "#include \"constraint_standard_shifted.hpp\"\n\n#include \"sudoku.hpp\"\n#include \"constraint_no_duplicate.hpp\"\n\nGGStandardBlock::GGStandardBlock(Sudoku *_sudoku, int _ox, int _oy) : GroupGenerator(9, 9), sudoku(_sudoku), ox(_ox), oy(_oy)\n{}\n\nvoid GGStandardBlock::getGroup(int *dst, int y) {\n    for(int x = 0; x < 9; x++) {\n        dst[x] = sudoku->getIndex(y / 3 * 3 + x / 3 + oy, y % 3 * 3 + x % 3 + ox);\n    }\n}\n\nGGHorizontal::GGHorizontal(Sudoku *_sudoku, int _ox, int _oy) : GroupGenerator(9, 9), sudoku(_sudoku), ox(_ox), oy(_oy)\n{}\n\nvoid GGHorizontal::getGroup(int *dst, int y) {\n    for(int x = 0; x < 9; x++) {\n        dst[x] = sudoku->getIndex(y + ox, x + oy);\n    }\n}\n\nGGVertical::GGVertical(Sudoku *_sudoku, int _ox, int _oy) : GroupGenerator(9, 9), sudoku(_sudoku), ox(_ox), oy(_oy)\n{}\n\nvoid GGVertical::getGroup(int *dst, int y) {\n    for(int x = 0; x < 9; x++) {\n        dst[x] = sudoku->getIndex(x + ox, y + oy);\n    }\n}\n\nvoid ConstraintNoDuplicate::inStandardBlock(Sudoku *sudoku, int ox, int oy)\n{\n    GGStandardBlock(sudoku, ox, oy).apply(this);\n}\n\nvoid ConstraintNoDuplicate::inVerticalLine(Sudoku *sudoku, int ox, int oy)\n{\n    GGVertical(sudoku, ox, oy).apply(this);\n}\n\nvoid ConstraintNoDuplicate::inHorizontalLine(Sudoku *sudoku, int ox, int oy)\n{\n    GGHorizontal(sudoku, ox, oy).apply(this);\n}\n\nvoid ConstraintNoDuplicate::standardSudoku(Sudoku *sudoku, int ox, int oy) {\n    inStandardBlock(sudoku, ox, oy);\n    inVerticalLine(sudoku, ox, oy);\n    inHorizontalLine(sudoku, ox, oy);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// dear imgui, v1.90.5\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"    ",
    "#include \"Agent.h\"\n#include <random> // \u5305\u542b\u968f\u673a\u6570\u751f\u6210\u5668\u548c\u5206\u5e03\n\nAgent::Agent(Environment* env) : environment(env) {\n    srand(static_cast<unsigned int>(time(nullptr)));\n    initializeDeterministicPolicy(env);\n    initializeStochasticPolicy(env);\n    //initializeActionSpace();\n    setAlgorithm(new QLearning()); // \u9ed8\u8ba4\u8bbe\u7f6e\u4e3aBellmanSolve\u7b97\u6cd5\n}\n\nAgent::~Agent() {\n    delete algorithm;\n}\n\nvoid Agent::setAlgorithm(RLAlgorithm* newAlgorithm) {\n    delete algorithm;\n    algorithm = newAlgorithm;\n}\n\nvoid Agent::run() {\n    if (algorithm) {\n        algorithm->run(*this); // \u5c06\u81ea\u8eab\u4f20\u9012\u7ed9\u7b97\u6cd5\n        stepCount++; // \u5728\u6bcf\u6b21\u8fd0\u884c\u7b97\u6cd5\u65f6\u9012\u589e\u6b65\u9aa4\u8ba1\u6570\n    }\n}\n\n\n\nvoid Agent::initializeDeterministicPolicy(Environment* env) {\n    const auto& grid = env->getGrid();\n    for (int x = 0; x < grid.size(); x++) {\n        for (int y = 0; y < grid[x].size(); y++) {\n            std::map<ActionType, float> probabilities;\n            for (int i = 0; i < 5; i++) {\n                probabilities[static_cast<ActionType>(i)] = 0.0f;\n            };\n            int action = rand()%5;\n            probabilities[static_cast<ActionType>(action)] = 1.0f;\n            stochasticPolicy[{x, y}] = probabilities;\n        }\n    }\n}\n\nvoid Agent::initializeStochasticPolicy(Environment* env) {\n    const auto& grid = env->getGrid();\n    for (int x = 0; x < grid.size(); x++) {\n        for (int y = 0; y < grid[x].size(); y++) {\n            std::map<ActionType, float> probabilities;\n            float total = 0;\n            for (int action = 0; action < 5; action++) {\n                float prob = static_cast<float>(rand()) / RAND_MAX; // \u751f\u62100\u52301\u4e4b\u95f4\u7684\u968f\u673a\u6982\u7387\n                probabilities[static_cast<ActionType>(action)] = prob;\n                total += prob;\n            }\n            // \u5f52\u4e00\u5316\u6982\u7387\n            for (auto& pair : probabilities) {\n                pair.second /= total;\n            }\n            stochasticPolicy[{x, y}] = probabilities;\n        }\n    }\n}\n\n\n// \u8bbe\u7f6e\u968f\u673a\u6027\u7b56\u7565\u7684\u65b9\u6cd5\nvoid Agent::setStochasticPolicy(const std::pair<int, int>& state, const std::map<ActionType, float>& actionProbabilities) {\n    stochasticPolicy[state] = actionProbabilities;\n}\n\n// \u6839\u636e\u968f\u673a\u6027\u7b56\u7565\u9009\u62e9\u52a8\u4f5c\nActionType Agent::chooseActionStochastic(const std::pair<int, int>& state) {\n    auto it = stochasticPolicy.find(state);\n    if (it == stochasticPolicy.end()) {\n        return ActionType::Up; // \u5982\u679c\u72b6\u6001\u672a\u5b9a\u4e49\uff0c\u8fd4\u56de\u9ed8\u8ba4\u52a8\u4f5c\n    }\n\n    // \u7d2f\u79ef\u6982\u7387\u8fb9\u754c\n    std::vector<std::pair<float, ActionType>> cumulativeProbabilities;\n    float cumulative = 0.0;\n    for (const auto& actionProb : it->second) {\n        cumulative += actionProb.second;\n        cumulativeProbabilities.push_back({ cumulative, actionProb.first });\n    }\n\n    // \u751f\u6210\u4e00\u4e2a\u968f\u673a\u6570\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_real_distribution<> dis(0.0, 1.0);\n    float randomValue = dis(gen);\n\n    // \u6839\u636e\u968f\u673a\u6570\u9009\u62e9\u52a8\u4f5c\n    for (const auto& cp : cumulativeProbabilities) {\n        if (randomValue <= cp.first) {\n            return cp.second;\n        }\n    }\n\n    return ActionType::Stay; // \u5e94\u8be5\u6c38\u8fdc\u4e0d\u4f1a\u5230\u8fbe\u8fd9\u91cc\uff0c\u9664\u975e\u6982\u7387\u4e4b\u548c\u4e0d\u4e3a1\n}\n\n\n\nstd::map<ActionType, float> Agent::getStochasticPolicy(const std::pair<int, int>& state) const {\n    if (stochasticPolicy.find(state) != stochasticPolicy.end()) {\n        return stochasticPolicy.at(state);\n    }\n    return std::map<ActionType, float>(); // \u5982\u679c\u72b6\u6001\u672a\u5b9a\u4e49\uff0c\u5219\u8fd4\u56de\u7a7a\u7684\u7b56\u7565\n}\n\n\nint Agent::getStepCount() const {\n    return stepCount; // \u63d0\u4f9b\u83b7\u53d6\u5f53\u524d\u6b65\u9aa4\u8ba1\u6570\u7684\u65b9\u6cd5\n}\n\nstd::pair<int, int> Agent::getNextState(const std::pair<int, int>& currentState, ActionType action)\n{\n    const auto& grid = environment->getGrid();\n\n    int dx = 0;\n    int dy = 0;\n    switch (action) {\n    case ActionType::Up:\n        dy = -1;\n        break;\n    case ActionType::Down:\n        dy = 1;\n        break;\n    case ActionType::Left:\n        dx = -1;\n        break;\n    case ActionType::Right:\n        dx = 1;\n        break;\n    case ActionType::Stay:\n    default:\n        // \u4e0d\u79fb\u52a8\n        break;\n    }\n    // \u8ba1\u7b97\u4e0b\u4e00\u4e2a\u72b6\u6001\n    int nextX = std::max(0, std::min(static_cast<int>(grid.size()) - 1, currentState.first + dx));\n    int nextY = std::max(0, std::min(static_cast<int>(grid[0].size()) - 1, currentState.second + dy));\n\n    // \u5982\u679c\u4e0b\u4e00\u4e2a\u72b6\u6001\u8d85\u51fa\u8fb9\u754c\uff0c\u5219\u4fdd\u6301\u539f\u5730\u4e0d\u52a8\n    if (nextX == currentState.first && nextY == currentState.second) {\n        return currentState;\n    }\n\n    return { nextX, nextY };\n}\n\nvoid Agent::initializeActionSpace() {\n    actionSpace[ActionType::Up] = { 0, -1 };\n    actionSpace[ActionType::Down] = { 0, 1 };\n    actionSpace[ActionType::Left] = { -1, 0 };\n    actionSpace[ActionType::Right] = { 1, 0 };\n    actionSpace[ActionType::Right] = { 0, 0 };\n}\n\nstd::map<ActionType, std::pair<int, int>> Agent::getActionSpace()\n{\n    return actionSpace;\n}\n\n\n\nstd::vector<EpisodeStep> Agent::generateEpisode(Agent & agent, Environment * penv, std::pair<int, int> start, int length) {\n    std::vector<EpisodeStep> episode;\n    std::pair<int, int> state = start;\n    const auto& grid = penv->getGrid();\n    while (length > 0 && grid[state.first][state.second] != CellType::Target) {\n        auto actionProbabilities = agent.getStochasticPolicy(state);\n        ActionType ",
    "#include \"render_pipeline.h\"\n#include \"../utils.h\"\n\nusing namespace std;\n\nGLuint createShader(GLenum type, const string &shaderStr) {\n    auto shader = glCreateShader(type);\n    auto *shaderCStr = shaderStr.c_str();\n    GL(glShaderSource(shader, 1, &shaderCStr, nullptr));\n\n    GLint compiled;\n    GL(glCompileShader(shader));\n    GL(glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled));\n    if (!compiled) {\n        char errorLog[1000];\n        GL(glGetShaderInfoLog(shader, sizeof(errorLog), nullptr, errorLog));\n        LOGE(\"SHADER COMPILATION ERROR: %s\\nSHADER:\\n%s\", errorLog, shaderCStr);\n    }\n    return shader;\n}\n\nnamespace gl_render_utils {\n\nRenderState::RenderState(const Texture *renderTarget) {\n    mRenderTarget = renderTarget;\n    mDepthTarget = make_unique<Texture>(false,\n                                        0,\n                                        false,\n                                        renderTarget->GetWidth(),\n                                        renderTarget->GetHeight(),\n                                        GL_DEPTH_COMPONENT32F,\n                                        GL_DEPTH_COMPONENT32F);\n\n    GL(glGenFramebuffers(1, &mFrameBuffer));\n    GL(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, mFrameBuffer));\n    GL(glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER,\n                              GL_COLOR_ATTACHMENT0,\n                              mRenderTarget->GetTarget(),\n                              renderTarget->GetGLTexture(),\n                              0));\n    GL(glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER,\n                              GL_DEPTH_ATTACHMENT,\n                              mDepthTarget->GetTarget(),\n                              mDepthTarget->GetGLTexture(),\n                              0));\n}\n\nRenderState::~RenderState() { GL(glDeleteFramebuffers(1, &mFrameBuffer)); }\n\nvoid RenderState::ClearDepth() const {\n    GL(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, mFrameBuffer));\n    GL(glDisable(GL_SCISSOR_TEST));\n    GL(glClear(GL_DEPTH_BUFFER_BIT));\n}\n\nGLuint RenderPipeline::mBindingPointCounter = 0;\n\nRenderPipeline::RenderPipeline(const vector<const Texture *> &inputTextures,\n                               const string &vertexShader,\n                               const string &fragmentShader,\n                               size_t uniformBlockSize) {\n    mVertexShader = createShader(GL_VERTEX_SHADER, vertexShader);\n    mFragmentShader = createShader(GL_FRAGMENT_SHADER, fragmentShader);\n\n    mProgram = glCreateProgram();\n    GL(glAttachShader(mProgram, mVertexShader));\n    GL(glAttachShader(mProgram, mFragmentShader));\n\n    GLint linked;\n    GL(glLinkProgram(mProgram));\n    GL(glGetProgramiv(mProgram, GL_LINK_STATUS, &linked));\n    if (!linked) {\n        char errorLog[1000];\n        GL(glGetProgramInfoLog(mProgram, sizeof(errorLog), nullptr, errorLog));\n        LOGE(\"SHADER LINKING ERROR: %s\", errorLog);\n    }\n\n    for (size_t i = 0; i < inputTextures.size(); i++) {\n        mInputTexturesInfo.push_back(\n            {inputTextures[i], glGetUniformLocation(mProgram, (\"tex\" + to_string(i)).c_str())});\n    }\n\n    mUniformBlockSize = uniformBlockSize;\n    if (mUniformBlockSize > 0) {\n        GL(glUniformBlockBinding(mProgram, 0, mBindingPointCounter));\n        GL(glGenBuffers(1, &mBlockBuffer));\n        GL(glBindBuffer(GL_UNIFORM_BUFFER, mBlockBuffer));\n        GL(glBufferData(GL_UNIFORM_BUFFER, uniformBlockSize, nullptr, GL_DYNAMIC_DRAW));\n        GL(glBindBufferBase(GL_UNIFORM_BUFFER, mBindingPointCounter, mBlockBuffer));\n        mBindingPointCounter++;\n    }\n}\n\nvoid RenderPipeline::Render(const RenderState &renderState, const void *uniformBlockData) const {\n    GL(glUseProgram(mProgram));\n    GL(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, renderState.GetFrameBuffer()));\n\n    GL(glDisable(GL_SCISSOR_TEST));\n    GL(glDepthMask(GL_TRUE));\n    GL(glDisable(GL_CULL_FACE));\n    GL(glEnable(GL_DEPTH_TEST));\n    GL(glEnable(GL_BLEND));\n    GL(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));\n    GL(glViewport(0,\n                  0,\n                  renderState.GetRenderTarget()->GetWidth(),\n                  renderState.GetRenderTarget()->GetHeight()));\n\n    for (size_t i = 0; i < mInputTexturesInfo.size(); i++) {\n        GL(glActiveTexture(GL_TEXTURE0 + i));\n        GL(glBindTexture(mInputTexturesInfo[i].texture->GetTarget(),\n                         mInputTexturesInfo[i].texture->GetGLTexture()));\n        GL(glUniform1i(mInputTexturesInfo[i].uniformLocation, i));\n    }\n\n    if (uniformBlockData != nullptr) {\n        GL(glBindBuffer(GL_UNIFORM_BUFFER, mBlockBuffer));\n        GL(glBufferSubData(GL_UNIFORM_BUFFER, 0, mUniformBlockSize, uniformBlockData));\n    }\n\n    GL(glDrawArrays(GL_TRIANGLE_STRIP, 0, 4));\n}\n\nRenderPipeline::~RenderPipeline() {\n    if (GL_TRUE == glIsBuffer(mBlockBuffer)) {\n        GL(glDeleteBuffers(1, &mBlockBuffer));\n    }\n    if (GL_TRUE == glIsShader(mVertexShader)) {\n        GL(glDetachShader(mProgram, mVertexShader));\n        GL(glDeleteShader(mVertexShader));\n    ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/**\r\n    ##################################\r\n    #                                #\r\n    #      AUTORES DO PROJETO:       #\r\n    #                                #\r\n    # MARCO VINICIUS DA COSTA BUSATO #\r\n    #      FELYPE CESAR MOLINARI     #\r\n    #     LAURA FERRARI HECKMANN     #\r\n    #                                #\r\n    ##################################\r\n*/\r\n\r\n#include <iostream>\r\n#include <windows.h>\r\n#include <conio.h>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\n///Coordenadas do personagem e da bomba\r\nint xPersonagem = 2, yPersonagem = 2;\r\nint xBomba, yBomba;\r\n\r\n///Controle de movimento aleat\u00f3rio dos inimigos\r\nint deslocamentos;\r\nint direcao;\r\nint inimigo;\r\n\r\n///Controle de tempo entre movimenta\u00e7\u00e3o de inimigos e explos\u00e3o de bomba.\r\nint timerInimigo = 0;\r\nint timerBomba = 0;\r\n\r\n///Controla quanto tempo o caractere de explos\u00e3o fica em tela\r\nint explosaoBomba = 0;\r\n\r\n///Controles gerais de execu\u00e7\u00e3o do jogo\r\nbool gameLoop = true;\r\nbool bombaEmJogo = false;\r\n\r\nstring causaDaMorte = \"Indefinida\";\r\n\r\n///Variavel para tecla pressionada\r\nchar tecla;\r\n\r\n///Matriz que controla a impress\u00e3o do mapa\r\n///0: Caminho livre\r\n///1: Parede s\u00f3lida\r\n///2: Parede fr\u00e1gil\r\n///3 e 6: Caracteres da bomba (pois ela pisca)\r\n///4: Caractere de explos\u00e3o da bomba\r\n///5: Inimigos\r\nint m[10][22]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n               0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\r\n               0,1,0,0,2,0,2,2,0,0,2,0,2,0,2,0,2,0,0,0,5,1,\r\n               0,1,0,1,2,1,2,1,0,1,0,1,2,1,2,1,0,1,0,1,0,1,\r\n               0,1,2,0,2,0,2,0,0,0,2,2,2,0,2,2,2,0,0,2,0,1,\r\n               0,1,0,1,2,1,2,1,5,1,2,1,2,1,0,1,2,1,2,1,2,1,\r\n               0,1,0,0,2,0,2,2,0,0,0,0,2,0,2,2,0,0,0,0,0,1,\r\n               0,1,0,1,0,1,2,1,2,1,0,1,0,1,2,1,2,1,0,1,0,1,\r\n               0,1,5,0,0,2,2,0,0,2,0,0,0,2,2,2,0,2,0,0,5,1,\r\n               0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\r\n\r\n///Estrutura do inimigo\r\nstruct Inimigo{\r\n    int xInimigo;\r\n    int yInimigo;\r\n};\r\n\r\n///Inimigos\r\nInimigo a;\r\nInimigo b;\r\nInimigo c;\r\nInimigo d;\r\n\r\n///Ponteiro para armazenar o inimigo escolhido em quest\u00e3o\r\nInimigo* inimigoEscolhido;\r\n\r\n///As 4 pr\u00f3ximas fun\u00e7\u00f5es s\u00e3o booleanos que controlam a possibilidade de movimenta\u00e7\u00e3o do personagem\r\nbool personagemCima(int x, int y){\r\n\r\n    if(m[x-1][y] == 1 || m[x-1][y] == 2 || m[x-1][y] == 3 || m[x-1][y] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemBaixo(int x, int y){\r\n\r\n    if(m[x+1][y] == 1 || m[x+1][y] == 2 || m[x+1][y] == 3 || m[x+1][y] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemEsquerda(int x, int y){\r\n\r\n    if(m[x][y-1] == 1 || m[x][y-1] == 2 || m[x][y-1] == 3 || m[x][y-1] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemDireita(int x, int y){\r\n\r\n    if(m[x][y+1] == 1 || m[x][y+1] == 2 || m[x][y+1] == 3 || m[x][y+1] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\n///As 4 pr\u00f3ximas fun\u00e7\u00f5es s\u00e3o booleanos que controlam a possibilidade de movimenta\u00e7\u00e3o dos inimigos\r\nbool inimigoCima(Inimigo &inimigoEscolhido){\r\n\r\n   if(m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 1 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 2 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 3 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 5 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 6 ||\r\n      ///As coordenadas -1 indicam que o inimigo j\u00e1 morreu, uma vez que n\u00e3o existe essa coordenada na matriz.\r\n      inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoBaixo(Inimigo &inimigoEscolhido){\r\n\r\n    if(m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 1 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 2 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 3 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 5 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 6 ||\r\n       inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoEsquerda(Inimigo &inimigoEscolhido){\r\n\r\n    if(m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 1 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 2 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 3 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 5 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 6 ||\r\n       inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoDireita(Inimigo &ini",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <Eigen/Dense>\n#include <algorithm>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <numeric>\n#include <random>\n#include <vector>\n#define LOGV(v) std::cout << #v << \"[\" << v.rows() << \" : \" << 1 << \"]\" << std::endl\n#define LOGM(v) std::cout << #v << \"[\" << v.rows() << \" : \" << v.cols() << \"]\" << std::endl\n#define LOG(v) std::cout << #v << \"=\" << std::endl \\\n                         << v << std::endl\n\nEigen::MatrixXd readMatrix()\n{\n    // Open the file\n    std::ifstream file(\"matrix.txt\");\n    if (!file.is_open()) {\n        std::cout << \"Error opening file.\" << std::endl;\n        return Eigen::MatrixXd();\n    }\n    // Read the matrix from the file\n    // Read the matrix dimensions\n    int rows, cols;\n    file >> rows >> cols;\n    // Create a Eigen::MatrixXd to store the data\n    Eigen::MatrixXd M(rows, cols);\n    // Read the matrix elements\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            file >> M(i, j);\n        }\n    }\n    // Close the file\n    file.close();\n    return M;\n}\n\n// \u00c3\u00e5\u00ed\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0 \u00f1\u00eb\u00f3\u00f7\u00e0\u00e9\u00ed\u00fb\u00f5 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00ee\u00e2 \u00ef\u00ee \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00ec\u00f3 \u00e8 \u00ea\u00ee\u00e2\u00e0\u00f0\u00e8\u00e0\u00f6\u00e8\u00e8\nEigen::VectorXd generateRandomVector(const Eigen::VectorXd& mean,\n    const Eigen::MatrixXd& covariance)\n{\n    // Create random number generator\n    std::random_device rd;\n    std::mt19937 generator(rd());\n    std::normal_distribution<double> distribution(0.0, 1.0); // Gaussian distribution with mean 0 and standard deviation 1\n    // Compute Cholesky decomposition of the covariance matrix\n    Eigen::LLT<Eigen::MatrixXd> llt(covariance);\n    Eigen::MatrixXd L = llt.matrixL();\n\n    // Generate random vector from standard Gaussian distribution\n    Eigen::VectorXd z(mean.size());\n    for (int i = 0; i < mean.size(); ++i) {\n        z(i) = distribution(generator);\n    }\n    // Transform random vector to match the desired mean and covariance\n    Eigen::VectorXd random_vector = mean + L * z;\n    return random_vector;\n}\n\n// \u00dd\u00eb\u00eb\u00e8\u00ef\u00f1 \u00ef\u00ee \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00ec\u00f3 \u00e8 \u00ea\u00ee\u00e2\u00e0\u00f0\u00e8\u00e0\u00f6\u00e8\u00e8\n// x - \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00e5\n// P - \u00ea\u00ee\u00e2\u00e0\u00f0\u00e8\u00e0\u00f6\u00e8\u00ff\n// n - \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f1\u00e8\u00e3\u00ec (\u00ec\u00e0\u00f1\u00f8\u00f2\u00e0\u00e1)\n// NP - \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f2\u00ee\u00f7\u00e5\u00ea \u00fd\u00eb\u00eb\u00e8\u00ef\u00f1\u00e0\n// \u00e2\u00ee\u00e7\u00e2\u00f0\u00e0\u00f9\u00e0\u00e5\u00f2 NP \u00f2\u00ee\u00f7\u00e5\u00ea \u00fd\u00eb\u00eb\u00e8\u00ef\u00f1\u00e0 + 4 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00e4\u00eb\u00ff \u00ee\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e8 \u00ee\u00f1\u00e5\u00e9\nstd::tuple<Eigen::VectorXd, Eigen::VectorXd> cov2elli(const Eigen::VectorXd& x, const Eigen::MatrixXd& P, int n = 3, int NP = 16)\n{\n    // +4 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00ee\u00f1\u00e5\u00e9\n    Eigen::VectorXd X(NP + 4);\n    Eigen::VectorXd Y(NP + 4);\n    double alpha = 2 * M_PI / NP;\n    Eigen::MatrixXd circle(2, NP);\n    for (int i = 0; i < NP; ++i) {\n        circle(0, i) = cos(alpha * i);\n        circle(1, i) = sin(alpha * i);\n    }\n    Eigen::JacobiSVD<Eigen::MatrixXd> svd(P, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    Eigen::MatrixXd R = svd.matrixU();\n    Eigen::MatrixXd D = svd.singularValues().asDiagonal();\n    Eigen::MatrixXd d = D.array().sqrt().matrix();\n    Eigen::MatrixXd ellip = n * R * d * circle;\n    for (int i = 0; i < ellip.cols(); ++i) {\n        X(i) = x(0) + ellip(0, i);\n        Y(i) = x(1) + ellip(1, i);\n    }\n    Eigen::MatrixXd axis(2, 4);\n    axis << -1, 1, 0, 0,\n        0, 0, -1, 1;\n    axis = (n * R * d * axis).colwise() + x;\n\n    X.segment(NP, 4) = axis.row(0);\n    Y.segment(NP, 4) = axis.row(1);\n    return std::make_tuple(X, Y);\n}\n// \u00cf\u00f0\u00e5\u00ee\u00e1\u00f0\u00e0\u00e7\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00e8\u00e7 \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00fb\u00f5 \u00e2 \u00d1\u00ca \u00f0\u00ee\u00e1\u00ee\u00f2\u00e0\nEigen::VectorXd toFrame(const Eigen::VectorXd& F,\n    const Eigen::VectorXd& p,\n    Eigen::MatrixXd& PF_f = Eigen::MatrixXd(),\n    Eigen::MatrixXd& PF_p = Eigen::MatrixXd())\n{\n    Eigen::VectorXd pf;\n    Eigen::VectorXd t = F.head(2);\n    double a = F(2);\n    Eigen::Matrix2d R;\n    R << cos(a), -sin(a), sin(a), cos(a);\n    pf = R.transpose() * (p - t);\n    if (!PF_f.isZero() && !PF_p.isZero()) {\n        double px = p(0);\n        double py = p(1);\n        double x = t(0);\n        double y = t(1);\n        PF_f << -cos(a), -sin(a), cos(a) * (py - y) - sin(a) * (px - x),\n            sin(a), -cos(a), -cos(a) * (px - x) - sin(a) * (py - y);\n        PF_p = R.transpose();\n    }\n    return pf;\n}\n// \u00cf\u00f0\u00e5\u00ee\u00e1\u00f0\u00e0\u00e7\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00e8\u00e7 \u00d1\u00ca \u00f0\u00ee\u00e1\u00ee\u00f2\u00e0 \u00e2 \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00f3\u00fe.\nEigen::VectorXd fromFrame(const Eigen::VectorXd& F,\n    const Eigen::VectorXd& pf,\n    Eigen::MatrixXd& PW_f = Eigen::MatrixXd(),\n    Eigen::MatrixXd& PW_pf = Eigen::MatrixXd())\n{\n    Eigen::VectorXd pw;\n    Eigen::VectorXd t = F.head(2);\n    double a = F(2);\n    Eigen::Matrix2d R;\n    R << cos(a), -sin(a), sin(a), cos(a);\n    pw = R * pf + t.replicate(1, pf.cols());\n    if (!PW_f.isZero() && !PW_pf.isZero()) {\n        double px = pf(0);\n        double py = pf(1);\n        PW_f << 1, 0, -py * cos(a) - px * sin(a),\n            0, 1, px * cos(a) - py * sin(a);\n        PW_pf = R;\n    }\n    return pw;\n}\n\n// \u00cd\u00e0\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00e8 \u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e5 \u00e2 x \u00e8 y.\n//\n// \u00e2\u00f5\u00ee\u00e4:  y = [\u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e5 ; \u00ed\u00e0\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5]\n// \u00c2\u00fb\u00f5\u00ee\u00e4: p = [p x ; p y]\n// P_y: \u00df\u00ea\u00ee\u00e1\u00e8\u00e0\u00ed \u00ee\u00f2\u00ed\u00ee\u00f1\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee y. \u00cc\u00e0\u00f2\u00f0\u00e8\u00f6\u00e0 2x2\nEigen::VectorXd invScan(const Eigen::VectorXd& y, Eigen::MatrixXd& P_y = Eigen::MatrixXd())\n{\n    Eigen::VectorXd p;\n    double d = y(0);\n    double a = y(1);\n    double px = d * cos(a);\n    double py = d * sin(a);\n    p.resize(2);\n    p << px, py;\n  ",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <QDesktopWidget>\n#include <QTimer>\n#include <QDateTime>\n#include <cmath>\n#include <QDebug>\n#include <QWindow>\n// http\n#include <QUrlQuery>\n#include <QNetworkRequest>\n#include <QNetworkReply>\n// Json\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QJsonArray>\n\n#include <QFile>\n\n#include <xcb/xcb.h>\n#include <X11/Xlib.h>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    setWindowFlag(Qt::WindowTransparentForInput, true);\n    // \u8bbe\u7f6e\u5b9a\u65f6\u4e8b\u4ef6\u7528\u4e8e\u66f4\u65b0\u6570\u636e\n    m_updateTimeTimer = new QTimer();\n    connect(m_updateTimeTimer, &QTimer::timeout, this, &MainWindow::ChangeInformation);\n    m_updateTimeTimer->setInterval(500);\n    m_updateTimeTimer->start();\n    // \u8bb0\u5f55\u521d\u59cb\u8fd0\u884c\u65f6\u95f4\n    firstRunTime = QDateTime::currentDateTime();\n    // \u8bbe\u7f6e\u5c4f\u4fdd\u80cc\u666f\n    this->setStyleSheet(\"#MainWindow {border-image: url(:/Background/background.jpg);} * {color: white;}\");\n    // \u6dfb\u52a0\u9000\u51fa\u6309\u94ae\uff08\u5df2\u5e9f\u5f03\uff09\n    /*QLabel *exitButton = new QLabel(\"<a style='text-decoration: none; color: white;' href='https://www.gfdgdxi.top'>\" + tr(\"\u9000\u51fa\") + \"</a>\");\n    // \u4f7f\u7528\u8d85\u94fe\u63a5\u5b9e\u73b0 QLabel \u70b9\u51fb\u4e8b\u4ef6\n    connect(exitButton, &QLabel::linkActivated, this, [this](){\n        this->ExitScreenSaver();\n    });\n    exitButton->setAlignment(Qt::AlignRight);\n    ui->m_timeLayout->addWidget(exitButton, 0, 0);*/\n    // \u5224\u65ad\u7cfb\u7edf\u662f\u5426\u4e3a GXDE\n    if(QFile::exists(\"/etc/profile.d/gxde.sh\")) {\n        // \u5982\u679c\u662f\u5219\u663e\u793a logo\n        ui->m_iconShow->setMinimumWidth(ui->m_iconShow->height()); // \u4ee5\u4fbf\u53ef\u4ee5\u6b63\u786e\u663e\u793a\u56fe\u6807\n    }\n    else {\n        ui->m_iconShow->setVisible(false);\n        ui->m_systemName->setText(\"\u00a92023\uff5e\" + QDateTime::currentDateTime().toString(\"yyyy\") + \" gfdgd xi\");\n        ui->m_systemName->setAlignment(Qt::AlignBottom);\n\n    }\n    // \u53e5\u5b50\u66f4\u65b0 QTimer\n    m_updateSentencesTimer = new QTimer();\n    m_updateSentencesTimer->setInterval(60 * 1000);\n    connect(m_updateSentencesTimer, &QTimer::timeout, this, &MainWindow::ChangePoem);\n    m_updateSentencesTimer->start();\n    // \u8bfb\u53d6\u79bb\u7ebf\u8bcd\u5e93\n    QFile sentence(\":/Poem/poem.json\");\n    sentence.open(QFile::ReadOnly);\n    offLineSentence = QJsonDocument::fromJson(sentence.readAll()).array();\n    offLineSentence_count = offLineSentence.count(); // \u63d0\u524d\u8ba1\u7b97\u6570\u636e\u4ee5\u51cf\u5c11\u635f\u8017\n    sentence.close();\n    ChangePoem();\n}\n\nQSize MainWindow::mapFromHandle(const QSize &handleSize)\n{\n    qreal ratio = devicePixelRatioF();\n    qDebug() << \"parent window handle size\" << handleSize << \"devicePixelRatio\" << ratio;\n\n    if (ratio > 0 && ratio != 1.0)\n        return handleSize / ratio;\n    else\n        return handleSize;\n}\n\nbool MainWindow::nativeEventFilter(const QByteArray &eventType, void *message, long *result)\n{\n    Q_UNUSED(result);\n    if (eventType == \"xcb_generic_event_t\") {\n        xcb_generic_event_t *event = reinterpret_cast<xcb_generic_event_t *>(message);\n        int type = (event->response_type & ~0x80);\n        if (XCB_CONFIGURE_NOTIFY == type) {\n            xcb_configure_notify_event_t *ce = reinterpret_cast<xcb_configure_notify_event_t *>(event);\n            qInfo() << \"parent window size changed\" << ce->width << ce->height;\n            QSize widSize = mapFromHandle(QSize(ce->width, ce->height));\n            if (widSize != size()) {\n                qInfo() << \"update window size:\" << widSize;\n                resize(widSize);\n            }\n        } else if (XCB_DESTROY_NOTIFY == type) {\n            xcb_destroy_notify_event_t *ce = reinterpret_cast<xcb_destroy_notify_event_t *>(event);\n            if (ce->window == Window(this->windowHandle()->winId())) {\n                qInfo() << \"parent window closed\";\n                QMetaObject::invokeMethod(this, \"close\", Qt::QueuedConnection);\n            }\n        }\n    }\n    return false;\n}\n\nvoid MainWindow::ChangePoem()\n{\n    QUrl url(\"https://v1.hitokoto.cn/?c=d&c=i&c=k\");\n    QUrlQuery query;\n    query.addQueryItem(\"type\", \"DESKDICT\");\n    query.addQueryItem(\"c\", \"d\");\n    query.addQueryItem(\"c\", \"i\");\n    query.addQueryItem(\"c\", \"k\");\n    query.addQueryItem(\"num\", \"4\");\n    query.addQueryItem(\"ver\", \"2.0\");\n    query.addQueryItem(\"le\", \"eng\");\n    query.addQueryItem(\"doctype\", \"json\");\n    url.setQuery(query.toString(QUrl::FullyEncoded));\n    qDebug() << url;\n    QNetworkRequest request(url);\n    QNetworkAccessManager *m_http = new QNetworkAccessManager(this);\n    QNetworkReply *reply = m_http->get(request);\n    connect(reply, &QNetworkReply::finished, this, [this, m_http](){\n        QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());\n        if (reply->error() != QNetworkReply::NoError) {\n            qDebug() << reply->errorString();\n            GetSentenceOffLine(); // \u5982\u679c\u65e0\u6cd5\u8bbf\u95ee\u5219\u4f7f\u7528\u79bb\u7ebf\u6570\u636e\u5e93\n            return;\n        }\n        QByteArray data = reply->readAll();\n        qDebug() << data;\n        // \u89e3\u6790\u6570\u636e\n        // \u6570\u636e\u4f8b\u5b50\uff1a\n        /*\n        {\n            \"id\": 6256,\n            \"uuid\": \"b2f3834f-5f52-4b62-bb3c-f9fb98901419\",\n            \"hitokoto\": \"\u6211\u4eec\u5728\u52aa\u529b\u6269\u5927\u81ea\u5df1\uff0c\u4ee5\u9760\u8fd1\uff0c\u4ee5\u89e6\u53ca\u6211\u4eec\u81ea\u8eab\u4ee5\u5916\u7684\u4e16\u754c\u3002\",\n            \"type\": \"k\",\n            \"from\": \"",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "// local includes\n#include \"tests/conftest.cpp\"\n\nTEST(LoggingTest, LogLevelVerbose) {\n  using level = display_device::logger_t::log_level_e;\n  auto &logger { display_device::logger_t::get() };\n\n  logger.set_log_level(level::verbose);\n\n  EXPECT_EQ(logger.is_log_level_enabled(level::verbose), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::debug), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::info), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::warning), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::error), true);\n}\n\nTEST(LoggingTest, LogLevelDebug) {\n  using level = display_device::logger_t::log_level_e;\n  auto &logger { display_device::logger_t::get() };\n\n  logger.set_log_level(level::debug);\n\n  EXPECT_EQ(logger.is_log_level_enabled(level::verbose), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::debug), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::info), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::warning), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::error), true);\n}\n\nTEST(LoggingTest, LogLevelInfo) {\n  using level = display_device::logger_t::log_level_e;\n  auto &logger { display_device::logger_t::get() };\n\n  logger.set_log_level(level::info);\n\n  EXPECT_EQ(logger.is_log_level_enabled(level::verbose), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::debug), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::info), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::warning), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::error), true);\n}\n\nTEST(LoggingTest, LogLevelWarning) {\n  using level = display_device::logger_t::log_level_e;\n  auto &logger { display_device::logger_t::get() };\n\n  logger.set_log_level(level::warning);\n\n  EXPECT_EQ(logger.is_log_level_enabled(level::verbose), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::debug), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::info), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::warning), true);\n  EXPECT_EQ(logger.is_log_level_enabled(level::error), true);\n}\n\nTEST(LoggingTest, LogLevelError) {\n  using level = display_device::logger_t::log_level_e;\n  auto &logger { display_device::logger_t::get() };\n\n  logger.set_log_level(level::error);\n\n  EXPECT_EQ(logger.is_log_level_enabled(level::verbose), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::debug), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::info), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::warning), false);\n  EXPECT_EQ(logger.is_log_level_enabled(level::error), true);\n}\n\nTEST(LoggingTest, DefaultLogger) {\n  using level = display_device::logger_t::log_level_e;\n  auto &logger { display_device::logger_t::get() };\n\n  const auto write_and_get_cout { [this, &logger](level level, std::string value) -> std::string {\n    this->cout_buffer.str(std::string {});  // reset the buffer\n    logger.write(level, std::move(value));\n    return this->cout_buffer.str();\n  } };\n\n  logger.set_log_level(level::verbose);\n  // clang-format off\n  EXPECT_TRUE(test_regex(write_and_get_cout(level::verbose, \"Hello World!\"), R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}\\] VERBOSE: Hello World!\\n)\"));\n  EXPECT_TRUE(test_regex(write_and_get_cout(level::debug, \"Hello World!\"),   R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}\\] DEBUG:   Hello World!\\n)\"));\n  EXPECT_TRUE(test_regex(write_and_get_cout(level::info, \"Hello World!\"),    R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}\\] INFO:    Hello World!\\n)\"));\n  EXPECT_TRUE(test_regex(write_and_get_cout(level::warning, \"Hello World!\"), R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}\\] WARNING: Hello World!\\n)\"));\n  EXPECT_TRUE(test_regex(write_and_get_cout(level::error, \"Hello World!\"),   R\"(\\[\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}\\] ERROR:   Hello World!\\n)\"));\n  // clang-format on\n}\n\nTEST(LoggingTest, CustomCallback) {\n  using level = display_device::logger_t::log_level_e;\n  using level_t = std::underlying_type_t<level>;\n  auto &logger { display_device::logger_t::get() };\n\n  std::string output;\n  logger.set_log_level(level::verbose);\n  logger.set_custom_callback([&output](const level level, const std::string &value) {\n    output = std::to_string(static_cast<level_t>(level)) + \" \" + value;\n  });\n\n  logger.write(level::verbose, \"Hello World!\");\n  EXPECT_EQ(output, \"0 Hello World!\");\n  EXPECT_TRUE(this->cout_buffer.str().empty());\n\n  logger.write(level::debug, \"Hello World!\");\n  EXPECT_EQ(output, \"1 Hello World!\");\n  EXPECT_TRUE(this->cout_buffer.str().empty());\n\n  logger.write(level::info, \"Hello World!\");\n  EXPECT_EQ(output, \"2 Hello World!\");\n  EXPECT_TRUE(this->cout_buffer.str().empty());\n\n  logger.write(level::warning, \"Hello World!\");\n  EXPECT_EQ(output, \"3 Hello World!\");\n  EXPECT_TRUE(this->cout_buffer.str().empty());\n\n  logger.write(level::error, \"Hello World!\");\n  EXPECT_EQ(output, \"4 Hello World!\");\n  EXPECT_TRUE(this->cout_buffer.str().empty());\n}\n\nTEST(LoggingTest, WriteMethodRespectsLogLevelWhenUsingDefaultLogger) {\n  using level = display_d",
    "const int Green = 13;\nconst int Yellow = 12;\nconst int Red = 11;\n\nconst int GroupB[] = {2, 3, 4, 5, 6, 7, 8};\nconst int botao = 10;\n\nvoid setup() {\n  pinMode(Green, OUTPUT);\n  pinMode(Yellow, OUTPUT);\n  pinMode(Red, OUTPUT);\n  for (int i = 0; i < 7; i++) {\n    pinMode(GroupB[i], OUTPUT);\n  }\n  pinMode(botao, INPUT_PULLUP);\n}\n\nvoid loop() {  \n  while (digitalRead(botao) == HIGH) {\n    digitalWrite(Green, HIGH);\n    \n     for (int i = 0; i < 5; i++) {\n      \n      \tfor (int j = 0; j < 7; j++) {\n        digitalWrite(GroupB[j], HIGH);\n        delay(100);\n        digitalWrite(GroupB[j], LOW);\n        delay(200);\n      }      \n    }\n    \n    digitalWrite(Green, LOW);\n    digitalWrite(Yellow, HIGH);\n\n    for (int i = 0; i < 3; i++) {\n      for (int j = 8; j >=0 ; j--) {\n      digitalWrite(GroupB[j], HIGH);\n      delay(800);\n      }   \n      for (int j = 0; j < 7; j++) {\n        digitalWrite(GroupB[j], LOW);\n      }\n    } \n    \n    digitalWrite(Yellow, LOW);\n    digitalWrite(Red, HIGH);\n \t\n    for (int R = 0; R < 3; R++) {\n      for (int u = 0; u < 5; u++) { \n        for (int d = 0; d < 7; d++) {\n          digitalWrite(GroupB[d], HIGH);\n        }\n        delay(300);\n        for (int j = 0; j < 7; j++) {\n          digitalWrite(GroupB[j], LOW);\n        }\n        delay(300);\n      }\n      delay(10000);\n    }\n    \n    digitalWrite(Red, LOW); \n  }\n}",
    "#include <SFML/Graphics.hpp>\r\n#include <iostream>\r\n#include \"Player.h\"\r\n#include \"Ball.h\"\r\n#include <cmath>\r\n#include <vector>\r\n#include <sstream>\r\nint main()\r\n{\r\n    sf::RenderWindow window(sf::VideoMode(950, 900), \"Arcanoid\");\r\n    srand(time(0));\r\n    window.setFramerateLimit(60);\r\n    std::vector<sf::RectangleShape> plitki(100);\r\n    int nPlitok = 0;\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        for (int j = 0; j < 10;j++)\r\n        {\r\n            plitki[nPlitok].setFillColor(sf::Color::Blue);\r\n            plitki[nPlitok].setSize(sf::Vector2f(70, 30));\r\n            plitki[nPlitok].setOutlineThickness(2);\r\n            plitki[nPlitok].setPosition(74*i+120, 34*j+120);\r\n            nPlitok++;\r\n        }\r\n    }\r\n\r\n    \r\n    Player player;\r\n    Ball ball;\r\n    sf::Clock clock;\r\n    sf::Font font;\r\n    \r\n    if (!font.loadFromFile(\"Silkscreen.ttf\")) exit(EXIT_FAILURE);\r\n    \r\n    sf::Text start(\"Press Left Mouse Button \\n\\n\\t\\t  to start\",font,35);\r\n    start.setPosition(217, 500);\r\n    \r\n    sf::Text gameOvertxt(\"Game over\", font, 75);\r\n    gameOvertxt.setFillColor(sf::Color::Red);\r\n    gameOvertxt.setPosition(250, 300);\r\n    \r\n    sf::Text continuetxt(\"Restart\", font, 50);\r\n    continuetxt.setPosition(350,450);\r\n\r\n    sf::Text exittxt(\"Exit\", font, 50);\r\n    exittxt.setPosition(415,525);\r\n    \r\n    sf::Text scoretxt;\r\n    scoretxt.setFont(font);\r\n    scoretxt.setCharacterSize(30);\r\n    scoretxt.setFillColor(sf::Color::White);\r\n    scoretxt.setPosition(740, 30);\r\n    \r\n    sf::Text levelCompletetxt(\"Level complete!\",font,75);\r\n    levelCompletetxt.setPosition(150,300);\r\n    levelCompletetxt.setFillColor(sf::Color::Green);\r\n\r\n    float speedPlayer = 800.f;\r\n    float speedBallX = 6.f;\r\n    float speedBallY = -9.f;\r\n    bool gameStarted = false;\r\n    bool gameOver = false;\r\n    int score= 0;\r\n    bool levelComplete=0;\r\n    \r\n\r\n    while (window.isOpen())\r\n    {\r\n        sf::Event event;\r\n        sf::Time deltaTime = clock.restart();\r\n        float dt = deltaTime.asSeconds();\r\n        while (window.pollEvent(event))\r\n        {\r\n            if (gameStarted==false)\r\n            {\r\n                switch (event.type)\r\n                {\r\n                case sf::Event::Closed:\r\n                    window.close();\r\n                    break;\r\n                case sf::Event::MouseButtonPressed:\r\n                    if (event.mouseButton.button == sf::Mouse::Left && gameStarted == false)\r\n                    {\r\n                        ball.setSpeed(speedBallX, speedBallY);\r\n                        gameStarted = true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n                }\r\n            }\r\n            else \r\n            { \r\n                switch (event.type)\r\n                {\r\n\r\n                    case sf::Event::Closed:\r\n                        window.close();\r\n                        break;\r\n                    case sf::Event::KeyPressed:\r\n                        if (event.key.code == sf::Keyboard::A || event.key.code == sf::Keyboard::Left) player.setSpeed(-dt * speedPlayer);\r\n                        if (event.key.code == sf::Keyboard::D || event.key.code == sf::Keyboard::Right) player.setSpeed(dt * speedPlayer);\r\n                        break;\r\n                    case sf::Event::KeyReleased:\r\n                        if (event.key.code == sf::Keyboard::A || event.key.code == sf::Keyboard::Left) player.setSpeed(0);\r\n                        if (event.key.code == sf::Keyboard::D || event.key.code == sf::Keyboard::Right) player.setSpeed(0);\r\n                        break;\r\n                    case sf::Event::MouseButtonPressed:\r\n                        if (event.mouseButton.button == sf::Mouse::Left)\r\n                        {\r\n                            if (continuetxt.getGlobalBounds().contains(event.mouseButton.x, event.mouseButton.y))\r\n                            {\r\n                                gameOver = false;\r\n                                gameStarted = false;\r\n                                levelComplete = false;\r\n                                ball.setPosition(460,770);\r\n                                player.setPosition(400,800);\r\n                                ball.setSpeed(0, 0);\r\n                                nPlitok = 0;\r\n                                score = 0;\r\n                                std::ostringstream scoreStr;\r\n                                scoretxt.setString(scoreStr.str());\r\n                                for (int i = 0; i < 10; i++)\r\n                                {\r\n                                    for (int j = 0; j < 10; j++)\r\n                                    {  \r\n                                        plitki[nPlitok].setPosition(74 * i + 120, 34 * j + 120);\r\n                                        nPlitok++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (exittxt.getGlobalBounds().contains(event.mouseButt",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* A Bison parser, made by GNU Bison 3.8.2.  */\n\n/* Bison implementation for Yacc-like parsers in C\n\n   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,\n   Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n\n/* As a special exception, you may create a larger work that contains\n   part or all of the Bison parser skeleton and distribute that work\n   under terms of your choice, so long as that work isn't itself a\n   parser generator using the skeleton or a modified version thereof\n   as a parser skeleton.  Alternatively, if you modify or redistribute\n   the parser skeleton itself, you may (at your option) remove this\n   special exception, which will cause the skeleton and the resulting\n   Bison output files to be licensed under the GNU General Public\n   License without this special exception.\n\n   This special exception was added by the Free Software Foundation in\n   version 2.2 of Bison.  */\n\n/* C LALR(1) parser skeleton written by Richard Stallman, by\n   simplifying the original so-called \"semantic\" parser.  */\n\n/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,\n   especially those whose name start with YY_ or yy_.  They are\n   private implementation details that can be changed or removed.  */\n\n/* All symbols defined below should begin with yy or YY, to avoid\n   infringing on user name space.  This should be done even for local\n   variables, as they might otherwise be expanded by user macros.\n   There are some unavoidable exceptions within include files to\n   define necessary library symbols; they are noted \"INFRINGES ON\n   USER NAME SPACE\" below.  */\n\n/* Identify Bison output, and Bison version.  */\n#define YYBISON 30802\n\n/* Bison version string.  */\n#define YYBISON_VERSION \"3.8.2\"\n\n/* Skeleton name.  */\n#define YYSKELETON_NAME \"yacc.c\"\n\n/* Pure parsers.  */\n#define YYPURE 2\n\n/* Push parsers.  */\n#define YYPUSH 1\n\n/* Pull parsers.  */\n#define YYPULL 0\n\n\n\n\n/* First part of user prologue.  */\n#line 1 \"parser.y\"\n\n  #include <iostream>\n  #include <set>\n  #include \"parser.hpp\"\n\n  extern int yylex();\n  void yyerror(YYLTYPE* loc, const char* err);\n  std::string* translate_boolean_str(std::string* boolean_str);\n\n  std::string* target_program;\n  std::set<std::string> symbols;\n  Tree * root;\n\n#line 85 \"parser.cpp\"\n\n# ifndef YY_CAST\n#  ifdef __cplusplus\n#   define YY_CAST(Type, Val) static_cast<Type> (Val)\n#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)\n#  else\n#   define YY_CAST(Type, Val) ((Type) (Val))\n#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))\n#  endif\n# endif\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n#include \"parser.hpp\"\n/* Symbol kind.  */\nenum yysymbol_kind_t\n{\n  YYSYMBOL_YYEMPTY = -2,\n  YYSYMBOL_YYEOF = 0,                      /* \"end of file\"  */\n  YYSYMBOL_YYerror = 1,                    /* error  */\n  YYSYMBOL_YYUNDEF = 2,                    /* \"invalid token\"  */\n  YYSYMBOL_IDENTIFIER = 3,                 /* IDENTIFIER  */\n  YYSYMBOL_BOOLEAN = 4,                    /* BOOLEAN  */\n  YYSYMBOL_INT = 5,                        /* INT  */\n  YYSYMBOL_FLOAT = 6,                      /* FLOAT  */\n  YYSYMBOL_NUMBER = 7,                     /* NUMBER  */\n  YYSYMBOL_STR = 8,                        /* STR  */\n  YYSYMBOL_DECIMAL = 9,                    /* DECIMAL  */\n  YYSYMBOL_BOOL = 10,                      /* BOOL  */\n  YYSYMBOL_INDENT = 11,                    /* INDENT  */\n  YYSYMBOL_DEDENT = 12,                    /* DEDENT  */\n  YYSYMBOL_NEWLINE = 13,                   /* NEWLINE  */\n  YYSYMBOL_NEGATION = 14,                  /* NEGATION  */\n  YYSYMBOL_LIST = 15,                      /* LIST  */\n  YYSYMBOL_NONE = 16,                      /* NONE  */\n  YYSYMBOL_DEF = 17,                       /* DEF  */\n  YYSYMBOL_FOR = 18,                       /* FOR  */\n  YYSYMBOL_IF = 19,                        /* IF  */\n  YYSYMBOL_RANGE = 20,                     /* RANGE  */\n  YYSYMBOL_PLUS = 21,                      /* PLUS  */\n  YYSYMBOL_MINUS = 22,                     /* MINUS  */\n  YYSYMBOL_TIMES = 23,                     /* TIMES  */\n  YYSYMBOL_DIVIDEDBY = 24,                 /* DIVIDEDBY  */\n  YYSYMBOL_INTDIVIDEDBY = 25,              /* INTDIVIDEDBY  */\n  YYSYMBOL_MOD = 26,             ",
    "// Include important C++ libraries here\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\n// Make code easier to type with \"using namespace\"\nusing namespace sf;\nusing namespace std;\n\nint main()\n{\n    // Create a video mode object\n\tVideoMode vm(1920, 1080);\n\t// Create and open a window for the game\n\tRenderWindow window(vm, \"Chaos Game!!\", Style::Default);\n\n    vector<Vector2f> vertices;\n    vector<Vector2f> points;\n\n\tFont font;\n\tif (!font.loadFromFile(\"KOMIKAP_.ttf\"))\n\t{\n\t\tcerr << \"Something wrong with font.\" << endl;\n\t}\n\t\n\tText displayCoords; //new object to show the coordinates to user\n\tdisplayCoords.setFont(font);\n\tdisplayCoords.setCharacterSize(15);\n\tdisplayCoords.setFillColor(Color::White);\n\tdisplayCoords.setPosition(1500.f, 600.f); // need to change coords\n\tstring completestring = \"\";\n\tstring displayvertices;\n\n\n\twhile (window.isOpen())\n\t{\n        /*\n\t\t****************************************\n\t\tHandle the players input\n\t\t****************************************\n\t\t*/\n        Event event;\n\t\twhile (window.pollEvent(event))\n\t\t{\n\n\t\t\n\t\t\tif (event.type == Event::Closed)\n            {\n\t\t\t\t// Quit the game when the window is closed\n\t\t\t\twindow.close();\n            }\n            if (event.type == sf::Event::MouseButtonPressed)\n            {\n\t\t\t\tFont font;\n            \tif (event.mouseButton.button == sf::Mouse::Left)\n                {\n                    std::cout << \"the left button was pressed\" << std::endl;\n                    std::cout << \"mouse x: \" << event.mouseButton.x << std::endl;\n                    std::cout << \"mouse y: \" << event.mouseButton.y << std::endl;\n\n                    if(vertices.size() < 3)\n                    {\n                        vertices.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n\t\t\t\t\t\tdisplayvertices = \"Vertex \" + to_string(vertices.size()) + \"\\nmouse x: \" + to_string(event.mouseButton.x) + \"\\nmouse y: \" + to_string(event.mouseButton.y) +\"\\n\";\n\t\t\t\t\t\tcompletestring = completestring + displayvertices;\n\t\t\t\t\t\tdisplayCoords.setString(completestring);\n                    }\n                    else if(points.size() == 0)\n                    {\n\t\t\tpoints.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n                        ///fourth click\n                        ///push back to points vector\n                    }\n                }\n            }\n        }\n        if (Keyboard::isKeyPressed(Keyboard::Escape))\n\t\t{\n\t\t\twindow.close();\n\t\t}\n        /*\n\t\t****************************************\n\t\tUpdate\n\t\t****************************************\n\t\t*/\n\n        if(points.size() > 0)\n        {\n            ///generate more point(s)\n            ///select random vertex\n            ///calculate midpoint between random vertex and the last point in the vector\n            ///push back the newly generated coord.\n\t    \tfor (int i=0; i<50; i++)\n\t\t\t{\n\t\t\t\tint index=rand() % vertices.size();\n\t\t\t\tVector2f randVertex = vertices[index];\n\n\t\t\t\tVector2f midpoint = (randVertex + points.back())/2.0f;\n\t\t\t\tpoints.push_back(midpoint);\n\n\t\t\t\tRectangleShape rect(Vector2f(5,5));\n\t\t\t\trect.setPosition(midpoint);\n\t\t\t\trect.setFillColor(Color::Red);\n\t\t\t\twindow.draw(rect);\n\t\t\t}\n        }\n\n        /*\n\t\t****************************************\n\t\tDraw\n\t\t****************************************\n\t\t*/\n        window.clear();\n        for(unsigned long long int i = 0; i < vertices.size(); i++)\n        {\n            RectangleShape rect(Vector2f(10,10));\n            rect.setPosition(Vector2f(vertices[i].x, vertices[i].y));\n            rect.setFillColor(Color::Blue);\n            window.draw(rect);\n        }\n\tfor (unsigned long long int i=0; i< points.size();i++){\n\t    RectangleShape rect(Vector2f(5,5));\n\t    rect.setPosition(Vector2f(points[i].x, points[i].y));\n\t    rect.setFillColor(Color::Blue);\n\t    window.draw(rect);\n\t}\n\n    \tText text;\n    \ttext.setFont(font);\n    \ttext.setCharacterSize(25);\n    \ttext.setFillColor(Color::White);\n    \ttext.setPosition(10.f, 10.f);\n    \ttext.setString(\"Click on 3 spots to set up triangle vertices. \\nThen click for the 4th point to start generating the fractal. \");\n\t\t\n\twindow.draw(text);\n\twindow.draw(displayCoords);\n\twindow.display();\n    }\n}\n//Karnpreet Klair and Musa Rana",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Player.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: tkasbari <thomas.kasbarian@gmail.com>      +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/04/12 22:09:10 by vfrants           #+#    #+#             */\n/*   Updated: 2024/04/14 23:36:03 by tkasbari         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../Game.hpp\"\n#include \"Player.hpp\"\n\n#include <algorithm>\n#include <iostream>\n#include <ncurses.h>\n\nPlayer::Player() : _bullets() {}\nPlayer::Player( int health, Point position ) : BaseEntity(health, position, \"\ud83c\udfbe\", 1), _bullets() {}\nPlayer::~Player() {\n\tfor (auto bullet : this->_bullets) {\n\t\tdelete bullet;\n\t}\n\tthis->_bullets.clear();\n}\n\nvoid\tPlayer::shoot( void ) {\n\tthis->_bullets.push_back(new Bullet(this->getPosition(), t_bulletType::PLAYER, PLAYER_BULLET_SPEED));\n}\n\nvoid\tPlayer::goUp( int steps ) {\n\tif (this->getPosition().getY() - steps <= 0)\n\t\treturn ;\n\tthis->setPosition(Point(this->getPosition().getY() - steps, this->getPosition().getX()));\n}\n\nvoid\tPlayer::goDown( int steps ) {\n\tif (this->getPosition().getY() + steps >= BATTLE_HEIGHT - 1)\n\t\treturn ;\n\tthis->setPosition(Point(this->getPosition().getY() + steps, this->getPosition().getX()));\n}\n\nvoid\tPlayer::goLeft( int steps ) {\n\tif (this->getPosition().getX() - steps <= 0)\n\t\treturn ;\n\tthis->setPosition(Point(this->getPosition().getY(), this->getPosition().getX() - steps));\n}\n\nvoid\tPlayer::goRight( int steps ) {\n\tif (this->getPosition().getX() + steps >= SCREEN_WIDTH - 2)\n\t\treturn ;\n\tthis->setPosition(Point(this->getPosition().getY(), this->getPosition().getX() + steps));\n}\n\nstd::vector<Bullet *>\tPlayer::getBullets( void ) {\n\treturn (this->_bullets);\n}\n\nvoid \tPlayer::refreshBullets( int frame ) {\n\tfor (auto bullet : this->_bullets) {\n\t\tbullet->move(frame);\n\t}\n\tfor (auto bullet : this->_bullets) {\n\t\tif (bullet->getPosition().getY() <= 0) {\n\t\t\tauto bulletIt = std::find(this->_bullets.begin(), this->_bullets.end(), bullet);\n\t\t\tdelete *bulletIt;\n\t\t\tthis->_bullets.erase(std::remove(this->_bullets.begin(), this->_bullets.end(), bullet), this->_bullets.end());\n\t\t}\n\t}\n}\n\nvoid\tPlayer::move( size_t ) {}\n\nstd::ostream\t&operator<<( std::ostream &stream, const Player &instance ) {\n\tstream << \"{Player:{\"\n\t\t<< \"health=\" << instance.getHealth()\n\t\t<< \",position=\" << instance.getPosition()\n\t\t<< \"}}\";\n\treturn (stream);\n}\n",
    "#include \"utils.h\"\n#include <time.h>\n\nnamespace utils\n{\n\tstd::string GenRandomStr()\n\t{\n\t\tsrand((unsigned)time(0) * GetCurrentThreadId());\n\n\t\tstatic const int len = 16;\n\t\tstatic char charset[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\t\tchar str[len]{ 0 };\n\t\tfor (int i = 0; i < len - 1; i++)\n\t\t\tstr[i] = charset[rand() % (strlen(charset) - 1)];\n\n\t\treturn str;\n\t}\n\n\tstd::string GenTempPath()\n\t{\n\t\tchar path[MAX_PATH];\n\t\tauto len = GetTempPathA(MAX_PATH, path);\n\t\tif (!len)\n\t\t\treturn \"\";\n\n\t\tif (path[strlen(path) - 1] == L'\\\\')\n\t\t\tpath[strlen(path) - 1] = 0;\n\n\t\treturn std::string(path);\n\t}\n\n\tbool CreateFileFromMemory(const std::string& path, void* data, size_t size)\n\t{\n\t\tDWORD BytesWritten;\n\t\tBOOL result;\n\t\tHANDLE f;\n\t\tif (!data || !size)\n\t\t\treturn false;\n\n\t\tf = CreateFileA(path.c_str(), GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\tif (!IsValidHandle(f))\n\t\t\treturn false;\n\n\t\tresult = WriteFile(f, data, size, &BytesWritten, NULL);\n\t\tCloseHandle(f);\n\n\t\treturn result && (BytesWritten == size);\n\t}\n\n\tbool DeleteFileFromDisk(const std::string& path)\n\t{\n\t\treturn DeleteFileA(path.c_str());\n\t}\n\n\tbool ReadFileFromMemory(const std::string& path, void* data, size_t dataSize)\n\t{\n\t\tDWORD BytesRead;\n\t\tBOOL result;\n\t\tHANDLE f;\n\t\tif (!data)\n\t\t\treturn false;\n\n\t\tf = CreateFileA(path.c_str(), GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\tif (!IsValidHandle(f))\n\t\t\treturn false;\n\n\t\tresult = ReadFile(f, data, dataSize, &BytesRead, 0);\n\t\tCloseHandle(f);\n\n\t\treturn result && (BytesRead <= dataSize);\n\t}\n\n\t// return = buffer that need to free by caller\n\tPVOID Ntqsi(ULONG klass)\n\t{\n\t\tULONG returnLength = 0;\n\t\tULONG dwBuffer = 0;\n\t\tPVOID pBuffer = 0;\n\t\tNTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)klass, nullptr, 0, &returnLength);\n\n\t\tif (status != 0xC0000004)\n\t\t\treturn 0;\n\n\t\tpBuffer = UAlloc((returnLength + 0x1000));\n\t\tif (!pBuffer)\n\t\t\treturn 0;\n\n\t\tdwBuffer = returnLength + 0x1000;\n\t\tstatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0xB, pBuffer, dwBuffer, &returnLength);\n\t\tif (!NT_SUCCESS(status))\n\t\t{\n\t\t\tUFree(pBuffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn pBuffer;\n\t}\n\n\tPVOID GetKernelModule(LPCSTR moduleName, SIZE_T * size)\n\t{\n\t\tPVOID modbase = 0;\n\t\tauto pSystemModules = (PSYSTEM_MODULE_INFORMATION)Ntqsi(0xB); // systemModuleInformation\n\t\tif (!pSystemModules)\n\t\t\treturn 0;\n\t\t\n\t\tfor (auto i = 0u; i < pSystemModules->Count; i++)\n\t\t{\n\t\t\tauto pModule = &pSystemModules->Module[i];\n\t\t\tauto name = pModule->FullPathName + pModule->OffsetToFileName;\n\t\t\tif (strstr((char*)name, moduleName))\n\t\t\t{\n\t\t\t\tif (size)\n\t\t\t\t\t*size = pModule->ImageSize;\n\t\t\t\tmodbase = pModule->ImageBase;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tUFree(pSystemModules);\n\t\treturn modbase;\n\t}\n\n\tbool GetPhysicalMemoryRange(std::vector<std::pair<ULONG_PTR, ULONG>>* out)\n\t{\n\t\tULONGLONG MaxPhysicalRange;\n\t\tif (!GetPhysicallyInstalledSystemMemory(&MaxPhysicalRange))\n\t\t\treturn false;\n\t\tMaxPhysicalRange *= 1024;\n\t\tMaxPhysicalRange -= 1;\n\n\t\t// printf(\"[+] Your system max physical address : 0x%llX\\n\", MaxPhysicalRange);\n\n\t\tHKEY hKey;\n\t\tDWORD type, size;\n\t\tUCHAR* data = nullptr;\n\n\t\tauto result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"HARDWARE\\\\RESOURCEMAP\\\\System Resources\\\\Physical Memory\", 0, KEY_READ, &hKey);\n\t\tif (result != ERROR_SUCCESS)\n\t\t\treturn false;\n\n\t\tresult = RegQueryValueExA(hKey, \".Translated\", NULL, &type, NULL, &size);\n\t\tif (result != ERROR_SUCCESS)\n\t\t\treturn false;\n\n\t\tdata = new UCHAR[size];\n\t\tif (!data)\n\t\t\treturn false;\n\n\t\tRegQueryValueExA(hKey, \".Translated\", NULL, &type, data, &size);\n\n\t\tauto count = ((_CM_RESOURCE_LIST*)data)->List->PartialResourceList.Count;\n\t\tauto pMemRange = ((_CM_RESOURCE_LIST*)data)->List->PartialResourceList.PartialDescriptors;\n\n\t\tfor (auto i = 0u; i < count; i++)\n\t\t{\n\t\t\tauto physmem = pMemRange[i];\n\t\t\tif (physmem.Memory.OutOfRange(MaxPhysicalRange))\n\t\t\t{\n\t\t\t\t// printf(\"[!] this memory is out of range < %016llX , %08X > \\n\", physmem.Memory.Start, physmem.Memory.Length);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// printf(\"[+] valid physical memory range found < %016llX , %08X > \\n\", physmem.Memory.Start, physmem.Memory.Length);\n\t\t\tout->push_back({ physmem.Memory.Start, physmem.Memory.Length });\n\t\t}\n\t\tdelete[] data;\n\t\tRegCloseKey(hKey);\n\t\treturn true;\n\t}\n}",
    "#include \"Arduino.h\"\r\n#include \"TM1638_Module.h\"\r\n\r\nbyte digit[] = {\r\n 0b00111111,  // 0\r\n 0b00000110,\r\n 0b01011011,\r\n 0b01001111,\r\n 0b01100110,\r\n 0b01101101,\r\n 0b01111101,\r\n 0b00000111,\r\n 0b01111111,\r\n 0b01101111,   // 9\r\n 0b00000000,  // clear all\r\n 0b01000000,  // minus \"-\"\r\n\t};\r\n\r\n\r\n\r\nTM1638_Module::TM1638_Module(const uint8_t strobe,\r\n\tconst uint8_t clock,\r\n\tconst uint8_t data): strobe(strobe),clock(clock),data(data) {\r\n\r\n\t}\r\n\r\nTM1638_Module::~TM1638_Module() \r\n\t{}\r\n\r\nvoid TM1638_Module::init() {\r\n\tpinMode(strobe, OUTPUT);\r\n\tpinMode(clock, OUTPUT);\r\n\tpinMode(data, OUTPUT);\r\n\r\n\tsendCommand(0x8f);  // activate and set brightness to max\r\n\treset();\r\n\t}\r\n\r\nvoid TM1638_Module::sendCommand(uint8_t value)\r\n\t{\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, value);\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nvoid TM1638_Module::tm1638_led(byte pos, byte state) {\r\n\tif ((pos > 7) || (state > 1)) return;\r\n\tsendCommand(0x44);  // set single address\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, (0xc1 + pos * 2)); // 3rd LED\r\n\tshiftOut(data, clock, LSBFIRST, state);\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nvoid TM1638_Module::tm1638_num(byte pos, byte num, bool dp) {\r\n\tif ((pos > 7) || (num > 11)) return;  // 0-9, space, minus/dash\r\n\tbyte out = digit[num];\r\n\tif (dp) out |= 0x80;\r\n\tsendCommand(0x44);  // set single address\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, (0xc0 + pos * 2)); // 3rd LED\r\n\tshiftOut(data, clock, LSBFIRST, out);\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nvoid TM1638_Module::reset()\r\n\t{\r\n\tsendCommand(0x40); // set auto increment mode\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, 0xc0);   // set starting address to 0\r\n\tfor (uint8_t i = 0; i < 16; i++)\r\n\t\t{\r\n\t\tshiftOut(data, clock, LSBFIRST, 0x00);\r\n\t\t}\r\n\tdigitalWrite(strobe, HIGH);\r\n\t}\r\n\r\nuint8_t TM1638_Module::readButtons(void)\r\n\t{\r\n\tuint8_t buttons = 0;\r\n\tdigitalWrite(strobe, LOW);\r\n\tshiftOut(data, clock, LSBFIRST, 0x42);\r\n\r\n\tpinMode(data, INPUT);\r\n\r\n\tfor (uint8_t i = 0; i < 4; i++)\r\n\t\t{\r\n\t\tuint8_t v = shiftIn(data, clock, LSBFIRST) << i;\r\n\t\tbuttons |= v;\r\n\t\t}\r\n\r\n\tpinMode(data, OUTPUT);\r\n\tdigitalWrite(strobe, HIGH);\r\n\treturn buttons;\r\n\t}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <limits>\n\n#include \"TodoList.hpp\"\n\nint main() {\n    TodoList todo_list;\n    \n    int choice;\n    do {\n        std::cout << \"1. Add todo\\n\";\n        std::cout << \"2. List todos\\n\";\n        std::cout << \"3. Mark todo as completed\\n\";\n        std::cout << \"4. Save and exit\\n\";\n\n        while(!(std::cin >> choice)) {\n            std::cin.clear();\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        }\n\n        switch(choice) {\n            case 1: {\n                std::string description;\n                std::cout << \"\\nTodo description: \";\n                std::cin.ignore();\n                std::getline(std::cin, description);\n                todo_list.add_todo(description);\n                std::cout << \"Added \" << description << \" in todo list.\\n\\n\";\n                break;\n            }\n            case 2: {\n                todo_list.display_todo();\n                break;\n            }\n            case 3: {\n                std::cout << \"\\n\";\n                if(todo_list.elements() == 0) {\n                    std::cout << \"Todo list is empty.\\n\\n\";\n                    break;\n                }\n\n                size_t todo_index;\n                do {\n                    std::cout << \"Todo index: \";\n                    while(!(std::cin >> todo_index)) {\n                        std::cin.clear();\n                        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                    }\n                } while(todo_index < 1 || todo_index > todo_list.elements());\n                if(!todo_list[todo_index - 1].get_status()) {\n                    todo_list[todo_index - 1].set_status(true);\n                    std::cout << \"Todo with the index \" << todo_index << \" is now marked as completed.\\n\\n\";\n                } else {\n                    std::cout << \"Todo with the index \" << todo_index << \" is already marked as completed.\\n\\n\";\n                }\n                break;\n            }\n            case 4: {\n                todo_list.save_todo();\n                break;\n            }\n        }\n    } while(choice != 4);\n    return 0;\n}",
    "//\n// Created by MichaelBrunner on 12/04/2024.\n//\n\n#include \"Logger.h\"\n\n#include <utility>\n\nstd::string getCurrentTime() {\n    auto now = std::chrono::system_clock::now();\n    auto in_time_t = std::chrono::system_clock::to_time_t(now);\n    std::tm buf{};\n    localtime_s(&buf, &in_time_t);\n    std::stringstream ss;\n    ss << std::put_time(&buf, \"%Y-%m-%d %X\");\n    return ss.str();\n}\n\nclass Logger : public LoggerInterface {\npublic:\n    explicit Logger(std::string fileName, std::ios_base::openmode mode)\n            : fileName(std::move(fileName)), mode(mode) {\n    }\n\n    Logger(const Logger &other) = delete;\n\n    Logger &operator=(const Logger &other) = delete;\n\n    Logger(Logger &&other) = delete;\n\n    Logger &operator=(Logger &&other) = delete;\n\n    explicit operator bool() const { return file.is_open(); }\n\n    ~Logger() override {\n        if (file.is_open()) { file.close(); }\n    }\n\nprivate:\n    std::ofstream file;\n    std::string fileName;\n    std::ios_base::openmode mode;\n\n    void do_log(const std::string &message) override {\n        file.open(fileName, mode);\n        file << getCurrentTime() << \": \" << message << \"\\n\";\n        file.close();\n    }\n};\n\nLoggerInterface *instance = nullptr;\n\nLoggerInterface *getLogger(std::string const &aFileName) {\n    static auto init = [fileName = aFileName]() {\n        if (!instance)\n            instance = new Logger(fileName, std::ios::out | std::ios::app);\n        return true;\n    }();\n    return instance;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\r\n#include <iostream>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <string>\r\n#include <cmath>\r\n#include <fstream> \r\n#include <sstream> \r\n#include <cmath> \r\n\r\nusing namespace std;\r\n\r\n#define M_PI 3.14159265358979323846\r\n\r\nenum class SeatType {\r\n    ECONOMY,\r\n    BUSINESS,\r\n    FIRST_CLASS\r\n};\r\n\r\nenum class FoodOption {\r\n    VEGETARIAN,\r\n    NON_VEGETARIAN,\r\n    BOTH\r\n};\r\n\r\nclass Seat {\r\npublic:\r\n    SeatType seatType;\r\n    string seatNumber;\r\n\r\n    Seat(SeatType type, const string& number) : seatType(type), seatNumber(number) {}\r\n};\r\n\r\nclass Aircraft {\r\npublic:\r\n    string model;\r\n    size_t economySeats;\r\n    size_t businessSeats;\r\n    size_t firstClassSeats;\r\n\r\n    Aircraft(const string& mdl, size_t economy, size_t business, size_t firstClass)\r\n        : model(mdl), economySeats(economy), businessSeats(business), firstClassSeats(firstClass) {}\r\n};\r\n\r\nclass Airport {\r\npublic:\r\n    string airportCode;\r\n    string airportName;\r\n    string location;\r\n    int runway; // Changed to integer\r\n    double latitude;\r\n    double longitude;\r\n\r\n    Airport(const string& code, const string& name, const string& loc, int rw, double lat, double lon)\r\n        : airportCode(code), airportName(name), location(loc), runway(rw), latitude(lat), longitude(lon) {}\r\n\r\n};\r\n\r\nclass Flight {\r\npublic:\r\n    string flightNumber;\r\n    string departureAirport;\r\n    string destinationAirport;\r\n    string departureTime;\r\n    string departureDay;\r\n    string arrivalTime;\r\n    string arrivalDay;\r\n    Aircraft aircraft;\r\n    vector<Seat> availableSeats;\r\n    FoodOption foodOption;\r\n    unordered_map<string, Airport>& airports; \r\n\r\n    Flight(const string& number, const string& departure, const string& destination,\r\n        const string& depTime, const string& depDay, const string& arrTime, const string& arrDay,\r\n        const Aircraft& ac, FoodOption food, unordered_map<string, Airport>& airportMap)\r\n        : flightNumber(number), departureAirport(departure), destinationAirport(destination),\r\n        departureTime(depTime), departureDay(depDay), arrivalTime(arrTime), arrivalDay(arrDay),\r\n        aircraft(ac), foodOption(food), airports(airportMap) {\r\n            initializeSeats();\r\n        }\r\n\r\n    void displaySeatDetails() const {\r\n        cout << \"Seat Details for \" << flightNumber << \":\" << endl;\r\n\r\n        displaySeatDetailsByClass(SeatType::ECONOMY, \"Economy Class\");\r\n        displaySeatDetailsByClass(SeatType::BUSINESS, \"Business Class\");\r\n        displaySeatDetailsByClass(SeatType::FIRST_CLASS, \"First Class\");\r\n\r\n        cout << endl;\r\n    }\r\n\r\n    double calculateDistance() const {\r\n        // Get departure and destination airports\r\n        auto departureAirportIter = airports.find(departureAirport);\r\n        auto destinationAirportIter = airports.find(destinationAirport);\r\n\r\n        if (departureAirportIter != airports.end() && destinationAirportIter != airports.end()) {\r\n            const Airport& departureAirport = departureAirportIter->second;\r\n            const Airport& destinationAirport = destinationAirportIter->second;\r\n\r\n            // Calculate distance using Haversine formula\r\n            double distance = calculateDistance(departureAirport, destinationAirport);\r\n            return distance;\r\n        } else {\r\n            cerr << \"Error: Departure or destination airport not found.\" << endl;\r\n            return 0.0;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    void displaySeatDetailsByClass(SeatType seatClass, const string& className) const {\r\n        cout << \"   \" << className << \":\" << endl;\r\n        for (const auto& seat : availableSeats) {\r\n            if (seat.seatType == seatClass) {\r\n                cout << \"      \" << seat.seatNumber;\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    void initializeSeats() {\r\n        for (size_t i = 1; i <= aircraft.economySeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::ECONOMY, \"E\" + to_string(i)));\r\n        }\r\n\r\n        for (size_t i = 1; i <= aircraft.businessSeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::BUSINESS, \"B\" + to_string(i)));\r\n        }\r\n\r\n        for (size_t i = 1; i <= aircraft.firstClassSeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::FIRST_CLASS, \"F\" + to_string(i)));\r\n        }\r\n    }\r\n\r\n    double calculateDistance(const Airport& source, const Airport& destination) const {\r\n        // We change radian to degree\r\n        double lat1 = source.latitude * M_PI / 180.0;\r\n        double lon1 = source.longitude * M_PI / 180.0;\r\n        double lat2 = destination.latitude * M_PI / 180.0;\r\n        double lon2 = destination.longitude * M_PI / 180.0;\r\n\r\n        // Earth radius in kilometers\r\n        const double R = 6371.0;\r\n\r\n        // Haversine formula\r\n        double dlon = lon2 - lon1;\r\n        double dlat = lat2 - lat1;\r\n        double a = sin(dlat / 2) * sin(dlat / 2) + cos(lat1) * cos(lat2) * sin(dlon / 2) * sin(dlon / 2);\r\n        double c = 2 * atan2(sqrt(a), sqrt(1 - a));\r\n        double distance =",
    "#include \"../include/t265_realsense_node.h\"\r\n\r\nusing namespace realsense2_camera;\r\n\r\nT265RealsenseNode::T265RealsenseNode(ros::NodeHandle& nodeHandle,\r\n                                     ros::NodeHandle& privateNodeHandle,\r\n                                     rs2::device dev,\r\n                                     const std::string& serial_no) : \r\n                                     BaseRealSenseNode(nodeHandle, privateNodeHandle, dev, serial_no),\r\n                                     _wo_snr(dev.first<rs2::wheel_odometer>()),\r\n                                     _use_odom_in(false) \r\n                                     {\r\n                                         _monitor_options = {RS2_OPTION_ASIC_TEMPERATURE, RS2_OPTION_MOTION_MODULE_TEMPERATURE};\r\n                                         initializeOdometryInput();\r\n                                         handleWarning();\r\n                                     }\r\n\r\nvoid T265RealsenseNode::initializeOdometryInput()\r\n{\r\n    std::string calib_odom_file;\r\n    _pnh.param(\"calib_odom_file\", calib_odom_file, std::string(\"\"));\r\n    if (calib_odom_file.empty())\r\n    {\r\n        ROS_INFO(\"No calib_odom_file. No input odometry accepted.\");\r\n        return;\r\n    }\r\n    std::ifstream calibrationFile(calib_odom_file);\r\n    if (!calibrationFile)\r\n    {\r\n        ROS_FATAL_STREAM(\"calibration_odometry file not found. calib_odom_file = \" << calib_odom_file);\r\n        throw std::runtime_error(\"calibration_odometry file not found\" );\r\n    }\r\n    const std::string json_str((std::istreambuf_iterator<char>(calibrationFile)),\r\n        std::istreambuf_iterator<char>());\r\n    const std::vector<uint8_t> wo_calib(json_str.begin(), json_str.end());\r\n\r\n    if (!_wo_snr.load_wheel_odometery_config(wo_calib))\r\n    {\r\n        ROS_FATAL_STREAM(\"Format error in calibration_odometry file: \" << calib_odom_file);\r\n        throw std::runtime_error(\"Format error in calibration_odometry file\" );\r\n    }\r\n    _use_odom_in = true;\r\n}\r\n\r\nvoid T265RealsenseNode::toggleSensors(bool enabled)\r\n{\r\n  ROS_WARN_STREAM(\"toggleSensors method not implemented for T265\");\r\n}\r\n\r\nvoid T265RealsenseNode::publishTopics()\r\n{\r\n    BaseRealSenseNode::publishTopics();\r\n    setupSubscribers();\r\n}\r\n\r\nvoid  T265RealsenseNode::handleWarning()\r\n{\r\n    rs2::log_to_callback( rs2_log_severity::RS2_LOG_SEVERITY_WARN, [&]\r\n      ( rs2_log_severity severity, rs2::log_message const & msg ) noexcept {\r\n        _T265_fault =  msg.raw();\r\n        std::array<std::string, 2> list_of_fault{\"SLAM_ERROR\", \"Stream transfer failed, exiting\"};\r\n        auto it = std::find_if(begin(list_of_fault), end(list_of_fault),\r\n                  [&](const std::string& s) {return _T265_fault.find(s) != std::string::npos; });\r\n        if (it != end(list_of_fault))\r\n        {\r\n          callback_updater.add(\"Warning \",this, & T265RealsenseNode::warningDiagnostic);\r\n          callback_updater.force_update();\r\n        }\r\n    });\r\n}\r\n\r\nvoid T265RealsenseNode::setupSubscribers()\r\n{\r\n    if (!_use_odom_in) return;\r\n\r\n    std::string topic_odom_in;\r\n    _pnh.param(\"topic_odom_in\", topic_odom_in, DEFAULT_TOPIC_ODOM_IN);\r\n    ROS_INFO_STREAM(\"Subscribing to in_odom topic: \" << topic_odom_in);\r\n\r\n    _odom_subscriber = _node_handle.subscribe(topic_odom_in, 1, &T265RealsenseNode::odom_in_callback, this);\r\n}\r\n\r\nvoid T265RealsenseNode::odom_in_callback(const nav_msgs::Odometry::ConstPtr& msg)\r\n{\r\n    ROS_DEBUG(\"Got in_odom message\");\r\n    rs2_vector velocity {-(float)(msg->twist.twist.linear.y),\r\n                          (float)(msg->twist.twist.linear.z),\r\n                         -(float)(msg->twist.twist.linear.x)};\r\n\r\n    ROS_DEBUG_STREAM(\"Add odom: \" << velocity.x << \", \" << velocity.y << \", \" << velocity.z);\r\n    _wo_snr.send_wheel_odometry(0, 0, velocity);\r\n}\r\n\r\nvoid T265RealsenseNode::calcAndPublishStaticTransform(const stream_index_pair& stream, const rs2::stream_profile& base_profile)\r\n{\r\n    // Transform base to stream\r\n    tf::Quaternion quaternion_optical;\r\n    quaternion_optical.setRPY(M_PI / 2, 0.0, -M_PI / 2);    //Pose To ROS\r\n    float3 zero_trans{0, 0, 0};\r\n\r\n    ros::Time transform_ts_ = ros::Time::now();\r\n\r\n    rs2_extrinsics ex;\r\n    try\r\n    {\r\n        ex = getAProfile(stream).get_extrinsics_to(base_profile);\r\n    }\r\n    catch (std::exception& e)\r\n    {\r\n        if (!strcmp(e.what(), \"Requested extrinsics are not available!\"))\r\n        {\r\n            ROS_WARN_STREAM(e.what() << \" : using unity as default.\");\r\n            ex = rs2_extrinsics({{1, 0, 0, 0, 1, 0, 0, 0, 1}, {0,0,0}});\r\n        }\r\n        else\r\n        {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    auto Q = rotationMatrixToQuaternion(ex.rotation);\r\n    Q = quaternion_optical * Q * quaternion_optical.inverse();\r\n    float3 trans{ex.translation[0], ex.translation[1], ex.translation[2]};\r\n    if (stream == POSE)\r\n    {\r\n        Q = Q.inverse();\r\n        publish_static_tf(transform_ts_, trans, Q, _frame_id[stream], _base_frame_id);\r\n    }\r\n    else\r\n    {\r\n        publish_static_t",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cmath>\n\nclass City {\n  std::string name;\n  double lat;\n  double lon;\npublic:\n  City(std::string _name=\"\", double _lat=0, double _lon=0):name(_name), lat(_lat), lon(_lon) {}\n\n  std::string get_name(){\n    return name;\n  }\n  double get_lat(){\n    return lat;\n  }\n  double get_lon(){\n    return lon;\n  }\n\n  void set_name(std::string _name){\n    name = _name;\n  }\n  void set_lat(double _lat){\n    lat = _lat;\n  }\n  void set_lon(double _lon){\n    lon = _lon;\n  }\n};\n\ndouble distance(City city1, City city2){\n    double lat1 = city1.get_lat();\n    double lat2 = city2.get_lat();\n\n    double lon1 = city1.get_lon();\n    double lon2 = city2.get_lon();\n\n    double dLat = (lat2 - lat1) *\n                  M_PI / 180.0;\n    double dLon = (lon2 - lon1) *\n                  M_PI / 180.0;\n\n    lat1 = (lat1) * M_PI / 180.0;\n    lat2 = (lat2) * M_PI / 180.0;\n\n    double a = pow(sin(dLat / 2), 2) +\n               pow(sin(dLon / 2), 2) *\n               cos(lat1) * cos(lat2);\n    double rad = 6371;\n    double c = 2 * asin(sqrt(a));\n    return rad * c;\n}\n\nint main() {\n  \n  std::ifstream fin(\"data/cities10k.txt\");\n  \n  std::string name;\n  double lat;\n  double lon;\n\n  City city;\n  std::vector<City> cities;\n\n  while(fin>>name>>lat>>lon) {\n\n    city.set_name(name);\n    city.set_lat(lat);\n    city.set_lon(lon);\n\n    cities.push_back(city); \n  }\n\n  double farest_distance = 0;\n  City city_1;\n  City city_2;\n\n  for(int i = 0; i < cities.size()-1; i++){\n    for(int j = i; j < cities.size()-1; j++){\n      double new_distance = distance(cities[i], cities[j]);\n      if(new_distance > farest_distance){\n        farest_distance = new_distance;\n        city_1 = cities[i];\n        city_2 = cities[j];\n      }\n    }\n  }\n\n  std::cout<<\"Farest cities are \"<<city_1.get_name()<<\" and \"<<city_2.get_name()<<\". And the distance between them is \"<<farest_distance<<std::endl;\n\n  return 0;\n}\n",
    "#include <iostream>\n#include \"Date.h\"\n#include <stdexcept>\nusing namespace std;\n\nconst string Date::monthName[13] = {\"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n                              \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n\nconst unsigned int Date::daysPerMonth[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n/*Date::Date(unsigned int y, unsigned int m, unsigned int d)\n{\n    setYear(y);\n    setMonth(m);\n    setDay(d);\n}*/\n\nvoid Date::setYear(unsigned int y)\n{\n    year = y;\n}\n\nunsigned int Date::getYear() const\n{\n    return year;\n}\n\nvoid Date::setMonth(unsigned int m)\n{\n    if(m >= 1 && m <= 12)\n        month = m;\n    else\n        throw std::invalid_argument(\"Invalid month!\");\n}\n\nunsigned int Date::getMonth() const\n{\n    return month;\n}\n\nvoid Date::setDay(unsigned int d)\n{\n    if(checkDay(d))\n        day = d;\n    else\n        throw std::invalid_argument(\"Invalid day for current month and year!\");\n}\n\nunsigned int Date::getDay() const\n{\n    return day;\n}\n\nbool Date::leap(unsigned int testYear)\n{\n    if (testYear % 400 == 0 ||\n       (testYear % 4 == 0 && testYear % 100 != 0))\n       return true;\n    else\n        return false;\n}\n\nbool Date::endOfMonth(unsigned int testDay)\n{\n    if(leap(year) && month == 2)\n        return testDay == 29;\n    else\n        return testDay == Date::daysPerMonth[month];\n}\n\nvoid Date::print() const\n{\n    std::cout << year << \"/\" << month << \"/\" << day << std::endl;\n}\n\nbool Date::checkDay(unsigned int testDay) const\n{\n\n    if(testDay <= daysPerMonth[month])\n        return true;\n    if((month == 2 && testDay == 29) &&\n       (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))\n        return true;\n    return false;\n}\n\nvoid Date::increament()\n{\n    if(!endOfMonth(day))\n        ++day;\n    else if(month != 12)\n    {\n        ++month;\n        day = 1;\n    }\n    else\n    {\n        ++year;\n        month = day = 1;\n    }\n}\n\nDate &Date::operator++()\n{\n    increament();\n    return *this;\n}\nDate Date::operator++(int)\n{\n    Date t = *this;\n    increament();\n    return t;\n}\n\nDate &Date::operator+=(unsigned int daysToAdd)\n{\n    for(unsigned int i = 0; i < daysToAdd; ++i)\n        increament();\n    return *this;\n}\nbool Date::operator==(Date b)\n{\n    if((this->day==b.day))\n        if(this->month==b.month)\n            if(this->getYear()==b.getYear())\n                return true;\n}\n\n\nostream &operator<<(ostream &output, Date date)\n{\n    output << Date::monthName[date.month] << \" \" << date.day << \", \" << date.year;\n    return output;\n}\n\n",
    "#include \"Arduino.h\"\n#include \"MsgService.h\"\n\nString content;\n\nMsgServiceClass MsgService;\n\nbool MsgServiceClass::isMsgAvailable()\n{\n  return msgAvailable;\n}\n\nMsg *MsgServiceClass::receiveMsg()\n{\n  if (msgAvailable)\n  {\n    Msg *msg = currentMsg;\n    msgAvailable = false;\n    currentMsg = NULL;\n    content = \"\";\n    return msg;\n  }\n  else\n  {\n    return NULL;\n  }\n}\n\nvoid MsgServiceClass::init()\n{\n  Serial.begin(9600);\n  content.reserve(256);\n  content = \"\";\n  currentMsg = NULL;\n  msgAvailable = false;\n}\n\nvoid MsgServiceClass::sendMsg(const String &msg)\n{\n  Serial.println(msg);\n}\n\nvoid serialEvent()\n{\n  /* reading the content */\n  while (Serial.available())\n  {\n    char ch = (char)Serial.read();\n    if (ch == '\\n')\n    {\n      MsgService.currentMsg = new Msg(content);\n      MsgService.msgAvailable = true;\n    }\n    else\n    {\n      content += ch;\n    }\n  }\n}\n\nbool MsgServiceClass::isMsgAvailable(Pattern &pattern)\n{\n  return (msgAvailable && pattern.match(*currentMsg));\n}\n\nMsg *MsgServiceClass::receiveMsg(Pattern &pattern)\n{\n  if (msgAvailable && pattern.match(*currentMsg))\n  {\n    Msg *msg = currentMsg;\n    msgAvailable = false;\n    currentMsg = NULL;\n    content = \"\";\n    return msg;\n  }\n  else\n  {\n    return NULL;\n  }\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n// Call by value\nvoid swap_call_by_value(int a, int b) {\n\n    // Swap using 3rd variable\n    int temp;\n\n    temp = a;\n    a = b;\n    b = temp;\n\n    // Swap without using a 3rd variable\n    // b = a + b;\n    // a = b - a;\n    // b = b - a;\n}\n\n// Call by address\nvoid swap_call_by_address(int *a, int *b) {\n    \n    // Swap using 3rd variable\n    int temp;\n\n    temp = *a;\n    *a = *b;\n    *b = temp;\n\n    // Swap without using a 3rd variable\n    // *b = *a + *b;\n    // *a = *b - *a;\n    // *b = *b - *a;\n}\n\n// Call by reference (Only in C++)\n// It is not advised to use Call by reference in large programs as it copy pastes the function in main so it basically becomes a monolithic program\nvoid swap_call_by_reference(int &a, int &b) {\n\n    // Swap using 3rd variable\n    int temp;\n\n    temp = a;\n    a = b;\n    b = temp;\n    \n    // Swap without using a 3rd variable\n    // b = (a + b);\n    // a = b - a;\n    // b = b - a;\n\n}\n\nint main()\n{\n    \n    int x = 37, y = 19;\n\n    swap_call_by_value(x, y);\n    cout<< \"x: \" << x << \" \" << \"y: \" << y << endl;\n\n    swap_call_by_address(&x, &y);\n    cout<< \"x: \" << x << \" \" << \"y: \" << y << endl;\n\n    x = 37;\n    y = 19;\n    swap_call_by_reference(x, y);\n    cout<< \"x: \" << x << \" \" << \"y: \" << y << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <conio.h>\n#include <windows.h>\nusing namespace std;\n\nbool gameOver;//this variable is used to check if the game is over\nconst int width = 20;//width and height of the game\nconst int height = 20;//width and height of the game\nint x, y, fruitX, fruitY, score;//x and y are the coordinates of the head of the snake\nint tailX[100], tailY[100];//tailX and tailY are the coordinates of the tail of the snake\nint nTail;//length of the tail\n\nenum eDirecton { STOP = 0, LEFT, RIGHT, UP, DOWN };\neDirecton dir;\n//this function is used to set up the game\nvoid Setup()\n{\n    gameOver = false;\n    dir = STOP;\n    x = width / 2;\n    y = height / 2;\n    fruitX = rand() % width;\n    fruitY = rand() % height;\n    score = 0;\n}\n//this function is used to draw the game\nvoid Draw()\n{\n    system(\"cls\");//cls is used to clear the screen\n    for (int i = 0; i < width + 2; i++)\n        cout << \"#\";//# is used to print the game\n    cout << endl;//endl is used to move the cursor to the next line\n    //for loop is used to print the game\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            if (j == 0)//this if statement is used to print the game\n                cout << \"#\";\n            if (i == y && j == x)//this if statement is used to print the game\n                cout << \"@\";     // head\n            else if (i == fruitY && j == fruitX)//this if statement is used to print the game\n                cout << \"$\";         // apple\n            else\n            {\n                bool print = false;//this variable is used to print the game\n                for (int k = 0; k < nTail; k++)//for loop is used to print the game\n                {\n                    if (tailX[k] == j && tailY[k] == i)//this if statement is used to print the game\n                    {\n                        cout << \"^\"; print = true; // body\n                    }\n                }\n                if (!print) cout << \" \";//this if statement is used to print the game\n\n            }\n\n            if (j == width - 1)//this if statement is used to print the game\n                cout << \"#\";\n        }\n        cout << endl;\n    }\n\n    for (int i = 0; i < width + 2; i++)//this for loop is used to print the game\n        cout << \"#\";//# is used to print the game\n    cout << endl;\n    cout << \"Score:\" << score << endl;//this cout statement is used to print the game\n}\n//this function is used to take input from the user\nvoid Input()\n{\n    if (_kbhit())\n    {\n        switch (_getch())//this switch statement is used to take input from the user\n        {\n        case 'a' ://this case statement is used to take input from the user\n            dir = LEFT;\n            break;\n        case 'd'://this case statement is used to take input from the user\n            dir = RIGHT;\n            break;\n        case 'w'://this case statement is used to take input from the user\n            dir = UP;\n            break;\n        case 's'://this case statement is used to take input from the user\n            dir = DOWN;\n            break;\n        case 'x'://this case statement is used to take input from the user\n            gameOver = true;\n            break;\n        }\n    }\n}\n//this function is used to move the snake\nvoid algorithm()\n{\n    int prevX = tailX[0];\n    int prevY = tailY[0];\n    int prev2X, prev2Y;\n    tailX[0] = x;\n    tailY[0] = y;\n    for (int i = 1; i < nTail; i++)\n    {\n        prev2X = tailX[i];\n        prev2Y = tailY[i];\n        tailX[i] = prevX;\n        tailY[i] = prevY;\n        prevX = prev2X;\n        prevY = prev2Y;\n    }\n\n    switch (dir)\n    {\n    case LEFT:\n        x--;\n        break;\n    case RIGHT:\n        x++;\n        break;\n    case UP:\n        y--;\n        break;\n    case DOWN:\n        y++;\n        break;\n    default:\n        break;\n    }\n    if (x >= width)\n        x = 0; else if (x < 0) x = width - 1;\n    if (y >= height)\n        y = 0; else if (y < 0) y = height - 1;\n\n    for (int i = 0; i < nTail; i++)\n        if (tailX[i] == x && tailY[i] == y)\n            gameOver = true;\n\n    if (x == fruitX && y == fruitY)\n    {\n        score += 10;\n        fruitX = rand() % width;\n        fruitY = rand() % height;\n        nTail++;\n    }\n}\n//pragrammin in start\nint main()\n{\n    Setup();//this function is used to set up the game\n    while (!gameOver)\n    {\n        Draw();//this function is used to draw the game\n        Input();//this function is used to take input from the user\n        algorithm();//this function is used to move the snake\n        Sleep(40); // Adding a delay to slow down the snake's movement\n    return 0;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "\ufeff#include \"core/trace.hpp\"\r\n#include \"core/network.hpp\"\r\n\r\nint main()\r\n{\r\n\tint choice;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\r\n\t\tstd::cout << R\"(\r\n                                            \r\n                                                            \r\n                 *//                                          \r\n             .*/****/.       ,***************                 \r\n        *****************************************             \r\n      ******(***************************************          \r\n   .********%#***************************************         \r\n   **************************************************.        \r\n        ////**********************//******************        \r\n                ////*************////*****************        \r\n                   ////*******///////****************         \r\n                       //*****///////*********************    \r\n                          ***.          *********     ******* \r\n                        *****        ********             ****\r\n                                                          ****\r\n                                                      ,*****  \r\n                             .*************************       \r\n\r\n\t)\" << '\\n';\r\n\r\n\t\tg_network = std::make_unique<network>();\r\n\t\tg_trace = std::make_unique<trace>();\r\n\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tg_trace->m_fivem_path = g_trace->set_folder(\"Select FiveM Folder which contains FiveM.exe\");\r\n\r\n\t\t\tsystem(\"cls\");\r\n\r\n\t\t\tif (!g_trace->m_fivem_path.empty())\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Selected Folder]  \" << g_trace->m_fivem_path << std::endl;\r\n\t\t\t\tstd::cout << \"  [Launch Build]  \" << g_trace->get_launch_build() << \"\\n\" << std::endl;\r\n\t\r\n\t\t\t\tstd::cout << \"  [1]  :  \" << \"clean traces\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [2]  :  \" << \"enable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [3]  :  \" << \"disable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [4]  :  \" << \"reset fivem path\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [5]  :  \" << \"edit launch options\" << std::endl;\r\n\t\t\t\tstd::cin >> choice;\r\n\r\n\t\t\t\tswitch (choice)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 5:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->set_launch_build();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Error]  :  \" << \"select valid folder for FiveM\" << \"\\n\" << std::endl;\r\n\t\t\t}\r\n\r\n\t\t\tsystem(\"Pause\");\r\n\t\t}\r\n\r\n\t\tsystem(\"Pause\");\r\n\t}\r\n\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"e_commerce_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"pch.h\"\r\n\r\n#include \"ntwdblib.h\"\r\n#include <WinSock2.h>\r\n#include <nb30.h>\r\n\r\n//#include <excpt.h>\r\n\r\n#pragma warning (disable : 4996)\r\n#pragma comment(lib, \"Netapi32.lib\")\r\n\r\n#define  DBCURSOR  cursor_t   // cursor record type\r\n#define  DBHANDLE  void   // generic handle\r\n\r\nLPSTR __cdecl GetConnectionError(PDBPROCESS dbproc, int* lpErr, char** a3);\r\nBOOL __stdcall FreeMemory(PDBPROCESS dbproc, LPVOID lpMem);\r\nint __stdcall GeneralError(PDBPROCESS dbproc, int dbErrCode);\r\nLPVOID __stdcall AllocateHeapMemory(int op, PDBPROCESS dbproc, size_t dwBytes, int zero);\r\nchar* __stdcall dberrstr(unsigned __int16 dbErrCode);\r\nBOOL __stdcall LibMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);\r\nvoid __stdcall tidyproc(PDBPROCESS dbproc);\r\nvoid __stdcall free_rowbuffer(PDBPROCESS dbproc);\r\nint __stdcall CheckEntry(PDBPROCESS dbproc);\r\nretval_t* __stdcall ReturnRequestedRetval(PDBPROCESS dbproc, int length);\r\nBOOL __cdecl ConvertNumericDecimalToDouble(DBNUMERIC* Src, double* lpValue);\r\nint __stdcall bcpRead(PDBPROCESS dbproc, bcp_t* bcp, size_t Size, void* lpBuffer);\r\nint __stdcall bcpInsert(PDBPROCESS dbproc);\r\nint __stdcall bcpLengthConversion(char type, int length, char usertype, int direction);\r\nchar* __stdcall CursorWriteBuf(PDBPROCESS dbproc, int ColumnType, int length, void* Src);\r\nint __cdecl PrepareFullName(PDBPROCESS dbproc, bcp_info_t* bcpinfo, int b);\r\nint __cdecl bcpCmd(PDBPROCESS dbproc, const char* Src, ...);\r\nint __stdcall CursorBuildKeysetSelect(DBCURSOR* hcursor);\r\nint __stdcall CursorVerify(DBCURSOR* cursor, PDBPROCESS dbproc);\r\nint __cdecl InitLocal(HINSTANCE hInstance);\r\nvoid __cdecl clntcomn_init();\r\nvoid __cdecl clntcomn_cleanup();\r\n// Netapi32.lib\r\n\r\n\r\nBYTE ver60[] = { 6,0,0,0,0,0,0,0 };\r\nSecEntry g_SecEntrys = { (DBPROCESS* )-1 ,0,0};\r\nDWORD TlsErrIndex = -1;\r\nHANDLE hGlobalHeap = 0;\r\nint g_fSSPIInit = 0;\r\nchar null_string[4] = { 0 };\r\nint bDtm = 0;\r\nshort UsDefaultTimeFlags = 0;\r\nshort UsDefaultMnyFlags = 0;\r\nHINSTANCE DbHandle = 0;\r\nint DbTimeOut = 0;\r\nPDBPROCESS* DbProcArray = 0;\r\nDBERRHANDLE_PROC DbErrHandler = 0;\r\nDBMSGHANDLE_PROC DbMsgHandler = 0;\r\nPDBPROCESS validdbproc = 0;\r\nshort word_7335B844 = 0;\r\nchar byte_7335B848[32] = { 0 };\r\nLPCVOID pMemMap = 0;\r\nint debug_no_entry = 0;\r\nCRITICAL_SECTION CriticalSection = { 0 };\r\nHKEY hKey = 0;\r\nPSecurityFunctionTableA g_pSecFunctionTable = 0;\r\nCRITICAL_SECTION sspiSection = { 0 };\r\nHMODULE hModule = 0;\r\nDTC_GET_TRANSACTION_MANAGER fnGetTranMan = 0;\r\nCRITICAL_SECTION ErrSem = { 0 };\r\nCRITICAL_SECTION MsgSem = { 0 };\r\nchar DeciSep[8] = { 0 };\r\nchar SMonths[12][7] = {0};\r\nchar byte_7335B954[12] = { 0 };\r\nCRITICAL_SECTION OptionSem = { 0 };\r\nCRITICAL_SECTION bcpCmdSem = { 0 };\r\nint UseClientCursors = 0;\r\nCRITICAL_SECTION DbProcSem = { 0 };\r\nchar ThouSep[8] = { 0 };\r\nchar MnySign[32] = { 0 };\r\nCRITICAL_SECTION UseSem = { 0 };\r\n__int16 DTM_FORMAT = 0;\r\nDWORD DataReadySleep = 0;\r\n__int16 DefaultTimeFlags = 0;\r\nchar DefaultThouSep[32] = { 0 };\r\nchar TimeSep[32] = { 0 };\r\nchar szCol[32] = { 0 };\r\nchar DateSep[32] = { 0 };\r\nchar szSkip[32] = { 0 };\r\nchar TimeStrAm[32] = { 0 };\r\nchar DefaultSMonthsFE[13][7] = {0};\r\nchar DefaultDeciSep[32] = { 0 };\r\n__int16 DefaultMnyFlags = 0;\r\nchar szRow[32] = { 0 };\r\nchar DefaultSMonths[13][7] = { 0 };\r\nchar TimeStrPm[32] = { 0 };\r\n__int16 DefaultDateFlags = 0;\r\nchar DefaultMnySign[32] = { 0 };\r\nint fNTIsRunning = 0;\r\nULONG g_cbMaxToken = 0;\r\n\r\nchar ProgVersion[] = { 1,2,0,0,0};\r\n\r\nBYTE moneys[] = {2, 3, 0, 1};\r\nint mnyradix[] = { 10000, 1000, 100, 10, 0 };\r\nchar DblibName[] = \"MSDBLIB\";\r\nchar TdsVer[] = { 4,2,0,0 };\r\nchar dbon[] = \" on \";\r\nchar dboff[] = \" off \";\r\nint MonthDay[] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 366 };\r\nchar DefaultUsSMonths[][6] = { \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\r\nchar DefaultUsSMonthsFE[][6] = { \"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\" };\r\nchar UsDefaultDateFlags[] = \"J\";\r\nchar UsDefaultMnySign[] = \"$\";\r\nchar UsDefaultDeciSep[] = \".\";\r\nchar UsDefaultThouSep[] = \",\";\r\nint ArC[] = { 6,3,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };\r\nint ArB[] = { 6,9,2,7,6,9,4,9,2,4,0,0,0,0,0,0,0,0,0 };\r\nint ArA[] = { 6,5,6,0,1,7,6,7,9,4,7,4,1,8,2,0,0,0,0 };\r\nchar Offsets[][10] = {\"select\",\"from\",\"table\",\"order\",\"compute\",\"statement\",\"procedure\",\"execute\",\"param\"};\r\nchar ConvertArray[256] = {\r\n\t1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,\r\n\t1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1\r\n};\r\noption_t OptionDict[] = {\r\n\t{   0, 0x11, (char*)\"\",           0,      0},\r\n\t{   1,    9, (char*)\"offse",
    "#define GLEW_STATIC\r\n#include <GL/glew.h>\r\n#include <GLFW/glfw3.h>\r\n#pragma comment(lib,\"../API/GLFW/glfw3.lib\")\r\n#pragma comment(lib,\"../API/GLEW/glew32s.lib\")\r\n#pragma comment(lib,\"Opengl32.lib\")\r\n#include <iostream>\r\n#include <string>\r\n\r\n#include \"imgui.h\"\r\n#include \"imgui_impl_glfw.h\"\r\n#include \"imgui_impl_opengl3.h\"\r\n#include \"GUI.h\"\r\n\r\nGLFWwindow* Windows;\r\n\r\nint main()\r\n{\r\n\tglfwInit();\r\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\r\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\r\n\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\r\n\r\n\tWindows = glfwCreateWindow(900, 800, \"HalfPeople-Imgui\", NULL, NULL);\r\n\r\n\tglfwMakeContextCurrent(Windows);\r\n\tglfwSwapInterval(0);\r\n\r\n\tIMGUI_CHECKVERSION();\r\n\tImGui::CreateContext(NULL);\r\n\tImGuiIO& io = ImGui::GetIO(); (void)io;\r\n\tio.Fonts->AddFontFromFileTTF(\"kaiu.ttf\", 18, NULL, io.Fonts->GetGlyphRangesChineseFull());\r\n\r\n\tio.ConfigFlags |= ImGuiConfigFlags_DockingEnable;\r\n\tio.ConfigFlags |= ImGuiViewportFlags_NoDecoration;\r\n\tio.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;\r\n\tio.ConfigFlags |= ImGuiCol_DockingEmptyBg;\r\n\r\n\tImGui::StyleColorsDark();\r\n\tImGuiStyle& style = ImGui::GetStyle();\r\n\r\n\tImVec4* colors = style.Colors;\r\n\tcolors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.16f, 0.17f, 1.00f);\r\n\tcolors[ImGuiCol_FrameBgHovered] = ImVec4(0.37f, 0.36f, 0.36f, 102.00f);\r\n\tcolors[ImGuiCol_FrameBgActive] = ImVec4(0.10f, 0.10f, 0.10f, 171.00f);\r\n\tcolors[ImGuiCol_TitleBgActive] = ImVec4(0.20f, 0.20f, 0.20f, 255.00f);\r\n\tcolors[ImGuiCol_CheckMark] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);\r\n\tcolors[ImGuiCol_SliderGrab] = ImVec4(0.64f, 0.64f, 0.64f, 1.00f);\r\n\tcolors[ImGuiCol_SliderGrabActive] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);\r\n\tcolors[ImGuiCol_Button] = ImVec4(0.22f, 0.22f, 0.22f, 0.40f);\r\n\tcolors[ImGuiCol_ButtonHovered] = ImVec4(0.29f, 0.29f, 0.29f, 1.00f);\r\n\tcolors[ImGuiCol_ButtonActive] = ImVec4(0.13f, 0.13f, 0.13f, 1.00f);\r\n\tcolors[ImGuiCol_Header] = ImVec4(0.45f, 0.45f, 0.45f, 0.31f);\r\n\tcolors[ImGuiCol_HeaderHovered] = ImVec4(0.55f, 0.55f, 0.55f, 0.80f);\r\n\tcolors[ImGuiCol_HeaderActive] = ImVec4(0.09f, 0.09f, 0.09f, 1.00f);\r\n\tcolors[ImGuiCol_ResizeGrip] = ImVec4(1.00f, 1.00f, 1.00f, 0.20f);\r\n\tcolors[ImGuiCol_ResizeGripHovered] = ImVec4(0.46f, 0.46f, 0.46f, 0.67f);\r\n\tcolors[ImGuiCol_ResizeGripActive] = ImVec4(0.17f, 0.17f, 0.17f, 0.95f);\r\n\tcolors[ImGuiCol_SeparatorActive] = ImVec4(0.42f, 0.42f, 0.42f, 1.00f);\r\n\tcolors[ImGuiCol_SeparatorHovered] = ImVec4(0.50f, 0.50f, 0.50f, 0.78f);\r\n\tcolors[ImGuiCol_TabHovered] = ImVec4(0.45f, 0.45f, 0.45f, 0.80f);\r\n\tcolors[ImGuiCol_TabActive] = ImVec4(0.28f, 0.28f, 0.28f, 1.00f);\r\n\tcolors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.19f, 0.19f, 0.19f, 1.00f);\r\n\tcolors[ImGuiCol_DockingPreview] = ImVec4(0.51f, 0.51f, 0.51f, 0.70f);\r\n\tcolors[ImGuiCol_Tab] = ImVec4(0.21f, 0.21f, 0.21f, 0.86f);\r\n\tcolors[ImGuiCol_TabUnfocused] = ImVec4(0.15f, 0.15f, 0.15f, 0.97f);\r\n\tcolors[ImGuiCol_NavHighlight] = ImVec4(1.00f, 0.40f, 0.13f, 1.00f);\r\n\tcolors[ImGuiCol_TextSelectedBg] = ImVec4(0.45f, 1.00f, 0.85f, 0.35f);\r\n\r\n\tstyle.WindowRounding = 4;\r\n\tstyle.FrameRounding = 4;\r\n\tstyle.GrabRounding = 3;\r\n\tstyle.ScrollbarSize = 7;\r\n\tstyle.ScrollbarRounding = 0;\r\n\r\n\tImGui_ImplGlfw_InitForOpenGL(Windows, true);\r\n\tImGui_ImplOpenGL3_Init(\"#version 330\");\r\n\r\n\twhile (!glfwWindowShouldClose(Windows))\r\n\t{\r\n\t\tglClear(GL_COLOR_BUFFER_BIT);\r\n\r\n\t\tImGui_ImplOpenGL3_NewFrame();\r\n\t\tImGui_ImplGlfw_NewFrame();\r\n\t\tImGui::NewFrame();\r\n\t\tImGui::DockSpaceOverViewport();\r\n\r\n\t\tDrawGUI();\r\n\r\n\t\tImGui::ShowDemoWindow();\r\n\r\n\t\tImGui::Render();\r\n\t\tImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\r\n\r\n\t\tif (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)\r\n\t\t{\r\n\t\t\tGLFWwindow* backup_current_context = glfwGetCurrentContext();\r\n\t\t\tImGui::UpdatePlatformWindows();\r\n\t\t\tImGui::RenderPlatformWindowsDefault();\r\n\t\t\tglfwMakeContextCurrent(backup_current_context);\r\n\t\t}\r\n\r\n\t\tglfwSwapBuffers(Windows);\r\n\t\tglfwPollEvents();\r\n\t}\r\n}",
    "/*\n * SPDX-FileCopyrightText: Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n *\n * Copyright (c) 2019-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Edited by Marcos Luciano\n * https://www.github.com/marcoslucianops\n */\n\n#include \"yolov5Plugins.hpp\"\n#include \"NvInferPlugin.h\"\n#include <cassert>\n#include <iostream>\n#include <memory>\n#define NANCHORS 3\n#define NFEATURES 3\n\nnamespace\n{\n    template <typename T>\n    void write(char *&buffer, const T &val)\n    {\n        *reinterpret_cast<T *>(buffer) = val;\n        buffer += sizeof(T);\n    }\n\n    template <typename T>\n    void read(const char *&buffer, T &val)\n    {\n        val = *reinterpret_cast<const T *>(buffer);\n        buffer += sizeof(T);\n    }\n}\n\n//->\u9759\u6001\u53d8\u91cf\u58f0\u660e\nPluginFieldCollection YoloLayerPluginCreator::mFC{};\nstd::vector<PluginField> YoloLayerPluginCreator::mPluginAttributes;\n\nYoloLayerPluginCreator::YoloLayerPluginCreator() noexcept\n{\n    //->\u4eceONNX\u83b7\u53d6\u53c2\u6570\n    mPluginAttributes.emplace_back(PluginField(\"max_stride\", nullptr, PluginFieldType::kINT32, 1));\n    mPluginAttributes.emplace_back(PluginField(\"num_classes\", nullptr, PluginFieldType::kINT32, 1));\n    mPluginAttributes.emplace_back(PluginField(\"anchors\", nullptr, PluginFieldType::kFLOAT32, NFEATURES * NANCHORS * 2));\n    mPluginAttributes.emplace_back(PluginField(\"prenms_score_threshold\", nullptr, PluginFieldType::kFLOAT32, 1));\n\n    mFC.nbFields = mPluginAttributes.size();  //->PluginField\u7684\u6570\u91cf\n    mFC.fields = mPluginAttributes.data();    //->\u6307\u5411PluginField vector\u6570\u7ec4\u7684\u6307\u9488\n}\n\nYoloLayerPluginCreator::~YoloLayerPluginCreator() noexcept {}   //->\u4e00\u822c\u4e0d\u505a\u4efb\u4f55\u64cd\u4f5c\n\nconst char* YoloLayerPluginCreator::getPluginName() const noexcept { \n    return YOLOLAYER_PLUGIN_NAME;             //->\u83b7\u53d6\u63d2\u4ef6\u540d\u5b57\n}\n\nconst char* YoloLayerPluginCreator::getPluginVersion() const noexcept { \n    return YOLOLAYER_PLUGIN_VERSION;          //->\u83b7\u53d6\u63d2\u4ef6\u7248\u672c\n}\n\nconst PluginFieldCollection* YoloLayerPluginCreator::getFieldNames() noexcept {\n    return &mFC;\n}\n\nconst char* YoloLayerPluginCreator::getPluginNamespace() const noexcept {\n    return mNamespace.c_str();\n}\n\n\nIPluginV2DynamicExt* YoloLayerPluginCreator::createPlugin(const char *name, const PluginFieldCollection *fc) noexcept {\n    /******** \u4ecefc\u83b7\u53d6\u53c2\u6570\uff0c\u5b9e\u4f8b\u5316\u4e00\u4e2aplugin *********/\n    const PluginField *fields = fc->fields;\n    int max_stride = 0;\n    int num_classes = 0;\n    std::vector<float> anchors;\n    float score_threshold = 0.0;\n\n    for (int i = 0; i < fc->nbFields; ++i) {                                    //->\u6839\u636e\u540d\u5b57\u89e3\u6790\u53c2\u6570\n        const char *attrName = fields[i].name;                                  //->\u83b7\u53d6\u540d\u5b57\n        if (!strcmp(attrName, \"max_stride\")) {\n            assert(fields[i].type == PluginFieldType::kINT32);                  //->\u65ad\u8a00\u7c7b\u578b\n            max_stride = *(static_cast<const int*>(fields[i].data));            //->\u53d8\u91cf\u8d4b\u503c\n        }\n        if (!strcmp(attrName, \"num_classes\")) {\n            assert(fields[i].type == PluginFieldType::kINT32);\n            num_classes = *(static_cast<const int*>(fields[i].data));\n        }\n        if (!strcmp(attrName, \"anchors\")) {\n            assert(fields[i].type == PluginFieldType::kFLOAT32);\n            const auto anchors_ptr = static_cast<const float*>(fields[i].data);\n            anchors.assign(anchors_ptr, anchors_ptr + NFEATURES * NANCHORS * 2);\n        }\n        if (!strcmp(attrName, \"prenms_score_threshold\")) {\n            assert(fields[i].type == PluginFieldType::kFLOAT32);\n            score_threshold = *(static_cast<const float *>(fields[i].data));\n        }\n    }\n    return new YoloLayer(max_stride, num_classes, anchors, score_threshold);    //->\u5b9e\u4f8b\u5316plugin\n}\n\nIPluginV2DynamicExt* YoloLayerPluginCreator::deserializePlugin(const char *name, const void *serialData, size_t serialLength) noexcept {\n    std::cout << \"Deserialize yoloLayer plugin: \" << name << std::endl;\n    return new YoloLayer(serialData, serialLength);\n}\n\nvoid YoloLayerPluginCreator::setPluginNamespace(co",
    "#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include <unistd.h>\n\nPyDoc_STRVAR(c_parallelsim_fns_documentation,\n             \"Doc for c_parallelism implemented in C\");\n\n/**\n * Returns the factorial % 1e9+7 for a given number.\n * This is just used to demonstrate any expensive operation.\n */\nint factorial(int val) {\n\tint i;\n\tstruct timeval t1, t2;\n\ttime_t ltime;\n\tstruct tm *tm;\n\tdouble elapsedTime;\n\tlong long int s = 1;\n        gettimeofday(&t1, NULL);\n\n\t/** ------- ACTUAL BUSINESS LOGIC BEGINS ------------------ */\n\tfor (i = val; i >= 1; --i) {\n\t\ts *= i;\n\t\ts %= 1000000007;\n\t}\n\t/** ------- ACTUAL BUSINESS LOGIC ENDS ------------------ */\n\n\t// Calculate elapsed time & log current time\n\tgettimeofday(&t2, NULL);\n\telapsedTime = (t2.tv_sec - t1.tv_sec) * 1000.0;      // sec to ms\n\telapsedTime += (t2.tv_usec - t1.tv_usec) / 1000.0;   // us to ms\n\tltime=time(NULL);\n\ttm = localtime(&ltime);\n\tprintf(\"[%04d-%02d-%02d %02d:%02d:%02d C API] Time taken is %f ms\\n\", elapsedTime, tm->tm_year+1900, tm->tm_mon, \n\t\ttm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n\treturn s;\n}\n\nPyObject* c_factorial(PyObject* self, PyObject* args) {\n    int num;\n    int sol;\n    if (!PyArg_ParseTuple(args, \"i\", &num)) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    sol = factorial(num);\n    Py_END_ALLOW_THREADS\n\n    PyObject* object = PyLong_FromLong(sol);\n    return object;\n}\n\nstatic PyMethodDef c_parallelsim_fns[] = {\n    {\"c_factorial\", c_factorial, METH_VARARGS, \"Calculate factorial in C layer\"},\n    {NULL, NULL, 0, NULL}        /* Sentinel */\n};\n\nPyMODINIT_FUNC\nPyInit_pure_cpp_parallelism(void)\n{\n  static struct PyModuleDef moduledef = {\n      PyModuleDef_HEAD_INIT,                   /* m_base */\n      \"pure_cpp_parallelism\",   /* m_name */\n      c_parallelsim_fns_documentation,            /* m_doc */\n      -1,                                      /* m_size */\n      c_parallelsim_fns,                          /* m_methods */\n      nullptr,                                    /* m_slots */\n      nullptr,                                    /* m_traverse */\n      nullptr,                                    /* m_clear */\n      nullptr                                     /* m_free */\n  };\n  return PyModule_Create(&moduledef);\n}\n\n",
    "#include \"GLout.h\"\n\nvoid processInput(GLFWwindow *window)\n{\n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, true);\n}\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    // make sure the viewport matches the new window dimensions; note that width and \n    // height will be significantly larger than specified on retina displays.\n    glViewport(0, 0, width, height);\n}\n\nvoid GLout(Mat img,vector<vector<point> > mesh,vector<vector<point> > V)\n{\n    int n = img.rows,m = img.cols;\n    \n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); \n\n    GLFWwindow*window = glfwCreateWindow(m,n,\"Out Resizing\",NULL,NULL); //\u521b\u5efa\u4e00\u4e2a\u7a97\u53e3\u5bf9\u8c61\n\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    \n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) //\u521d\u59cb\u5316GLAD\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        exit(0);\n    }\n\n    Shader ourShader(\"E:/c++/wl/src/texture/texture.vs\", \"E:/c++/wl/src/texture/texture.fx\"); \n    \n    // float vertices[] = {\n    //     // positions          // colors           // texture coords\n    //      0.5f,  0.5f, 0.0f,   0.0f, 0.0f, 0.0f,   1.0f, 1.0f, // top right\n    //      0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 0.0f,   1.0f, 0.0f, // bottom right\n    //     -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 0.0f,   0.0f, 0.0f, // bottom left\n    //     -0.5f,  0.5f, 0.0f,   0.0f, 0.0f, 0.0f,   0.0f, 1.0f, // top left \n    //      0.0f,  0.0f, 0.0f,   0.0f, 0.0f, 0.0f,   0.5f, 0.5f  // center\n    // };\n    // unsigned int indices[] = {  \n    //     0, 1, 3, // first triangle\n    //     0, 3, 4  // second triangle\n    // };\n    // float vertices[] = {\n    //     // positions          // colors           // texture coords\n    //      -1.0f, -1.0f, 0.0f,   0.0f, 0.0f, 0.0f,   0.02698413f, 0.11498258f, // bottom left\n    //       0.99365079,-1.00000000, 0.0f,   0.0f, 0.0f, 0.0f,   0.94126981, 0.00000000,  // bottom right\n    //       0.99365079,0.98606277, 0.0f,   0.0f, 0.0f, 0.0f,   0.99206346,0.81533098  // bottom right\n    // };\n    // unsigned int indices[] = {  \n    //     0, 1, 21, // first triangle\n    // };\n    // unsigned int indices[] = {1,20,20*21+20};\n    \n    float vertices[21 * 21 * 8];\n    // float*vertices = new float[21 * 21 * 8];\n    for(int i = 0;i <= 20; ++ i)\n        for(int j = 0;j <= 20; ++ j)\n        {\n            int ii = i,jj = j;\n            // int x = (n - 1) / 20.0 * ii;\n            // if(x > n - 1) x = n - 1;\n            // int y = (m - 1) / 20.0 * jj;\n            // if(y > m - 1) y = m - 1;\n            int x = V[ii][jj].x,y = V[ii][jj].y;\n            // vertices[(ii*21+jj)*8] = (float)2.0*mesh[20-ii][jj].y/m - 1,\n            // vertices[(ii*21+jj)*8 + 1] = (float)2.0*mesh[20-ii][jj].x/n - 1;\n            vertices[(i*21+j)*8] = (float)2.0*y/m - 1,\n            vertices[(i*21+j)*8 + 1] = 1 - (float)2.0*x/n;\n            vertices[(i*21+j)*8 + 2] = (float)0;\n            \n            // vertices[(i*21+j)*8 + 3] = (float)img.at<Vec3b>(mesh[ii][jj].x,mesh[ii][jj].y)[2]/255.0,\n            // vertices[(i*21+j)*8 + 4] = (float)img.at<Vec3b>(mesh[ii][jj].x,mesh[ii][jj].y)[1]/255.0;\n            // vertices[(i*21+j)*8 + 5] = (float)img.at<Vec3b>(mesh[ii][jj].x,mesh[ii][jj].y)[0]/255.0;\n            \n            // vertices[(ii*21+jj)*8 + 6] = (float)1.0*y/m;\n            // vertices[(ii*21+jj)*8 + 7] = (float)1.0*x/n;\n            vertices[(i*21+j)*8 + 6] = (float)1.0*mesh[i][j].y/m;\n            vertices[(i*21+j)*8 + 7] = 1 - (float)1.0*mesh[i][j].x/n;\n        }\n\n    // unsigned int*indices = new unsigned int[20*20*6];\n    unsigned int indices[20*20*6];\n    for(int i = 0;i < 20; ++ i)\n        for(int j = 0;j < 20; ++ j)\n        {\n            int ii = i,jj = j;\n            indices[(i*20+j)*6] = ii*21+j;\n            indices[(i*20+j)*6+1] = ii*21+j+1;\n            indices[(i*20+j)*6+2] = (ii+1)*21+j;\n            indices[(i*20+j)*6+3] = ii*21+j+1;\n            indices[(i*20+j)*6+4] = (ii+1)*21+(j+1);\n            indices[(i*20+j)*6+5] = (ii+1)*21+j;\n        }\n    // for(int i = 0;i < 3; ++ i)\n    // {\n    //     cout <<\"indices: \";\n    //     cout << indices[i] << ' ';cout << endl;\n    //     cout << \"vertices: \";\n    //     for(int j = 0;j < 8;++ j)\n    //     {\n    //         cout <<fixed << setprecision(8) << vertices[indices[i]*8 + j] << ' ';\n    //     }\n    //     cout << endl;\n    // }\n\n    unsigned int VAO,VBO,EBO;\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n    glGenBuffers(1, &EBO);\n    \n    // 1. \u7ed1\u5b9aVAO,VBO\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);  \n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    \n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFF",
    "#include \"video.hpp\"\n\n\nvoid Video::open_video(String a_path) {\n\n\t// Allocate video file context\n\tav_format_ctx = avformat_alloc_context();\n\tif (!av_format_ctx) {\n\t\tUtilityFunctions::printerr(\"Couldn't allocate av format context!\");\n\t\treturn;\n\t}\n\n\t// Open file with avformat\n\tif (avformat_open_input(&av_format_ctx, a_path.utf8(), NULL, NULL)) {\n\t\tUtilityFunctions::printerr(\"Couldn't open video file!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Find stream information\n\tif (avformat_find_stream_info(av_format_ctx, NULL)) {\n\t\tUtilityFunctions::printerr(\"Couldn't find stream info!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Getting the audio and video stream\n\tfor (int i = 0; i < av_format_ctx->nb_streams; i++) {\n\t\tAVCodecParameters* av_codec_params = av_format_ctx->streams[i]->codecpar;\n\n\t\tif (!avcodec_find_decoder(av_codec_params->codec_id))\n\t\t\tcontinue;\n\t\telse if (av_codec_params->codec_type == AVMEDIA_TYPE_AUDIO)\n\t\t\tav_stream_audio = av_format_ctx->streams[i];\n\t\telse if (av_codec_params->codec_type == AVMEDIA_TYPE_VIDEO)\n\t\t\tav_stream_video = av_format_ctx->streams[i];\n\t}\n\n\t// Video Decoder Setup \n\n\t// Setup Decoder codec context\n\tconst AVCodec* av_codec_video = avcodec_find_decoder(av_stream_video->codecpar->codec_id);\n\tif (!av_codec_video) {\n\t\tUtilityFunctions::printerr(\"Couldn't find any codec decoder for video!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Allocate codec context for decoder\n\tav_codec_ctx_video = avcodec_alloc_context3(av_codec_video);\n\tif (av_codec_ctx_video == NULL) {\n\t\tUtilityFunctions::printerr(\"Couldn't allocate codec context for video!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Copying parameters\n\tif (avcodec_parameters_to_context(av_codec_ctx_video, av_stream_video->codecpar)) {\n\t\tUtilityFunctions::printerr(\"Couldn't initialize video codec context!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Open codecs\n\tif (avcodec_open2(av_codec_ctx_video, av_codec_video, NULL)) {\n\t\tUtilityFunctions::printerr(\"Couldn't open video codec!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\n\t// Audio Decoder Setup \n\n\t// Setup Decoder codec context\n\tconst AVCodec* av_codec_audio = avcodec_find_decoder(av_stream_audio->codecpar->codec_id);\n\tif (!av_codec_audio) {\n\t\tUtilityFunctions::printerr(\"Couldn't find any codec decoder for audio!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Allocate codec context for decoder\n\tav_codec_ctx_audio = avcodec_alloc_context3(av_codec_audio);\n\tif (av_codec_ctx_audio == NULL) {\n\t\tUtilityFunctions::printerr(\"Couldn't allocate codec context for audio!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Copying parameters\n\tif (avcodec_parameters_to_context(av_codec_ctx_audio, av_stream_audio->codecpar)) {\n\t\tUtilityFunctions::printerr(\"Couldn't initialize audio codec context!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\t// Open codecs\n\tif (avcodec_open2(av_codec_ctx_audio, av_codec_audio, NULL)) {\n\t\tUtilityFunctions::printerr(\"Couldn't open audio codec!\");\n\t\tclose_video();\n\t\treturn;\n\t}\n\n\tUtilityFunctions::print(\"Working!\");\n\tis_open = true;\n}\n\n\nvoid Video::close_video() {\n\tis_open = false;\n\n\tif (av_format_ctx)\n\t\tavformat_close_input(&av_format_ctx);\n\n\tif (av_codec_ctx_video)\n\t\tavcodec_free_context(&av_codec_ctx_video);\n\tif (av_codec_ctx_audio)\n\t\tavcodec_free_context(&av_codec_ctx_audio);\n}\n\n",
    "#include <iostream>\n\n#include <sophus/test_macros.hpp>\n#include <sophus/formatstring.hpp>\n\nnamespace Sophus {\n\nnamespace {\n\nbool testFormatString() {\n  bool passed = true;\n  SOPHUS_TEST_EQUAL(passed, details::FormatString(), std::string());\n  std::string test_str = \"Hello World!\";\n  SOPHUS_TEST_EQUAL(passed, details::FormatString(test_str.c_str()), test_str);\n  SOPHUS_TEST_EQUAL(passed, details::FormatString(\"Number: %\", 5),\n                    std::string(\"Number: 5\"));\n  SOPHUS_TEST_EQUAL(passed,\n                    details::FormatString(\"Real: % msg %\", 1.5, test_str),\n                    std::string(\"Real: 1.5 msg Hello World!\"));\n  SOPHUS_TEST_EQUAL(passed,\n                    details::FormatString(\n                        \"vec: %\", Eigen::Vector3f(0.f, 1.f, 1.5f).transpose()),\n                    std::string(\"vec:   0   1 1.5\"));\n  SOPHUS_TEST_EQUAL(\n      passed, details::FormatString(\"Number: %\", 1, 2),\n      std::string(\"Number: 1\\nFormat-Warning: There are 1 args unused.\"));\n  return passed;\n}\n\nbool testSmokeDetails() {\n  bool passed = true;\n  std::cout << details::pretty(4.2) << std::endl;\n  std::cout << details::pretty(Vector2f(1, 2)) << std::endl;\n  bool dummy = true;\n  details::testFailed(dummy, \"dummyFunc\", \"dummyFile\", 99,\n                      \"This is just a pratice alarm!\");\n  SOPHUS_TEST_EQUAL(passed, dummy, false);\n\n  double val = transpose(42.0);\n  SOPHUS_TEST_EQUAL(passed, val, 42.0);\n  Matrix<float, 1, 2> row = transpose(Vector2f(1, 7));\n  Matrix<float, 1, 2> expected_row(1, 7);\n  SOPHUS_TEST_EQUAL(passed, row, expected_row);\n\n  optional<int> opt(nullopt);\n  SOPHUS_TEST(passed, !opt);\n\n  return passed;\n}\n\nvoid runAll() {\n  std::cerr << \"Common tests:\" << std::endl;\n  bool passed = testFormatString();\n  passed &= testSmokeDetails();\n  processTestResult(passed);\n}\n\n}  // namespace\n}  // namespace Sophus\n\nint main() { Sophus::runAll(); }\n",
    "#include \"Stdafx.h\"\n#include \"PaperCode.h\"\n#include \"ImGuiHelper.h\"\n\nvoid UIPreference::open() {\n    \n    ImGui::OpenPopup(\"Preference\");\n}\n\nvoid UIPreference::applyChanges() {\n    \n}\n\nvoid UIPreference::close() {\n    ImGui::CloseCurrentPopup();\n}\n\nvoid UIPreference::draw() {\n    ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_AutoSelectNewTabs;\n    if (ImGui::BeginTabBar(\"PreferenceTabs\", tab_bar_flags)) {\n\n        if (ImGui::BeginTabItem(\"General\")) {\n            \n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Toolchain\")) {\n\n            \n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Editor\")) {\n\n            \n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"Theme\")) {\n\n            \n\n            ImGui::EndTabItem();\n        }\n\n        if (ImGui::BeginTabItem(\"File\")) {\n\n            \n\n            ImGui::EndTabItem();\n        }\n\n        ImGui::EndTabBar();\n    }\n\n    float width = ImGui::GetWindowWidth();\n    float height = ImGui::GetWindowHeight();\n\n    ImGui::SetCursorPosX(width - 190);\n    ImGui::SetCursorPosY(height - 45);\n\n    if (ImGui::Button(\"Ok\", ImVec2(80, 25))) {\n        applyChanges();\n        close();\n    }\n    ImGui::SameLine();\n    if (ImGui::Button(\"Cancel\", ImVec2(80, 25))) {\n        close();\n    }\n}\n",
    "#include \"Include/helper/colortext.hpp\"\n\n\nColorText::ColorText()\n{\n\n}\n\n\nQString ColorText::Colors::Hex::Background    = \"#282a36\";\nQString ColorText::Colors::Hex::Foreground    = \"#f8f8f2\";\nQString ColorText::Colors::Hex::Comment       = \"#6272a4\";\nQString ColorText::Colors::Hex::CurrentLine   = \"#44475a\";\n\nQString ColorText::Colors::Hex::Cyan          = \"#8be9fd\";\nQString ColorText::Colors::Hex::Green         = \"#50fa7b\";\nQString ColorText::Colors::Hex::Orange        = \"#ffb86c\";\nQString ColorText::Colors::Hex::Pink          = \"#ff79c6\";\nQString ColorText::Colors::Hex::Purple        = \"#bd93f9\";\nQString ColorText::Colors::Hex::Red           = \"#ff5555\";\nQString ColorText::Colors::Hex::Yellow        = \"#f1fa8c\";\n\nvoid ColorText::SetDraculaDark()\n{\n    ColorText::Colors::Hex::Background    = \"#282a36\";\n    ColorText::Colors::Hex::Foreground    = \"#f8f8f2\";\n    ColorText::Colors::Hex::Comment       = \"#6272a4\";\n    ColorText::Colors::Hex::CurrentLine   = \"#44475a\";\n\n    ColorText::Colors::Hex::Cyan          = \"#8be9fd\";\n    ColorText::Colors::Hex::Green         = \"#50fa7b\";\n    ColorText::Colors::Hex::Orange        = \"#ffb86c\";\n    ColorText::Colors::Hex::Pink          = \"#ff79c6\";\n    ColorText::Colors::Hex::Purple        = \"#bd93f9\";\n    ColorText::Colors::Hex::Red           = \"#ff5555\";\n    ColorText::Colors::Hex::Yellow        = \"#f1fa8c\";\n}\n\nvoid ColorText::SetDraculaLight()\n{\n    // TODO: get white theme\n}\n\nQString ColorText::Color(const QString& color, const QString &text)\n{\n    return \"<span style=\\\"color: \"+ color +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Background(const QString& text)\n{\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Background +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Foreground(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Foreground +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Comment(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Comment +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Cyan(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Cyan +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Green(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Green +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Orange(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Orange +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Pink(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Pink +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Purple(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Purple +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Red(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Red +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Yellow(const QString& text) {\n    return \"<span style=\\\"color: \"+ ColorText::Colors::Hex::Yellow +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::Bold(const QString& text) {\n    return \"<b>\" + text.toHtmlEscaped() + \"</b>\";\n}\n\nQString ColorText::Underline(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline\\\">\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlineBackground(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Background +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlineForeground(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Foreground +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlineComment(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Comment +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlineCyan(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Cyan +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlineGreen(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Green +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlineOrange(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Orange +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlinePink(const QString &text) {\n    return \"<span style=\\\"text-decoration:underline; color: \"+ ColorText::Colors::Hex::Pink +\";\\\" >\" + text.toHtmlEscaped() + \"</span>\";\n}\n\nQString ColorText::UnderlinePurple(const QString &text) {\n    return \"<span style=\\\"text-decoration:underlin",
    "#include <opencv2/opencv.hpp>\n#include<iostream>\n//#include <opencv2/shape.hpp>\n\nusing namespace std;\n//using namespace cv;\n\nint main()\n{\n    cv::Mat image= cv::imread(\"/home/luna/image.png\");\n    if (!image.data)\n        return 0;\n    //cv::namedWindow(\"Image\");\n    //cv::imshow(\"Image\",image);\n\n    // \u5b9a\u4e49\u8fb9\u6846\u77e9\u5f62\n    cv::Rect rectangle(61,78,210,210);\n    // \u5b9a\u4e49\u524d\u666f\u3001\u80cc\u666f\u548c\u5206\u5272\u7ed3\u679c\n    cv::Mat bgModel,fgModel,result;\n\n    // GrabCut\u5206\u5272\n    cv::grabCut(image,\n                result,\n                rectangle,\n                bgModel,\n                fgModel,\n                5,\n                cv::GC_INIT_WITH_RECT); // use rectangle\n\n    // \u6807\u8bb0\u53ef\u80fd\u5c5e\u4e8e\u524d\u666f\u7684\u533a\u57df\n    cv::compare(result,cv::GC_PR_FGD,result,cv::CMP_EQ);\n    // or:\n    //\tresult= result&1;\n    //cv::imshow(\"test\",result);\n    //cv::waitKey(0);\n    // \u521b\u5efa\u524d\u666f\u56fe\u50cf\n    //cv::Mat foreground(image.size(), CV_8UC3, cv::Scalar(0, 0, 0));\n    //image.copyTo(foreground,result); // \u590d\u5236\u524d\u666f\u56fe\u50cf\n\n    // \u5728\u539f\u56fe\u50cf\u7ed8\u5236\u77e9\u5f62\u533a\u57df\n    //cv::rectangle(image, rectangle, cv::Scalar(200,0,200),4);\n    //cv::namedWindow(\"Rectangle\");\n    //cv::imshow(\"Rectangle\",image);\n\n    //cqv::namedWindow(\"Foreground\");\n    //cv::imshow(\"Foreground\",foreground);\n\n    //cv::waitKey();\n    cv::Mat edges;\n    Canny(result, edges, 50, 150, 5);\n    // \u627e\u5230\u6240\u6709\u8f6e\u5ed3\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(edges, contours, cv::RETR_LIST, cv::CHAIN_APPROX_SIMPLE);\n\n    // \u8ba1\u7b97\u6bcf\u4e2a\u8f6e\u5ed3\u7684\u957f\u5ea6\n    std::vector<double> lengths;\n    for (const auto& contour : contours) {\n        lengths.push_back(cv::arcLength(contour, true));\n    }\n\n    // \u8bbe\u7f6e\u957f\u5ea6\u9608\u503c\n    double threshold = 100;\n\n    // \u8fc7\u6ee4\u8f6e\u5ed3\n    std::vector<std::vector<cv::Point>> filtered_contours;\n    for (size_t i = 0; i < contours.size(); ++i) {\n        if (lengths[i] > threshold) {\n            filtered_contours.push_back(contours[i]);\n        }\n    }\n\n    //double length = cv::arcLength(edges, true);\n    // \u7ed8\u5236\u8fc7\u6ee4\u540e\u7684\u8f6e\u5ed3\n    cv::Mat filtered_edges = cv::Mat::zeros(edges.size(), CV_8UC1);\n    cv::drawContours(filtered_edges, filtered_contours, -1, cv::Scalar(255), 1);\n\n    //cv::imshow(\"Edges\", edges);\n    //cv::imshow(\"Filtered Edges\", filtered_edges);\n    //cv::waitKey(0);\n    //cout << edges <<endl;\n\n    cv::Mat gradient_x, gradient_y;\n    Sobel(filtered_edges, gradient_x, CV_32F, 0, 1);\n    Sobel(filtered_edges, gradient_y, CV_32F, 0, 1);\n\n    cv::Mat gradient_magnitude;\n    sqrt(gradient_x.mul(gradient_x) + gradient_y.mul(gradient_y), gradient_magnitude);\n\n    double avg_smoothness = mean(gradient_magnitude)(0);\n    cout << \"Average edge smoothness: \" << avg_smoothness << endl;\n\n    //imshow(\"test\", filtered_edges);\n    //cv::waitKey(0);\n\n    std::string smoothness_str = std::to_string(avg_smoothness);\n    cv::Mat text_image = cv::Mat::zeros(cv::Size(200, 50), CV_8UC3);\n    cv::putText(text_image, smoothness_str, cv::Point(10, 30), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);\n    //imshow(\"test\", text_image);\n    //cv::waitKey(0);\n    cv::Mat sword;\n    //double alpha = 0.7; double beta;\n    //beta = ( 1.0 - alpha );\n    //cv::addWeighted(filtered_edges, 0.5, text_image, 0.3, 0.0, filtered_edges);\n    //addWeighted(filtered_edges, alpha, text_image, beta, 0.0, sword);\n    //imshow(\"test\", filtered_edges);\n    cv::waitKey(0);\n    cv::imwrite(\"/home/luna/text.png\",text_image);\n    cv::imwrite(\"/home/luna/edge.png\",filtered_edges);\n\n    double alpha = 0.5; double beta;\n    cv::Mat src1 = cv::imread(\"/home/luna/text.png\");\n    cv::Mat src2 = cv::imread(\"/home/luna/edge.png\");\n    cv::Mat dst;\n\n    //cout << src2 <<endl;\n    cv::Mat src2_resized;\n    int width = src1.rows;\n    int height = src1.cols;\n    int depth = src1.channels();\n\n    cout << width << endl;\n    cout << height << endl;\n    cout << depth << endl;\n\n    resize(src2, src2_resized, cv::Size(width, height), cv::INTER_LINEAR);\n    //cv::resize(src2, src2_resized, (width,height));\n    beta = (1.0 - alpha);\n    //addWeighted(src1, alpha, src2_resized, beta, 0, src1);\n    imshow(\"mixed image\",filtered_edges);\n    cv::waitKey(0);\n\n    return 0;\n}\n// \u4e3a\u4ec0\u4e48\u8fd9\u91ccaddwidgeted\u603b\u662f\u62a5\u9519\uff0c\u540c\u6837size\u540c\u6837channels.\u9700\u8981\u4e86\u89e3\u6e05\u695a\u3002\n",
    "#include \"bus.h\"\n\nBus::Bus() {\n    this->processors = {};\n    for (int i = 0; i < processors_num; i++) {\n        this->processors.push_back(new Processor(i));\n    }\n\n    this->memory = {};\n    for (int i = 0; i < memory_cells_num; i++) {\n        this->memory.push_back(MemoryLine(i));\n    }\n}\n\nBus::~Bus() {\n    for (auto &proc : processors) delete proc;\n}\n\nvoid Bus::BusInvalidate(short lineAddress, int id) {\n    // \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u043c \u043f\u043e \u0432\u0441\u0435\u043c \u0441\u0442\u0440\u043e\u0447\u043a\u0430\u043c \u043a\u044d\u0448\u0430 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435\n    for (int i = 0; i < processors_num; i++) {\n        if (i == id) continue; // \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440, \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0432\u0448\u0438\u0439 \u0441\u0438\u0433\u043d\u0430\u043b\n        for (int j = 0; j < cache_lines_num; j++) {\n            if (processors[i]->getCache()[j].getAddress() == lineAddress)\n            {\n                processors[i]->getCache()[j].updateState('I');\n                break; // \u0431\u043e\u043b\u044c\u0448\u0435 \u0432 \u044d\u0442\u043e\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0435 \u0442\u0430\u043a\u0438\u0445 \u0441\u0442\u0440\u043e\u043a \u043d\u0435 \u0431\u0443\u0434\u0435\u0442\n            }\n        }\n    }\n    emit updateLog(QString(\"Invalidate \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443 a%1 \u043e\u0442 CPU %2\")\n                .arg(lineAddress).arg(id));\n    emit updateCacheView();\n}\n\n\nvoid Bus::BusRead(short lineAddress, int id) {\n\n    short cache_line_num = processors[id]->getLFUcell(lineAddress);\n\n    // \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0432 \u043f\u0430\u043c\u044f\u0442\u044c \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 M \u0438\u043b\u0438 F\n    if (processors[id]->getCache()[cache_line_num].getState() == 'F' or\n        processors[id]->getCache()[cache_line_num].getState() == 'M')\n    {\n        emit updateLog(QString(\"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0432 \u043f\u0430\u043c\u044f\u0442\u044c \u0430\u0434\u0440\u0435\u0441\u0430 a%1 \u043e\u0442 CPU %2\\n\u041a\u043e\u043d\u0435\u0446 \u0448\u0438\u043d\u043d\u043e\u0433\u043e \u0446\u0438\u043a\u043b\u0430\\n\")\n                       .arg(processors[id]->getCache()[cache_line_num].getAddress()).arg(id));\n        emit endBusCycle();\n        writeDataToMemory(processors[id]->getCache()[cache_line_num].getAddress(),\n                          processors[id]->getCache()[cache_line_num].getData());\n    }\n\n    emit updateLog(QString(\"\u0427\u0442\u0435\u043d\u0438\u0435 \u0430\u0434\u0440\u0435\u0441\u0430 a%1 \u043d\u0430 \u0448\u0438\u043d\u0435 \u043e\u0442 CPU %2\")\n                .arg(lineAddress).arg(id));\n\n    char data = 0;\n    bool read_from_cache = 0;\n    // \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u043c \u043f\u043e \u0432\u0441\u0435\u043c \u0441\u0442\u0440\u043e\u0447\u043a\u0430\u043c \u043a\u044d\u0448\u0430 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435\n    for (int i = 0; i < processors_num; i++) {\n        if (i == id) continue; // \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440, \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0432\u0448\u0438\u0439 \u0441\u0438\u0433\u043d\u0430\u043b\n        for (int j = 0; j < cache_lines_num; j++) {\n            if (processors[i]->getCache()[j].getAddress() == lineAddress and\n                processors[i]->getCache()[j].getState() != 'I')\n            {\n                processors[i]->getCache()[j].updateState('S');\n                data = processors[i]->getCache()[j].getData();\n                read_from_cache = 1;\n\n                emit updateCacheView();\n                emit updateLog(QString(\"\u041d\u0430\u0439\u0434\u0435\u043d \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u0430\u0434\u0440\u0435\u0441 \u0432 \u043a\u044d\u0448\u0435 CPU %1\").arg(i));\n            }\n        }\n    }\n\n    if (!read_from_cache) {\n        data = memory[lineAddress].getData();\n        emit updateLog(QString(\"\u041d\u0435\u0442 \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0432 \u043a\u044d\u0448\u0435 CPU, \u0447\u0442\u0435\u043d\u0438\u0435 \u0438\u0437 \u043f\u0430\u043c\u044f\u0442\u0438\"));\n\n        // \u0437\u0430\u043f\u0438\u0441\u044c data \u0432 \u043a\u044d\u0448\n        writeDataToCache(id, cache_line_num, lineAddress, data, 'E');\n    } else {\n        // \u0437\u0430\u043f\u0438\u0441\u044c data \u0432 \u043a\u044d\u0448\n        writeDataToCache(id, cache_line_num, lineAddress, data, 'F');\n    }\n\n    emit updateCacheView();\n    emit updateLog(\"\u041a\u043e\u043d\u0435\u0446 \u0448\u0438\u043d\u043d\u043e\u0433\u043e \u0446\u0438\u043a\u043b\u0430\\n\");\n    emit endBusCycle();\n}\n\nvoid Bus::BusRWITM(short lineAddress, int id) {\n\n    short cache_line_num = processors[id]->getLFUcell(lineAddress);\n    // \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0432 \u043f\u0430\u043c\u044f\u0442\u044c \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 M \u0438\u043b\u0438 F\n    if (processors[id]->getCache()[cache_line_num].getState() == 'F' or\n        processors[id]->getCache()[cache_line_num].getState() == 'M')\n    {\n        emit updateLog(QString(\"\u041e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0432 \u043f\u0430\u043c\u044f\u0442\u044c \u0430\u0434\u0440\u0435\u0441\u0430 a%1 \u043e\u0442 CPU %2\\n\u041a\u043e\u043d\u0435\u0446 \u0448\u0438\u043d\u043d\u043e\u0433\u043e \u0446\u0438\u043a\u043b\u0430\\n\")\n                       .arg(processors[id]->getCache()[cache_line_num].getAddress()).arg(id));\n        emit endBusCycle();\n        writeDataToMemory(processors[id]->getCache()[cache_line_num].getAddress(),\n                          processors[id]->getCache()[cache_line_num].getData());\n    }\n\n    emit updateLog(QString(\"RWITM \u0430\u0434\u0440\u0435\u0441\u0430 a%1 \u043d\u0430 \u0448\u0438\u043d\u0435 \u043e\u0442 CPU %2\")\n                .arg(lineAddress).arg(id));\n\n    char data = 0;\n    bool read_from_cache = 0;\n    // \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u043c \u043f\u043e \u0432\u0441\u0435\u043c \u0441\u0442\u0440\u043e\u0447\u043a\u0430\u043c \u043a\u044d\u0448\u0430 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435\n    for (int i = 0; i < processors_num; i++) {\n        if (i == id) continue; // \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440, \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0432\u0448\u0438\u0439 \u0441\u0438\u0433\u043d\u0430\u043b\n        for (int j = 0; j < cache_lines_num; j++) {\n            if (processors[i]->getCache()[j].getAddress() == lineAddress and\n                processors[i]->getCache()[j].getState() != 'I')\n            {\n                processors[i]->getCache()[j].updateState('I');\n                data = processors[i]->getCache()[j].getData();\n                emit updateCacheView();\n                read_from_cache = 1;\n\n                emit updateLog(QString(\"Invalidate \u0430\u0434\u0440\u0435\u0441\u0430 a%1 \u0432 \u043a\u044d\u0448\u0435 CPU %2\").arg(lineAddress).arg(i));\n            }\n        }\n    }\n\n    if (!read_from_cache) {\n        data = memory[lineAddress].getData();\n        emit updateLog(QString(\"\u041d\u0435\u0442 \u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0432 \u043a\u044d\u0448\u0435 CPU, \u0447\u0442\u0435\u043d\u0438\u0435 \u0438\u0437 \u043f\u0430\u043c\u044f\u0442\u0438\"));\n    }\n\n    data++; // \u0441\u0447\u0438\u0442\u0430\u043b\u0438 \u043d\u0430 \u0437\u0430\u043f\u0438\u0441\u044c -> \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\n    // \u0437\u0430\u043f\u0438\u0441\u044c data \u0432 \u043a\u044d\u0448\n    writeDataToCache(id, cache_line_num, lineAddress, data, 'M');\n    emit updateLog(\"\u041a\u043e\u043d\u0435\u0446 \u0448\u0438\u043d\u043d\u043e\u0433\u043e \u0446\u0438\u043a\u043b\u0430\\n\");\n",
    "// Copyright 2024 OUXT Polaris. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <gtest/gtest.h>\n\n#include <functional>\n#include <pcl_type_adapter/pcl_type_adapter.hpp>\n\nnamespace pcl_type_adapter\n{\ntemplate <typename PCL_POINTCLOUD_TYPE>\nclass PubNode : public rclcpp::Node\n{\npublic:\n  using AdaptedType =\n    rclcpp::TypeAdapter<std::shared_ptr<PCL_POINTCLOUD_TYPE>, sensor_msgs::msg::PointCloud2>;\n  explicit PubNode(const rclcpp::NodeOptions & options) : Node(\"test\", options)\n  {\n    publisher_ = create_publisher<AdaptedType>(\"pointcloud\", 1);\n  }\n  void publish(const std::shared_ptr<PCL_POINTCLOUD_TYPE> & point_cloud)\n  {\n    publisher_->publish(point_cloud);\n  }\n\nprivate:\n  std::shared_ptr<rclcpp::Publisher<AdaptedType>> publisher_;\n};\n\ntemplate <typename PCL_POINTCLOUD_TYPE>\nclass SubNode : public rclcpp::Node\n{\npublic:\n  using AdaptedType =\n    rclcpp::TypeAdapter<std::shared_ptr<PCL_POINTCLOUD_TYPE>, sensor_msgs::msg::PointCloud2>;\n  explicit SubNode(\n    const rclcpp::NodeOptions & options,\n    const std::function<void(const std::shared_ptr<PCL_POINTCLOUD_TYPE> &)> function)\n  : Node(\"test\", options)\n  {\n    subscriber_ = create_subscription<AdaptedType>(\"pointcloud\", 1, function);\n  }\n\nprivate:\n  std::shared_ptr<rclcpp::Subscription<AdaptedType>> subscriber_;\n};\n\n#define DEFINE_PUB_SUB_TEST(POINT_TYPE)                                                        \\\n  TEST(TypeAdaptaer, POINT_TYPE)                                                               \\\n  {                                                                                            \\\n    bool point_cloud_recieved = false;                                                         \\\n    rclcpp::init(0, nullptr);                                                                  \\\n    rclcpp::NodeOptions options;                                                               \\\n    options.use_intra_process_comms(true);                                                     \\\n    const auto pub_point_cloud =                                                               \\\n      std::shared_ptr<pcl::PointCloud<pcl::POINT_TYPE>>(new pcl::PointCloud<pcl::POINT_TYPE>); \\\n    auto sub_node = std::make_shared<SubNode<pcl::PointCloud<pcl::POINT_TYPE>>>(               \\\n      options, [&](const std::shared_ptr<pcl::PointCloud<pcl::POINT_TYPE>> & point_cloud) {    \\\n        EXPECT_TRUE(pub_point_cloud == point_cloud);                                           \\\n        RCLCPP_INFO_STREAM(rclcpp::get_logger(\"pub : \"), pub_point_cloud);                     \\\n        RCLCPP_INFO_STREAM(rclcpp::get_logger(\"sub : \"), point_cloud);                         \\\n        point_cloud_recieved = true;                                                           \\\n      });                                                                                      \\\n    auto pub_node = std::make_shared<PubNode<pcl::PointCloud<pcl::POINT_TYPE>>>(options);      \\\n    pub_node->publish(pub_point_cloud);                                                        \\\n    rclcpp::executors::SingleThreadedExecutor exec;                                            \\\n    exec.add_node(sub_node);                                                                   \\\n    exec.add_node(pub_node);                                                                   \\\n    exec.spin_some();                                                                          \\\n    rclcpp::shutdown();                                                                        \\\n    EXPECT_TRUE(point_cloud_recieved);                                                         \\\n  }\n\nDEFINE_PUB_SUB_TEST(PointXYZ)\nDEFINE_PUB_SUB_TEST(PointXYZI)\nDEFINE_PUB_SUB_TEST(PointXYZRGB)\nDEFINE_PUB_SUB_TEST(PointXYZRGBA)\n\n#undef DEFINE_PUB_SUB_TEST\n}  // namespace pcl_type_adapter\n\nint main(int argc, char ** argv)\n{\n  testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n",
    "// Copyright 2015 Citra Emulator Project\n// Licensed under GPLv2 or any later version\n// Refer to the license.txt file included.\n\n#include \"common/archives.h\"\n#include \"core/hle/service/cfg/cfg_s.h\"\n\nSERIALIZE_EXPORT_IMPL(Service::CFG::CFG_S)\n\nnamespace Service::CFG {\n\nCFG_S::CFG_S(std::shared_ptr<Module> cfg) : Module::Interface(std::move(cfg), \"cfg:s\", 23) {\n    static const FunctionInfo functions[] = {\n        // cfg common\n        // clang-format off\n        {0x0001, &CFG_S::GetConfig, \"GetConfig\"},\n        {0x0002, &CFG_S::GetRegion, \"GetRegion\"},\n        {0x0003, &CFG_S::GetTransferableId, \"GetTransferableId\"},\n        {0x0004, &CFG_S::IsCoppacsSupported, \"IsCoppacsSupported\"},\n        {0x0005, &CFG_S::GetSystemModel, \"GetSystemModel\"},\n        {0x0006, &CFG_S::GetModelNintendo2DS, \"GetModelNintendo2DS\"},\n        {0x0007, nullptr, \"WriteToFirstByteCfgSavegame\"},\n        {0x0008, nullptr, \"TranslateCountryInfo\"},\n        {0x0009, &CFG_S::GetCountryCodeString, \"GetCountryCodeString\"},\n        {0x000A, &CFG_S::GetCountryCodeID, \"GetCountryCodeID\"},\n        {0x000B, nullptr, \"IsFangateSupported\"},\n        // cfg:s\n        {0x0401, &CFG_S::GetSystemConfig, \"GetSystemConfig\"},\n        {0x0402, &CFG_S::SetSystemConfig, \"SetSystemConfig\"},\n        {0x0403, &CFG_S::UpdateConfigNANDSavegame, \"UpdateConfigNANDSavegame\"},\n        {0x0404, &CFG_S::GetLocalFriendCodeSeedData, \"GetLocalFriendCodeSeedData\"},\n        {0x0405, &CFG_S::GetLocalFriendCodeSeed, \"GetLocalFriendCodeSeed\"},\n        {0x0406, &CFG_S::GetRegion, \"GetRegion\"},\n        {0x0407, &CFG_S::SecureInfoGetByte101, \"SecureInfoGetByte101\"},\n        {0x0408, &CFG_S::SecureInfoGetSerialNo, \"SecureInfoGetSerialNo\"},\n        {0x0409, nullptr, \"UpdateConfigBlk00040003\"},\n        {0x040D, &CFG_S::SetUUIDClockSequence, \"SetUUIDClockSequence\"},\n        {0x040E, &CFG_S::GetUUIDClockSequence, \"GetUUIDClockSequence\"},\n        // clang-format on\n    };\n    RegisterHandlers(functions);\n}\n\n} // namespace Service::CFG\n",
    "#include <chrono>\n#include <cstdlib>\n#include <cstring>\n#include <locale>\n#include <ncurses.h>\n#include <rapidfuzz/fuzz.hpp>\n#include <stdio.h>\n#include <string>\n#include <thread>\n#include <vector>\n\nusing namespace std;\n\n#define INPUT_CURSOR 1\n#define SELECT_CURSOR 2\n#define SELECT_ITEM 3\n#define COLOR_DEFAULT -1\n#define ctrl(x) ((x)&0x1f)\n\ntemplate <typename T>\nstd::vector<T> slice(std::vector<T> const &v, int m, int n) {\n  auto first = v.cbegin() + m;\n  auto last = v.cbegin() + n + 1;\n\n  std::vector<T> vec(first, last);\n  return vec;\n}\n\nvoid delete_str(std::string &text);\nvoid sortFuzzy(std::string query, std::vector<std::string> &items);\nstd::string ffui(std::vector<std::string> items);\n\n// extern \"C\" {\n// \tstring ffui(vector<string> items);\n// }\n\nstring ffui(vector<string> items) {\n  // Initialize\n  WINDOW *win;\n\n  win = initscr();\n  setlocale(LC_ALL, \"\");\n  noecho();\n  nodelay(win, TRUE);\n  curs_set(0);\n  nonl();\n  use_default_colors();\n  start_color();\n\n  // Set color alias\n  init_pair(INPUT_CURSOR, COLOR_CYAN, COLOR_DEFAULT);\n  init_pair(SELECT_CURSOR, COLOR_RED, COLOR_DEFAULT);\n  init_pair(SELECT_ITEM, COLOR_WHITE, COLOR_BLACK);\n\n  int w, h;\n  int cursorPos;\n  // int matchedItemsMaxY;\n  string select_item;\n  string search_query;\n\n  // Y-coordinate of the bottom of the selection\n  int selectMenuUnderY = 3;\n\n  vector<string> matchedItems(items);\n\n  getmaxyx(stdscr, h, w);\n  cursorPos = h - selectMenuUnderY;\n\n  while (true) {\n    // Show items\n    for (int idx = 0; idx < matchedItems.size(); idx++) {\n      if (cursorPos == (h - selectMenuUnderY - idx)) {\n        // hightlight select item\n        attron(COLOR_PAIR(SELECT_ITEM));\n        mvprintw(h - selectMenuUnderY - idx, 3, \"%s\", matchedItems[idx].c_str());\n        select_item = matchedItems[idx];\n        attroff(COLOR_PAIR(SELECT_ITEM));\n      } else {\n        mvprintw(h - selectMenuUnderY - idx, 3, \"%s\", matchedItems[idx].c_str());\n      }\n    }\n\n    int c = getch();\n\n    switch (c) {\n    case ctrl('p'):\n      // cursor up\n      cursorPos = cursorPos - 1;\n      erase();\n      break;\n\n    case ctrl('n'):\n      // cursoe down\n      cursorPos = cursorPos + 1;\n      erase();\n      break;\n\n    case KEY_BACKSPACE:\n      // remove input text\n      delete_str(search_query);\n      break;\n    case KEY_DC:\n      // remove input text\n      delete_str(search_query);\n      break;\n\n    case 127:\n      // remove input text\n      delete_str(search_query);\n      break;\n\n    case ctrl('h'):\n      delete_str(search_query);\n      break;\n\n    case ctrl('u'):\n      search_query.clear();\n      erase();\n      break;\n\n    case '\\r':\n      goto Exit;\n      break;\n\n    case '\\n':\n      goto Exit;\n      break;\n\n    default:\n      if (c == '\\b') {\n        delete_str(search_query);\n        break;\n      } else\n\n          if (c >= 0x00 && c <= 0x7F) {\n        search_query.push_back(c);\n        // fuzzy match and sorting\n        sortFuzzy(search_query, matchedItems);\n      }\n\n      break;\n    }\n\n    // DEBUG\n    // mvprintw(10, 3, select_item.c_str());\n    // mvprintw(12, 3, \"%d\", matchedItems.size());\n    // mvprintw(1, 0, \"%d\", cursorPos);\n    // mvprintw(2, 0, \"%d\", w);\n    // mvprintw(3, 0, \"%d\", matchedItemsMaxY);\n\n\n    // cursorPos top stopper\n    if (cursorPos <= 0) {\n\t    cursorPos = 0;\n    }\n\n\n    // cursorPos under stopper\n    if (cursorPos >= (h - selectMenuUnderY)) {\n      cursorPos = h - selectMenuUnderY;\n    }\n\n    // select cursor\n    attron(COLOR_PAIR(SELECT_CURSOR));\n    mvprintw(cursorPos, 1, \"> \");\n    attroff(COLOR_PAIR(SELECT_CURSOR));\n\n    // input cursor\n    attron(COLOR_PAIR(INPUT_CURSOR));\n    mvprintw(h - 1, 1, \"> \");\n    attroff(COLOR_PAIR(INPUT_CURSOR));\n\n    // mvhline(h - 2, 3, '\u2500', w);\n    string matchedItemsLen = to_string(matchedItems.size());\n\n    if (matchedItemsLen.size() >= 2) {\n      mvprintw(h - 2, 3, \"%s\", matchedItemsLen.c_str());\n      mvprintw(h - 2, 5, \"/\");\n      mvprintw(h - 2, 6, \"%ld\", items.size());\n\n      mvhline(h - 2, 9, '-', w);\n    } else {\n      mvprintw(h - 2, 3, \"%s\", matchedItemsLen.c_str());\n      mvprintw(h - 2, 4, \"/\");\n      mvprintw(h - 2, 5, \"%ld\", items.size());\n\n      mvhline(h - 2, 7, '-', w);\n    }\n\n    mvprintw(h - 1, 3, \"%s\", search_query.c_str());\n    // getstr(&search_query);\n\n    // 60FPS\n    std::this_thread::sleep_for(16ms);\n  }\n\nExit:\n  endwin();\n\n  return select_item.c_str();\n}\n\nvoid delete_str(string &text) {\n  if (text.empty()) {\n    text.clear();\n  } else {\n    text.pop_back();\n  }\n\n  erase();\n}\n\nvoid sortFuzzy(string query, vector<string> &items) {\n  sort(items.begin(), items.end(), [&query](string &a, string &b) {\n    return rapidfuzz::fuzz::ratio(query, a) > rapidfuzz::fuzz::ratio(query, b);\n  });\n}\n",
    "#include <chrono>\r\n#include <thread>\r\n#include <tchar.h>\r\n#include <strsafe.h>\r\n#include <windows.h>\r\n#include <SetupAPI.h>\r\n#include <string>   \r\n#include <iostream> \r\n\r\n#pragma comment(lib, \"Setupapi.lib\")\r\n\r\nBOOLEAN GetDevicePath2(\r\n    _In_ LPCGUID InterfaceGuid,\r\n    _Out_writes_(BufLen) PTCHAR DevicePath,\r\n    _In_ size_t BufLen\r\n)\r\n{\r\n    HANDLE                              hDevice = INVALID_HANDLE_VALUE;\r\n    PSP_DEVICE_INTERFACE_DETAIL_DATA    deviceInterfaceDetailData = NULL;\r\n    ULONG                               predictedLength = 0;\r\n    ULONG                               requiredLength = 0;\r\n    HDEVINFO                            hardwareDeviceInfo;\r\n    SP_DEVICE_INTERFACE_DATA deviceInterfaceData = { 0 };\r\n    BOOLEAN                             status = FALSE;\r\n    HRESULT                             hr;\r\n\r\n    hardwareDeviceInfo = SetupDiGetClassDevs(\r\n        InterfaceGuid,\r\n        NULL, // Define no enumerator (global)\r\n        NULL, // Define no\r\n        (DIGCF_PRESENT | // Only Devices present\r\n            DIGCF_DEVICEINTERFACE)); // Function class devices.\r\n    if (INVALID_HANDLE_VALUE == hardwareDeviceInfo)\r\n    {\r\n        printf(\"Idd device: SetupDiGetClassDevs failed, last error 0x%x\\n\", GetLastError());\r\n        return FALSE;\r\n    }\r\n\r\n    deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\r\n\r\n\r\n    if (!SetupDiEnumDeviceInterfaces(hardwareDeviceInfo,\r\n        0, // No care about specific PDOs\r\n        InterfaceGuid,\r\n        0, //\r\n        &deviceInterfaceData))\r\n    {\r\n        printf(\"Idd device: SetupDiEnumDeviceInterfaces failed, last error 0x%x\\n\", GetLastError());\r\n        goto Clean0;\r\n    }\r\n\r\n    //\r\n    // Allocate a function class device data structure to receive the\r\n    // information about this particular device.\r\n    //\r\n    SetupDiGetDeviceInterfaceDetail(\r\n        hardwareDeviceInfo,\r\n        &deviceInterfaceData,\r\n        NULL, // probing so no output buffer yet\r\n        0, // probing so output buffer length of zero\r\n        &requiredLength,\r\n        NULL);//not interested in the specific dev-node\r\n\r\n    if (ERROR_INSUFFICIENT_BUFFER != GetLastError())\r\n    {\r\n        printf(\"Idd device: SetupDiGetDeviceInterfaceDetail failed, last error 0x%x\\n\", GetLastError());\r\n        goto Clean0;\r\n    }\r\n\r\n    predictedLength = requiredLength;\r\n    deviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(\r\n        GetProcessHeap(),\r\n        HEAP_ZERO_MEMORY,\r\n        predictedLength\r\n    );\r\n\r\n    if (deviceInterfaceDetailData)\r\n    {\r\n        deviceInterfaceDetailData->cbSize =\r\n            sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);\r\n    }\r\n    else\r\n    {\r\n        printf(\"Idd device: HeapAlloc failed, last error 0x%x\\n\", GetLastError());\r\n        goto Clean0;\r\n    }\r\n\r\n    if (!SetupDiGetDeviceInterfaceDetail(\r\n        hardwareDeviceInfo,\r\n        &deviceInterfaceData,\r\n        deviceInterfaceDetailData,\r\n        predictedLength,\r\n        &requiredLength,\r\n        NULL))\r\n    {\r\n        printf(\"Idd device: SetupDiGetDeviceInterfaceDetail failed, last error 0x%x\\n\", GetLastError());\r\n        goto Clean1;\r\n    }\r\n\r\n    hr = StringCchCopy(DevicePath, BufLen, deviceInterfaceDetailData->DevicePath);\r\n    if (FAILED(hr))\r\n    {\r\n        printf(\"Error: StringCchCopy failed with HRESULT 0x%x\", hr);\r\n        status = FALSE;\r\n        goto Clean1;\r\n    }\r\n    else\r\n    {\r\n        status = TRUE;\r\n    }\r\n\r\nClean1:\r\n    (VOID)HeapFree(GetProcessHeap(), 0, deviceInterfaceDetailData);\r\nClean0:\r\n    (VOID)SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);\r\n    return status;\r\n}\r\n\r\nHANDLE DeviceOpenHandle(const GUID& devGuid)\r\n{\r\n    // const int maxDevPathLen = 256;\r\n    TCHAR devicePath[256] = { 0 };\r\n    HANDLE hDevice = INVALID_HANDLE_VALUE;\r\n    do\r\n    {\r\n        if (FALSE == GetDevicePath2(\r\n            &devGuid,\r\n            devicePath,\r\n            sizeof(devicePath) / sizeof(devicePath[0])))\r\n        {\r\n            break;\r\n        }\r\n        if (_tcslen(devicePath) == 0)\r\n        {\r\n            printf(\"GetDevicePath got empty device path\\n\");\r\n            break;\r\n        }\r\n\r\n        _tprintf(_T(\"Idd device: try open %s\\n\"), devicePath);\r\n        hDevice = CreateFile(\r\n            devicePath,\r\n            GENERIC_READ | GENERIC_WRITE,\r\n            // FILE_SHARE_READ | FILE_SHARE_WRITE,\r\n            0,\r\n            NULL, // no SECURITY_ATTRIBUTES structure\r\n            OPEN_EXISTING, // No special create flags\r\n            0, // No special attributes\r\n            NULL\r\n        );\r\n        if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)\r\n        {\r\n            DWORD error = GetLastError();\r\n            printf(\"CreateFile failed 0x%lx\\n\", error);\r\n        }\r\n    } while (0);\r\n\r\n    return hDevice;\r\n}\r\n\r\nenum VddCtlCode\r\n{\r\n    IOCTL_VDD_CONNECT = 0x22A008,\r\n    IOCTL_VDD_ADD = 0x22E004,\r\n    IOCTL_VDD_UPDATE = 0x22A00C,\r\n};\r\n\r\nvoid VddIoCtl(HANDLE vdd, VddCtlCode code)\r\n{\r\n    BYTE InBuffer[32]{};\r\n    int OutBuffer = 0;\r\n    OVERLAPPED Overlapped{}",
    "#include \"WebController.h\"\n\nAsyncWebServer webserver(80);\n\nvoid WebController::begin(){\n    // Initialize the web server\n\n    // Route for root / web page\n    webserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request){\n        request->send(SPIFFS, \"/www/index.html\", \"text/html\");\n    });\n\n    // Route to load style.css file\n    webserver.on(\"/styles.css\", HTTP_GET, [](AsyncWebServerRequest *request){\n        request->send(SPIFFS, \"/www/styles.css\", \"text/css\");\n    });\n\n    // Route to load scripts.js file\n    webserver.on(\"/scripts.js\", HTTP_GET, [](AsyncWebServerRequest *request){\n        request->send(SPIFFS, \"/www/scripts.js\", \"text/javascript\");\n    });\n\n    // GET Endpoints\n    webserver.on(\"/getstate\", HTTP_GET, [this](AsyncWebServerRequest *request) {\n        // Send the response\n        request->send(200, \"application/json\", LightsData());\n    });\n\n    // Route for receiving a POST request on \"/power\"\n    webserver.on(\"/power\", HTTP_POST, [](AsyncWebServerRequest *request) {}, nullptr, [this](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n        // Allocate the JSON document\n        JsonDocument doc;\n\n        // Deserialize the JSON document\n        DeserializationError error = deserializeJson(doc, (const char*)data);\n\n        // Test if parsing succeeds\n        if (error) {\n            TRACELN(F(\"deserializeJson() failed: \"))\n            TRACELN(error.f_str())\n            request->send(400, \"application/json\", R\"({\"message\":\"failed\"})\");\n            return;\n        }\n\n        if (doc[\"power\"] == 1){\n            if (ledController.currentMode == LEDController::ModeOff) {\n                LEDController::On();\n            }\n        }\n        else{\n            if (ledController.currentMode != LEDController::ModeOff) {\n                LEDController::Off();\n            }\n        }\n        request->send(200, \"application/json\", R\"({\"message\":\"success\"})\");\n    });\n\n    // Route for receiving a POST request on \"/brightness\"\n    webserver.on(\"/brightness\", HTTP_POST, [](AsyncWebServerRequest *request) {}, nullptr, [this](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n        // Allocate the JSON document\n        JsonDocument doc;\n\n        // Deserialize the JSON document\n        DeserializationError error = deserializeJson(doc, (const char*)data);\n\n        // Test if parsing succeeds\n        if (error) {\n            TRACELN(F(\"deserializeJson() failed: \"))\n            TRACELN(error.f_str())\n            request->send(400, \"application/json\", R\"({\"message\":\"failed\"})\");\n            return;\n        }\n\n        uint8_t brightness = doc[\"brightness\"];\n\n        if (ledController.currentBrightness != brightness){\n            LEDController::setBrightness(brightness);\n        }\n\n        request->send(200, \"application/json\", R\"({\"message\":\"success\"})\");\n    });\n\n    // Route for receiving a POST request on \"/temperature\"\n    webserver.on(\"/temperature\", HTTP_POST, [](AsyncWebServerRequest *request) {}, nullptr, [this](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n        // Allocate the JSON document\n        JsonDocument doc;\n\n        // Deserialize the JSON document\n        DeserializationError error = deserializeJson(doc, (const char*)data);\n\n        // Test if parsing succeeds\n        if (error) {\n            TRACELN(F(\"deserializeJson() failed: \"))\n            TRACELN(error.f_str())\n            request->send(400, \"application/json\", R\"({\"message\":\"failed\"})\");\n            return;\n        }\n\n        uint16_t temperature = doc[\"temperature\"];\n\n        if (ledController.currentTemperature != temperature){\n            LEDController::setTemperature(temperature);\n        }\n\n        request->send(200, \"application/json\", R\"({\"message\":\"success\"})\");\n    });\n\n    // Route for receiving a POST request on \"/direction\"\n    webserver.on(\"/direction\", HTTP_POST, [](AsyncWebServerRequest *request) {}, nullptr, [this](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n        // Allocate the JSON document\n        JsonDocument doc;\n\n        // Deserialize the JSON document\n        DeserializationError error = deserializeJson(doc, (const char*)data);\n\n        // Test if parsing succeeds\n        if (error) {\n            TRACELN(F(\"deserializeJson() failed: \"))\n            TRACELN(error.f_str())\n            request->send(400, \"application/json\", R\"({\"message\":\"failed\"})\");\n            return;\n        }\n\n        uint8_t direction = doc[\"direction\"];\n\n        if (ledController.currentDirection != direction){\n            LEDController::setDirection(direction);\n        }\n\n        request->send(200, \"application/json\", R\"({\"message\":\"success\"})\");\n    });\n\n    webserver.onNotFound(notFound);\n    webserver.begin();\n}\n\nvoid WebController::notFound(AsyncWebServerRequest *request) {\n    request->send(404, \"text/plain\", \"Not found\");\n}\n\nString WebController::LightsData() con",
    "/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied \nwarranty. In no event will the authors be held liable for any \ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any \npurpose, including commercial applications, and to alter it and \nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n#include \"tinyxml.h\"\n\n// The goal of the seperate error file is to make the first\n// step towards localization. tinyxml (currently) only supports\n// english error messages, but the could now be translated.\n//\n// It also cleans up the code a bit.\n//\n\nconst char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =\n{\n\t\"No error\",\n\t\"Error\",\n\t\"Failed to open file\",\n\t\"Error parsing Element.\",\n\t\"Failed to read Element name\",\n\t\"Error reading Element value.\",\n\t\"Error reading Attributes.\",\n\t\"Error: empty tag.\",\n\t\"Error reading end tag.\",\n\t\"Error parsing Unknown.\",\n\t\"Error parsing Comment.\",\n\t\"Error parsing Declaration.\",\n\t\"Error document empty.\",\n\t\"Error null (0) or unexpected EOF found in input stream.\",\n\t\"Error parsing CDATA.\",\n\t\"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.\",\n};\n",
    "#include\"facerecognizer.h\"\n\nusing namespace cv;\nusing namespace std;\nusing namespace Ort;\n\nFaceEmbdding::FaceEmbdding(string model_path)\n{\n    /// OrtStatus* status = OrtSessionOptionsAppendExecutionProvider_CUDA(sessionOptions, 0);   ///\u5982\u679c\u4f7f\u7528cuda\u52a0\u901f\uff0c\u9700\u8981\u53d6\u6d88\u6ce8\u91ca\n\n    sessionOptions.SetGraphOptimizationLevel(ORT_ENABLE_BASIC);\n    /// std::wstring widestr = std::wstring(model_path.begin(), model_path.end());  ////windows\u5199\u6cd5\n    /// ort_session = new Session(env, widestr.c_str(), sessionOptions); ////windows\u5199\u6cd5\n    ort_session = new Session(env, model_path.c_str(), sessionOptions); ////linux\u5199\u6cd5\n\n    size_t numInputNodes = ort_session->GetInputCount();\n    size_t numOutputNodes = ort_session->GetOutputCount();\n    AllocatorWithDefaultOptions allocator;\n    for (int i = 0; i < numInputNodes; i++)\n    {\n        input_names.push_back(ort_session->GetInputName(i, allocator)); /// \u4f4e\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        ////AllocatedStringPtr input_name_Ptr = ort_session->GetInputNameAllocated(i, allocator);  /// \u9ad8\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        ////input_names.push_back(input_name_Ptr.get()); /// \u9ad8\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        Ort::TypeInfo input_type_info = ort_session->GetInputTypeInfo(i);\n        auto input_tensor_info = input_type_info.GetTensorTypeAndShapeInfo();\n        auto input_dims = input_tensor_info.GetShape();\n        input_node_dims.push_back(input_dims);\n    }\n    for (int i = 0; i < numOutputNodes; i++)\n    {\n        output_names.push_back(ort_session->GetOutputName(i, allocator)); /// \u4f4e\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        ////AllocatedStringPtr output_name_Ptr= ort_session->GetInputNameAllocated(i, allocator);\n        ////output_names.push_back(output_name_Ptr.get()); /// \u9ad8\u7248\u672connxruntime\u7684\u63a5\u53e3\u51fd\u6570\n        Ort::TypeInfo output_type_info = ort_session->GetOutputTypeInfo(i);\n        auto output_tensor_info = output_type_info.GetTensorTypeAndShapeInfo();\n        auto output_dims = output_tensor_info.GetShape();\n        output_node_dims.push_back(output_dims);\n    }\n\n    this->input_height = input_node_dims[0][2];\n    this->input_width = input_node_dims[0][3];\n    ////\u5728\u8fd9\u91cc\u5c31\u76f4\u63a5\u5b9a\u4e49\u4e86\uff0c\u6ca1\u6709\u50cfpython\u7a0b\u5e8f\u91cc\u7684\u90a3\u6837normed_template = TEMPLATES.get(template) * crop_size\n    this->normed_template.emplace_back(Point2f(38.29459984, 51.69630032));\n    this->normed_template.emplace_back(Point2f(73.53180016, 51.50140016));\n    this->normed_template.emplace_back(Point2f(56.0252,     71.73660032));\n    this->normed_template.emplace_back(Point2f(41.54929968, 92.36549952));\n    this->normed_template.emplace_back(Point2f(70.72989952, 92.20409968));\n}\n\nvoid FaceEmbdding::preprocess(Mat srcimg, const vector<Point2f> face_landmark_5)\n{\n    Mat crop_img;\n    warp_face_by_face_landmark_5(srcimg, crop_img, face_landmark_5, this->normed_template, Size(112, 112));\n    /*vector<uchar> inliers(face_landmark_5.size(), 0);\n    Mat affine_matrix = cv::estimateAffinePartial2D(face_landmark_5, this->normed_template, cv::noArray(), cv::RANSAC, 100.0);\n    Mat crop_img;\n    Size crop_size(112, 112);\n    warpAffine(srcimg, crop_img, affine_matrix, crop_size, cv::INTER_AREA, cv::BORDER_REPLICATE);*/\n\n    vector<cv::Mat> bgrChannels(3);\n    split(crop_img, bgrChannels);\n    for (int c = 0; c < 3; c++)\n    {\n        bgrChannels[c].convertTo(bgrChannels[c], CV_32FC1, 1 / 127.5, -1.0);\n    }\n\n    const int image_area = this->input_height * this->input_width;\n    this->input_image.resize(3 * image_area);\n    size_t single_chn_size = image_area * sizeof(float);\n    memcpy(this->input_image.data(), (float *)bgrChannels[2].data, single_chn_size);\n    memcpy(this->input_image.data() + image_area, (float *)bgrChannels[1].data, single_chn_size);\n    memcpy(this->input_image.data() + image_area * 2, (float *)bgrChannels[0].data, single_chn_size);\n}\n\nvector<float> FaceEmbdding::detect(Mat srcimg, const vector<Point2f> face_landmark_5)\n{\n    this->preprocess(srcimg, face_landmark_5);\n\n    std::vector<int64_t> input_img_shape = {1, 3, this->input_height, this->input_width};\n    Value input_tensor_ = Value::CreateTensor<float>(memory_info_handler, this->input_image.data(), this->input_image.size(), input_img_shape.data(), input_img_shape.size());\n\n    Ort::RunOptions runOptions;\n    vector<Value> ort_outputs = this->ort_session->Run(runOptions, this->input_names.data(), &input_tensor_, 1, this->output_names.data(), output_names.size());\n\n    float *pdata = ort_outputs[0].GetTensorMutableData<float>(); /// \u5f62\u72b6\u662f(1, 512)\n    const int len_feature = ort_outputs[0].GetTensorTypeAndShapeInfo().GetShape()[1];\n    vector<float> embedding(len_feature);\n    memcpy(embedding.data(), pdata, len_feature*sizeof(float));\n    return embedding;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Server.h\"\n#include <unistd.h>\n#include <functional>\n#include \"Acceptor.h\"\n#include \"Channel.h\"\n#include \"Connection.h\"\n#include \"EventLoop.h\"\n#include \"Socket.h\"\n#include \"ThreadPool.h\"\n\nServer::Server(EventLoop *_loop) : mainReactor(_loop), acceptor(nullptr) {\n  // set Acceptor\n  acceptor = new Acceptor(mainReactor);\n  std::function<void(Socket *)> cb = std::bind(&Server::newConnection, this, std::placeholders::_1);\n  acceptor->setNewConnectionCallback(cb);\n  // set ThreadPool\n  int size = std::thread::hardware_concurrency();  // \u83b7\u53d6CPU\u6838\u5fc3\u6700\u5927\u5e76\u53d1\u6570\u91cf\n  thpool = new ThreadPool(size);\n  // set subReactors\n  for (int i = 0; i < size; ++i) {\n    subReactors.push_back(new EventLoop());\n  }\n  for (int i = 0; i < size; ++i) {\n    std::function<void()> sub_loop = std::bind(&EventLoop::loop, subReactors[i]);\n    thpool->add(sub_loop);\n  }\n}\n\nServer::~Server() {\n  delete acceptor;\n  delete thpool;\n}\n\nvoid Server::newConnection(Socket *sock) {\n  if (sock->getFd() != -1) {\n    // \u65b0\u8fde\u63a5\u968f\u673a\u9009\u62e9\u4e00\u4e2asubReactor\n    int random = sock->getFd() % subReactors.size();  //\u8c03\u5ea6\u7b56\u7565\uff1a\u5168\u968f\u673a\n    Connection *conn = new Connection(subReactors[random], sock);\n    std::function<void(int)> cb = std::bind(&Server::deleteConnection, this, std::placeholders::_1);\n    conn->setDeleteConnectionCallback(cb);\n    connections[sock->getFd()] = conn;\n  }\n}\n\nvoid Server::deleteConnection(int sockfd) {\n  if (sockfd != -1) {\n    auto it = connections.find(sockfd);\n    if (it != connections.end()) {\n      Connection *conn = connections[sockfd];\n      connections.erase(sockfd);\n      close(sockfd);       //\u6b63\u5e38\n    //   delete conn;  //\u4f1aSegmant fault\n    }\n  }\n}",
    "#include \"Service2Reset.hpp\"\n#include \"pluginlib/class_list_macros.hpp\"\n\nnamespace rviz2_plugin_ser2res {\n    Service2Reset::Service2Reset() {\n        shortcut_key_ = 'r';\n    }\n\n    Service2Reset::~Service2Reset() {}\n\n    void Service2Reset::onInitialize()\n    {\n        auto ros_node_abstraction = this->context_->getRosNodeAbstraction().lock();\n        if (ros_node_abstraction) {\n            auto node = ros_node_abstraction->get_raw_node();\n            reset_time_srv_ = node->create_service<std_srvs::srv::Empty>(\n                    ros_node_abstraction->get_node_name() + \"/reset_time\",\n                    std::bind(&Service2Reset::resetService, this,\n                              std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n\n        }\n    }\n\n    void Service2Reset::activate() {}\n\n    void Service2Reset::resetService(const std::shared_ptr<rmw_request_id_t>,\n                                           const std::shared_ptr<std_srvs::srv::Empty::Request>,\n                                           const std::shared_ptr<std_srvs::srv::Empty::Response>)\n    {\n        this->context_->getRootDisplayGroup()->reset();\n    }\n\n    void Service2Reset::deactivate() {}\n\n}\n\nPLUGINLIB_EXPORT_CLASS(rviz2_plugin_ser2res::Service2Reset, rviz_common::Tool)\n",
    "#include \"pch.h\"\n\n#include \"bakkesmod/wrappers/canvaswrapper.h\"\n#include \"Circle.h\"\n#include \"Matrix3.h\"\n#include \"Frustum.h\"\n#include \"../Extra/RenderingMath.h\"\n#include \"../Extra/WrapperStructsExtensions.h\"\n#include <vector>\n\nRT::Circle::Circle()\n\t: location(Vector(0.0f,0.0f,0.0f)), orientation(Quat(1.0f,0.0f,0.0f,0.0f)), radius(100.0f), lineThickness(1.0f), piePercentage(1.0f), steps(16) {}\n\nRT::Circle::Circle(Vector loc, Quat rot, float rad)\n\t: Circle() { location = loc; orientation = rot; radius = rad; }\n\nvoid RT::Circle::Draw(CanvasWrapper canvas, Frustum &frustum) const\n{\n\tstd::vector<Vector> circlePoints;\n\tVector start = {1.0f,0.0f,0.0f};\n\tVector axis = {0.0f,0.0f,1.0f};\n\n\t//Rename variables for easier readability\n\t/*float radius = circle.radius;\n\tVector location = circle.location;\n\tQuat orientation = circle.orientation;\n\tfloat lineThickness = circle.lineThickness;\n\tint steps = circle.steps;\n\tfloat piePercentage = circle.piePercentage;*/\n\n\t//Get all the vertices that comprise the circle\n\tfor(int32_t i = 0; i < steps; ++i)\n\t{\n\t\tVector newPoint = start;\n\t\tfloat angle = (2.0f * CONST_PI_F / steps) * i;\n\t\tQuat rotAmount = AngleAxisRotation(angle, axis);\n\t\tnewPoint = RotateVectorWithQuat(newPoint, rotAmount);\n\t\tcirclePoints.push_back(newPoint);\n\t}\n\n\t//Reorient all points of circle\n\tfor(Vector& circlePoint : circlePoints)\n\t{\n\t\tcirclePoint = RotateVectorWithQuat(circlePoint, orientation);\n\t}\n\n\t//Determine how many lines to draw\n\tint32_t newPointAmount = static_cast<int32_t>(static_cast<float>(circlePoints.size()) * piePercentage);\n\tif(piePercentage != 0 && piePercentage != 1.0f)\n\t{\n\t\tnewPointAmount += 1;\n\t}\n\t\n\t//Calculate how much of the last line should be drawn\n\tfloat percentagePerLineSegment = 1.0f / steps;\n\tfloat fullLinePercentage = newPointAmount * percentagePerLineSegment - percentagePerLineSegment;\n\n\tif (piePercentage == 0.0f)\n\t{\n\t\tfullLinePercentage = 0.0f;\n\t}\n\tif (piePercentage == 1.0f)\n\t{\n\t\tfullLinePercentage = 1.0f;\n\t}\n\n\tfloat lastLineRemainder = piePercentage - fullLinePercentage;\n\tfloat lastLinePercent = lastLineRemainder/percentagePerLineSegment;\n\n\tif (piePercentage == 1.0f)\n\t{\n\t\tlastLinePercent = 1.0f;\n\t}\n\n\t//Draw the line segments\n\tfor(size_t i = 0; i < newPointAmount; ++i)\n\t{\n\t\tVector startPoint;\n\t\tVector originalEnd;\n\t\tVector calculatedEnd;\n\n\t\tif(i < circlePoints.size()-1)\n\t\t{\n\t\t\tstartPoint = location + circlePoints[i] * radius;\n\t\t\toriginalEnd = location + circlePoints[i + 1] * radius;\n\t\t}\n\n\t\tif(i == circlePoints.size()-1)\n\t\t{\n\t\t\tstartPoint = location + circlePoints[i] * radius;\n\t\t\toriginalEnd = location + circlePoints[0] * radius;\n\t\t}\n\n\t\tcalculatedEnd = originalEnd;\n\t\tif(i == (size_t)newPointAmount - 1)\n\t\t{\n\t\t\tcalculatedEnd = ((originalEnd - startPoint) * lastLinePercent) + startPoint;\n\t\t}\n\n\t\tif(frustum.IsInFrustum(startPoint) && frustum.IsInFrustum(calculatedEnd))\n\t\t{\n\t\t\tif(lineThickness == 1.0f)\n\t\t\t{\n\t\t\t\tcanvas.DrawLine(canvas.ProjectF(startPoint), canvas.ProjectF(calculatedEnd)); //Avoid gaps between lines\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.DrawLine(canvas.ProjectF(startPoint), canvas.ProjectF(calculatedEnd), lineThickness);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid RT::Circle::DrawSegmented(CanvasWrapper canvas, Frustum &frustum, int segments, float percentPerSeg) const\n{\n\t//Horribly inefficient but whatever - duplicates all circle points for each circle\n\t//Fix it to use piePercentage methods multiple times around ONE circle to avoid creating duplicate calculations\n\n\tCircle circ = *this;\n\tcirc.piePercentage = percentPerSeg / segments;\n\tfloat rotSection = (2.f * CONST_PI_F) / segments;\n\n\tMatrix3 orientationMat(circ.orientation);\n\n\tfor(int32_t i = 0; i < segments; ++i)\n\t{\n\t\tQuat rotAroundUp = AngleAxisRotation(rotSection * i, orientationMat.up);\n\t\tcirc.orientation = rotAroundUp * circ.orientation;\n\t\tcirc.Draw(canvas, frustum);\n\t}\n}\n",
    "#include \"./6502/class_6502.h\"\n\n#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <termios.h>\n\nvoid outputFromCpu(unsigned char* dataRecv, bool* loop){\n    //initilaise output as unbuffered\n    std::cout.setf(std::ios::unitbuf);\n\n    //get outputs\n    char outputBuffer;\n    while(*loop){\n        if(*dataRecv != 0xFF){\n            outputBuffer = (char) *dataRecv;\n            *dataRecv = 0xFF;\n            //translate CR to newline\n            if(outputBuffer == 0x0D) std::cout << '\\n';\n            else std::cout << outputBuffer;\n        }\n    }\n}\n\nint main(){\n\n    //create CPU\n    C6502 myCPU(\"./wozmon/wozmon.bin\");\n\n    //set unput and output lanes\n    unsigned char* dataSend = myCPU.getIn();\n    unsigned char* dataRecv = myCPU.getOut();\n    bool* signal = myCPU.getDataInSig();\n\n    //set thread control variables\n    bool loopCPU = true;\n    bool loopOutput = true;\n    bool loopMain = true;\n\n    //create threads\n    std::thread t2(outputFromCpu, dataRecv, &loopOutput);\n    std::thread t1(&C6502::run, &myCPU, &loopCPU);\n\n    //create input environment (from jsmith message on https://cplusplus.com/forum/beginner/5619/#msg25139)\n    struct termios oldSettings, newSettings;\n    tcgetattr( fileno( stdin ), &oldSettings );\n    newSettings = oldSettings;\n    newSettings.c_lflag &= (~ICANON & ~ECHO);\n    tcsetattr( fileno( stdin ), TCSANOW, &newSettings );    \n\n    // std::this_thread::sleep_for(std::chrono::seconds(25));\n    // loopMain = false;\n\n    while ( loopMain ){\n        //get the input controls\n        fd_set set;\n        FD_ZERO( &set );\n        FD_SET( fileno( stdin ), &set );\n\n        //wait till input available\n        int res = select( fileno( stdin )+1, &set, NULL, NULL, NULL );\n\n        //get the input\n        char c;\n        read( fileno( stdin ), &c, 1 );\n        //translation for different number set?\n        if(c == 0x0A) c = 0x0D;\n        if(c == 0x7F) c = 0x08;\n            \n        //send the data and signal\n        *dataSend = c;\n        *signal = true;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n\n    tcsetattr( fileno( stdin ), TCSANOW, &oldSettings );\n\n    //shutdown program\n    loopCPU = false;\n    loopOutput = false;\n\n    //joins\n    t1.join();\n    t2.join();\n\n    //return no errors\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: WBP_CharaCre_ColorSliderWin\n\n#include \"Basic.hpp\"\n\n#include \"WBP_CharaCre_ColorSliderWin_classes.hpp\"\n#include \"WBP_CharaCre_ColorSliderWin_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.BndEvt__WBP_CharaCre_ColorSliderWin_WBP_CharaCre_ColorSelect_WithPreset_K2Node_ComponentBoundEvent_0_OnColorChanged__DelegateSignature\n// (BlueprintEvent)\n// Parameters:\n// struct FLinearColor                     HSV                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UWBP_CharaCre_ColorSliderWin_C::BndEvt__WBP_CharaCre_ColorSliderWin_WBP_CharaCre_ColorSelect_WithPreset_K2Node_ComponentBoundEvent_0_OnColorChanged__DelegateSignature(const struct FLinearColor& HSV)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"WBP_CharaCre_ColorSliderWin_C\", \"BndEvt__WBP_CharaCre_ColorSliderWin_WBP_CharaCre_ColorSelect_WithPreset_K2Node_ComponentBoundEvent_0_OnColorChanged__DelegateSignature\");\n\n\tParams::WBP_CharaCre_ColorSliderWin_C_BndEvt__WBP_CharaCre_ColorSliderWin_WBP_CharaCre_ColorSelect_WithPreset_K2Node_ComponentBoundEvent_0_OnColorChanged__DelegateSignature Parms{};\n\n\tParms.HSV = std::move(HSV);\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.BndEvt__WBP_CharaCre_ColorSliderWin_WBP_Menu_btn_K2Node_ComponentBoundEvent_1_OnButtonClicked__DelegateSignature\n// (BlueprintEvent)\n\nvoid UWBP_CharaCre_ColorSliderWin_C::BndEvt__WBP_CharaCre_ColorSliderWin_WBP_Menu_btn_K2Node_ComponentBoundEvent_1_OnButtonClicked__DelegateSignature()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"WBP_CharaCre_ColorSliderWin_C\", \"BndEvt__WBP_CharaCre_ColorSliderWin_WBP_Menu_btn_K2Node_ComponentBoundEvent_1_OnButtonClicked__DelegateSignature\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.ExecuteUbergraph_WBP_CharaCre_ColorSliderWin\n// (Final, UbergraphFunction, HasDefaults)\n// Parameters:\n// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UWBP_CharaCre_ColorSliderWin_C::ExecuteUbergraph_WBP_CharaCre_ColorSliderWin(int32 EntryPoint)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"WBP_CharaCre_ColorSliderWin_C\", \"ExecuteUbergraph_WBP_CharaCre_ColorSliderWin\");\n\n\tParams::WBP_CharaCre_ColorSliderWin_C_ExecuteUbergraph_WBP_CharaCre_ColorSliderWin Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.OnCancel\n// (Public, BlueprintCallable, BlueprintEvent)\n\nvoid UWBP_CharaCre_ColorSliderWin_C::OnCancel()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"WBP_CharaCre_ColorSliderWin_C\", \"OnCancel\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.OnInitialized\n// (BlueprintCosmetic, Event, Public, BlueprintEvent)\n\nvoid UWBP_CharaCre_ColorSliderWin_C::OnInitialized()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"WBP_CharaCre_ColorSliderWin_C\", \"OnInitialized\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.OnInputMethodChanged\n// (Public, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// ECommonInputType                        bNewInputType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UWBP_CharaCre_ColorSliderWin_C::OnInputMethodChanged(ECommonInputType bNewInputType)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"WBP_CharaCre_ColorSliderWin_C\", \"OnInputMethodChanged\");\n\n\tParams::WBP_CharaCre_ColorSliderWin_C_OnInputMethodChanged Parms{};\n\n\tParms.bNewInputType = bNewInputType;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function WBP_CharaCre_ColorSliderWin.WBP_CharaCre_ColorSliderWin_C.OnMouseButtonDown_0\n// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)\n// Parameters:\n// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)\n// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)\n// struct FEventReply                      Re",
    "#pragma once\r\n#define WIN32_LEAN_AND_MEAN\r\n#include <Windows.h>\r\n\r\ntypedef void (*SetHookFunc)();\r\ntypedef void (*RemoveHookFunc)();\r\n\r\nint main() {\r\n\r\n    // ocultar shell cmd\r\n    FreeConsole();\r\n\r\n    // Cargar la DLL\r\n    HINSTANCE hDll = LoadLibrary(\"hook64.dll\");\r\n    if (hDll == NULL) {\r\n        MessageBox(NULL, \"Failed to load DLL 64\", \"Error\", MB_OK | MB_ICONERROR);\r\n        return 1;\r\n    }\r\n\r\n    // Obtener puntero a para registrar el gancho de 64 bits\r\n    SetHookFunc setHook = (SetHookFunc)GetProcAddress(hDll, \"SetHook\");\r\n    RemoveHookFunc removeHook = (RemoveHookFunc)GetProcAddress(hDll, \"RemoveHook\");\r\n    if (setHook == NULL || removeHook == NULL) {\r\n        MessageBox(NULL, \"Failed to get function pointers 64\", \"Error\", MB_OK | MB_ICONERROR);\r\n        FreeLibrary(hDll);\r\n        return 1;\r\n    }\r\n\r\n    // Instalar el gancho\r\n    setHook();\r\n\r\n    // Mantener el programa en ejecuci\u00f3n\r\n    MSG msg;\r\n    while (GetMessage(&msg, NULL, 0, 0)) {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n\r\n    //remover gancho\r\n    removeHook();\r\n\r\n    //liberar la DLL\r\n    FreeLibrary(hDll);\r\n\r\n    return 0;\r\n}\r\n",
    "//////////////////////////////////////////////written by mht83/////////////////////////////////////////\n#include <iostream>\n#include <vector>\n#include <memory>\n\n// ANSI color codes\nconst std::string RED = \"\\033[31m\";\nconst std::string GREEN = \"\\033[32m\";\nconst std::string YELLOW = \"\\033[33m\";\nconst std::string BLUE = \"\\033[34m\";\nconst std::string MAGENTA = \"\\033[35m\";\nconst std::string CYAN = \"\\033[36m\";\nconst std::string RESET = \"\\033[0m\";\n\nint sum_of_divisors(int n) {\n    int sum = 1; \n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            sum += i;\n            if (i != n / i) {\n                sum += n / i;\n            }\n        }\n    }\n    return sum;\n}\n\nint main() {\n    const int num = 1000000;\n    auto numWithSum = std::make_unique<std::vector<std::vector<int>>>(num, std::vector<int>(2));\n\n    for (int i = 1; i <= num; ++i) {\n        (*numWithSum)[i - 1][0] = i;\n        (*numWithSum)[i - 1][1] = sum_of_divisors(i);\n    }\n    \n    std::cout << CYAN << \"Finding Amicable Numbers...\" << RESET << \"\\n\";\n    std::cout << YELLOW << \"---------------------------------\" << RESET << \"\\n\";\n\n    for (int i = 0; i < num; i++) {\n        int sumDiv = (*numWithSum)[i][1];\n        if (sumDiv < num && sumDiv != i + 1) { // Check if sumDiv is within bounds\n            if (i + 1 == (*numWithSum)[sumDiv - 1][1]) { \n                std::cout << GREEN << \"Amicable Pair Found: \" << RESET;\n                std::cout << i + 1 << ' ' << sumDiv << \"\\n\";\n            }\n        }\n    }\n\n    std::cout << YELLOW << \"---------------------------------\" << RESET << \"\\n\";\n    std::cout << MAGENTA << \"Search Complete.\" << RESET << \"\\n\";\n\n\n    return 0;\n}\n",
    "#include <pch.h>\n\n\n\nnamespace client\n{\n\tinputs_hook::inputs_hook()\n\t{\n\t\tm_window = nullptr;\n\t}\n\n\n\n\tinputs_hook::~inputs_hook()\n\t{\n\t\tm_window = nullptr;\n\t}\n\n\n\n\tvoid inputs_hook::init(HWND _window)\n\t{\n\t\tm_window = _window;\n\n\t\tm_original_window_procedure = (WNDPROC)SetWindowLongPtr(m_window, GWLP_WNDPROC, (LONG_PTR)new_window_procedure);\n\n\t\tminhook::add(SetCursorPos, &new_set_cursor_pos, &m_original_set_cursor_pos);\n\t}\n\n\n\n\tvoid inputs_hook::shutdown()\n\t{\n\t\tSetWindowLongPtr(m_window, GWLP_WNDPROC, (LONG_PTR)m_original_window_procedure);\n\n\t\tminhook::remove(SetCursorPos);\n\n\t\tlog::get()->print(log_success, \"Unitialized inputs hook\");\n\t}\n\n\n\n\tLRESULT WINAPI inputs_hook::new_window_procedure(HWND _window, UINT _message, WPARAM _word_param, LPARAM _long_param)\n\t{\n\t\tif (directx_hook::get()->is_running())\n\t\t{\n\t\t\tImGui_ImplWin32_WndProcHandler(_window, _message, _word_param, _long_param);\n\n\t\t\tif (imgui::get()->is_any_window_open())\n\t\t\t{\n\t\t\t\tswitch (_message)\n\t\t\t\t{\n\t\t\t\t\t// Keyboard buttons.\n\t\t\t\t\tcase WM_SYSKEYDOWN:\n\t\t\t\t\tcase WM_KEYDOWN:\n\n\t\t\t\t\t// Mouse buttons.\n\t\t\t\t\tcase WM_LBUTTONDBLCLK:\n\t\t\t\t\tcase WM_LBUTTONDOWN:\n\t\t\t\t\tcase WM_MBUTTONDBLCLK:\n\t\t\t\t\tcase WM_MBUTTONDOWN:\n\t\t\t\t\tcase WM_RBUTTONDBLCLK:\n\t\t\t\t\tcase WM_RBUTTONDOWN:\n\t\t\t\t\tcase WM_MOUSEWHEEL:\n\n\t\t\t\t\t// Mouse movements.\n\t\t\t\t\tcase WM_MOUSEMOVE:\n\t\t\t\t\tcase WM_INPUT:\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn CallWindowProc(m_original_window_procedure, _window, _message, _word_param, _long_param);\n\t}\n\n\n\n\tBOOL WINAPI inputs_hook::new_set_cursor_pos(int _x, int _y)\n\t{\n\t\tif (directx_hook::get()->is_running() && imgui::get()->is_any_window_open())\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treturn m_original_set_cursor_pos(_x, _y);\n\t}\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"PlatformTrigger.h\"\n\n#include \"Components/BoxComponent.h\"\n\n#include \"MovingPlatform.h\"\n\n// Sets default values\nAPlatformTrigger::APlatformTrigger()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tTriggerVolume = CreateDefaultSubobject<UBoxComponent>(FName(\"TriggerVolume\"));\n\tif (!ensure(TriggerVolume != nullptr)) return;\n\n\tRootComponent = TriggerVolume;\n\n\n\tTriggerVolume->OnComponentBeginOverlap.AddDynamic(this, &APlatformTrigger::OnOverlapBegin);\n\tTriggerVolume->OnComponentEndOverlap.AddDynamic(this, &APlatformTrigger::OnOverlapEnd);\n}\n\n// Called when the game starts or when spawned\nvoid APlatformTrigger::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid APlatformTrigger::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid APlatformTrigger::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\tfor (AMovingPlatform* Platform : PlatformsToTrigger)\n\t{\n\t\tPlatform->AddActiveTrigger();\n\t}\n}\n\nvoid APlatformTrigger::OnOverlapEnd(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)\n{\n\tfor (AMovingPlatform* Platform : PlatformsToTrigger)\n\t{\n\t\tPlatform->RemoveActiveTrigger();\n\t}\n}",
    "// dear imgui: \"null\" example application\n// (compile and link imgui, create context, run headless with NO INPUTS, NO GRAPHICS OUTPUT)\n// This is useful to test building, but you cannot interact with anything here!\n#include \"imgui.h\"\n#include <stdio.h>\n\nint main(int, char**)\n{\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO();\n\n    // Build atlas\n    unsigned char* tex_pixels = nullptr;\n    int tex_w, tex_h;\n    io.Fonts->GetTexDataAsRGBA32(&tex_pixels, &tex_w, &tex_h);\n\n    for (int n = 0; n < 20; n++)\n    {\n        printf(\"NewFrame() %d\\n\", n);\n        io.DisplaySize = ImVec2(1920, 1080);\n        io.DeltaTime = 1.0f / 60.0f;\n        ImGui::NewFrame();\n\n        static float f = 0.0f;\n        ImGui::Text(\"Hello, world!\");\n        ImGui::SliderFloat(\"float\", &f, 0.0f, 1.0f);\n        ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / io.Framerate, io.Framerate);\n        ImGui::ShowDemoWindow(nullptr);\n\n        ImGui::Render();\n    }\n\n    printf(\"DestroyContext()\\n\");\n    ImGui::DestroyContext();\n    return 0;\n}\n",
    "#include \"constraint_no_duplicate.hpp\"\n\nConstraintNoDuplicate::ConstraintNoDuplicate()\n{}\n\nvoid ConstraintNoDuplicate::addNeigbour(int index)\n{\n    for(auto neighbour : neighbours) {\n        if(index == neighbour) return;\n    }\n    neighbours.push_back(index);\n}\n\nSudokuResult ConstraintNoDuplicate::onCollapsed(Sudoku *sudoku, int collapsedIndex, int value, SudokuNote note)\n{\n    bool changed = false;\n    SudokuNote inverse = ~note;\n    for(auto index : neighbours) {\n        if(sudoku->isIgnored(index)) continue;\n        int oldValue = sudoku->note[index];\n        if(oldValue & SudokuNoteOk) continue;\n        int result = oldValue & inverse;\n        changed |= oldValue != result;\n        if((result & SudokuNoteAll) == 0) return SudokuResultError;\n        sudoku->note[index] = result;\n    }\n    return changed ? SudokuResultOk : SudokuResultUnchanged;\n}\n\nConstraintNoDuplicate *ConstraintNoDuplicate::create(Sudoku *sudoku)\n{\n    return new ConstraintNoDuplicate[sudoku->getSize()];\n}\n\nvoid ConstraintNoDuplicate::apply(Sudoku *dst)\n{\n    for(int i = 0; i < dst->getSize(); i++) {\n        dst->addConstraint(i, &this[i]);\n    }\n}\n\nGroupGenerator::GroupGenerator(int _groupCount, int _groupSize)\n    : groupCount(_groupCount), groupSize(_groupSize)\n{}\n\nvoid ConstraintNoDuplicate::addRelative(Sudoku *sudoku, int ox, int oy, int dx, int dy)\n{\n    int ix = ox + dx;\n    int iy = oy + dy;\n    if(ix < 0 || ix >= sudoku->getDimension()) return;\n    if(iy < 0 || iy >= sudoku->getDimension()) return;\n    this[oy * sudoku->getDimension() + ox].addNeigbour(iy * sudoku->getDimension() + ix);\n}\n\nvoid ConstraintNoDuplicate::inAdjacent(Sudoku *sudoku)\n{\n    for(int y = 0; y < sudoku->getDimension(); y++) {\n        for(int x = 0; x < sudoku->getDimension(); x++) {\n            for(int dy = -1; dy <= 1; dy++) {\n                for(int dx = -1; dx <= 1; dx++) {\n                    if(dx == 0 && dy == 0) continue;\n                    addRelative(sudoku, x, y, dx, dy);\n                }\n            }\n        }\n    }\n}\n\nvoid ConstraintNoDuplicate::inHorseMove(Sudoku *sudoku)\n{\n    for(int y=0; y<sudoku->getDimension(); y++) {\n        for(int x=0; x<sudoku->getDimension(); x++) {\n            addRelative(sudoku, x, y, -2, -1);\n            addRelative(sudoku, x, y, -1, -2);\n            addRelative(sudoku, x, y,  2, -1);\n            addRelative(sudoku, x, y,  1, -2);\n            addRelative(sudoku, x, y,  2,  1);\n            addRelative(sudoku, x, y,  1,  2);\n            addRelative(sudoku, x, y, -2,  1);\n            addRelative(sudoku, x, y, -1,  2);\n        }\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"camera_ai\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"Functions.h\"\n\n#include <cstdint>\n#include <stdbool.h>\n#include <stdbool.h>\n\n#include \"../Offsets/Offsets.h\"\n\nstatic uintptr_t GameBase_;\nstatic uintptr_t GameAssembly_;\nstatic uintptr_t UnityPlayer_;\n\n// TODO: Fix\n\nvoid Functions::init(uintptr_t game_base, uintptr_t game_assembly, uintptr_t unity_player)\n{\n    GameBase_ = game_base;\n    GameAssembly_ = game_assembly;\n    UnityPlayer_ = unity_player;\n}\n\n// WeaponSounds\nvoid Functions::SetNextHitCritical(void* arg, bool arg1)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, bool)) (GameAssembly_ + Offsets::SetNextCriticalHit);\n    return fn(arg, arg1);\n}\n\n// Player_move_c\nvoid Functions::MakeInvisibleForSeconds(void* arg, float duration)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, float)) (GameAssembly_ + Offsets::MakeInvisibleForSeconds);\n    return fn(arg, duration);\n}\n\n// PlayerDamageable\nvoid Functions::AddHealthFromWeaponOnline(void* arg, float amount)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, float, char*)) (GameAssembly_ + Offsets::AddHealthFromWeaponOnline);\n    return fn(arg, amount, nullptr);\n}\n\nvoid Functions::AddAmmoFromWeaponOnline(void* arg, float amount)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, float, char*)) (GameAssembly_ + Offsets::AddAmmoFromWeaponOnline);\n    return fn(arg, amount, nullptr);\n}\n\nvoid* Functions::TextMeshGetText(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*)) (GameAssembly_ + Offsets::TextMeshGetText);\n    return fn(arg);\n}\n\nvoid Functions::TextMeshGetColor(void* arg, void* color_ptr)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, void*)) (GameAssembly_ + Offsets::TextMeshGetColor);\n    return fn(arg, color_ptr);\n}\n\nvoid Functions::CameraWorldToScreen(void* arg, void* world, void* screen)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, void*, int, void*)) (GameAssembly_ + Offsets::WorldToScreenPoint);\n    return fn(arg, world, 2, screen);\n}\n\nvoid* Functions::ComponentGetTransform(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*)) (GameAssembly_ + Offsets::ComponentGetTransform);\n    return fn(arg);\n}\n\nvoid Functions::TransformGetRotation(void* arg, void* quaternion)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, void*)) (GameAssembly_ + Offsets::TransformGetRotation);\n    return fn(arg, quaternion);\n}\n\nvoid Functions::TransformGetPosition(void* arg, void* position)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, void*)) (GameAssembly_ + Offsets::TransformGetPosition);\n    return fn(arg, position);\n}\n\nvoid Functions::TransformLookAt(void* arg, void* position, void* up)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*, void*, void*)) (GameAssembly_ + Offsets::TransformLookAt);\n    return fn(arg, position, up);\n}\n\nbool Functions::PhysicsRaycast(void* ray, void* hit_info, float max_distance)\n{\n    static const auto fn = (bool(*)(void*, void*, float)) (GameAssembly_ + Offsets::PhysicsRayCast);\n    return fn(ray, hit_info, max_distance);\n}\n\nint Functions::ObjectGetInstanceID(void* arg)\n{\n    if (!arg) return -1;\n    static const auto fn = (int(*)(void*))(GameAssembly_ + Offsets::ObjectGetInstanceID);\n    return fn(arg);\n}\n\nvoid* Functions::FindObjectsOfType(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*))(GameAssembly_ + Offsets::FindObjectsOfType);\n    return fn(arg);\n}\n\nvoid* Functions::FindObjectOfType(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*))(GameAssembly_ + Offsets::FindObjectOfType);\n    return fn(arg);\n}\n\nvoid* Functions::TypeGetType(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*))(GameAssembly_ + Offsets::TypeGetType);\n    return fn(arg);\n}\n\nbool Functions::BehaviourGetEnabled(void* arg)\n{\n    if (!arg) return false;\n    static const auto fn = (bool(*)(void*))(GameAssembly_ + Offsets::BehaviourGetEnabled);\n    return fn(arg);\n}\n\nvoid Functions::AddWeapon(void* arg, void* string, int source, bool bool1 = true, bool bool2 = false, void* class1 = nullptr, void* struct1 = nullptr)\n{\n    if (!arg) return;\n    static const auto fn = (void(*)(void*))(GameAssembly_ + Offsets::AddWeapon);\n    fn(arg);\n}\n\nvoid* Functions::PlayerGetWeaponManager(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*))(GameAssembly_ + Offsets::PlayerGetWeaponManager);\n    return fn(arg); \n}\n\nvoid* Functions::GetItemRecordDict()\n{\n    static const auto fn = (void*(*)())(GameAssembly_ + Offsets::GetItemRecordDict);\n    return fn(); \n}\n\nvoid* Functions::ItemRecordGetShopId(void* arg)\n{\n    if (!arg) return nullptr;\n    static const auto fn = (void*(*)(void*))(GameAssembly_ + Offsets::ItemRecordGetShopId);\n    return fn(arg); \n}",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "/**\r\n    ##################################\r\n    #                                #\r\n    #      AUTORES DO PROJETO:       #\r\n    #                                #\r\n    # MARCO VINICIUS DA COSTA BUSATO #\r\n    #      FELYPE CESAR MOLINARI     #\r\n    #     LAURA FERRARI HECKMANN     #\r\n    #                                #\r\n    ##################################\r\n*/\r\n\r\n#include <iostream>\r\n#include <windows.h>\r\n#include <conio.h>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\n///Coordenadas do personagem e da bomba\r\nint xPersonagem = 2, yPersonagem = 2;\r\nint xBomba, yBomba;\r\n\r\n///Controle de movimento aleat\u00f3rio dos inimigos\r\nint deslocamentos;\r\nint direcao;\r\nint inimigo;\r\n\r\n///Controle de tempo entre movimenta\u00e7\u00e3o de inimigos e explos\u00e3o de bomba.\r\nint timerInimigo = 0;\r\nint timerBomba = 0;\r\n\r\n///Controla quanto tempo o caractere de explos\u00e3o fica em tela\r\nint explosaoBomba = 0;\r\n\r\n///Controles gerais de execu\u00e7\u00e3o do jogo\r\nbool gameLoop = true;\r\nbool bombaEmJogo = false;\r\n\r\nstring causaDaMorte = \"Indefinida\";\r\n\r\n///Variavel para tecla pressionada\r\nchar tecla;\r\n\r\n///Matriz que controla a impress\u00e3o do mapa\r\n///0: Caminho livre\r\n///1: Parede s\u00f3lida\r\n///2: Parede fr\u00e1gil\r\n///3 e 6: Caracteres da bomba (pois ela pisca)\r\n///4: Caractere de explos\u00e3o da bomba\r\n///5: Inimigos\r\nint m[10][22]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n               0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\r\n               0,1,0,0,2,0,2,2,0,0,2,0,2,0,2,0,2,0,0,0,5,1,\r\n               0,1,0,1,2,1,2,1,0,1,0,1,2,1,2,1,0,1,0,1,0,1,\r\n               0,1,2,0,2,0,2,0,0,0,2,2,2,0,2,2,2,0,0,2,0,1,\r\n               0,1,0,1,2,1,2,1,5,1,2,1,2,1,0,1,2,1,2,1,2,1,\r\n               0,1,0,0,2,0,2,2,0,0,0,0,2,0,2,2,0,0,0,0,0,1,\r\n               0,1,0,1,0,1,2,1,2,1,0,1,0,1,2,1,2,1,0,1,0,1,\r\n               0,1,5,0,0,2,2,0,0,2,0,0,0,2,2,2,0,2,0,0,5,1,\r\n               0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\r\n\r\n///Estrutura do inimigo\r\nstruct Inimigo{\r\n    int xInimigo;\r\n    int yInimigo;\r\n};\r\n\r\n///Inimigos\r\nInimigo a;\r\nInimigo b;\r\nInimigo c;\r\nInimigo d;\r\n\r\n///Ponteiro para armazenar o inimigo escolhido em quest\u00e3o\r\nInimigo* inimigoEscolhido;\r\n\r\n///As 4 pr\u00f3ximas fun\u00e7\u00f5es s\u00e3o booleanos que controlam a possibilidade de movimenta\u00e7\u00e3o do personagem\r\nbool personagemCima(int x, int y){\r\n\r\n    if(m[x-1][y] == 1 || m[x-1][y] == 2 || m[x-1][y] == 3 || m[x-1][y] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemBaixo(int x, int y){\r\n\r\n    if(m[x+1][y] == 1 || m[x+1][y] == 2 || m[x+1][y] == 3 || m[x+1][y] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemEsquerda(int x, int y){\r\n\r\n    if(m[x][y-1] == 1 || m[x][y-1] == 2 || m[x][y-1] == 3 || m[x][y-1] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool personagemDireita(int x, int y){\r\n\r\n    if(m[x][y+1] == 1 || m[x][y+1] == 2 || m[x][y+1] == 3 || m[x][y+1] == 6){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\n///As 4 pr\u00f3ximas fun\u00e7\u00f5es s\u00e3o booleanos que controlam a possibilidade de movimenta\u00e7\u00e3o dos inimigos\r\nbool inimigoCima(Inimigo &inimigoEscolhido){\r\n\r\n   if(m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 1 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 2 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 3 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 5 ||\r\n      m[inimigoEscolhido.xInimigo-1][inimigoEscolhido.yInimigo] == 6 ||\r\n      ///As coordenadas -1 indicam que o inimigo j\u00e1 morreu, uma vez que n\u00e3o existe essa coordenada na matriz.\r\n      inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoBaixo(Inimigo &inimigoEscolhido){\r\n\r\n    if(m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 1 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 2 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 3 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 5 ||\r\n       m[inimigoEscolhido.xInimigo+1][inimigoEscolhido.yInimigo] == 6 ||\r\n       inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoEsquerda(Inimigo &inimigoEscolhido){\r\n\r\n    if(m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 1 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 2 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 3 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 5 ||\r\n       m[inimigoEscolhido.xInimigo][inimigoEscolhido.yInimigo-1] == 6 ||\r\n       inimigoEscolhido.xInimigo == -1 && inimigoEscolhido.yInimigo == -1){\r\n        return false;\r\n    }\r\n    else{\r\n        return true;\r\n    }\r\n}\r\n\r\nbool inimigoDireita(Inimigo &ini",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"StochasticGradientDescent.h\"\n#include \"Agent.h\"\n#include <iostream>\n#include <set>\n#include <numeric>\n\n\n\nvoid StochasticGradientDescent::evaluatePolicy(Agent& agent) {\n\n    auto penv = agent.getEnvironment();\n    const auto& grid = penv->getGrid();\n\n    auto episodes = agent.iteratorGenerateEpisodes(agent, penv, EpisodeLen, EpisodeNum);\n    auto& stateValues = penv->getStateValues();\n\n    // \u5047\u8bbegamma\u548calpha\u5df2\u5b9a\u4e49\n    std::map<std::pair<size_t, size_t>, std::pair<float, int>> stateGradients;\n\n    for (const auto& episode : episodes) {\n        float G = 0; // \u7d2f\u79ef\u5956\u52b1\n        for (auto it = episode.rbegin(); it != episode.rend(); ++it) {\n            G = it->reward + gamma * G; // \u66f4\u65b0\u7d2f\u79ef\u5956\u52b1\n            auto& state = it->state;\n            auto& value = stateValues[state.first][state.second];\n            float gradient = -2 * (G - value); // \u8ba1\u7b97\u68af\u5ea6\n\n            // \u7d2f\u52a0\u5f53\u524d\u72b6\u6001\u7684\u68af\u5ea6\uff0c\u5e76\u8ba1\u6570\u8be5\u72b6\u6001\u51fa\u73b0\u7684\u6b21\u6570\n            if (stateGradients.find(state) == stateGradients.end()) {\n                stateGradients[state] = std::make_pair(gradient, 1);\n            }\n            else {\n                stateGradients[state].first += gradient;\n                stateGradients[state].second += 1;\n            }\n        }\n    }\n\n    // \u4f7f\u7528\u7d2f\u79ef\u7684\u68af\u5ea6\u548c\u8ba1\u6570\u6765\u66f4\u65b0\u72b6\u6001\u503c\n    for (auto& [state, gradCount] : stateGradients) {\n        auto& [cumulativeGradient, count] = gradCount;\n        float avgGradient = cumulativeGradient / count; // \u8ba1\u7b97\u5e73\u5747\u68af\u5ea6\n        stateValues[state.first][state.second] -= alpha * avgGradient; // \u66f4\u65b0\u72b6\u6001\u503c\n    }\n}\n\nvoid StochasticGradientDescent::improvePolicyGreedy(Agent& agent) {\n\n    auto penv = agent.getEnvironment();\n    const auto& grid = penv->getGrid();\n    for (size_t i = 0; i < penv->getGrid().size(); i++) {\n        for (size_t j = 0; j < penv->getGrid()[i].size(); j++) {\n            std::pair<int, int> state = { i, j };\n            auto actionProbabilities = agent.getStochasticPolicy(state);\n            float maxActionValue = -std::numeric_limits<float>::infinity();\n            ActionType bestAction = ActionType::Up;\n            for (const auto& [action, prob] : actionProbabilities) {\n                //if (action == ActionType::Stay && grid[state.first][state.second] != CellType::Target)continue;\n                auto s_next = agent.getNextState(state, action);\n                float reward = penv->getReward(state.first, state.second, action);\n                float actionValue = reward + gamma * penv->getStateValues()[s_next.first][s_next.second];\n                if (actionValue > maxActionValue) {\n                    maxActionValue = actionValue;\n                    bestAction = action;\n                }\n            }\n            // \u66f4\u65b0\u7b56\u7565\uff0c\u53ea\u4e3a\u6700\u4f73\u52a8\u4f5c\u8bbe\u7f6e\u6982\u7387\u4e3a1\uff0c\u5176\u4ed6\u52a8\u4f5c\u4e3a0\n            std::map<ActionType, float> updatedProbabilities;\n            for (const auto& action : actionProbabilities) {\n                updatedProbabilities[action.first] = (action.first == bestAction) ? 1.0f : 0.0f;\n            }\n            agent.setStochasticPolicy(state, updatedProbabilities);\n        }\n    }\n}\n\n\nvoid StochasticGradientDescent::run(Agent& agent) {\n\n\n    evaluatePolicy(agent);\n    improvePolicyGreedy(agent);\n\n}",
    "const int Green = 13;\nconst int Yellow = 12;\nconst int Red = 11;\n\nconst int GroupB[] = {2, 3, 4, 5, 6, 7, 8};\nconst int botao = 10;\n\nvoid setup() {\n  pinMode(Green, OUTPUT);\n  pinMode(Yellow, OUTPUT);\n  pinMode(Red, OUTPUT);\n  for (int i = 0; i < 7; i++) {\n    pinMode(GroupB[i], OUTPUT);\n  }\n  pinMode(botao, INPUT_PULLUP);\n}\n\nvoid loop() {  \n  while (digitalRead(botao) == HIGH) {\n    digitalWrite(Green, HIGH);\n    \n     for (int i = 0; i < 5; i++) {\n      \n      \tfor (int j = 0; j < 7; j++) {\n        digitalWrite(GroupB[j], HIGH);\n        delay(100);\n        digitalWrite(GroupB[j], LOW);\n        delay(200);\n      }      \n    }\n    \n    digitalWrite(Green, LOW);\n    digitalWrite(Yellow, HIGH);\n\n    for (int i = 0; i < 3; i++) {\n      for (int j = 8; j >=0 ; j--) {\n      digitalWrite(GroupB[j], HIGH);\n      delay(800);\n      }   \n      for (int j = 0; j < 7; j++) {\n        digitalWrite(GroupB[j], LOW);\n      }\n    } \n    \n    digitalWrite(Yellow, LOW);\n    digitalWrite(Red, HIGH);\n \t\n    for (int R = 0; R < 3; R++) {\n      for (int u = 0; u < 5; u++) { \n        for (int d = 0; d < 7; d++) {\n          digitalWrite(GroupB[d], HIGH);\n        }\n        delay(300);\n        for (int j = 0; j < 7; j++) {\n          digitalWrite(GroupB[j], LOW);\n        }\n        delay(300);\n      }\n      delay(10000);\n    }\n    \n    digitalWrite(Red, LOW); \n  }\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"machine_learning_application\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <string.h>             // memset\n\n\n#include \"rd03-protocol.h\"\n\nRD03Protocol::RD03Protocol(uint32_t header, uint32_t footer)\n{\n    _header = header;\n    _footer = footer;\n    reset_rx();\n}\n\nsize_t RD03Protocol::build_command(uint8_t *buf, uint16_t cmd, size_t cmd_data_len,\n                                   const uint8_t *cmd_data)\n{\n    // header\n    size_t idx = 0;\n    buf[idx++] = 0xFD;\n    buf[idx++] = 0xFC;\n    buf[idx++] = 0xFB;\n    buf[idx++] = 0xFA;\n    // length\n    uint16_t len = 2 + cmd_data_len;\n    buf[idx++] = len & 0xFF;\n    buf[idx++] = (len >> 8) & 0xFF;\n    // command word\n    buf[idx++] = cmd & 0xFF;\n    buf[idx++] = (cmd >> 8) & 0xFF;\n    // command data\n    for (size_t i = 0; i < cmd_data_len; i++) {\n        buf[idx++] = cmd_data[i];\n    }\n    // footer\n    buf[idx++] = 0x04;\n    buf[idx++] = 0x03;\n    buf[idx++] = 0x02;\n    buf[idx++] = 0x01;\n    return idx;\n}\n\nvoid RD03Protocol::reset_rx(void)\n{\n    _delim = _header;\n    _state = HEADER;\n    memset(_buf, 0, sizeof(_buf));\n    _len = 0;\n    _idx = 0;\n}\n\nbool RD03Protocol::process_rx(uint8_t c)\n{\n    switch (_state) {\n    case HEADER:\n        if (c == (_delim & 0xFF)) {\n            _delim = _delim >> 8;\n            if (_delim == 0) {\n                _state = LEN_1;\n            }\n        } else {\n            reset_rx();\n        }\n        break;\n    case LEN_1:\n        _len = c;\n        _state = LEN_2;\n        break;\n    case LEN_2:\n        _len += (c >> 8);\n        _delim = _footer;\n        if (_len < sizeof(_buf)) {\n            _state = (_len > 0) ? DATA : FOOTER;\n        } else {\n            _state = HEADER;\n        }\n        break;\n    case DATA:\n        _buf[_idx++] = c;\n        if (_idx == _len) {\n            _state = FOOTER;\n        }\n        break;\n    case FOOTER:\n        if (c == (_delim & 0xFF)) {\n            _delim = _delim >> 8;\n            if (_delim == 0) {\n                return true;\n            }\n        } else {\n            reset_rx();\n        }\n        break;\n    default:\n        reset_rx();\n        break;\n    }\n    return false;\n}\n\nsize_t RD03Protocol::get_data(uint8_t *data)\n{\n    memcpy(data, _buf, _len);\n    return _len;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_login_signup_ui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* A Bison parser, made by GNU Bison 3.8.2.  */\n\n/* Bison implementation for Yacc-like parsers in C\n\n   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,\n   Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\n\n/* As a special exception, you may create a larger work that contains\n   part or all of the Bison parser skeleton and distribute that work\n   under terms of your choice, so long as that work isn't itself a\n   parser generator using the skeleton or a modified version thereof\n   as a parser skeleton.  Alternatively, if you modify or redistribute\n   the parser skeleton itself, you may (at your option) remove this\n   special exception, which will cause the skeleton and the resulting\n   Bison output files to be licensed under the GNU General Public\n   License without this special exception.\n\n   This special exception was added by the Free Software Foundation in\n   version 2.2 of Bison.  */\n\n/* C LALR(1) parser skeleton written by Richard Stallman, by\n   simplifying the original so-called \"semantic\" parser.  */\n\n/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,\n   especially those whose name start with YY_ or yy_.  They are\n   private implementation details that can be changed or removed.  */\n\n/* All symbols defined below should begin with yy or YY, to avoid\n   infringing on user name space.  This should be done even for local\n   variables, as they might otherwise be expanded by user macros.\n   There are some unavoidable exceptions within include files to\n   define necessary library symbols; they are noted \"INFRINGES ON\n   USER NAME SPACE\" below.  */\n\n/* Identify Bison output, and Bison version.  */\n#define YYBISON 30802\n\n/* Bison version string.  */\n#define YYBISON_VERSION \"3.8.2\"\n\n/* Skeleton name.  */\n#define YYSKELETON_NAME \"yacc.c\"\n\n/* Pure parsers.  */\n#define YYPURE 2\n\n/* Push parsers.  */\n#define YYPUSH 1\n\n/* Pull parsers.  */\n#define YYPULL 0\n\n\n\n\n/* First part of user prologue.  */\n#line 1 \"parser.y\"\n\n  #include <iostream>\n  #include <set>\n  #include \"parser.hpp\"\n\n  extern int yylex();\n  void yyerror(YYLTYPE* loc, const char* err);\n  std::string* translate_boolean_str(std::string* boolean_str);\n\n  std::string* target_program;\n  std::set<std::string> symbols;\n  Tree * root;\n\n#line 85 \"parser.cpp\"\n\n# ifndef YY_CAST\n#  ifdef __cplusplus\n#   define YY_CAST(Type, Val) static_cast<Type> (Val)\n#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)\n#  else\n#   define YY_CAST(Type, Val) ((Type) (Val))\n#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))\n#  endif\n# endif\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n#include \"parser.hpp\"\n/* Symbol kind.  */\nenum yysymbol_kind_t\n{\n  YYSYMBOL_YYEMPTY = -2,\n  YYSYMBOL_YYEOF = 0,                      /* \"end of file\"  */\n  YYSYMBOL_YYerror = 1,                    /* error  */\n  YYSYMBOL_YYUNDEF = 2,                    /* \"invalid token\"  */\n  YYSYMBOL_IDENTIFIER = 3,                 /* IDENTIFIER  */\n  YYSYMBOL_BOOLEAN = 4,                    /* BOOLEAN  */\n  YYSYMBOL_INT = 5,                        /* INT  */\n  YYSYMBOL_FLOAT = 6,                      /* FLOAT  */\n  YYSYMBOL_NUMBER = 7,                     /* NUMBER  */\n  YYSYMBOL_STR = 8,                        /* STR  */\n  YYSYMBOL_DECIMAL = 9,                    /* DECIMAL  */\n  YYSYMBOL_BOOL = 10,                      /* BOOL  */\n  YYSYMBOL_INDENT = 11,                    /* INDENT  */\n  YYSYMBOL_DEDENT = 12,                    /* DEDENT  */\n  YYSYMBOL_NEWLINE = 13,                   /* NEWLINE  */\n  YYSYMBOL_NEGATION = 14,                  /* NEGATION  */\n  YYSYMBOL_LIST = 15,                      /* LIST  */\n  YYSYMBOL_NONE = 16,                      /* NONE  */\n  YYSYMBOL_DEF = 17,                       /* DEF  */\n  YYSYMBOL_FOR = 18,                       /* FOR  */\n  YYSYMBOL_IF = 19,                        /* IF  */\n  YYSYMBOL_RANGE = 20,                     /* RANGE  */\n  YYSYMBOL_PLUS = 21,                      /* PLUS  */\n  YYSYMBOL_MINUS = 22,                     /* MINUS  */\n  YYSYMBOL_TIMES = 23,                     /* TIMES  */\n  YYSYMBOL_DIVIDEDBY = 24,                 /* DIVIDEDBY  */\n  YYSYMBOL_INTDIVIDEDBY = 25,              /* INTDIVIDEDBY  */\n  YYSYMBOL_MOD = 26,             ",
    "/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n// BEGIN_INCLUDE(all)\n#include <EGL/egl.h>\n#include <GLES/gl.h>\n#include <android/log.h>\n#include <android/sensor.h>\n#include <android_native_app_glue.h>\n#include <jni.h>\n\n#include <cassert>\n#include <cerrno>\n#include <cstdlib>\n#include <cstring>\n#include <initializer_list>\n#include <memory>\n\n#define LOGI(...)                                                              \\\n  ((void)__android_log_print(ANDROID_LOG_INFO, \"native-activity\", __VA_ARGS__))\n#define LOGW(...)                                                              \\\n  ((void)__android_log_print(ANDROID_LOG_WARN, \"native-activity\", __VA_ARGS__))\n\n/**\n * Our saved state data.\n */\nstruct saved_state {\n  float angle;\n  int32_t x;\n  int32_t y;\n};\n\n/**\n * Shared state for our app.\n */\nstruct engine {\n  struct android_app *app;\n\n  ASensorManager *sensorManager;\n  const ASensor *accelerometerSensor;\n  ASensorEventQueue *sensorEventQueue;\n\n  int animating;\n  EGLDisplay display;\n  EGLSurface surface;\n  EGLContext context;\n  int32_t width;\n  int32_t height;\n  struct saved_state state;\n};\n\n/**\n * Initialize an EGL context for the current display.\n */\nstatic int engine_init_display(struct engine *engine) {\n  // initialize OpenGL ES and EGL\n\n  /*\n   * Here specify the attributes of the desired configuration.\n   * Below, we select an EGLConfig with at least 8 bits per color\n   * component compatible with on-screen windows\n   */\n  const EGLint attribs[] = {EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n                            EGL_BLUE_SIZE,    8,\n                            EGL_GREEN_SIZE,   8,\n                            EGL_RED_SIZE,     8,\n                            EGL_NONE};\n  EGLint w, h, format;\n  EGLint numConfigs;\n  EGLConfig config = nullptr;\n  EGLSurface surface;\n  EGLContext context;\n\n  EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n\n  eglInitialize(display, nullptr, nullptr);\n\n  /* Here, the application chooses the configuration it desires.\n   * find the best match if possible, otherwise use the very first one\n   */\n  eglChooseConfig(display, attribs, nullptr, 0, &numConfigs);\n  std::unique_ptr<EGLConfig[]> supportedConfigs(new EGLConfig[numConfigs]);\n  assert(supportedConfigs);\n  eglChooseConfig(display, attribs, supportedConfigs.get(), numConfigs,\n                  &numConfigs);\n  assert(numConfigs);\n  auto i = 0;\n  for (; i < numConfigs; i++) {\n    auto &cfg = supportedConfigs[i];\n    EGLint r, g, b, d;\n    if (eglGetConfigAttrib(display, cfg, EGL_RED_SIZE, &r) &&\n        eglGetConfigAttrib(display, cfg, EGL_GREEN_SIZE, &g) &&\n        eglGetConfigAttrib(display, cfg, EGL_BLUE_SIZE, &b) &&\n        eglGetConfigAttrib(display, cfg, EGL_DEPTH_SIZE, &d) && r == 8 &&\n        g == 8 && b == 8 && d == 0) {\n      config = supportedConfigs[i];\n      break;\n    }\n  }\n  if (i == numConfigs) {\n    config = supportedConfigs[0];\n  }\n\n  if (config == nullptr) {\n    LOGW(\"Unable to initialize EGLConfig\");\n    return -1;\n  }\n\n  /* EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is\n   * guaranteed to be accepted by ANativeWindow_setBuffersGeometry().\n   * As soon as we picked a EGLConfig, we can safely reconfigure the\n   * ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID. */\n  eglGetConfigAttrib(display, config, EGL_NATIVE_VISUAL_ID, &format);\n  surface =\n      eglCreateWindowSurface(display, config, engine->app->window, nullptr);\n  context = eglCreateContext(display, config, nullptr, nullptr);\n\n  if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE) {\n    LOGW(\"Unable to eglMakeCurrent\");\n    return -1;\n  }\n\n  eglQuerySurface(display, surface, EGL_WIDTH, &w);\n  eglQuerySurface(display, surface, EGL_HEIGHT, &h);\n\n  engine->display = display;\n  engine->context = context;\n  engine->surface = surface;\n  engine->width = w;\n  engine->height = h;\n  engine->state.angle = 0;\n\n  // Check openGL on the system\n  auto opengl_info = {GL_VENDOR, GL_RENDERER, GL_VERSION, GL_EXTENSIONS};\n  for (auto name : opengl_info) {\n    auto info = glGetString(name);\n    LOGI(\"OpenGL Info: %s\", info);\n  }\n  // Initialize GL state.\n  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_FASTEST);\n  glEnable(GL_CULL_FACE);\n  glShadeModel(GL_SMOOTH);\n  glDisable(GL_DEPTH_TEST);\n\n  return 0;\n}\n\n/**\n * Just the current frame in the display.\n */\nstatic void engine_draw_frame(struct engine *engine) {\n  if (engine->display == nullptr) {\n    // No display.\n    ",
    "#include <Windows.h>\r\n#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nLRESULT CALLBACK WindowProcedure(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);\r\nvoid LoadDictionary(const std::wstring& path);\r\nvoid SaveDictionary(const std::wstring& path);\r\nvoid AddWordToDictionary(const std::wstring& word);\r\n\r\n// \u00ce\u00e3\u00ee\u00eb\u00ee\u00f8\u00e5\u00ed\u00ed\u00ff \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00e8\u00f5 \u00e7\u00ec\u00b3\u00ed\u00ed\u00e8\u00f5 \u00e4\u00eb\u00ff \u00f2\u00e5\u00ec\r\nHBRUSH lightBackgroundBrush = CreateSolidBrush(RGB(255, 255, 255));\r\nHBRUSH darkBackgroundBrush = CreateSolidBrush(RGB(50, 50, 50));\r\nCOLORREF lightTextColor = RGB(0, 0, 0);\r\nCOLORREF darkTextColor = RGB(255, 255, 255);\r\n\r\n// \u00d1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea \u00e4\u00eb\u00ff \u00e7\u00e1\u00e5\u00f0\u00b3\u00e3\u00e0\u00ed\u00ed\u00ff \u00f1\u00eb\u00b3\u00e2\r\nstd::vector<std::wstring> dictionary;\r\nstd::wstring defaultDictionaryPath = L\"dictionary.txt\";\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00f1\u00f2\u00e2\u00ee\u00f0\u00e5\u00ed\u00ed\u00ff \u00e2\u00b3\u00ea\u00ed\u00e0 \u00ed\u00e0\u00eb\u00e0\u00f8\u00f2\u00f3\u00e2\u00e0\u00ed\u00fc\r\nvoid CreateSettingsWindow() {\r\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e5\u00ed\u00ed\u00ff \u00ea\u00eb\u00e0\u00f1\u00f3 \u00e2\u00b3\u00ea\u00ed\u00e0\r\n    WNDCLASS wc = {};\r\n    wc.lpfnWndProc = WindowProcedure;\r\n    wc.hInstance = GetModuleHandle(nullptr);\r\n    wc.lpszClassName = L\"SettingsWindowClass\";\r\n    RegisterClass(&wc);\r\n\r\n    // \u00d1\u00f2\u00e2\u00ee\u00f0\u00e5\u00ed\u00ed\u00ff \u00e2\u00b3\u00ea\u00ed\u00e0\r\n    HWND hwnd = CreateWindow(wc.lpszClassName, L\"\u00cd\u00e0\u00eb\u00e0\u00f8\u00f2\u00f3\u00e2\u00e0\u00ed\u00ed\u00ff\", WS_OVERLAPPEDWINDOW,\r\n        CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, nullptr, nullptr, wc.hInstance, nullptr);\r\n\r\n    // \u00c4\u00ee\u00e4\u00e0\u00e2\u00e0\u00ed\u00ed\u00ff \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2 \u00f3 \u00e2\u00b3\u00ea\u00ed\u00ee \u00ed\u00e0\u00eb\u00e0\u00f8\u00f2\u00f3\u00e2\u00e0\u00ed\u00fc\r\n\r\n    // \u00d2\u00e5\u00ea\u00f1\u00f2\u00ee\u00e2\u00e5 \u00ef\u00ee\u00eb\u00e5 \u00e4\u00eb\u00ff \u00e2\u00e2\u00e5\u00e4\u00e5\u00ed\u00ed\u00ff \u00f8\u00eb\u00ff\u00f5\u00f3 \u00e4\u00ee \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0\r\n    CreateWindowW(L\"STATIC\", L\"\u00d8\u00eb\u00ff\u00f5 \u00e4\u00ee \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0:\", WS_CHILD | WS_VISIBLE | SS_LEFT, 20, 20, 150, 20, hwnd, nullptr, nullptr, nullptr);\r\n    HWND hDictionaryEdit = CreateWindowW(L\"EDIT\", defaultDictionaryPath.c_str(), WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL, 180, 20, 180, 20, hwnd, nullptr, nullptr, nullptr);\r\n    SendMessage(hDictionaryEdit, EM_SETREADONLY, TRUE, 0);\r\n\r\n    // \u00c2\u00e8\u00e1\u00b3\u00f0 \u00f2\u00e5\u00ec\u00e8 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00e8\r\n    CreateWindowW(L\"STATIC\", L\"\u00d2\u00e5\u00ec\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00e8:\", WS_CHILD | WS_VISIBLE | SS_LEFT, 20, 60, 150, 20, hwnd, nullptr, nullptr, nullptr);\r\n    HWND hThemeComboBox = CreateWindowW(L\"COMBOBOX\", L\"\", WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST, 180, 60, 180, 150, hwnd, (HMENU)1001, nullptr, nullptr, nullptr);\r\n    SendMessageW(hThemeComboBox, CB_ADDSTRING, 0, (LPARAM)L\"\u00d1\u00e2\u00b3\u00f2\u00eb\u00e0\");\r\n    SendMessageW(hThemeComboBox, CB_ADDSTRING, 0, (LPARAM)L\"\u00d2\u00e5\u00ec\u00ed\u00e0\");\r\n\r\n    // \u00c2\u00e8\u00e1\u00b3\u00f0 \u00ec\u00ee\u00e2\u00e8\r\n    CreateWindowW(L\"STATIC\", L\"\u00cc\u00ee\u00e2\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00e8:\", WS_CHILD | WS_VISIBLE | SS_LEFT, 20, 100, 150, 20, hwnd, nullptr, nullptr, nullptr);\r\n    HWND hLanguageComboBox = CreateWindowW(L\"COMBOBOX\", L\"\", WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST, 180, 100, 180, 150, hwnd, (HMENU)1002, nullptr, nullptr, nullptr);\r\n    SendMessageW(hLanguageComboBox, CB_ADDSTRING, 0, (LPARAM)L\"\u00c0\u00ed\u00e3\u00eb\u00b3\u00e9\u00f1\u00fc\u00ea\u00e0\");\r\n    SendMessageW(hLanguageComboBox, CB_ADDSTRING, 0, (LPARAM)L\"\u00d3\u00ea\u00f0\u00e0\u00bf\u00ed\u00f1\u00fc\u00ea\u00e0\");\r\n    SendMessageW(hLanguageComboBox, CB_ADDSTRING, 0, (LPARAM)L\"\u00d0\u00ee\u00f1\u00b3\u00e9\u00f1\u00fc\u00ea\u00e0\");\r\n\r\n    // \u00cf\u00f0\u00e0\u00ef\u00ee\u00f0\u00e5\u00f6\u00fc \u00e4\u00eb\u00ff \u00e2\u00e8\u00e1\u00ee\u00f0\u00f3 \u00e0\u00e2\u00f2\u00ee\u00ec\u00e0\u00f2\u00e8\u00f7\u00ed\u00ee\u00e3\u00ee \u00e2\u00e8\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00ed\u00ff \u00f1\u00eb\u00b3\u00e2\r\n    CreateWindowW(L\"BUTTON\", L\"\u00c0\u00e2\u00f2\u00ee\u00ec\u00e0\u00f2\u00e8\u00f7\u00ed\u00e5 \u00e2\u00e8\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00ed\u00ff \u00f1\u00eb\u00b3\u00e2\", WS_CHILD | WS_VISIBLE | BS_CHECKBOX, 20, 140, 200, 20, hwnd, nullptr, nullptr, nullptr);\r\n\r\n    // \u00ca\u00ed\u00ee\u00ef\u00ea\u00e0 \"\u00c7\u00e1\u00e5\u00f0\u00e5\u00e3\u00f2\u00e8\"\r\n    CreateWindowW(L\"BUTTON\", L\"\u00c7\u00e1\u00e5\u00f0\u00e5\u00e3\u00f2\u00e8\", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, 150, 180, 100, 30, hwnd, (HMENU)1, nullptr, nullptr);\r\n\r\n    // \u00cf\u00ee\u00ea\u00e0\u00e7 \u00e2\u00b3\u00ea\u00ed\u00e0\r\n    ShowWindow(hwnd, SW_SHOW);\r\n}\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00e7\u00e0\u00e2\u00e0\u00ed\u00f2\u00e0\u00e6\u00e5\u00ed\u00ed\u00ff \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0 \u00b3\u00e7 \u00f4\u00e0\u00e9\u00eb\u00f3\r\nvoid LoadDictionary(const std::wstring& path) {\r\n    std::wifstream dictionaryFile(path);\r\n    if (dictionaryFile.is_open()) {\r\n        std::wstring word;\r\n        while (std::getline(dictionaryFile, word)) {\r\n            dictionary.push_back(word);\r\n        }\r\n        dictionaryFile.close();\r\n    }\r\n}\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00e7\u00e1\u00e5\u00f0\u00e5\u00e6\u00e5\u00ed\u00ed\u00ff \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0 \u00f3 \u00f4\u00e0\u00e9\u00eb\r\nvoid SaveDictionary(const std::wstring& path) {\r\n    std::wofstream dictionaryFile(path);\r\n    if (dictionaryFile.is_open()) {\r\n        for (const auto& word : dictionary) {\r\n            dictionaryFile << word << std::endl;\r\n        }\r\n        dictionaryFile.close();\r\n    }\r\n}\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00e4\u00ee\u00e4\u00e0\u00e2\u00e0\u00ed\u00ed\u00ff \u00f1\u00eb\u00ee\u00e2\u00e0 \u00e4\u00ee \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00e0\r\nvoid AddWordToDictionary(const std::wstring& word) {\r\n    // \u00cf\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ff\u00ba\u00ec\u00ee, \u00f7\u00e8 \u00f2\u00e0\u00ea\u00e5 \u00f1\u00eb\u00ee\u00e2\u00ee \u00f9\u00e5 \u00ed\u00e5 \u00e7\u00e1\u00e5\u00f0\u00e5\u00e6\u00e5\u00ed\u00ee \u00f3 \u00f1\u00eb\u00ee\u00e2\u00ed\u00e8\u00ea\u00f3\r\n    auto it = std::find(dictionary.begin(), dictionary.end(), word);\r\n    if (it == dictionary.end()) {\r\n        dictionary.push_back(word);\r\n    }\r\n}\r\n\r\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00e7\u00ec\u00b3\u00ed\u00e8 \u00f2\u00e5\u00ec\u00e8 \u00e2\u00b3\u00ea\u00ed\u00e0\r\nvoid ChangeTheme(HWND hwnd, bool isDarkTheme) {\r\n    if (isDarkTheme) {\r\n        SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG_PTR)darkBackgroundBrush);\r\n        SetTextColor(GetDC(hwnd), darkTextColor);\r\n    }\r\n    else {\r\n        SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG_PTR)lightBackgroundBrush);\r\n        SetTextColor(GetDC(hwnd), lightTextColor);\r\n    }\r\n    RedrawWindow(hwnd, nullptr, nullptr, RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);\r\n}\r\n\r\n// \u00ce\u00f1\u00ed\u00ee\u00e2\u00ed\u00e0 \u00f4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00ee\u00e1\u00f0\u00ee\u00e1\u00ea\u00e8 \u00ef\u00ee\u00e2\u00b3\u00e4\u00ee\u00ec\u00eb\u00e5\u00ed\u00fc \u00e2\u00b3\u00ea\u00ed\u00e0\r\nLRESULT CALLBACK WindowProcedure(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {\r\n    switch (message) {\r\n    case WM_CTLCOLORSTATIC: { // \u00ce\u00e1\u00f0\u00ee\u00e1\u00ea\u00e0 \u00ef\u00ee\u00e2\u00b3\u00e4\u00ee\u00ec\u00eb\u00e5\u00ed\u00ed\u00ff \u00ef\u00f0\u00ee \u00e7\u00ec\u00b3\u00ed\u00f3 \u00ea\u00ee\u00eb\u00fc\u00ee\u00f0\u00f3 \u00f2\u00e5\u00ea\u00f1\u00f2\u00f3 \u00e4\u00eb\u00ff \u00f1\u00f2\u00e0\u00f2\u00e8\u00f7\u00ed\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00f3\r\n        HDC hdcStatic = (HDC)wP",
    "#include \"func.h\"\n\nconst std::vector<std::string> nameList{\"Nojus\", \"Domas\", \"Arvydas\", \"Rokas\", \"Vytautas\", \"Aurimas\", \"Joris\", \"Ramunas\", \"Povilas\", \"Mindaugas\"};\nconst std::vector<std::string> surnameList{\"Vaicekauskas\", \"Kateiva\", \"Kardauskas\", \"Zalionis\", \"Norkus\", \"Ozelis\", \"Stasiunas\", \"Oginskas\", \"Petrauskas\", \"Pakuckas\"};\n\nStudent::Student() : hwRes_({0})\n{\n    name_ = \"NeraVardo\";\n    surname_ = \"NeraPavardes\";\n    exRes_ = 0;\n    avg_ = 0.0;\n    med_ = 0.0;\n}\n\nStudent::Student(std::string name, std::string surname) : hwRes_({0})\n{\n    name_ = name;\n    surname_ = surname;\n    exRes_ = 0;\n    avg_ = 0.0;\n    med_ = 0.0;\n}\n\nStudent::~Student()\n{\n    hwRes_.clear();\n}\n\nStudent::Student(const Student &Student_)\n{\n    name_ = Student_.name_;\n    surname_ = Student_.surname_;\n    hwRes_ = Student_.hwRes_;\n    exRes_ = Student_.exRes_;\n    avg_ = Student_.avg_;\n    med_ = Student_.med_;\n}\n\nStudent::Student(Student &&Student_) noexcept\n{\n    name_ = std::move(Student_.name_);\n    surname_ = std::move(Student_.surname_);\n    hwRes_ = std::move(Student_.hwRes_);\n    exRes_ = std::move(Student_.exRes_);\n    avg_ = std::move(Student_.avg_);\n    med_ = std::move(Student_.med_);\n    Student_.clear_All();\n    std::cout << \"Perkelimo operatorius suveike\" << std::endl;\n}\n\nStudent &Student::operator=(const Student &Student_)\n{\n    if (this != &Student_)\n    {\n        name_ = Student_.name_;\n        surname_ = Student_.surname_;\n        hwRes_ = Student_.hwRes_;\n        exRes_ = Student_.exRes_;\n        avg_ = Student_.avg_;\n        med_ = Student_.med_;\n    }\n    std::cout << \"Priskyrimo operatorius suveike\" << std::endl;\n    return *this;\n}\n\nStudent &Student::operator=(Student &&Student_) noexcept\n{\n    name_ = std::move(Student_.name_);\n    surname_ = std::move(Student_.surname_);\n    hwRes_ = std::move(Student_.hwRes_);\n    exRes_ = std::move(Student_.exRes_);\n    avg_ = std::move(Student_.avg_);\n    med_ = std::move(Student_.med_);\n    Student_.clear_All();\n    std::cout << \"Perkelimo operatorius suveike\" << std::endl;\n    return *this;\n}\n\nstd::istringstream &operator>>(std::istringstream &input, Student &Student_)\n{\n    std::string name, surname;\n    if (!(input >> name >> surname))\n        throw std::runtime_error(\"Nepavyko nuskaityti vardo ir pavardes\");\n    Student_.set_Name(name);\n    Student_.set_Name(surname);\n    int hw;\n    Student_.clear_Hw();\n    while (input >> hw)\n        Student_.set_Hw(hw);\n    if (!Student_.hwRes_Empty())\n    {\n        Student_.set_ExRes(Student_.hw_Last());\n        Student_.del_LastHw();\n        Student_.hw_Sort();\n        Student_.set_Avg(Student_.Average());\n        Student_.set_Med(Student_.Median());\n    }\n    std::cout << \"As esu ivedimo is failo operatoriuje >>\" << std::endl;\n    return input;\n}\n\nstd::istream &operator>>(std::istream &input, Student &Student_)\n{\n    std::string name, surname;\n    int hw, ex;\n    std::cout << \"Vardas: \";\n    std::cin >> name;\n    std::cout << \"Pavarde: \";\n    std::cin >> surname;\n    Student_.set_Name(name);\n    Student_.set_Surname(surname);\n    Student_.clear_Hw();\n    while (true)\n    {\n        std::cout << \"Namu darbu pazymys (\\\"-1\\\", kad uzbaigti): \";\n        std::cin >> hw;\n        if (std::cin.fail())\n            throw std::runtime_error(\"Klaidinga ivestis\");\n        if (hw < 0)\n            break;\n        Student_.set_Hw(hw);\n    }\n    std::cout << \"Egzamino pazymys: \";\n    std::cin >> ex;\n    if (std::cin.fail())\n        throw std::runtime_error(\"Klaidinga ivestis\");\n    Student_.set_ExRes(ex);\n    Student_.set_Avg(Student_.Average());\n    Student_.set_Med(Student_.Median());\n    std::cout << \"As esu ivedimo per konsole operatoriuje >>\" << std::endl;\n    return input;\n}\n\nstd::ostream &operator<<(std::ostream &output, const Student &Student_)\n{\n    output << std::left << std::setw(15) << Student_.get_Surname() << std::setw(15) << Student_.get_Name() << std::setw(20) << Student_.get_Avg() << std::setw(15) << Student_.get_Med() << std::endl;\n    std::cout << \"As esu isvedimo i konsole operatoriuje <<\" << std::endl;\n}\n\nstd::ofstream &operator<<(std::ofstream &output, const Student &Student_)\n{\n    std::stringstream out;\n    out << std::left << std::setw(15) << Student_.get_Surname() << std::setw(15) << Student_.get_Name() << std::setw(20) << Student_.get_Avg() << std::setw(15) << Student_.get_Med() << std::endl;\n    output << out.str();\n    out.clear();\n    return output;\n}\n\ndouble Student::Average()\n{\n    if (hwRes_Size() > 0)\n        return 0.4 * hw_Sum() / hwRes_Size() + 0.6 * get_exRes();\n    else\n        return 0.6 * get_exRes();\n}\n\ndouble Student::Median()\n{\n    std::vector<int> hwRes = get_HwRes();\n    int size = hwRes_Size();\n    if (size % 2 == 0 && size > 0)\n        return (hwRes[size / 2 - 1] + hwRes[size / 2]) / 2.0 * 0.4 + 0.6 * get_exRes();\n    else if (size % 2 != 0 && size > 0)\n        return hwRes[size / 2] * 0.4 + 0.6 * get_exRes();\n    else\n        return 0.6 * get_exRes();\n}\n\nbool compareName(const Student &a, cons",
    "#include <iostream>\n#include <cstring>\n \nusing namespace std;\n \nconst int MAX_N = 5e5 + 5, LOG_MAX = 30;\nint trie[MAX_N*LOG_MAX][2], overall_xor = 0, largest = 1;\n \nint is_bit_set(long long n, long long position)\n{\n    return ( (n& (1LL << position)) != 0);\n}\n \nvoid insert(int x)\n{\n    int p = 0;\n \n    for(int bit = 30; bit >= 0; bit--)\n    {\n        int current_bit = is_bit_set(x, bit);\n \n        if(trie[p][current_bit] == 0)\n        {\n            trie[p][current_bit] = largest;\n \n            largest++;\n        }\n \n        p = trie[p][current_bit];\n    }\n}\n \nint get_minimum_xor_with(int x)\n{\n    int answer = 0, p = 0;\n \n    for(int bit = 30; bit >= 0; bit--)\n    {\n        int current_bit = is_bit_set(x, bit);\n        int other_bit = !current_bit;\n \n        if(trie[p][current_bit] != 0)\n        {\n            p = trie[p][current_bit];\n        }\n        else\n        {\n            p = trie[p][other_bit];\n            answer |= (1 << bit);\n        }\n    }\n \n    return answer;\n}\n \nvoid answer()\n{\n    const int INSERT = 1, XOR_ALL = 2, FIND_MINIMUM = 3;\n    int query_type;\n    cin >> query_type;\n \n    switch(query_type)\n    {\n        case INSERT : int element;\n                      cin >> element;\n                      element ^= overall_xor;\n                      insert(element);\n                      break;\n \n        case XOR_ALL : int x;\n                       cin >> x;\n                       overall_xor ^= x;\n                       break;\n \n        case FIND_MINIMUM : cout << get_minimum_xor_with(overall_xor) << \"\\n\";\n                            break;\n \n        default : cout << \"Invalid Query\\n\";\n    }\n}\n \nint main()\n{\n    memset(trie, 0, sizeof(trie));\n    insert(0);\n \n\tint no_of_queries;\n\tcin >> no_of_queries;\n \n\twhile(no_of_queries--)\n\t    answer();\n \n\treturn 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Include important C++ libraries here\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n\n// Make code easier to type with \"using namespace\"\nusing namespace sf;\nusing namespace std;\n\nint main()\n{\n    // Create a video mode object\n\tVideoMode vm(1920, 1080);\n\t// Create and open a window for the game\n\tRenderWindow window(vm, \"Chaos Game!!\", Style::Default);\n\n    vector<Vector2f> vertices;\n    vector<Vector2f> points;\n\n\tFont font;\n\tif (!font.loadFromFile(\"KOMIKAP_.ttf\"))\n\t{\n\t\tcerr << \"Something wrong with font.\" << endl;\n\t}\n\t\n\tText displayCoords; //new object to show the coordinates to user\n\tdisplayCoords.setFont(font);\n\tdisplayCoords.setCharacterSize(15);\n\tdisplayCoords.setFillColor(Color::White);\n\tdisplayCoords.setPosition(1500.f, 600.f); // need to change coords\n\tstring completestring = \"\";\n\tstring displayvertices;\n\n\n\twhile (window.isOpen())\n\t{\n        /*\n\t\t****************************************\n\t\tHandle the players input\n\t\t****************************************\n\t\t*/\n        Event event;\n\t\twhile (window.pollEvent(event))\n\t\t{\n\n\t\t\n\t\t\tif (event.type == Event::Closed)\n            {\n\t\t\t\t// Quit the game when the window is closed\n\t\t\t\twindow.close();\n            }\n            if (event.type == sf::Event::MouseButtonPressed)\n            {\n\t\t\t\tFont font;\n            \tif (event.mouseButton.button == sf::Mouse::Left)\n                {\n                    std::cout << \"the left button was pressed\" << std::endl;\n                    std::cout << \"mouse x: \" << event.mouseButton.x << std::endl;\n                    std::cout << \"mouse y: \" << event.mouseButton.y << std::endl;\n\n                    if(vertices.size() < 3)\n                    {\n                        vertices.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n\t\t\t\t\t\tdisplayvertices = \"Vertex \" + to_string(vertices.size()) + \"\\nmouse x: \" + to_string(event.mouseButton.x) + \"\\nmouse y: \" + to_string(event.mouseButton.y) +\"\\n\";\n\t\t\t\t\t\tcompletestring = completestring + displayvertices;\n\t\t\t\t\t\tdisplayCoords.setString(completestring);\n                    }\n                    else if(points.size() == 0)\n                    {\n\t\t\tpoints.push_back(Vector2f(event.mouseButton.x, event.mouseButton.y));\n                        ///fourth click\n                        ///push back to points vector\n                    }\n                }\n            }\n        }\n        if (Keyboard::isKeyPressed(Keyboard::Escape))\n\t\t{\n\t\t\twindow.close();\n\t\t}\n        /*\n\t\t****************************************\n\t\tUpdate\n\t\t****************************************\n\t\t*/\n\n        if(points.size() > 0)\n        {\n            ///generate more point(s)\n            ///select random vertex\n            ///calculate midpoint between random vertex and the last point in the vector\n            ///push back the newly generated coord.\n\t    \tfor (int i=0; i<50; i++)\n\t\t\t{\n\t\t\t\tint index=rand() % vertices.size();\n\t\t\t\tVector2f randVertex = vertices[index];\n\n\t\t\t\tVector2f midpoint = (randVertex + points.back())/2.0f;\n\t\t\t\tpoints.push_back(midpoint);\n\n\t\t\t\tRectangleShape rect(Vector2f(5,5));\n\t\t\t\trect.setPosition(midpoint);\n\t\t\t\trect.setFillColor(Color::Red);\n\t\t\t\twindow.draw(rect);\n\t\t\t}\n        }\n\n        /*\n\t\t****************************************\n\t\tDraw\n\t\t****************************************\n\t\t*/\n        window.clear();\n        for(unsigned long long int i = 0; i < vertices.size(); i++)\n        {\n            RectangleShape rect(Vector2f(10,10));\n            rect.setPosition(Vector2f(vertices[i].x, vertices[i].y));\n            rect.setFillColor(Color::Blue);\n            window.draw(rect);\n        }\n\tfor (unsigned long long int i=0; i< points.size();i++){\n\t    RectangleShape rect(Vector2f(5,5));\n\t    rect.setPosition(Vector2f(points[i].x, points[i].y));\n\t    rect.setFillColor(Color::Blue);\n\t    window.draw(rect);\n\t}\n\n    \tText text;\n    \ttext.setFont(font);\n    \ttext.setCharacterSize(25);\n    \ttext.setFillColor(Color::White);\n    \ttext.setPosition(10.f, 10.f);\n    \ttext.setString(\"Click on 3 spots to set up triangle vertices. \\nThen click for the 4th point to start generating the fractal. \");\n\t\t\n\twindow.draw(text);\n\twindow.draw(displayCoords);\n\twindow.display();\n    }\n}\n//Karnpreet Klair and Musa Rana",
    "#include \"Arduino.h\"\r\n#include \"Fok_Gyem.h\"\r\n#include \"font.h\"\r\n\r\n\r\n\r\nFok_Gyem::Fok_Gyem(const uint8_t digit_num, uint8_t* digit_pins, uint8_t* polarity_pins,\r\n\tconst uint8_t latch_pin, const uint8_t clock_pin, const uint8_t data_pin, const uint8_t oe_pin)\r\n\t\r\n\t: latchPin(latch_pin), clockPin(clock_pin), dataPin(data_pin), OE_pin(oe_pin), digit_num(digit_num), \r\n\tdigits(digit_pins), polarity_sw(polarity_pins)\r\n\t\r\n\t{ }\r\n\r\n\r\nFok_Gyem::~Fok_Gyem()\r\n\t{}\r\n\r\nvoid Fok_Gyem::init() {\r\n\tfont_ptr = Departures;\r\n\tpinMode(latchPin, OUTPUT);\r\n\tpinMode(clockPin, OUTPUT);\r\n\tpinMode(dataPin, OUTPUT);\r\n\tpinMode(OE_pin, OUTPUT);\r\n\tfor (byte i = 0; i < digit_num; i++) {\r\n\t\tpinMode(digits[i], OUTPUT);\r\n\t\t}\r\n\tfor (byte i = 0; i < 2; i++) {\r\n\t\tpinMode(polarity_sw[i], OUTPUT);\r\n\t\t}\r\n\tshift_clear_all();\r\n\r\n\t}\r\n\r\nvoid Fok_Gyem::print_digit(uint8_t pos, uint8_t digit) {\r\n\t\r\n\tfor (uint8_t i = 0; i < pixel_cols_num; i++) {\r\n\t\tuint8_t mask = pgm_read_byte(font_ptr + FONT_DATA_START + digit * 5 + i);\r\n\t\tuint8_t neg_mask = mask ^ polarity_mask[i];\r\n\t\tuint8_t pos_mask = ~neg_mask;\r\n\t\tload_font_data(i, pos_mask);\r\n\t\twrite_data(pos, 0);\r\n\t\tdelay(30);\r\n\t\tload_font_data(i, neg_mask);\r\n\t\twrite_data(pos, 1);\r\n\t\tdelay(30);\r\n\t\t}\r\n\r\n\t}\r\n\r\n// fill every digit with bitmask\r\nvoid Fok_Gyem::fillDisplay(uint8_t mask) {\r\n\tfor (uint8_t i = 0; i < pixel_cols_num; i++) {\r\n\r\n\t\tuint8_t neg_mask = mask ^ polarity_mask[i];\r\n\t\tuint8_t pos_mask = ~neg_mask;\r\n\t\tload_font_data(i, pos_mask);\r\n\t\tfor (uint8_t d = 0; d < digit_num; d++) {\r\n\t\t\twrite_data(d, 0);\r\n\t\t\tdelay(10);\r\n\t\t\t}\r\n\t\tload_font_data(i, neg_mask);\r\n\t\tfor (uint8_t d = 0; d < digit_num; d++) {\r\n\t\t\twrite_data(d, 1);\r\n\t\t\tdelay(10);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n// clear all shift registers\r\nvoid Fok_Gyem::shift_clear_all() {\r\n\tload_font_data(0, 0);\r\n\t}\r\n\r\n\r\n// load bit data to shift register for single flip dot column (do not output to solenoids)\r\nvoid Fok_Gyem::load_font_data(uint8_t col, uint8_t mask) {\r\n\tif (col >= pixel_cols_num) return;\r\n\tuint8_t out = mask;\r\n\tdigitalWrite(latchPin, LOW); // \u00ed\u00e0\u00f7\u00e8\u00ed\u00e0\u00e5\u00ec \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00f7\u00f3 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5\r\n\tfor (uint8_t i = 0; i < pixel_cols_num; i++) {\r\n\t\tif (i == col) { out = mask; }\r\n\t\telse { out = 0; }\r\n\t\tshiftOut(dataPin, clockPin, MSBFIRST, out);\r\n\t\t}\r\n\tdigitalWrite(latchPin, HIGH);\r\n\t}\r\n\r\n// same as load_font_data(), but inverse column order and use LSBFIRST\r\nvoid Fok_Gyem::load_data(uint8_t col, uint8_t mask) {\r\n\tif (col >= pixel_cols_num) return;\r\n\tuint8_t out = mask;\r\n\tdigitalWrite(latchPin, LOW); // \u00ed\u00e0\u00f7\u00e8\u00ed\u00e0\u00e5\u00ec \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00f7\u00f3 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5\r\n\tfor (uint8_t i = 0; i < pixel_cols_num; i++) {\r\n\t\tif (i == ((pixel_cols_num - col) - 1)) { out = mask; }\r\n\t\telse { out = 0; }\r\n\t\tshiftOut(dataPin, clockPin, LSBFIRST, out);\r\n\t\t}\r\n\tdigitalWrite(latchPin, HIGH);\r\n\t}\r\n\r\n// write data from shift register to flip dots solenoids\r\nvoid Fok_Gyem::write_data(uint8_t pos, bool polarity) {\r\n\tif (pos >= digit_num) return;\r\n\r\n\tdigitalWrite(digits[pos], HIGH);\r\n\tdigitalWrite(polarity_sw[polarity], HIGH);\r\n\tdelay(30);\r\n\tdigitalWrite(polarity_sw[polarity], LOW);\r\n\tdigitalWrite(digits[pos], LOW);\r\n\t}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"TodoList.hpp\"\n\nTodoList::TodoList() {\n    std::fstream todo_file(\"todo.dat\", std::ios::in | std::ios::binary);\n        \n    while(todo_file.peek() != EOF) {\n        std::string description;\n        std::getline(todo_file, description, '\\0');\n        bool completed;\n        todo_file.read(reinterpret_cast<char*>(&completed), sizeof(bool));\n        todo_list.push_back(TodoItem(description, completed));\n    }\n}\n\nvoid TodoList::add_todo(const std::string& todo) {\n    todo_list.push_back(TodoItem(todo));\n}\n\nvoid TodoList::display_todo() const {\n    if(todo_list.empty()) {\n        std::cout << \"\\nTodo list is empty.\\n\\n\";\n        return;\n    }\n\n    std::cout << \"\\nTodo List:\\n\";\n        \n    int todo_count = 1;\n    for(const auto& todo : todo_list) {\n        std::cout << todo_count++ << \" | \" << todo.get_todo() << \" | \" << (todo.get_status() ? \"Completed\" : \"Not completed\") << \"\\n\";\n    }\n\n    std::cout << \"\\n\";\n}\n\nvoid TodoList::save_todo() {\n    std::fstream todo_file(\"todo.dat\", std::ios::out | std::ios::binary);\n\n    for(const auto& todo : todo_list) {\n        std::string description = todo.get_todo();\n        bool status = todo.get_status();\n        todo_file.write(description.c_str(), description.size() + 1);\n        todo_file.write(reinterpret_cast<char*>(&status), sizeof(bool));\n    }\n}\n\nsize_t TodoList::elements() const {\n    return todo_list.size();\n}\n\nTodoItem& TodoList::operator[](size_t index) {\n    return todo_list.at(index);\n}",
    "#include <iostream>\n#include \"Campanha.hpp\"\n#include \"EscolhaClasse.hpp\"\n#include \"Personagem.hpp\"\n#include \"Inventario.hpp\"\n#include \"ataques.hpp\"\n#include \"economia.hpp\"\nint main() {\n   // Solicitar ao usu\u00e1rio que escolha a campanha\n    Campanha campanha;\n    std::string nomeCampanha = campanha.escolherCampanha();\n     std::string classePersonagem = escolherClasse();\n\n    if (!nomeCampanha.empty()) {\n        std::cout << \"Campanha selecionada: \" << nomeCampanha << std::endl;\n\n        // Solicitar ao usu\u00e1rio que entre com o nome do personagem\n        std::string nomePersonagem;\n        std::cout << \"Digite o nome do seu personagem: \";\n        std::cin >> nomePersonagem;\n\n        // Solicitar ao usu\u00e1rio que escolha a classe do personagem\n        std::string classePersonagem = escolherClasse();\n\n        // Criar um novo personagem com o nome e classe escolhidos e exibir informa\u00e7\u00f5es\n        Personagem personagem = criarPersonagem(nomePersonagem, classePersonagem);\n        std::cout << \"\\nPersonagem criado com sucesso!\\n\";\n        personagem.exibir();\n    }\n    system (\"pause\");\n    system (\"cls\");\n\n    // Criar um objeto da classe Economia\n    Economia economia;\n\n    // Exemplo de uso da economia\n    economia.ganharOuro(100); // O jogador come\u00e7a com 100 de ouro\n    std::cout << \"O jogador tem \" << economia.getOuro() << \" de ouro.\" << std::endl;\n\n   bool continuarComprando = true; // Vari\u00e1vel para controlar se o jogador deseja continuar comprando\n\nwhile (continuarComprando) {\n    // Cria um invent\u00e1rio para o jogador\n    Inventario inventario(economia);\n\n    std::cout << \"\\nBem-vindo(a) \u00e0 loja!\" << std::endl;\n    std::cout << \"Escolha os itens que deseja comprar:\" << std::endl;\n    std::cout << \"1. Espada (10 de ouro)\" << std::endl;\n    std::cout << \"2. Po\u00e7\u00e3o de vida (5 de ouro)\" << std::endl;\n    std::cout << \"3. Armadura (15 de ouro)\" << std::endl;\n    std::cout << \"4. Po\u00e7\u00e3o de mana (8 de ouro)\" << std::endl;\n    std::cout << \"0. Sair da loja\" << std::endl; // Op\u00e7\u00e3o para sair da loja\n\n    int escolha;\n    std::cin >> escolha;\n\n    switch (escolha) {\n        case 1:\n            inventario.adicionarItem(\"Espada\", 1, 10);\n            break;\n        case 2:\n            inventario.adicionarItem(\"Po\u00e7\u00e3o de vida\", 1, 5);\n            break;\n        case 3:\n            inventario.adicionarItem(\"Armadura\", 1, 15);\n            break;\n        case 4:\n            inventario.adicionarItem(\"Po\u00e7\u00e3o de mana\", 1, 8);\n            break;\n        case 0:\n            // Op\u00e7\u00e3o para sair da loja\n            continuarComprando = false;\n            break;\n        default:\n            std::cout << \"Op\u00e7\u00e3o inv\u00e1lida!\" << std::endl;\n            break;\n    }\n\n    // Verifica se o jogador escolheu sair da loja\n    if (!continuarComprando) {\n        std::cout << \"Saindo da loja...\" << std::endl;\n        break; // Sai do loop\n    }\n\n    std::cout << \"\\nItens comprados:\" << std::endl;\n    inventario.mostrarItens();\n    system (\"pause\");\n    system (\"cls\");\n}\n\nint x;\nfor(x=0; x<=4; x++){\n    \n    Ataques ataque;\n        std::cout << \"\\nEscolha um ataque para usar:\" << std::endl;\n        if (classePersonagem == \"Mago\") {\n            ataque.adicionarAtaque(\"Bola de fogo\");\n            ataque.adicionarAtaque(\"Raio\");\n        } else if (classePersonagem == \"Guerreiro\") {\n            ataque.adicionarAtaque(\"Corte horizontal\");\n            ataque.adicionarAtaque(\"Investida\");\n        } else if (classePersonagem == \"Assassino\") {\n            ataque.adicionarAtaque(\"Ataque sorrateiro\");\n            ataque.adicionarAtaque(\"Arremesso de adaga\");\n        } else if (classePersonagem == \"Monge\") {\n            ataque.adicionarAtaque(\"Chute girat\u00f3rio\");\n            ataque.adicionarAtaque(\"Soco r\u00e1pido\");\n        }\n\n        ataque.mostrarOpcoes();\n}\n\nreturn 0;\n}",
    "#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <conio.h>\n#define pi 3.14159\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\n#define nl endl\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define mod 90000007\n#define fs(n) fixed << setprecision(int(n))\n#define s(n) setprecision(int(n))\nusing namespace std;\n\nclass student\n{\nprivate:\n    string name, roll, course, address, email, contact;\n\npublic:\n    void menu();\n    void insert();\n    void display();\n    void modify();\n    void search();\n    void deleteData();\n};\n\nvoid student::insert()\n{\n    system(\"cls\");\n\n    fstream file;\n    cout << \"\\n\";\n    cout << \"\\t\\t-------------------------------------\\n\";\n    cout << \"\\t\\t|---       Add Student Data      ---|\\n\";\n    cout << \"\\t\\t-------------------------------------\\n\";\n    cout << \"\\t\\tEnter Name: \";\n    cin >> name;\n    cout << \"\\t\\tEnter Roll: \";\n    cin >> roll;\n    cout << \"\\t\\tEnter Course: \";\n    cin >> course;\n    cout << \"\\t\\tEnter Contact: \";\n    cin >> contact;\n    cout << \"\\t\\tEnter Email: \";\n    cin >> email;\n    cout << \"\\t\\tEnter Address: \";\n    cin >> address;\n\n    file.open(\"studentdata.txt\", ios::app | ios::out);\n    file << \" \" << name << \" \" << roll << \" \" << course << \" \" << email << \" \" << contact << \" \" << address << endl;\n    file.close();\n}\n\nvoid student::display()\n{\n    string name, roll, course, address, email, contact;\n    int total = 1;\n    system(\"cls\");\n    fstream file;\n    cout << \"\\t\\t-------------------------------------\\n\";\n    cout << \"\\t\\t|---     Display Student Data    ---|\\n\";\n    cout << \"\\t\\t-------------------------------------\\n\";\n\n    file.open(\"studentdata.txt\", ios::in);\n    if (!file)\n    {\n        cout << \"\\n\\t\\t No data found!!!\\n\";\n        file.close();\n    }\n    else\n    {\n        // file >> name >> roll >> course >> email >> contact >> address;\n        while (!file.eof())\n        {\n            cout << \"\\n\\n\\t\\t|---     Student Data    ---|\\n\";\n            cout << \"\\t\\tStudent No: \" << total++ << endl;\n            cout << \"\\t\\tStudent Name: \" << name << endl;\n            cout << \"\\t\\tStudent Roll: \" << roll << endl;\n            cout << \"\\t\\tStudent Course: \" << course << endl;\n            cout << \"\\t\\tStudent Email: \" << email << endl;\n            cout << \"\\t\\tStudent Contact: \" << contact << endl;\n            cout << \"\\t\\tStudent Address: \" << address << endl;\n            file >> name >> roll >> course >> email >> contact >> address;\n        }\n\n        if (total == 0)\n        {\n\n            cout << \"\\n\\t\\t No data found!!!\\n\";\n        }\n    }\n\n    file.close();\n}\n\nvoid student::modify()\n{\n    system(\"cls\");\n    fstream file, file1;\n\n    cout << endl;\n    cout << \"\\t\\t-------------------------------------\\n\";\n    cout << \"\\t\\t|---     Student Data Modify     ---|\\n\";\n    cout << \"\\t\\t-------------------------------------\\n\";\n\n    string roll_select;\n    int found = 0;\n    file.open(\"studentdata.txt\", ios::in);\n\n    if (!file)\n    {\n        cout << \"\\n\\t\\t No data found!!!\\n\";\n        file.close();\n    }\n    else\n    {\n        cout << \"\\nEnter roll no to select student: \";\n        cin >> roll_select;\n\n        file1.open(\"data.txt\", ios::app | ios::out);\n\n        file >> name >> roll >> course >> email >> contact >> address;\n        while (!file.eof())\n        {\n            if (roll != roll_select)\n            {\n                file1 << \" \" << name << \" \" << roll << \" \" << course << \" \" << email << \" \" << contact << \" \" << address << endl;\n            }\n            else\n            {\n                cout << \"\\t\\tEnter Name: \";\n                cin >> name;\n                cout << \"\\t\\tEnter Roll: \";\n                cin >> roll;\n                cout << \"\\t\\tEnter Course: \";\n                cin >> course;\n                cout << \"\\t\\tEnter Contact: \";\n                cin >> contact;\n                cout << \"\\t\\tEnter Email: \";\n                cin >> email;\n                cout << \"\\t\\tEnter Address: \";\n                cin >> address;\n\n                file1 << \" \" << name << \" \" << roll << \" \" << course << \" \" << email << \" \" << contact << \" \" << address << endl;\n\n                found++;\n            }\n\n            file >> name >> roll >> course >> email >> contact >> address;\n            if (found == 0)\n            {\n                cout << \"\\t\\tStudent Roll not found.\\n\";\n            }\n        }\n\n        file1.close();\n        file.close();\n        remove(\"studentdata.txt\");\n        rename(\"data.txt\", \"studentdata.txt\");\n    }\n}\n\nvoid student::search(){\n    system(\"cls\");\n    fstream file;\n    int found=0;\n    file.open(\"studentdata.txt\", ios::in);\n    if(!file){\n        \n        cout << endl;\n        cout << \"\\t\\t-------------------------------------\\n\";\n        cout << \"\\t\\t|---     Student Data Search     ---|\\n\";\n        cout << \"\\t\\t-------------------------------------\\n\";\n\n        cout<<\"\\n\\n\\t\\t------     No data found    -----\\n\";\n\n\n    }else{\n        string rol",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\r\n#include <iostream>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <string>\r\n#include <cmath>\r\n#include <fstream> \r\n#include <sstream> \r\n#include <cmath> \r\n\r\nusing namespace std;\r\n\r\n#define M_PI 3.14159265358979323846\r\n\r\nenum class SeatType {\r\n    ECONOMY,\r\n    BUSINESS,\r\n    FIRST_CLASS\r\n};\r\n\r\nenum class FoodOption {\r\n    VEGETARIAN,\r\n    NON_VEGETARIAN,\r\n    BOTH\r\n};\r\n\r\nclass Seat {\r\npublic:\r\n    SeatType seatType;\r\n    string seatNumber;\r\n\r\n    Seat(SeatType type, const string& number) : seatType(type), seatNumber(number) {}\r\n};\r\n\r\nclass Aircraft {\r\npublic:\r\n    string model;\r\n    size_t economySeats;\r\n    size_t businessSeats;\r\n    size_t firstClassSeats;\r\n\r\n    Aircraft(const string& mdl, size_t economy, size_t business, size_t firstClass)\r\n        : model(mdl), economySeats(economy), businessSeats(business), firstClassSeats(firstClass) {}\r\n};\r\n\r\nclass Airport {\r\npublic:\r\n    string airportCode;\r\n    string airportName;\r\n    string location;\r\n    int runway; // Changed to integer\r\n    double latitude;\r\n    double longitude;\r\n\r\n    Airport(const string& code, const string& name, const string& loc, int rw, double lat, double lon)\r\n        : airportCode(code), airportName(name), location(loc), runway(rw), latitude(lat), longitude(lon) {}\r\n\r\n};\r\n\r\nclass Flight {\r\npublic:\r\n    string flightNumber;\r\n    string departureAirport;\r\n    string destinationAirport;\r\n    string departureTime;\r\n    string departureDay;\r\n    string arrivalTime;\r\n    string arrivalDay;\r\n    Aircraft aircraft;\r\n    vector<Seat> availableSeats;\r\n    FoodOption foodOption;\r\n    unordered_map<string, Airport>& airports; \r\n\r\n    Flight(const string& number, const string& departure, const string& destination,\r\n        const string& depTime, const string& depDay, const string& arrTime, const string& arrDay,\r\n        const Aircraft& ac, FoodOption food, unordered_map<string, Airport>& airportMap)\r\n        : flightNumber(number), departureAirport(departure), destinationAirport(destination),\r\n        departureTime(depTime), departureDay(depDay), arrivalTime(arrTime), arrivalDay(arrDay),\r\n        aircraft(ac), foodOption(food), airports(airportMap) {\r\n            initializeSeats();\r\n        }\r\n\r\n    void displaySeatDetails() const {\r\n        cout << \"Seat Details for \" << flightNumber << \":\" << endl;\r\n\r\n        displaySeatDetailsByClass(SeatType::ECONOMY, \"Economy Class\");\r\n        displaySeatDetailsByClass(SeatType::BUSINESS, \"Business Class\");\r\n        displaySeatDetailsByClass(SeatType::FIRST_CLASS, \"First Class\");\r\n\r\n        cout << endl;\r\n    }\r\n\r\n    double calculateDistance() const {\r\n        // Get departure and destination airports\r\n        auto departureAirportIter = airports.find(departureAirport);\r\n        auto destinationAirportIter = airports.find(destinationAirport);\r\n\r\n        if (departureAirportIter != airports.end() && destinationAirportIter != airports.end()) {\r\n            const Airport& departureAirport = departureAirportIter->second;\r\n            const Airport& destinationAirport = destinationAirportIter->second;\r\n\r\n            // Calculate distance using Haversine formula\r\n            double distance = calculateDistance(departureAirport, destinationAirport);\r\n            return distance;\r\n        } else {\r\n            cerr << \"Error: Departure or destination airport not found.\" << endl;\r\n            return 0.0;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    void displaySeatDetailsByClass(SeatType seatClass, const string& className) const {\r\n        cout << \"   \" << className << \":\" << endl;\r\n        for (const auto& seat : availableSeats) {\r\n            if (seat.seatType == seatClass) {\r\n                cout << \"      \" << seat.seatNumber;\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n\r\n    void initializeSeats() {\r\n        for (size_t i = 1; i <= aircraft.economySeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::ECONOMY, \"E\" + to_string(i)));\r\n        }\r\n\r\n        for (size_t i = 1; i <= aircraft.businessSeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::BUSINESS, \"B\" + to_string(i)));\r\n        }\r\n\r\n        for (size_t i = 1; i <= aircraft.firstClassSeats; ++i) {\r\n            availableSeats.push_back(Seat(SeatType::FIRST_CLASS, \"F\" + to_string(i)));\r\n        }\r\n    }\r\n\r\n    double calculateDistance(const Airport& source, const Airport& destination) const {\r\n        // We change radian to degree\r\n        double lat1 = source.latitude * M_PI / 180.0;\r\n        double lon1 = source.longitude * M_PI / 180.0;\r\n        double lat2 = destination.latitude * M_PI / 180.0;\r\n        double lon2 = destination.longitude * M_PI / 180.0;\r\n\r\n        // Earth radius in kilometers\r\n        const double R = 6371.0;\r\n\r\n        // Haversine formula\r\n        double dlon = lon2 - lon1;\r\n        double dlat = lat2 - lat1;\r\n        double a = sin(dlat / 2) * sin(dlat / 2) + cos(lat1) * cos(lat2) * sin(dlon / 2) * sin(dlon / 2);\r\n        double c = 2 * atan2(sqrt(a), sqrt(1 - a));\r\n        double distance =",
    "//github.com/ThatSmittyDude\r\n//ThatSmittyDude@outlook.com\r\n//passingunderyellow.com\r\n//Unix Timestamp: 1713238781\r\n//up2par\r\n#include <iostream>\r\n#include <cstdlib> //Include for system()\r\n\r\nint main() {\r\n    while(true){ //Added this loop for _v1.3 to allow user to see results before app breaks\r\n   \r\n        //Bash scrpit paths\r\n        const char* bashScriptPath1 = \"bat\\\\wngt.bat\";\r\n        const char* bashScriptPath2 = \"bat\\\\scnnow.bat\";\r\n        const char* bashScriptPath3 = \"bat\\\\dskclnp.bat\";\r\n\r\n        //we will execute the bash scrpts in a CLI\r\n        int result1 = system((\"Powershell.exe -Command \\\"& { .\\\\'\" + std::string(bashScriptPath1) +\"' }\\\"\").c_str());\r\n        int result2 = system((\"Powershell.exe -Command \\\"& { .\\\\'\" + std::string(bashScriptPath2) +\"' }\\\"\").c_str());\r\n        int result3 = system((\"Powershell.exe -Command \\\"& { .\\\\'\" + std::string(bashScriptPath3) +\"' }\\\"\").c_str());\r\n\r\n        //Print results\r\n        if (result1 == 0 && result2 == 0){\r\n            std::cout << \"All bash scripts executed succesfully!\\n\";\r\n        }else{\r\n            std::cout << \"Error executing bash scripts.\\n\";\r\n        }\r\n        return 0;\r\n\r\n}\r\nreturn 0;\r\n}",
    "\ufeff#include \"core/trace.hpp\"\r\n#include \"core/network.hpp\"\r\n\r\nint main()\r\n{\r\n\tint choice;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\r\n\t\tstd::cout << R\"(\r\n                                            \r\n                                                            \r\n                 *//                                          \r\n             .*/****/.       ,***************                 \r\n        *****************************************             \r\n      ******(***************************************          \r\n   .********%#***************************************         \r\n   **************************************************.        \r\n        ////**********************//******************        \r\n                ////*************////*****************        \r\n                   ////*******///////****************         \r\n                       //*****///////*********************    \r\n                          ***.          *********     ******* \r\n                        *****        ********             ****\r\n                                                          ****\r\n                                                      ,*****  \r\n                             .*************************       \r\n\r\n\t)\" << '\\n';\r\n\r\n\t\tg_network = std::make_unique<network>();\r\n\t\tg_trace = std::make_unique<trace>();\r\n\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tg_trace->m_fivem_path = g_trace->set_folder(\"Select FiveM Folder which contains FiveM.exe\");\r\n\r\n\t\t\tsystem(\"cls\");\r\n\r\n\t\t\tif (!g_trace->m_fivem_path.empty())\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Selected Folder]  \" << g_trace->m_fivem_path << std::endl;\r\n\t\t\t\tstd::cout << \"  [Launch Build]  \" << g_trace->get_launch_build() << \"\\n\" << std::endl;\r\n\t\r\n\t\t\t\tstd::cout << \"  [1]  :  \" << \"clean traces\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [2]  :  \" << \"enable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [3]  :  \" << \"disable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [4]  :  \" << \"reset fivem path\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [5]  :  \" << \"edit launch options\" << std::endl;\r\n\t\t\t\tstd::cin >> choice;\r\n\r\n\t\t\t\tswitch (choice)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 5:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->set_launch_build();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Error]  :  \" << \"select valid folder for FiveM\" << \"\\n\" << std::endl;\r\n\t\t\t}\r\n\r\n\t\t\tsystem(\"Pause\");\r\n\t\t}\r\n\r\n\t\tsystem(\"Pause\");\r\n\t}\r\n\r\n}\r\n",
    "#include \"Customer.h\"\n#include <iostream>\n#include <string>\n#include \"Date.h\"\n#include <fstream>\n\nusing namespace std;\nCustomer::Customer()\n{\n\n}\n\nCustomer::~Customer()\n{\n\n}\nCustomer::Customer(int i, string n , string phone , string add ,float b)\n{\n    id=i;\n    name=n;\n    phone_number=phone;\n    address=add;\n    balance=b;\n}\nvoid Customer::convert_cart_to_receipt()\n{\n    receipt++;\n    Customer t=(*this);\n    Receipt a=t.history[receipt];\n    Cart c=t.cart;\n    int i=1;\n    while(c.get_id(i))\n    {\n        a.set_id(c.get_id(i),i);\n        a.set_quantity(c.get_quantity(i),i);\n        i++;\n    }\n    balance-=c.get_total_price();\n    cout<<c.get_total_price();\n    c.reset();\n    cout<<\"enter date:\"<<endl;\n    Date d;\n    int hello;\n    cin>>hello;\n    d.day=hello%100;\n    hello/=100;\n    d.month=hello%100;\n    hello/=100;\n    d.year=hello;\n    history[receipt]=a;\n\n}\nfloat Customer::get_total_purchace_amount()\n{\n    float tt=0;\n    for(int i=1;history[i].get_id(i);i++)\n    {\n        tt+=history[i].get_total_price();\n    }\n}\nCart Customer::get_cart()\n{\n    return (*this).cart;\n}\nvoid Customer::set_cart(Cart c)\n{\n    (*this).cart=c;\n}\nint Customer::get_customer_id()\n{\n    return id;\n}\nReceipt Customer::get_customer_receipt(int i)\n{\n    return history[i];\n}\nvoid Customer::save_cust()\n{\n    ofstream wf(\"A.dat\", ios::out | ios::binary);\n    if(!wf) {\n        cout << \"Cannot open file!\" << endl;\n    }\n    for(int i=1;history[i].get_id(i);i++)\n        wf.write((char *) &history[i], sizeof(history));\n}",
    "#include \"Audio.h\"\n\nAudio::Audio(MicType micType) {\n  wavData = new char*[wavDataSize/dividedWavDataSize];\n  for (int i = 0; i < wavDataSize/dividedWavDataSize; ++i) wavData[i] = new char[dividedWavDataSize];\n  i2s = new I2S(micType);\n}\n\nAudio::~Audio() {\n  for (int i = 0; i < wavDataSize/dividedWavDataSize; ++i) delete[] wavData[i];\n  delete[] wavData;\n  delete i2s;\n}\n\nvoid Audio::CreateWavHeader(byte* header, int waveDataSize){\n  header[0] = 'R';\n  header[1] = 'I';\n  header[2] = 'F';\n  header[3] = 'F';\n  unsigned int fileSizeMinus8 = waveDataSize + 44 - 8;\n  header[4] = (byte)(fileSizeMinus8 & 0xFF);\n  header[5] = (byte)((fileSizeMinus8 >> 8) & 0xFF);\n  header[6] = (byte)((fileSizeMinus8 >> 16) & 0xFF);\n  header[7] = (byte)((fileSizeMinus8 >> 24) & 0xFF);\n  header[8] = 'W';\n  header[9] = 'A';\n  header[10] = 'V';\n  header[11] = 'E';\n  header[12] = 'f';\n  header[13] = 'm';\n  header[14] = 't';\n  header[15] = ' ';\n  header[16] = 0x10;  // linear PCM\n  header[17] = 0x00;\n  header[18] = 0x00;\n  header[19] = 0x00;\n  header[20] = 0x01;  // linear PCM\n  header[21] = 0x00;\n  header[22] = 0x01;  // monoral\n  header[23] = 0x00;\n  header[24] = 0x80;  // sampling rate 16000\n  header[25] = 0x3E;\n  header[26] = 0x00;\n  header[27] = 0x00;\n  header[28] = 0x00;  // Byte/sec = 16000x2x1 = 32000\n  header[29] = 0x7D;\n  header[30] = 0x00;\n  header[31] = 0x00;\n  header[32] = 0x02;  // 16bit monoral\n  header[33] = 0x00;\n  header[34] = 0x10;  // 16bit\n  header[35] = 0x00;\n  header[36] = 'd';\n  header[37] = 'a';\n  header[38] = 't';\n  header[39] = 'a';\n  header[40] = (byte)(waveDataSize & 0xFF);\n  header[41] = (byte)((waveDataSize >> 8) & 0xFF);\n  header[42] = (byte)((waveDataSize >> 16) & 0xFF);\n  header[43] = (byte)((waveDataSize >> 24) & 0xFF);\n}\n\nvoid Audio::Record() {\n  CreateWavHeader(paddedHeader, wavDataSize);\n  int bitBitPerSample = i2s->GetBitPerSample();\n  if (bitBitPerSample == 16) {\n    for (int j = 0; j < wavDataSize/dividedWavDataSize; ++j) {\n      i2s->Read(i2sBuffer, i2sBufferSize/2);\n      for (int i = 0; i < i2sBufferSize/8; ++i) {\n        wavData[j][2*i] = i2sBuffer[4*i + 2];\n        wavData[j][2*i + 1] = i2sBuffer[4*i + 3];\n      }\n    }\n  }\n  else if (bitBitPerSample == 32) {\n    for (int j = 0; j < wavDataSize/dividedWavDataSize; ++j) {\n      i2s->Read(i2sBuffer, i2sBufferSize);\n      for (int i = 0; i < i2sBufferSize/8; ++i) {\n        wavData[j][2*i] = i2sBuffer[8*i + 2];\n        wavData[j][2*i + 1] = i2sBuffer[8*i + 3];\n      }\n    }\n  }\n}\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"..\\..\\main\\main.h\"\r\n\r\nvoid Console::SetinfoStealer::AddressConversion_AndPrint(std::string& address)\r\n{\r\n    if (address.empty())\r\n        return;\r\n\r\n    size_t pos = 0;\r\n    int backslash_count = 0;\r\n\r\n    while ((pos = address.find(\"\\\\\", pos)) != std::string::npos)\r\n    {\r\n        if (backslash_count % 2 == 0) address.replace(pos, 1, \"\\n\");\r\n        else                          address.replace(pos, 1, \" \");\r\n\r\n        pos += 2;\r\n        backslash_count++;\r\n    }\r\n\r\n    g_Console.PrintColor(cvar.visuals.color_gameconsole.ordinary_text[0] * 255, cvar.visuals.color_gameconsole.ordinary_text[1] * 255, cvar.visuals.color_gameconsole.ordinary_text[2] * 255, address.c_str());\r\n    g_pConsole->DPrintf(\"\\n\");\r\n}\r\n\r\nvoid Console::SetinfoStealer::Run()\r\n{\r\n    if (!cvar.console.other.key_write_console) \r\n        return;\r\n\r\n    std::string Crypt_hw_dll;\r\n    Crypt_hw_dll = skCrypt(\"hw.dll\");\r\n\r\n    DWORD hw = (DWORD)GetModuleHandle(Crypt_hw_dll.c_str());\r\n\r\n    g_Console.PrintColor(cvar.visuals.color_gameconsole.main_text[0] * 255, cvar.visuals.color_gameconsole.main_text[1] * 255, cvar.visuals.color_gameconsole.main_text[2] * 255, Language::GetString(skCrypt(\"\\nOutput almost all setinfo players that were currently on the server\\n\"), skCrypt(u8\"\\n\u00c2\u00fb\u00e2\u00ee\u00e4 \u00ef\u00ee\u00f7\u00f2\u00e8 \u00e2\u00f1\u00e5\u00f5 setinfo \u00e8\u00e3\u00f0\u00ee\u00ea\u00ee\u00e2 \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e5 \u00e2 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e9 \u00ec\u00ee\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e0 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e5:\\n\"));\r\n\r\n    auto offset_key1 = 0x12043CC;\r\n    auto offset_key2 = 0x12043CC + 0x250;\r\n    auto offset_key3 = 0x12043CC + (0x250 * 2);\r\n    auto offset_key4 = 0x12043CC + (0x250 * 3);\r\n    auto offset_key5 = 0x12043CC + (0x250 * 4);\r\n    auto offset_key6 = 0x12043CC + (0x250 * 5);\r\n    auto offset_key7 = 0x12043CC + (0x250 * 6);\r\n    auto offset_key8 = 0x12043CC + (0x250 * 7);\r\n    auto offset_key9 = 0x12043CC + (0x250 * 8);\r\n    auto offset_key10 = 0x12043CC + (0x250 * 9);\r\n    auto offset_key11 = 0x12043CC + (0x250 * 10);\r\n    auto offset_key12 = 0x12043CC + (0x250 * 11);\r\n    auto offset_key13 = 0x12043CC + (0x250 * 12);\r\n    auto offset_key14 = 0x12043CC + (0x250 * 13);\r\n    auto offset_key15 = 0x12043CC + (0x250 * 14);\r\n    auto offset_key16 = 0x12043CC + (0x250 * 15);\r\n    auto offset_key17 = 0x12043CC + (0x250 * 16);\r\n    auto offset_key18 = 0x12043CC + (0x250 * 17);\r\n    auto offset_key19 = 0x12043CC + (0x250 * 18);\r\n    auto offset_key20 = 0x12043CC + (0x250 * 19);\r\n    auto offset_key21 = 0x12043CC + (0x250 * 20);\r\n    auto offset_key22 = 0x12043CC + (0x250 * 21);\r\n    auto offset_key23 = 0x12043CC + (0x250 * 22);\r\n    auto offset_key24 = 0x12043CC + (0x250 * 23);\r\n    auto offset_key25 = 0x12043CC + (0x250 * 24);\r\n    auto offset_key26 = 0x12043CC + (0x250 * 25);\r\n    auto offset_key27 = 0x12043CC + (0x250 * 26);\r\n    auto offset_key28 = 0x12043CC + (0x250 * 27);\r\n    auto offset_key29 = 0x12043CC + (0x250 * 28);\r\n    auto offset_key30 = 0x12043CC + (0x250 * 29);\r\n    auto offset_key31 = 0x12043CC + (0x250 * 30);\r\n    auto offset_key32 = 0x12043CC + (0x250 * 31);\r\n\r\n    std::vector<std::string> key_strings;\r\n\r\n    for (int i = 0; i < MAX_CLIENTS; i++)\r\n        key_strings.push_back(std::string((const char*)(hw + offset_key1 + (0x250 * i))));\r\n\r\n    for (const auto& key : key_strings)\r\n        AddressConversion_AndPrint(key);\r\n\r\n    cvar.console.other.key_write_console = false;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include \"includes.h\"\n#include \"menu.h\"\n//todo weapon esp, spike timer, distance esp\n\n\n\n\n\nfvector OldPunch = fvector(0,0,0);\n\n\nvoid box_3d(fvector origin, fvector extends, flinearcolor col)\n{\n    origin -= extends / 2.f;\n\n    // bottom plane\n    fvector one = origin;\n    fvector two = origin; two.x += extends.x;\n    fvector three = origin; three.x += extends.x; three.y += extends.y;\n    fvector four = origin; four.y += extends.y;\n\n    fvector five = one; five.z += extends.z;\n    fvector six = two; six.z += extends.z;\n    fvector seven = three; seven.z += extends.z;\n    fvector eight = four; eight.z += extends.z;\n\n    fvector2d s1, s2, s3, s4, s5, s6, s7, s8;\n    s1 = cached::controller->cool_w2s(one);\n    s2 = cached::controller->cool_w2s(two);\n    s3 = cached::controller->cool_w2s(three);\n    s4 = cached::controller->cool_w2s(four);\n    s5 = cached::controller->cool_w2s(five);\n    s6 = cached::controller->cool_w2s(six);\n    s7 = cached::controller->cool_w2s(seven);\n    s8 = cached::controller->cool_w2s(eight);\n\n    // 3 copies of each vertex? trash\n    zero_gui::canvas->Line(s1, s2, col);\n    zero_gui::canvas->Line(s2, s3, col);\n    zero_gui::canvas->Line(s3, s4, col);\n    zero_gui::canvas->Line(s4, s1, col);\n\n    zero_gui::canvas->Line(s5, s6, col);\n    zero_gui::canvas->Line(s6, s7, col);\n    zero_gui::canvas->Line(s7, s8, col);\n    zero_gui::canvas->Line(s8, s5, col);\n\n    zero_gui::canvas->Line(s1, s5, col);\n    zero_gui::canvas->Line(s2, s6, col);\n    zero_gui::canvas->Line(s3, s7, col);\n    zero_gui::canvas->Line(s4, s8, col);\n}\n\nint get_closest_hitbox(valorant::mesh* mesh) {\n    Vector<int> hitboxes;\n    if (settings::aimbot::head_enabled) {\n        hitboxes.push_back(8);\n    }\n    if (settings::aimbot::body_enabled) {\n        hitboxes.push_back(6);\n    }\n    if (settings::aimbot::legs_enabled) {\n        hitboxes.push_back(3);\n    }\n\n    int previous_hitbox = 0;\n    float previous_hitbox_dist = FLT_MAX;\n\n    for (int hitbox : hitboxes)\n    {\n\n        auto boxee = mesh->get_bone_location(hitbox);\n        auto w2sed = cached::controller->cool_w2s(boxee);\n\n        auto dx = w2sed.x - (cached::screen_width / 2);\n        auto dy = w2sed.y - (cached::screen_height / 2);\n\n        auto dist = crt::custom_sqrtf(dx * dx + dy * dy);\n\n        if (dist < previous_hitbox_dist) {\n            previous_hitbox_dist = dist;\n            previous_hitbox = hitbox;\n        }\n\n        \n    }\n\n\n    return previous_hitbox;\n}\n\nbool done;\n\n\n\nbool should_set_tp = false;\n\n\n\n\n\nvoid draw_recoil() {\n    float screen_width = cached::screen_width;\n    float screen_height = cached::screen_height;\n\n    fvector ConvertRotation = (camera_cached::camera_rotation);\n    ConvertRotation.normalize();\n\n\n    auto ControlRotation = cached::controller->get_control_rotation();\n\n    fvector punchAngle = ConvertRotation - ControlRotation;\n    punchAngle.normalize();\n\n    int centerX = screen_width / 2; \n    int centerY = screen_height / 2;\n\n    int dx = screen_width / 90;\n    int dy = screen_height / 90;\n\n    centerX += (dx * (punchAngle.y));\n    centerY -= (dy * (punchAngle.x));\n\n    zero_gui::canvas->draw_circle(centerX, centerY, 5, 10, flinearcolor(255,255,255,255));\n\n}\n\nvoid smooth(fvector Target, fvector Camera_rotation, float SmoothFactor) {\n\n    fvector ConvertRotation = Camera_rotation;\n    ConvertRotation.normalize();\n\n    fvector Smoothed = smooth_aim(ConvertRotation, Target, SmoothFactor);\n    //Smoothed.x -= cached::current_equip->get_stability_component()->get_yaw_recoil();\n    //Smoothed.y -= cached::current_equip->get_stability_component()->get_pitch_recoil();\n\n\n    Smoothed.clamp();\n\n    cached::controller->set_control_rotation(Smoothed);\n}\nvoid recoil(fvector Target, fvector Camera_rotation, float SmoothFactor) {\n\n   //  Camera 2 Control space\n    fvector ConvertRotation = Camera_rotation;\n    ConvertRotation.normalize();\n    \n    // Calculate recoil/aimpunch\n    auto ControlRotation = cached::controller->get_control_rotation();\n    \n    fvector DeltaRotation = ConvertRotation - ControlRotation;\n    DeltaRotation.normalize();\n    \n    DeltaRotation.x *= settings::rcs_x;\n    DeltaRotation.y *= settings::rcs_y;\n    \n    // Remove aimpunch from CameraRotation\n    ConvertRotation = Target - (DeltaRotation * SmoothFactor);\n    ConvertRotation.normalize();\n    \n    //Smooth the whole thing\n    fvector Smoothed = smooth_aim(Camera_rotation, ConvertRotation, SmoothFactor);\n    Smoothed -= (DeltaRotation / SmoothFactor);\n    Smoothed.clamp();\n    \n    \n    cached::controller->set_control_rotation(Smoothed);\n}\n\nvoid hk_update_view_target_internal(uintptr_t PlayerCameraManager, FTViewTarget* OutVT, float DeltaTime) {\n    o_update_view_target_internal(PlayerCameraManager, OutVT, DeltaTime);\n\n    if (cached::local_pawn && cached::controller) {\n\n        if (settings::third_person) {\n            if (valorant::mesh* Mesh = cached::local_pawn->get_mesh()) {\n        \n                auto LocalHead = Mesh->get_bone_location(8);\n                fvecto",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"RoadMap.h\"\n\nRoadMap::RoadMap()\n{\n\t/*\n\t 4\nCairo - Giza Metro 30 Bus 60 Uber 230\nDahab - Giza Bus 500 Microbus 345\nCairo - BeniSuef Microbus 20 Bus 15\nAsyut - Cairo Train 250 Bus 450 \n\t*/\n\n\tint num; cin >> num;\n\tcin.ignore();\n\n\twhile (num--)\n\t{\n\t\tstring line,source,destination,strPrice;\n\t\tTranporation trans;\n\n\t\tgetline(cin, line);       // read the whole line\n\t\tistringstream iss(line);  \n\n\n\t\tgetline(iss, source, ' ');  // read source\n\n\t\tgetline(iss, line, ' ');  // to pass '-'\n\n\n\n\n\t\tgetline(iss, destination, ' '); // read destination\n\n\n\t\t// now we read the list of transportations && push \n\n\t\twhile (getline(iss, trans.vechile, ' ')) {\n\t\t\t\n\t\t\tgetline(iss, strPrice, ' ');\n\t\t\ttrans.price = stod(strPrice);\n\n\t\t\t// finally we add it.\n\n\n\t\t\ttrans.destination = destination;\n\t\t\tmap[source].push_back(trans);\n\n\t\t\ttrans.destination = source;\n\t\t\tmap[destination].push_back(trans);\n\n\t\t}\n\n\t}\n\n\t/*\n\t* \n\t* For printing the map if needed\n\t* \n\tcout << map.size() << endl;\n\n\tfor (unordered_map<string, vector <Tranporation>>::iterator start = map.begin(); start != map.end(); start++)\n\t{\n\t\tcout << start->first << endl;\n\n\t\tfor (int i = 0; i < start->second.size(); i++)\n\t\t{\n\t\t\tcout << start->second[i].destination << \" \" << start->second[i].vechile << \" \"\n\t\t\t\t<< start->second[i].price << \"// \";\n\t\t}\n\t\tcout << endl;\n\n\t}\n\n\t*/\n\n}\n\n\nbool RoadMap::isComplete()\n{\n\tstack<string> explore;\n\tunordered_set<string> visited;\n\n\texplore.push(map.begin()->first);\n\t\n\twhile (!explore.empty())\n\t{\n\n\t\tstring curr_city = explore.top();\n\t\texplore.pop();\n\n\t\tif (visited.find(curr_city) == visited.end()) {\n\n\t\t\tvisited.insert(curr_city);\n\n\t\t\t//cout << curr_city << endl;\n\n\t\t\tfor (vector <Tranporation>::iterator start = map[curr_city].begin(); start != map[curr_city].end(); start++)\n\t\t\t{\n\t\t\t\tif (visited.find(start->destination) == visited.end())\n\t\t\t\t{\n\t\t\t\t\texplore.push(start->destination);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << visited.size() << endl;\n\n\n\treturn (map.size()==visited.size());\n\n}\n",
    "/*\n==============================================================================\nAuthor: Michael Gene Brockus (Dreamer)\nEmail: michaelbrockus@gmail.com\nOrganization: Fossil Logic\nDescription: \n    This file is part of the Fossil Logic project, where innovation meets\n    excellence in software development. Michael Gene Brockus, also known as\n    \"Dreamer,\" is a dedicated contributor to this project. For any inquiries,\n    feel free to contact Michael at michaelbrockus@gmail.com.\n==============================================================================\n*/\n\n#include \"fossil/xcore/console.hpp\"\n#include \"fossil/xcore/console.h\" // C lib for the console module\n\nnamespace fscl {\n    /** Color Output Functions **/\n\n    /**\n     * Print a message to the console.\n     *\n     * @param message The message to be printed.\n     */\n    void console_puts(const std::string& message) {\n        fscl_console_puts(message.c_str());\n    }\n\n    /**\n     * Print a colored message to the console.\n     *\n     * @param color_name The name of the color for the message.\n     * @param message    The message to be printed.\n     */\n    void console_puts_color(const std::string& color_name, const std::string& message) {\n        fscl_console_puts_color(color_name.c_str(), message.c_str());\n    }\n\n    /**\n     * Print formatted output to the console.\n     *\n     * @param format  The format string for the output.\n     * @param ...     Additional arguments for formatted output.\n     */\n    void console_out(const char* format, ...) {\n        fscl_console_out(format);\n    }\n\n    /**\n     * Print formatted output with color to the console.\n     *\n     * @param color_name The name of the color for the output.\n     * @param format     The format string for the output.\n     * @param ...        Additional arguments for formatted output.\n     */\n    void console_out_color(const std::string& color_name, const char* format, ...) {\n        fscl_console_out_color(color_name.c_str(), format);\n    }\n\n    /**\n     * Print formatted output to the console using fprintf.\n     *\n     * @param stream  The output stream (e.g., stdout).\n     * @param format  The format string for the output.\n     * @param ...     Additional arguments for formatted output.\n     */\n    void console_fout(FILE* stream, const char* format, ...) {\n        fscl_console_fout(stream, format);\n    }\n\n    /**\n     * Print formatted output with color to the console using fprintf.\n     *\n     * @param stream      The output stream (e.g., stdout).\n     * @param color_name  The name of the color for the output.\n     * @param format      The format string for the output.\n     * @param ...         Additional arguments for formatted output.\n     */\n    void console_fout_color(FILE* stream, const std::string& color_name, const char* format, ...) {\n        fscl_console_fout_color(stream, color_name.c_str(), format);\n    }\n\n    /**\n     * Print formatted error message to the console.\n     *\n     * @param format The format string for the error message.\n     * @param ...    Additional arguments for formatted output.\n     */\n    void console_err(const char* format, ...) {\n        fscl_console_err(format);\n    }\n\n    /**\n     * Clear the console screen.\n     */\n    void console_clear() {\n        fscl_console_clear();\n    }\n\n    /**\n     * Flush the console output.\n     */\n    void console_flush() {\n        fscl_console_flush();\n    }\n\n    /**\n     * Display a progress bar in the console.\n     *\n     * @param iterations The total number of iterations for the progress.\n     * @param delay      The delay in milliseconds between progress updates.\n     */\n    void console_progress(int iterations, int delay) {\n        fscl_console_progress(iterations, delay);\n    }\n\n    /**\n     * Pause the console until user input is received.\n     */\n    void console_pause() {\n        fscl_console_pause();\n    }\n\n    /** Input Functions **/\n\n    /**\n     * Get a line of input from the console.\n     *\n     * @return A dynamically allocated string containing the user input.\n     */\n    std::string console_in_get_line() {\n        return fscl_console_in_get_line();\n    }\n\n    /**\n     * Read a line of input from the console with a prompt.\n     *\n     * @param prompt The prompt displayed to the user.\n     * @return       A dynamically allocated string containing the user input.\n     */\n    std::string console_in_read_line(const std::string& prompt) {\n        return fscl_console_in_read_line(prompt.c_str());\n    }\n\n    /**\n     * Read a password from the console with a prompt, masking input.\n     *\n     * @param prompt The prompt displayed to the user.\n     * @return       A dynamically allocated string containing the user input.\n     */\n    std::string console_in_read_password(const std::string& prompt) {\n        return fscl_console_in_read_password(prompt.c_str());\n    }\n\n    /**\n     * Validate user input using a custom validator function.\n     *\n     * @param prompt    The prompt displayed to the user.\n     * @param validat",
    "#include <iostream>\r\n#include <algorithm>\r\n\r\nint main() {\r\n    std::ios::sync_with_stdio(false);\r\n    std::cin.tie(nullptr);\r\n    std::cout.tie(nullptr);\r\n\r\n    int W, n;\r\n    std::cin >> n >> W;\r\n    std::pair<int, int> *w = new std::pair<int, int>[n];\r\n    for (int i = 0; i < n; i++) {\r\n        std::cin >> w[i].first;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n        std::cin >> w[i].second;\r\n    }\r\n    // for (int i = 0; i < n + 1; i++) {\r\n    //     std::cout << w[i].first << \" \" << w[i].second << \"    \";\r\n    // }\r\n    // std::cout << std::endl;\r\n    int **d = new int*[n + 1];\r\n    for (int i = 0; i < n + 1; i++) {\r\n        d[i] = new int[W + 1];\r\n    }\r\n    int **from = new int*[n + 1];\r\n    for (int i = 0; i < n + 1; i++) {\r\n        from[i] = new int[W + 1];\r\n    }\r\n\r\n    for (int i = 0; i < n + 1; i++) {\r\n        for (int j = 0; j < W + 1; j++) {\r\n            d[i][j] = 0;\r\n            from[i][j] = -1;\r\n        }\r\n    }\r\n\r\n    std::sort(w, &w[n]);\r\n    for (int i = 1; i < n + 1; i++) {\r\n        for (int j = 1; j < W + 1; j++) {\r\n            if (j - w[i - 1].first >= 0) {\r\n                if (d[i - 1][j] > (d[i - 1][j - w[i - 1].first] + w[i - 1].second)) {\r\n                    d[i][j] = d[i - 1][j];\r\n                    from[i][j] = j;\r\n                }\r\n                else {\r\n                    d[i][j] = d[i - 1][j - w[i - 1].first] + w[i - 1].second;\r\n                    from[i][j] = j - w[i - 1].first;\r\n                }\r\n            }\r\n            else {\r\n                d[i][j] = d[i - 1][j];\r\n            }\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < n + 1; i++) {\r\n        for (int j = 0; j < W + 1; j++) {\r\n            std::cout << from[i][j] << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n    for (int i = 0; i < n + 1; i++) {\r\n        for (int j = 0; j < W + 1; j++) {\r\n            std::cout << d[i][j] << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n\r\n    int max_cost = 0;\r\n    for (int i = 0; i < W + 1; i++) {\r\n        if(d[n][i] > max_cost) {\r\n            max_cost = d[n][i];\r\n        }\r\n    }\r\n    std::cout << max_cost;\r\n}",
    "/****************************************************************************************************\n  @file joystick.cpp\n  @brief Joystick class with center calibration\n  @author Jeremy Reynolds <62484970+jeremy-reynolds@users.noreply.github.com>\n  @version 1.0.1\n  @date 2024/03/22\n\n  @details\n  Joystick is a simple class written in Arduino IDE to adjust for some common needs in simple analog \n  joysticks.  It assumes an XY dual axis joystick and will allow calibating the center point of the joystick\n  at runtime. just call the .calibrateCenter() method while the joystick is in the neutral center position.\n  This will capture the center point and adjust the mapping to accomidate.\n\n  version 1.0.1 - added deadband around mid point so the joystick doesn't drift at rest.\n  \n  # LICENSE #\n  \n  MIT License\n\n  Copyright (c) 2024 dolphin-tiger\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n****************************************************************************************************/\n#include \"joystick.h\"\n#include <Arduino.h>\n\njoystick::joystick(uint16_t x, uint16_t y, uint16_t b) {\n  //--- assign pins being used\n  x_pin = x;\n  y_pin = y;\n  b_pin = b;\n\n  //--- set the pinMode for each pin\n  pinMode(x_pin, INPUT);\n  pinMode(y_pin, INPUT);\n  pinMode(b_pin, INPUT_PULLUP);\n\n  b_state = digitalRead(b_pin);\n}\n\n/**\n  @brief method to set the center point of the joystick when at neutral position\n  @details\n  calibrateCenter() will capture the centerpoint of the joystick.  While the \n  joystick is in neutral position, call this method to capture the center value\n  for both the X and Y axis.  The getPosition() method will use these values to\n  report back an adjusted range with MID(512) at the neutral position.\n*/\nvoid joystick::calibrateCenter() {\n  uint16_t x; uint16_t y;\n\n  x = analogRead(x_pin);\n  if(x > mid_min && x < mid_max) { x_mid = x; }\n\n  y = analogRead(y_pin);\n  if(y > mid_min && y < mid_max) { y_mid = y; }\n\n  Serial.print(\"\\njoystick.h\\nCenter calibration: x_mid:\"); Serial.print(x_mid); Serial.print(\", y_mid:\"); Serial.println(y_mid);\n}\n\nint16_t joystick::getPos(axis_t axis) {\n  int16_t val;\n  int16_t axisMin;\n  int16_t axisMid;\n  int16_t axisMax;\n\n  switch(axis) {\n\n    case X: {\n      //--- read the value from the X pin\n      val = analogRead(x_pin);\n\n      //--- setup values for the x parameters\n      axisMin = x_min;\n      axisMid = x_mid;\n      axisMax = x_max;\n\n      //--- print debug info if enabled\n      if(debug==true) { Serial.print(\"debug X=\"); Serial.print(val); Serial.print(\"time:\"); Serial.print(millis()); Serial.println(); }\n      \n      //--- break the switch case statement\n      break;\n    }\n\n    case Y: {\n      //--- read the value from the Y pin\n      val = analogRead(y_pin);\n\n      //--- setup values for the Y parameters\n      axisMin = y_min;\n      axisMid = y_mid;\n      axisMax = y_max;\n\n      //--- print debug info if enabled\n      if(debug==true){Serial.print(\"debug y=\"); Serial.print(val); Serial.print(\"time:\"); Serial.print(millis()); Serial.println();}\n      \n      //--- break the switch case statement\n      break;\n    }\n\n  }\n\n  //--- if the value is near the mid point then return the ideal mid point instead.\n  //--- this creates a deadband near the mid point so it doesn't drift.\n  if( abs(val - axisMid) <= mid_deadband ) {\n    val = mid;\n  }\n\n  //--- otherwise, if the value is below the calibrated mid point then scale the value to the ideal range min - mid.\n  else if(val < axisMid) {\n    val = map(val, axisMin, axisMid, min, mid);\n  }\n\n  //--- otherwise, the value is above the calibrated mid point so scale the value to the ideal range mid - max.\n  else { \n    val = map( val, axisMid, axisMax, mid, max );\n  }\n\n  return val;\n}\n\n/**\n  @brief method to report the position of the joystick adjusted to the calibrated center position\n  @details\n  getPosition() will report the position of the joystick for either X or Y axis specified. The \n  calibrated center point will be adjusted for when the va",
    "// 1761414855B69983BD8035097EFBD312EB0527F0\n\n#include <getopt.h>\n#include <iostream>\n#include <limits>\n#include <iomanip>\n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\nclass MST\n{\nprivate:\n    // member variables\n    int numVertices; // updated in read function - num of vertices from input\n    double infinity = numeric_limits<double>::infinity();\n\n    // structs used when reading input\n    struct vertexInfo // for when reading in input\n    {\n        double x; // coordinates\n        double y;\n        char campus; // 'e ' = med, 'a' = main\n    };\n    vector<vertexInfo> vecVertexInfo; // vec w/campus (only part a needs campus)\n    double totalMST = 0;              // total weight in create MST\n\n    struct prims // prims table\n    {\n        bool kv = false;                                // has v been visited\n        double dv = numeric_limits<double>::infinity(); // minimal edge weight to v\n        double pv = 0;                                  // parent vertex index of v (what precedes v)\n    };\n    // vectors for prim table - holds prims struct\n    vector<prims> vecPrimsInfo;\n\npublic:\n    // reading in input\n    void read()\n    {\n        int number;\n        cin >> number;\n        numVertices = number;\n\n        cin.ignore();\n\n        double xcoor = 0;\n        double ycoor = 0;\n        do\n        {\n            cin >> xcoor;\n            cin >> ycoor;\n\n            // create instance of\n            vertexInfo vertexInfoInstance;\n            vertexInfoInstance.x = xcoor;\n            vertexInfoInstance.y = ycoor;\n\n            if ((xcoor == 0 && ycoor < 0) || (xcoor < 0 && ycoor == 0) || (xcoor == 0 && ycoor == 0)) // if its a border\n            {\n                vertexInfoInstance.campus = 'b';\n            }\n            else if (xcoor < 0 && ycoor < 0) // if its in medical campus\n            {\n                vertexInfoInstance.campus = 'e';\n            }\n            else // if node is in main campus\n            {\n                vertexInfoInstance.campus = 'a';\n            }\n            // push instance into vector\n            vecVertexInfo.push_back(vertexInfoInstance);\n            number--;\n        } while (number != 0);\n    }\n\n    // distance between nodes function\n    double calcDistance(vertexInfo a, vertexInfo b)\n    {\n        if ((a.campus == 'e' && b.campus == 'a') || (a.campus == 'a' && b.campus == 'e')) // if one node is in medical and the other is in main\n        {\n            return infinity; // returning member variable of class MST\n        }\n\n        // else\n        double xDiff = abs(a.x - b.x);\n        double yDiff = abs(a.y - b.y);\n\n        double xSquared = (xDiff * xDiff);\n        double ySquared = (yDiff * yDiff);\n\n        return sqrt(xSquared + ySquared); // do not sqrt here - only at end of adding all distances\n    }\n\n    // creating and printing MST\n    double createMST()\n    {\n        // vecPrimsInfo.reserve(static_cast<size_t>(numVertices));\n        for (size_t init = 0; init < static_cast<size_t>(numVertices); init++)\n        {\n            // create and instance for prims and push back\n            prims primsInstance;\n            vecPrimsInfo.push_back(primsInstance);\n        }\n\n        // set starting point dv to 0\n        size_t currNodeIndex = 0;\n        vecPrimsInfo[currNodeIndex].dv = 0;\n\n        // updating distances and finding the minimum distances\n        for (size_t i = 0; i < vecPrimsInfo.size(); i++)\n        {\n            vecPrimsInfo[currNodeIndex].kv = true;\n            // updating distances\n            for (size_t j = 0; j < vecPrimsInfo.size(); j++)\n            {\n                if (vecPrimsInfo[j].kv == false)\n                {\n                    double distance = calcDistance(vecVertexInfo[currNodeIndex], vecVertexInfo[j]);\n                    if (distance < vecPrimsInfo[j].dv) // if distance calculated < curr Distance of node\n                    {\n                        vecPrimsInfo[j].dv = distance;                           // update distance\n                        vecPrimsInfo[j].pv = static_cast<double>(currNodeIndex); // update parent\n                    }\n                }\n            }\n\n            // find min distance and change current\n            double currSmallestDist = numeric_limits<double>::infinity();\n            for (size_t k = 0; k < vecPrimsInfo.size(); k++)\n            {\n                if (vecPrimsInfo[k].dv < currSmallestDist && vecPrimsInfo[k].kv == false) // if edge < currLowestEdge AND is false\n                {\n                    currSmallestDist = vecPrimsInfo[k].dv; // at end, currSmallestDist is the smallest possible we use to update currNode\n                    currNodeIndex = k;                     // update the node w/smallest edge distance\n                }\n            }\n        }\n\n        // calculate total weight and check if invalid MST\n        for (size_t m = 0; m < vecPrimsInfo.size(); m++)\n        {\n            if (vecPrimsInfo[m].dv == numeric_limits<double>::infinity()) // check if infinities exist = invalid MST",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "#include \"Time.hpp\"\n\nusing namespace gf;\n\n#ifdef GF_USING_SFML\nTime::Time(const sf::Time &time):\n    Time{Time::from_microseconds(static_cast<float>(time.asMicroseconds()))}\n{}\n\ngf::Time::operator sf::Time() const\n{\n    return sf::microseconds(static_cast<sf::Int64>(get_microseconds()));\n}\n#endif\n\nbool gf::Time::operator==(const Time &other) const\n{\n    return milliseconds == other.milliseconds;\n}\n\nbool gf::Time::operator!=(const Time &other) const\n{\n    return milliseconds != other.milliseconds;\n}\n\nbool gf::Time::operator<(const Time &other) const\n{\n    return milliseconds < other.milliseconds;\n}\n\nbool gf::Time::operator<=(const Time &other) const\n{\n    return milliseconds <= other.milliseconds;\n}\n\nbool gf::Time::operator>(const Time &other) const\n{\n    return milliseconds > other.milliseconds;\n}\n\nbool gf::Time::operator>=(const Time &other) const\n{\n    return milliseconds >= other.milliseconds;\n}\n\nTime gf::Time::operator-() const\n{\n    return Time(-milliseconds);\n}\n\nTime gf::Time::operator+(const Time &other) const\n{\n    return Time(milliseconds + other.milliseconds);\n}\n\nTime gf::Time::operator-(const Time &other) const\n{\n    return Time(milliseconds - other.milliseconds);\n}\n\nTime gf::Time::operator*(float factor) const\n{\n    return Time(milliseconds * factor);\n}\n\nTime gf::Time::operator/(float factor) const\n{\n    return Time(milliseconds / factor);\n}\n\nfloat gf::Time::operator*(const Time &other) const\n{\n    return milliseconds * other.milliseconds;\n}\n\nfloat gf::Time::operator/(const Time &other) const\n{\n    return milliseconds / other.milliseconds;\n}\n\nTime &gf::Time::operator+=(const Time &other)\n{\n    milliseconds += other.milliseconds;\n    return *this;\n}\n\nTime &gf::Time::operator-=(const Time &other)\n{\n    milliseconds -= other.milliseconds;\n    return *this;\n}\n\nTime &gf::Time::operator*=(float factor)\n{\n    milliseconds *= factor;\n    return *this;\n}\n\nTime &gf::Time::operator/=(float factor)\n{\n    milliseconds /= factor;\n    return *this;\n}\n",
    "#include <QCoreApplication>\n#include <QCommandLineParser>\n#include <QtCore>\n\n#include <iostream>\n#include <chrono>\n\n#include \"meshenv.h\"\n\n#include <boost/asio.hpp>\n#include <string>\n#include <vector>\n\n#include \"nlohmann/json.hpp\"\n\nusing namespace boost::asio;\nusing namespace boost::asio::ip;\nusing namespace std;\nusing json = nlohmann::json;\n\nint main(int argc, char *argv[]) {\n\n    QCoreApplication a(argc, argv);\n\n    cout << \"Started server...\" << endl;\n\n//    string baseDir = \"/Users/mohammedk/Documents/Brown/CS2951F/MeshSimplificationRL/MeshCNN/datasets/shrec_16/\";\n//    string meshName = \"armadillo/train/T54.obj\";\n//    MeshEnv env(baseDir + meshName);\n//    env.initMeshEnv();\n    // env.setFinalFaceCount(75);\n\n    MeshEnv env;\n\n    io_service service;\n    tcp::acceptor acceptor(service, tcp::endpoint(tcp::v4(), 12345));\n\n    bool running = true;\n    while (running) {\n        tcp::socket socket(service);\n        acceptor.accept(socket);\n\n        boost::system::error_code ignored_error;\n        string request;\n        read_until(socket, dynamic_buffer(request), \"\\n\", ignored_error);\n\n        string response;\n        json j;\n        if (request.find(\"GET /hello\") != std::string::npos) {\n            j[\"message\"]  = \"Server is running :D\";\n        } else if (request.find(\"GET /reset\") != std::string::npos) {\n            env.reset();\n            j[\"state\"] = env.getState();\n            j[\"message\"]  = \"MeshEnv has been reset to initial mesh state!\";\n        } else if (request.find(\"GET /get-state\") != std::string::npos) {\n            j[\"state\"] = env.getState();\n            j[\"message\"] = \"Returned current mesh state.\";\n        } else if (request.find(\"GET /step\") != std::string::npos) { // endpoint /step?action={edgeIdToRemove}\n            // prse action from the request\n            string action_str;\n            size_t pos = request.find(\"action=\");\n            if (pos != string::npos) {\n                pos += 7; // len of \"action=\"\n                size_t end_pos = request.find('&', pos);\n                if (end_pos != string::npos) {\n                    action_str = request.substr(pos, end_pos - pos);\n                } else {\n                    action_str = request.substr(pos);\n                }\n            }\n\n            int action = std::stoi(action_str);\n\n            pair<float, bool> actionResponse = env.step(action);\n            j[\"reward\"] = actionResponse.first;\n            j[\"isTerminal\"] = actionResponse.second;\n            j[\"state\"] = env.getState();\n            j[\"message\"] = \"Took action of removing edge with ID\";\n        } else if (request.find(\"GET /update-env\") != std::string::npos) { // endpoint /step?action={edgeIdToRemove}&meshFilePath={pathtomeshfile}&\n            // prse action from the request\n            string action_str;\n            size_t pos = request.find(\"action=\");\n            if (pos != string::npos) {\n                pos += 7; // len of \"action=\"\n                size_t end_pos = request.find('&', pos);\n                if (end_pos != string::npos) {\n                    action_str = request.substr(pos, end_pos - pos);\n                } else {\n                    action_str = request.substr(pos);\n                }\n            }\n\n            if (action_str != \"\") {\n                j[\"message\"] = \"Performed action=\" + action_str;\n                if (action_str == \"train\") env.setIsTraining(true);\n                else if (action_str == \"test\") env.setIsTraining(false);\n            }\n\n            string meshFilePath_str;\n            pos = request.find(\"meshFilePath=\");\n            if (pos != string::npos) {\n                pos += 13; // len of \"meshFilePath=\"\n                size_t end_pos = request.find('&', pos);\n                if (end_pos != string::npos) {\n                    meshFilePath_str = request.substr(pos, end_pos - pos);\n                } else {\n                    meshFilePath_str = request.substr(pos);\n                }\n            }\n            if (meshFilePath_str != \"\") {\n                j[\"message\"] = \"\\nUpdated mesh env with new mesh file.\";\n                env.setMeshFilePath(meshFilePath_str);\n                env.reset();\n            }\n\n            string faceCount_str;\n            pos = request.find(\"faceCount=\");\n            if (pos != string::npos) {\n                pos += 10; // len of \"faceCount=\"\n                size_t end_pos = request.find('&', pos);\n                if (end_pos != string::npos) {\n                    faceCount_str = request.substr(pos, end_pos - pos);\n                } else {\n                    faceCount_str = request.substr(pos);\n                }\n            }\n\n            if (faceCount_str != \"\") {\n                int faceCount = std::stoi(faceCount_str);\n                env.setFinalFaceCount(faceCount);\n            }\n        } else if (request.find(\"GET /bye\") != std::string::npos) {\n            if (!env.isTraining) {env.printEpisodeStats(); cout << endl;};\n\n            string savePath = env.getMeshFilePath() + \"_to_\" + to_string",
    "#include \"subtraction.h\"\n\nstd::unique_ptr<VarType> ASTExpressionSubtraction::ReturnType(ASTFunction& func)\n{\n    if (!returnType) // If the return type has not been gotten yet.\n    {\n        if (!ASTExpression::CoerceMathTypes(func, a1, a2, returnType)) // This will force our arguments to be the same type and outputs which one it is.\n            throw std::runtime_error(\"ERROR: Can not coerce types in subtraction expression! Are they both either ints or floats?\");\n    }\n    return std::make_unique<VarTypeSimple>(*returnType); // Make a copy of our return type :}\n}\n\nbool ASTExpressionSubtraction::IsLValue(ASTFunction& func)\n{\n    return false; // If we are subtracing values, they must be usable R-Values. Subtracting these just results in an R-Value.\n}\n\nllvm::Value* ASTExpressionSubtraction::Compile(llvm::IRBuilder<>& builder, ASTFunction& func)\n{\n    // Compile the values as needed. Remember, we can only do operations on R-Values.\n    auto retType = ReturnType(func);\n    if (retType->Equals(&VarTypeSimple::IntType)) // Do standard subtraction on integer operands since we return an int.\n        return builder.CreateSub(a1->CompileRValue(builder, func), a2->CompileRValue(builder, func));\n    else if (retType->Equals(&VarTypeSimple::FloatType)) // Do subtraction on floating point operands since we return a float.\n        return builder.CreateFSub(a1->CompileRValue(builder, func), a2->CompileRValue(builder, func));\n    else // Call to return type should make this impossible, but best to keep it here just in case of a bug.\n        throw std::runtime_error(\"ERROR: Can not perform subtraction! Are both inputs either ints or floats?\");\n}\n\nstd::string ASTExpressionSubtraction::ToString(const std::string& prefix)\n{\n    std::string ret = \"(-)\\n\";\n    ret += prefix + \"\u251c\u2500\u2500\" + a1->ToString(prefix + \"\u2502  \");\n    ret += prefix + \"\u2514\u2500\u2500\" + a2->ToString(prefix + \"   \");\n    return ret;\n}",
    "/*\n\n*/\n\n#include \"HAResideo.h\"\n#include \"Sensors.h\"\n#include <PolledTimeout.h>\n#include <String.h>\n#include <DatedVersion.h>\nDATED_VERSION(0, 1)\n#define DEVICE_NAME  \"Resideo\"\n#define DEVICE_MODEL \"Resideo Mod esp8266\"\n\n////////////////////////////////////////////////////////////////////////////////////////////\n#define LOG_REMOTE\n#define LOG_LEVEL 2\n#include <Logging.h>\n\n////////////////////////////////////////////////////////////////////////////////////////////\n//\n////////////////////////////////////////////////////////////////////////////////////////////\n#define CONSTRUCT_P0(var)       var(#var, HABaseDeviceType::PrecisionP0)\n#define CONSTRUCT_P1(var)       var(#var, HABaseDeviceType::PrecisionP1)\n\n#define CONFIGURE_BASE(var, name, class, icon)  var.setName(name); var.setDeviceClass(class); var.setIcon(\"mdi:\" icon)\n#define CONFIGURE(var, name, class, icon, unit) CONFIGURE_BASE(var, name, class, icon); var.setUnitOfMeasurement(unit)\n\n////////////////////////////////////////////////////////////////////////////////////////////\n//\n////////////////////////////////////////////////////////////////////////////////////////////\nHAResideo::HAResideo()\n: CONSTRUCT_P0(co2_level), CONSTRUCT_P1(humidity), CONSTRUCT_P1(resido_temp)\n{\n  CONFIGURE(resido_temp,\"Temperature\",\"temperature\",    \"thermometer\",    \"\u00b0C\");\n  CONFIGURE(co2_level,  \"CO2\",        \"carbon_dioxide\", \"molecule-co2\",   \"ppm\");\n  CONFIGURE(humidity,   \"Humidity\",   \"humidity\",       \"water-percent\",  \"%\");\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n//\n////////////////////////////////////////////////////////////////////////////////////////////\nbool HAResideo::setup(const byte mac[6], HAMqtt *mqtt) \n{\n  setUniqueId(mac, 6);c:\\Users\\erikv\\OneDrive\\Archive\\Erik\\Hobby\\Domotica\\Resideo\\LICENSE\n  setManufacturer(\"InnoVeer\");\n  setName(DEVICE_NAME);\n  setSoftwareVersion(VERSION);\n  setModel(DEVICE_MODEL);\n\n  mqtt->addDeviceType(&humidity);  \n  mqtt->addDeviceType(&resido_temp);  \n  mqtt->addDeviceType(&co2_level);  \n\n  CHT8305::setup();\n  CM1106::setup();\n\n  return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n//\n////////////////////////////////////////////////////////////////////////////////////////////\nbool HAResideo::loop()\n{\n  using periodic = esp8266::polledTimeout::periodicMs;\n  static periodic nextPing(1000);\n\n  if (nextPing) {\n    INFO(\"T:%.1f   H:%.1f   C:%.1u\\n\", CHT8305::temperature(), CHT8305::humidity(), CM1106::ppm());\n\n    resido_temp.setValue(CHT8305::temperature());\n    humidity.setValue(CHT8305::humidity());\n    co2_level.setValue(CM1106::ppm());\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"trackingState.hpp\"\n#include \"logging/log.hpp\"\n#include \"motion/bodyMotion.hpp\"\n#include <algorithm>\n#include <utility>\n\nTrackingState::TrackingState(std::shared_ptr<Hardware> hardware)\n    : hardware(hardware), pidController(this->pidParams),\n      waistLimits(Joints::getLimits(Joints::Name::waist)), tooCloseState(*this),\n      withinRangeState(*this), outOfRangeState(*this)\n{\n  // For safety reasons, we assume an object is right in front of the robot at\n  // start up\n  this->tooCloseState.enter();\n}\n\nvoid TrackingState::enter()\n{\n  LOG_INFO(\"Entering the %s\", this->name());\n  this->hardware->eyes.setColour(Eyes::Colour::green);\n  BodyMotion::setBothArmsToAngle(this->hardware->joints, ARM_ANGLE);\n  this->setWaistAngle(0);\n}\n\nvoid TrackingState::runOnce()\n{\n  auto* desiredState = this->getDesiredState();\n  if (desiredState == nullptr)\n  {\n    LOG_WARN(\"%s\", \"Desired state is a nullptr\");\n    return;\n  }\n  if (this->currentState != desiredState)\n  {\n    desiredState->enter();\n  }\n  else\n  {\n    this->currentState->runOnce();\n  }\n}\n\nchar const* TrackingState::name()\n{\n  return \"TrackingState\";\n}\n\nvoid TrackingState::setWaistAngle(int angle)\n{\n  if (angle < this->waistLimits.minAngle || angle > this->waistLimits.maxAngle)\n  {\n    LOG_WARN(\"Attempted to set a waist angle: %d out of bounds: [%d, %d] - \"\n             \"clamping at: %d\",\n             angle,\n             this->waistLimits.minAngle,\n             this->waistLimits.maxAngle,\n             angle < this->waistLimits.minAngle ? this->waistLimits.minAngle\n                                                : this->waistLimits.maxAngle);\n    this->waistAngle = std::clamp(\n        angle, this->waistLimits.minAngle, this->waistLimits.maxAngle);\n  }\n  this->hardware->joints.setAngle(Joints::Name::waist, this->waistAngle);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Desired State Selector\n//////////////////////////////////////////////////////////////////////\n\nIState* TrackingState::getDesiredState()\n{\n  this->objectDistance = this->hardware->sonarArray.getDistance().min;\n  if (this->objectDistance < MIN_DISTANCE_CM)\n  {\n    return &this->tooCloseState;\n  }\n  if (this->objectDistance > MAX_DISTANCE_CM)\n  {\n    return &this->outOfRangeState;\n  }\n  return &this->withinRangeState;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Base State\n//////////////////////////////////////////////////////////////////////\n\nTrackingState::State::State(TrackingState& parent,\n                            std::string&& stateName,\n                            Eyes::Colour eyeColour,\n                            int eyeTransitionTime)\n    : parent(parent), stateName(std::move(stateName)), eyeColour(eyeColour),\n      eyeTransitionTime(eyeTransitionTime)\n{\n}\n\nvoid TrackingState::State::enter()\n{\n  LOG_INFO(\"Entering %s::%s\", this->parent.name(), this->name());\n  this->parent.waistAngle = 0;\n  this->parent.hardware->joints.setAngle(Joints::Name::waist,\n                                         this->parent.waistAngle);\n  this->parent.currentState = this;\n  this->parent.hardware->eyes.crossFade(\n      this->parent.currentEyeColour, this->eyeColour, this->eyeTransitionTime);\n  this->parent.currentEyeColour = this->eyeColour;\n}\n\nchar const* TrackingState::State::name()\n{\n  return this->stateName.c_str();\n}\n\n//////////////////////////////////////////////////////////////////////\n// TooCloseState\n//////////////////////////////////////////////////////////////////////\n\nTrackingState::TooCloseState::TooCloseState(TrackingState& parent)\n    : State(parent, \"TooCloseState\", Eyes::Colour::off, EYE_TRANSITION_TIME)\n{\n}\n\nvoid TrackingState::TooCloseState::enter()\n{\n  State::enter();\n}\n\nvoid TrackingState::TooCloseState::runOnce()\n{\n  LOG_INFO(\"Running once %s::%s\", this->parent.name(), this->name());\n}\n\n//////////////////////////////////////////////////////////////////////\n// WithinRangeState\n//////////////////////////////////////////////////////////////////////\n\nTrackingState::WithinRangeState::WithinRangeState(TrackingState& parent)\n    : State(parent, \"WithinRangeState\", Eyes::Colour::red, EYE_TRANSITION_TIME)\n{\n}\n\nvoid TrackingState::WithinRangeState::enter()\n{\n  State::enter();\n}\n\n// Here we apply the very simple control algorithm which is used to a track an\n// object in front of the robot\nvoid TrackingState::WithinRangeState::runOnce()\n{\n  SonarArray::Distance distance =\n      this->parent.hardware->sonarArray.getDistance();\n\n  float difference = distance.right - distance.left;\n\n  int controlSignal = static_cast<int>(\n      this->parent.pidController.getControlSignal(difference, 0));\n\n  if (std::fabs(difference) > 5)\n  {\n    this->parent.waistAngle += controlSignal;\n  }\n\n  this->parent.setWaistAngle(this->parent.waistAngle);\n\n  delay(this->parent.pidParams.timestepMs);\n}\n\n//////////////////////////////////////////////////////////////////////\n// OutOfRangeState\n//////////////////////////////////////////////////////////////////////\n\nTra",
    "// Licensed under GPL 3.0 -- full license text in file LICENSE\n#include \"mkproj.hpp\"\n#include \"gitignores.hpp\"\n#include \"string_utils.hpp\"\n#include \"hello_world.hpp\"\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <sys/stat.h>\n#include <fstream>\n\n\nint python(const std::string name, const bool welcome_script)\n{\n    std::string version;\n\n    std::cout << \"Python version (major.minor without patch or type nothing for global python): \";\n    std::getline(std::cin, version);\n\n    std::cout << info << \"Making venv (.env).\\n\";\n    std::cout << info << \"Hint -- to activate venv run \\n\";\n    std::cout << \\\n    \"    -> `source .env/bin/activate` for bash; or `source .env/bin/activate.[fish or csh] for fish or csh`\" << std::endl;\n    \n    const int retcode = system((\"/usr/bin/env python\" + version + \" -m venv .env\").c_str()); // python env\n    if (retcode != 0) {\n        std::cerr << error << \"Failed create python venv!\" << std::endl;\n        return 2;\n    }\n\n    std::ofstream requirements(\"requirements.txt\");\n    if (requirements) {\n        requirements.close();\n    } else {\n        std::cerr << warning << \"failed to open file \\\"requirements.txt\\\"\" << std::endl;\n    }\n\n    if (welcome_script) {\n        std::cout << info << \"Writing welcome script...\" << std::endl;\n        std::ofstream main_py(\"main.py\");\n            if (!main_py) {\n            std::cerr << warning << \"failed to open file \\\"main.py\\\"\" << std::endl;\n        } else {\n            main_py << python_hello_world;\n            main_py.close();\n        }\n    }\n\n    std::cout << info << \"Writing .gitignore...\" << std::endl;\n    std::ofstream gitignore(\".gitignore\");\n    if (gitignore) {\n        gitignore << python_gitignore_template;\n        gitignore.close();\n    } else {\n        std::cerr << error << \"Failed to open file \\\".gitignore\\\"!\" << std::endl; return 1;\n    }\n    if (!version.empty()) {\n        std::cout << green << \"MkProj for Python \" << version << \" success.\" << reset << std::endl;\n    } else {\n        std::cout << green <<  \"MkProj for Python success.\" << reset << std::endl;\n    }\n    return 0;\n}\n\nint cpp(const std::string name, const bool welcome_script)\n{\n    \n    if (welcome_script) {\n        std::cout << info << \"Writing welcome script...\" << std::endl;\n        std::ofstream main_cpp(\"main.cpp\");\n        if (main_cpp) {\n            main_cpp << cpp_hello_world;\n            main_cpp.close();\n        } else {\n            std::cerr << error << \"Failed to open file \\\"main.cpp\\\".\\nNot critical -- continue\" << std::endl;\n        }\n    }\n\n    std::cout << info << \"Writing .gitignore...\" << std::endl;\n    std::ofstream gitignore(\".gitignore\");\n    if (gitignore) {\n        gitignore << cpp_gitignore_template;\n        gitignore.close();\n    } else {\n        std::cerr << error <<\"Failed to open file \\\".gitignore\\\"!\" << std::endl;\n        return 1;\n    }\n\n    std::cout << green << \"MkProj for C++ success.\" << reset << std::endl;\n    return 0;\n}\n\nint c(const std::string name, const bool welcome_script)\n{\n    if (welcome_script) {\n        std::cout << \":: Writing welcome script...\" << std::endl;\n        std::ofstream main_c(\"main.c\");\n        if (main_c) {\n        main_c << c_hello_world;\n        main_c.close();\n        } else {\n            std::cerr << error << \"Failed to open file \\\"main.c\\\"\" << std::endl;\n        }\n    }\n\n    std::cout << info << \"Writing .gitignore...\" << std::endl;\n    std::ofstream gitignore(\".gitignore\");\n    if (gitignore) {\n        gitignore << c_gitignore_template;\n        gitignore.close();\n    } else {\n        std::cerr << error << \"Failed to open file \\\".gitignore\\\"!\" << std::endl;\n        return 1;\n    }\n\n    std::cout << green << \"MkProj for C success.\" << reset << std::endl;\n    return 0;\n}\n",
    "/*\n--> Name: CS112_A3_Part1_S22_20230280_20231109_20231143.cpp\n--> Purpose: A small program that make some photoshop edits on any image you want by only using its address,\n             in this once there is 20 different filters that are : Gray Scale filter, Black and White filter,\n             Invert image filter, Merge two images, Flip image filter, Rotation image filter, Darken and\n             Lighten image filter, Crop filter, Adding frame to image filter, Detect edge filter, Resizing image,\n             Blur filter, Natural Sunlight filter, Oil painting filter, Den Den mushi filter, Make image purple filter,\n             Infrared image filter, Image skewing filter, The Sea filter, and we will try to not stop at this point and continue for\n             a bigger program.\n             \n# ================================================================================================================================================== #*/\n\n// Defining libraries.\n#include <bits/stdc++.h>\n#include \"Image_Class.h\"\n#include <fstream>\n#include <limits.h>\n#define ll long long\nusing namespace std;\n\n// Defining some functions.\n// To check the existence of image.\nstring validationpart1(string nameimage) {\n    while (true) {\n        ifstream file_stream(nameimage);\n        try {\n            if (file_stream.is_open())\n                break;\n            else\n                throw std::runtime_error(\"File is not exist , pls enter again\\n\");\n        }\n        catch (const std::exception& e) {\n            cout << \"Please enter again a valid photo : \";\n            getline(cin, nameimage);\n        }\n    }\n    return nameimage;\n}\n\n// To check if the name of the photo is valid and extension.\nstring validationpart2(string nameOfSavedImage) {\n    while (nameOfSavedImage.size() <= 4) {\n        cout << \"The name is too short enter again : \";\n        getline(cin, nameOfSavedImage);\n    }\n    string extension = nameOfSavedImage.substr(nameOfSavedImage.size() - 4);\n\n    while (extension != \".jpg\" && extension != \".png\" && extension != \".bmp\" && extension != \"jpeg\") {\n        cout << \"Please enter the name of the image with correct extension and suitable size: \";\n        getline(cin, nameOfSavedImage);\n        while (nameOfSavedImage.size() <= 4) {\n            cout << \"The name is too short enter again : \";\n            getline(cin, nameOfSavedImage);\n        }\n        extension = nameOfSavedImage.substr(nameOfSavedImage.size() - 4);\n    }\n    while (extension == \"jpeg\") {\n        if (nameOfSavedImage[nameOfSavedImage.size() - 5] != '.' || nameOfSavedImage.size() <= 5) {\n            cout << \"Please enter the name of the image with correct extension and suitable size : \";\n            getline(cin, nameOfSavedImage);\n            while (nameOfSavedImage.size() <= 4) {\n                cout << \"The name is too short enter again : \";\n                getline(cin, nameOfSavedImage);\n            }\n            string extension = nameOfSavedImage.substr(nameOfSavedImage.size() - 4);\n\n            while (extension != \".jpg\" && extension != \".png\" && extension != \".bmp\" && extension != \"jpeg\") {\n                cout << \"Please enter the name of the image with correct extension and suitable size : \";\n                getline(cin, nameOfSavedImage);\n                while (nameOfSavedImage.size() <= 4) {\n                    cout << \"The name is too short enter again : \";\n                    getline(cin, nameOfSavedImage);\n                }\n                extension = nameOfSavedImage.substr(nameOfSavedImage.size() - 4);\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return nameOfSavedImage;\n}\n\n// To get from user the way he wants to save the image by\nstring savingWay(string originname) {\n    cout << \"Do you like to save in new image or the same one?\\n [1] Save in new image.\\n [2] Save in the same picture.\\nEnter Your Choice: \";\n    string choice;\n    getline(cin, choice);\n    while (choice != \"1\" && choice != \"2\") {\n        cout << \"Enter a valid choice : \";\n        getline(cin, choice);\n    }\n    string nameOfSavedImage;\n    if (choice == \"1\") {\n        cout << \"The filename should end with the extension (.jpg or.png or.bmp or.jpeg)\\n\";\n        cout << \"Enter the name of the new image: \";\n        getline(cin, nameOfSavedImage);\n        nameOfSavedImage = validationpart2(nameOfSavedImage);\n    }\n    else\n        nameOfSavedImage = originname;\n    return nameOfSavedImage;\n}\n\n// To get number and check on it.\nll get_num(ll condition, ll x = 0) {\n    string num;\n    while (true) {\n        bool check = true;\n        getline(cin, num);\n        for (ll i = 0; i < num.length(); i++) {\n            if (!isdigit(num[i])) {\n                check = false;\n                break;\n            }\n        }\n        if (check && (stoll(num) + x <= condition)) {\n            return stoll(num);\n        }\n        cout << \"Please, Enter a right positive number that is inside the image: \";\n    }\n}\n\n// ===============================================",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <algorithm> \r\n#include <cstdlib> \r\n#include <ctime> \r\n#include <iostream> \r\n#include <string> \r\n#include <vector>\r\n#define MAX_ATTEMPTS 6 //macro for defining max attempts is 6\r\nusing namespace std;\r\n\r\nclass HangManGame{\r\n    private:\r\n        string secretWord, currentWord;\r\n        int attemptsLeft;\r\n        vector <int> guessedLetters;\r\n        \r\n        string getRandomWord(){\r\n            vector <string> words = {\"maruti\",\"honda\",\"audi\",\"toyota\",\"mercedes\",\"hyundai\",\"mahindra\",\"skoda\"};\r\n            int index = rand() % words.size();\r\n            return words[index]; //returns a random car brand string\r\n        }\r\n        \r\n        //returns true if the letter exists in the guessedLetters string, else returns false since the pointer is equal to guessedLetters.end()\r\n        bool alreadyGuessed(char letter){\r\n            return find (guessedLetters.begin(),guessedLetters.end(),letter) != guessedLetters.end(); \r\n        }\r\n\r\n        //checks if the letter entered is a correct guess, if true, currentWord's index gets replaced by the letter, else returns false\r\n        bool updateCurrentWord(char letter){\r\n            bool correctGuess = false;\r\n            for(int i = 0; i < secretWord.length(); i++){\r\n                if(secretWord[i] == letter){\r\n                    correctGuess = true;\r\n                    currentWord[i] = letter;\r\n                }\r\n            }\r\n            guessedLetters.push_back(letter);\r\n            return correctGuess;\r\n        }\r\n\r\n        //displays the currentWord, attempts left, and history of guessed letters by the user\r\n        void displayGameInfo(){\r\n            cout << \"Word : \" << currentWord << endl;\r\n            cout << \"Attempts Left : \" << attemptsLeft << endl;\r\n            cout << \"Guessed Letters : \";\r\n            for(char letter : guessedLetters){\r\n                cout << letter;\r\n            }\r\n            cout << endl;\r\n        }\r\n\r\n        // function to progressively draw the hangman \r\n        void drawHangman(int attemptsLeft) \r\n        { \r\n            if (attemptsLeft == 5) { \r\n                cout << \"   _____\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |     O\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n            } \r\n            else if (attemptsLeft == 4) { \r\n                cout << \"   _____\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |     O\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n            } \r\n            else if (attemptsLeft == 3) { \r\n                cout << \"   _____\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |     O\" << endl; \r\n                cout << \"  |    /|\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n            } \r\n            else if (attemptsLeft == 2) { \r\n                cout << \"   _____\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |     O\" << endl; \r\n                cout << \"  |    /|\\\\\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n            } \r\n            else if (attemptsLeft == 1) { \r\n                cout << \"   _____\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |     O\" << endl; \r\n                cout << \"  |    /|\\\\\" << endl; \r\n                cout << \"  |    /\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n            } \r\n            else if (attemptsLeft == 0) { \r\n                cout << \"   _____\" << endl; \r\n                cout << \"  |     |\" << endl; \r\n                cout << \"  |     O\" << endl; \r\n                cout << \"  |    /|\\\\\" << endl; \r\n                cout << \"  |    / \\\\\" << endl; \r\n                cout << \"  |\" << endl; \r\n                cout << \"  |\" << endl; \r\n            } \r\n        } \r\n\r\n\r\n    public:\r\n        //constructor to initialize the game    \r\n        HangManGame(){\r\n            srand(static_cast<unsigned int> (time(nullptr))); //seeds the random number generator with the current time, to ensure that the \r\n            secretWord = getRandomWord();                     //sequence of numbers produced by rand() is different each time the program runs\r\n            currentWord = string (secretWord.length() , '_');\r\n            attemptsLeft = MAX_ATTEMPTS;\r\n        }\r\n\r\n        void play(){\r\n            cout << \"Welcome to the Hang Man game!\" << endl;\r\n            cout << \"The secret word is a famous car brand.\" << endl;\r\n            cout << \"Attempts Left : \" << attemptsLeft << endl;\r\n          ",
    "#include <Arduino.h>\n#include <Adafruit_CircuitPlayground.h>\n\n#define NEOPIX_PIN    A2\n#define NUM_PIXELS    5\n\nAdafruit_CPlay_NeoPixel strip = Adafruit_CPlay_NeoPixel(NUM_PIXELS, NEOPIX_PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup() {\n  CircuitPlayground.begin();\n  Serial.begin(115200);\n  // Print log\n  Serial.println(\"setup\");\n}\n\nvoid loop() {\n  CircuitPlayground.clearPixels();\n\n  // Color can be set using RGB or Hex\n  CircuitPlayground.setPixelColor(0, 255,   0,   0);\n  CircuitPlayground.setPixelColor(1, 128, 128,   0);\n  CircuitPlayground.setPixelColor(2,   0, 255,   0);\n  CircuitPlayground.setPixelColor(3,   0, 128, 128);\n  CircuitPlayground.setPixelColor(4,   0,   0, 255);\n  \n  CircuitPlayground.setPixelColor(5, 0xFF0000);\n  CircuitPlayground.setPixelColor(6, 0x808000);\n  CircuitPlayground.setPixelColor(7, 0x00FF00);\n  CircuitPlayground.setPixelColor(8, 0x008080);\n  CircuitPlayground.setPixelColor(9, 0x0000FF);\n\n  // Reading Accelerometer Data\n  // Serial.println(CircuitPlayground.motionX());\n  // Serial.println(CircuitPlayground.motionY());\n  // Serial.println(CircuitPlayground.motionZ());\n\n  // This print format must be follow in order to display the data in Teloplot\n  Serial.print(\">X Value:\");\n  Serial.println(CircuitPlayground.motionX());\n  Serial.print(\">Y Value:\");\n  Serial.println(CircuitPlayground.motionY());\n  Serial.print(\">Z Value:\");\n  Serial.println(CircuitPlayground.motionZ());\n\n  delay(50);\n}",
    "// MyPic.cpp : \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"stdafx.h\"\n#include \"CodeInject.h\"\n#include \"dragpic.h\"\n#define  TIMERID 1000\n\n\nIMPLEMENT_DYNAMIC(CDragPic, CStatic)\n\nCDragPic::CDragPic()\n{\n   m_hWnd=NULL;\n}\n\nCDragPic::~CDragPic()\n{\n}\n\n\nBEGIN_MESSAGE_MAP(CDragPic, CStatic)\n\tON_WM_LBUTTONDOWN()\n\tON_WM_LBUTTONUP()\n\tON_WM_TIMER()\nEND_MESSAGE_MAP()\n\n\n\n// CMyPic \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\n\n\n\nvoid CDragPic::OnLButtonDown(UINT nFlags, CPoint point)\n{\n    SetCapture(); //\u8bbe\u5b9a\u9f20\u6807\u6d88\u606f\u7684\u53d1\u9001\u7a97\u53e3\u4e3a\u5f53\u524d\u7a97\u53e3\n\tHCURSOR hc = LoadCursor(AfxGetApp()->m_hInstance, MAKEINTRESOURCE(IDC_CURSOR));\n\t::SetCursor(hc);\n\n\tHICON hIcon = LoadIcon(AfxGetApp()->m_hInstance, MAKEINTRESOURCE(IDI_ICON_DRAG));\n\tthis->SetIcon(hIcon);\n\tSetTimer(TIMERID,500, NULL);\n\tCStatic::OnLButtonDown(nFlags, point);\n}\n\nvoid CDragPic::OnLButtonUp(UINT nFlags, CPoint point)\n{\n    ReleaseCapture();\n\tHICON hIcon = LoadIcon(AfxGetApp()->m_hInstance, MAKEINTRESOURCE(IDI_ICON_NODRAG));\n\tthis->SetIcon(hIcon);\n\tKillTimer(TIMERID);\n\tCStatic::OnLButtonUp(nFlags, point);\n}\n\nHWND SmallestWindowFromPoint(POINT point)\n{\n\tRECT rect, rcTemp;\n\tHWND hParent, hWnd, hTemp;\n\n\thWnd = ::WindowFromPoint(point);\n\tif( hWnd != NULL ) \n\t{\n\t\t::GetWindowRect(hWnd, &rect);\n\t\thParent = ::GetParent(hWnd);\n\n\t\tif(hParent != NULL) \n\t\t{\n\t\t\thTemp = hWnd;\n\t\t\tdo \n\t\t\t{\n\t\t\t\thTemp = ::GetWindow(hTemp, GW_HWNDNEXT);\n\n\t\t\t\t::GetWindowRect(hTemp, &rcTemp);\n\t\t\t\tif(::PtInRect(&rcTemp, point) && ::GetParent(hTemp) == hParent && ::IsWindowVisible(hTemp))\n\t\t\t\t{\n\t\t\t\t\tif(((rcTemp.right - rcTemp.left) * (rcTemp.bottom - rcTemp.top)) < ((rect.right - rect.left) * (rect.bottom - rect.top))) \n\t\t\t\t\t{\n\t\t\t\t\t\thWnd = hTemp;\n\t\t\t\t\t\t::GetWindowRect(hWnd, &rect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while(hTemp != NULL);\n\t\t}\n\t}\n\n\treturn hWnd;\n}\n\n\nvoid CDragPic::OnTimer(UINT_PTR nIDEvent)\n{\n    if (nIDEvent = TIMERID)\n    {\n        HWND deskWnd = ::GetDesktopWindow();\n        HDC deskDC = ::GetWindowDC(deskWnd);\n        int oldRop2 = SetROP2(deskDC, R2_NOTXORPEN);\n\n        CPoint pt;\n        GetCursorPos(&pt);\n\n\n        HWND hTargetWnd = SmallestWindowFromPoint(pt);\n        //m_hWnd = hTargetWnd;\n        if (GetWindowThreadProcessId(GetSafeHwnd(), NULL) == GetWindowThreadProcessId(hTargetWnd, NULL))\n        {\n            GetParent()->SetDlgItemText(IDC_EDIT_WINDOWTITLE, _T(\"\"));\n            return;\n        }\n\n        DWORD pid = 0;\n        GetWindowThreadProcessId(hTargetWnd, &pid);\n        GetParent()->SetDlgItemInt(IDC_EDIT_PID, pid);\n\n        //\u7a97\u53e3\u6807\u9898\u3001\u7f16\u8f91\u6846\u6587\u672c\u7684\u83b7\u53d6\n        LRESULT nLen = ::SendMessage(hTargetWnd, WM_GETTEXTLENGTH, 0, 0);\n        if (nLen > 0)\n        {\n            nLen += 1;\n            TCHAR *pszBuf = new TCHAR[nLen];\n            ZeroMemory(pszBuf, nLen);\n            ::SendMessage(hTargetWnd, WM_GETTEXT, nLen, (LPARAM)pszBuf);\n            GetParent()->SetDlgItemText(IDC_EDIT_WINDOWTITLE, pszBuf);\n            delete[] pszBuf;\n        }\n\n        //::GetWindowRect(m_hWnd, &rc);\n        CRect mRect;\n        ::GetWindowRect(hTargetWnd, &mRect);\n\n        if (mRect.left < 0)\n        {\n            mRect.left = 0;\n        }\n        if (mRect.top < 0)\n        {\n            mRect.top = 0;\n        }\n\n        HPEN newPen = ::CreatePen(0, 3, RGB(0, 167, 255));\n        HGDIOBJ oldPen = ::SelectObject(deskDC, newPen);\n\n        ::Rectangle(deskDC, mRect.left, mRect.top, mRect.right, mRect.bottom);\n        Sleep(200);\n        ::Rectangle(deskDC, mRect.left, mRect.top, mRect.right, mRect.bottom);\n\n        ::SetROP2(deskDC, oldRop2);\n        ::SelectObject(deskDC, oldPen);\n\n        ::DeleteObject(newPen);\n        ::ReleaseDC(deskWnd, deskDC);\n        deskDC = NULL;\n    }\n\t\n\n\tCStatic::OnTimer(nIDEvent);\n}\n",
    "#include <vector>\n#include \"binarytree.hpp\"\n#include \"slidwindow.hpp\"\nusing namespace std;\n\nvoid bitree_demo()\n{\n\t//\u6839\u636e\u6570\u7ec4\u6784\u9020\u4e8c\u53c9\u6811\n\tvector<int> list = { 1,5,3,3,6,9,8 };\n\tbinarytree<int>* tree = new binarytree<int>(list);\n\t//fun\u7ed1\u5b9aprint\u51fd\u6570\uff0c\u5148\u5e8f\u904d\u5386\u4e8c\u53c9\u6811\u6253\u5370\u5404\u8282\u70b9\u503c\n\tauto fun = bind(&binarytree<int>::print,tree, placeholders::_1);\n\ttree->order(fun,0);\n\t//\u67e5\u627edata==3\u7684\u8282\u70b9\u5730\u5740\n\tauto address = tree->search(3);\n\tfor (auto iter = address.begin(); iter != address.end(); iter++)\n\t{\n\t\tcout << \"address: \" << *iter << \"  data:\" << (*iter)->data << endl;\n\t}\n\t//\u67e5\u627e\u7b2c\u4e00\u4e2adata==3\u7684\u8282\u70b9\u7684\u7236\u8282\u70b9\u5730\u5740\n\tauto father = tree->parent(address[0]);\n\tcout << \"address: \" << father << \"  data:\" << father->data << endl;\n\n\n}\n\nvoid graph_demo()\n{\n\n}\n\nvoid PID_demo()\n{\n\n\n}\n\nvoid slidwin_demo()\n{\n\tvector<int> arr;\n\tint i;\n\tint n;\n\tint item;\n\tcin >> n;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> item;\n\t\tarr.push_back(item);\n\t}\n\tslidewindow<int> window = slidewindow<int>(arr);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\twindow.add();\n\t}\n\tfunction<void(int)> fun = (\n\t\t[&](int item)\n\t\t{\n\t\t\tcout << item << endl;\n\t\t}\n\t);\n\twindow.order(fun);\n}\n\nvoid main()\n{\n\tslidwin_demo();\n}\n\n",
    "#include <iostream>\n\nclass Node{\n    public:\n        int value;\n        Node* next;\n\n        Node(int value){\n            this->value = value;\n            next = nullptr;\n        }\n};\n\nclass LinkedList{\n    private:\n        Node* head;\n        Node* tail;\n        int length = 0;\n    public:\n        LinkedList(int value){\n            Node* new_node = new Node(value);\n            this->head = new_node;\n            this->tail = new_node;\n            length++;\n        }\n\n        ~LinkedList(){\n            Node* temp = head;\n            while(head){\n                head = head->next;\n                delete temp;\n                temp = head;\n            };\n        }\n\n        void show_all_value(){\n            if(length == 0){\n                std::cout << \"Empty\" << std::endl;\n                return;\n            }\n            Node* temp = head;\n            while(temp){\n                std::cout << temp->value << \" \";\n                temp = temp->next;\n            }\n            std::cout << \"\\n\";\n        }\n        \n        void show_head(){\n            if(length == 0) return;\n            std::cout << head->value << std::endl;\n        }\n\n        void show_tail(){\n            if(length == 0) return;\n            std::cout << tail->value << std::endl;\n        }\n\n        void get_length(){\n            std::cout << length << std::endl;\n        }\n\n        void empty_list(){\n            if(length == 0) return;\n            Node* temp = head;\n            while(head){\n                head = head->next;\n                delete temp;\n                temp = head;\n            }\n        }\n\n        void prepend(int value){\n            Node* new_node = new Node(value);\n            if(length == 0){\n               this->head = new_node;\n               this->tail = new_node;\n            }\n            else{\n                new_node->next = this->head;\n                this->head = new_node;\n            }\n            length++;\n        }\n        \n        void append(int value){\n            Node* new_node = new Node(value);\n            if(length == 0){\n                this->head = new_node;\n                this->tail = new_node;\n            }\n            else{\n                tail->next = new_node;\n                this->tail = new_node;\n            }\n            length++;\n        }\n\n        void delete_first(){\n            if(length == 0) return;\n            Node* temp = head;\n            if(length == 1){\n                this->head = nullptr;\n                this->tail = nullptr;\n            }\n            else{\n                this->head = head->next;\n            }\n            delete  temp; \n            length--;\n        }\n\n        void delete_last(){\n            if(length == 0) return;\n            Node* temp = head;\n            if(length  == 1){\n                this->head = nullptr;\n                this->tail = nullptr;\n            }\n            else{\n                Node* prev = nullptr;\n                while(temp->next){\n                    prev = temp;\n                    temp = temp->next;\n                }\n                this->tail = prev;\n                tail->next = nullptr;\n            }\n            delete temp;\n            length--;\n        }\n\n        Node* get(int index){\n            if(length == 0){\n                std::cout << \"GET : Empty\" << std::endl;\n                return nullptr;\n            }\n            if(index < 0 || index > length-1){\n                std::cout << \"GET : Out of Bounds\" << std::endl;\n                return nullptr;\n            }\n            else{\n                Node* temp = head;\n                for(int i=0; i < index; i++){\n                    temp = temp->next;\n                }\n                return temp;\n            }\n        }\n        \n        bool set(int index, int value){\n            if(length == 0){\n                std::cout << \"SET : Empty\" << std::endl;\n                return false;\n            }\n            if(index < 0 || index > length-1){\n                std::cout << \"SET : Out Of Bounds\" << std::endl;\n                return false;\n            }\n            else{\n                Node* temp = head;\n                for(int i=0; i < index; i++){\n                    temp = temp->next;\n                }\n                temp->value = value;\n                return true;\n            }\n        }\n        \n        bool insert(int index, int value){\n\n            if(index < 0 || index > length){\n                std::cout << \"INSERT: out of bounds \" << std::endl;\n                return false;\n            }\n\n            if(length == 0){\n                this->append(value);\n                return true;\n            }\n\n            else if(length == index){\n                this->append(value);\n                return true;\n            }\n\n            else{\n                Node* new_node = new Node(value);\n                Node* before = this->get(index - 1);\n                Node* after = before->next;\n                new_node->next = after;\n                before->next = new_node;\n            }\n            ",
    "#include \"../includes/thing.h\" // my horrible \"simplification\", i just pump every possible function into here. I N C L U D E   T H I S   F I R S T ! ! !\n\n// lazy definitions\nfloat seed = 42405.4;\n\nvoid vertexSpec() { // stuff happens here\n    GLfloat quadVertices[] = {\n        // Positions    // Texture coordinates\n        -1.0f,  1.0f,   0.0f, 1.0f,\n        -1.0f, -1.0f,   0.0f, 0.0f,\n        1.0f, -1.0f,   1.0f, 0.0f,\n\n        -1.0f,  1.0f,   0.0f, 1.0f,\n        1.0f, -1.0f,   1.0f, 0.0f,\n        1.0f,  1.0f,   1.0f, 1.0f\n    };\n\n// quad for post processing\n    glGenVertexArrays(1, &quadVAO);\n    glGenBuffers(1, &quadVBO);\n    glBindVertexArray(quadVAO);\n    glBindBuffer(GL_ARRAY_BUFFER, quadVBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));\n\n    // Unbind VAO\n    glBindVertexArray(0);\n\n    // bind stuff to vertex array index 0\n    glBindVertexArray(0);\n    // clean up\n    glDisableVertexAttribArray(0);\n    glDisableVertexAttribArray(1);\n    glDisableVertexAttribArray(2);\n}\n\nvoid input() {\n    if(keyPressed(SDLK_EQUALS)) {\n        releaseKey(SDLK_EQUALS);\n        moveSpeed *= 2;\n    }\n    if(keyPressed(SDLK_MINUS)) {\n        releaseKey(SDLK_MINUS);\n        moveSpeed /= 2;\n        if(moveSpeed < 0.001) moveSpeed = 0.001;\n    }\n    if(keyPressed(SDLK_w)) {\n        position.z -= moveSpeed;\n    }\n    if(keyPressed(SDLK_s)) {\n        position.z += moveSpeed;\n    }\n    if(keyPressed(SDLK_a)) {\n        position.x -= moveSpeed;\n    }\n    if(keyPressed(SDLK_d)) {\n        position.x += moveSpeed;\n    }\n    if(keyPressed(SDLK_q)) {\n        position.y -= moveSpeed;\n    }\n    if(keyPressed(SDLK_z)) {\n        seed -= 0.01;\n    }\n    if(keyPressed(SDLK_x)) {\n        seed += 0.01;\n    }\n    if(keyPressed(SDLK_e)) {\n        position.y += moveSpeed;\n    }\n    if(keyPressed(SDLK_F5)) {\n        mainShader = new Shader(\"./shaders/vertexShader.glsl\", \"./shaders/fragmentShader.glsl\");\n        releaseKey(SDLK_F5);\n    }\n    if(keyPressed(SDLK_o)) {\n        std::cout << \"Stats:\\n\";\n        std::cout << \"Seed: \\\"\" << std::to_string(seed) << \"\\\".\\n\";\n        std::cout << \"Position:\\n\";\n        std::cout << std::to_string(position.x) << \" x,\\n\";\n        std::cout << std::to_string(position.y) << \" y,\\n\";\n        std::cout << std::to_string(position.z) << \" z.\\n\";\n    }\n}\n\nvoid drawQuad() {\n    mainShader->use();\n    mainShader->setVec2(\"screen\", glm::vec2(WIDTH, HEIGHT));\n    mainShader->setVec3(\"camPos\", position);\n    mainShader->setFloat(\"seed\", seed);\n\n    glBindVertexArray(quadVAO);\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n}\n\n\nvoid frame() {\n    glViewport(0, 0, WIDTH, HEIGHT);\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    drawQuad();\n}\n\nvoid mainLoop() {\n    glEnable(GL_CULL_FACE);\n    glClearColor(0.7f, 0.0f, 0.0f, 1.0f);\n    while (running) {\n        inputHandler();\n        input();\n\n        frame();\n\n        redisplay();\n    }\n}\n\nint main() { // yeah...\n    init();\n\n    vertexSpec();\n\n    mainLoop();\n\n    cleanUp();\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <bits/stdc++.h>\n\n#include <iostream>\n#include<cstdio>\nusing namespace std;\n\n\nint main(){\n    int t; cin >> t;\n    while(t--){\n        int n; cin >>n;\n        char direto[2*n][2*n];\n        int linha = 0;\n        bool cU = true;\n        if(n%2==0){\n            for(int i = 0; i<n*2; i = i + 2){\n                if (cU) {\n                    for(int j=0; j<n*2; j = j + 4){\n                        direto[i][j] = '#';\n                        direto[i][j+1] = '#';\n                        direto[i+1][j] = '#';\n                        direto[i+1][j+1] = '#';\n                        direto [i][j + 2] = '.';\n                        direto [i][j + 3] = '.';\n                        direto [i+1][j + 2] = '.';\n                        direto [i+1][j + 3] = '.';\n                    }\n                    cU = false;\n                }else{\n                    for(int j=0; j<n*2; j = j + 4){\n                        direto [i][j] = '.';\n                        direto [i][j+1] = '.';\n                        direto [i+1][j] = '.';\n                        direto [i+1][j+1] = '.';\n                        direto[i][j + 2] = '#';\n                        direto[i][j + 3] = '#';\n                        direto[i+1][j + 2] = '#';\n                        direto[i+1][j + 3] = '#';\n                    }\n                    cU = true;\n                }\n            }\n        }else{\n            for(int i = 0; i<n*2; i = i + 2){\n                for(int j=0; j<n*2; j = j + 2){\n                    if(cU){\n                        direto[i][j] = '#';\n                        direto[i][j+1] = '#';\n                        direto[i+1][j] = '#';\n                        direto[i+1][j+1] = '#';\n                        cU = false;\n                    }else{\n                        direto [i][j] = '.';\n                        direto [i][j+1] = '.';\n                        direto [i+1][j] = '.';\n                        direto [i+1][j+1] = '.';\n                        cU = true;\n                    }   \n                }\n            }\n        }\n        for (int i = 0; i < n*2; i++){\n            for (int j = 0; j < n*2; j++){\n                cout << direto[i][j];\n\n            }\n            cout << endl;   \n        }\n        for (int i = 0; i < n*2; i++){\n            for (int j = 0; j < n*2; j++){\n                direto[i][j] = 0;\n\n            } \n        }\n        \n    }\n    return 0;\n}",
    "#include \"Symbol.h\"\n#include <iostream>\n\nvoid Symbol::generateSymbolOfRightDownStairs() {\n    for (int i = 1; i <= _step; i++) {\n        for (int j = 1; j <= i; j++) {\n            std::cout << _character;\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid Symbol::generateSymbolOfLeftDownStairs() {\n    for (int i = 1; i <= _step; i++) {\n        for (int j = 1; j <= _step; j++) {\n            outputIfAbsoluteValueIsLessThanSpecifiedValue(i, _step + 1 - j);\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid Symbol::generateSymbolOfDiamond() {\n    // \u6bb5\u6570\u304c\u5076\u6570\u3060\u3068\u7dba\u9e97\u306a\u30c0\u30a4\u30e4\u30e2\u30f3\u30c9\u72b6\u306b\u306a\u3089\u306a\u3044\u305f\u3081\u3001\u5947\u6570\u306e\u5834\u5408\u6bb5\u6570\u3092-1\n    if (_step % 2 == 0) _step -= 1;\n    int median = (double)_step / 2 + 0.5;\n\n    // \u4e2d\u592e\u307e\u3067\u306e\u63cf\u753b\n    for (int i = 1; i <= median; i++) {\n        for (int j = 1; j <= _step; j++) {\n            outputIfAbsoluteValueIsLessThanSpecifiedValue(i - 1,\n                abs(median - j));\n        }\n        std::cout << \"\\n\";\n    }\n\n    // \u4e2d\u592e\u3088\u308a\u4e0b\u306e\u63cf\u753b\n    for (int i = median - 1; i >= 1; i--) {\n        for (int j = 1; j <= _step; j++) {\n            outputIfAbsoluteValueIsLessThanSpecifiedValue(i - 1,\n                abs(median - j));\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nvoid Symbol::outputIfAbsoluteValueIsLessThanSpecifiedValue(\n    int determinedValue, int designatedValue) {\n    if (determinedValue >= designatedValue) {\n        std::cout << _character;\n    } else {\n        std::cout << \" \";\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"demopro\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <iostream>\n#include <random>\n\nusing namespace std;\n\nstring generateRandomPassword(const vector<string>& charSet, int max) {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dist(0, charSet.size() - 1);\n\n    string password;\n    for (int i = 0; i < max; ++i) {\n        password += charSet[dist(gen)];\n    }\n    return password;\n}\n\nint main() {\n    system(\"chcp 1251 > nul\");\n\n    string numbers, english_characters, special_characters;\n    vector<string> charSet = {};\n\n    cout << \"\u0412 \u0432\u0430\u0448\u0435\u043c \u043f\u0430\u0440\u043e\u043b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0446\u0438\u0444\u0440\u044b: \";\n    cin >> numbers;\n    if (numbers == \"\u0434\u0430\") {\n        charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\" };\n    }\n    else if (numbers == \"\u043d\u0435\u0442\") {\n        charSet = {};\n    }\n    else {\n        cout << \"\u041e\u0448\u0438\u0431\u043a\u0430! \u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c!\" << endl;\n        return 1;\n    }\n\n    cout << \"\u0412 \u0432\u0430\u0448\u0435\u043c \u043f\u0430\u0440\u043e\u043b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0430\u043d\u0433\u043b\u0438\u0439\u0441\u043a\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b: \";\n    cin >> english_characters;\n    if (english_characters == \"\u0434\u0430\") {\n        if (numbers == \"\u0434\u0430\") {\n            charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\",\n        \"a\", \"b\", \"c\",  \"d\",  \"e\",  \"f\",  \"g\",  \"h\",  \"i\",  \"j\",  \"k\",  \"l\",  \"m\",  \"n\",\n        \"o\",  \"p\",  \"q\",  \"r\",  \"s\",  \"t\",  \"w\",  \"x\",  \"y\",  \"z\",\n        \"A\", \"B\", \"C\",  \"D\",  \"E\",  \"F\",  \"G\",  \"H\",  \"I\",  \"J\",  \"K\",  \"L\",  \"M\",  \"N\",\n        \"O\",  \"P\",  \"Q\",  \"R\",  \"S\",  \"T\",  \"W\",  \"X\",  \"Y\",  \"Z\" };\n        }\n        else if (numbers == \"\u043d\u0435\u0442\") {\n            charSet = { \"a\", \"b\", \"c\",  \"d\",  \"e\",  \"f\",  \"g\",  \"h\",  \"i\",  \"j\",  \"k\",  \"l\",  \"m\",  \"n\",\n        \"o\",  \"p\",  \"q\",  \"r\",  \"s\",  \"t\",  \"w\",  \"x\",  \"y\",  \"z\",\n        \"A\", \"B\", \"C\",  \"D\",  \"E\",  \"F\",  \"G\",  \"H\",  \"I\",  \"J\",  \"K\",  \"L\",  \"M\",  \"N\",\n        \"O\",  \"P\",  \"Q\",  \"R\",  \"S\",  \"T\",  \"W\",  \"X\",  \"Y\",  \"Z\" };\n        }\n    }\n    else if (english_characters == \"\u043d\u0435\u0442\") {\n        if (numbers == \"\u0434\u0430\") {\n            charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\" };\n        }\n        else if (numbers == \"\u043d\u0435\u0442\") {\n            charSet = {};\n        }\n    }\n    else {\n        cout << \"\u041e\u0448\u0438\u0431\u043a\u0430! \u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c!\" << endl;\n        return 1;\n    }\n\n    cout << \"\u0412 \u0432\u0430\u0448\u0435\u043c \u043f\u0430\u0440\u043e\u043b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b: \";\n    cin >> special_characters;\n    if (special_characters == \"\u0434\u0430\") {\n        if (english_characters == \"\u0434\u0430\") {\n            if (numbers == \"\u0434\u0430\") {\n                charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\",\n                \"a\", \"b\", \"c\",  \"d\",  \"e\",  \"f\",  \"g\",  \"h\",  \"i\",  \"j\",  \"k\",  \"l\",  \"m\",  \"n\",\n                \"o\",  \"p\",  \"q\",  \"r\",  \"s\",  \"t\",  \"w\",  \"x\",  \"y\",  \"z\",\n                \"A\", \"B\", \"C\",  \"D\",  \"E\",  \"F\",  \"G\",  \"H\",  \"I\",  \"J\",  \"K\",  \"L\",  \"M\",  \"N\",\n                \"O\",  \"P\",  \"Q\",  \"R\",  \"S\",  \"T\",  \"W\",  \"X\",  \"Y\",  \"Z\",\n                \"-\", \"_\", \"+\", \"=\", \"(\", \")\", \"*\", \"&\", \"?\" };\n            }\n            else if (numbers == \"\u043d\u0435\u0442\") {\n                charSet = { \"a\", \"b\", \"c\",  \"d\",  \"e\",  \"f\",  \"g\",  \"h\",  \"i\",  \"j\",  \"k\",  \"l\",  \"m\",  \"n\",\n                \"o\",  \"p\",  \"q\",  \"r\",  \"s\",  \"t\",  \"w\",  \"x\",  \"y\",  \"z\",\n                \"A\", \"B\", \"C\",  \"D\",  \"E\",  \"F\",  \"G\",  \"H\",  \"I\",  \"J\",  \"K\",  \"L\",  \"M\",  \"N\",\n                \"O\",  \"P\",  \"Q\",  \"R\",  \"S\",  \"T\",  \"W\",  \"X\",  \"Y\",  \"Z\",\n                \"-\", \"_\", \"+\", \"=\", \"(\", \")\", \"*\", \"&\", \"?\" };\n            }\n        }\n        else if (english_characters == \"\u043d\u0435\u0442\") {\n            if (numbers == \"\u0434\u0430\") {\n                charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\",\n                \"-\", \"_\", \"+\", \"=\", \"(\", \")\", \"*\", \"&\", \"?\" };\n            }\n            else if (numbers == \"\u043d\u0435\u0442\") {\n                charSet = { \"-\", \"_\", \"+\", \"=\", \"(\", \")\", \"*\", \"&\", \"?\" };\n            }\n        }\n    }\n    else if (special_characters == \"\u043d\u0435\u0442\") {\n        if (english_characters == \"\u0434\u0430\") {\n            charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\",\n            \"a\", \"b\", \"c\",  \"d\",  \"e\",  \"f\",  \"g\",  \"h\",  \"i\",  \"j\",  \"k\",  \"l\",  \"m\",  \"n\",\n            \"o\",  \"p\",  \"q\",  \"r\",  \"s\",  \"t\",  \"w\",  \"x\",  \"y\",  \"z\",\n            \"A\", \"B\", \"C\",  \"D\",  \"E\",  \"F\",  \"G\",  \"H\",  \"I\",  \"J\",  \"K\",  \"L\",  \"M\",  \"N\",\n            \"O\",  \"P\",  \"Q\",  \"R\",  \"S\",  \"T\",  \"W\",  \"X\",  \"Y\",  \"Z\" };\n        }\n        else if (english_characters == \"\u043d\u0435\u0442\") {\n            if (numbers == \"\u0434\u0430\") {\n                charSet = { \"1\", \"2\", \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",  \"0\" };\n            }\n            else if (numbers == \"\u043d\u0435\u0442\") {\n                cout << \"\u0410 \u0438\u0437 \u0447\u0435\u0433\u043e \u043c\u043d\u0435 \u0431\u043b\u044f\u0442\u044c \u0442\u043e\u0433\u0434\u0430 \u043f\u0430\u0440\u043e\u043b\u044c \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0434\u043e\u043b\u0431\u043e\u0451\u0431?\";\n                return 1;\n            }\n        }\n    }\n    else {\n        cout << \"\u041e\u0448\u0438\u0431\u043a\u0430! \u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c!\" << endl;\n        return 1;\n    }\n\n    int max;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0436\u0435\u043b\u0430\u0435\u043c\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0432 \u043f\u0430\u0440\u043e\u043b\u0435: \";\n    cin >> max;\n\n    string password = generateRandomPassword(charSet, max);\n    cout << \"\u0412\u0430\u0448 \u043f\u0430\u0440\u043e\u043b\u044c: \" << password << endl;\n\n    system(\"pause > nul\");\n\n    return 0;\n}\n",
    "#define DESCRIPTOR_DEF\n#include \"croskblight.h\"\n#include <acpiioct.h>\n#include <ntstrsafe.h>\n#define NOTVM 1\n\nstatic ULONG CrosKBLightDebugLevel = 100;\nstatic ULONG CrosKBLightDebugCatagories = DBG_INIT || DBG_PNP || DBG_IOCTL;\n\nNTSTATUS\nDriverEntry(\n\t__in PDRIVER_OBJECT  DriverObject,\n\t__in PUNICODE_STRING RegistryPath\n\t)\n{\n\tNTSTATUS               status = STATUS_SUCCESS;\n\tWDF_DRIVER_CONFIG      config;\n\tWDF_OBJECT_ATTRIBUTES  attributes;\n\n\tCrosKBLightPrint(DEBUG_LEVEL_INFO, DBG_INIT,\n\t\t\"Driver Entry\");\n\n\tWDF_DRIVER_CONFIG_INIT(&config, CrosKBLightEvtDeviceAdd);\n\n\tWDF_OBJECT_ATTRIBUTES_INIT(&attributes);\n\n\t//\n\t// Create a framework driver object to represent our driver.\n\t//\n\n\tstatus = WdfDriverCreate(DriverObject,\n\t\tRegistryPath,\n\t\t&attributes,\n\t\t&config,\n\t\tWDF_NO_HANDLE\n\t\t);\n\n\tif (!NT_SUCCESS(status))\n\t{\n\t\tCrosKBLightPrint(DEBUG_LEVEL_ERROR, DBG_INIT,\n\t\t\t\"WdfDriverCreate failed with status 0x%x\\n\", status);\n\t}\n\n\treturn status;\n}\n\n#define MAX_DEVICE_REG_VAL_LENGTH 0x100\nNTSTATUS GetSmbiosName(WCHAR systemProductName[MAX_DEVICE_REG_VAL_LENGTH]) {\n\tNTSTATUS status = STATUS_UNSUCCESSFUL;\n\tHANDLE parentKey = NULL;\n\tUNICODE_STRING ParentKeyName;\n\tOBJECT_ATTRIBUTES  ObjectAttributes;\n\tRtlInitUnicodeString(&ParentKeyName, L\"\\\\Registry\\\\Machine\\\\Hardware\\\\DESCRIPTION\\\\System\\\\BIOS\");\n\n\tInitializeObjectAttributes(&ObjectAttributes,\n\t\t&ParentKeyName,\n\t\tOBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,\n\t\tNULL,    // handle\n\t\tNULL);\n\n\tstatus = ZwOpenKey(&parentKey, KEY_READ, &ObjectAttributes);\n\tif (!NT_SUCCESS(status)) {\n\t\treturn status;\n\t}\n\n\tULONG ResultLength;\n\tPKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePoolZero(NonPagedPool, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_DEVICE_REG_VAL_LENGTH, CROSKBLIGHT_POOL_TAG);\n\tif (!KeyValueInfo) {\n\t\tstatus = STATUS_NO_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tUNICODE_STRING SystemProductNameValue;\n\tRtlInitUnicodeString(&SystemProductNameValue, L\"SystemProductName\");\n\tstatus = ZwQueryValueKey(parentKey, &SystemProductNameValue, KeyValuePartialInformation, KeyValueInfo, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_DEVICE_REG_VAL_LENGTH, &ResultLength);\n\tif (!NT_SUCCESS(status)) {\n\t\tgoto exit;\n\t}\n\n\tif (KeyValueInfo->DataLength > MAX_DEVICE_REG_VAL_LENGTH) {\n\t\tstatus = STATUS_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\n\tRtlZeroMemory(systemProductName, sizeof(systemProductName));\n\tRtlCopyMemory(systemProductName, &KeyValueInfo->Data, KeyValueInfo->DataLength);\n\nexit:\n\tif (KeyValueInfo) {\n\t\tExFreePoolWithTag(KeyValueInfo, CROSKBLIGHT_POOL_TAG);\n\t}\n\treturn status;\n}\n\n#if NOTVM\nNTSTATUS ConnectToEc(\n\t_In_ WDFDEVICE FxDevice\n) {\n\tPCROSKBLIGHT_CONTEXT pDevice = GetDeviceContext(FxDevice);\n\tWDF_OBJECT_ATTRIBUTES objectAttributes;\n\n\tWDF_OBJECT_ATTRIBUTES_INIT(&objectAttributes);\n\tobjectAttributes.ParentObject = FxDevice;\n\n\tNTSTATUS status = WdfIoTargetCreate(FxDevice,\n\t\t&objectAttributes,\n\t\t&pDevice->busIoTarget\n\t);\n\tif (!NT_SUCCESS(status))\n\t{\n\t\tCrosKBLightPrint(\n\t\t\tDEBUG_LEVEL_ERROR,\n\t\t\tDBG_IOCTL,\n\t\t\t\"Error creating IoTarget object - 0x%x\\n\",\n\t\t\tstatus);\n\t\tif (pDevice->busIoTarget)\n\t\t\tWdfObjectDelete(pDevice->busIoTarget);\n\t\treturn status;\n\t}\n\n\tDECLARE_CONST_UNICODE_STRING(busDosDeviceName, L\"\\\\DosDevices\\\\GOOG0004\");\n\n\tWDF_IO_TARGET_OPEN_PARAMS openParams;\n\tWDF_IO_TARGET_OPEN_PARAMS_INIT_OPEN_BY_NAME(\n\t\t&openParams,\n\t\t&busDosDeviceName,\n\t\t(GENERIC_READ | GENERIC_WRITE));\n\n\topenParams.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;\n\topenParams.CreateDisposition = FILE_OPEN;\n\topenParams.FileAttributes = FILE_ATTRIBUTE_NORMAL;\n\n\tCROSEC_INTERFACE_STANDARD CrosEcInterface;\n\tRtlZeroMemory(&CrosEcInterface, sizeof(CrosEcInterface));\n\n\tstatus = WdfIoTargetOpen(pDevice->busIoTarget, &openParams);\n\tif (!NT_SUCCESS(status))\n\t{\n\t\tCrosKBLightPrint(\n\t\t\tDEBUG_LEVEL_ERROR,\n\t\t\tDBG_IOCTL,\n\t\t\t\"Error opening IoTarget object - 0x%x\\n\",\n\t\t\tstatus);\n\t\tWdfObjectDelete(pDevice->busIoTarget);\n\t\treturn status;\n\t}\n\n\tstatus = WdfIoTargetQueryForInterface(pDevice->busIoTarget,\n\t\t&GUID_CROSEC_INTERFACE_STANDARD,\n\t\t(PINTERFACE)&CrosEcInterface,\n\t\tsizeof(CrosEcInterface),\n\t\t1,\n\t\tNULL);\n\tWdfIoTargetClose(pDevice->busIoTarget);\n\tpDevice->busIoTarget = NULL;\n\tif (!NT_SUCCESS(status)) {\n\t\tCrosKBLightPrint(DEBUG_LEVEL_ERROR, DBG_PNP,\n\t\t\t\"WdfFdoQueryForInterface failed 0x%x\\n\", status);\n\t\treturn status;\n\t}\n\n\tpDevice->CrosEcBusContext = CrosEcInterface.InterfaceHeader.Context;\n\tpDevice->CrosEcCmdXferStatus = CrosEcInterface.CmdXferStatus;\n\treturn status;\n}\n\nstatic NTSTATUS send_ec_command(\n\t_In_ PCROSKBLIGHT_CONTEXT pDevice,\n\tUINT32 cmd,\n\tUINT32 version,\n\tUINT8* out,\n\tsize_t outSize,\n\tUINT8* in,\n\tsize_t inSize)\n{\n\tPCROSEC_COMMAND msg = (PCROSEC_COMMAND)ExAllocatePoolWithTag(NonPagedPool, sizeof(CROSEC_COMMAND) + max(outSize, inSize), CROSKBLIGHT_POOL_TAG);\n\tif (!msg) {\n\t\treturn STATUS_NO_MEMORY;\n\t}\n\tmsg->Version = version;\n\tmsg->Command = cmd;\n\tmsg->OutSize = outSize;\n\tmsg->InSize = inSize;\n\n\tif (outSize)\n\t\tmemcpy(msg->Data, out, outSize);\n\n\tNTSTATUS status = (*pDevice->CrosEcCmdXferStatus)(pDevice->CrosEcBusCon",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//////////////////////////////////////////////written by mht83/////////////////////////////////////////\n#include <iostream>\n#include <string>\n#include <bitset>\n\n// ANSI color codes for terminal output\nconst std::string RED = \"\\033[31m\";\nconst std::string GREEN = \"\\033[32m\";\nconst std::string YELLOW = \"\\033[33m\";\nconst std::string BLUE = \"\\033[34m\";\nconst std::string RESET = \"\\033[0m\";\n\nstd::string binaryToGray(std::string binary) {\n    std::string gray = \"\";\n    gray += binary[0];\n\n    for (size_t i = 1; i < binary.length(); i++) {\n        gray += (binary[i - 1] == binary[i]) ? '0' : '1';\n    }\n    return gray;\n}\n\n\nstd::string grayToBinary(std::string gray) {\n    std::string binary = \"\";\n    binary += gray[0];\n\n    for (size_t i = 1; i < gray.length(); i++) {\n        binary += (binary[i - 1] == gray[i]) ? '0' : '1';\n    }\n    return binary;\n}\n\nint main() {\n    std::cout << GREEN << \"Welcome to the 5-bit Gray Code Generator!\" << RESET << \"\\n\";\n    std::cout << \"This program displays the binary representations, Gray code representations,\\n\";\n    std::cout << \"and decoded Gray code values for all 5-bit numbers.\\n\\n\";\n\n    std::cout << BLUE << \"Binary\\tGray\\tDecoded\" << RESET << \"\\n\";\n    for (int i = 0; i < 32; ++i) {\n        std::string binary = std::bitset<5>(i).to_string();\n        std::string gray = binaryToGray(binary);\n        std::string decoded = grayToBinary(gray);\n        std::cout << YELLOW << binary << \"\\t\" << RESET;\n        std::cout << RED << gray << \"\\t\" << RESET;\n        std::cout << GREEN << decoded << RESET << \"\\n\";\n    }\n    return 0;\n}",
    "#include <iostream>\r\n#include <conio.h>\r\n#include <windows.h>\r\nusing namespace std;\r\nbool gameOver;\r\nconst int width = 20;\r\nconst int height = 20;\r\nint x, y, fruitX, fruitY, score;\r\nint tailX[100], tailY[100];\r\nint nTail;\r\nenum eDirecton { STOP = 0, LEFT, RIGHT, UP, DOWN};\r\neDirecton dir;\r\nvoid Setup()\r\n{\r\n    gameOver = false;\r\n    dir = STOP;\r\n    x = width / 2;\r\n    y = height / 2;\r\n    fruitX = rand() % width;\r\n    fruitY = rand() % height;\r\n    score = 0;\r\n}\r\nvoid Draw()\r\n{\r\n    system(\"cls\"); //system(\"clear\");\r\n    for (int i = 0; i < width+2; i++)\r\n        cout << \"#\";\r\n    cout << endl;\r\n \r\n    for (int i = 0; i < height; i++)\r\n    {\r\n        for (int j = 0; j < width; j++)\r\n        {\r\n            if (j == 0)\r\n                cout << \"#\";\r\n            if (i == y && j == x)\r\n                cout << \"O\";\r\n            else if (i == fruitY && j == fruitX)\r\n                cout << \"F\";\r\n            else\r\n            {\r\n                bool print = false;\r\n                for (int k = 0; k < nTail; k++)\r\n                {\r\n                    if (tailX[k] == j && tailY[k] == i)\r\n                    {\r\n                        cout << \"o\";\r\n                        print = true;\r\n                    }\r\n                }\r\n                if (!print)\r\n                    cout << \" \";\r\n            }\r\n                 \r\n \r\n            if (j == width - 1)\r\n                cout << \"#\";\r\n        }\r\n        cout << endl;\r\n    }\r\n \r\n    for (int i = 0; i < width+2; i++)\r\n        cout << \"#\";\r\n    cout << endl;\r\n    cout << \"Score:\" << score << endl;\r\n}\r\nvoid Input()\r\n{\r\n    if (_kbhit())\r\n    {\r\n        switch (_getch())\r\n        {\r\n        case 'a':\r\n            dir = LEFT;\r\n            break;\r\n        case 'd':\r\n            dir = RIGHT;\r\n            break;\r\n        case 'w':\r\n            dir = UP;\r\n            break;\r\n        case 's':\r\n            dir = DOWN;\r\n            break;\r\n        case 'x':\r\n            gameOver = true;\r\n            break;\r\n        }\r\n    }\r\n}\r\nvoid Logic()\r\n{\r\n    int prevX = tailX[0];\r\n    int prevY = tailY[0];\r\n    int prev2X, prev2Y;\r\n    tailX[0] = x;\r\n    tailY[0] = y;\r\n    for (int i = 1; i < nTail; i++)\r\n    {\r\n        prev2X = tailX[i];\r\n        prev2Y = tailY[i];\r\n        tailX[i] = prevX;\r\n        tailY[i] = prevY;\r\n        prevX = prev2X;\r\n        prevY = prev2Y;\r\n    }\r\n    switch (dir)\r\n    {\r\n    case LEFT:\r\n        x--;\r\n        break;\r\n    case RIGHT:\r\n        x++;\r\n        break;\r\n    case UP:\r\n        y--;\r\n        break;\r\n    case DOWN:\r\n        y++;\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\n    //if (x > width || x < 0 || y > height || y < 0)\r\n    //  gameOver = true;\r\n    if (x >= width) x = 0; else if (x < 0) x = width - 1;\r\n    if (y >= height) y = 0; else if (y < 0) y = height - 1;\r\n \r\n    for (int i = 0; i < nTail; i++)\r\n        if (tailX[i] == x && tailY[i] == y)\r\n            gameOver = true;\r\n \r\n    if (x == fruitX && y == fruitY)\r\n    {\r\n        score += 10;\r\n        fruitX = rand() % width;\r\n        fruitY = rand() % height;\r\n        nTail++;\r\n    }\r\n}\r\nint main()\r\n{\r\n    Setup();\r\n    while (!gameOver)\r\n    {\r\n        Draw();\r\n        Input();\r\n        Logic();\r\n        Sleep(10); //sleep(10);\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\nclass entry\n{\nprotected:\n    static int count;\n    string name, address, phone, roll;\n\npublic:\n    int id;\n    string password;\n    entry()\n    {\n        id = count;\n        count++;\n    }\n    void getdata()\n    {\n        system(\"cls\");\n\n        cout << \"enter the details\"\n             << endl;\n        cout << \"*****************\" << endl;\n        cout << \"name :\" << endl;\n        cin >> name;\n        cout << \"address :\" << endl;\n        cin >> address;\n        cout << \"phone number:\" << endl;\n        cin >> phone;\n        cout << \"roll no :\" << endl;\n        cin >> roll;\n        pass();\n        cout << \"id :\" << id << endl;\n        cout << \"data inserted successfully.......!!!\" << endl;\n        getchar();\n    }\n    void putdata()\n    {\n        system(\"cls\");\n        cout << \"DETAILS.....\" << endl;\n        cout << \"name         : \" << name << endl\n             << \"address      : \" << address << endl\n             << \"phone number : \" << phone << endl\n             << \"roll no      : \" << roll << endl\n             << \"id           : \" << id << endl\n             << endl;\n        getchar();\n    }\n    void pass()\n    {\n        cout << \"enter your password\" << endl;\n        cin >> password;\n    }\n    void edit()\n    {\n        system(\"cls\");\n\n        cout << \"enter the details\"\n             << endl;\n        cout << \"*****************\" << endl;\n        cout << \"name :\" << endl;\n        cin >> name;\n        cout << \"address :\" << endl;\n        cin >> address;\n        cout << \"phone number:\" << endl;\n        cin >> phone;\n        cout << \"roll no :\" << endl;\n        cin >> roll;\n        int temp;\n        cout << \"do you want to change password\" << endl;\n        cout << \"1.yes\\n2.no\" << endl;\n        cin >> temp;\n        if (temp == 1)\n            pass();\n        cout << \"id :\" << id << endl;\n        cout << \"data inserted successfully.......!!!\" << endl;\n        getchar();\n    }\n};\n\nint entry::count = 1;\nclass book : public entry\n{\nprotected:\n    static int book1;\n    static int book2;\n    static int book3;\n    static int book4;\n    static int book5;\n\n    int c = 0;\n    int cpp = 0;\n    int dms = 0;\n    int cgr = 0;\n    int java = 0;\n    int day1 = 0;\n    int day2 = 0;\n    int day3 = 0;\n    int day4 = 0;\n    int day5 = 0;\n\npublic:\n    books_avaliable()\n    {\n        cout << endl\n             << endl\n             << endl\n             << endl;\n        cout << \"\\t\\t\\t\\t\\t^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  book name      ||     ||  quatity   ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||--------------------------------------||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c++ book :     ||     ||     \" << book1 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c book :       ||     ||     \" << book2 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  dms book :     ||     ||     \" << book3 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  cgr book :     ||     ||     \" << book4 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  java book :    ||     ||     \" << book5 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t-----------------------------------------\" << endl;\n        getchar();\n    }\n\n    void get_book()\n    {\n        system(\"cls\");\n        cout << endl\n             << endl\n             << endl\n             << endl;\n        cout << \"\\t\\t\\t\\t\\t^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  book name      ||     ||  quatity   ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||--------------------------------------||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c++ book :     ||     ||     \" << book1 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  c book :       ||     ||     \" << book2 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  dms book :     ||     ||     \" << book3 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  cgr book :     ||     ||     \" << book4 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t||  java book :    ||     ||     \" << book5 << \"      ||\" << endl;\n        cout << \"\\t\\t\\t\\t\\t=========================================\" << endl;\n        cout << \"\\t\\t\\t\\t\\t-----------------------------------------\" << endl;\n        getchar();\n\n        int quantity, choice, day;\n\n        do\n        {\n            cout << \"enter the number which book do you want to get\" << endl;\n            cout << \"\\n1.c++ \\n2.c\\n3.dms\\n4.cgr\\n5.java\\n6.exit\" << endl;\n            cin >> choice;\n            switch (choice)\n            {\n            case 1:\n                cout << \"enter how many quantity do you want to get\" << endl;\n                cin >> quantity;\n\n                if (quantity > book1)\n                {\n                    cout << quantity << \" quanti",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#line 1 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/ArduinoOutput/sketch/PRIZM_missionbot.ino.cpp\"\n#include <Arduino.h>\n#line 1 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/PRIZM_missionbot.ino\"\n#include \"PRIZM_missionbot.h\"\n\n//========================== main func ==========================\nvoid setup() {\n  prizm.PrizmBegin();\n  Serial.begin(115200);\n  Serial.print(F(\"\\n\\n[[[Setup Start]]]\\n\\n\"));  // \uc138\ud305\uc644\ub8cc \uba54\uc2dc\uc9c0\n  huskeylensInit();\n  motorInit();\n  battVoltagePrint();\n  linetrace_analogSetting(3.0, 60, 40, 35);\n\n  Get_Avoid_Return(TEA, COLA, BLUE);  // \ubbf8\uc158 \uc138\ud305\uac12\n\n  Serial.print(F(\"\\n\\n[[[Setup Finish]]]\\n\\n\"));  // \uc138\ud305\uc644\ub8cc \uba54\uc2dc\uc9c0\n}\n\nvoid loop() {\n  // battVoltagePrint(1000);\n  setBattVoltage2(12.65);  // \uc815\uc0c1\uc791\ub3d9 \ubc30\ud130\ub9ac \uc804\uc555 12.8 ~ 12.2\n\n  // MissionStart();\n  // MissionStart_register();\n  // Mission_Stupid();\n}\n#line 1 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/battry.ino\"\n// robot State Check\nvoid battVoltagePrint() {\n  int battVoltage = prizm.readBatteryVoltage();\n  Serial.print(F(\"battVoltage : \"));\n  Serial.print(battVoltage / 100);\n  Serial.print(F(\".\"));\n  Serial.print(battVoltage % 100);\n  Serial.println(F(\"V\"));  // \ud604 \ubc30\ud130\ub9ac \uc804\uc555 \uccb4\ud06c\n}\n\nvoid battVoltagePrint(int time) {\n  int battVoltage = prizm.readBatteryVoltage();\n  Serial.print(F(\"battVoltage : \"));\n  Serial.print(battVoltage / 100);\n  Serial.print(F(\".\"));\n  Serial.print(battVoltage % 100);\n  Serial.println(F(\"V\"));  // \ud604 \ubc30\ud130\ub9ac \uc804\uc555 \uccb4\ud06c\n  delay(time);\n}\n\nvoid setBattVoltage2(float setVoltage) {\n  int time = 5000;\n  battVoltagePrint();\n  float battVoltage = prizm.readBatteryVoltage() / 100.0;\n  if (battVoltage > setVoltage) {\n    Serial.print(F(\"> battVoltage TOO HIGH\"));\n    prizm.setMotorPowers(120, 120);\n  } else if (battVoltage < setVoltage - 0.2) {\n    delay(1000);\n    if (battVoltage >= setVoltage - 0.2) time = 500;\n    Serial.print(F(\"> battVoltage TOO LOW :: CHARGE RECOMMENDED\"));\n    prizm.setMotorPowers(125, 125);\n  } else {\n    Serial.print(F(\"> battVoltage JUST RIGHT\"));\n    prizm.setMotorPowers(125, 125);\n    time = 500;\n  }\n  Serial.print(F(\"  Optimal setting : \"));\n  Serial.println(setVoltage);\n  delay(time);\n}\n#line 1 \"/Users/kh_jinu/Desktop/\uc751\uc6a9\ub85c\ubd07\uacf5/PRIZM_missionbot/huskylens.ino\"\nvoid huskeylensInit() {\n  Wire.begin();\n  while (!huskylens.begin(Wire)) {\n    Serial.println(F(\"Begin failed!\"));\n    gripper_closePOS();\n    delay(100);\n  }\n  gripper_openPOS();\n}\n\n//****************************** check NODE ******************************\nvoid check_1NODE(int node) {\n  int SQ_size = ReturnSquareSize();\n  int CNT = 0;\n  while (SQ_size == 0) {\n    if (CNT >= 3) break;\n    CNT++;\n    delay(50);\n    SQ_size = ReturnSquareSize();\n    Serial.print(F(\"SquareSizeCNT : \"));\n    Serial.println(CNT);\n  }\n  if (SQ_size > 100) {\n    if (isObjectTarget())\n      NODE_dataUpdate(node, 1);\n    else\n      NODE_dataUpdate(node, 2);\n  } else\n    NODE_dataUpdate(node, 0);\n}\n\nvoid check_1NODE_Far() {\n  int ObjCNT = ReturnObjectCNT();\n  int CNT = 0;\n  while (ObjCNT == 0) {\n    if (CNT >= 10) break;\n    CNT++;\n    delay(50);\n    ObjCNT = ReturnObjectCNT();\n    Serial.print(F(\"ObjcheckCNT : \"));\n    Serial.println(CNT);\n  }\n  if (ObjCNT > 0) {\n    Serial.print(F(\"ReturnObjectCNT : \"));\n    Serial.println(ObjCNT);\n    if (isObjectTarget())\n      NODE_dataUpdate(NODE3, 1);\n    else\n      NODE_dataUpdate(NODE3, 2);\n  } else {\n    Serial.println(F(\"ReturnObjectCNT : 0\"));\n    NODE_dataUpdate(NODE3, 0);\n  }\n}\n\nvoid check_1NODE_Near() {\n  int ObjCNT = ReturnObjectCNT();\n  int CNT = 0;\n  while (ObjCNT == 0) {\n    if (CNT >= 5) break;\n    CNT++;\n    delay(50);\n    ObjCNT = ReturnObjectCNT();\n    Serial.print(F(\"ObjcheckCNT : \"));\n    Serial.println(CNT);\n  }\n  if (ObjCNT > 0) {\n    if (isObjectTarget())\n      NODE_dataUpdate(NODE7, 1);\n    else\n      NODE_dataUpdate(NODE7, 2);\n  } else\n    NODE_dataUpdate(NODE7, 0);\n}\n\nvoid check_2NODE(int node_near, int node_far) {\n  int SQ_size = ReturnSquareSize();\n  Serial.print(F(\"ReturnSquareSize : \"));\n  Serial.println(SQ_size);\n  if (SQ_size >= 5000) {\n    if (isObjectTarget())\n      NODE_dataUpdate(node_near, 1);\n    else\n      NODE_dataUpdate(node_near, 2);\n  } else if (SQ_size >= 100 && SQ_size < 5000) {\n    NODE_dataUpdate(node_near, 0);\n    int ObjCNT = ReturnObjectCNT();\n    int CNT = 0;\n    while (ObjCNT == 0) {\n      CNT++;\n      if (CNT > 5) break;\n      delay(100);\n      ObjCNT = ReturnObjectCNT();\n      Serial.print(F(\"ObjcheckCNT : \"));\n      Serial.println(CNT);\n    }\n    if (ObjCNT > 0) {\n      if (isObjectTarget())\n        NODE_dataUpdate(node_far, 1);\n      else\n        NODE_dataUpdate(node_far, 2);\n    }\n  } else {\n    NODE_dataUpdate(node_near, 0);\n    NODE_dataUpdate(node_far, 0);\n  }\n}\n\n//****************************** object check ******************************\nbool isObjectTarget() {\n  int id_detected = 0;\n  int CNT = 0;\n  while (id_detected == 0) {\n    CNT++;\n    if (CNT > 5) break;\n    id_detected = IdReturn_Closer();\n  }\n  Serial.print(F(\"detected id : \"));\n  Serial.println(id_detected);\n  if (id_detected == target_object)\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <SDL.h>\r\n#include <SDL_ttf.h>\r\n\r\nusing namespace std;\r\n\r\nSDL_Surface* Screen;\r\nTTF_Font* font;\r\nbool quit = false;\r\n\r\nint main(int argc, char **argv)\r\n{\r\n\tif (SDL_Init(SDL_INIT_VIDEO) == 0)\r\n\t{\r\n\t\tprintf(\"SDL Succesfully initialized\\n\");\r\n    Screen = SDL_SetVideoMode(240, 240,16, SDL_HWSURFACE );\r\n\t\tif(Screen)\r\n\t\t{\r\n      printf(\"Succesfully Set %dx%dx16\\n\",240,240);\r\n      SDL_ShowCursor(SDL_DISABLE);\r\n\t\t\tif (TTF_Init() == 0)\r\n\t\t\t{\r\n        printf(\"Succesfully initialized TTF\\n\");\r\n\t\t\t\tfont = TTF_OpenFont(\"./fs/font.ttf\",50);\r\n\t\t\t\tif (font)\r\n\t\t\t\t{            \r\n\t\t\t\t\t\tprintf(\"Succesfully Loaded fonts\\n\");\r\n\t\t\t\t\t\tTTF_SetFontStyle(font,TTF_STYLE_NORMAL);\r\n\t\t\t\t\t\twhile (!quit)\r\n\t\t\t\t\t\t{\r\n              SDL_Event event;\r\n              while (SDL_PollEvent(&event)) { \r\n                if ((event.type == SDL_QUIT) || (event.type == SDL_KEYDOWN ))\r\n                {\r\n                  quit = true;\r\n                }\r\n              }\r\n              SDL_FillRect(Screen, NULL, SDL_MapRGB(Screen->format,0,0,0));\r\n              FILE *fp;\r\n              char temp[1024];\r\n              \r\n              fp = popen(\"printf \\\"(%d*0.1)-144.7\\\" $(i2cget -y -f 0 0x34 0x5E w|awk '{print \\\"0x\\\"substr($0,5,2)substr($0,4,1)}')|bc\", \"r\");\r\n              if (fp == NULL) {\r\n                printf(\"Failed to run command\\n\" );\r\n                quit = true;\r\n              }\r\n              \r\n              if (fgets(temp, sizeof(temp), fp) != NULL)\r\n              {\r\n                SDL_Color color={255,255,255,255};\r\n                SDL_Surface *TextSurface;\r\n                if(!(TextSurface=TTF_RenderText_Solid(font,temp, color))) \r\n                {\r\n                  printf(\"Failed to render text\\n\" );\r\n                } \r\n                else \r\n                {\r\n                  SDL_Rect rect;\r\n                  rect.x = (240-TextSurface->w) / 2;\r\n                  rect.y = (240-TextSurface->h) / 2;\r\n                  rect.w = TextSurface->w;\r\n                  rect.h = TextSurface->h;\r\n                  SDL_BlitSurface(TextSurface,NULL,Screen,&rect);\r\n                  //perhaps we can reuse it, but I assume not for simplicity.\r\n                  SDL_FreeSurface(TextSurface);\r\n                  SDL_Flip(Screen);\r\n                }\r\n              }\r\n              \r\n              pclose(fp);\r\n              \r\n              SDL_Delay(1000);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tTTF_CloseFont(font);\r\n\t\t\t\t\t\tfont=NULL;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"Failed to Load fonts\\n\");\r\n\t\t\t\t}\r\n\t\t\t\tTTF_Quit();\r\n\t\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tprintf(\"Failed to initialize TTF\\n\");\r\n\t\t\t}\r\n      SDL_FreeSurface(Screen);\r\n      Screen=NULL;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprintf(\"Failed to Set Videomode %dx%dx16\\n\",240, 240);\r\n\t\t}\r\n\r\n\t\tSDL_Quit();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tprintf(\"Couldn't initialise SDL!\\n\");\r\n\t}\r\n\treturn 0;\r\n}\r\n",
    "#include \"matrix.h\"\n#include \"test-helpers.h\"\n\n#include <gtest/gtest.h>\n\nnamespace {\n\nclass ctors_test : public ::testing::Test {\nprotected:\n  void SetUp() override {\n    element::reset_allocations();\n  }\n};\n\n} // namespace\n\nTEST_F(ctors_test, default_ctor) {\n  matrix<element> a;\n\n  expect_empty(a);\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, zeros_ctor) {\n  constexpr size_t ROWS = 40;\n  constexpr size_t COLS = 100;\n  constexpr size_t SIZE = ROWS * COLS;\n\n  matrix<element> a(ROWS, COLS);\n\n  EXPECT_EQ(ROWS, a.rows());\n  EXPECT_EQ(COLS, a.cols());\n  EXPECT_EQ(SIZE, a.size());\n  EXPECT_FALSE(a.empty());\n  EXPECT_NE(nullptr, a.data());\n\n  for (size_t i = 0; i < ROWS; ++i) {\n    for (size_t j = 0; j < COLS; ++j) {\n      EXPECT_EQ(0, a(i, j));\n    }\n  }\n\n  expect_allocations(SIZE);\n}\n\nTEST_F(ctors_test, zeros_ctor_empty) {\n  matrix<element> a(0, 0);\n\n  expect_empty(a);\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, zeros_ctor_weird) {\n  matrix<element> a(10, 0);\n  expect_empty(a);\n\n  matrix<element> b(0, 10);\n  expect_empty(b);\n\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, init_ctor) {\n  matrix<element> a({\n      {10, 20, 30},\n      {40, 50, 60},\n  });\n\n  EXPECT_EQ(2, a.rows());\n  EXPECT_EQ(3, a.cols());\n  EXPECT_EQ(6, a.size());\n  EXPECT_FALSE(a.empty());\n  EXPECT_NE(nullptr, a.data());\n\n  EXPECT_EQ(10, a(0, 0));\n  EXPECT_EQ(20, a(0, 1));\n  EXPECT_EQ(30, a(0, 2));\n  EXPECT_EQ(40, a(1, 0));\n  EXPECT_EQ(50, a(1, 1));\n  EXPECT_EQ(60, a(1, 2));\n\n  expect_allocations(6);\n}\n\nTEST_F(ctors_test, copy_ctor) {\n  constexpr size_t ROWS = 40;\n  constexpr size_t COLS = 100;\n  constexpr size_t SIZE = ROWS * COLS;\n\n  matrix<element> a(ROWS, COLS);\n\n  expect_allocations(SIZE);\n\n  fill(a);\n\n  expect_allocations(SIZE);\n\n  matrix<element> b = a;\n\n  expect_equal(a, b);\n\n  expect_allocations(SIZE * 2);\n}\n\nTEST_F(ctors_test, copy_ctor_empty) {\n  matrix<element> a;\n  matrix<element> b = a;\n\n  expect_empty(a);\n  expect_empty(b);\n\n  expect_allocations(0);\n}\n\nTEST_F(ctors_test, copy_assignment) {\n  constexpr size_t ROWS_A = 40;\n  constexpr size_t COLS_A = 100;\n  constexpr size_t SIZE_A = ROWS_A * COLS_A;\n\n  constexpr size_t ROWS_B = 15;\n  constexpr size_t COLS_B = 15;\n  constexpr size_t SIZE_B = ROWS_B * COLS_B;\n\n  matrix<element> b(ROWS_B, COLS_B);\n\n  {\n    matrix<element> a(ROWS_A, COLS_A);\n\n    expect_allocations(SIZE_A + SIZE_B);\n\n    fill(a);\n\n    expect_allocations(SIZE_A + SIZE_B);\n\n    b = a;\n\n    expect_equal(a, b);\n\n    expect_allocations(SIZE_A * 2 + SIZE_B);\n  }\n\n  for (size_t i = 0; i < ROWS_A; ++i) {\n    for (size_t j = 0; j < COLS_A; ++j) {\n      EXPECT_EQ(elem(i, j), b(i, j));\n    }\n  }\n}\n\nTEST_F(ctors_test, self_copy_assignment) {\n  constexpr size_t ROWS = 40;\n  constexpr size_t COLS = 100;\n  constexpr size_t SIZE = ROWS * COLS;\n\n  matrix<element> a(ROWS, COLS);\n\n  expect_allocations(SIZE);\n\n  fill(a);\n\n  expect_allocations(SIZE);\n\n  a = a;\n\n  expect_allocations(SIZE);\n\n  for (size_t i = 0; i < ROWS; ++i) {\n    for (size_t j = 0; j < COLS; ++j) {\n      EXPECT_EQ(elem(i, j), a(i, j));\n    }\n  }\n}\n\nTEST_F(ctors_test, copy_assignment_empty) {\n  constexpr size_t ROWS_B = 40;\n  constexpr size_t COLS_B = 100;\n  constexpr size_t SIZE_B = ROWS_B * COLS_B;\n\n  matrix<element> a;\n  matrix<element> b(ROWS_B, COLS_B);\n  b = a;\n\n  expect_empty(a);\n  expect_empty(b);\n\n  expect_allocations(SIZE_B);\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass MyCircularQueue\r\n{\r\npublic:\r\n    int *arr;\r\n    int n;\r\n    int front;\r\n    int rear;\r\n\r\n    // Queue : pop <-- front .......... rear <-- push\r\n    // Array : [ 0 | 1 | 2 ] 3 - 4 - 5- 6 - ...\r\n\r\n    MyCircularQueue(int k)\r\n    {\r\n        arr = new int[k];\r\n        n = k;\r\n        // rear and front will exceed array of arr\r\n        // but can refer index via modulo of size of array\r\n        // hence, circular\r\n\r\n        // if rear == front, here one element\r\n        // if front exceeds rear after popping, stack empty\r\n        // if their difference becomes size. stack full\r\n        // this way we can create a queue without wasting any space inside array\r\n\r\n        rear = -1;\r\n        front = 0;\r\n    }\r\n\r\n    bool enQueue(int value)\r\n    {\r\n        if (rear - front + 1 == n)\r\n            return false;\r\n        arr[(++rear) % n] = value;\r\n        return true;\r\n    }\r\n\r\n    bool deQueue()\r\n    {\r\n        if (rear + 1 == front)\r\n            return false;\r\n        front++;\r\n        return true;\r\n    }\r\n\r\n    int Front() { return (rear + 1 == front) ? -1 : arr[front % n]; }\r\n\r\n    int Rear() { return (rear + 1 == front) ? -1 : arr[rear % n]; }\r\n\r\n    bool isEmpty() { return rear + 1 == front; }\r\n\r\n    bool isFull() { return rear - front + 1 == n; }\r\n};\r\n\r\nint main()\r\n{\r\n    MyCircularQueue q(3);\r\n\r\n    cout << \"Empty: \" << q.isEmpty() << endl;\r\n\r\n    cout << q.enQueue(1) << endl;\r\n    cout << q.enQueue(2) << endl;\r\n    cout << q.enQueue(3) << endl;\r\n    cout << q.enQueue(4) << endl;\r\n\r\n    cout << \"Full: \" << q.isFull() << endl;\r\n    cout << \"Front: \" << q.Front() << endl;\r\n    cout << \"Rear: \" << q.Rear() << endl;\r\n\r\n    cout << q.deQueue() << endl;\r\n    cout << q.deQueue() << endl;\r\n    cout << q.enQueue(4) << endl;\r\n\r\n    cout << \"Full: \" << q.isFull() << endl;\r\n    cout << \"Front: \" << q.Front() << endl;\r\n    cout << \"Rear: \" << q.Rear() << endl;\r\n\r\n    return 0;\r\n}\r\n\r\n// https://leetcode.com/problems/design-circular-queue/\r\n",
    "#include \"JsonHandler.h\"\n#include <jsoncpp/json/json.h>\n#include <sstream>\n#include <iostream>\n\nstd::string JsonHandler::serializeToJson(const std::string& requestType, const std::string& username, const std::string& receiver, const std::string& message) {\n    Json::Value root;\n    root[\"requestType\"] = requestType;\n    root[\"username\"] = username;\n    root[\"receiver\"] = receiver;\n    root[\"message\"] = message;\n\n    Json::StreamWriterBuilder builder;\n    builder[\"indentation\"] = \"\";\n    std::ostringstream os;\n    Json::StreamWriter* writer = builder.newStreamWriter();\n    writer->write(root, &os);\n    delete writer;\n    return os.str();\n}\nstd::string JsonHandler::serializeToJson_v2(const std::string& requestType, const std::string& username, const std::string& receiver, const std::string& message) {\n    Json::Value root;\n    root[\"requestType\"] = requestType;\n    root[\"username\"] = username;\n    root[\"receiver\"] = receiver;\n    root[\"message\"] = message;\n\n    Json::StreamWriterBuilder builder;\n    builder[\"indentation\"] = \"\";\n    std::string jsonData = Json::writeString(builder, root);\n    return jsonData;\n    /*******************************/\n    // std::stringstream ss\n    // ss<<root;\n    // return ss.str();\n    /*******************************/\n}\n\nstd::tuple<std::string, std::string, std::string, std::string> JsonHandler::deserializeFromJson(const std::string& jsonString) {\n    std::string requestType, username, receiver, message;\n    Json::Value root;\n    Json::CharReaderBuilder builder;\n    std::istringstream is(jsonString);\n    std::string errs;\n    if (!Json::parseFromStream(builder, is, &root, &errs)) {\n        std::cerr << \"Error parsing JSON: \" << errs << std::endl;\n        return std::make_tuple(\"\", \"\", \"\", \"\");\n    }\n\n    if (root.isMember(\"requestType\") && root[\"requestType\"].isString())\n        requestType = root[\"requestType\"].asString();\n    if (root.isMember(\"username\") && root[\"username\"].isString())\n        username = root[\"username\"].asString();\n    if (root.isMember(\"receiver\") && root[\"receiver\"].isString())\n        receiver = root[\"receiver\"].asString();\n    if (root.isMember(\"message\") && root[\"message\"].isString())\n        message = root[\"message\"].asString();\n\n    return std::make_tuple(requestType, username, receiver, message);\n}\n\nstd::tuple<std::string, std::string, std::string, std::string> JsonHandler::deserializeFromJson_v2(const std::string& jsonString) {\n    std::string requestType, username, receiver, message;\n    Json::Value root;\n    Json ::Reader reader;\n    bool parsingSuccessful = reader.parse(jsonString, root);\n    if (!parsingSuccessful) {\n        std::cerr << \"Error parsing JSON: \"<< std::endl;\n        return std::make_tuple(\"\", \"\", \"\", \"\");\n    }\n\n    if (root.isMember(\"requestType\") && root[\"requestType\"].isString())\n        requestType = root[\"requestType\"].asString();\n    if (root.isMember(\"username\") && root[\"username\"].isString())\n        username = root[\"username\"].asString();\n    if (root.isMember(\"receiver\") && root[\"receiver\"].isString())\n        receiver = root[\"receiver\"].asString();\n    if (root.isMember(\"message\") && root[\"message\"].isString())\n        message = root[\"message\"].asString();\n\n    return std::make_tuple(requestType, username, receiver, message);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n    int pilihan;\n    float suhu;\n    float cF, fC, cK, kC, fK, kF;\n\n    cout << \"Masukkan suhu: \";\n    cin >> suhu;\n\n    cout << \"Pilih konversi suhu:\" << endl;\n    cout << \"1. Celsius ke Fahrenheit\" << endl;\n    cout << \"2. Fahrenheit ke Celsius\" << endl;\n    cout << \"3. Celsius ke Kelvin\" << endl;\n    cout << \"4. Kelvin ke Celsius\" << endl;\n    cout << \"5. Fahrenheit ke Kelvin\" << endl;\n    cout << \"6. Kelvin ke Fahrenheit\" << endl;\n    cout << \"Masukkan pilihan Anda (1-6): \";\n    cin >> pilihan;\n\n    switch(pilihan) {\n        case 1:\n            cF = (suhu * 9/5) + 32;\n            cout << \"Celcius ke Fahrenheit: \" << cF << \"\u00b0F\" << endl;\n            break;\n        case 2:\n            fC = (suhu - 32) * 5/9;\n            cout << \"Fahrenheit ke Celcius: \" << fC << \"\u00b0C\" << endl;\n            break;\n        case 3:\n            cK = suhu + 273.15;\n            cout << \"Celcius ke Kelvin: \" << cK << \"\u00b0K\" << endl;\n            break;\n        case 4:\n            kC = suhu - 273.15;\n            cout << \"Kelvin ke Celcius: \" << kC << \"\u00b0C\" << endl;\n            break;\n        case 5:\n            fK = (suhu - 32) * 5/9 + 273.15;\n            cout << \"Fahrenheit ke Kelvin: \" << fK << \"\u00b0K\" << endl;\n            break;\n        case 6:\n            kF = (suhu + 273.15) * 9/5 + 32;\n            cout << \"Kelvin ke Fahrenheit: \" << kF << \"\u00b0F\" << endl;\n            break;\n        default:\n            cout << \"Pilihan tidak valid\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"change_my_mood_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <regex>\n#include <vector>\n\nusing namespace std;\n\n// Token structure\nstruct Token {\n    string type;\n    string lexeme;\n    int line;\n};\n\nvector<Token> tokenize(const string& code) {\n    vector<Token> tokens;\n    // Define regular expressions for tokens\n    string reservedword = \"\\\\b(int|float|void|cin|cout|continue|break|#include|using|namespace|std|main|if|else|while|for|return)\\\\b\";\n    string identifier = \"\\\\b[a-zA-Z][a-zA-Z0-9]*\\\\b\";\n    string digit = \"\\\\b[0-9]\\\\b\";\n    string number = \"\\\\b[0-9]+(?:\\\\.[0-9]+)?\\\\b\";\n    string stringsPattern = R\"(\".*?\")\";\n    string symbol = \"\\\\b[(|)|{|}|\\\\[|\\\\]|,|;|+|-|*|/|==|!=|>|>=|<|<=|=|&&|\\\\|\\\\||<<|>>]\\\\b\";\n    string whitespacePattern = \"\\\\s+\";\n\n    // Combine regular expressions into one\n    string tokenRegexStr = \"(\" + reservedword + \"|\" + identifier + \"|\" + digit + \"|\" + number + \"|\" + stringsPattern + \"|\" + symbol + \"|\" + whitespacePattern + \")\";\n    regex tokenRegex(tokenRegexStr);\n\n    // Tokenization process\n    smatch match;\n    int lineNumber = 1;\n    string::const_iterator start = code.begin();\n    string::const_iterator end = code.end();\n    while (regex_search(start, end, match, tokenRegex)) {\n        if (!regex_match(match[0].str(), regex(whitespacePattern))) {\n            Token token;\n            token.lexeme = match[0];\n            token.line = lineNumber;\n            // Determine token type\n            if (regex_match(token.lexeme, regex(reservedword)))\n                token.type = \"Reservedword\";\n            else if (regex_match(token.lexeme, regex(identifier)))\n                token.type = \"Identifier\";\n            else if (regex_match(token.lexeme, regex(digit)))\n                token.type = \"Digit\";\n            else if (regex_match(token.lexeme, regex(number)))\n                token.type = \"Number\";\n            else if (regex_match(token.lexeme, regex(stringsPattern)))\n                token.type = \"String\";\n            else if (regex_match(token.lexeme, regex(symbol)))\n                token.type = \"Symbol\";\n            tokens.push_back(token);\n        }\n\n        start = match.suffix().first;\n        // Count lines\n        while (start != end && (*start == '\\n' || *start == '\\r')) {\n            if (*start == '\\n') lineNumber++;\n            ++start;\n        }\n    }\n    return tokens;\n}\n\nint main() {\n    string code = R\"(\n        #include <iostream>\n        using namespace std;\n        int main(){\n          int x;\n          int s=0, t=10;\n          while (t >= 0){\n           cin>>x;\n           t = t - 1;\n           s = s + x;\n        }\n        cout<<\"sum=\"<<s;\n        return 0;\n    }\n    )\";\n    vector<Token> tokens = tokenize(code);\n    for (const auto& token : tokens) {\n        cout << \"Type: \" << token.type << \", Lexeme: \" << token.lexeme << \", Line: \" << token.line << endl;\n    }\n    return 0;\n}",
    "#include \"SHA-3.h\"\n\nSHA_3::SHA_3(const SHA_3_Length sha_length) {\n\tswitch (sha_length) {\n\tcase SHA_3_Length::SHA_224:\n\t\tr = 1152;\n\t\tc = 448;\n\t\toutput_size = 224;\n\t\tbreak;\n\tcase SHA_3_Length::SHA_256:\n\t\tr = 1088;\n\t\tc = 512;\n\t\toutput_size = 256;\n\t\tbreak;\n\tcase SHA_3_Length::SHA_384:\n\t\tr = 832;\n\t\tc = 768;\n\t\toutput_size = 384;\n\t\tbreak;\n\tcase SHA_3_Length::SHA_512:\n\t\tr = 576;\n\t\tc = 1024;\n\t\toutput_size = 512;\n\t\tbreak;\n\t}\n}\n\nstd::vector<uint8_t> SHA_3::hashing(const std::vector<uint8_t>& message) {\n\t//Initialization and Padding\n\tuint64_t state[25] = { 0 };\n\tint block_size = r / 8;\n\n\tstd::vector<uint8_t> padded_message = message;\n\tpadding(padded_message, block_size);\n\tstd::vector<uint8_t> block;\n\n\t//Absorbing\n\tfor (size_t i = 0; i < padded_message.size(); i += block_size) {\n\t\tblock = pop_front_block(padded_message, block_size);\n\t\txor_vectors(state, block);\n\t\tkeccak(state);\n\t}\n\n\t//Squeezing\n\treturn get_hash(state);\n}\n\nvoid SHA_3::keccak(uint64_t* state) {\n\tfor (size_t round = 0; round < 24; round++) {\n\t\tkeccak_theta(state);\n\n\t\t/*std::cout << \"State theta:\";\n\t\tfor (int i = 0; i < 25; i++) {\n\t\t\tstd::cout << std::hex << static_cast<int>(state[i]) << \" \";\n\t\t}\n\t\tstd::cout << std::endl << std::endl;*/\n\n\t\tkeccak_ro(state);\n\n\t\t/*std::cout << \"State ro:\";\n\t\tfor (int i = 0; i < 25; i++) {\n\t\t\tstd::cout << std::hex << static_cast<int>(state[i]) << \" \";\n\t\t}\n\t\tstd::cout << std::endl << std::endl;*/\n\n\t\tkeccak_pi(state);\n\n\t\t/*std::cout << \"State pi:\";\n\t\tfor (int i = 0; i < 25; i++) {\n\t\t\tstd::cout << std::hex << static_cast<int>(state[i]) << \" \";\n\t\t}\n\t\tstd::cout << std::endl << std::endl;*/\n\n\t\tkeccak_chi(state);\n\n\t\t/*std::cout << \"State chi:\";\n\t\tfor (int i = 0; i < 25; i++) {\n\t\t\tstd::cout << std::hex << static_cast<int>(state[i]) << \" \";\n\t\t}\n\t\tstd::cout << std::endl << std::endl;*/\n\n\t\tkeccak_yot(state, round);\n\n\t\t/*std::cout << \"State yot:\";\n\t\tfor (int i = 0; i < 25; i++) {\n\t\t\tstd::cout << std::hex << static_cast<int>(state[i]) << \" \";\n\t\t}\n\t\tstd::cout << std::endl << std::endl;*/\n\t}\n}\n\nvoid SHA_3::padding(std::vector<uint8_t>& message, int block_size) {\n\t/*updated:*/\n\tif (message.size() != 0 && message.size() % block_size == 0)\n\t\treturn;\n\n\tif (message.size() % block_size == 1) {\n\t\tmessage.push_back(0x86);\n\t\treturn;\n\t}\n\t/*--------*/\n\n\tmessage.push_back(0x06);\n\n\twhile ((message.size() + 1) % block_size != 0)\n\t\tmessage.push_back(0x00);\n\n\tmessage.push_back(0x80);\n}\n\n/*updated:*/\nvoid SHA_3::xor_vectors(uint64_t* state64, std::vector<uint8_t>& vec8) {\n\tsize_t vec64_size = 25;\n\tsize_t vec8_size = vec8.size();\n\n\tfor (int i = 0; i < vec64_size && i * sizeof(uint64_t) < vec8_size; i++) {\n\t\tuint64_t buffer = 0;\n\t\tfor (int j = 0; j < sizeof(uint64_t) && i * sizeof(uint64_t) + j < vec8_size; j++)\n\t\t\tbuffer |= (uint64_t)vec8[i * sizeof(uint64_t) + j] << (j * 8);\n\t\tstate64[i] ^= buffer;\n\t}\n}\n/*--------*/\n\nstd::vector<uint8_t> SHA_3::pop_front_block(std::vector<uint8_t>& vector, int& block_size) {\n\tstd::vector<uint8_t> block;\n\tfor (size_t i = 0; i < block_size; i++)\n\t\tblock.push_back(vector[i]);\n\tvector.erase(vector.begin(), vector.begin() + block_size);\n\t\n\t/*updated:*/\n\twhile (block.size() < 25)\n\t\tblock.push_back(0x00);\n\t/*--------*/\n\n\treturn block;\n}\n\nvoid SHA_3::keccak_theta(uint64_t* A) {\n\tuint64_t C[5], D[5];\n\n\tfor (size_t i = 0; i < 5; i++)\n\t\tC[i] = A[i] ^ A[i + 5] ^ A[i + 10] ^ A[i + 15] ^ A[i + 20];\n\n\tD[0] = left_rotate(C[1], 1) ^ C[4];\n\tD[1] = left_rotate(C[2], 1) ^ C[0];\n\tD[2] = left_rotate(C[3], 1) ^ C[1];\n\tD[3] = left_rotate(C[4], 1) ^ C[2];\n\tD[4] = left_rotate(C[0], 1) ^ C[3];\n\n\tfor (size_t i = 0; i < 5; i++) {\n\t\tA[i] ^= D[i];\n\t\tA[i + 5] ^= D[i];\n\t\tA[i + 10] ^= D[i];\n\t\tA[i + 15] ^= D[i];\n\t\tA[i + 20] ^= D[i];\n\t}\n}\n\nvoid SHA_3::keccak_ro(uint64_t* A) {\n\tfor (size_t i = 1; i < 25; i++)\n\t\tA[i] = left_rotate(A[i], rot_offset[i]);\n}\n\nvoid SHA_3::keccak_pi(uint64_t* A) {\n\tuint64_t A1 = A[1];\n\tA[1] = A[6], A[6] = A[9], A[9] = A[22], A[22] = A[14],\n\tA[14] = A[20], A[20] = A[2], A[2] = A[12], A[12] = A[13],\n\tA[13] = A[19], A[19] = A[23], A[23] = A[15], A[15] = A[4],\n\tA[4] = A[24], A[24] = A[21], A[21] = A[8], A[8] = A[16],\n\tA[16] = A[5], A[5] = A[3], A[3] = A[18], A[18] = A[17],\n\tA[17] = A[11], A[11] = A[7], A[7] = A[10], A[10] = A1;\n}\n\nvoid SHA_3::keccak_chi(uint64_t* A) {\n\tfor (size_t i = 0; i < 25; i += 5) {\n\t\tuint64_t A0 = A[0 + i], A1 = A[1 + i];\n\t\tA[0 + i] ^= ~A1 & A[2 + i];\n\t\tA[1 + i] ^= ~A[2 + i] & A[3 + i];\n\t\tA[2 + i] ^= ~A[3 + i] & A[4 + i];\n\t\tA[3 + i] ^= ~A[4 + i] & A0;\n\t\tA[4 + i] ^= ~A0 & A1;\n\t}\n}\n\nvoid SHA_3::keccak_yot(uint64_t* A, size_t& round) {\n\tA[0] ^= round_constants[round];\n}\n\n/*updated:*/\nstd::vector<uint8_t> SHA_3::get_hash(uint64_t* state) {\n\tstd::vector<uint8_t> hash;\n\tfor (size_t i = 0; i < (c / 2) / 64; i++) {\n\t\tconst uint8_t* bytes = reinterpret_cast<const uint8_t*>(&state[i]);\n\t\tfor (int j = 0; j < sizeof(uint64_t); j++)\n\t\t\thash.push_back(bytes[j]);\n\t}\n\treturn hash;\n}\n/*--------*/",
    "/*\n * Copyright (C) 2024 Dirk Sarodnick\n * All rights reserved.\n */\n#include \"ircRelay.h\"\n\n#include \"bzfsAPI.h\"\n#include \"plugin_utils.h\"\n\n#include <regex>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#if defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)\n#include <io.h>\n#include <windows.h>\nDWORD WINAPI WorkerThread(LPVOID lpParameter) { ircRelay::Worker(); };\n#else\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <unistd.h>\nvoid* WorkerThread(void* t) { ircRelay::Worker(); }\n#endif\n\nBZ_PLUGIN(ircRelay)\n\nconst char* ircRelay::Name() {\n    return \"IRC Relay\";\n}\n\nvoid ircRelay::Init(const char* config) {\n    bz_debugMessage(2, \"Initializing ircRelay custom plugin\");\n\n    // register events\n    Register(bz_eBZDBChange);\n    Register(bz_eRawChatMessageEvent);\n    Register(bz_ePlayerJoinEvent);\n    Register(bz_ePlayerPartEvent);\n\n    // register config\n    bz_registerCustomBZDBString(\"_ircAddress\", \"\", 0, false);\n    bz_registerCustomBZDBString(\"_ircChannel\", \"\", 0, false);\n    bz_registerCustomBZDBString(\"_ircNick\", \"\", 0, false);\n    bz_registerCustomBZDBString(\"_ircPass\", \"\", 0, false);\n    bz_registerCustomBZDBString(\"_ircAuthType\", \"\", 0, false);\n    bz_registerCustomBZDBString(\"_ircAuthPass\", \"\", 0, false);\n    bz_registerCustomBZDBString(\"_ircIgnore\", \"\", 0, false);\n\n#if defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)\n    DWORD thread;\n    CreateThread(0, 0, WorkerThread, NULL, 0, &thread);\n#else\n    pthread_t thread;\n    pthread_create(&thread, NULL, WorkerThread, NULL);\n#endif\n\n    bz_debugMessage(2, \"Initialized ircRelay custom plugin\");\n}\n\nvoid ircRelay::Start() {\n    bz_debugMessage(2, \"Starting ircRelay custom plugin\");\n\n    // get config\n    std::string ircAddress;\n    std::string ircChannel;\n    std::string ircNick;\n    std::string ircPass;\n    std::string ircAuthType;\n    std::string ircAuthPass;\n    if (bz_BZDBItemExists(\"_ircAddress\")) ircAddress = bz_getBZDBString(\"_ircAddress\"); else { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because _ircAddress does not exist\"); return; }\n    if (bz_BZDBItemExists(\"_ircChannel\")) ircChannel = bz_getBZDBString(\"_ircChannel\"); else { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because _ircChannel does not exist\"); return; }\n    if (bz_BZDBItemExists(\"_ircNick\")) ircNick = bz_getBZDBString(\"_ircNick\"); else { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because _ircNick does not exist\"); return; }\n    if (bz_BZDBItemExists(\"_ircPass\")) ircPass = bz_getBZDBString(\"_ircPass\"); else ircPass = \"\";\n    if (bz_BZDBItemExists(\"_ircAuthType\")) ircAuthType = bz_getBZDBString(\"_ircAuthType\"); else ircAuthType = \"\";\n    if (bz_BZDBItemExists(\"_ircAuthPass\")) ircAuthPass = bz_getBZDBString(\"_ircAuthPass\"); else ircAuthPass = \"\";\n    if (ircAddress == \"\") { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because address is still empty\"); return; }\n    if (ircChannel == \"\") { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because channel is still empty\"); return; }\n    if (ircNick == \"\") { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because nick is still empty\"); return; }\n    if (fd != 0) { bz_debugMessage(2, \"Starting ircRelay custom plugin skipped, because its already running\"); return; }\n\n    // prepare socket\n    fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (fd == 0) {\n        std::string debugMessage = \"Connection to irc server \" + ircAddress + \" failed, because creating the socket failed\";\n        bz_debugMessage(1, debugMessage.c_str());\n        return;\n    }\n\n    // prepare connection\n    struct sockaddr_in dest_addr;\n    memset(&dest_addr, 0, sizeof(dest_addr));\n    dest_addr.sin_family = AF_INET;\n    dest_addr.sin_port = htons(6667);\n\n    if (std::regex_match(ircAddress, rgx)) {\n        bz_debugMessage(2, \"Given irc server address looks like an IP\");\n        dest_addr.sin_addr.s_addr = inet_addr(ircAddress.c_str());\n    }\n    else {\n        bz_debugMessage(2, \"Given irc server address looks like a Hostname\");\n        struct hostent* dest_host = gethostbyname(ircAddress.c_str());\n        if (!dest_host) {\n            std::string debugMessage = \"Could not resolve irc server \" + ircAddress;\n            bz_debugMessage(1, debugMessage.c_str());\n            fd = 0;\n            return;\n        }\n        dest_addr.sin_addr = *((struct in_addr*)dest_host->h_addr);\n    }\n    memset(&(dest_addr.sin_zero), '\\0', 8);\n\n    // connect to server\n    std::string debugMessage = \"Connecting to irc server \" + ircAddress;\n    bz_debugMessage(1, debugMessage.c_str());\n    if (connect(fd, (struct sockaddr*)&dest_addr, sizeof(struct sockaddr)) < 0) {\n        std::string debugMessage = \"Connection to irc server \" + ircAddress + \" failed\";\n        bz_debugMessage(1, debugMessage.c_str());\n        fd = 0;\n        return;\n    }\n    Wait(0, 10);\n\n    // receive some",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_template\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// #include<iostream>\n// using namespace std;\n\n// class Node{\n//     public:\n//     int data;\n//     Node* next;\n\n//     //contructor\n//     Node(int data){\n//         this->data=data;\n//         this->next=NULL;\n//         }\n\n//     //destructor\n//     ~Node(){\n//         int value=this->data;\n\n//         //memory is freed\n//         if(this->next!=NULL){\n//             delete next;\n//             this->next=NULL;\n//         }\n\n//         cout<<\"Memory is free for Node deleted -> \"<<value<<endl;\n//     }\n\n// };\n\n// void insertAtHead(Node* &head, int d){\n\n//     Node* temp=new Node(d);\n//     temp->next=head;\n//     head=temp;\n// }\n\n// void insertAtTail(Node* &tail, int d){\n\n//     Node* temp=new Node(d);\n//     tail->next=temp;\n//     tail=tail->next;\n// }\n\n// void insertAtPosition(Node* &head, Node* &tail, int position, int d){\n\n//     if(position<=0){\n//         cout<<\"Not a valid position, So insertion took place\"<<endl;\n//         return;\n//     }\n\n//     if(position==1){\n//         insertAtHead(head,d);\n//         return;\n//     }\n\n//     Node* temp=head;\n//     int cnt=1;\n\n//     while(cnt<position-1){\n//         temp=temp->next;\n//         cnt++;\n//     }\n\n//     if(temp->next==NULL){\n//         insertAtTail(tail,d);\n//         return;\n//     }\n\n//     Node* nodeToInsert=new Node(d);\n//     nodeToInsert->next=temp->next;\n//     temp->next=nodeToInsert;\n\n\n// }\n\n// void deleteNode(Node* &head,Node* &tail, int position){\n//     //deleteing first node\n//     if(position==1){\n//         Node* temp=head;\n//         head=head->next;\n//         temp->next=NULL;\n//         delete temp;\n//     }\n//     //delete any midlle node or last node\n//     else{\n\n//         Node* curr=head;\n//         Node* prev=NULL;\n\n//         int cnt=1;\n//         while(cnt<position){\n//             prev=curr;\n//             curr=curr->next;\n//             cnt++;\n//         }\n\n\n//         prev->next=curr->next;\n//         curr->next=NULL;\n//         delete curr;\n//         tail=prev;\n//     }\n// }\n\n// //Get middle element in node 1st way\n// Node* getMiddle(Node* head){\n//     if(head==NULL || head->next==NULL)\n//         return head;\n\n//     //2 nodes\n//     if(head -> next -> next == NULL){\n//         return head -> next;\n//     }\n//     Node* fast=head->next;\n//     Node* slow=head;\n\n//     while(fast!=NULL){\n//         fast=fast->next;\n//         if(fast!=NULL){\n//             fast=fast->next;\n//         }\n//         slow=slow->next;\n//     }\n//     return slow;\n// }\n\n// //Get Length of linkedlist\n// int getLen(Node* head){\n    \n//     int len=0;\n//     while(head!=NULL){\n//         head=head->next;\n//         len++;\n//     }\n//     return len;\n// }\n\n// void getLength(Node* head){\n\n//     Node* temp=head;\n//     int len=0;\n\n//     while(temp!=NULL){\n//         len++;\n//         temp=temp->next;\n//     }\n//     cout<<len<<endl;;\n\n// }\n\n// Node* findMiddle(Node* head){\n//     int len=getLen(head);\n//     int ans=(len/2);\n\n//     Node* temp=head;\n//     int cnt=0;\n//     while(cnt<ans){\n//         temp=temp->next;\n//         cnt++;\n//     }\n//     return temp;\n// }\n\n// void print(Node* &head){\n    \n//     Node* temp=head;\n//     while(temp!=NULL){\n//         cout<<temp->data<<\" \";\n//         temp=temp->next;\n//     }\n//     cout<<endl;\n// }\n\n// int main()\n// {\n\n//     Node* node1=new Node(10);\n//     // cout<<node1 -> data<<endl;\n//     // cout<<node1 -> next<<endl;\n\n//     Node* head=node1;\n//     Node* tail=node1;\n\n//     print(head);\n\n//     insertAtHead(head,12);\n//     insertAtHead(head,35);\n//     insertAtTail(tail,15);\n//     insertAtTail(tail,22);\n\n//     // insertAtPosition(head,tail,0,16);\n\n\n//     print(head);\n\n//     cout<<\"Head -> \"<<head->data<<endl;\n//     cout<<\"Tail -> \"<<tail->data<<endl;\n\n//     deleteNode(head,tail,1);\n//     print(head);\n//     cout<<\"Head -> \"<<head->data<<endl;\n//     cout<<\"Tail -> \"<<tail->data<<endl;\n\n//     insertAtPosition(head,tail,5,16);\n//     print(head);\n\n//     cout<<\"Head -> \"<<head->data<<endl;\n//     cout<<\"Tail -> \"<<tail->data<<endl;\n\n\n//     // Node* temp=getMiddle(head);\n\n//     // if(temp!=NULL){\n//     //     cout<<\"Middle Element: \"<<temp->data<<endl;\n//     // }\n//     // else{\n//     //     cout<<\"The list is empty, so there is no middle element.\"<<endl;\n//     // }\n\n//     // cout<<temp->data<<endl;\n\n//     // cout<<getMiddle(head)->data;\n\n\n//     return 0;\n// }\n\n\n\n#include<iostream>\nusing namespace std;\n\nclass Node{\n    public:\n    int data;\n    Node* next;\n\n    //contructor\n    Node(int data){\n        this->data=data;\n        this->next=NULL;\n        }\n\n    //destructor\n    ~Node(){\n        int value=this->data;\n\n        //memory is freed\n        if(this->next!=NULL){\n            delete next;\n            this->next=NULL;\n        }\n\n        cout<<\"Memory is free for Node deleted -> \"<<value<<endl;\n    }\n\n};\n\nvoid insertAtHead(Node* &head, int d){\n\n    Node* temp=new Node(d);\n    temp->next=head;\n    head=temp;\n}\n\nvoid insertAtTail(Node* &tail, int d){\n\n    Node* temp=",
    "// dear imgui, v1.85 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#if !defined(alloca)\n#if defined(__GLIBC__) || defined(__sun) || defined(__APPLE__) || defined(__NEWLIB__)\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\n#elif defined(_WIN32)\n#include <malloc.h>     // alloca\n#if !defined(alloca)\n#define alloca _alloca  // for clang with MS Codegen\n#endif\n#else\n#include <stdlib.h>     // alloca\n#endif\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 6255)     // [Static Analyzer] _alloca indicates failure by raising a stack overflow exception.  Consider using _malloca instead.\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#if __has_warning(\"-Walloca\")\n#pragma clang diagnostic ignored \"-Walloca\"                         // warning: use of function '__builtin_alloca' is discouraged\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // w",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nint FIFO(int pages[], int n, int capacity){\n    unordered_map<int, int> pageMap;\n    queue<int> pageQueue;\n\n    int faults = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (pageMap.find(pages[i]) == pageMap.end())\n        {\n            faults++;\n            if (pageQueue.size() == capacity)\n            {\n                int front = pageQueue.front();\n                pageQueue.pop();\n                pageMap.erase(front);\n            }\n            pageQueue.push(pages[i]);\n            pageMap[pages[i]] = 1;\n        }\n    }\n    return faults;\n}\n\nint LRU(int pages[], int n, int capacity)\n{\n    list<int> lru;\n    unordered_map<int, list<int>::iterator> pageMap;\n\n    int faults = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (pageMap.find(pages[i]) == pageMap.end())\n        {\n            faults++;\n            if (lru.size() == capacity)\n            {\n                int leastUsed = lru.back();\n                lru.pop_back();\n                pageMap.erase(leastUsed);\n            }\n            lru.push_front(pages[i]);\n            pageMap[pages[i]] = lru.begin();\n        }\n        else\n        {\n            lru.erase(pageMap[pages[i]]);\n            lru.push_front(pages[i]);\n            pageMap[pages[i]] = lru.begin();\n        }\n    }\n    return faults;\n}\n\n\nint Optimal(int pages[], int n, int capacity){\n    vector<int> pageVector(capacity, -1);\n    map<int , int> pageMap;\n     int faults = 0; \n    for(int i=0 ; i<n ; i++){\n        if(pageMap.find(pages[i]) == pageMap.end()){\n            faults++;\n            if(pageMap.size() == capacity){\n                int farthestIndex = -1 , index = 0;\n                for(int j=0 ; j< capacity ; j++){\n                    int fartherst = -1;\n                    for(int k= i+1 ; k< n ; k++){\n                        if(pages[k] == pageVector[j]){\n                            fartherst = k;\n                            break;\n                        }\n                    }\n                    if(fartherst == -1){\n                        index = j;\n                        break;\n                    }\n                    else if(fartherst > farthestIndex){\n                        farthestIndex = fartherst;\n                        index = j;\n                    }\n                }\n\n                pageMap.erase(pageVector[index]);\n                pageVector[index] = pages[i];\n\n            }\n            else{\n                for(int j=0 ; j<capacity ; j++){\n                    if(pageVector[j] == -1){\n                        pageVector[j] = pages[i];\n                        break;\n                    }\n                }\n            }\n            pageMap[pages[i]] = i;\n\n        }\n    }\n    return faults;\n}\nint main()\n{\n    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2,1,2,0,1,7,0,1};\n    int n = sizeof(pages) / sizeof(pages[0]);\n    int capacity = 4;\n\n    cout << \"Total page faults using FIFO: \" << FIFO(pages, n, capacity) << endl;\n    cout << \"Total page faults using LRU: \" << LRU(pages, n, capacity) << endl;\n    cout<<\"Total page faults using Optimal: \"<<Optimal(pages, n, capacity)<<endl;\n    return 0;\n}\n",
    "#include \"/opt/homebrew/Cellar/freeglut/3.4.0/include/GL/glut.h\"\n#include \"/opt/homebrew/Cellar/glfw/3.4/include/GLFW/glfw3.h\"\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT);\n\n  //house\n    glBegin(GL_QUADS); \n    glColor3f(1.0, 0.0, 0.0); \n    glVertex2f(-0.5f, -0.5f); //lb\n    glVertex2f(0.5f, -0.5f);  //rb\n    glVertex2f(0.5f, 0.0f);   //rt\n    glVertex2f(-0.5f, 0.0f);  //lt\n    glEnd();\n\n  //roof\n    glBegin(GL_TRIANGLES); \n    glColor3f(0.0, 0.0, 0.0); \n    glVertex2f(-0.5f, 0.0f);  \n    glVertex2f(0.5f, 0.0f);   \n    glVertex2f(0.0f, 0.5f);   \n    glEnd();\n\n\n  //door\n   glBegin(GL_QUADS);\n    glColor3f(0.0, 1.0, 0.0);\n    glVertex2f(-0.1f, -0.5f); //lb\n    glVertex2f(0.1f, -0.5f); //rb\n    glVertex2f(0.1f, -0.2f); //rt\n    glVertex2f(-0.1f, -0.2f); //lt\n    glEnd();\n\n    glFlush(); \n}\n\nvoid init() {\n    glClearColor(1.0, 1.0, 1.0, 1.0);\n    glColor3f(0.0, 0.0, 0.0);    \n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowSize(500, 500);\n    glutInitWindowPosition(100, 100); \n    glutCreateWindow(\"Simple 2D House in OpenGL\");\n    init();\n    glutDisplayFunc(display);\n    glutMainLoop();\n    return 0;\n}",
    "// Created by Antonio \"Antoniowski\" Romano\n\n/*\\\n    Class used to abstract the database and its logics.\n    Every operation to do on the database will be filtered by the database class.\n*/\n\n\n#include \"database.h\"\n\nDatabase* Database::_instance = nullptr;\n\nDatabase::Database()\n{\n}\n\n/**\n * Cannot create a database object. A new database class can be only be created\n * by using the getInstance method.\n * \n */\n\nDatabase::Database(const Database& database) = delete;\n\nDatabase::~Database()\n{\n\n}\n\n\nDatabase* Database::getInstance()\n{\n    if(_instance == nullptr)\n        _instance = new Database();\n\n    return _instance;\n}\n\nbool Database::connect()\n{\n    //Connect to the local database\n    int rc;\n    rc = sqlite3_open(\"./localdata.db\", &sqlite_db);\n    if(rc)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nbool Database::disconnect()\n{\n    //Disconnect from the database\n\n    if(sqlite3_close(sqlite_db))\n        return true;\n\n    return false;\n    \n}\n\nvoid Database::drop_table()\n{\n    //Delete all tables in database.\n\n    connect();\n    std::string query_basis = \"DROP TABLE IF EXISTS \";\n    std::vector<std::string> tables = {\"LOGIN\", \"PASSWORDS\", \"PATH\"};\n    for(std::string t: tables)\n    {\n        sqlite3_exec(sqlite_db, (query_basis+t+\";\").c_str(), NULL, NULL, NULL);\n    }\n    disconnect();\n\n}\n\nvoid Database::create_tables()\n{\n    connect();    \n    sqlite3_exec(sqlite_db, LOGIN_CREATE_SCHEMA.c_str(), NULL, NULL, NULL);\n    sqlite3_exec(sqlite_db, PATH_CREATE_SCHEMA.c_str(), NULL, NULL, NULL);\n    sqlite3_exec(sqlite_db, PASSWORDS_CREATE_SCHEMA.c_str(), NULL, NULL, NULL);\n    disconnect();\n}\n\nvoid Database::first_init()\n{\n    drop_table();\n    create_tables();\n}\n\nvoid Database::init()\n{\n    connect();\n    \n    disconnect();\n}\n\nbool Database::insert(std::string table, std::vector<std::string> colums, std::vector<std::string> values)\n{\n    if(colums.size() > values.size())\n        return false;\n    \n    connect();\n    \n    std::string query_basis_1 = \"INSERT INTO \";\n    std::string query_basis_2 = \") VALUES(\";\n    std::string query_basis_3 = \");\";\n    std::string colums_string = \"\";\n    std::string values_string = \"\";\n    \n    for(int i=0; i<colums.size(); i++)\n    {\n        colums_string += colums.at(i);\n        values_string += \"'\"+values.at(i)+\"'\";\n        if(i != colums.size()-1)\n        {            \n            colums_string += \", \";\n            values_string += \", \";\n            continue;\n        }\n    }\n    std::string query = query_basis_1+table+\"(\"+colums_string+query_basis_2+values_string+query_basis_3;\n    sqlite3_exec(sqlite_db, query.c_str(), NULL,NULL,NULL);\n\n    disconnect();\n    return true;\n}\n\nstd::string Database::get_value(std::string column, std::string table, std::string where_condition)\n{\n    std::string query_1 = \"SELECT \";\n    std::string queey_2 = \" FROM \";\n    std::string query_3 = \" WHERE \";\n    std::string query;\n    if(where_condition != \"\")\n    {\n        query = query_1 + column + queey_2 + table + query_3 + where_condition + \";\";\n    }else{\n        query = query_1 + column + queey_2 + table + \";\";\n    }\n\n    connect();\n    sqlite3_stmt* statement;\n    const void* result;\n    int rc = sqlite3_prepare_v2(sqlite_db, query.c_str(),query.length(),&statement, nullptr);\n    if(rc != SQLITE_OK)\n    {\n        disconnect();\n        return \"Error\\n\";\n    }\n\n    std::string x = \"\";\n    while ((rc = sqlite3_step(statement)) == SQLITE_ROW)\n    {\n        result = sqlite3_column_text(statement, 0);\n        std::string string_result(static_cast<char const *>(result));\n        x = string_result;\n    }\n    sqlite3_finalize(statement);\n    disconnect();\n    return x;\n}\n\nstd::vector<std::tuple<std::string, std::string,std::string>> Database::get_password_rows(std::string service_name)\n{\n    /**\n     * Returns a password row with service, password and last update date.\n     * If service_name is \"\" (empty) returns all the password rows.\n     * \n     * \n     * If there is an aerroe with the query statement return a vector with only one tuple. The error tuple\n     * contains only ERROR as values.\n    */\n    std::string query_1 = \"SELECT * FROM PASSWORDS\";\n    std::string query_2 = \" WHERE SERVICE = \";\n    std::string query_end= \";\";\n    std::string query = \"\";\n    if(service_name != \"\")\n    {\n        query = query_1 + query_2 + \"'\"+service_name+\"'\"+query_end;\n    }else{\n        query = query_1 + query_end;\n    }\n\n    connect();\n    sqlite3_stmt* statement;\n    int rc = sqlite3_prepare_v2(sqlite_db, query.c_str(),query.length(),&statement, nullptr);\n    if(rc != SQLITE_OK)\n    {\n        disconnect();\n        std::tuple<std::string, std::string, std::string> error_tuple = std::make_tuple(\"ERROR\", \"ERROR\", \"ERROR\");\n        std::vector<std::tuple<std::string, std::string, std::string>> error_vector = {error_tuple};\n        return error_vector;\n    }\n\n    const void* result;\n    std::string username = \"\";\n    std::string password = \"\";\n    std::string last_update = \"\";\n    std::tuple<std::string,std::stri",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "/****************************************************************************\r\n** Meta object code from reading C++ file 'Calculator.h'\r\n**\r\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.1)\r\n**\r\n** WARNING! All changes made in this file will be lost!\r\n*****************************************************************************/\r\n\r\n#include \"../../calculator/Calculator.h\"\r\n#include <QtCore/qmetatype.h>\r\n\r\n#if __has_include(<QtCore/qtmochelpers.h>)\r\n#include <QtCore/qtmochelpers.h>\r\n#else\r\nQT_BEGIN_MOC_NAMESPACE\r\n#endif\r\n\r\n\r\n#include <memory>\r\n\r\n#if !defined(Q_MOC_OUTPUT_REVISION)\r\n#error \"The header file 'Calculator.h' doesn't include <QObject>.\"\r\n#elif Q_MOC_OUTPUT_REVISION != 68\r\n#error \"This file was generated using the moc from 6.6.1. It\"\r\n#error \"cannot be used with the include files from this version of Qt.\"\r\n#error \"(The moc has changed too much.)\"\r\n#endif\r\n\r\n#ifndef Q_CONSTINIT\r\n#define Q_CONSTINIT\r\n#endif\r\n\r\nQT_WARNING_PUSH\r\nQT_WARNING_DISABLE_DEPRECATED\r\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\r\nnamespace {\r\n\r\n#ifdef QT_MOC_HAS_STRINGDATA\r\nstruct qt_meta_stringdata_CLASSCalculatorENDCLASS_t {};\r\nstatic constexpr auto qt_meta_stringdata_CLASSCalculatorENDCLASS = QtMocHelpers::stringData(\r\n    \"Calculator\",\r\n    \"on_pushButton9_clicked\",\r\n    \"\",\r\n    \"on_pushButton8_clicked\",\r\n    \"on_pushButton7_clicked\",\r\n    \"on_pushButton6_clicked\",\r\n    \"on_pushButton5_clicked\",\r\n    \"on_pushButton4_clicked\",\r\n    \"on_pushButton3_clicked\",\r\n    \"on_pushButton2_clicked\",\r\n    \"on_pushButton1_clicked\",\r\n    \"on_pushButton0_clicked\",\r\n    \"on_pushButton_ans_clicked\",\r\n    \"on_pushButton_imag_clicked\",\r\n    \"on_pushButton_pow_clicked\",\r\n    \"on_pushButton_del_clicked\",\r\n    \"on_pushButton_ac_clicked\",\r\n    \"on_pushButton_plus_clicked\",\r\n    \"on_pushButton_div_clicked\",\r\n    \"on_pushButton_mul_clicked\",\r\n    \"on_pushButton_minus_clicked\",\r\n    \"on_pushButton_left_clicked\",\r\n    \"on_pushButton_right_clicked\",\r\n    \"on_pushButton_point_clicked\",\r\n    \"on_pushButton_imag_2_clicked\",\r\n    \"on_pushButton_nextline_clicked\",\r\n    \"on_pushButton_resetfilebuffer_clicked\"\r\n);\r\n#else  // !QT_MOC_HAS_STRING_DATA\r\nstruct qt_meta_stringdata_CLASSCalculatorENDCLASS_t {\r\n    uint offsetsAndSizes[54];\r\n    char stringdata0[11];\r\n    char stringdata1[23];\r\n    char stringdata2[1];\r\n    char stringdata3[23];\r\n    char stringdata4[23];\r\n    char stringdata5[23];\r\n    char stringdata6[23];\r\n    char stringdata7[23];\r\n    char stringdata8[23];\r\n    char stringdata9[23];\r\n    char stringdata10[23];\r\n    char stringdata11[23];\r\n    char stringdata12[26];\r\n    char stringdata13[27];\r\n    char stringdata14[26];\r\n    char stringdata15[26];\r\n    char stringdata16[25];\r\n    char stringdata17[27];\r\n    char stringdata18[26];\r\n    char stringdata19[26];\r\n    char stringdata20[28];\r\n    char stringdata21[27];\r\n    char stringdata22[28];\r\n    char stringdata23[28];\r\n    char stringdata24[29];\r\n    char stringdata25[31];\r\n    char stringdata26[38];\r\n};\r\n#define QT_MOC_LITERAL(ofs, len) \\\r\n    uint(sizeof(qt_meta_stringdata_CLASSCalculatorENDCLASS_t::offsetsAndSizes) + ofs), len \r\nQ_CONSTINIT static const qt_meta_stringdata_CLASSCalculatorENDCLASS_t qt_meta_stringdata_CLASSCalculatorENDCLASS = {\r\n    {\r\n        QT_MOC_LITERAL(0, 10),  // \"Calculator\"\r\n        QT_MOC_LITERAL(11, 22),  // \"on_pushButton9_clicked\"\r\n        QT_MOC_LITERAL(34, 0),  // \"\"\r\n        QT_MOC_LITERAL(35, 22),  // \"on_pushButton8_clicked\"\r\n        QT_MOC_LITERAL(58, 22),  // \"on_pushButton7_clicked\"\r\n        QT_MOC_LITERAL(81, 22),  // \"on_pushButton6_clicked\"\r\n        QT_MOC_LITERAL(104, 22),  // \"on_pushButton5_clicked\"\r\n        QT_MOC_LITERAL(127, 22),  // \"on_pushButton4_clicked\"\r\n        QT_MOC_LITERAL(150, 22),  // \"on_pushButton3_clicked\"\r\n        QT_MOC_LITERAL(173, 22),  // \"on_pushButton2_clicked\"\r\n        QT_MOC_LITERAL(196, 22),  // \"on_pushButton1_clicked\"\r\n        QT_MOC_LITERAL(219, 22),  // \"on_pushButton0_clicked\"\r\n        QT_MOC_LITERAL(242, 25),  // \"on_pushButton_ans_clicked\"\r\n        QT_MOC_LITERAL(268, 26),  // \"on_pushButton_imag_clicked\"\r\n        QT_MOC_LITERAL(295, 25),  // \"on_pushButton_pow_clicked\"\r\n        QT_MOC_LITERAL(321, 25),  // \"on_pushButton_del_clicked\"\r\n        QT_MOC_LITERAL(347, 24),  // \"on_pushButton_ac_clicked\"\r\n        QT_MOC_LITERAL(372, 26),  // \"on_pushButton_plus_clicked\"\r\n        QT_MOC_LITERAL(399, 25),  // \"on_pushButton_div_clicked\"\r\n        QT_MOC_LITERAL(425, 25),  // \"on_pushButton_mul_clicked\"\r\n        QT_MOC_LITERAL(451, 27),  // \"on_pushButton_minus_clicked\"\r\n        QT_MOC_LITERAL(479, 26),  // \"on_pushButton_left_clicked\"\r\n        QT_MOC_LITERAL(506, 27),  // \"on_pushButton_right_clicked\"\r\n        QT_MOC_LITERAL(534, 27),  // \"on_pushButton_point_clicked\"\r\n        QT_MOC_LITERAL(562, 28),  // \"on_pushButton_imag_2_clicked\"\r\n        QT_MOC_LITERAL(591, 30),  // \"on_pushButton_nextline_clicked\"\r\n        QT_MOC_LITERAL(622, 37)   // \"on_pushButton_resetfilebuffer...\"\r\n    },\r\n    \"Calculator\",\r\n    \"on_pu",
    "/*\n Z80 emulator code derived from Lin Ke-Fong source. Copyright says:\n\n Copyright (c) 2016, 2017 Lin Ke-Fong\n\n This code is free, do whatever you want with it.\n\n 2020 adapted by Fabrizio Di Vittorio for fabgl ESP32 library\n */\n\n#include \"Z80.h\"\n\n#ifdef PLATFORM_SDL\n#include <stdio.h>\n#endif /* PLATFORM_SDL */\n\n#include \"cerberus.h\"\n\nstatic inline int m_readByte(void* context, int addr)\n{\n    return cpeek(addr);\n}\nstatic inline void m_writeByte(void* context, int addr, int value)\n{\n    cpoke(addr, value);\n}\nstatic inline int m_readWord(void* context, int addr)\n{\n    return cpeekW(addr);\n}\nstatic inline void m_writeWord(void* context, int addr, int value)\n{\n    cpokeW(addr, value);\n}\nstatic inline int m_readIO(void* context, int addr) { return 0; }\nstatic inline void m_writeIO(void* context, int addr, int value)\n{\n#ifdef PLATFORM_SDL\n    Z80* z80 = static_cast<Z80*>(context);\n    fprintf(stderr, \"OUT($%02x) debug trigger: BC=%04x DE=%04x HL=%04x AF=%04x IX=%04x IY=%04x SP=%04x\\n\",\n        addr,\n        z80->readRegWord(Z80_BC),\n        z80->readRegWord(Z80_DE),\n        z80->readRegWord(Z80_HL),\n        z80->readRegWord(Z80_AF),\n        z80->readRegWord(Z80_IX),\n        z80->readRegWord(Z80_IY),\n        z80->readRegWord(Z80_SP));\n#endif\n}\n\n#pragma GCC optimize(\"O2\")\n\n/* Write the following macros for memory access and input/output on the Z80.\n *\n * Z80_FETCH_BYTE() and Z80_FETCH_WORD() are used by the emulator to read the\n * code (opcode, constants, displacement, etc). The upper 16-bit of the address\n * parameters is undefined and must be reset to zero before actually reading\n * memory (use & 0xffff). The value x read, must be an unsigned 8-bit or 16-bit\n * value in the endianness of the host processor.\n *\n * Z80_READ_BYTE(), Z80_WRITE_BYTE(), Z80_READ_WORD(), and Z80_WRITE_WORD()\n * are used for general memory access. They obey the same rules as the code\n * reading macros. The upper bits of the value x to write may be non-zero.\n * Z80_READ_WORD_INTERRUPT() and Z80_WRITE_WORD_INTERRUPT() are same as\n * respectively Z80_READ_WORD() and Z80_WRITE_WORD(), except they are only used\n * for interrupt generation.\n *\n * Z80_INPUT_BYTE() and Z80_OUTPUT_BYTE() are for input and output. The upper\n * bits of the port number to read or write are always zero. The input byte x\n * must be an unsigned 8-bit value. The value x to write is an unsigned 8-bit\n * with its upper bits zeroed.\n *\n * All macros have access to the following three variables:\n *\n *      state           Pointer to the current Z80_STATE. Because the\n *\t\t\tinstruction is currently executing, its members may not\n *\t\t\tbe fully up to date, depending on when the macro is\n *\t\t\tcalled in the process. It is rather suggested to access\n *\t\t\tthe state only when the emulator is stopped.\n *\n *      elapsed_cycles  Number of cycles emulated. If needed, you may add wait\n *\t\t\tstates to it for slow memory accesses. Because the\n *\t\t\tmacros are called during the execution of the current\n *\t\t\tinstruction, this number is only precise up to the\n *\t\t\tprevious one.\n *\n *\n * Except for Z80_READ_WORD_INTERRUPT and Z80_WRITE_WORD_INTERRUPT, all macros\n * also have access to:\n *\n *\n *      registers       Current register decoding table, use it to determine if\n * \t\t\tthe current instruction is prefixed. It points on:\n *\n *\t\t\t\tstate.dd_register_table for 0xdd prefixes;\n *                      \tstate.fd_register_table for 0xfd prefixes;\n *\t\t\t\tstate.register_table otherwise.\n *\n *      pc              Current PC register (upper bits are undefined), points\n *                      on the opcode, the displacement or constant to read for\n *                      Z80_FETCH_BYTE() and Z80_FETCH_WORD(), or on the next\n *                      instruction otherwise.\n *\n * Except for Z80_FETCH_BYTE(), Z80_FETCH_WORD(), Z80_READ_WORD_INTERRUPT, and\n * Z80_WRITE_WORD_INTERRUPT, all other macros can know which instruction is\n * currently executing:\n *\n *      opcode          Opcode of the currently executing instruction.\n *\n *      instruction     Type of the currently executing instruction, see\n *                      instructions.h for a list.\n */\n\n/* Here are macros for emulating zexdoc and zexall. Read/write memory macros\n * are written for a linear 64k RAM. Input/output port macros are used as\n * \"traps\" to simulate system calls.\n */\n\n#define Z80_READ_BYTE(address, x)                        \\\n    {                                                    \\\n        (x) = (m_readByte(m_context, (address)&0xffff)); \\\n    }\n\n#define Z80_FETCH_BYTE(address, x) Z80_READ_BYTE((address), (x))\n\n#define Z80_READ_WORD(address, x)                                                                                 \\\n    {                                                                                                             \\\n        (x) = (m_readByte(m_context, (address)&0xffff) | (m_readByte(m_context, ((address) + 1) & 0xffff) << 8)); \\\n    }\n\n#define Z80_FETCH_WORD(address, x) Z80_READ_WORD((address), (x))\n\n#def",
    "#include <iostream>\nusing namespace std;\ntemplate <class type>\nclass Node {\nprivate:\n  type data;\n  Node* next;\npublic:\n  Node() : next(NULL) {}\n\n  void set_data(type data) {\n    this->data = data;\n  }\n\n  void set_next(Node* next) {\n    this->next = next;\n  }\n\n  Node* get_next() {\n    return next;\n  }\n\n  type get_data() {\n    return data;\n  }\n};\ntemplate <class type>\nclass CircularSinglyLinkedlist {\nprivate:\n  Node<type>* tail;\npublic:\nint count=0;\n  CircularSinglyLinkedlist() : tail(NULL) {}\n  bool is_empty() // o(1)\n  {\n    return tail == NULL;\n  }\n  void insert_first(type val) // o(1)\n   {\n    Node<type>* newnode = new Node<type>;\n    newnode->set_data(val);\n    if (!is_empty()) {\n      newnode->set_next(tail->get_next());\n      tail->set_next(newnode);\n    } else {\n      tail = newnode;\n      newnode->set_next(newnode); // Handle single element case (circular)\n    }\n  count++;\n  }\n  void insert_end(type val) // o(1)\n   {\n    if (is_empty()) {\n      insert_first(val);\n    } else {\n      Node<type>* newnode = new Node<type>;\n      newnode->set_data(val);\n      newnode->set_next(tail->get_next());\n      tail->set_next(newnode);\n      tail = newnode;\n    }\n  count++;\n  }\n void delete_first() // o(1)\n {\n Node<type>*temp=tail->get_next();\n tail->set_next(temp->get_next());\ndelete temp;\ncount--;\n }\nvoid delete_end() // o(N)\n{\nNode<type>* temp = tail->get_next();\nNode<type>* prev;\nwhile(temp->get_data()!=tail->get_data())\n{prev=temp;\ntemp=temp->get_next();\n}\nprev->set_next(tail->get_next());\ntail=prev;\ndelete temp;\ncount--;\n}\nvoid insert_after(type item,type newitem) // o(N)\n{\nNode<type>*temp=tail->get_next();\ndo\n{\nif(temp->get_data()==item)\n {\nNode<type>*newelement=new Node<type>;\nnewelement->set_data(newitem);\nnewelement->set_next(temp->get_next());\ntemp->set_next(newelement);\ncount++;\nbreak;\n}\nelse{\ntemp=temp->get_next();\n}\n}while(temp!=tail->get_next());\n}\nvoid insert_before(type item,type newitem) // o(N)\n{\n Node<type>* current = tail->get_next();\n Node<type>* previous = nullptr;\ndo\n{\nif(current->get_data()==item)\n {\nprevious->set_data(newitem);\nprevious->set_next(current);\n count++;\n break;\n }\nprevious=current;\ncurrent=current->get_next();\n}while(current->get_next()!=tail->get_next());\n}\nvoid delete_before(type item ) // o(N)\n{\n  Node<type>*temp=tail->get_next();\n  Node<type>*current=temp->get_next();\n  current=current->get_next();\n  Node<type>*cur;\ndo{\n if(item==current->get_data())\n {cur=temp->get_next();\n  temp->set_next(current);\n  delete cur;\n count--;\n break;\n }\ncurrent=current->get_next();\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\n}\nvoid delete_after(type item) // o(N)\n{\n  Node<type>*temp=tail->get_next();\n  Node<type>*current=temp->get_next();\n  current=current->get_next();\n  Node<type>*cur;\ndo{\n if(item==temp->get_data())\n {cur=temp->get_next();\n   temp->set_next(current);\n delete cur;\n count--;\n break;\n }\ncurrent=current->get_next();\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\n}\n  void display() // o(N)\n  {\n  int n=1;\n    cout << \"*******  all elements ********\\n\\n\";\n    if (is_empty()) {\n      cout << \"List is empty\\n\";\n      return;\n    }\n\n    Node<type>* temp = tail->get_next();\n    do {\n      cout<<\"item \"<<n<<\":\"<<temp->get_data()<<endl;\n n++;\n      temp = temp->get_next();\n    } while (temp != tail->get_next());\n  }\nbool isfind(type item) // o(N)\n{\nNode<type>*temp=tail->get_next();\ndo{\nif(item==temp->get_data())\nreturn true;\n\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\nreturn false;\n}\nvoid replace(type old_item,type new_item) // o(N)\n{\nNode<type>*temp=tail->get_next();\nbool exist=false;\ndo{\nif(old_item==temp->get_data())\n{\n exist=true;\n temp->set_data(new_item);\nbreak;\n}\ntemp=temp->get_next();\n}while(temp!=tail->get_next());\nif(exist==false)\ncout<<\"NOT found\";}\nvoid displaybyrecursion() // o(N)\n{\nstatic Node<type>*temp=tail->get_next();\nstatic int n=1;\nif (is_empty()) {\n      cout << \"List is empty\\n\";\n      return;\n }\nif(n==1){\ncout<<\"item \"<<n<<\":\"<<temp->get_data()<<endl;\ntemp=temp->get_next();}\nif(temp==tail->get_next())\nreturn ;\nelse{\nn++;\n cout<<\"item \"<<n<<\":\"<<temp->get_data()<<endl;\n  temp=temp->get_next();\ndisplaybyrecursion();\n}\n}\nint size() //o(1)\n{\nreturn count;\n}\n};\nint main() {\n  CircularSinglyLinkedlist<int> numbers;\n  for (int i = 0; i < 10; i++) {\n    numbers.insert_first(i);\n  }\n  numbers.insert_end(100);\nnumbers.replace(1,10001);\nnumbers.display();\n\ncout<<\"\\n size :\"<<numbers.size();\n\n return 0;\n}\n\n",
    "//#include <catch2/catch_test_macros.hpp>\r\n//#include <iostream>\r\n//\r\n//// change if you choose to use a different header name\r\n//#include \"C:\\DSAProject2Catch\\Page-Rank-Project\\src\\main.cpp\"\r\n//\r\n//using namespace std;\r\n//\r\n////catch template from project 2 catch github\r\n//\r\n//TEST_CASE(\"Four Power Iterations\", \"[flag]\"){\r\n//    string input = R\"(7 4\r\n//google.com gmail.com\r\n//google.com maps.com\r\n//facebook.com ufl.edu\r\n//ufl.edu google.com\r\n//ufl.edu gmail.com\r\n//maps.com facebook.com\r\n//gmail.com maps.com)\";\r\n//\r\n//    string expectedOutput = R\"(facebook 0.20\r\n//gmail 0.20\r\n//google 0.10\r\n//maps 0.30\r\n//ufl 0.20\r\n//)\";\r\n//\r\n//    string actualOutput;\r\n//\r\n//    adjacencyList a;\r\n//    a.addToVect(\"google\", \"gmail\");\r\n//    a.addToVect(\"google\", \"maps\");\r\n//    a.addToVect(\"facebook\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"google\");\r\n//    a.addToVect(\"ufl\", \"gmail\");\r\n//    a.addToVect(\"ufl\", \"gmail\");\r\n//    a.addToVect(\"gmail\", \"maps\");\r\n//\r\n//    a.findRT();\r\n//    a.firstRValues();\r\n//    a.pageRank(4);\r\n//    actualOutput = a.returnValues();\r\n//\r\n//    REQUIRE(actualOutput == expectedOutput);\r\n//}\r\n//\r\n//TEST_CASE(\"One line\", \"[flag]\"){\r\n//string input = R\"(1 2\r\n//google facebook)\";\r\n//\r\n//string expectedOutput = R\"(facebook 0.50\r\n//google 0.00\r\n//)\";\r\n//\r\n//string actualOutput;\r\n//\r\n//adjacencyList a;\r\n//a.addToVect(\"google\", \"facebook\");\r\n//\r\n//a.findRT();\r\n//a.firstRValues();\r\n//a.pageRank(2);\r\n//actualOutput = a.returnValues();\r\n//\r\n//REQUIRE(actualOutput == expectedOutput);\r\n//}\r\n//\r\n//TEST_CASE(\"Ten Lines, One Power Iteration\", \"[flag]\"){\r\n//    string input = R\"(10 1\r\n//google gmail\r\n//gmail ufl\r\n//ufl maps\r\n//maps facebook\r\n//facebook google\r\n//google ufl\r\n//ufl google\r\n//google facebook\r\n//gmail facebook\r\n//ufl facebook\r\n//)\";\r\n//\r\n//    string expectedOutput = R\"(facebook 0.20\r\n//gmail 0.20\r\n//google 0.20\r\n//maps 0.20\r\n//ufl 0.20\r\n//)\";\r\n//\r\n//    string actualOutput;\r\n//\r\n//    adjacencyList a;\r\n//    a.addToVect(\"google\", \"gmail\");\r\n//    a.addToVect(\"gmail\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"maps\");\r\n//    a.addToVect(\"maps\", \"facebook\");\r\n//    a.addToVect(\"facebook\", \"google\");\r\n//    a.addToVect(\"google\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"google\");\r\n//    a.addToVect(\"google\", \"facebook\");\r\n//    a.addToVect(\"gmail\", \"facebook\");\r\n//    a.addToVect(\"ufl\", \"facebook\");\r\n//\r\n//    a.findRT();\r\n//    a.firstRValues();\r\n//    a.pageRank(1);\r\n//    actualOutput = a.returnValues();\r\n//\r\n//    REQUIRE(actualOutput == expectedOutput);\r\n//}\r\n//\r\n//TEST_CASE(\"Ten Lines, One Power Iteration\", \"[flag]\"){\r\n//    string input = R\"(10 1\r\n//google gmail\r\n//gmail ufl\r\n//ufl maps\r\n//maps facebook\r\n//facebook google\r\n//google ufl\r\n//ufl google\r\n//google facebook\r\n//gmail facebook\r\n//ufl facebook\r\n//)\";\r\n//\r\n//    string expectedOutput = R\"(facebook 0.20\r\n//gmail 0.20\r\n//google 0.20\r\n//maps 0.20\r\n//ufl 0.20\r\n//)\";\r\n//\r\n//    string actualOutput;\r\n//\r\n//    adjacencyList a;\r\n//    a.addToVect(\"google\", \"gmail\");\r\n//    a.addToVect(\"gmail\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"maps\");\r\n//    a.addToVect(\"maps\", \"facebook\");\r\n//    a.addToVect(\"facebook\", \"google\");\r\n//    a.addToVect(\"google\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"google\");\r\n//    a.addToVect(\"google\", \"facebook\");\r\n//    a.addToVect(\"gmail\", \"facebook\");\r\n//    a.addToVect(\"ufl\", \"facebook\");\r\n//\r\n//    a.findRT();\r\n//    a.firstRValues();\r\n//    a.pageRank(1);\r\n//    actualOutput = a.returnValues();\r\n//\r\n//    REQUIRE(actualOutput == expectedOutput);\r\n//}\r\n//\r\n//TEST_CASE(\"Nodes pointing to each other\", \"[flag]\"){\r\n//    string input = R\"(4 2\r\n//google gmail\r\n//gmail google\r\n//facebook ufl\r\n//ufl facebook\r\n//)\";\r\n//\r\n//    string expectedOutput = R\"(facebook 0.25\r\n//gmail 0.25\r\n//google 0.25\r\n//ufl 0.25\r\n//)\";\r\n//\r\n//    string actualOutput;\r\n//\r\n//    adjacencyList a;\r\n//    a.addToVect(\"google\", \"gmail\");\r\n//    a.addToVect(\"gmail\", \"google\");\r\n//    a.addToVect(\"facebook\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"facebook\");\r\n//\r\n//    a.findRT();\r\n//    a.firstRValues();\r\n//    a.pageRank(2);\r\n//    actualOutput = a.returnValues();\r\n//\r\n//    REQUIRE(actualOutput == expectedOutput);\r\n//}\r\n//\r\n//TEST_CASE(\"High power iteration\", \"[flag]\"){\r\n//    string input = R\"(7 10\r\n//google gmail\r\n//gmail facebook\r\n//maps ufl\r\n//ufl gmail\r\n//google maps\r\n//ufl maps\r\n//maps facebook\r\n//)\";\r\n//\r\n//    string expectedOutput = R\"(facebook 0.00\r\n//gmail 0.00\r\n//google 0.00\r\n//maps 0.00\r\n//ufl 0.00\r\n//)\";\r\n//\r\n//    string actualOutput;\r\n//\r\n//    adjacencyList a;\r\n//    a.addToVect(\"google\", \"gmail\");\r\n//    a.addToVect(\"gmail\", \"facebook\");\r\n//    a.addToVect(\"maps\", \"ufl\");\r\n//    a.addToVect(\"ufl\", \"gmail\");\r\n//    a.addToVect(\"google\", \"maps\");\r\n//    a.addToVect(\"ufl\", \"maps\");\r\n//    a.addToVect(\"maps\", \"facebook\");\r\n//\r\n//    a.findRT();\r\n//    a.firstRValues();\r\n//    a.pageRank(50);\r\n//    actualOutput = a.returnValues();\r\n//\r\n//    REQUIRE(actualOutput == expectedOutput);\r\n//}\r\n//\r\n",
    "/*\n *  Modern Native AddIn\n *  Copyright (C) 2018  Infactum\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Affero General Public License as\n *  published by the Free Software Foundation, either version 3 of the\n *  License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Affero General Public License for more details.\n *\n *  You should have received a copy of the GNU Affero General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n#include <ComponentBase.h>\n#include <types.h>\n#include <stdexcept>\n#include <sstream>\n\n#include \"Component4Python.h\"\n\n#ifdef _WINDOWS\n#pragma warning (disable : 4311 4302)\n#endif\n\nconst WCHAR_T *GetClassNames() {\n    // Might contain multiple class names seperated by |\n    static char16_t cls_names[] = u\"Component4Python\";\n    return reinterpret_cast<WCHAR_T *>(cls_names);\n}\n\nlong GetClassObject(const WCHAR_T *clsName, IComponentBase **pInterface) {\n    if (!*pInterface) {\n        auto cls_name = std::u16string(reinterpret_cast<const char16_t *>(clsName));\n        if (cls_name == u\"Component4Python\") {\n            *pInterface = new Component4Python;\n        }\n        return (long) *pInterface;\n    }\n    return 0;\n}\n\nlong DestroyObject(IComponentBase **pInterface) {\n    if (!*pInterface) {\n        return -1;\n    }\n    delete *pInterface;\n    *pInterface = nullptr;\n    return 0;\n}\n\nAppCapabilities SetPlatformCapabilities(const AppCapabilities capabilities) {\n    return eAppCapabilitiesLast;\n}\n",
    "/////////////////////////////////////////////////////////////////////////////\n// Copyright (c) Electronic Arts Inc. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"EASTLTest.h\"\n#include <EASTL/slist.h>\n#include <EABase/eabase.h>\n#include <EASTL/fixed_allocator.h>\n\nusing namespace eastl;\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nstruct TestObj\n{\n\tTestObj() : mI(0), mMoveCtor(0), mCopyCtor(0) {} \n\texplicit TestObj(int i) : mI(i), mMoveCtor(0), mCopyCtor(0) {}\n\texplicit TestObj(int a, int b, int c, int d) : mI(a+b+c+d), mMoveCtor(0), mCopyCtor(0) {}\n\n\tTestObj(TestObj&& other)\n\t{\n\t\tmI = other.mI;\n\t\tmMoveCtor = other.mMoveCtor;\n\t\tmCopyCtor = other.mCopyCtor;\n\t\tmMoveCtor++;\n\t}\n\n\tTestObj(const TestObj& other)\n\t{\n\t\tmI = other.mI;\n\t\tmMoveCtor = other.mMoveCtor;\n\t\tmCopyCtor = other.mCopyCtor;\n\t\tmCopyCtor++;\n\t}\n\n\tTestObj& operator=(const TestObj& other) \n\t{\n\t\tmI = other.mI;\n\t\tmMoveCtor = other.mMoveCtor;\n\t\tmCopyCtor = other.mCopyCtor;\n\t\treturn *this;\n\t}\n\n\tint mI;\n\tint mMoveCtor;\n\tint mCopyCtor;\n};\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// TestSList\nint TestSList()\n{\n\tint nErrorCount = 0;\n\n\t// slist();\n\t{\n\t\tslist<int> list;\n\t\tVERIFY(list.empty());\n\t\tVERIFY(list.size() == 0);\n\t}\n\n\t// slist(const allocator_type& allocator);\n\t{ \n\t\tMallocAllocator::reset_all();\n\n\t\tVERIFY(MallocAllocator::mAllocCountAll == 0);\n\t\tslist<int, MallocAllocator> list;\n\t\tlist.resize(100, 42);\n\t\tVERIFY(MallocAllocator::mAllocCountAll == 100);\n\t}\n\n\t// explicit slist(size_type n, const allocator_type& allocator = EASTL_SLIST_DEFAULT_ALLOCATOR);\n\t{\n\t\tslist<int> list(100);\n\t\tVERIFY(list.size() == 100);\n\t\tVERIFY(!list.empty());\n\t}\n\n\t// slist(size_type n, const value_type& value, const allocator_type& allocator = EASTL_SLIST_DEFAULT_ALLOCATOR);\n\t{\n\t\tslist<int> list(32, 42);\n\t\tVERIFY(list.size() == 32);\n\t\tVERIFY(list.front() == 42);\n\t\tVERIFY(!list.empty());\n\t}\n\n\t// slist(const this_type& x);\n\t{\n\t\tslist<int> list1;\n\t\tlist1.resize(100, 42);\n\n\t\tVERIFY(!list1.empty());\n\t\tslist<int> list2(list1);\n\t\tVERIFY(!list2.empty());\n\t\tVERIFY(list1 == list2);\n\t}\n\t\n\t// slist(std::initializer_list<value_type> ilist, const allocator_type& allocator = EASTL_SLIST_DEFAULT_ALLOCATOR);\n\t{\n\t#if !defined(EA_COMPILER_NO_INITIALIZER_LISTS)\n\t\tslist<int> list1({1,2,3,4,5,6,7,8});\n\t\tVERIFY(!list1.empty());\n\t\tVERIFY(list1.size() == 8);\n\t#endif\n\t}\n\n\t// slist(this_type&& x);\n\t{\n\t\tslist<int> list1; \n\t\tlist1.resize(100,42);\n\n\t\tslist<int> list2(eastl::move(list1));\n\n\t\tVERIFY(list1.empty());\n\t\tVERIFY(!list2.empty());\n\t\tVERIFY(list1 != list2);\n\t}\n\t\n\t// slist(this_type&& x, const allocator_type& allocator);\n\t{ } \n\n\t// slist(InputIterator first, InputIterator last); \n\t{\n\t\tslist<int> list1; \n\t\tlist1.resize(100, 42);\n\t\tVERIFY(!list1.empty());\n\n\t\tslist<int> list2(list1.begin(), list1.end());\n\t\tVERIFY(!list2.empty());\n\t\tVERIFY(list1 == list2);\n\t}\n\n\t// this_type& operator=(const this_type& x);\n\t{\n\t\tslist<int> list1;\n\t\tlist1.resize(100, 42);\n\t\tVERIFY(!list1.empty());\n\n\t\tslist<int> list2 = list1;\n\t\tVERIFY(!list2.empty());\n\t\tVERIFY(list1 == list2);\n\t}\n\n\t// this_type& operator=(std::initializer_list<value_type>);\n\t{\n\t\tslist<int> list1 = {1,2,3,4,5,6,7,8};\n\t\tVERIFY(!list1.empty());\n\t}\n\n\t// this_type& operator=(this_type&& x);\n\t{\n\t\tslist<int> list1;\n\t\tlist1.resize(100, 42);\n\t\tslist<int> list2 = eastl::move(list1);\n\n\t\tVERIFY(list1.empty());\n\t\tVERIFY(!list2.empty());\n\t\tVERIFY(list1 != list2);\n\t}\n\n\t// void swap(this_type& x);\n\t{\n\t\tslist<int> list1;\n\t\tlist1.resize(8, 37);\n\n\t\tslist<int> list2; \n\t\tVERIFY(!list1.empty());\n\t\tVERIFY(list1.size() == 8);\n\t\tVERIFY(list2.empty());\n\n\t\tlist2.swap(list1);\n\n\t\tVERIFY(list1.empty());\n\t\tVERIFY(!list2.empty());\n\t}\n\n\t// void assign(size_type n, const value_type& value);\n\t{\n\t\tslist<int> list1;\n\t\tlist1.assign(100, 42);\n\n\t\tVERIFY(!list1.empty());\n\t\tVERIFY(list1.size() == 100);\n\n\t\tfor(auto& e : list1)\n\t\t\tVERIFY(e == 42);\n\t}\n\n\t// void assign(std::initializer_list<value_type> ilist);\n\t{\n\t#if !defined(EA_COMPILER_NO_INITIALIZER_LISTS)\n\t\tslist<int> list1;\n\t\tlist1.assign({1,2,3,4,5,6,7,8});\n\n\t\tVERIFY(!list1.empty());\n\t\tVERIFY(list1.size() == 8);\n\n\t\tauto i = eastl::begin(list1);\n\t\tVERIFY(*i == 1); i++;\n\t\tVERIFY(*i == 2); i++;\n\t\tVERIFY(*i == 3); i++;\n\t\tVERIFY(*i == 4); i++;\n\t\tVERIFY(*i == 5); i++;\n\t\tVERIFY(*i == 6); i++;\n\t\tVERIFY(*i == 7); i++;\n\t\tVERIFY(*i == 8); i++;\n\t\tVERIFY(i == eastl::end(list1));\n\t#endif\n\t}\n\n\t// void assign(InputIterator first, InputIterator last);\n\t{\n\t\tslist<int> list1;\n\t\tlist1.resize(100, 42);\n\t\tVERIFY(!list1.empty());\n\n\t\tslist<int> list2;\n\t\tlist2.assign(list1.begin(), list1.end());\n\t\tVERIFY(!list2.empty());\n\t\tVERIFY(list1 == list2);\n\t}\n\n\t// iterator       begin() EA_NOEXCEPT;\n\t// const_iterator begin() const EA_NOEXCEPT;\n\t// const_iterator cbegin() const EA_NOEXCEPT;\n\t{\n\t\tslist<int> list1;\n\t\tlist1.resize(100, 1);\n\t\t",
    "#include <iostream>\n#include <vector>\n#include <ctime>\n#include <cstdlib>\n\nconst int TAMANHO_TABULEIRO = 5;\nint linhaNavio, colunaNavio;\n\nstd::vector<std::vector<char>> tabuleiro(TAMANHO_TABULEIRO, std::vector<char>(TAMANHO_TABULEIRO, 'O'));\n\nvoid inicializarTabuleiro() {\n    for (int i = 0; i < TAMANHO_TABULEIRO; i++) {\n        for (int j = 0; j < TAMANHO_TABULEIRO; j++) {\n            tabuleiro[i][j] = 'O';\n        }\n    }\n}\n\nvoid exibirTabuleiro() {\n    for (int i = 0; i < TAMANHO_TABULEIRO; i++) {\n        for (int j = 0; j < TAMANHO_TABULEIRO; j++) {\n            std::cout << tabuleiro[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid posicionarNavio() {\n    linhaNavio = std::rand() % TAMANHO_TABULEIRO;\n    colunaNavio = std::rand() % TAMANHO_TABULEIRO;\n    tabuleiro[linhaNavio][colunaNavio] = 'N';\n}\n\nint main() {\n    std::srand(std::time(nullptr));\n    int palpiteLinha, palpiteColuna;\n    int turno;\n\n    inicializarTabuleiro();\n    posicionarNavio();\n\n    std::cout << \"Bem-vindo ao Jogo de Batalha Naval!\" << std::endl;\n    std::cout << \"Escolha uma linha e uma coluna de 0 a 4 para atacar.\" << std::endl;\n  \n    for (turno = 0; turno < 4; turno++) {\n        std::cout << \"Turno \" << turno + 1 << std::endl;\n        std::cout << \"Adivinhe a linha: \";\n        std::cin >> palpiteLinha;\n        std::cout << \"Adivinhe a coluna: \";\n        std::cin >> palpiteColuna;\n\n        if (palpiteLinha < 0 || palpiteLinha >= TAMANHO_TABULEIRO || palpiteColuna < 0 || palpiteColuna >= TAMANHO_TABULEIRO) {\n            std::cout << \"Palpite fora do tabuleiro! Tente novamente.\" << std::endl;\n        } else if (tabuleiro[palpiteLinha][palpiteColuna] == 'X') {\n            std::cout << \"Voc\u00ea j\u00e1 tentou esta posi\u00e7\u00e3o. Tente novamente.\" << std::endl;\n        } else if (tabuleiro[palpiteLinha][palpiteColuna] == 'N') {\n            std::cout << \"Parab\u00e9ns! Voc\u00ea afundou o navio!\" << std::endl;\n            tabuleiro[palpiteLinha][palpiteColuna] = 'X';\n            exibirTabuleiro();\n            break;\n        } else {\n            std::cout << \"Voc\u00ea errou!\" << std::endl;\n            tabuleiro[palpiteLinha][palpiteColuna] = 'X';\n        }\n    }\n\n    if (turno == 4) {\n        std::cout << \"Fim do jogo! O navio estava na linha \" << linhaNavio << \" e coluna \" << colunaNavio << \".\" << std::endl;\n          tabuleiro[linhaNavio][colunaNavio] = 'N';\n          exibirTabuleiro();\n    }\n    return 0;\n}\n\n",
    "//\r\n// Created by Sophie Shah on 2/7/2024.\r\n//\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <queue>\r\n//#include \"Student.cpp\"\r\n#include \"AVLTree.h\"\r\n\r\nusing namespace std;\r\n\r\n//constructor for avl tree\r\nAVLTree::AVLTree() {\r\n    root = nullptr;\r\n    treeHeight = 0;\r\n}\r\n\r\nAVLTree::~AVLTree(){\r\n    queue<Student*> q;\r\n    q.push(root);\r\n\r\n    while(!q.empty()){\r\n        Student* curr = q.front();\r\n        if(curr->left!=nullptr){\r\n            q.push(curr->left);\r\n        }\r\n        if(curr->right!=nullptr){\r\n            q.push(curr->right);\r\n        }\r\n        q.pop();\r\n        delete curr;\r\n    }\r\n    treeHeight = 0;\r\n    AVLStudentVect.clear();\r\n    AVLVect.clear();\r\n}\r\n\r\n//determines if input is valid and prints successful/unsuccessful\r\n// calls insert helper and adds id and student object to vectors\r\nvoid AVLTree::insert(string ID, string name){\r\n    //add to vector, print successful/unsuccessful\r\n    bool isValid = insertValid(ID, name);\r\n    if(!isValid){\r\n        cout<<\"unsuccessful\"<<endl;\r\n    }\r\n    else{\r\n        int id = stoi(ID);\r\n        cout<<\"successful\"<<endl;\r\n        Student* s = new Student(id,name);\r\n        AVLVect.push_back(id);\r\n\r\n        if(root==nullptr){\r\n            root = insertHelper(s, root);\r\n            //cout<<\"root\"<<endl;\r\n        }\r\n        else{\r\n            insertHelper(s, root);\r\n        }\r\n\r\n        AVLStudentVect.push_back(s);\r\n    }\r\n}\r\n\r\n//recursivly goes from root to leaf to determine where to place new node\r\n//calls balance helper to get balance factors of parent and child nodes\r\n//calls the respoective rotation function if needed\r\nStudent* AVLTree::insertHelper(Student* s, Student* curr_){\r\n    //recursive code used from insertIntoBST from Prog Quiz 4\r\n\r\n    if(curr_==nullptr){\r\n        curr_ = s;\r\n        s->height = 0;\r\n        s->parent = nullptr;\r\n        //cout<<\"root \"<<s->id<<endl;\r\n        //cout<<\"root\"<<endl;\r\n        return curr_;\r\n    }\r\n    //cout<<s->id<<\" \" <<curr_->id<<endl;\r\n    if(s->id > curr_->id){\r\n        //cout<<\"inserting right\"<<endl;\r\n        curr_->height++;\r\n        curr_->parent = curr_;\r\n        //cout<< \"height \"<<s->height<<\" parent \"<<s->parent->id<<endl;\r\n        curr_->right = insertHelper(s, curr_->right);\r\n    }\r\n    else{\r\n        //cout<<\"inserting left\"<<endl;\r\n        curr_->height++;\r\n        curr_->parent = curr_;\r\n        //cout<< \"height \"<<curr_->height<<\" parent \"<<curr_->parent->id<<endl;\r\n        curr_->left = insertHelper(s, curr_->left);\r\n    }\r\n\r\n    //int parentBalance = balanceHelper(curr_);\r\n    if(balanceHelper(curr_)==-2 && balanceHelper(curr_->right)==-1){\r\n        //cout<<\"performing left rotation on \"<<curr_->name<<endl;\r\n        curr_ = leftRotation(curr_);\r\n    }\r\n    else if(balanceHelper(curr_)==2 && balanceHelper(curr_->left)==1){\r\n        //cout<<\"performing right rotation on \"<<curr_->name<<endl;\r\n        curr_ = rightRotation(curr_);\r\n    }\r\n    else if(balanceHelper(curr_)==2 && balanceHelper(curr_->left)==-1){\r\n        //cout<<\"performing left right rotation on \"<<curr_->name<<endl;\r\n        curr_ = leftRightRotation(curr_);\r\n//        if(curr_ ==root){\r\n//            root = curr_->left->right;\r\n//        }\r\n//        curr_->left = leftRotation(curr_->left);\r\n        curr_ = rightRotation(curr_);\r\n    }\r\n    else if(balanceHelper(curr_)==-2 && balanceHelper(curr_->right)==1){\r\n        //cout<<\"performing right left rotation on \"<<curr_->name<<endl;\r\n        curr_ = rightLeftRotation(curr_);\r\n//        if(curr_ ==root){\r\n//            root = curr_->right->left;\r\n//        }\r\n//        curr_->right = leftRotation(curr_->right);\r\n        curr_ = leftRotation(curr_);\r\n    }\r\n\r\n    //idea taken from the chart on the powerpoint:\r\n\r\n    //parent-2 and child (parent->right)-1 ---> left rotation\r\n    //parent +2 and child(parent->left) +1 ---> right rotation\r\n    // parent +2 and child(parent->left)-1 ---> left right rotation\r\n    //parent -2 and child(parent->right)+1 ---> right left rotation\r\n\r\n    return curr_;\r\n}\r\n\r\n//check length of id, is alpha of name, check vector if id is repeated\r\n// passes return value into insert\r\nbool AVLTree::insertValid(string ID, string name){\r\n\r\n    bool idGood = false;\r\n    bool isUnique = true;\r\n    bool nameGood = true;\r\n    int countId = 0;\r\n    int id = stoi(ID);\r\n\r\n    for(int j=0; j<AVLVect.size();j++){\r\n        if(AVLVect[j] == id){\r\n            isUnique = false;\r\n        }\r\n    }\r\n\r\n//    while(id!=0){\r\n//        id /= 10;\r\n//        countId++;\r\n//    }\r\n//    if(countId==8){\r\n//        idGood = true;\r\n//    }\r\n\r\n    if(ID.length()==8){\r\n        idGood = true;\r\n    }\r\n\r\n\r\n    for(int i=0; i<name.length();i++){\r\n        if(!isalpha(name[i]) && !isspace(name[i])){\r\n            nameGood = false;\r\n        }\r\n    }\r\n   //cout<<\"id \"<<idGood<<\" name \"<<nameGood<<\" unique \"<<isUnique<<endl;\r\n    if(idGood && nameGood && isUnique){\r\n        return true;\r\n    }\r\n    else{\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n//recursively g",
    "#include<iostream>\nusing namespace std;\n\nint main(){\n\n\n// Square\n  // outer loop -> Rows\n  // for(int i=0; i<4; i=i+1){\n\n  //   // Print 4 Stars\n  // for(int j=0; j<4; j=j+1){\n  //   cout<< \"*\";\n  // }\n  // cout<< endl;\n  // }\n\n\n// // Rectangle\n//   for(int i=0; i<3; i=i+1){\n//   for(int j=0; j<6; j=j+1){\n//     cout<< \"*\";\n//   }\n//   cout<< endl;\n//   }\n\n\n// Hollow Rectangle\n// Outer loop\n  // for(int row=0; row<5; row=row+1){\n  //   // inner loop\n  // for(int col=0; col<5; col=col+1){\n  //   // if zeroth or last row, then print star\n  //   if(row == 0 || row == 4){\n  //     cout<< \"*\";\n  //   }\n  //    else{\n  //     if(col == 0 || col == 4){\n  //       cout<< \"*\";\n  //     }\n  //     else{\n  //       cout<< \" \";\n  //     }\n  //    }\n  // }\n  // cout<< endl;\n  // }\n\n\n  // int n;\n  // cin>> n;\n  // // Half Pyramid\n  // for(int row=0; row<n; row=row+1){\n  // for(int col=0; col<row+1; col=col+1){\n  //   cout<< \"*\";\n  // }\n  // cout<< endl;\n  // }\n\n  // Inverted Half Pyramid\n  // int n;\n  // cin>> n;\n  // for(int row=0; row<n; row=row+1){\n  // for(int col=0; col<n-row; col=col+1){\n  //   cout<< \"*\";\n  // }\n  // cout<< endl;\n  // }\n\n\n// Numeric Half Pyramid\n//    int n;\n//   cin>> n;\n//   for(int row=0; row<n; row=row+1){\n//   for(int col=0; col<row+1; col=col+1){\n//     cout<< col+1 << \"\";\n//   }\n//   cout<< endl;\n//   }\n// }\n\n\n\n// Pyramid \n//   int n;\n//   cin>> n;\n\n//   for(int row=0; row<n; row=row+1){\n//   for(int col=0; col<n-row-1; col=col+1){\n//     cout<< \" \";\n//   }\n\n//   for(int col=0; col<row+1; col=col=col+1){\n//     cout<< \"* \";\n//   }\n\n//   cout<< endl;\n//   }\n\n//   return 0;\n// }\n\n int n;\n  cin>> n;\n\n  for(int row=0; row<n; row=row+1){\n  for(int col=0; col<n-row-1; col=col+1){\n    cout<< \" \";\n  }\n\n  for(int col=0; col<row+1; col=col=col+1){\n    cout<< \"* \";\n  }\n\n  cout<< endl;\n  }\n\n  return 0;\n}\n",
    "#include <bits/stdc++.h>\r\n#include<windows.h>\r\nusing namespace std;\r\nvoid printf_green(const char *s)\r\n{\r\n\tprintf(\"\\033[0m\\033[1;32m%s\\033[0m\", s);\r\n}\r\nBOOL SetConsoleColor(WORD wAttributes)  \r\n{  \r\n\tHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);  \r\n\tif (hConsole == INVALID_HANDLE_VALUE)  \r\n\t\treturn FALSE;  \r\n\t\r\n\treturn SetConsoleTextAttribute(hConsole, wAttributes);  \r\n}  \r\nbool check()\r\n{\r\n\tstring ans,ans2;\r\n\tfreopen(\"a.out\",\"r\",stdin);\r\n\tchar c;\r\n\twhile(scanf(\"%c\",&c)!=EOF) ans+=c;\r\n\tfclose(stdin);\r\n\tfreopen(\"b.out\",\"r\",stdin);\r\n\twhile(scanf(\"%c\",&c)!=EOF) ans2+=c;;\r\n\tfclose(stdin);\r\n\treturn ans == ans2;\r\n}\r\nint main() {\r\n\tint n;\r\n\tcin>>n;\r\n\tfor(int i = 1; n?i<=n:1;i++) {\r\n\t\tsystem(\"gen > test.in\");\r\n\t\tsystem(\"sol.exe < test.in > a.out\");\r\n\t\tsystem(\"ans.exe < test.in > b.out\"); \r\n\t\t\r\n\t\tif (check()) {\r\n\t\t\t\tSetConsoleColor(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | BACKGROUND_GREEN);\r\n\t\t\t\tprintf(\"[AC in %d]\",i);\r\n\t\t\t\tcout<<\"\\n\";\r\n\t\t}\r\n\t\telse{\r\n\t\t\tSetConsoleColor(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | BACKGROUND_RED);\r\n\t\t\tprintf(\"[WA in %d]\",i);\r\n\t\t\t\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\tprintf_green(\"ALL TESTS RIGHT\");\r\n}",
    "#include \"A.h\"\n#include \"B.h\"\n#include \"C.h\"\n#include \"D.h\"\n#include \"E.h\"\n#include \"F.h\"\n#include \"G.h\"\n#include \"H.h\"\n#include \"I.h\"\n#include \"J.h\"\n#include \"K.h\"\n#include \"L.h\"\n#include \"M.h\"\n#include \"N.h\"\n#include \"O.h\"\n#include \"P.h\"\n#include \"Q.h\"\n#include \"R.h\"\n#include \"S.h\"\n#include \"T.h\"\n#include \"U.h\"\n#include \"V.h\"\n#include \"W.h\"\n#include \"X.h\"\n#include \"Y.h\"\n#include \"Z.h\"\n#include \"SPACE.h\"\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cctype>\n\n\n//Checks if the user's name contains only letters.\nbool isLettersOnly(const std::string& input) {\n    for (size_t i = 0; i < input.length(); ++i) {\n        if (!std::isalpha(input[i]) && input[i] != ' ') {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//Checks if the user enter two or more consecutive spaces as their name.\nbool hasConsecutiveSpaces(const std::string& str) {\n    for (size_t i = 1; i < str.length(); ++i) {\n        if (std::isspace(str[i]) && std::isspace(str[i - 1])) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n//Main function where the program starts running.\nint main() {\n    std::string name;\n    std::cout << \"Enter your name: \";\n    std::getline(std::cin, name);\n     \n     //This loop converts the input to lowercase.\n    for (size_t x = 0; x < name.length(); x++) {\n        name[x] = std::tolower(name[x]);\n    }\n    \n    //This while loop checks if the user entered an empty input or input that contains numbers or input that has two or more consecutive spaces.\n    while (name.empty() || !isLettersOnly(name) ||   hasConsecutiveSpaces(name)) {\n        std::cout << \"Invalid input. Please enter a valid name: \";\n        std::getline(std::cin, name);\n        for (size_t x = 0; x < name.length(); x++) {\n            name[x] = std::tolower(name[x]);\n        }\n    }\n    \n   //For loop gets the ASCII character for each letter in the user's name.\n  for(int x = 0; x < name.length(); x++){             \n     switch(name[x]){\n        case 'a':\n            A();\n            break;\n        case 'b':\n            B();\n            break;\n        case 'c':\n               C();\n               break;                  \n        case 'd':\n            D();\n            break;\n        case 'e':\n            E();\n            break;\n        case 'f':\n            F();\n            break;\n        case 'g':\n            G();\n            break;\n        case 'h':\n            H();\n            break;\n        case 'i':\n            I();\n            break;\n        case 'j':\n            J();\n            break;\n        case 'k':\n            K();\n            break;\n        case 'l':\n            L();\n            break;\n        case 'm':\n            M();\n            break;\n        case 'n':\n            N();\n            break;\n        case 'o':\n            O();\n            break;\n        case 'p':\n            P();\n            break;\n        case 'q':\n            Q();\n            break;\n        case 'r':\n            R();\n            break;\n        case 's':\n            S();\n            break;\n        case 't':\n            T();\n            break;\n        case 'u':\n            U();\n            break;\n        case 'v':\n            V();\n            break;\n        case 'w':\n            W();\n            break;\n        case 'x':\n            X();\n            break;\n        case 'y':\n            Y();\n            break;\n        case 'z':\n            Z();\n            break;  \n        case ' ':\n            SPACES();\n            break;\n        default:\n             std::cout<<\"Invalid character\"<<std::endl;                                 \n      }\n  }\n  \n    return 0;\n}",
    "#include \"overseas_delights.h\"\n\nusing namespace std;\n\nstring tale_overseas (string line, string key) {\n    string result = \"\";\n    vector<int> permutation(key.size());\n    for (int i = 0; i < key.size(); i++) {\n        permutation[i] = i;\n    }\n    sort(permutation.begin(), permutation.end(), & {\n        return key[i] < key[j];\n    });\n    int number_of_rows = (line.size() + key.size() - 1) / key.size();\n    vector<vector<char>> grid(number_of_rows, vector<char>(key.size(), ' '));\n    int index = 0;\n    for (int j : permutation) {\n        for (int i = 0; i < number_of_rows; i++) {\n            if (index < line.size()) {\n                grid[i][j] = line[index++];\n            }\n        }\n    }\n    for (int i = 0; i < number_of_rows; i++) {\n        for (int j : permutation) {\n            if (grid[i][j] != ' ') {\n                result += grid[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    try {\n        HANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);\n        string line = \"kyi_43x4_snrcspl33th44_df3lvv}{r1yp\";\n        string key = \"secret\";\n        string overseas_line = tale_overseas(line, key);\n        SetConsoleTextAttribute(console, 12);\n        cout << \"Overseas line: \" << overseas_line << endl;\n        SetConsoleTextAttribute(console, 7);\n    }\n    catch(exception& e) {\n        return -1;\n    }\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"prebet_utm_map\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Points.hpp\"\n\n#include <iostream>\n\nvoid Points::generatePoints(std::vector<std::tuple<float, float>> centers, int count, float standardDeviation)\n{\n    // Allocate for m_points (point dimension assumed 2D)\n    m_count = count;\n    m_points = new float[2 * m_count];\n\n    // Generator for points\n    std::random_device randomDevice;\n    std::mt19937 generator(randomDevice());\n\n    // Generator for selecting a center point at random\n    std::random_device randomDeviceCenter;\n    std::mt19937 generatorCenter(randomDeviceCenter());\n    std::uniform_int_distribution<> distributionCenter(0, centers.size() - 1);\n\n    int pointsIndex = 0;\n    for (int i = 0; i < m_count; i++)\n    {\n        // Select a random center point\n        int randomCenterIndex = distributionCenter(generatorCenter);\n        \n        std::normal_distribution<float> distributionX(std::get<0>(centers[randomCenterIndex]), standardDeviation);\n        std::normal_distribution<float> distributionY(std::get<1>(centers[randomCenterIndex]), standardDeviation);\n\n        m_points[pointsIndex] = distributionX(generator);\n        m_points[pointsIndex + 1] = distributionX(generator);\n        pointsIndex += 2;\n    }\n\n    for (int j = 0; j < 2 * m_count; j += 2)\n    {\n        std::cout << m_points[j] << \" \" << m_points[j + 1] << \"\\n\";\n    }\n\n}\n\nPoints::~Points()\n{\n    delete m_points;\n}\n\nfloat* Points::getPoints()\n{\n    return m_points;\n}\n\nint Points::getCount()\n{\n    return m_count;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff// GitHubDesktop2Chinese.cpp: \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n\n\n#define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING\n#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING\t//\u6d88\u9664 converter.to_bytes\u7684\u8b66\u544a\n#define _CRT_SECURE_NO_WARNINGS\t\t\t\t\t\t\t\t//\u6d88\u9664 sprintf\u7684\u8b66\u544a\n\n#define PAUSE if(!no_pause) system(\"pause\")\n\n#include \"GitHubDesktop2Chinese.h\"\n#include <string>\n#include <filesystem>\n\n#include <regex>\n\n#include \"spdlog/spdlog.h\"\t\t\t// \u65e5\u5fd7\u5f0f\u8f93\u51fa\u5e93\n#include \"nlohmann/json.hpp\"\t\t// JSON\u8bfb\u53d6\u672c\u5730\u914d\u7f6e\u5e93\n#include \"WinReg/WinReg.hpp\"\t\t// \u6ce8\u518c\u8868\u64cd\u4f5c\u5e93\n\n#include <CLI/CLI.hpp>\t\t\t\t// \u53c2\u6570\u7ba1\u7406\u5668:\t\thttps://github.com/CLIUtils/CLI11\n#include \"Utils/utils.hpp\"\n\n\n#if _DEBUG\n#define NO_REPLACE 0\n#endif // _DEBUG\n\n\n\n\nnamespace fs = std::filesystem;\nusing json = nlohmann::json;\n\n// \u8bbe\u7f6e\u4e00\u4e2a\u8def\u5f84\u7684\u5168\u5c40\u53d8\u91cf  \u6307\u5411\u8981\u4fee\u6539JS\u7684\u76ee\u5f55\nfs::path Base;\nfs::path LocalizationJSON;\n\nbool no_pause;\t\t\t\t\t\t\t\t\t// \u7a0b\u5e8f\u5728\u7ed3\u675f\u524d\u662f\u5426\u6682\u505c\nbool only_read_from_remote;\t\t\t\t\t\t// \u4ec5\u4ece\u8fdc\u7a0burl\u4e2d\u8bfb\u53d6\u672c\u5730\u5316\u6587\u4ef6\n\njson localization = R\"(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"main\": [\n\t\t\t\t\t\t\t\t[\"XXXXX\", \"XXXXX\"]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"renderer\": [\n\t\t\t\t\t\t\t\t[\"xxxxx\",\"xxxxx\"]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t)\"_json;\nbool _debug_goto_devoptions;\n\nbool _debug_error_check_mode_main = false;\nbool _debug_error_check_mode_renderer = false;\nbool _debug_invalid_check_mode = false;\nbool _debug_no_replace_res = false;\nbool _debug_translation_from_bak = false;\t\t// \u76f4\u63a5\u4ece\u5907\u4efd\u6587\u4ef6\u4e2d\u7ffb\u8bd1\u5230\u76ee\u6807\u6587\u4ef6\u4e2d\nbool _debug_dev_replace = false;\t\t\t\t// \u5f00\u53d1\u6a21\u5f0f\u66ff\u6362\n\n// argv[0] \u662f\u7a0b\u5e8f\u8def\u5f84\nint main(int argc, char* argv[])\n{\n\t// \u8bbe\u7f6e\u63a7\u5236\u53f0\u6253\u5370\u65e5\u5fd7\u8f93\u51fa\u7b49\u7ea7\n#if _DEBUG\n\tspdlog::set_level(spdlog::level::debug);\n#endif // _DEBUG\n\t// \u6ce8\u518c\u547d\u4ee4\u884c\n\t{\n\t\tCLI::App app{ \"\u6c49\u5316GitHub Desktop\u7ba1\u7406\u3001\u66ff\u6362\u8d44\u6e90\" };\n\n\t\t//app.require_subcommand(1);\n\n\t\t// \u5b50\u547d\u4ee4 \u5f00\u53d1\u8005\u9009\u9879\n\t\tauto dev_cmd = app.add_subcommand(\"dev\", \"\u5f00\u53d1\u8005\u9009\u9879\");\n\t\tdev_cmd->add_flag(\"-d,--dev\", _debug_goto_devoptions, \"\u8fdb\u5165\u5f00\u53d1\u8005\u9009\u9879\u8c03\u6574\u529f\u80fd(\u53ef\u5728\u5f00\u542f\u7a0b\u5e8f\u65f6\u6309\u4f4fshift\u76f4\u63a5\u8fdb\u5165)\");\n\t\tdev_cmd->add_flag(\"--mainerrorcheck\", _debug_error_check_mode_main,\t\t\t\"[\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f]\u5bf9main.js\u4ee5\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f\u8fdb\u884c\u6392\u67e5\");\n\t\tdev_cmd->add_flag(\"--rendererrorcheck\", _debug_error_check_mode_renderer,\t\"[\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f]\u5bf9renderer.js\u4ee5\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f\u8fdb\u884c\u6392\u67e5\");\n\t\tdev_cmd->add_flag(\"--invalidcheck\", _debug_invalid_check_mode,\t\t\t\t\"[\u68c0\u6d4b\u5931\u6548\u9879]\u5bf9\u672c\u5730\u5316\u6587\u4ef6\u4e2d\u7684\u5931\u6548\u66ff\u6362\u9879\u8fdb\u884c\u68c0\u6d4b\");\n\t\tdev_cmd->add_flag(\"--noreplaceres\", _debug_no_replace_res,\t\t\t\t\t\"[\u8d44\u6e90\u4e0d\u66ff\u6362]\u5f00\u542f\u540e\u4e0d\u4f1a\u5bf9\u8d44\u6e90\u8fdb\u884c\u66ff\u6362,\u4f46\u4e0d\u4f1a\u963b\u6b62[\u9519\u8bef\u68c0\u67e5\u6a21\u5f0f]\");\n\t\tdev_cmd->add_flag(\"--translationfrombak\", _debug_translation_from_bak,\t\t\"[\u4ece\u5907\u4efd\u6587\u4ef6\u4e2d\u8bfb\u53d6\u66ff\u6362]\u4f18\u5148\u4ece\u5907\u4efd\u6587\u4ef6\u4e2d\u8bfb\u53d6js\u6587\u4ef6\u5185\u5bb9\u8fdb\u884c\u66ff\u6362,\u5f00\u542f[\u68c0\u6d4b\u5931\u6548\u9879]\u65f6\u5efa\u8bae\u5f00\u542f\u6b64\u9879\");\n\t\tdev_cmd->add_flag(\"--devreplace\", _debug_dev_replace,\t\t\t\t\t\t\"[\u5f00\u53d1\u6a21\u5f0f\u66ff\u6362]\u4ec5\u66ff\u6362\u6307\u5b9a\u6620\u5c04\u4ee5\u8282\u7ea6\u6c49\u5316\u65f6\u95f4(\u4f1a\u5f71\u54cd\u5176\u4ed6\u9879)\");\n\n\n\t\tapp.add_flag(\"--nopause\", no_pause,\t\t\t\t\t\t\t\"\u7a0b\u5e8f\u5728\u7ed3\u675f\u524d\u4e0d\u518d\u6682\u505c\u7b49\u5f85\");\n\t\tapp.add_flag(\"-r,--onlyfromremote\", only_read_from_remote,\t\"\u4ec5\u4ece\u8fdc\u7a0burl\u4e2d\u8bfb\u53d6\u672c\u5730\u5316\u6587\u4ef6\");\n\t\tapp.add_option(\"-j,--json\", LocalizationJSON,\t\t\t\t\"\u6307\u5b9a\u672c\u5730\u5316JSON\u6587\u4ef6\u7684\u672c\u5730\u8def\u5f84\");\n\t\tapp.add_option(\"-g,--githubdesktoppath\", Base,\t\t\t\t\"\u6307\u5b9aGitHubDesktop\u8981\u6c49\u5316\u7684\u8d44\u6e90\u6240\u5728\u76ee\u5f55\");\n\t\t\n\t\tapp.callback([&]() {\n\t\t\t// \u624b\u52a8\u6307\u5b9a\u4e86\u672c\u5730\u5316\u6587\u4ef6\u76ee\u5f55\n\t\t\tif (!LocalizationJSON.string().empty()) {\n\t\t\t\tif (!LocalizationJSON.string().ends_with(\".json\")) {\n\t\t\t\t\tthrow CLI::ValidationError(\"(-j,--json) \u6307\u5b9a\u7684\u672c\u5730\u5316\u6587\u4ef6\u8def\u5f84\u5fc5\u987b\u4ee5.json\u7ed3\u5c3e\");\n\t\t\t\t}\n\t\t\t\tif (!fs::exists(LocalizationJSON)) {\n\t\t\t\t\tstd::ofstream io(LocalizationJSON);\n\t\t\t\t\tio << std::setw(4) << localization << std::endl;\n\t\t\t\t\tio.close();\n\t\t\t\t\tthrow CLI::ValidationError(\"(-j,--json) \u6307\u5b9a\u7684\u672c\u5730\u5316\u6587\u4ef6\u4e0d\u5b58\u5728,\u5df2\u5728\u6307\u5b9a\u4f4d\u7f6e\u521b\u5efa\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \u624b\u52a8\u6307\u5b9a\u4e86GitHubDesktop\u8d44\u6e90\u6587\u4ef6\u76ee\u5f55\n\t\t\tif (!Base.string().empty()) {\n\t\t\t\tif (!fs::exists(Base)) {\n\t\t\t\t\tthrow CLI::ValidationError(\"(-g,--githubdesktoppath) \u6307\u5b9a\u7684\u8d44\u6e90\u6587\u4ef6\u76ee\u5f55\u4e0d\u5b58\u5728\");\n\t\t\t\t}\n\t\t\t\tif (!fs::exists(Base / \"index.html\")) {\n\t\t\t\t\tthrow CLI::ValidationError(\"(-g,--githubdesktoppath) \u6307\u5b9a\u7684\u8d44\u6e90\u6587\u4ef6\u76ee\u5f55\u65e0\u6548,\u8be5\u76ee\u5f55\u4e0b\u5e94\u8be5\u662f\u5b58\u653emain.js\u548crenderer.js\u6587\u4ef6\u7684\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\tCLI11_PARSE(app, argc, argv);\n\t\tspdlog::info(\"LocalizationJSON:{}\", LocalizationJSON.string());\n\t}\n\n\t// \u5f00\u53d1\u8005\u58f0\u660e\n\tspdlog::info(\"\u5f00\u53d1\u8005\uff1aCNGEGE>2024/04/13\");\n\t\n\tif (GetKeyState(VK_SHIFT) & 0x8000 || _debug_goto_devoptions) {\n\t\t// \u5982\u679cShift\u6309\u4e0b, \u5219\u8fdb\u5165\u5f00\u53d1\u8005\u9009\u9879\n\t\tSetConsoleTitle(\"\u5f00\u53d1\u8005\u6a21\u5f0f\");\n\t\tspdlog::info(\"\u60a8\u5df2\u8fdb\u5165\u5f00\u53d1\u8005\u6a21\u5f0f\");\n\t\tDeveloperOptions();\n\t}\n\n\tif (LocalizationJSON.empty()) {\n\t\tLocalizationJSON = \"localization.json\";\n\t}\n\n\t// \u5982\u679c\u662f\u4ec5\u4ece\u8fdc\u7a0b\u4ed3\u5e93\u8bfb\u53d6\u6c49\u5316\u6587\u4ef6\n\tif (only_read_from_remote) {\n\t\tspdlog::info(\"\u5c1d\u8bd5\u4ece\u8fdc\u7a0b\u5f00\u6e90\u9879\u76ee\u4e2d\u83b7\u53d6\");\n\t\tstd::string httpjson;\n\t\tif (utils::ReadHttpDataString(\"https://raw.kkgithub.com\", \"/cngege/GitHubDesktop2Chinese/master/json/localization.json\", httpjson)) {\n\t\t\tlocalization = json::parse(httpjson);\n\t\t\tspdlog::info(\"\u8fdc\u7a0b\u8bfb\u53d6\u6210\u529f\");\n\t\t}\n\t\telse {\n\t\t\tspdlog::warn(\"\u8fdc\u7a0b\u83b7\u53d6\u5931\u8d25,\u8bf7\u68c0\u67e5\u7f51\u7edc\u548c\u4ee3\u7406,\u5e76\u7a0d\u540e\u518d\u8bd5\");\n\t\t\tPAUSE;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t// \u6ca1\u6709\u6307\u5b9a\u4ec5\u4ece\u8fdc\u7a0b\u4ed3\u5e93\u83b7\u53d6\u6c49\u5316\u6587\u4ef6\n\telse {\n\t\t// \u5224\u65ad\u6c49\u5316\u6620\u5c04\u6587\u4ef6\u662f\u5426\u5b58\u5728, \u4e0d\u5b58\u5728\u5219\u521b\u5efa\u4e00\u4e2a\n\t\tif (!fs::exists(LocalizationJSON)) {\n\t\t\t// \u6ca1\u6709\u53d1\u73b0json\u6587\u4ef6,\u5c1d\u8bd5\u4ece\u8fdc\u7a0b\u5f00\u6e90\u9879\u76ee\u4e2d\u83b7\u53d6\n\t\t\tspdlog::warn(\"\u6ca1\u6709\u6307\u5b9a,\u6216\u4ece\u6307\u5b9a\u4f4d\u7f6e\u6ca1\u6709\u53d1\u73b0 {} \u6587\u4ef6\", \"localization.json\");\n\t\t\tspdlog::info(\"\u5c1d\u8bd5\u4ece\u8fdc\u7a0b\u5f00\u6e90\u9879\u76ee\u4e2d\u83b7\u53d6\");\n\t\t\tstd::string httpjson;\n\t\t\tif (utils::ReadHttpDataString(\"https://raw.kkgithub.com\", \"/cngege/GitHubDesktop2Chinese/master/json/localization.json\", httpjson)) {\n\t\t\t\tlocalization = json::parse(httpjson);\n\t\t\t\tspdlog::info(\"\u8fdc\u7a0b\u8bfb\u53d6\u6210\u529f\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspdlog::warn(\"\u8fdc\u7a0b\u83b7\u53d6\u5931\u8d25: {}, \u5df2\u521b\u5efa\u6846\u67b6,\u8bf7\u5148\u7f16\u8f91\u521b\u5efa\u7ffb\u8bd1\u6620\u5c04\", \"localization.json\");\n\t\t\t\tstd::ofstream io(LocalizationJSON);\n\t\t\t\tio << std::setw(4) << localization << std::endl;\n\t\t\t\tio.close();\n\t\t\t\tPAUSE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// \u672c\u5730\u8bfb\u53d6\u6c49\u5316\u6587\u4ef6\u5230json\u4e2d\n\t\t\tstd::if",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nusing namespace std;\nusing namespace std::chrono;\n\nvoid bubbleSort(vector<int>& v) {\n    int n = v.size();\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (v[j] > v[j+1]) {\n                swap(v[j], v[j+1]);\n            }\n        }\n    }\n}\n\nvoid selectionSort(vector<int>& v) {\n    int n = v.size();\n    for (int i = 0; i < n-1; i++) {\n        int min_idx = i;\n        for (int j = i+1; j < n; j++) {\n            if (v[j] < v[min_idx]) {\n                min_idx = j;\n            }\n        }\n        swap(v[i], v[min_idx]);\n    }\n}\n\nvoid insertionSort(vector<int>& v) {\n    int n = v.size();\n    for (int i = 1; i < n; i++) {\n        int key = v[i];\n        int j = i - 1;\n        while (j >= 0 && v[j] > key) {\n            v[j+1] = v[j];\n            j = j - 1;\n        }\n        v[j+1] = key;\n    }\n}\n\nvoid shellSort(vector<int>& v) {\n    int n = v.size();\n    for (int gap = n/2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = v[i];\n            int j;\n            for (j = i; j >= gap && v[j - gap] > temp; j -= gap) {\n                v[j] = v[j - gap];\n            }\n            v[j] = temp;\n        }\n    }\n}\n\nint partition(vector<int>& v, int low, int high) {\n    int pivot = v[high];\n    int i = low - 1;\n    for (int j = low; j <= high - 1; j++) {\n        if (v[j] < pivot) {\n            i++;\n            swap(v[i], v[j]);\n        }\n    }\n    swap(v[i + 1], v[high]);\n    return i + 1;\n}\n\nvoid quickSort(vector<int>& v, int low, int high) {\n    if (low < high) {\n        int pi = partition(v, low, high);\n        quickSort(v, low, pi - 1);\n        quickSort(v, pi + 1, high);\n    }\n}\n\nvoid merge(vector<int>& v, int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    vector<int> L(n1), R(n2);\n\n    for (int i = 0; i < n1; i++) {\n        L[i] = v[l + i];\n    }\n    for (int j = 0; j < n2; j++) {\n        R[j] = v[m + 1 + j];\n    }\n\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            v[k] = L[i];\n            i++;\n        } else {\n            v[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        v[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        v[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(vector<int>& v, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    int m = l + (r - l) / 2;\n    mergeSort(v, l, m);\n    mergeSort(v, m + 1, r);\n    merge(v, l, m, r);\n}\n\nint main() {\n    srand(time(NULL));\n\n    vector<int> sizes = {10, 100, 1000, 10000, 100000, 1000000};\n\n    for (int n : sizes) {\n        vector<int> v(n);\n        \n        for (int i = 0; i < n; ++i) {\n            v[i] = rand() % 1000000;\n        }\n\n        auto start = high_resolution_clock::now();\n        \n        // Bubble Sort\n        vector<int> v1 = v;\n        bubbleSort(v1);\n\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast<microseconds>(stop - start);\n        cout << \"Bubble Sort (\" << n << \"): \" << duration.count() << \" microseconds\" << endl;\n\n        // Selection Sort\n        vector<int> v2 = v;\n        start = high_resolution_clock::now();\n        selectionSort(v2);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<microseconds>(stop - start);\n        cout << \"Selection Sort (\" << n << \"): \" << duration.count() << \" microseconds\" << endl;\n\n        // Insertion Sort\n        vector<int> v3 = v;\n        start = high_resolution_clock::now();\n        insertionSort(v3);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<microseconds>(stop - start);\n        cout << \"Insertion Sort (\" << n << \"): \" << duration.count() << \" microseconds\" << endl;\n\n        // Shell Sort\n        vector<int> v4 = v;\n        start = high_resolution_clock::now();\n        shellSort(v4);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<microseconds>(stop - start);\n        cout << \"Shell Sort (\" << n << \"): \" << duration.count() << \" microseconds\" << endl;\n\n        // Quick Sort\n        vector<int> v5 = v;\n        start = high_resolution_clock::now();\n        quickSort(v5, 0, n - 1);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<microseconds>(stop - start);\n        cout << \"Quick Sort (\" << n << \"): \" << duration.count() << \" microseconds\" << endl;\n\n        // Merge Sort\n        vector<int> v6 = v;\n        start = high_resolution_clock::now();\n        mergeSort(v6, 0, n - 1);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<microseconds>(stop - start);\n        cout << \"Merge Sort (\" << n << \"): \" << duration.count() << \" microseconds\" << endl;\n\n        v.clear();\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n                            //Mohammad Hashim's Code\n// All Rights Reserved. Copyright (c) 2024 Mohammad Hashim - ByteMazeHashim\n\nusing namespace std;\n\nclass Train {\nprivate:\n    int trainID;\n    string name;\n    string origin;\n    string destination;\n    string departureTime;\n    string arrivalTime;\n\npublic:\n    Train(int id, const string& n, const string& ori, const string& dest, const string& depTime, const string& arrTime)\n        : trainID(id), name(n), origin(ori), destination(dest), departureTime(depTime), arrivalTime(arrTime) {}\n\n    int getTrainID() const { return trainID; }\n    string getName() const { return name; }\n    string getOrigin() const { return origin; }\n    string getDestination() const { return destination; }\n    string getDepartureTime() const { return departureTime; }\n    string getArrivalTime() const { return arrivalTime; }\n\n    void setName(const string& newName) { name = newName; }\n    void setOrigin(const string& newOrigin) { origin = newOrigin; }\n    void setDestination(const string& newDest) { destination = newDest; }\n    void setDepartureTime(const string& newDepTime) { departureTime = newDepTime; }\n    void setArrivalTime(const string& newArrTime) { arrivalTime = newArrTime; }\n};\n\nclass Booking {\nprivate:\n    int bookingID;\n    int trainID;\n    string passengerName;\n    char gender;\n    string className;\n    int seatNumber;\n\npublic:\n    Booking(int tID, const string& name, char gen, const string& cls, int seat)\n        : trainID(tID), passengerName(name), gender(gen), className(cls), seatNumber(seat) {}\n\n    int getTrainID() const { return trainID; }\n    string getPassengerName() const { return passengerName; }\n    char getGender() const { return gender; }\n    string getClassName() const { return className; }\n    int getSeatNumber() const { return seatNumber; }\n\n    void setPassengerName(const string& newName) { passengerName = newName; }\n    void setGender(char newGender) { gender = newGender; }\n    void setClassName(const string& newClass) { className = newClass; }\n    void setSeatNumber(int newSeatNumber) { seatNumber = newSeatNumber; }\n};\n\nvector<string> split(const string& str, char delimiter) {\n    vector<string> tokens;\n    stringstream ss(str);\n    string token;\n    while (getline(ss, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}//Hashim\n\nvector<Train> loadTrainsFromFile(const string& filename) {\n    vector<Train> trains;\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cout << \"No existing train details found.\" << endl;\n        return trains;\n    }\n\n    string line;\n    while (getline(file, line)) {\n        vector<string> tokens = split(line, ',');\n        if (tokens.size() == 6) {\n            int trainID = stoi(tokens[0]);\n            string name = tokens[1];\n            string origin = tokens[2];\n            string destination = tokens[3];\n            string departureTime = tokens[4];\n            string arrivalTime = tokens[5];\n            trains.push_back(Train(trainID, name, origin, destination, departureTime, arrivalTime));\n        }\n    }\n    file.close();\n    return trains;\n}\n\nvoid displayTrains(const vector<Train>& trains, const string& destination, const string& departureTime) {\n    bool found = false;\n    cout << \"\\nTrains from \" << destination << \" departing at \" << departureTime << \":\" << endl;\n    cout << setw(8) << left << \"Train ID\" << setw(25) << left << \"Train Name\" << setw(15) << left << \"Origin\" \n         << setw(20) << left << \"Destination\" << setw(15) << left << \"Departure\" << setw(15) << left << \"Arrival\" << endl;\n    cout << setfill('-') << setw(98) << \"-\" << setfill(' ') << endl;\n    for (const auto& train : trains) {//Hashim\n        if (train.getDestination() == destination && train.getDepartureTime() == departureTime) {\n            cout << setw(8) << left << train.getTrainID() << setw(25) << left << train.getName() \n                 << setw(15) << left << train.getOrigin() << setw(20) << left << train.getDestination() \n                 << setw(15) << left << train.getDepartureTime() << setw(15) << left << train.getArrivalTime() << endl;\n            found = true;\n        }\n    }\n    if (!found) {\n        cout << \"No trains found matching the criteria.\" << endl;\n    }\n}\n\nvoid addNewTrain(const string& filename, const Train& train) {\n    ofstream file(filename, ios::app);\n    if (!file.is_open()) {\n        cout << \"Error: Unable to open file for writing.\" << endl;\n        return;\n    }\n    file << train.getTrainID() << \",\" << train.getName() << \",\" << train.getOrigin() << \",\" << train.getDestination()\n         << \",\" << train.getDepartureTime() << \",\" << train.getArrivalTime() << endl;\n    file.close();\n}\n\nvoid modifyTrain(vector<Train>& trains, int trainID) {\n    auto it = find_if(trains.begin(), trains.end(),",
    "\ufeff#include<iostream>\r\n#include<Windows.h>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\twhile(true)\r\n\t{\r\n\t\tint choose;\r\n\t\tcout << \"\u8bf7\u6ce8\u610f\uff1a\u5728\u4f7f\u7528\u672c\u529f\u80fd\u524d\u5c06\u8981\u8f70\u70b8\u5bf9\u65b9\u7684\u6587\u5b57\u3001\u56fe\u7247\u590d\u5236\u597d\uff0c\u5e76\u5c06\u5bf9\u65b9\u7684\u7a97\u53e3\u6253\u5f00\u4e14\u4f7f\u5149\u6807\u5728\u8f93\u5165\u6846\u5185\u95ea\u52a8\u3002\" << endl;\r\n\t\tSleep(1200);\r\n\r\n\t\tint j = 1;\r\n\t\tint outnumber;\r\n\r\n\t\tcout << \"\u8bf7\u6682\u65f6\u5c06\u5bf9\u65b9\u7684\u5907\u6ce8\u6539\u4e3a\u201cname\u201d\" << endl;\r\n\r\n\t\tHWND hwnd = FindWindow(L\"TXGuiFoundation\", L\"name\");\r\n\r\n\t\tcout << \"\u8bbe\u7f6e\u4f60\u60f3\u8f93\u51fa\u7684\u6b21\u6570(\u975e\u6cd5\u8f93\u5165\u5c06\u5bfc\u81f4\u7a0b\u5e8f\u7ec8\u6b62)\" << endl;\r\n\t\tcin >> outnumber;\r\n\r\n\t\twhile (cin.fail())\r\n\t\t{\r\n\t\t\tcout << \"\u68c0\u6d4b\u5230\u975e\u6cd5\u8f93\u5165,\u7a0b\u5e8f\u7ec8\u6b62\" << endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tfor (int i = 0;i <= outnumber;i++)\r\n\t\t{\r\n\t\t\tSendMessage(hwnd, WM_PASTE, 0, 0);\r\n\t\t\tSendMessage(hwnd, WM_KEYDOWN, VK_RETURN, 0);\r\n\t\t\twhile (j <= outnumber)\r\n\t\t\t{\r\n\t\t\t\tcout << \"\u8fd9\u662f\u7b2c\" << j << \"\u6b21\u8f70\u70b8\" << endl;\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout << \"********************************\" << endl;\r\n\t\tcout << \"\u5982\u82e5\u60f3\u7ed3\u675f\u7a0b\u5e8f\u8bf7\u9009\u62e9ture(\u975e\u6cd5\u8f93\u5165\u5c06\u5bfc\u81f4\u7a0b\u5e8f\u7ec8\u6b62)\" << endl;\r\n\t\tcout << \"false\uff08\u9ed8\u8ba4\uff09\" << endl;\r\n\t\tcout << \"1.ture\" << endl;\r\n\t\tcin >> choose;\r\n\r\n\t\twhile (cin.fail())\r\n\t\t{\r\n\t\t\tcout << \"\u68c0\u6d4b\u5230\u975e\u6cd5\u8f93\u5165,\u7a0b\u5e8f\u7ec8\u6b62\" << endl;\r\n\t\t\treturn -2;\r\n\t\t}\r\n\r\n\t\tif (choose==1)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n",
    "// clang-format off\n#include <string.h>\n#include \"CrazyEyes.hpp\"\n#include \"M5DialEncoder.hpp\"\n// clang-format on\n\nconst char* CrazyEyes::VERSION = \"v0.0.2\";\n\nextern const uint8_t OPEN_EYE_START[] asm(\n    \"_binary_data_crazy_eyes_open_jpg_start\");\nextern const uint8_t OPEN_EYE_END[] asm(\"_binary_data_crazy_eyes_open_jpg_end\");\nstatic const size_t OPEN_EYE_SIZE = (OPEN_EYE_END - OPEN_EYE_START);\n\nextern const uint8_t CLOSE_EYE_START[] asm(\n    \"_binary_data_crazy_eyes_close_jpg_start\");\nextern const uint8_t CLOSE_EYE_END[] asm(\n    \"_binary_data_crazy_eyes_close_jpg_end\");\nstatic const size_t CLOSE_EYE_SIZE = (CLOSE_EYE_END - CLOSE_EYE_START);\n\nstatic const int32_t TEXT_AREA_X = 35;\nstatic const int32_t TEXT_AREA_Y = 35;\nstatic const int32_t TEXT_AREA_WIDTH = 170;\nstatic const int32_t TEXT_AREA_HEIGHT = 170;\n\nstatic M5DialEncoder encoder;\nstatic int16_t prev_dial_pos = 0;\n\ninline void M5_BEGIN(m5::M5Unified::config_t cfg) {\n    M5.begin(cfg);\n    encoder.begin();\n}\n\ninline void M5_BEGIN(void) {\n    auto cfg = M5.config();\n    M5_BEGIN(cfg);\n}\n\ninline void M5_UPDATE(void) {\n    M5.update();\n}\n\ninline int16_t getDirection(void) {\n    const int16_t pos = encoder.read();\n    M5_LOGV(\"Dial: %d -> %d\", prev_dial_pos, pos);\n    if (abs(prev_dial_pos - pos) >= 4) {\n        const int16_t direction = pos - prev_dial_pos > 0 ? 1 : -1;\n        prev_dial_pos = pos;\n        return direction;\n    } else {\n        return 0;\n    }\n}\n\nCrazyEyes::CrazyEyes(void)\n    : _isOpenEye(true),\n      _prevUpdate(0),\n      _isAutoMode(false),\n      _interval(AUTO_INTERVAL_MS) {\n}\n\nCrazyEyes::~CrazyEyes(void) {\n}\n\nbool CrazyEyes::begin(int bgColor) {\n    M5_BEGIN();\n\n#if defined(CRAZY_EYES_ORIENTATION)\n    M5.Lcd.setRotation(CRAZY_EYES_ORIENTATION);\n#else\n    M5.Lcd.setRotation(0);\n#endif\n\n    M5.Lcd.setTextScroll(true);\n    M5.Lcd.setCursor(TEXT_AREA_X, TEXT_AREA_Y);\n    M5.Lcd.setScrollRect(TEXT_AREA_X, TEXT_AREA_Y, TEXT_AREA_WIDTH,\n                         TEXT_AREA_HEIGHT);\n\n    M5.Lcd.printf(\"Crazy Eyes %s\", VERSION);\n    M5.Lcd.println();\n\n    M5.Lcd.println(\"Config:\");\n    M5.Lcd.printf(\" AutoMode: %s\", this->_isAutoMode ? \"true\" : \"false\");\n    M5.Lcd.println();\n    M5.Lcd.printf(\" Interval: %dms\", this->_interval);\n    M5.Lcd.println();\n\n    M5.Lcd.println(\"Mode:\");\n    M5_UPDATE();\n    if (M5.BtnA.isPressed()) {\n        this->_isAutoMode = true;\n    }\n    M5.Lcd.printf(\" %s\", this->_isAutoMode ? \"Auto\" : \"Manual\");\n    M5.Lcd.println();\n\n    M5.Lcd.println(\"Orientation:\");\n#if defined(CRAZY_EYES_ORIENTATION)\n    M5.Lcd.printf(\" %s Eye\", CRAZY_EYES_ORIENTATION == RIGHT_EYE_ORIENTATION\n                                 ? \"Right\"\n                                 : \"Left\");\n#else\n    M5.Lcd.printf(\" %s\", \"Manual\");\n#endif\n    M5.Lcd.println();\n    delay(START_INTERVAL_MS);\n\n    M5.Lcd.clearScrollRect();\n    M5.Lcd.setCursor(0, 0);\n\n    M5.Lcd.clear();\n    M5.Lcd.fillScreen(bgColor);\n\n#if !defined(CRAZY_EYES_ORIENTATION)\n    M5.Lcd.setRotation(RIGHT_EYE_ORIENTATION);\n#endif\n\n    if (!this->_isAutoMode) {\n        showEye();\n    }\n\n    return true;\n}\n\nbool CrazyEyes::update(void) {\n    M5_UPDATE();\n\n    if (M5.BtnA.wasClicked()) {\n#if defined(CRAZY_EYES_ORIENTATION)\n        this->_isAutoMode = !this->_isAutoMode;\n#else\n        M5.Lcd.setRotation(toggleOrientation(M5.Lcd.getRotation()));\n        showEye();\n#endif\n    }\n\n    const uint32_t t = millis();\n    int32_t direction = getDirection();\n    if (direction == 0 && this->_isAutoMode &&\n        t - this->_prevUpdate >= this->_interval) {\n        direction = 1;\n    }\n    if (direction != 0) {\n        this->_prevUpdate = t;\n        this->_isOpenEye = !this->_isOpenEye;\n        showEye();\n    }\n    return direction != 0;\n}\n\nuint8_t CrazyEyes::toggleOrientation(uint8_t orientation) const {\n    return orientation == RIGHT_EYE_ORIENTATION ? LEFT_EYE_ORIENTATION\n                                                : RIGHT_EYE_ORIENTATION;\n}\n\nvoid CrazyEyes::showEye(void) {\n    M5.Lcd.startWrite();\n    if (this->_isOpenEye) {\n        M5.Lcd.drawJpg(OPEN_EYE_START, OPEN_EYE_SIZE, 0, 0, M5.Display.width(),\n                       M5.Display.height(), 0, 0, 0.0F, 0.0F, middle_center);\n    } else {\n        M5.Lcd.drawJpg(CLOSE_EYE_START, CLOSE_EYE_SIZE, 0, 0,\n                       M5.Display.width(), M5.Display.height(), 0, 0, 0.0F,\n                       0.0F, middle_center);\n    }\n    M5.Lcd.endWrite();\n}\n",
    "\n#ifndef S_FILES_LIB_CPP\n#define S_FILES_LIB_CPP\n\n#include \"s_files.hpp\"\n\nuint32_t get_file_size(FILE *fp){\n    int prev=ftell(fp);\n    fseek(fp, 0L, SEEK_END);\n    uint32_t sz= uint32_t(ftell(fp));\n    fseek(fp,prev,SEEK_SET); //go back to where we were\n    return sz;\n}\n\nfile s_files::read_from_file( \n    std::string const& file_path , bool read_as_binary \n){\n    \n    file file_object = {0};\n\n    // try to open target file\n    std::FILE* handle = nullptr; \n    handle = fopen(file_path.c_str() , ((read_as_binary) ? \"rb\" : \"r\"));\n\n    // copy file data to buffer\n    if(handle != nullptr) {\n    \n        file_object.size = uint32_t(get_file_size(handle));\n        file_object.buffer = (void*)(new uint8_t[file_object.size]);\n\n        uint32_t readed = fread(file_object.buffer, 1/*byte*/, file_object.size, handle);\n\n        // close file after copying\n        fclose(handle);\n    }\n\n    return file_object;\n}\n\nbool s_files::write_to_file(\n    std::string const& file_path, void* buffer, uint32_t size, bool append\n){\n    \n    // try to open file\n    std::FILE* handle = nullptr;\n    handle = fopen(file_path.c_str() , (append ? \"a\" : \"w\") );\n\n    // try to write to file\n    if(handle != nullptr) {\n        // fwrite( const void* buffer, std::size_t size, std::size_t count, std::FILE* stream );\n        size_t write_result = NULL;\n        write_result = fwrite(buffer , 1 , size , handle);\n        \n        // close file after writing\n        fclose(handle);\n    \n        return (write_result != NULL);\n    }\n    \n    return false;\n}\n\nbool s_files::write_to_file(\n    std::FILE* file_pointer, void* buffer, uint32_t size, bool append\n){\n    \n    // try to write to file\n    if(file_pointer != nullptr) {\n        size_t write_result = NULL;\n        write_result = fwrite(buffer , 1 , size , file_pointer);\n        \n        return (write_result != NULL);\n    }\n    \n    return false;\n}\n\n\nstd::FILE* s_files::open_file(std::string const& file_path , std::string const& permission){\n     \n    // try to open file\n    std::FILE* handle = nullptr; \n    handle = fopen(file_path.c_str() , permission.c_str());\n\n    return handle;\n}\n\nstd::FILE* s_files::create_file(std::string const& file_path ){\n     \n    // try to open file\n    std::FILE* handle = nullptr; \n    handle = fopen(file_path.c_str() , \"w\");\n\n    return handle;\n}\n\nbool s_files::delete_file(std::string const& file_path){\n    // int remove(const char *filename)\n   return (remove(file_path.c_str()) == 0);\n}\n\n#endif\n",
    "#include \"r_data_m.h\"\n#include \"c_data_m.h\"\n#include \"VideoStore.h\" //file/headers\n\nusing namespace std;\n\nr_data_m::r_data_m() { // calling constructor to start and read file, simultaneously adding them to queue\n    readfile();\n}\n\nvoid r_data_m::rentalinfoget(int customerid, int videoid) {\n    rentalstack.push(make_pair(customerid, videoid));\n    cout << \"\\t\\t\\t\\t ******* Renting: Customer ID - \" << customerid << \", Video ID - \" << videoid << \" ******* \" << endl << endl;\n    rentalinfosave();                                           \n}                                                           // something in the rental code prevents the \"save at end of program\"\n                                                            // clause from functioning properly, so it's called here\nvoid r_data_m::rentalinfosave() {\n    ofstream myfile(\"rental.txt\");                          // adds everything in the queue to the file by popping em\n    if (!myfile) {\n        cout << \">> Error opening the file.\" << endl;\n        return;\n    }\n    myfile << \"----------------------------------------------\" << endl; // headers used for design on .txt file\n    myfile << \"         Customer ID | Movie ID\" << endl;\n    myfile << \"----------------------------------------------\" << endl;\n\n    stack<pair<int, int>> tempstack(rentalstack);                       // calling a temp stack to preserve rental queue\n    while (!tempstack.empty()) {                                        // if rentalinfosave isn't called at end of program\n        pair<int, int> rental = tempstack.top();\n        tempstack.pop();                         \n\n        myfile << rental.first << \" | \" << rental.second << endl;\n    }\n\n    myfile.close();\n}\n\nvoid r_data_m::readfile() {     // file reading function\n    ifstream file(\"rental.txt\");\n    if (!file) {\n        cout << \" \\t\\t\\t\\t\\t******* Error opening the file. ******* \" << endl;\n        return;\n    }\n    \n    while (!rentalstack.empty()) { // clears the existing rental stack just in case (as readfile is called multiple times)\n        rentalstack.pop();         // to ensure inter-class data transfer is completed properly\n    }\n\n    string line;                    // skips the header lines used for design\n    getline(file, line);\n    getline(file, line);\n    getline(file, line);\n\n    while (getline(file, line)) {               // a pair container is used for the stack stl as the adt only uses\n        pair<int, int> rental;                  // two data, and they're both int. the rest of the data are called\n        string delimiter = \" | \";               // from their respective classes, like the names.\n                                                // only ids are saved in the rental file\n        size_t pos = 0;\n        pos = line.find(delimiter);\n        rental.first = stoi(line.substr(0, pos));\n\n        line.erase(0, pos + delimiter.length());\n        pos = line.find(delimiter);\n        rental.second = stoi(line.substr(0, pos));\n\n        rentalstack.push(rental);\n    }\n\n    file.close();\n}\n\nvoid r_data_m::rentalinfodelete(int customerID, int videoID) { // rental function, deletes on .txt file\n    stack<pair<int, int>> tempstack;\n    while (!rentalstack.empty()) {                             // create temporary stack so rentalstack can be recreated after\n        pair<int, int> rental = rentalstack.top();\n        rentalstack.pop();\n\n        if ((rental.first == customerID) && (rental.second == videoID)) {\n            cout << \"\\t\\t\\t\\t\\tReturned: Customer ID - \" << rental.first << \", Video ID - \" << rental.second << endl;\n            continue;\n        }\n            tempstack.push(rental);                         // theoretically, only pushing the non-matching ones to the stack should work\n        }\n\n    while (!tempstack.empty()) {\n        pair<int, int> rental = tempstack.top();\n        tempstack.pop();\n        rentalstack.push(rental);\n    }\n\n    rentalinfosave();                                       // called immediately just to make sure the rental.txt saves properly\n}\n\nvoid r_data_m::customerrentalview(int customerID) {         // inter-class function to check for customer id, movie title, and more\n    c_data_m c_data_access;                                 // provides access to the different class files\n    VideoStore v_data_access;\n    bool rented = false;\n    \n    c_data_access.readfile();\n    v_data_access.loadVideoData(\"videos.txt\");\n    cout << \"\\t\\t\\t\\t\\tChecking for Account Number \" << customerID << \"...\" << endl;\n    if(c_data_access.showcustomerdata(customerID)==customerID){ // checks to see if customer id inputted exists on customerdata.txt\n    \n    stack<pair<int, int>> tempstack;\n    while (!rentalstack.empty()) {                              // temp stack to not damage the actual stack\n        pair<int, int> rental = rentalstack.top();\n        rentalstack.pop();\n\n        if (rental.first == customerID) {                       // checks to see if customer id matches with any of the rental ids\n      ",
    "#include <algorithm>\n#include <cstdio>\n#include <fstream>\n#include <iostream>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nclass Book {\nprotected:\n  vector<vector<string>> books = {{\"The Alchemist\", \"1\", \"200\"},\n                                  {\"The Great Gatsby\", \"2\", \"300\"},\n                                  {\"To Kill a Mockingbird\", \"3\", \"400\"},\n                                  {\"Pride and Prejudice\", \"4\", \"500\"},\n                                  {\"1984\", \"5\", \"600\"},\n                                  {\"The Catcher in the Rye\", \"6\", \"700\"}};\n\npublic:\n  void display_books() {\n    cout << \"Book Details\" << endl << endl;\n    cout << \"Book 1:\" << endl << endl;\n    for (int i = 0; i < books.size(); i++) {\n      for (int j = 0; j < books[i].size(); j++) {\n        cout << books[i][j] << '\\n';\n      }\n      cout << endl << endl;\n      cout << \"Book\" << i + 1 << \":\" << endl << endl;\n    }\n  }\n};\n\nclass Account { // Account class//\npublic:\n  string account_name;\n  char password[30];\n  string email;\n  string address;\n  char verify_password[30];\n  string file_name;\n\n  void login() { // login function//\n\n    cout << \"\\nEnter your account name: \";\n    cin >> account_name;\n    cout << \"\\nEnter your password: \";\n    cin >> password;\n    file_name = account_name + \".txt\";\n    ifstream user_file(file_name);\n    if (user_file.is_open()) {\n      user_file.getline(verify_password, 30);\n      if (strcmp(password, verify_password) == 0) {\n        cout << \"Login Successful\" << endl;\n      } else {\n        cout << \"Login Failed\" << endl;\n        login();\n      }\n    } else {\n      cerr << \"Account does not exist\" << endl;\n      cout << \"Sign up\" << endl;\n      sign_up();\n    }\n  }\n\n  void sign_up() { // sign up function//\n\n    cout << \"Enter your email id:\";\n    cin >> email;\n    cout << \"\\nEnter your account name: \";\n    cin >> account_name;\n    cout << \"\\nEnter your password: \";\n    cin >> password;\n    cout << \"\\nenter your password again: \";\n    cin >> verify_password;\n    cout << \"\\nEnter your address: \";\n    cin >> address;\n    if (strcmp(password, verify_password) == 0) {\n      file_name = account_name + \".txt\";\n      ofstream user_file(file_name);\n      user_file << verify_password << endl;\n      user_file << account_name << endl;\n      user_file << email << endl;\n      user_file << address << endl; \n      user_file << endl;\n      user_file << \"Books Rented: \" << endl;\n      user_file << endl;\n      user_file.close();\n      cout << \"Account created successfully\" << endl;\n    } else {\n      cout << \"Passwords do not match\" << endl;\n    }\n  }\n\n  void change_account_name() { // to change account name//\n\n    string line;\n    int line_number = 0;\n    string new_file_txt = \"input.txt\";\n    string new_account_name;\n\n    cout << \"Enter your new account name: \";\n    cin >> new_account_name;\n\n    ifstream user_file(file_name);\n    ofstream new_file(new_file_txt);\n\n    while (getline(user_file, line)) {\n      line_number++;\n      if (account_name == line) {\n        new_file << new_account_name << endl;\n        cout << \"\\nAccount name changed successfully\" << endl;\n      } else {\n        new_file << line << endl;\n      }\n    }\n    user_file.close();\n    new_file.close();\n    remove(file_name.c_str());\n    rename(new_file_txt.c_str(), file_name.c_str());\n  }\n\n  void change_password() { // to change password//\n    string line;\n    int line_number = 0;\n    string new_file_txt = \"input.txt\";\n    char new_password[30];\n\n    cout << \"Enter your new password: \";\n    cin >> new_password;\n\n    ifstream user_file(file_name);\n    ofstream new_file(new_file_txt);\n\n    while (getline(user_file, line)) {\n      line_number++;\n      if (password == line) {\n        new_file << new_password << endl;\n        cout << \"\\nPassword changed successfully\" << endl;\n      } else {\n        new_file << line << endl;\n      }\n    }\n    user_file.close();\n    new_file.close();\n    remove(file_name.c_str());\n    rename(new_file_txt.c_str(), file_name.c_str());\n  }\n\n  void change_email() { // to change email//\n    string line;\n    int line_number = 0;\n    string new_file_txt = \"input.txt\";\n    string new_email;\n\n    cout << \"Enter your new email: \";\n    cin >> new_email;\n\n    ifstream user_file(file_name);\n    ofstream new_file(new_file_txt);\n\n    while (getline(user_file, line)) {\n      line_number++;\n      if (email == line) {\n        new_file << new_email << endl;\n        cout << \"\\nEmail changed successfully\" << endl;\n      } else {\n        new_file << line << endl;\n      }\n    }\n    user_file.close();\n    new_file.close();\n    remove(file_name.c_str());\n    rename(new_file_txt.c_str(), file_name.c_str());\n  }\n};\n\nclass Library_System : public Account, public Book {\n\npublic:\n  Library_System() {\n    cout << \"Welcome to the library\" << endl;\n    cout << \"_______ __ ___ _______\" << endl;\n    int confirmation;\n    cout << \"\\n1)Do you want to sign up?\\n2)Do you want to login?\\n\";\n    cin >> confirmation;\n    if (confirmation == 1) {\n      cout << ",
    "#pragma once\n\n#include \"lexer/lexer.hpp\"\n#include \"program/vm_options.hpp\"\n\n#include <functional>\n\nvoid reserved_err(std::string _res) {\n    err_begin();\n    std::cerr << \"Cannot use reserved word \\\"\" << _res << \"\\\" to be an identifier.\";\n    err_end();\n}\n\nvoid Lexer::break_whitespace() {\n    while (_at < _input.length() && isspace(_input.at(_at))) {\n        if (_input.at(_at) == '\\n') {\n            _line++;\n            _column = 0;\n        }\n        else {\n            _column++;\n        }\n        _at++;\n\n    }\n}\n\nstd::string Lexer::read_identifier() {\n    std::string res = \"\";\n    while (isalnum(_input.at(_at)) || _input.at(_at) == '_') {\n        res += _input.at(_at);\n        _column++;\n        _at++;\n    }\n}\n\nstd::pair<std::string, Token::Type> Lexer::read_number() {\n    std::function<bool(char)> isValid = [](char ch)->bool {\n        return isdigit(ch) || ch == '.';\n    };\n    std::string res;\n    if (_input.at(_at) == '0') {\n        if (_input.at(_at + 1) == 'x') {\n            isValid = [](char ch)->bool {\n                return isdigit(ch) || ('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F');\n            };\n            _column += 2;\n            _at += 2;\n            res = \"0x\";\n        }\n        else if (_input.at(_at + 1) == 'b') {\n            isValid = [](char ch)->bool {\n                return ch == '0' || ch == '1';\n            };\n            _column += 2;\n            _at += 2;\n            res = \"0b\";\n        }\n        else if (isdigit(_input.at(_at + 1))) {\n            isValid = [](char ch)->bool {\n                return '0' <= ch && ch <= '7';\n            };\n            _column++;\n            _at++;\n            res = \"0\";\n        }\n        else if (_input.at(_at + 1) != '.') {\n            return std::make_pair(\"0\", Token::Type::Integer);\n        }\n    }\n    while (isValid(_input.at(_at))) {\n        res += _input.at(_at);\n        _column++;\n        _at++;\n    }\n    if (res.at(res.length() - 1) == '.') {\n        res = res.substr(0, res.length() - 1);\n        _at--;\n        _column--;\n    }\n    return std::make_pair(res, (res.find('.') != res.npos) ? Token::Type::Float : Token::Type::Integer);\n}\n\nstd::string Lexer::read_string() {\n    std::string res = \"\\\"\";\n    _column++;\n    _at++;\n    while (_input.at(_at) != '\"') {\n        if (_input.at(_at) == '\\\\') {\n            res += '\\\\';\n            res += _input.at(_at + 1);\n            _column += 2;\n            _at += 2;\n            continue;\n        }\n        res += _input.at(_at);\n        _column++;\n        _at++;\n    }\n    _column++;\n    _at++;\n    return res + '\"';\n}\n\nstd::shared_ptr<Token> Lexer::parseNext() {\n    // Break whitespace\n    break_whitespace();\n    // Return \"End\" when end.\n    if (_input.length() == _at) {\n        return std::make_shared<Token>(\"\", Token::Type::End);\n    }\n    // Ignore comments.\n    if (_input.length() > _at + 1 && _input.at(_at) == '#' && _input.at(_at + 1) == '!') {\n        while (_input.length() > _at && _input.at(_at) != '\\n') {\n            _at++;\n        }\n        _at++;\n        _line++;\n        _column = 0;\n    } // UNIX <#!/path/to/mpcc>\n    if (_input.length() > _at + 1 && _input.at(_at) == '/') {\n        if (_input.at(_at + 1) == '/') {\n            while (_input.length() > _at && _input.at(_at) != '\\n') {\n                _at++;\n            }\n            _at++;\n            _line++;\n            _column = 0;\n        } // In-line comment\n        else if (_input.at(_at + 1) == '*') {\n            _at += 2;\n            _column += 2;\n            while (_input.length() > _at) {\n                if (_input.at(_at) == '*' && _input.length() > (_at + 1)) {\n                    if (_input.at(_at + 1) == '/') {\n                        _at += 2;\n                        break;\n                    }\n                }\n                if (_input.at(_at) == '\\n') {\n                    _line++;\n                    _column = 0;\n                }\n                else {\n                    _column++;\n                }\n                _at++;\n            }\n        } // Out-line comment\n    }\n    // Try non-identifier tokens.\n    switch (_input.at(_at)) {\n    case '~':\n        _column++;\n        _at++;\n        return std::make_shared<Token>(\"~\", Token::Type::BitwiseNot);\n    case '!':\n        if (_input.length() > _at + 1 && _input.at(_at + 1) == '=') {\n            _column += 2;\n            _at += 2;\n            return std::make_shared<Token>(\"!=\", Token::Type::NotEqual);\n        }\n        _column++;\n        _at++;\n        return std::make_shared<Token>(\"!\", Token::Type::LogicalNot);\n    case '$':\n        _column++;\n        _at++;\n        return std::make_shared<Token>(\"$\", Token::Type::Lambda);\n    case '%':\n        if (_input.length() > _at + 1 && _input.at(_at + 1) == '=') {\n            _column += 2;\n            _at += 2;\n            return std::make_shared<Token>(\"%=\", Token::Type::ModulusAssign);\n        }\n        _column++;\n        _at++;\n        return std::make_shared<Token>(\"%\", Token::Type::Modulus);\n    case '^':\n        if",
    "// toled.h - Tiny OLED driver (only 128x32, only I2C, only for ESP32)\n#include <Arduino.h> // Serial.printf\n#include <Wire.h>    // Wire.write\n#include \"toled.h\"   // own\n\n\n#define TOLED_SIZE     (TOLED_WIDTH*TOLED_HEIGHT/8)\n#define I2CADDR        0x3C\n\n\nstatic uint8_t toled_framebuf[TOLED_SIZE];\n// Frame buffer layout of the OLED with 128 columns and 32 rows\n//      0     1     2        127\n//    +---+ +---+ +---+     +---+\n//  0 |LSB| |   | |   |     |   |\n//  : | 0 | | 1 | | 2 | ... |127|\n//  7 |MSB| |   | |   |     |   |\n//    +---+ +---+ +---+     +---+\n//    +---+ +---+ +---+     +---+\n//  8 |   | |   | |   |     |   |\n//  : |128| |   | |   | ... |255|\n// 15 |   | |   | |   |     |   |\n//    +---+ +---+ +---+     +---+\n//    +---+ +---+ +---+     +---+\n// 16 |   | |   | |   |     |   |\n//  : |256| |   | |   | ... |383|\n// 23 |   | |   | |   |     |   |\n//    +---+ +---+ +---+     +---+\n//    +---+ +---+ +---+     +---+\n// 24 |   | |   | |   |     |   |\n//  : |384| |   | |   | ... |511|\n// 32 |   | |   | |   |     |   |\n//    +---+ +---+ +---+     +---+\n\n\n// Applies msk to toled_framebuf[loc] using col\nstatic inline void toled_framebuf_mask(int loc, int msk, int col) {\n  switch( col ) {\n    case TOLED_COL_WHITE: toled_framebuf[loc] |=  msk; break;\n    case TOLED_COL_BLACK: toled_framebuf[loc] &= ~msk; break;\n    case TOLED_COL_FLIP : toled_framebuf[loc] ^=  msk; break;\n  }\n}\n\n\n// === I2C REGISTERS ======================================\n\n\n// Commands of the SSD1306 OLED\n// See https://iotexpert.com/debugging-ssd1306-display-problems/\n\n// See datasheet SSD1306 128 x 64 Dot Matrix OLED/PLED Segment/Common Driver with Controller\n// https://www.digikey.com/htmldatasheets/production/2047793/0/0/1/ssd1306.html\n\n////////////////////////////////////////////////////////////////////////\n// Page 28, Chap 9, Table 9-1, section 1.Fundamental\n////////////////////////////////////////////////////////////////////////\n// Command with 1 arg to select 1 out of 256 contrast steps.\n#define TOLED_SETCONTRAST                              0x81\n// +arg1: 0-0xFF Contrast value (reset = 0x7F)\n  #define TOLED_SETCONTRAST_HALF                       0x7F\n  #define TOLED_SETCONTRAST_MAX                        0xFF\n\n// Command with embedded arg to resume/ignore displaying data\n#define TOLED_DISPLAYALLONRESUME                       0xA4 // (reset)\n#define TOLED_DISPLAYALLONIGNORE                       0xA5\n\n// Command with embedded arg to select normal or inverse display\n#define TOLED_DISPLAYNORMAL                            0xA6\n#define TOLED_DISPLAYINVERT                            0xA7\n\n// Command with embedded arg to turn screen off/on\n#define TOLED_DISPLAYOFF                               0xAE\n#define TOLED_DISPLAYON                                0xAF\n\n////////////////////////////////////////////////////////////////////////\n// Page 28, Chap 9, Table 9-1, section 2.Scrolling\n////////////////////////////////////////////////////////////////////////\n// Command to deavtive scrolling\n#define TOLED_DEACTIVATE_SCROLL                        0x2E\n\n////////////////////////////////////////////////////////////////////////\n// Page 30, Chap 9, Table 9-1, section Address Setting\n////////////////////////////////////////////////////////////////////////\n// Command with embedded arg to set the lower nibble of the column start address register for Page Addressing Mode\n#define TOLED_SETLOWNIBBLEOFPAGE(addr)                 (0x00 | ((addr)&0x0F))\n\n// Command with embedded arg to set the higher nibble of the column start address register for Page Addressing Mode\n#define TOLED_SETHIGHNIBBLEOFPAGE(addr)                (0x01 | ((addr)&0x0F))\n\n// Command with 1 arg to set memory addressing mode\n#define TOLED_SETMEMORYMODE                            0x20\n// +arg1: legal arg values are:\n  #define TOLED_SETMEMORYMODE_HOR                      0x00\n  #define TOLED_SETMEMORYMODE_VER                      0x01\n  #define TOLED_SETMEMORYMODE_PAGE                     0x02\n\n// Command with 2 args to set column address\n#define TOLED_SETCOLUMNADDR                            0x21\n// +arg1: 0-127 column start address\n// +arg2:0-127 column end address\n\n// Command with 2 args to set page address\n#define TOLED_SETPAGEADDR                              0x22\n// +arg1: 0-7 page start address\n// +arg2: 0-7 page end Address\n\n// Command with embedded arg to set page start address\n#define TOLED_SETPAGESTART(page)                       (0xB0 | ((page)&0x07))\n\n////////////////////////////////////////////////////////////////////////\n// Page 31, Chap 9, Table 9-1, section Hardware Configuration\n////////////////////////////////////////////////////////////////////////\n// Command with embedded arg to set address startline from 0-63 (6-bits)\n#define TOLED_SETSTARTLINE(line)                       (0x40 | ((line)&0x3F))\n#define TOLED_SETSTARTLINE_ZERO                        0x40\n\n// Command with embedded arg to remap segment\n#define TOLED_SEGREMAPNORMAL                           0xA0\n#define TO",
    "#pragma warning( disable : 4996 )\n\n#include <stdio.h>\n#include \"micro_hash256.h\"\n\n\n#define BUFFER_SIZE (0x1000)\n\n\n\nstatic NTSTATUS createHash(\n    PHashCtxt ctxt\n);\n\nNTSTATUS hashData(\n    UCHAR* buffer,\n    size_t to_read,\n    size_t offset,\n    FILE* fp,\n    PHashCtxt ctxt\n)\n{\n    size_t bytes_read;\n    int errsv;\n    NTSTATUS status = 0;\n\n    (offset);\n    //fseek(fp, SEEK_SET, offset);\n\n    errno = 0;\n    bytes_read = fread(buffer, 1, to_read, fp);\n    errsv = errno;\n    if ((bytes_read == 0 || bytes_read != to_read) && errsv != 0)\n    {\n#ifdef ERROR_PRINT\n        printf(\"ERROR (0x%x): Reading bytes failed!\\n\", errsv);\n#endif\n        status = 10;\n        goto clean;\n    }\n\n    status = BCryptHashData(ctxt->hash, buffer, (ULONG)bytes_read, 0);\n    if (!NT_SUCCESS(status))\n    {\n#ifdef ERROR_PRINT\n        printf(\"Error 0x%x returned by BCryptHashData\\n\", status);\n#endif\n        status = 8;\n        goto clean;\n    }\nclean:\n    ;\n\n    return status;\n}\n\nNTSTATUS hashBufferC(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size,\n    PHashCtxt ctxt\n)\n{\n    NTSTATUS status = STATUS_UNSUCCESSFUL;\n\n    if (hash_bytes_size < ctxt->hash_size)\n    {\n        status = STATUS_BUFFER_TOO_SMALL;\n        goto clean;\n    }\n\n    status = createHash(ctxt);\n    if (!NT_SUCCESS(status))\n    {\n        goto clean;\n    }\n\n    status = BCryptHashData(ctxt->hash, buffer, (ULONG)buffer_ln, 0);\n    if (!NT_SUCCESS(status))\n    {\n#ifdef ERROR_PRINT\n        printf(\"Error 0x%x returned by BCryptHashData\\n\", status);\n#endif\n        goto clean;\n    }\n\n    // close the hash\n    status = BCryptFinishHash(ctxt->hash, hash_bytes, ctxt->hash_size, 0);\n    if (!NT_SUCCESS(status))\n    {\n#ifdef ERROR_PRINT\n        printf(\"Error (0x%x): BCryptFinishHash\\n\", status);\n#endif\n        goto clean;\n    }\n\nclean:\n    ;\n\n    return status;\n}\n\nNTSTATUS sha256Buffer(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size\n)\n{\n    Sha256Ctxt ctxt;\n    NTSTATUS status = 0;\n\n    status = initSha256(&ctxt);\n    if (!NT_SUCCESS(status))\n    {\n        goto clean;\n    }\n\n    status = sha256BufferC(buffer, buffer_ln, hash_bytes, hash_bytes_size, &ctxt);\n\nclean:\n    cleanSha256(&ctxt);\n\n    return status;\n}\n\nNTSTATUS sha256BufferC(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size,\n    PSha256Ctxt ctxt\n)\n{\n    return hashBufferC(buffer, buffer_ln, hash_bytes, hash_bytes_size, ctxt);\n}\n\n\n\nNTSTATUS sha1Buffer(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size\n)\n{\n    Sha1Ctxt ctxt;\n    NTSTATUS status = 0;\n\n    status = initSha1(&ctxt);\n    if (!NT_SUCCESS(status))\n    {\n        goto clean;\n    }\n\n    status = sha1BufferC(buffer, buffer_ln, hash_bytes, hash_bytes_size, &ctxt);\n\nclean:\n    cleanSha1(&ctxt);\n\n    return status;\n}\n\nNTSTATUS sha1BufferC(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size,\n    PSha1Ctxt ctxt\n)\n{\n    return hashBufferC(buffer, buffer_ln, hash_bytes, hash_bytes_size, ctxt);\n}\n\n\nNTSTATUS md5Buffer(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size\n)\n{\n    Md5Ctxt ctxt;\n    NTSTATUS status = 0;\n\n    status = initMd5(&ctxt);\n    if (!NT_SUCCESS(status))\n    {\n        goto clean;\n    }\n\n    status = md5BufferC(buffer, buffer_ln, hash_bytes, hash_bytes_size, &ctxt);\n\nclean:\n    cleanMd5(&ctxt);\n\n    return status;\n}\n\nNTSTATUS md5BufferC(\n    uint8_t* buffer,\n    uint32_t buffer_ln,\n    uint8_t* hash_bytes,\n    uint16_t hash_bytes_size,\n    PMd5Ctxt ctxt\n)\n{\n    return hashBufferC(buffer, buffer_ln, hash_bytes, hash_bytes_size, ctxt);\n}\n\nvoid hashToString(const uint8_t* hash, uint16_t hash_size, char* output, uint16_t output_size)\n{\n    uint16_t i = 0;\n\n    for (i = 0; i < hash_size; i++)\n    {\n        sprintf(output + (i * 2), \"%02x\", hash[i]);\n    }\n\n    output[output_size - 1] = 0;\n}\n\nvoid printHash(const uint8_t* hash, uint16_t hash_size, const char* prefix, const char* postfix)\n{\n    uint16_t i = 0;\n\n    printf(\"%s\", prefix);\n    for (i = 0; i < hash_size; i++)\n    {\n        printf(\"%02x\", hash[i]);\n    }\n    printf(\"%s\", postfix);\n}\n\nNTSTATUS initSha1(PSha1Ctxt ctxt)\n{\n    return initHashCtxt(ctxt, BCRYPT_SHA1_ALGORITHM);\n}\n\nNTSTATUS initSha256(PSha256Ctxt ctxt)\n{\n    return initHashCtxt(ctxt, BCRYPT_SHA256_ALGORITHM);\n}\n\nNTSTATUS initMd5(PMd5Ctxt ctxt)\n{\n    return initHashCtxt(ctxt, BCRYPT_MD5_ALGORITHM);\n}\n\nNTSTATUS initHashCtxt(PHashCtxt ctxt, LPCWSTR AlgId)\n{\n    NTSTATUS status = STATUS_UNSUCCESSFUL;\n    HANDLE heap = GetProcessHeap();\n\n    memset(ctxt, 0, sizeof(HashCtxt));\n\n    //open an algorithm handle\n    status = BCryptOpenAlgorithmProvider(\n        &(ctxt->alg),\n        AlgId,\n        NULL,\n        0);\n    if (!NT_SUCCESS(status))\n    {\n#ifdef ERROR_PRINT\n        printf(\"Error (0x%x): BCryptOpenAlgorithmProvider\\n\", status);\n#endif\n        cleanHash",
    "//\n//  entity.cpp\n//  new-engine\n//\n//  Created by Kenneth Esdaile on 1/18/24.\n//\n\n#include \"entity-iterator.hpp\"\n\nnamespace kege{\n\n    bool Entity::init( kege::ecs::Core* ecs, kege::EntityManager* em )\n    {\n        if ( !_core && !_entity_mngr )\n        {\n            _core = ecs;\n            _entity_mngr = em;\n            return true;\n        }\n        return false;\n    }\n\n    kege::Entity Entity::create()\n    {\n        return Entity( _core->create() );\n    }\n\n    kege::ecs::Core* Entity::ecs()\n    {\n        return _core;\n    }\n\n    void Entity::uninit()\n    {\n        _core = nullptr;\n        _entity_mngr = nullptr;\n    }\n\n\n    kege::Entity Entity::pretach( kege::Entity entity )\n    {\n        if ( !entity )\n        {\n            //KEGE_ERROR( \"attemping to prepending ( attach ) non-entity as child\" );\n            return entity;\n        };\n\n        /* if this entity is not a parent make it a parent\n         */\n        component::Children* children = _core->get< component::Children >( _id );\n        if ( !children )\n        {\n            children = _core->add< component::Children >( _id );\n            children->head._id = kege::PoolIndex( -1L );\n            children->tail._id = kege::PoolIndex( -1L );\n            children->count = 0;\n        }\n\n        /*\n         attach child-component to the child entity\n         */\n        component::Child* child = _core->add< component::Child >( entity._id );\n        child->next._id = kege::PoolIndex( -1L );\n        child->prev._id = kege::PoolIndex( -1L );\n        child->entity._id = entity._id;\n        child->parent._id = this->_id;\n\n        /*\n         get the component id of the  child-component\n         */\n        if ( !children->head )\n        {\n            /* set head and tail component id to child component id\n             */\n            children->head._id = children->tail._id = entity._id;\n        }\n        else\n        {\n            component::Child* head = children->head.get< component::Child >();\n\n            // connect the new child before the head of the list\n            head->prev = entity;\n            child->next = children->head;\n\n            // update the new child as the head of the list\n            children->head = entity;\n        }\n\n        // increase the child count\n        children->count++;\n\n        // post message of new entity child added\n        //kege::Channel::broadcast< const kege::EntityEvent&, const kege::EntityEvent& >({ entity, kege::ENTITY_ATTACHED });\n        return entity;\n    }\n\n    kege::Entity Entity::attach( kege::Entity entity )\n    {\n        if ( !entity )\n        {\n            //KEGE_ERROR( \"attemping to appending ( attach ) non-entity as child\" );\n            return entity;\n        };\n\n        /* if this entity is not a parent make it a parent\n         */\n        component::Children* children = _core->get< component::Children >( _id );\n        if ( !children )\n        {\n            children = _core->add< component::Children >( _id );\n            children->head._id = kege::PoolIndex(-1L);\n            children->tail._id = kege::PoolIndex(-1L);\n            children->count = 0;\n        }\n\n        /*\n         attach child-component to the child entity\n         */\n        component::Child* child = _core->add< component::Child >( entity._id );\n        child->next._id = kege::PoolIndex( -1L );\n        child->prev._id = kege::PoolIndex( -1L );\n        child->entity._id = entity._id;\n        child->parent._id = this->_id;\n\n        /* get the component id of the  child-component\n         */\n        if ( !children->head )\n        {\n            /* set head and tail component id to child component id\n             */\n            children->tail = children->head = entity;\n        }\n        else\n        {\n            component::Child* tail = children->tail.get< component::Child >();\n\n            // add child to tail of the list\n            tail->next = entity;\n            child->prev = tail->entity;\n\n            // update the child as tail of the list\n            children->tail = entity;\n        }\n\n        // increase child count\n        children->count++;\n\n        // post message of new entity child added\n        //kege::Channel::broadcast< const kege::EntityEvent&, const kege::EntityEvent& >({ entity, kege::ENTITY_ATTACHED });\n        return entity;\n    }\n\n    kege::Entity& Entity::operator =( const kege::ecs::EntityId& id )\n    {\n        _id = id;\n        return *this;\n    }\n\n    kege::Entity& Entity::operator =( const kege::Entity& other )\n    {\n        _id = other._id;\n        return *this;\n    }\n\n    bool Entity::operator<( const kege::Entity& other )const \n    {\n        return _id._index < other._id._index;\n    }\n\n    Entity::operator bool()const\n    {\n        return _id.operator bool();\n    }\n\n    kege::Entity Entity::getChild( const kege::string& name )\n    {\n        /*\n         if this entity is not a parent it has no child.\n         */\n        if ( !has< component::Children >() )\n        {\n            return {};\n        }\n\n        ",
    "#include \"robot.h\"\n\nRobot::Robot() {\n    mQuery.exec(\"DROP TABLE IF EXISTS robots\");\n    mQuery.exec(\"CREATE TABLE robots (\"\n                \"robot_id INT PRIMARY KEY AUTO_INCREMENT,\"\n                \"name CHAR(125),\"\n                \"current_task CHAR(125))\");\n}\n\nRobot::~Robot() {\n    mQuery.exec(\"DROP TABLE IF EXISTS robots\");\n}\n\nvoid Robot::printRobots() {\n    std::cout << \"Robots:\" << std::endl;\n    if (!mQuery.exec(\"SELECT * FROM robots\")) {\n        std::cout << \"Error: \" << mQuery.lastError().text().toStdString() << std::endl;\n        return;\n    }\n\n    while (mQuery.next()) {\n        int id = mQuery.value(0).toInt();\n        QString name = mQuery.value(1).toString();\n        QString task = mQuery.value(2).toString();\n\n        QString idString = QString(\"Robot ID: %1\").arg(id).leftJustified(15, ' ');\n        QString nameString = QString(\"Name: %1\").arg(name).leftJustified(20, ' ');\n        QString taskString = QString(\"Current Task: %1\").arg(task).leftJustified(15, ' ');\n\n        qDebug() << qPrintable(idString)\n                 << qPrintable(nameString)\n                 << qPrintable(taskString);\n    }\n}\n\nvoid Robot::addRobot() {\n    std::string name;\n\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    std::cout << \"Enter robot name: \";\n    std::getline(std::cin, name);\n\n    mQuery.prepare(\"INSERT INTO robots (name) \"\n                   \"VALUES (:name)\");\n    mQuery.bindValue(\":name\", QString::fromStdString(name));\n    if (!mQuery.exec()) {\n        std::cout << \"Error adding robot: \" << mQuery.lastError().text().toStdString() << std::endl;\n        return;\n    }\n    std::cout << \"Robot added successfully\" << std::endl;\n}\n\nvoid Robot::deleteRobot() {\n    int robot_id;\n\n    std::cout << \"Enter robot id: \";\n    if (!(std::cin >> robot_id)) {\n        std::cout << \"Invalid input for robot id\" << std::endl;\n        return;\n    }\n\n    mQuery.prepare(\"DELETE FROM robots WHERE robot_id = :robot_id\");\n    mQuery.bindValue(\":robot_id\", robot_id);\n    if (!mQuery.exec()) {\n        std::cout << \"Error deleting robot: \" << mQuery.lastError().text().toStdString() << std::endl;\n        return;\n    }\n    std::cout << \"Robot deleted successfully\" << std::endl;\n}\n\nvoid Robot::assignTask() {\n    int robot_id;\n    std::string task;\n\n    std::cout << \"Enter robot id: \";\n    std::cin >> robot_id;\n    \n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    mQuery.prepare(\"SELECT COUNT(*) FROM robots WHERE robot_id = :robot_id\");\n    mQuery.bindValue(\":robot_id\", robot_id);\n    if (!mQuery.exec()) {\n        std::cout << \"Error executing query: \" << mQuery.lastError().text().toStdString() << std::endl;\n        return;\n    }\n    if (mQuery.next() && mQuery.value(0).toInt() == 0) {\n        std::cout << \"Robot with ID \" << robot_id << \" does not exist\" << std::endl;\n        return;\n    }\n\n    mQuery.prepare(\"SELECT current_task FROM robots WHERE robot_id = :robot_id\");\n    mQuery.bindValue(\":robot_id\", robot_id);\n    if (!mQuery.exec()) {\n        std::cout << \"Error executing query: \" << mQuery.lastError().text().toStdString() << std::endl;\n        return;\n    }\n    if (mQuery.next() && !mQuery.value(0).isNull()) {\n        std::cout << \"Robot with ID \" << robot_id << \" already has a task assigned\" << std::endl;\n        return;\n    }\n\n    std::cout << \"Enter task name: \";\n    std::getline(std::cin, task);\n\n    mQuery.prepare(\"SELECT description FROM task WHERE description = :description\");\n    mQuery.bindValue(\":description\", QString::fromStdString(task));\n    if (!mQuery.exec()) {\n        std::cout << \"Error executing query: \" << mQuery.lastError().text().toStdString() << std::endl;\n        return;\n    }\n\n    if (mQuery.next()) {\n        QString description = mQuery.value(0).toString();\n\n        assignmentQuery.prepare(\"SELECT robot_id FROM robots WHERE current_task = :description\");\n        assignmentQuery.bindValue(\":description\", description);\n        if (!assignmentQuery.exec()) {\n            std::cout << \"Error executing query: \" << assignmentQuery.lastError().text().toStdString() << std::endl;\n            return;\n        }\n        if (assignmentQuery.next()) {\n            std::cout << \"Task is already assigned to a robot\" << std::endl;\n            return;\n        }\n\n        updateQuery.prepare(\"UPDATE robots SET current_task = :task_description WHERE robot_id = :robot_id\");\n        updateQuery.bindValue(\":task_description\", QString::fromStdString(task));\n        updateQuery.bindValue(\":robot_id\", robot_id);\n        if (!updateQuery.exec()) {\n            std::cout << \"Error assigning task: \" << updateQuery.lastError().text().toStdString() << std::endl;\n            return;\n        }\n        std::cout << \"Task assigned successfully\" << std::endl;\n    } else {\n        std::cout << \"Task not found\" << std::endl;\n    }\n}\n\nvoid Robot::run() {\n    mQuery.prepare(\"SELECT robot_id, current_task FROM robots WHERE current_task IS NOT NULL\");\n    if (!mQuery.exec()) {\n        std::cout << ",
    "#include <iostream>\r\n#include <cmath>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <conio.h>\r\nusing namespace std;\r\n\r\n//cmath untuk sqrt dan eksponen (power) phytagoras dalam mencari keliling di bangun datar\r\n//algorithm untuk fitur sort() sorting saat mencari median di statistika\r\n//vector untuk menyimpan sementara angka modus di statistika dan push_back \r\n//conio.h untuk getch menyamarkan password\r\n\r\n//KELOMPOK 1 STUKTUR DATA DAN ALGORITMA KELAS RPL 2C\r\n//Muhammad Akbar Permanaatmaja\t\t\t(2204074) \r\n//Kezia Helena Patricia Naibaho\t\t\t(2209498) \r\n//Alfia April Riani\t\t\t\t\t\t(2209367) \r\n//Dhowy Anja Alhusna\t\t\t\t\t(2210013) \r\n\r\nvoid log();\r\nvoid menu();\r\nvoid Keluar();\r\nint main();\r\n\r\nvoid Keluar()\r\n{\r\n    cout << \"\\t !!     Silahkan keluar  \t\\t!! \\n\";\r\n    cout << endl;\r\n \texit(0);\r\n}\r\n\r\n//BILANGAN REAL\r\n// ranah fitur 1 ==========================================================================================================================\r\nvoid filter_1(){\r\n\r\n\tcout << endl;\r\n\tcout << \"\\t\\t\\t| PENGERTIAN BILANGAN REAL | \" << endl << endl;\r\n\tcout << \"||==============================================================================================||\\n\";\r\n\tcout << \"||-Bilangan real adalah bilangan yang dapat digunakan dalam operasi numerik seperti biasa\\t||\\n\";\r\n\tcout << \"||-Bilangan real disebut juga dengan bilangan riil dan diwakili oleh simbol ( R )\\t\\t||\\n\"; \r\n\tcout << \"||-Bilangan riil dalam matematika merupakan bilangan yang dapat dituliskan dalam bentuk desimal\\t||\\n\"; \r\n\tcout << \"|| seperti 2.483 atau 3.25\t\t\t\t\t\t\t\t\\t||\\n\";\r\n\tcout << \"||-Bilangan real meliputi bilangan rasional, seperti 42 dan -23/129\t\t\t\\t||\\n\"; \r\n\tcout << \"|| dan bilangan irasional seperti p\t\t\t\t\t\t\t\\t||\\n\"; \r\n\tcout << \"||-Bilangan real juga dapat direpresentasikan sebagai titik pada garis digital\t\\t\\t||\\n\";\r\n\tcout << \"||-Standar modern matematika murni tidak cukup ketat untuk deskripsi bilangan riil ini\\t\\t||\\n\"; \r\n\tcout << \"||-Salah satu perkembangan matematika terpenting di abad ke-19 adalah\t\t\\t\\t||\\n\"; \r\n\tcout << \"|| penemuan definisi yang cukup ketat dari bilangan real \t\t\t\\t\\t||\\n\";\r\n\tcout << \"|| dan kesadaran bahwa diperlukan definisi yang lebih baik.\t\t\t\\t\\t||\\n\"; \r\n\tcout << \"||-Bilangan real membentuk bidang Archimedes unik, yang sepenuhnya teratur (R; +; \u00b7; <)\\t\\t||\\n\";\r\n\tcout << \"||==============================================================================================||\\n\";\r\n\tcout << endl;\r\n\t\r\n\tcout <<\"\\t||ingin mencoba operasi perhitungan dari bilangan Real?\t\t\t\t\t||\" << endl;\r\n\tcout << \"\\t||ketik 'y' jika ingin mencobanya, ketik apa saja jika tak ingin mencobanya\t\t||\\n\";\r\n\tstring ril = \"y\";\r\n\tfloat num1, num2, jumlah;\r\n    char op;\r\n\tstring pilih1;\r\n\tcin >>pilih1;\r\n\t\r\n\tif(cin.fail()){\r\n\t\tsystem(\"CLS\");\r\n\t\tcout << \"\\t !! perintah tidak valid !! \\n\";\r\n\t    cin.clear();\r\n\t\tcin.ignore();\r\n\t} else if (pilih1 == ril){\r\n\t\tawal :\r\n\t\t    cout << \"Masukkan bilangan pertama: \";\r\n\t\t    cin >> num1;\r\n\t\t    cout << \"Masukkan bilangan kedua: \";\r\n\t\t    cin >> num2;\r\n\t\t\r\n\t\t    cout << \"Pilih operasi matematika (+, -, *, /): \";\r\n\t\t    cin >> op;\r\n\t\tif (!cin){\r\n\t\t\tcout << \"Operasi tak dapat dilakukan\" << endl;\r\n\t\t} else{\r\n\t\tswitch (op) {\r\n\t        case '+':\r\n\t            cout << num1 << \" + \" << num2 << \" = \" << num1 + num2;\r\n\t            break;\r\n\t        case '-':\r\n\t            cout << num1 << \" - \" << num2 << \" = \" << num1 - num2;\r\n\t            break;\r\n\t        case '*':\r\n\t            cout << num1 << \" * \" << num2 << \" = \" << num1 * num2;\r\n\t            break;\r\n\t        case '/':\r\n\t            if (num2 == 0) {\r\n\t            \tcout << num1 << \" / \" << num2 << \" = \" << num1 / num2 << endl;\r\n\t                cout << \"Bilangan kedua tidak boleh dibagi nol! karena hasilnya tak terhingga\\n\";\r\n\t                cout << \"pembagian dengan penyebut nol 'tidak diperbolehkan' karena akan menyebabkan kontradiksi antar aturan aritmatik\";\r\n\t            } else {\r\n\t                cout << num1 << \" / \" << num2 << \" = \" << num1 / num2;\r\n\t            }\r\n\t            break;\r\n\t        default:\r\n\t        \tcout << endl;\r\n\t            cout << \"Error: Operasi matematika tidak dapat dilakukan!\" << endl;\r\n\t\t\t\tgoto awal;\r\n\t    \t}\r\n\t\t\t\t\tstring c = \"y\";\r\n\t\t\t    \tstring coba;\r\n\t\t\t    \tcout << endl;\r\n\t\t\t    \tcout << \"||==========================================================||\\n\";\r\n\t\t\t\t\tcout << \"|| ingin mencoba lagi ? (tekan 'y' jika ingin mencoba lagi) ||\\n\";\r\n\t\t\t\t\tcout << \"||==========================================================||\\n\";\r\n\t\t\t\t\tcin >> coba;\r\n\t\t\t\t\tif (coba == c){\r\n\t\t\t\t\t\tgoto awal;\r\n\t\t\t\t\t}  \r\n\t\t\t\t\r\n\t\t}\r\n\t    \r\n\t} \r\n\telse {\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n//HIMPUNAN\r\n// ranah fitur 2 ==========================================================================================================================\r\n\t\r\nvoid filter_2(){\r\n\tcout << \"\\t\\t\\t| PENGERTIAN HIMPUNAN | \" << endl << endl;\r\n\tcout << \"||=============================================================================||\\n\";\r\n\tcout << \"||        Secara umum, Himpunan adalah kumpulan dari objek tertentu            ||\\",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"nav_msgs/msg/occupancy_grid.hpp\"\n#include \"sensor_msgs/msg/laser_scan.hpp\"\n#include \"nav_msgs/msg/odometry.hpp\"\n#include <cmath>\n#include \"tf2_geometry_msgs/tf2_geometry_msgs.h\"\n#include \"sensor_msgs/msg/point_cloud.hpp\"\n\n#include \"sensor_msgs/msg/point_cloud2.hpp\" // Include for PointCloud2 message\n#include \"geometry_msgs/msg/point32.hpp\"    // Include for Point32 message\n#include \"pcl_conversions/pcl_conversions.h\"\n#include \"pcl/point_cloud.h\"\n#include \"pcl/point_types.h\"\n\nusing namespace std::chrono_literals;\n\nclass OccupancyMapUpdater : public rclcpp::Node {\npublic:\n    OccupancyMapUpdater() : Node(\"occupancy_map_updater\") {\n        occupancy_map_subscriber_ = this->create_subscription<nav_msgs::msg::OccupancyGrid>(\n            \"/map\", 10, std::bind(&OccupancyMapUpdater::occupancyMapCallback, this, std::placeholders::_1));\n        \n        rclcpp::QoS qos(rclcpp::KeepLast(5)); // Example QoS settings\n        qos.best_effort(); // Set the reliability to best effort\n        lidar_subscriber_ = this->create_subscription<sensor_msgs::msg::LaserScan>(\n            \"/sensing/lidar/scan\", qos, std::bind(&OccupancyMapUpdater::lidarCallback, this, std::placeholders::_1));\n\n        odometry_subscriber_ = this->create_subscription<nav_msgs::msg::Odometry>(\n            \"/localization/kinematic_state\", 10, std::bind(&OccupancyMapUpdater::odometryCallback, this, std::placeholders::_1));\n\n        updated_occupancy_map_publisher_ = this->create_publisher<nav_msgs::msg::OccupancyGrid>(\n            \"/updated_map\", 10);\n\n\n        lidar_points_publisher_ = this->create_publisher<sensor_msgs::msg::PointCloud2>(\n            \"/lidar_points\", 10);\n        transformed_lidar_points_publisher_ = this->create_publisher<sensor_msgs::msg::PointCloud2>(\n            \"/transformed_lidar_points\", 10);\n        car_position_publisher_ = this->create_publisher<sensor_msgs::msg::PointCloud2>(\n            \"/car_position\", 10);\n\n        epsilon_ = 0.2;  // Adjust epsilon according to your LiDAR sensor's resolution\n        min_points_ = 5;  // Adjust min_points as needed\n        min_fov = -3.14 / 6;\n        max_fov = 3.14 / 6;\n    }\n\nprivate:\n    nav_msgs::msg::OccupancyGrid::SharedPtr OG;\n    nav_msgs::msg::OccupancyGrid updated_OG;\n    nav_msgs::msg::Odometry::SharedPtr curr_odometry;\n    double epsilon_;\n    int min_points_;\n    float map_origin_x_;\n    float map_origin_y_;\n    float map_resolution_;\n    float map_width_;\n    double min_fov;\n    double max_fov;\n\n    void occupancyMapCallback(const nav_msgs::msg::OccupancyGrid::SharedPtr occupancy_map_msg) {\n        if (!OG) {\n            //RCLCPP_INFO(this->get_logger(), \"Received occupancy map\");\n            OG = occupancy_map_msg;\n            map_origin_x_ = occupancy_map_msg->info.origin.position.x;\n            map_origin_y_ = occupancy_map_msg->info.origin.position.y;\n            map_resolution_ = occupancy_map_msg->info.resolution;\n            map_width_ = occupancy_map_msg->info.width;\n            //RCLCPP_INFO(this->get_logger(), \"Map Origin: (%f, %f)\", map_origin_x_, map_origin_y_);\n            //RCLCPP_INFO(this->get_logger(), \"Map Resolution: %f\", map_resolution_);\n            //RCLCPP_INFO(this->get_logger(), \"Map Width: %f\", map_width_);\n        }\n    }\n\n    void lidarCallback(const sensor_msgs::msg::LaserScan::SharedPtr lidar_msg) {\n        //RCLCPP_INFO(this->get_logger(), \"Received LiDAR data\");\n\n        if (!OG) {\n            //RCLCPP_INFO(this->get_logger(), \"Occupancy grid not received yet\");\n            return;\n        }\n\n        // Process LiDAR data\n        std::vector<std::pair<double, double>> points;\n        for (size_t i = 0; i < lidar_msg->ranges.size(); ++i) {\n            double angle = lidar_msg->angle_min + i * lidar_msg->angle_increment;\n            // Check if the angle is within the field of view\n            if (angle < min_fov || angle > max_fov) {\n                continue; // Skip measurements outside of the field of view\n            }\n            double range = lidar_msg->ranges[i];\n            if (range < lidar_msg->range_min || range > lidar_msg->range_max)\n                continue; // Skip invalid range\n            double x = range * cos(angle);\n            double y = range * sin(angle);\n            points.push_back({x, y});\n        }\n        //RCLCPP_INFO(this->get_logger(), \"Number of LiDAR Points: %zu\", points.size());\n        \n        // Publish LiDAR points\n        publishPointCloud(lidar_points_publisher_, points);\n\n        // Transform LiDAR points to map frame\n        std::vector<std::pair<double, double>> transformed_points = transformLidarPoints(points, *curr_odometry);\n        //RCLCPP_INFO(this->get_logger(), \"Number of Transformed Points: %zu\", transformed_points.size());\n\n        // Publish transformed LiDAR points\n        publishPointCloud(transformed_lidar_points_publisher_, transformed_points);\n\n        std::vector<std::pair<double, double>> car_position = {{curr_odometry->pose.pose.position.x, curr",
    "#include<iostream>\r\n#include<cmath>\r\n#include<string>\r\n#define MAX 1000\r\nusing namespace std;\r\n\r\n//\u8054\u7cfb\u4eba\u7ed3\u6784\u4f53\r\nstruct Person {\r\n\tstring m_Name;\r\n\tint m_Age;\r\n\tint m_Sex;\r\n\tstring m_Phone;\r\n\tstring m_Address;\r\n};\r\n//\u901a\u8baf\u5f55\u7ed3\u6784\u4f53\r\nstruct AddressBooks\r\n{\r\n\tstruct Person personArray[MAX];\r\n\r\n\tint m_Size;\r\n};\r\n\r\nvoid key_find(AddressBooks* abs, string phone);\r\n\r\nvoid showMenu() {\r\n\tcout << \"****************************\" << endl;\r\n\tcout << \"*****   1.\u6dfb\u52a0\u8054\u7cfb\u4eba   *****\" << endl;\r\n\tcout << \"*****   2.\u663e\u793a\u8054\u7cfb\u4eba   *****\" << endl;\r\n\tcout << \"*****   3.\u5220\u9664\u8054\u7cfb\u4eba   *****\" << endl;\r\n\tcout << \"*****   4.\u67e5\u627e\u8054\u7cfb\u4eba   *****\" << endl;\r\n\tcout << \"*****   5.\u4fee\u6539\u8054\u7cfb\u4eba   *****\" << endl;\r\n\tcout << \"*****   6.\u6e05\u7a7a\u8054\u7cfb\u4eba   *****\" << endl;\r\n\tcout << \"*****   0.\u9000\u51fa\u901a\u8baf\u5f55   *****\" << endl;\r\n\tcout << \"****************************\" << endl;\r\n}\r\n\r\nvoid addPerson(AddressBooks * abs) {\r\n\tif (abs->m_Size == MAX) {\r\n\t\tcout << \"\u8054\u7cfb\u4eba\u5df2\u6ee1\" << endl;\r\n\t\treturn;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//\u59d3\u540d\u6dfb\u52a0\r\n\t\tstring name;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u59d3\u540d\" << endl;\r\n\t\tcin >> name;\r\n\t\tabs->personArray[abs->m_Size].m_Name = name;\r\n\t\t//\u6027\u522b\u6dfb\u52a0\r\n\t\tint sex = 0;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u6027\u522b\" << endl;\r\n\t\tcout << \"1----\u7537 2----\u5973\" << endl;\r\n\t\twhile(true){\r\n\t\tcin >> sex;\r\n\t\tif (sex == 1 || sex == 2)\r\n\t\t\tabs->personArray[abs->m_Size].m_Sex = sex;\r\n\t\telse\r\n\t\t\tcout << \"\u8f93\u5165\u6709\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\tbreak;\r\n\t\t}\r\n\t\t//\u5e74\u9f84\u6dfb\u52a0\r\n\t\tint age = 0;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u5e74\u9f84\" << endl;\r\n\t\twhile (true) {\r\n\t\t\tcin >> age;\r\n\t\t\tif (age < 1)\r\n\t\t\t\tcout << \"\u8f93\u5165\u7684\u5e74\u9f84\u9519\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t\telse\r\n\t\t\t\tabs->personArray[abs->m_Size].m_Age = age;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t//\u6dfb\u52a0\u7535\u8bdd\r\n\t\tstring phone;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u7535\u8bdd\u53f7\u7801\" << endl;\r\n\t\tcin >> phone;\r\n\t\tabs->personArray[abs->m_Size].m_Phone = phone;\r\n\t\t//\u6dfb\u52a0\u5730\u5740\r\n\t\tstring address;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u8054\u7cfb\u4eba\u5730\u5740\" << endl;\r\n\t\tcin >> address;\r\n\t\tabs->personArray[abs->m_Size].m_Address = address;\r\n\t\tabs->m_Size++;\r\n\t\tcout << \"\u5df2\u6210\u529f\u6dfb\u52a0\u4e00\u4e2a\u8054\u7cfb\u4eba\" << endl;\r\n\t\tsystem(\"pause\");\r\n\t\tsystem(\"cls\");\r\n\t}\r\n}\r\n\r\nvoid showPerson(AddressBooks* abs) {\r\n\t//\u7a7a\r\n\tif (abs->m_Size==0)\r\n\t{\r\n\t\tcout << \"\u8054\u7cfb\u4eba\u4e3a\u7a7a\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (int i = 0;i<abs->m_Size; i++) {\r\n\t\t\tcout << \"\u8054\u7cfb\u4eba\" << i + 1 << endl;\r\n\t\t\tcout << \"\u59d3\u540d=\" << abs->personArray[i].m_Name << '\\t';\r\n\t\t\tcout << \"\u5e74\u9f84=\" << abs->personArray[i].m_Age << '\\t';\r\n\t\t\tcout << \"\u6027\u522b=\" << (abs->personArray[i].m_Sex ==1?\"\u7537\":\"\u5973\") << '\\t';//\u4e09\u76ee\u8fd0\u7b97\u7b26\u5224\u65ad\u7537\u5973\r\n\t\t\tcout << \"\u7535\u8bdd=\" << abs->personArray[i].m_Phone << '\\t';\r\n\t\t\tcout << \"\u5730\u5740=\" << abs->personArray[i].m_Address << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid deleteContact(AddressBooks* abs) {\r\n\tint o;\r\n\tshowPerson(abs);\r\n\tcout << \"\u8f93\u5165\u4f60\u8981\u9009\u62e9\u5220\u9664\u7684\u7f16\u53f7\" << endl;\r\n\tcin >> o;\r\n\tif (o > 0) {\r\n\t\t//personArray\u53ea\u67091000\u4e2a\u5b58\u50a8\u4f4d\uff1a[0]-[999],i\u5e94\u8be5\u4ece0\u5f00\u59cb,\u5230998\u7ed3\u675f\u3002m_Size\u6700\u5927\u4e3a1000\uff0c\u5e94i<999\uff0c\r\n\t\tfor (int i = o-1; i <abs->m_Size-1; i++)//\u6570\u7ec4\u4ece\u504f\u79fb\u503c0\u5f00\u59cb\u5b58\u50a8\r\n\t\t{\r\n\t\t\tabs->personArray[i] = abs->personArray[i + 1];\r\n\t\t}\r\n\t\tabs->m_Size--;\r\n\t\tcout << \"\u5df2\u6210\u529f\u5220\u9664\u8054\u7cfb\u4eba\" << o << endl;\r\n\t}\r\n\telse\r\n\t\tcout << \"\u9519\u8bef\u7684\u7f16\u53f7\u6216\u8054\u7cfb\u4eba\u4e0d\u5b58\u5728\";\r\n\tsystem(\"pause\");\r\n\tsystem(\"cls\");\r\n}\r\n\r\nvoid findContact(AddressBooks *abs) {\r\n\tint o;\r\n\tcout << \"1.\u7535\u8bdd\u67e5\u627e\" << endl;\r\n\tcout << \"2.\u59d3\u540d\u67e5\u627e\" << endl; \r\n\tcout << \"3.\u8fd4\u56de\" << endl;\r\n\twhile (true)\r\n\t{\r\n\t\tcin >> o;\r\n\t\t//\u7535\u8bdd\r\n\t\tif (o == 1) {\r\n\t\t\tstring phone;\r\n\t\t\tcout << \"\u8f93\u5165\u7535\u8bdd\" << endl;\r\n\t\t\tcin >> phone;\r\n\t\t\tkey_find(abs,phone);\r\n\t\t}\r\n\t\t//\u59d3\u540d\r\n\t\telse if (o == 2) {\r\n\t\t\tstring name;\r\n\t\t\tcout << \"\u8f93\u5165\u59d3\u540d\";\r\n\t\t\tcin >> name;\r\n\t\t\tkey_find(abs, name);\r\n\t\t}\r\n\t\t//back\r\n\t\telse if (o == 3)\r\n\t\t{\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse\r\n\t\t\tcout << \"\u65e0\u6548\u8f93\u5165\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\";\r\n\t}\r\n}\r\n\r\nvoid modifyContact(AddressBooks *abs) {\r\n\tint o;\r\n\tif (abs->m_Size == 0)\r\n\t{\r\n\t\tcout << \"\u672a\u6dfb\u52a0\u4efb\u4f55\u8054\u7cfb\u4eba\" << endl;\r\n\t\tsystem(\"pause\");\r\n\t\tsystem(\"cls\");\r\n\t\treturn;\r\n\t}\r\n\tshowPerson(abs);\r\n\tcout << \"\u8f93\u5165\u4fee\u6539\u7684\u8054\u7cfb\u4eba\u7f16\u53f7\" << endl;\r\n\twhile (true)\r\n\t{\r\n\t\tcin >> o;\r\n\t\tif (o > abs->m_Size)\r\n\t\t\tcout << \"\u672a\u627e\u5230\u8be5\u8054\u7cfb\u4eba,\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\telse if (o == 0)\r\n\t\t\treturn;\r\n\t\telse\r\n\t\t\tbreak;\r\n\t}\r\n\to =o-1;\r\n\tcout << \"\u4fee\u6539\" << endl;\r\n\tcout << \"1----\u59d3\u540d\" << '\\t'\r\n\t\t<< \"2----\u5e74\u9f84\" << '\\t'\r\n\t\t<< \"3----\u6027\u522b\" << '\\t'\r\n\t\t<< \"4----\u7535\u8bdd\" << '\\t'\r\n\t\t<< \"5----\u5730\u5740\" << '\\t'\r\n\t\t<< \"0----\u8fd4\u56de\" << '\\t';\r\n\tcout << endl;\r\n\tint c;\r\n\tcin >> c;\r\n\tcout << \"\u8bf7\u8f93\u5165\u4fee\u6539\u5185\u5bb9\" << endl;\r\n\t\tswitch (c)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t{\r\n\t\t\t\tstring name;\r\n\t\t\t\tcin >> name;\r\n\t\t\t\tabs->personArray[o].m_Name = name;\r\n\t\t\t\tcout << \"\u4fee\u6539\u6210\u529f\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 2:\r\n\t\t\t{\r\n\t\t\t\tint age;\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tcin >> age;\r\n\t\t\t\t\tif (age < 1)\r\n\t\t\t\t\t\tcout << \"\u8f93\u5165\u7684\u5e74\u9f84\u9519\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tabs->personArray[o].m_Age = age;\r\n\t\t\t\t\tcout << \"\u4fee\u6539\u6210\u529f\" << endl;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t{\r\n\t\t\t\tint sex = 0;\r\n\t\t\t\tcout << \"1----\u7537 2----\u5973\" << endl;\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\tcin >> sex;\r\n\t\t\t\t\tif (sex == 1 || sex == 2)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tabs->personArray[o].m_Sex = sex;\r\n\t\t\t\t\t\tcout << \"\u4fee\u6539\u6210\u529f\" << endl;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcout << \"\u8f93\u5165\u6709\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t\tcase 4: {\r\n\t\t\t\tstring phone;\r\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u7535\u8bdd\u53f7\u7801\" << endl;\r\n\t\t\t\tcin >> phone;\r\n\t\t\t\tabs->personArray[o].m_Phone = phone;\r\n\t\t\t\tcout << \"\u4fee\u6539\u6210\u529f\" << endl;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 5: {\r\n\t\t\t\tstring address;\r\n\t\t\t\tcout << \"\u8bf7\u8f93\u5165\u8054\u7cfb\u4eba\u5730\u5740\" << endl;\r\n\t\t\t\tcin >> address;\r\n\t\t\t\tabs->personArray[o].m_Address = address;\r\n\t\t\t\tcou",
    "#include \"token.h\"\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <thread>\n#include <algorithm>\n\n    Tokenizer::TrieNode::TrieNode() {\n        this->tokenId = -999999;\n    }\n\n    Tokenizer::Tokenizer() {\n        root = new TrieNode();\n        int n = 0;\n        wchar_t special_token = L'\\x0';\n        for (; special_token < L'!'; special_token++, n++) {\n            byteCharDict[L'\\x100' + n] = special_token;\n            charByteDict[special_token] = L'\\x100' + n;\n        }\n        for (special_token = L'\\x7F'; special_token < L'\\xA1'; special_token++, n++) {\n            byteCharDict[L'\\x100' + n] = special_token;\n            charByteDict[special_token] = L'\\x100' + n;\n        }\n        byteCharDict[L'\\x100' + n++] = L'\\xAD';\n        charByteDict[L'\\xAD'] = L'\\x100' + n++;\n    }\n\n    Tokenizer::~Tokenizer() {\n        Clear();\n        delete root;\n    }\n\n    void Tokenizer::Clear() {\n        std::vector <TrieNode*> q;\n        q.push_back(root);\n        for (int i = 0; i < q.size(); i++) {\n            TrieNode *now = q[i];\n            for (auto it : now->next) {\n                q.push_back(it.second);\n            }\n        }\n        if (specialRoot != nullptr) {\n            q.push_back(specialRoot);\n            for (int i = q.size() - 1; i < q.size(); i++) {\n                TrieNode *now = q[i];\n                for (auto it : now->next) {\n                    q.push_back(it.second);\n                }\n            }\n        }\n        for (TrieNode * node : q)\n            delete node;\n        q.clear();\n        root = new TrieNode();\n        specialRoot = nullptr;\n        tokenToStringDict.clear();\n        tokenToScoreDict.clear();\n        stringToTokenDict.clear();\n    }\n\n    void Tokenizer::Insert(const std::string &s, int tokenId, float score) {\n        TrieNode *now = this->root;\n        for (int i = 0; i < s.size(); i++) {\n            if (now->next.find(s[i]) == now->next.end()) {\n                now->next[s[i]] = new TrieNode();\n            }\n            now = now->next[s[i]];\n        }\n        now->tokenId = tokenId;\n        now->score = score;\n        tokenToStringDict[tokenId] = s;\n        tokenToScoreDict[tokenId] = score;\n        stringToTokenDict[s] = tokenId;\n    }\n\n    void Tokenizer::SetSpecialTokens(const std::map<std::string, int>& specialTokenMap) {\n        if (specialRoot == nullptr)\n            specialRoot = new TrieNode();\n        for (auto &it : specialTokenMap) {\n            TrieNode *now = this->specialRoot;\n            for (int i = 0; i < it.first.size(); i++) {\n                if (now->next.find(it.first[i]) == now->next.end()) {\n                    now->next[it.first[i]] = new TrieNode();\n                }\n                now = now->next[it.first[i]];\n            }\n            now->tokenId = it.second;\n            now->score = 0.0f;\n            tokenToStringDict[it.second] = it.first;\n            stringToTokenDict[it.first] = it.second;\n            specialTokens.push_back(it.first);\n        }\n    }\n\n    void Tokenizer::TryMergePairs(std::vector<Symbol> &symbols, int l, int r, std::priority_queue <SymbolPairs> &q) {\n        if (l == -1 || r == -1 || symbols[l].len == 0 || symbols[r].len == 0) {\n            return;\n        }\n        auto now = symbols[l].node;\n        char *s = symbols[r].s;\n        int pos = symbols[r].pos, len = symbols[r].len;\n        for (int i = pos; i < pos + len; i++) {\n            if (now->next.find(s[i]) != now->next.end()) {\n                now = now->next[s[i]];\n            } else {\n                return;\n            }\n        }\n        if (now->tokenId == -999999) {\n            return;\n        }\n        q.push(SymbolPairs(now->score, l, r, symbols[l].len + symbols[r].len));\n    }\n\n    int Tokenizer::GetRank(std::vector<Symbol> &symbols,  std::vector<std::pair<int, int>> &partitions, int idx, int skip) {\n        if (idx + skip + 2 >= partitions.size()) {\n            return std::numeric_limits<int>::max();\n        }\n        auto s = symbols[0].s + symbols[0].pos;\n        std::string key(s + partitions[idx].first, s + partitions[idx + skip + 2].first);\n        if (stringToTokenDict.find(key) != stringToTokenDict.end()) {\n            return stringToTokenDict[key];\n        }\n        return std::numeric_limits<int>::max();\n    }\n\n    std::string Tokenizer::Normalize(const std::string &ori) {\n        if (this->byteAsChar) {\n            std::wstring ws(ori.size(), L' ');\n            for (int i=0; i < ori.length(); i++) {\n                wchar_t wi = static_cast<wchar_t>(static_cast<unsigned char>(ori[i]));\n                if (charByteDict.find(wi) != charByteDict.end()) {\n                    wi = charByteDict[wi];\n                }\n                ws[i] = wi;\n            }\n            return converter.to_bytes(ws);  \n        }\n        std::string blank = \"\";\n        blank += 226, blank += 150, blank += 129;\n        std::string s = this->addDummyPrefix ? blank : \"\";\n        if (15 < ori.size() && ori.substr(0, 15) == \"<FLM_FIX_TOKEN_\") {\n            s = ",
    "#include <pybind11/numpy.h>\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n\n#include <vector>\n\n#include \"makelevelset3.h\"\n\n#define STRINGIFY(x) #x\n#define MACRO_STRINGIFY(x) STRINGIFY(x)\n\nnamespace py = pybind11;\n\npy::array_t<float> compute(py::array_t<float> vertices,\n                           py::array_t<unsigned int> faces, int size) {\n  // input\n  std::vector<Vec3f> V;\n  for (int i = 0; i < vertices.shape(0); ++i) {\n    V.push_back(Vec3f(vertices.at(i, 0), vertices.at(i, 1), vertices.at(i, 2)));\n  }\n  std::vector<Vec3ui> F;\n  for (int i = 0; i < faces.shape(0); ++i) {\n    F.push_back(Vec3ui(faces.at(i, 0), faces.at(i, 1), faces.at(i, 2)));\n  }\n\n  // bounding box\n  Vec3f bbmin(-1.0f, -1.0f, -1.0f);\n  Vec3f bbmax(1.0f, 1.0f, 1.0f);\n  float dx = 2.0f / (float)size;\n\n  // compute level sets\n  Array3f grid;\n  make_level_set3(F, V, bbmin, dx, size, size, size, grid);\n\n  // output\n  py::array_t<float> sdf({size, size, size});\n  for (int x = 0; x < size; x++) {\n    for (int y = 0; y < size; y++) {\n      for (int z = 0; z < size; z++) {\n        sdf.mutable_at(x, y, z) = grid(x, y, z);\n      }\n    }\n  }\n  return sdf;\n}\n\nPYBIND11_MODULE(core, m) {\n  m.def(\"compute\", &compute, R\"pbdoc(\n        Compute the SDF from an input mesh.\n\n        Args:\n          vertices (np.ndarray): The vertex array with shape (Nv, 3), and\n              vertices MUST be in range [-1, 1].\n          faces (np.ndarray): The face array with shape (Nf, 3).\n          size (int): The resolution of resulting SDF.\n        )pbdoc\",\n        py::arg(\"vertices\"), py::arg(\"faces\"), py::arg(\"size\") = 128);\n\n#ifdef VERSION_INFO\n  m.attr(\"__version__\") = MACRO_STRINGIFY(VERSION_INFO);\n#else\n  m.attr(\"__version__\") = \"dev\";\n#endif\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to return precedence of operators\nint prec(char c) {\n\tif (c == '^')\n\t\treturn 3;\n\telse if (c == '/' || c == '*')\n\t\treturn 2;\n\telse if (c == '+' || c == '-')\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}\n\n// Function to return associativity of operators\nchar associativity(char c) {\n\tif (c == '^')\n\t\treturn 'R';\n\treturn 'L'; // Default to left-associative\n}\n\n// The main function to convert infix expression\n// to postfix expression\nvoid infixToPostfix(string s) {\n\tstack<char> st;\n\tstring result;\n\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tchar c = s[i];\n\n\t\t// If the scanned character is\n\t\t// an operand, add it to the output string.\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))\n\t\t\tresult += c;\n\n\t\t// If the scanned character is an\n\t\t// \u2018(\u2018, push it to the stack.\n\t\telse if (c == '(')\n\t\t\tst.push('(');\n\n\t\t// If the scanned character is an \u2018)\u2019,\n\t\t// pop and add to the output string from the stack\n\t\t// until an \u2018(\u2018 is encountered.\n\t\telse if (c == ')') {\n\t\t\twhile (st.top() != '(') {\n\t\t\t\tresult += st.top();\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.pop(); // Pop '('\n\t\t}\n\n\t\t// If an operator is scanned\n\t\telse {\n\t\t\twhile (!st.empty() && prec(s[i]) < prec(st.top()) ||\n\t\t\t\t!st.empty() && prec(s[i]) == prec(st.top()) &&\n\t\t\t\tassociativity(s[i]) == 'L') {\n\t\t\t\tresult += st.top();\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.push(c);\n\t\t}\n\t}\n\n\t// Pop all the remaining elements from the stack\n\twhile (!st.empty()) {\n\t\tresult += st.top();\n\t\tst.pop();\n\t}\n\n\tcout << result << endl;\n}\n\n// Driver code\nint main() {\n\tstring exp = \"a+b*(c^d-e)^(f+g*h)-i\";\n\n\t// Function call\n\tinfixToPostfix(exp);\n\n\treturn 0;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'mainwindow.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.1)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../OS_Scheduler/mainwindow.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.6.1. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {};\nstatic constexpr auto qt_meta_stringdata_CLASSMainWindowENDCLASS = QtMocHelpers::stringData(\n    \"MainWindow\",\n    \"on_algorithm_comboBox_currentTextChanged\",\n    \"\",\n    \"arg1\",\n    \"on_no_of_process_value_valueChanged\",\n    \"on_simulate_button_clicked\",\n    \"openWidget\",\n    \"on_AddDynamically_clicked\",\n    \"on_algorithm_comboBox_textHighlighted\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {\n    uint offsetsAndSizes[18];\n    char stringdata0[11];\n    char stringdata1[41];\n    char stringdata2[1];\n    char stringdata3[5];\n    char stringdata4[36];\n    char stringdata5[27];\n    char stringdata6[11];\n    char stringdata7[26];\n    char stringdata8[38];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSMainWindowENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSMainWindowENDCLASS_t qt_meta_stringdata_CLASSMainWindowENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 10),  // \"MainWindow\"\n        QT_MOC_LITERAL(11, 40),  // \"on_algorithm_comboBox_current...\"\n        QT_MOC_LITERAL(52, 0),  // \"\"\n        QT_MOC_LITERAL(53, 4),  // \"arg1\"\n        QT_MOC_LITERAL(58, 35),  // \"on_no_of_process_value_valueC...\"\n        QT_MOC_LITERAL(94, 26),  // \"on_simulate_button_clicked\"\n        QT_MOC_LITERAL(121, 10),  // \"openWidget\"\n        QT_MOC_LITERAL(132, 25),  // \"on_AddDynamically_clicked\"\n        QT_MOC_LITERAL(158, 37)   // \"on_algorithm_comboBox_textHig...\"\n    },\n    \"MainWindow\",\n    \"on_algorithm_comboBox_currentTextChanged\",\n    \"\",\n    \"arg1\",\n    \"on_no_of_process_value_valueChanged\",\n    \"on_simulate_button_clicked\",\n    \"openWidget\",\n    \"on_AddDynamically_clicked\",\n    \"on_algorithm_comboBox_textHighlighted\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSMainWindowENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       6,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    1,   50,    2, 0x08,    1 /* Private */,\n       4,    1,   53,    2, 0x08,    3 /* Private */,\n       5,    0,   56,    2, 0x08,    5 /* Private */,\n       6,    0,   57,    2, 0x08,    6 /* Private */,\n       7,    0,   58,    2, 0x08,    7 /* Private */,\n       8,    1,   59,    2, 0x08,    8 /* Private */,\n\n // slots: parameters\n    QMetaType::Void, QMetaType::QString,    3,\n    QMetaType::Void, QMetaType::Int,    3,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void, QMetaType::QString,    3,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject MainWindow::staticMetaObject = { {\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\n    qt_meta_stringdata_CLASSMainWindowENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSMainWindowENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMainWindowENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,\n        // method 'on_algorithm_comboBox_currentTextChanged'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        QtPrivate::TypeAndForceComplete<const QString &, std::false_type>,\n        // method 'on_no_of_process_value_valueChanged'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        QtPrivate::TypeAndForceComplete<int, std::false_type>,\n        // method 'on_simulate_button_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'openWidget'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_AddDynamica",
    "#include <stdio.h>\n\nint symbole;\n\nint symbole_suivant(void);\nvoid accepter(int a);\nvoid erreur(void);\n\nvoid type(void);\nvoid dcl(void);\nvoid pro(void);\nvoid L_id(void);\nvoid lprim(void);\nvoid dprim(void);\nvoid inst_comp(void);\nvoid exp(void);\nvoid exp_simple(void);\nvoid dprim(void);\nvoid es(void);\nvoid terme(void);\nvoid fact(void);\nvoid eprim(void);\nvoid L_inst(void);\nvoid inst(void);\n\nint main()\n{\n    printf(\"Donner une ligne : \");\n    scanf(\"%d\", &symbole);\n    pro();\n    return 0;\n}\n\nvoid erreur()\n{\n    printf(\"\\nERREUR\\n\");\n}\n\nint symbole_suivant(void)\n{\n    int s;\n    printf(\"Donner le caract\u00e8re suivant : \");\n    scanf(\"%d\", &s);\n    return s;\n}\n\nvoid accepter(int a)\n{\n    if (symbole == a)\n        symbole = symbole_suivant();\n    else\n        erreur();\n}\n\nvoid type()\n{\n    switch (symbole)\n    {\n        case 7:\n        case 8:\n            accepter(symbole);\n            break;\n        default:\n            erreur();\n    }\n}\n\nvoid dcl()\n{\n    if (symbole == 5)\n        dprim();\n}\n\nvoid pro()\n{\n    accepter(1);\n    accepter(2);\n    accepter(3);\n    dcl();\n    inst_comp();\n}\n\nvoid L_id()\n{\n    if (symbole == 2)\n    {\n        accepter(2);\n        lprim();\n    }\n    else\n        erreur();\n}\n\nvoid lprim()\n{\n    if (symbole == 11)\n    {\n        accepter(11);\n        accepter(2);\n        lprim();\n    }\n}\n\nvoid dprim()\n{\n    accepter(5);\n    L_id();\n    accepter(6);\n    type();\n    accepter(3);\n\n    if (symbole == 5)\n        dprim();\n}\n\nvoid inst_comp()\n{\n    if (symbole == 9)\n    {\n        accepter(9);\n        inst();\n        accepter(10);\n        accepter(4);\n    }\n    else\n        erreur();\n}\n\nvoid exp()\n{\n    exp_simple();\n\n    if (symbole == 26)\n        eprim();\n}\n\nvoid exp_simple()\n{\n    terme();\n\n    if (symbole == 24)\n        es();\n}\n\nvoid es()\n{\n    if (symbole == 24)\n    {\n        accepter(24);\n        terme();\n\n        if (symbole == 24)\n            es();\n    }\n    else\n        erreur();\n}\n\nvoid terme()\n{\n    accepter(26);\n    fact();\n\n    if (symbole == 26)\n        lprim();\n}\n\nvoid fact()\n{\n    switch (symbole)\n    {\n        case 27:\n        case 2:\n        case 22:\n            accepter(symbole);\n            break;\n        default:\n            erreur();\n    }\n}\n\nvoid eprim()\n{\n    if (symbole == 26)\n    {\n        accepter(26);\n        exp_simple();\n    }\n}\n\nvoid L_inst()\n{\n    inst();\n}\n\nvoid inst()\n{\n    switch (symbole)\n    {\n        case 13:\n            accepter(13);\n            accepter(22);\n            exp();\n            accepter(23);\n            accepter(14);\n            accepter(9);\n            L_inst();\n            accepter(15);\n            L_inst();\n            accepter(10);\n            break;\n        case 16:\n            accepter(16);\n            accepter(22);\n            exp();\n            accepter(23);\n            accepter(9);\n            L_inst();\n            accepter(10);\n            break;\n        case 2:\n            accepter(2);\n            accepter(12);\n            exp_simple();\n            break;\n\n        case 17:\n            accepter(9);\n            L_inst();\n            accepter(10);\n            accepter(16);\n            break;\n        case 20:\n            accepter(20);\n            accepter(22);\n            L_inst();\n            accepter(23);\n            break;\n        case 21:\n            accepter(21);\n            accepter(22);\n            L_inst();\n            accepter(23);\n            break;\n        case 18:\n            accepter(18);\n            accepter(22);\n            exp();\n            accepter(23);\n            break;\n        case 19:\n            accepter(19);\n            accepter(22);\n            exp();\n            accepter(23);\n            break;\n        case 11:\n            accepter(11);\n            break;\n        case 4:\n            accepter(4);\n            break;\n        case 6:\n            accepter(6);\n            break;\n        case 12:\n            accepter(12);\n            break;\n        case 3:\n            accepter(3);\n            break;\n        default:\n            erreur();\n    }\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//========= Copyright \u00a9 1996-2005, Valve Corporation, All rights reserved. ============//\n//\n// Purpose:\n//\n//=============================================================================//\n\n#ifdef _WIN32\n#define WIN_32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n\n#include \"tier0/dbg.h\"\n#include \"memstack.h\"\n\ntemplate <typename T>\ninline T MemAlign( T val, unsigned alignment )\n{\n\treturn (T)( ( (unsigned)val + alignment - 1 ) & ~( alignment - 1 ) );\n}\n\n//-------------------------------------\n\nCMemoryStack::CMemoryStack()\n : \tm_pBase( NULL ),\n#ifdef _WIN32\n \tm_commitSize( 0 ),\n\tm_minCommit( 0 ),\n#endif\n \tm_size( 0 )\n{\n}\n\t\n//-------------------------------------\n\nCMemoryStack::~CMemoryStack()\n{\n\tif ( m_pBase )\n\t\tTerm();\n}\n\n//-------------------------------------\n\nbool CMemoryStack::Init( unsigned maxSize, unsigned commitSize, unsigned initialCommit )\n{\n\tAssert( !m_pBase );\n\n\tm_size = maxSize;\n\tAssert( m_size > 0 );\n\n#ifdef _WIN32\n\n\tif ( commitSize != 0 )\n\t{\n\t\tm_commitSize = commitSize;\n\t}\n\t\n\n\tSYSTEM_INFO sysInfo;\n\tGetSystemInfo(&sysInfo);\n\n\tAssert( !( sysInfo.dwPageSize & (sysInfo.dwPageSize-1)) );\n\t\n\tif ( m_commitSize == 0 )\n\t{\n\t\tm_commitSize = sysInfo.dwPageSize;\n\t}\n\telse\n\t{\n\t\tm_commitSize = MemAlign( m_commitSize, sysInfo.dwPageSize );\n\t}\n\n\tm_size = MemAlign( m_size, m_commitSize );\n\t\n\tAssert( m_size % sysInfo.dwPageSize == 0 && m_commitSize % sysInfo.dwPageSize == 0 && m_commitSize <= m_size );\n\n\tm_pBase = (unsigned char *)VirtualAlloc( NULL, m_size, MEM_RESERVE, PAGE_NOACCESS );\n\tAssert( m_pBase );\n\tm_pCommitLimit = m_pNextAlloc = m_pBase;\n\n\tif ( initialCommit )\n\t{\n\t\tinitialCommit = MemAlign( initialCommit, m_commitSize );\n\t\tAssert( initialCommit < m_size );\n\t\tif ( !VirtualAlloc( m_pCommitLimit, initialCommit, MEM_COMMIT, PAGE_READWRITE ) )\n\t\t\treturn false;\n\t\tm_minCommit = initialCommit;\n\t\tm_pCommitLimit += initialCommit;\n\t}\n\n#else\n\tm_pBase = new unsigned char[m_size];\n\tm_pNextAlloc = m_pBase;\n\tm_pCommitLimit = m_pBase + m_size;\n#endif\n\n\tm_pAllocLimit = m_pBase + m_size;\n\n\treturn ( m_pBase != NULL );\n}\n\n//-------------------------------------\n\nvoid CMemoryStack::Term()\n{\n\tFreeAll();\n\tif ( m_pBase )\n\t{\n#ifdef _WIN32\n\t\tVirtualFree( m_pBase, 0, MEM_RELEASE );\n#else\n\t\tdelete m_pBase;\n#endif\n\t\tm_pBase = NULL;\n\t}\n}\n\n//-------------------------------------\n\nvoid *CMemoryStack::Alloc( unsigned bytes )\n{\n\tAssert( m_pBase );\n\t\n\tif ( !bytes )\n\t\tbytes = 1;\n\n\tbytes = MemAlign( bytes, 16 );\n\n\tvoid *pResult = m_pNextAlloc;\n\tm_pNextAlloc += bytes;\n\t\n\tif ( m_pNextAlloc > m_pCommitLimit )\n\t{\n#ifdef _WIN32\n\t\tunsigned char *\tpNewCommitLimit = MemAlign( m_pNextAlloc, m_commitSize );\n\t\tunsigned \t\tcommitSize \t\t= pNewCommitLimit - m_pCommitLimit;\n\t\t\n\t\tAssert( m_pCommitLimit + commitSize < m_pAllocLimit );\n\t\tif ( !VirtualAlloc( m_pCommitLimit, commitSize, MEM_COMMIT, PAGE_READWRITE ) )\n\t\t{\n\t\t\tAssert( 0 );\n\t\t\treturn NULL;\n\t\t}\n\t\tm_pCommitLimit = pNewCommitLimit;\n#else\n\t\tAssert( 0 );\n\t\treturn NULL;\n#endif\n\t}\n\telse\n\t{\n\t\t// MEM_COMMIT zeros out the memory, simulate that if mem is reused\n\t\tmemset( pResult, 0, bytes );\n\t}\n\t\n\treturn pResult;\n}\n\n//-------------------------------------\n\nvoid *CMemoryStack::GetBase()\n{\n\treturn m_pBase;\n}\n\n//-------------------------------------\n\nvoid *CMemoryStack::GetCurrentAllocPoint()\n{\n\treturn m_pNextAlloc;\n}\n\n//-------------------------------------\n\nvoid CMemoryStack::FreeToAllocPoint( void *pAllocPoint )\n{\n\tAssert( pAllocPoint >= m_pBase && pAllocPoint <= m_pNextAlloc );\n\t\n\tif ( pAllocPoint >= m_pBase && pAllocPoint < m_pNextAlloc )\n\t{\n#ifdef _WIN32\n\t\tunsigned char *pDecommitPoint = MemAlign( (unsigned char *)pAllocPoint, m_commitSize );\n\n\t\tif ( pDecommitPoint < m_pBase + m_minCommit )\n\t\t{\n\t\t\tpDecommitPoint = m_pBase + m_minCommit;\n\t\t}\n\n\t\tunsigned decommitSize = m_pCommitLimit - pDecommitPoint;\n\t\t\n\t\tif ( decommitSize > 0 )\n\t\t{\n\t\t\tVirtualFree( pDecommitPoint, decommitSize, MEM_DECOMMIT );\n\t\t\tm_pCommitLimit = pDecommitPoint;\n\t\t}\n#endif\n\t\tm_pNextAlloc = (unsigned char *)pAllocPoint;\n\t}\n}\n\n//-------------------------------------\n\nvoid CMemoryStack::FreeAll()\n{\n\tif ( m_pBase && m_pCommitLimit - m_pBase > 0 )\n\t{\n#ifdef _WIN32\n\t\tVirtualFree( m_pBase, m_pCommitLimit - m_pBase, MEM_DECOMMIT );\n\t\tm_pCommitLimit = m_pBase;\n#endif\n\t\tm_pNextAlloc = m_pBase;\n\t}\n}\n\n//-------------------------------------\n\nvoid CMemoryStack::Access( void **ppRegion, unsigned *pBytes )\n{\n\t*ppRegion = m_pBase;\n\t*pBytes = ( m_pNextAlloc - m_pBase);\n}\n\n//-----------------------------------------------------------------------------\n",
    "#include <Windows.h>\n#include <string>\n#include <iostream> \n#include \"resource.h\"\n#include <atlconv.h>\n#include <tchar.h>\n#include <cassert>\n\n\nHWND CURRENT_WINDOW;\nHINSTANCE CURRENT_HINSTANCE;\nNOTIFYICONDATA SYSTRAY_DATA;\n#define UNIQUE_MK_AUTOTYPER L\"MK-AutoTyper\"\nHWND BTN_TYPE;\n\nvoid SendCharacter(TCHAR character) {\n    INPUT keystrokes[2] = {};\n\n    // Keydown event\n    keystrokes[0].type = INPUT_KEYBOARD;\n    keystrokes[0].ki.wVk = 0;\n    keystrokes[0].ki.wScan = character;\n    keystrokes[0].ki.dwFlags = KEYEVENTF_UNICODE;\n\n    // Keyup event\n    keystrokes[1].type = INPUT_KEYBOARD;\n    keystrokes[1].ki.wVk = 0;\n    keystrokes[1].ki.wScan = character;\n    keystrokes[1].ki.dwFlags = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;\n\n    // Check if the character is a newline\n    if (character == L'\\n') {\n        // Change the character to VK_RETURN\n        keystrokes[0].ki.wVk = VK_RETURN;\n        keystrokes[1].ki.wVk = VK_RETURN;\n    }\n\n    SendInput(2, keystrokes, sizeof(INPUT));\n}\n// Function to simulate keystrokes\nvoid simulateKeystrokes(const std::wstring& input,const int&keyStrokeDelay, const int& initialDelay) {\n    Sleep(initialDelay);\n    HWND foregroundWindow = GetForegroundWindow();\n    TCHAR* keyChars = W2T((wchar_t*)input.c_str());\n    for (UINT i = 0; i < _tcslen(keyChars); ++i) {\n        if (foregroundWindow != GetForegroundWindow()) {\n            break;\n        }\n        SendCharacter(keyChars[i]);\n        Sleep(keyStrokeDelay); // Can be adjusted\n    }\n}\n\n// Windows procedure function\nHWND textboxTypeContent, txtKeyStrokeDelay, txtInitialDelay;\nstd::wstring getTxtBoxString(HWND txtBox) {\n    int length = GetWindowTextLength(txtBox);\n    std::wstring buffer(length + 1, L'\\0');\n    GetWindowText(txtBox, &buffer[0], length + 1);\n    std::wstring input(buffer.begin(), buffer.end());\n    return input;\n}\n\nint getiInitialDelay() {\n    int iInitialDelay = 1000;\n    try {\n        iInitialDelay = std::stoi(getTxtBoxString(txtInitialDelay));\n    }\n    catch (const std::exception& e) {\n        SetWindowText(txtInitialDelay, L\"1000\");\n    }\n    return iInitialDelay;\n}\n\nint getIKeyStrokeDelay() {\n    int iKeyStrokeDelay = 10;\n    try {\n        iKeyStrokeDelay = std::stoi(getTxtBoxString(txtKeyStrokeDelay));\n    }\n    catch (const std::exception& e) {\n        SetWindowText(txtKeyStrokeDelay, L\"10\");\n    }\n    return iKeyStrokeDelay;\n}\n\n// Function to create systray icon\nvoid CreateSystemTrayIcon(HWND hWnd) {\n    SYSTRAY_DATA.cbSize = sizeof(NOTIFYICONDATA);\n    SYSTRAY_DATA.hWnd = hWnd;\n    SYSTRAY_DATA.uID = 1;\n    SYSTRAY_DATA.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;\n    SYSTRAY_DATA.uCallbackMessage = WM_USER + 1;\n    SYSTRAY_DATA.hIcon = LoadIcon(CURRENT_HINSTANCE, MAKEINTRESOURCE(IDI_SMALL));\n    lstrcpy(SYSTRAY_DATA.szTip, TEXT(\"MK AutoTyper\"));\n\n    Shell_NotifyIcon(NIM_ADD, &SYSTRAY_DATA);\n}\n\n// Function to handle right-click context menu\nvoid ShowContextMenu(HWND hWnd) {\n    POINT pt;\n    GetCursorPos(&pt);\n\n    HMENU hMenu = CreatePopupMenu();\n    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, TEXT(\"Exit\"));\n\n    SetForegroundWindow(hWnd); // Set the window as foreground\n    TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);\n    DestroyMenu(hMenu);\n}\n\n// Function to remove systray icon\nvoid RemoveSystemTrayIcon() {\n    Shell_NotifyIcon(NIM_DELETE, &SYSTRAY_DATA);\n}\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n    switch (uMsg) {\n    case WM_CREATE: {\n        textboxTypeContent = CreateWindowEx(WS_EX_CLIENTEDGE, L\"EDIT\", L\"\", WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL, 10, 10, 760, 500, hwnd, NULL, GetModuleHandle(NULL), NULL);\n        BTN_TYPE = CreateWindow(L\"BUTTON\", L\"TYPE\", WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 10, 520, 100, 30, hwnd, NULL, GetModuleHandle(NULL), NULL);\n        HWND labelKeyStrokeDelay = CreateWindowEx(0, L\"STATIC\", L\"Keystroke delay (ms):\", WS_CHILD | WS_VISIBLE, 130, 520, 120, 30, hwnd, NULL, GetModuleHandle(NULL), NULL);\n        txtKeyStrokeDelay = CreateWindowEx(WS_EX_CLIENTEDGE, L\"EDIT\", L\"10\", WS_CHILD | ES_NUMBER | WS_VISIBLE | ES_AUTOVSCROLL | ES_AUTOHSCROLL, 255, 520, 100, 30, hwnd, NULL, GetModuleHandle(NULL), NULL);\n        HWND labelInitialDelay = CreateWindowEx(0, L\"STATIC\", L\"Initial delay (ms):\", WS_CHILD | WS_VISIBLE, 385, 520, 120, 30, hwnd, NULL, GetModuleHandle(NULL), NULL);\n        txtInitialDelay = CreateWindowEx(WS_EX_CLIENTEDGE, L\"EDIT\", L\"1000\", WS_CHILD | ES_NUMBER | WS_VISIBLE | ES_AUTOVSCROLL | ES_AUTOHSCROLL, 510, 520, 100, 30, hwnd, NULL, GetModuleHandle(NULL), NULL);\n\n        break;\n    }\n    case WM_COMMAND: {\n        switch (LOWORD(wParam)) {\n            case 1: { // ID of the button\n                if (HIWORD(wParam) == 0) {\n                    RemoveSystemTrayIcon();\n                    PostQuitMessage(0);\n                }\n                break;\n            } case BN_CLICKED: {\n                if ((HWND)lParam == BTN_TYPE) {\n     ",
    "#include <SDL2/SDL.h>\n#include <iostream>\n\nconst int SCREEN_WIDTH = 640;\nconst int SCREEN_HEIGHT = 480;\nconst int PLAYER_SIZE = 20;\nconst int OBJECT_SIZE = 10;\nconst int OBSTACLE_SIZE = 30;\nconst int NUM_OBJECTS = 5;\nconst int NUM_OBSTACLES = 5;\n\nSDL_Window* gWindow = NULL;\nSDL_Renderer* gRenderer = NULL;\n\nSDL_Rect playerRect = { SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, PLAYER_SIZE, PLAYER_SIZE };\nSDL_Rect objects[NUM_OBJECTS];\nSDL_Rect obstacles[NUM_OBSTACLES];\n\nint score = 0;\nint playerSpeed = 5;\n\nvoid initializeSDL() {\n    SDL_Init(SDL_INIT_VIDEO);\n    gWindow = SDL_CreateWindow(\"Simple SDL Game\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED);\n}\n\nvoid closeSDL() {\n    SDL_DestroyRenderer(gRenderer);\n    SDL_DestroyWindow(gWindow);\n    SDL_Quit();\n}\n\nvoid handleInput() {\n    SDL_Event e;\n    while (SDL_PollEvent(&e) != 0) {\n        if (e.type == SDL_QUIT) {\n            closeSDL();\n            exit(0);\n        }\n        else if (e.type == SDL_KEYDOWN) {\n            switch (e.key.keysym.sym) {\n                case SDLK_UP:\n                    if (playerRect.y > 0)\n                        playerRect.y -= playerSpeed;\n                    break;\n                case SDLK_DOWN:\n                    if (playerRect.y < SCREEN_HEIGHT - PLAYER_SIZE)\n                        playerRect.y += playerSpeed;\n                    break;\n                case SDLK_LEFT:\n                    if (playerRect.x > 0)\n                        playerRect.x -= playerSpeed;\n                    break;\n                case SDLK_RIGHT:\n                    if (playerRect.x < SCREEN_WIDTH - PLAYER_SIZE)\n                        playerRect.x += playerSpeed;\n                    break;\n            }\n        }\n    }\n}\n\nvoid generateObjectsAndObstacles() {\n    for (int i = 0; i < NUM_OBJECTS; ++i) {\n        objects[i].x = rand() % (SCREEN_WIDTH - OBJECT_SIZE);\n        objects[i].y = rand() % (SCREEN_HEIGHT - OBJECT_SIZE);\n        objects[i].w = OBJECT_SIZE;\n        objects[i].h = OBJECT_SIZE;\n    }\n\n    for (int i = 0; i < NUM_OBSTACLES; ++i) {\n        obstacles[i].x = rand() % (SCREEN_WIDTH - OBSTACLE_SIZE);\n        obstacles[i].y = rand() % (SCREEN_HEIGHT - OBSTACLE_SIZE);\n        obstacles[i].w = OBSTACLE_SIZE;\n        obstacles[i].h = OBSTACLE_SIZE;\n    }\n}\n\nbool checkCollision(SDL_Rect rect1, SDL_Rect rect2) {\n    return (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x && rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y);\n}\n\nvoid render() {\n    SDL_SetRenderDrawColor(gRenderer, 255, 255, 255, 255);\n    SDL_RenderClear(gRenderer);\n\n    // Render player\n    SDL_SetRenderDrawColor(gRenderer, 255, 0, 0, 255);\n    SDL_RenderFillRect(gRenderer, &playerRect);\n\n    // Render objects\n    SDL_SetRenderDrawColor(gRenderer, 0, 255, 0, 255);\n    for (int i = 0; i < NUM_OBJECTS; ++i) {\n        SDL_RenderFillRect(gRenderer, &objects[i]);\n    }\n\n    // Render obstacles\n    SDL_SetRenderDrawColor(gRenderer, 0, 0, 255, 255);\n    for (int i = 0; i < NUM_OBSTACLES; ++i) {\n        SDL_RenderFillRect(gRenderer, &obstacles[i]);\n    }\n\n    SDL_RenderPresent(gRenderer);\n}\n\nint main(int argc, char* args[]) {\n    initializeSDL();\n    generateObjectsAndObstacles();\n\n    bool quit = false;\n    while (!quit) {\n        handleInput();\n\n        // Collision detection\n        for (int i = 0; i < NUM_OBJECTS; ++i) {\n            if (checkCollision(playerRect, objects[i])) {\n                std::cout << \"Object collected!\\n\";\n                objects[i].x = rand() % (SCREEN_WIDTH - OBJECT_SIZE);\n                objects[i].y = rand() % (SCREEN_HEIGHT - OBJECT_SIZE);\n                score++;\n                playerSpeed += 1; // Increase speed\n                std::cout << '\\a';\n            }\n        }\n\n        for (int i = 0; i < NUM_OBSTACLES; ++i) {\n            if (checkCollision(playerRect, obstacles[i])) {\n                std::cout << \"Game Over!\\n\";\n                quit = true;\n            }\n        }\n\n        render();\n    }\n\n    closeSDL();\n    return 0;\n}\n",
    "/**********************************************************************************************************************\r\n * Copyright (c) Prophesee S.A. - All Rights Reserved                                                                 *\r\n *                                                                                                                    *\r\n * Subject to Prophesee Metavision Licensing Terms and Conditions (\"License T&C's\").                                  *\r\n * You may not use this file except in compliance with these License T&C's.                                           *\r\n * A copy of these License T&C's is located in the \"licensing\" folder accompanying this file.                         *\r\n **********************************************************************************************************************/\r\n\r\n#include <opencv2/highgui.hpp>\r\n#include <opencv2/imgproc.hpp>\r\n#include <opencv2/calib3d/calib3d.hpp>\r\n#if CV_MAJOR_VERSION >= 4\r\n#include <opencv2/calib3d/calib3d_c.h>\r\n#endif\r\n\r\n#include <metavision/sdk/base/events/event_cd.h>\r\n#include <metavision/sdk/calibration/utils/calibration_detection_frame_generator.h>\r\n#include <metavision/sdk/calibration/utils/points_on_grid.h>\r\n\r\n#include \"blinking_chessboard_detector.h\"\r\n\r\nnamespace Metavision {\r\n\r\nBlinkingChessBoardDetector::BlinkingChessBoardDetector(int width, int height, int cols, int rows,\r\n                                                       const BlinkingFrameGeneratorAlgorithmConfig &config,\r\n                                                       timestamp skip_time_us, bool debug) :\r\n    width_(width),\r\n    height_(height),\r\n    cols_(cols),\r\n    rows_(rows),\r\n    grid_size_(cols, rows),\r\n    use_inverted_gray_(true),\r\n    cos_max_angle_(std::cos(3.14159 / 9)),\r\n    last_ts_(-skip_time_us - 1), // Avoid making the algorithm wait until ts=skip_time_us_\r\n    skip_time_us_(skip_time_us),\r\n    debug_(debug) {\r\n    algo_ = std::make_unique<BlinkingFrameGeneratorAlgorithm>(width, height, config);\r\n    algo_->set_output_callback([this](timestamp ts, cv::Mat &frame) { on_blinking_frame(ts, frame); });\r\n    new_frame_.create(height, width, CV_8UC1);\r\n    frame_.create(height, width, CV_8UC1);\r\n}\r\n\r\nBlinkingChessBoardDetector::~BlinkingChessBoardDetector() {}\r\n\r\ntemplate<typename InputIt>\r\nvoid BlinkingChessBoardDetector::process_events(InputIt it_begin, InputIt it_end) {\r\n    algo_->process_events(it_begin, it_end);\r\n}\r\n\r\nvoid BlinkingChessBoardDetector::set_output_callback(const OutputCb &output_cb) {\r\n    output_cb_ = output_cb;\r\n}\r\n\r\nvoid BlinkingChessBoardDetector::on_blinking_frame(timestamp ts, cv::Mat &cb_frame) {\r\n    const int calibration_flags = CV_CALIB_CB_FILTER_QUADS;\r\n\r\n    if (ts < last_ts_ + skip_time_us_)\r\n        return;\r\n\r\n    if (cb_frame.empty())\r\n        return;\r\n\r\n    if (use_inverted_gray_)\r\n        cb_frame.convertTo(new_frame_, CV_8UC1, -1., 255.); // map linearly 0 to 255 and 255 to 0\r\n    else\r\n        cb_frame.convertTo(new_frame_, CV_8UC1); // keep the pixel intensity\r\n\r\n    cv::bitwise_xor(new_frame_, frame_, dst_);\r\n    if (!cv::countNonZero(dst_))\r\n        return;\r\n\r\n    if (debug_) {\r\n        cv::imshow(\"[DEBUG] Blinking frame\", new_frame_);\r\n        cv::waitKey(1);\r\n    }\r\n\r\n    output_calib_results_.reset(height_, width_, CV_8UC3);\r\n    auto &keypoints = output_calib_results_.keypoints_;\r\n\r\n    cv::swap(frame_, new_frame_);\r\n    if (!cv::findChessboardCorners(frame_, grid_size_, keypoints, calibration_flags))\r\n        return;\r\n\r\n    cv::TermCriteria criteria(cv::TermCriteria::EPS + cv::TermCriteria::COUNT, 40, 0.001);\r\n    cv::cornerSubPix(frame_, keypoints, cv::Size(11, 11), cv::Size(-1, -1), criteria);\r\n\r\n    if (!Metavision::are_points_on_grid_radial_distortion(keypoints, cols_, rows_, cos_max_angle_))\r\n        return;\r\n\r\n    auto &output_mat = output_calib_results_.frame_;\r\n    cv::cvtColor(frame_, output_mat, cv::COLOR_GRAY2BGR);\r\n    output_cb_(ts, output_calib_results_);\r\n    last_ts_ = ts;\r\n}\r\n\r\n// Template instantiation\r\ntemplate void BlinkingChessBoardDetector::process_events(std::vector<Metavision::EventCD>::const_iterator first,\r\n                                                         std::vector<Metavision::EventCD>::const_iterator last);\r\ntemplate void BlinkingChessBoardDetector::process_events(const Metavision::EventCD *first,\r\n                                                         const Metavision::EventCD *last);\r\n\r\n} // namespace Metavision\r\n",
    "#include <iostream>\n#include <map>\n#include <fstream>\n\nusing namespace std;\n\nstruct Produto {\n    string nome;\n    int quantidade;\n    string validade;\n    string fornecedor;\n    float custo;\n    float precoVenda;\n};\n\nmap<string, Produto> estoque; // Mapa para armazenar os produtos\n\nvoid adicionarProduto() {\n    Produto produto;\n\n    cout << \"Digite o nome do produto: \";\n    cin >> produto.nome;\n\n    cout << \"Digite a quantidade do produto: \";\n    cin >> produto.quantidade;\n\n    cout << \"Digite a data de validade do produto (dd/mm/aaaa): \";\n    cin >> produto.validade;\n\n    cout << \"Digite o nome do fornecedor do produto: \";\n    cin >> produto.fornecedor;\n\n    cout << \"Digite o custo do produto: \";\n    cin >> produto.custo;\n\n    // Calcula o pre\u00e7o de venda como o dobro do custo\n    produto.precoVenda = produto.custo * 2;\n\n    estoque[produto.nome] = produto;\n\n    cout << \"Produto adicionado com sucesso!\" << endl;\n}\n\nvoid removerProduto() {\n    string nome;\n\n    cout << \"Digite o nome do produto a ser removido: \";\n    cin >> nome;\n\n    if (estoque.find(nome) != estoque.end()) {\n        estoque.erase(nome);\n        cout << \"Produto removido com sucesso!\" << endl;\n    } else {\n        cout << \"Produto nao encontrado.\" << endl;\n    }\n}\n\nvoid editarProduto() {\n    string nome;\n\n    cout << \"Digite o nome do produto a ser editado: \";\n    cin >> nome;\n\n    if (estoque.find(nome) != estoque.end()) {\n        Produto& produto = estoque[nome];\n\n        cout << \"Digite a nova quantidade do produto: \";\n        cin >> produto.quantidade;\n\n        cout << \"Digite a nova data de validade do produto (dd/mm/aaaa): \";\n        cin >> produto.validade;\n\n        cout << \"Digite o novo nome do fornecedor do produto: \";\n        cin >> produto.fornecedor;\n\n        cout << \"Produto editado com sucesso!\" << endl;\n    } else {\n        cout << \"Produto nao encontrado.\" << endl;\n    }\n}\n\nvoid exibirEstoque() {\n    cout << \"Estoque atual:\" << endl;\n    for (map<string, Produto>::iterator it = estoque.begin(); it != estoque.end(); ++it) {\n        cout << \"Nome: \" << it->second.nome << endl;\n        cout << \"Quantidade: \" << it->second.quantidade << endl;\n        cout << \"Data de Validade: \" << it->second.validade << endl;\n        cout << \"Fornecedor: \" << it->second.fornecedor << endl;\n        cout << \"Custo: R$ \" << it->second.custo << endl;\n        cout << \"Preco de Venda: R$ \" << it->second.precoVenda << endl;\n        cout << \"--------------------------\" << endl;\n    }\n}\n\nvoid gerarRelatorioTXT() {\n    ofstream relatorio(\"relatorio.txt\");\n    if (!relatorio.is_open()) {\n        cout << \"Erro ao criar arquivo de relatorio\" << endl;\n        return;\n    }\n\n    relatorio << \"Relatorio de Estoque\" << endl;\n    for (map<string, Produto>::iterator it = estoque.begin(); it != estoque.end(); ++it) {\n        relatorio << \"Nome: \" << it->second.nome << endl;\n        relatorio << \"Quantidade: \" << it->second.quantidade << endl;\n        relatorio << \"Data de Validade: \" << it->second.validade << endl;\n        relatorio << \"Fornecedor: \" << it->second.fornecedor << endl;\n        relatorio << \"Custo: R$ \" << it->second.custo << endl;\n        relatorio << \"Preco de Venda: R$ \" << it->second.precoVenda << endl;\n        relatorio << \"--------------------------\" << endl;\n    }\n\n    relatorio.close();\n\n    cout << \"Relatorio gerado com sucesso (relatorio.txt)\" << endl;\n}\n\nint main() {\n    int escolha;\n\n    do {\n        cout << \"======================================\" << endl;\n        cout <<\"Sistema de Gerenciamento de Estoque  v1.0\"<<endl;\n        cout << \"Escolha uma opcao:\" << endl;\n        cout << \"1. Adicionar Produto\" << endl;\n        cout << \"2. Remover Produto\" << endl;\n        cout << \"3. Editar Produto\" << endl;\n        cout << \"4. Exibir Estoque\" << endl;\n        cout << \"5. Gerar Relatorio em TXT\" << endl;\n        cout << \"6. Sair\" << endl;\n        cout << \"Escolha uma opcao: \";\n        cin >> escolha;\n\n        switch (escolha) {\n            case 1:\n                adicionarProduto();\n                break;\n            case 2:\n                removerProduto();\n                break;\n            case 3:\n                editarProduto();\n                break;\n            case 4:\n                exibirEstoque();\n                break;\n            case 5:\n                gerarRelatorioTXT();\n                break;\n            case 6:\n                cout << \"Saindo do programa...\" << endl;\n                break;\n            default:\n                cout << \"Opcao invalida. Tente novamente.\" << endl;\n                break;\n        }\n    } while (escolha != 6);\n\n    return 0;\n}\n",
    "\n#include <iostream>\n#include <pcap.h>\n#include <netinet/ip.h> // For IP header structure\n#include <netinet/tcp.h> // For TCP header structure\n#include <netinet/udp.h> // For UDP header structure\n#include <iomanip> // For std::hex, std::setw, std::setfill\n\nvoid packetHandler(unsigned char* userData, const struct pcap_pkthdr* pkthdr, const unsigned char* packet) {\n    // Increment the packet count\n    static int packetCount = 0;\n    packetCount++;\n\n    // Print the raw packet data\n    std::cout << \"Packet count: \" << packetCount << std::endl;\n    for (int i = 0; i < pkthdr->len; ++i) {\n        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(packet[i]) << \" \";\n        if ((i + 1) % 16 == 0)\n            std::cout << std::endl;\n    }\n    std::cout << std::endl;\n\n    // Extract the IP header\n    const struct ip* ipHeader = reinterpret_cast<const struct ip*>(packet + 14); // Skip Ethernet header (14 bytes)\n\n    // Get source and destination IP addresses\n    const char* srcIP = inet_ntoa(ipHeader->ip_src);\n    const char* destIP = inet_ntoa(ipHeader->ip_dst);\n\n    // Determine the transport layer protocol\n    if (ipHeader->ip_p == IPPROTO_TCP) {\n        const struct tcphdr* tcpHeader = reinterpret_cast<const struct tcphdr*>(packet + 14 + ipHeader->ip_hl * 4);\n        std::cout << \"Packet count: \" << packetCount << \" (TCP)\" << std::endl;\n        std::cout << \"Source IP: \" << srcIP << \", Source Port: \" << ntohs(tcpHeader->th_sport) << std::endl;\n        std::cout << \"Destination IP: \" << destIP << \", Destination Port: \" << ntohs(tcpHeader->th_dport) << std::endl;\n    } else if (ipHeader->ip_p == IPPROTO_UDP) {\n        const struct udphdr* udpHeader = reinterpret_cast<const struct udphdr*>(packet + 14 + ipHeader->ip_hl * 4);\n        std::cout << \"Packet count: \" << packetCount << \" (UDP)\" << std::endl;\n        std::cout << \"Source IP: \" << srcIP << \", Source Port: \" << ntohs(udpHeader->uh_sport) << std::endl;\n        std::cout << \"Destination IP: \" << destIP << \", Destination Port: \" << ntohs(udpHeader->uh_dport) << std::endl;\n    } else {\n        std::cout << \"Packet count: \" << packetCount << \" (Other protocol)\" << std::endl;\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    char errbuf[PCAP_ERRBUF_SIZE];\n    pcap_t* pcapHandle;\n\n    // Replace \"ens33\" with the name of your network interface\n    const char* device = \"ens33\";\n\n    // Open the network interface for live packet capture\n    pcapHandle = pcap_open_live(device, BUFSIZ, 1, 1000, errbuf);\n    if (pcapHandle == nullptr) {\n        std::cerr << \"Error opening device: \" << errbuf << std::endl;\n        return 1;\n    }\n\n    // Set a packet handler callback\n    pcap_loop(pcapHandle, 0, packetHandler, nullptr);\n\n    // Close the capture handle when done\n    pcap_close(pcapHandle);\n\n    return 0;\n}\n\n\n\n\n",
    "#include <KeyEngineCore\\Camera.hpp>\n\n#include <glm/trigonometric.hpp>\n\nnamespace KeyEngine {\n\n\tCamera::Camera(const glm::vec3& position,\n\t\tconst glm::vec3& rotation,\n\t\tconst ProjectionMode projection_mode)\n\t\t: m_position(position)\n\t\t, m_rotation(rotation)\n\t\t, m_projection_mode(projection_mode)\n\t{\n\t\tupdate_view_matrix();\n\t\tupdate_projection_matrix();\n\t}\n\n\tvoid Camera::update_view_matrix()\n\t{\n\t\tfloat rotate_in_radians_x = glm::radians(-m_rotation.x);\n\t\tglm::mat4 rotate_matrix_x(1, 0, 0, 0,\n\t\t\t0, cos(rotate_in_radians_x), sin(rotate_in_radians_x), 0,\n\t\t\t0, -sin(rotate_in_radians_x), cos(rotate_in_radians_x), 0,\n\t\t\t0, 0, 0, 1);\n\n\t\tfloat rotate_in_radians_y = glm::radians(-m_rotation.y);\n\t\tglm::mat4 rotate_matrix_y(cos(rotate_in_radians_y), 0, -sin(rotate_in_radians_y), 0,\n\t\t\t0, 1, 0, 0,\n\t\t\tsin(rotate_in_radians_y), 0, cos(rotate_in_radians_y), 0,\n\t\t\t0, 0, 0, 1);\n\n\t\tfloat rotate_in_radians_z = glm::radians(-m_rotation.z);\n\t\tglm::mat4 rotate_matrix(cos(rotate_in_radians_z), sin(rotate_in_radians_z), 0, 0,\n\t\t\t-sin(rotate_in_radians_z), cos(rotate_in_radians_z), 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1);\n\n\t\tglm::mat4 translate_matrix(1,\t\t\t   0,\t\t\t   0,\t\t\t   0,\n\t\t\t\t\t\t\t\t   0,\t\t\t   1,\t\t\t   0,\t\t\t   0,\n\t\t\t\t\t\t\t\t   0,\t\t\t   0,\t\t\t   1,\t\t\t   0,\n\t\t\t\t\t\t\t\t   -m_position[0], -m_position[1], -m_position[2], 1);\n\n\t\tm_view_matrix = rotate_matrix_y * rotate_matrix_x * translate_matrix;\n\t}\n\n\tvoid Camera::update_projection_matrix()\n\t{\n        if (m_projection_mode == ProjectionMode::Perspective)\n        {\n            float r = 0.1f;\n            float t = 0.1f;\n            float f = 10;\n            float n = 0.1f;\n            m_projection_matrix = glm::mat4(n / r, 0, 0, 0,\n                                            0, n / t, 0, 0,\n                                            0, 0, (-f - n) / (f - n), -1,\n                                            0, 0, -2 * f * n / (f - n), 0);\n        }\n        else\n        {\n            float r = 2;\n            float t = 2;\n            float f = 100;\n            float n = 0.1f;\n            m_projection_matrix = glm::mat4(1 / r, 0, 0, 0,\n                                            0, 1 / t, 0, 0,\n                                            0, 0, -2 / (f - n), 0,\n                                            0, 0, (-f - n) / (f - n), 1);\n        }\n\t}\n\n\tvoid Camera::set_position(const glm::vec3& position)\n\t{\n\t\tm_position = position;\n\t\tupdate_view_matrix();\n\t}\n\n\tvoid Camera::set_rotation(const glm::vec3& rotation)\n\t{\n\t\tm_rotation = rotation;\n\t\tupdate_view_matrix();\n\t}\n\n\tvoid Camera::set_position_rotation(const glm::vec3& position, const glm::vec3& rotation)\n\t{\n\t\tm_position = position;\n\t\tm_rotation = rotation;\n\t\tupdate_view_matrix();\n\t}\n\n\tvoid Camera::set_projection_mode(const ProjectionMode projection_mode)\n\t{\n\t\tm_projection_mode = projection_mode;\n\t\tupdate_projection_matrix();\n\t}\n}",
    "#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\n\n\nvoid program_1()\n{\n    cout << \"Enter The Number OF Rows : \";\n    int row, column ;\n    cin >> row;\n    cout << endl << \"Enter The Number Of Columns : \";\n    cin >> column; cout << endl;\n    int data[row][column], mean, max, min;\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            cout << \"Enter The  [ \"<<index <<\" ] [ \"<< index_2 <<\"] : \";\n            cin >> data[index][index_2];\n            if (index == 0 && index_2 == 0)\n            {\n                min = data[index][index_2], max = data[index][index_2], mean = data[index][index_2];\n            }\n            else\n            {\n                mean += data[index][index_2];\n                if (data[index][index_2] > max)\n                    max = data[index][index_2];\n                if (data[index][index_2] < min)\n                    min = data[index][index_2];\n            }\n            cout << endl;\n        }\n    }\n    cout << \"Mean : \" << mean / (row * column);\n    cout << \"\\nMax : \" << max << \"\\nMin : \" << min <<endl;\n}\n\n\nvoid program_2()\n{\n    cout << \"Enter The Number OF Rows : \";\n    int row, column ;\n    cin >> row;\n//    cout << endl << \"Enter The Number Of Columns : \";\n//    cin >> column; cout << endl;\n    column = row;\n    int data[row][column], answer = 0;\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            cout << \"Enter The  [ \"<<index <<\" ] [ \"<< index_2 <<\"] : \";\n            cin >> data[index][index_2];\n            cout << endl;\n        }\n    }\n\n    for (int index = 0; index < row; index++)\n    {\n        answer += data[index][index];\n    }\n\n    cout << \"Answer Is : \" << answer << endl;\n}\n\nvoid program_3()\n{\n    // making things ready\n    cout << \"Enter The Number OF Rows : \";\n    int row, column ;\n    cin >> row;\n    cout << endl << \"Enter The Number Of Columns : \";\n    cin >> column; cout << endl;\n\n    int data[row][column], mean = 0;\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            cout << \"Enter The  [ \"<<index <<\" ] [ \"<< index_2 <<\"] : \";\n            cin >> data[index][index_2];\n            mean += data[index][index_2];\n            cout << endl;\n        }\n    }\n    //caculating\n    mean /= (row * column);\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            if (data[index][index_2] < mean)\n                data[index][index_2] = -1;\n            else if (data[index][index_2] == mean)\n                data[index][index_2] = 0;\n            else if (data[index][index_2] > mean)\n                data[index][index_2] = 1;\n        }\n    }\n    //showing\n    cout << \"Mean IS : \" << mean << endl;\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            cout << \"[ \"<<index <<\" ] [ \"<< index_2 <<\"] : \" << data[index][index_2] << endl;\n        }\n    }\n\n}\n\nvoid program_4()\n{\n    // making things ready\n    cout << \"Enter The Number OF Rows : \";\n    int row, column ;\n    cin >> row;\n    cout << endl << \"Enter The Number Of Columns : \";\n    cin >> column; cout << endl;\n\n    int data[row][column], mean = 0;\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            cout << \"Enter The  [ \"<<index <<\" ] [ \"<< index_2 <<\"] : \";\n            cin >> data[index][index_2];\n            mean += data[index][index_2];\n            cout << endl;\n        }\n    }\n\n    int e_r = row-1 , e_c = column-1, counter = 0;\n    bool end = true;\n    for (int index = 0; index < row && end; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            if (counter == ((row * column)/2))\n            {\n                end = false;\n                break;\n            }\n            int temp_v = data[index][index_2];\n            data[index][index_2] = data[e_r][e_c];\n            data[e_r][e_c] = temp_v;\n            e_c--;\n            counter ++;\n\n        }\n        e_r --;\n        e_c = column-1;\n    }\n\n    for (int index = 0; index < row; index++)\n    {\n        for(int index_2 = 0; index_2 < column; index_2++)\n        {\n            cout << \"[ \"<<index <<\" ] [ \"<< index_2 <<\"] : \" << data[index][index_2] << endl;\n        }\n    }\n}\n\n\n\n\nint main() {\n    system(\"color f3\");\n    program_4();\n\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\nvoid rules();\r\n\r\nint main()\r\n{\r\n\tstring name;\r\n\tint amnt;\r\n\tint bidamnt;\r\n\tint guess;\r\n\tint dice;\r\n\tchar choice;\r\n\r\n\tsrand(time(0));\t// Use for Generating Random Number Each Time.\r\n\r\n\tcout << \"\\n===============================================================================================\";\r\n\tcout << \"\\n   CCCCC      A        SSSSSSSSS   IIIIIIIII  NN     NN    OOOOOOOO     \";\r\n\tcout << \"\\n CC          A  A      SS             III     NN N   NN   OO      OO    \";\r\n\tcout << \"\\nCC          A    A     SSSSSSSSS      III     NN  N  NN   OO      OO    \";\r\n\tcout << \"\\n CC        AAAAAAAA           SS      III     NN   N NN   OO      OO    \";\r\n\tcout << \"\\n   CCCCC  A        A   SSSSSSSSS   IIIIIIIII  NN     NN    OOOOOOOO     \";\r\n\tcout << \"\\n===============================================================================================\\n\";\r\n\r\n\tcout << \"\\nEnter Player Name: \";\r\n\tgetline(cin, name);\r\n\r\n\tcout << \"\\nDeposit Your Amount: $\";\r\n\tcin >> amnt;\r\n\r\n\tdo {\r\n\t\tsystem(\"cls\");\r\n\t\trules();\r\n\t\tdo { \tcout << \"\\nWelcome \" << name << \" Are You Ready To Play? \" << \"\\n\\n\";\r\n\t\t\tcout << \"Enter Bid Amount: $\";\r\n\t\t\tcin >> bidamnt;\r\n\t\t\tif (bidamnt > amnt)\r\n\t\t\t\tcout << \"You Can not Bid More Than Current Amount\\n\" <<\r\n\t\t\t\t\"\\nRe-enter Amount: \";\r\n\t\t} while (bidamnt > amnt);\r\n\r\n\t\tdo { \tcout << \"Guess The Number Between 1 To 10 :\";\r\n\t\t\tcin >> guess;\r\n\t\t\tif (guess <= 0 || guess > 10)\r\n\t\t\t\tcout << \"\\nNumber Sholud Be Between 1 To 10\\n\" <<\r\n\t\t\t\t\"\\nGuess Numer Again: \";\r\n\t\t} while (guess <= 0 || guess > 10);\r\n\r\n\t\tdice = rand() % 10 + 1;\r\n\r\n\t\tif (dice == guess)\r\n\t\t{\r\n\t\t\tcout << \"\\nHurray You Won \" << bidamnt * 10 << \"$\";\r\n\t\t\tamnt = amnt + bidamnt * 10;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"Sorry You Lose \" << bidamnt << \"$\\n\";\r\n\t\t\tamnt = amnt - bidamnt;\r\n\t\t}\r\n\r\n\t\tcout << \"\\nThe Winning Number Was: \" << dice << \"\\n\";\r\n\t\tcout << \"\\n\" << name << \", Your Remaining Amount Is \" << amnt << \"$\\n\";\r\n\t\tif (amnt == 0)\r\n\t\t{\r\n\t\t\tcout << \"\\nSorry You Don't Have Money To Play \\n\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcout << \"\\nYou Want To Play Again Press (y/n)? \";\r\n\t\tcin >> choice;\r\n\t} while (choice == 'Y' || choice == 'y');\r\n\r\n\tcout << \"\\n===============================================================================================\\n\";\r\n\tcout << \"Thanks For Playing Game Again Your Current Amount Is \" << amnt << \"$\";\r\n\tcout << \"\\n===============================================================================================\\n\";\r\n\r\n\treturn 0;\r\n}\r\n\r\nvoid rules()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout << \"\\n===============================================================================================\\n\";\r\n\tcout << \"\\t\\t\\tGame Rules\";\r\n\tcout << \"\\n===============================================================================================\";\r\n\tcout << \"\\n1. Choose Number Between 1 To 10\";\r\n\tcout << \"\\n2. Winning Amount Will Be 10 Times Of Bid Amount\";\r\n\tcout << \"\\n3. Loose Amount Will Be Biding Amount\";\r\n\tcout << \"\\n4. You Can Leave A Game Any Time\";\r\n\tcout << \"\\n===============================================================================================\\n\";\r\n}",
    "//\n//  plugin_start.cpp\n//  Lilu\n//\n//  Copyright \u00a9 2016-2017 vit9696. All rights reserved.\n//\n\n#include <Headers/plugin_start.hpp>\n#include <Headers/kern_api.hpp>\n#include <Headers/kern_util.hpp>\n#include <Headers/kern_version.hpp>\n\n#ifndef LILU_CUSTOM_KMOD_INIT\nbool ADDPR(startSuccess) = false;\n#else\n// Workaround custom kmod code and enable by default\nbool ADDPR(startSuccess) = true;\n#endif /* LILU_CUSTOM_KMOD_INIT */\n\nbool ADDPR(debugEnabled) = false;\nuint32_t ADDPR(debugPrintDelay) = 0;\n\n#ifndef LILU_CUSTOM_IOKIT_INIT\n\nOSDefineMetaClassAndStructors(PRODUCT_NAME, IOService)\n\nPRODUCT_NAME *ADDPR(selfInstance) = nullptr;\n\nIOService *PRODUCT_NAME::probe(IOService *provider, SInt32 *score) {\n\tADDPR(selfInstance) = this;\n\tsetProperty(\"VersionInfo\", kextVersion);\n\tauto service = IOService::probe(provider, score);\n\treturn ADDPR(startSuccess) ? service : nullptr;\n}\n\nbool PRODUCT_NAME::start(IOService *provider) {\n\tADDPR(selfInstance) = this;\n\tif (!IOService::start(provider)) {\n\t\tSYSLOG(\"init\", \"failed to start the parent\");\n\t\treturn false;\n\t}\n\n\treturn ADDPR(startSuccess);\n}\n\nvoid PRODUCT_NAME::stop(IOService *provider) {\n\tADDPR(selfInstance) = nullptr;\n\tIOService::stop(provider);\n}\n\n#endif /* LILU_CUSTOM_IOKIT_INIT */\n\n#ifndef LILU_CUSTOM_KMOD_INIT\n\nEXPORT extern \"C\" kern_return_t ADDPR(kern_start)(kmod_info_t *, void *) {\n\t// This is an ugly hack necessary on some systems where buffering kills most of debug output.\n\tlilu_get_boot_args(\"liludelay\", &ADDPR(debugPrintDelay), sizeof(ADDPR(debugPrintDelay)));\n\n\tauto error = lilu.requestAccess();\n\tif (error == LiluAPI::Error::NoError) {\n\t\terror = lilu.shouldLoad(ADDPR(config).product, ADDPR(config).version, ADDPR(config).runmode, ADDPR(config).disableArg, ADDPR(config).disableArgNum,\n\t\t\t\t\t\t\t\tADDPR(config).debugArg, ADDPR(config).debugArgNum, ADDPR(config).betaArg, ADDPR(config).betaArgNum, ADDPR(config).minKernel,\n\t\t\t\t\t\t\t\tADDPR(config).maxKernel, ADDPR(debugEnabled));\n\n\t\tif (error == LiluAPI::Error::NoError) {\n\t\t\tDBGLOG(\"init\", \"%s bootstrap %s\", xStringify(PRODUCT_NAME), kextVersion);\n\t\t\t(void)kextVersion;\n\t\t\tADDPR(startSuccess) = true;\n\t\t\tADDPR(config).pluginStart();\n\t\t} else {\n\t\t\tSYSLOG(\"init\", \"parent said we should not continue %d\", error);\n\t\t}\n\n\t\tlilu.releaseAccess();\n\t} else {\n\t\tSYSLOG(\"init\", \"failed to call parent %d\", error);\n\t}\n\t\n\tfor (size_t i = 0; i < ADDPR(config).debugArgNum; i++) {\n\t\tif (checkKernelArgument(ADDPR(config).debugArg[i])) {\n\t\t\tADDPR(debugEnabled) = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (checkKernelArgument(\"-liludbgall\"))\n\t\tADDPR(debugEnabled) = true;\n\n\t// Report success but actually do not start and let I/O Kit unload us.\n\t// This works better and increases boot speed in some cases.\n\treturn KERN_SUCCESS;\n}\n\nEXPORT extern \"C\" kern_return_t ADDPR(kern_stop)(kmod_info_t *, void *) {\n\t// It is not safe to unload Lilu plugins unless they were disabled!\n\treturn ADDPR(startSuccess) ? KERN_FAILURE : KERN_SUCCESS;\n}\n\n#endif /* LILU_CUSTOM_KMOD_INIT */\n",
    "#include \"QtWidgetsApplication1.h\"\n#include\"helpclass.h\"\n#include\"basic_gameClass.h\"\n#include <QPainter>\nQtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)\n    : QMainWindow(parent),ui(new Ui::QtWidgetsApplication1Class)\n{\n    ui->setupUi(this);\n    m_imgPicSrc = QImage(\"E:\\\\c train\\\\QtWidgetsApplication1\\\\image\\\\bg_m0ain.bmp\");\n    QSize initialSize = size(); \n    m_pixPic2Show = QPixmap::fromImage(m_imgPicSrc.scaled(initialSize, Qt::KeepAspectRatio, Qt::SmoothTransformation));\n\n    connect(ui->pb_helping, &QPushButton::clicked, this, &QtWidgetsApplication1::on_actionShow_help_triggered);//\u5e2e\u52a9\n    connect(ui->pb_basic_game, &QPushButton::clicked, this, &QtWidgetsApplication1::on_actionShow_basic_game_clicked);//\u5f00\u59cb\u8fdb\u5165\u6e38\u620f\n\n}\nvoid QtWidgetsApplication1::paintEvent(QPaintEvent* event)//\u91cd\u5199painEvent,\u53ef\u4ee5\u5c06\u56fe\u7247\u6dfb\u52a0\u5230widget\u91cc\n{\n    QPainter painter(this);\n    painter.drawPixmap(rect(), m_pixPic2Show);\n}\nvoid QtWidgetsApplication1::on_actionShow_help_triggered()\n{\n    helpclass* help = new helpclass;\n    help->show();\n}\nvoid QtWidgetsApplication1::on_actionShow_basic_game_clicked()\n{\n    basic_gameClass* bp = new basic_gameClass;\n    bp->show();\n}\nQtWidgetsApplication1::~QtWidgetsApplication1()\n{\n    delete ui;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Player.h\"\n#include \"Math.h\"\n#include \"Skeleton.h\"\n#include <iostream>\n\n\nconst int SPRITE_SIZE = 64;\nconst int SPRITE_SCALE = SPRITE_SIZE * 2;\n\nvoid Player::OnInitialize()\n{\n    BoundBox.setFillColor(sf::Color::Transparent);\n    BoundBox.setOutlineColor(sf::Color::White);\n    BoundBox.setOutlineThickness(1);\n    BoundBox.setSize(sf::Vector2f(SPRITE_SCALE, SPRITE_SCALE));\n\n}\n\nvoid Player::OnLoad()\n{\n    \n    if (texture.loadFromFile(\"Assets/Player/Textures/spritesheet.png\"))\n    {\n        std::cout << \"Player texture loaded!\" << std::endl;\n        sprite.setTexture(texture);\n\n        // X , Y , Width , Height\n        int xIndex = 2;\n        int yIndex = 3;\n\n        sprite.setTextureRect(sf::IntRect(xIndex * 64, yIndex * 64, SPRITE_SIZE, SPRITE_SIZE)); //grabbing the position of the sprite from the sheet.\n        sprite.setScale(sf::Vector2f(2, 2));\n\n        sprite.setPosition(sf::Vector2f(960, 540));\n\n    }\n    else { std::cout << \"Error loading player texures!\" << std::endl; }\n\n}\n\nvoid Player::OnUpdate(Skeleton& skeleton)\n{\n    int moveSpeed = 2;\n    sf::Vector2f position = sprite.getPosition();\n\n    if (sf::Keyboard::isKeyPressed(sf::Keyboard::LShift))\n    {\n        moveSpeed = 4;\n    }\n\n    if (sf::Keyboard::isKeyPressed(sf::Keyboard::D))\n    {\n        sprite.setPosition(position + sf::Vector2f(moveSpeed, 0));\n    }\n\n    if (sf::Keyboard::isKeyPressed(sf::Keyboard::A))\n    {\n        sprite.setPosition(position - sf::Vector2f(moveSpeed, 0));\n    }\n\n    if (sf::Keyboard::isKeyPressed(sf::Keyboard::W))\n    {\n        sprite.setPosition(position - sf::Vector2f(0, moveSpeed));\n    }\n\n    if (sf::Keyboard::isKeyPressed(sf::Keyboard::S))\n    {\n        sprite.setPosition(position + sf::Vector2f(0, moveSpeed));\n    }\n\n    BoundBox.setPosition(sprite.getPosition());\n  \n    /*---------- COLLISION ----------*/\n    \n    //left\n    if (sprite.getPosition().x < 0.f)\n    {\n        sprite.setPosition(0.f, sprite.getPosition().y);\n    }\n    //top\n    if (sprite.getPosition().y < 0.f)\n    {\n        sprite.setPosition(sprite.getPosition().x, 0.f);\n    }   \n    //right\n    if (sprite.getPosition().x + sprite.getGlobalBounds().width > 1920)\n    {\n        sprite.setPosition(1920 - sprite.getGlobalBounds().width, sprite.getPosition().y);\n    }\n    //bottom\n    if (sprite.getPosition().y + sprite.getGlobalBounds().height > 1080)\n    {\n        sprite.setPosition(sprite.getPosition().x, 1080 - sprite.getGlobalBounds().height);\n    }\n\n\n    sf::FloatRect skelePos = skeleton.sprite.getGlobalBounds();\n    if (sprite.getGlobalBounds().intersects(skelePos))\n    {\n        std::cout << \"Plr & Skeleton are colliding!\" << std::endl;\n    }\n\n\n\n\n\n\n\n\n}\n\nvoid Player::OnDraw(sf::RenderWindow& window)\n{\n    window.draw(BoundBox);\n    window.draw(sprite);\n\n}\n",
    "#include <rclcpp/rclcpp.hpp>\n#include <image_transport/image_transport.hpp>\n#include <cv_bridge/cv_bridge.h>\n#include <sensor_msgs/msg/image.hpp>\n#include <sensor_msgs/msg/camera_info.hpp>\n#include <opencv2/opencv.hpp>\n#include <opencv2/core.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/objdetect.hpp>\n#include <iostream>\n#include <vector>\n#include <geometry_msgs/msg/pose.hpp>\n#include <fstream>\n\n#define STREAM          RS2_STREAM_COLOR  // rs2_stream is a types of data provided by RealSense device           //\n#define FORMAT          RS2_FORMAT_RGB8   // rs2_format identifies how binary data is encoded within a frame      //\n#define WIDTH           640 // 1920               // Defines the number of columns for each frame                         //\n#define HEIGHT          480 // 1080               // Defines the number of lines for each frame                           //\n#define FPS             30                // Defines the rate of frames per second                                //\n#define STREAM_INDEX    0                 // Defines the stream index, used for multiple streams of the same type //\n\n//all #define dimensions in mm\n#define QR_Dimension 66\n\n#define Spacing 17\n\n#define Cube_Size 100\n\n\n//from camera calibration\n// const cv::Mat INTRINSIC = (cv::Mat_<float>(3, 3) << 1378.13429, 0, 954.241651,\n//                                                    0, 1376.70507, 554.51173,\n//                                                    0, 0, 1);\nconst cv::Mat INTRINSIC = (cv::Mat_<float>(3, 3) << 608.90339309, 0, 321.37995726,\n                                                   0, 608.25294592, 244.79138807,\n                                                   0, 0, 1);\n\n// const cv::Mat DIST = (cv::Mat_<double>(1, 5) << -.00535442812, -0.862563774, -0.000440522884, -0.00402199855, -3.24408199);\nconst cv::Mat DIST = (cv::Mat_<double>(1, 5) << -0.0166, 1.06, 0, 0, -4.06);\n\nclass QRCodeDetectorNode : public rclcpp::Node {\n    public:\n        QRCodeDetectorNode() : Node(\"qr_code_detector_node\") {}\n\n        void initialize() {\n\n            // Using shared_from_this() after the object is fully constructed\n            auto node_shared_ptr = shared_from_this();\n            image_transport::ImageTransport it(node_shared_ptr);\n\n            color_subscriber_ = it.subscribe(\"/camera/camera/color/image_raw\", 10, \n                &QRCodeDetectorNode::image_callback, this);\n\n            depth_subscriber_ = it.subscribe(\"/camera/camera/aligned_depth_to_color/image_raw\", 10,\n                &QRCodeDetectorNode::depth_callback, this);\n\n            camera_info_subscriber_ = this->create_subscription<sensor_msgs::msg::CameraInfo>(\n                \"/camera/camera/aligned_depth_to_color/camera_info\", 10,\n                std::bind(&QRCodeDetectorNode::camera_info_callback, this, std::placeholders::_1));\n\n            image_publisher_ = image_transport::create_publisher(this, \"/qr_codes/detected_images\");\n\n            pose_publisher_ = this->create_publisher<geometry_msgs::msg::Pose>(\"/cube/pose\", 10);\n        }\n\n    private:\n        void image_callback(const sensor_msgs::msg::Image::ConstSharedPtr& msg) {\n            try {\n                cv::Mat frame = cv_bridge::toCvShare(msg, \"bgr8\")->image;\n                // detect_and_draw_qr_codes(frame);\n                detect_cube_cords(frame);\n\n                // Convert back to ROS message and publish\n                auto img_msg = cv_bridge::CvImage(std_msgs::msg::Header(), \"bgr8\", frame).toImageMsg();\n                image_publisher_.publish(img_msg);\n            } catch (const cv_bridge::Exception& e) {\n                RCLCPP_ERROR(this->get_logger(), \"cv_bridge exception: %s\", e.what());\n            }\n        }\n\n        void depth_callback(const sensor_msgs::msg::Image::ConstSharedPtr& msg) {\n            try {\n                current_depth_frame_ = cv_bridge::toCvShare(msg, msg->encoding)->image.clone();\n            } catch (const cv_bridge::Exception& e) {\n                RCLCPP_ERROR(this->get_logger(), \"cv_bridge exception: %s\", e.what());\n            }\n        }\n\n        void camera_info_callback(const sensor_msgs::msg::CameraInfo::ConstSharedPtr& msg) {\n            fx_ = msg->k[0];  // Focal length x\n            fy_ = msg->k[4];  // Focal length y\n            cx_ = msg->k[2];  // Principal point x\n            cy_ = msg->k[5];  // Principal point y\n            camera_info_received_ = true;\n            // RCLCPP_INFO(this->get_logger(), \"Camera info received.\");\n        }\n\n    void detect_and_draw_qr_codes(cv::Mat& image) {\n\n        if (!camera_info_received_) {\n            RCLCPP_WARN(this->get_logger(), \"Camera info not yet received.\");\n            return;\n        }\n\n        cv::QRCodeDetector qrDecoder;\n        std::vector<cv::Point> points;\n        cv::Mat bbox;\n\n        if (qrDecoder.detect(image, points)) {\n\n            // Draw the bounding box around the QR code\n            bbox = cv::Mat(points).reshape(1);\n            cv::polylines(image, bbox, true, cv::Scalar(0,",
    "/**\n* @file  uthread.cpp\n* @author chenxueyou\n* @version 0.1\n* @brief   :A asymmetric coroutine library for C++\n* History\n*      1. Date: 2014-12-12 \n*          Author: chenxueyou\n*          Modification: this file was created \n*/\n\n#ifndef MY_UTHREAD_CPP\n#define MY_UTHREAD_CPP\n\n\n#include \"uthread.h\"\n//#include <stdio.h>\n\nvoid uthread_resume(schedule_t &schedule , int id)\n{\n    if(id < 0 || id >= schedule.max_index){\n        return;\n    }\n\n    uthread_t *t = &(schedule.threads[id]);\n\n    if (t->state == SUSPEND) {\n        swapcontext(&(schedule.main),&(t->ctx));\n    }\n}\n\nvoid uthread_yield(schedule_t &schedule)\n{\n    if(schedule.running_thread != -1 ){\n        uthread_t *t = &(schedule.threads[schedule.running_thread]);\n        t->state = SUSPEND;\n        schedule.running_thread = -1;\n\n        swapcontext(&(t->ctx),&(schedule.main));\n    }\n}\n\n// \nvoid uthread_body(schedule_t *ps)\n{\n    int id = ps->running_thread;\n\n    if(id != -1){\n        uthread_t *t = &(ps->threads[id]);\n\n        t->func(t->arg);\n\n        t->state = FREE;\n        \n        ps->running_thread = -1;\n    }\n}\n\n// \nint uthread_create(schedule_t &schedule,Fun func,void *arg)\n{\n    int id = 0;\n    \n    for(id = 0; id < schedule.max_index; ++id ){\n        if(schedule.threads[id].state == FREE){\n            break;\n        }\n    }\n    \n    if (id == schedule.max_index) {\n        schedule.max_index++;\n    }\n\n    uthread_t *t = &(schedule.threads[id]);\n\n    t->state = RUNNABLE;\n    t->func = func;\n    t->arg = arg;\n\n    // \u83b7\u53d6\u5f53\u524d\u4e0a\u4e0b\u6587\n    getcontext(&(t->ctx));\n    \n    t->ctx.uc_stack.ss_sp = t->stack;\n    t->ctx.uc_stack.ss_size = DEFAULT_STACK_SZIE;\n    t->ctx.uc_stack.ss_flags = 0;\n    // \u8bbe\u7f6e\u540e\u7ee7\u4e0a\u4e0b\u6587\uff0c\u7edf\u4e00\u4e3amain\n    t->ctx.uc_link = &(schedule.main);\n    schedule.running_thread = id;\n    \n    // \u4fee\u6539\u4e0a\u4e0b\u6587\u6307\u5411uthread_body\u51fd\u6570\n    makecontext(&(t->ctx),(void (*)(void))(uthread_body),1,&schedule);\n\n    // \u5207\u6362\u5230\u65b0\u521b\u5efa\u7684uthread\n    swapcontext(&(schedule.main), &(t->ctx));\n    \n    return id;\n}\n\nint schedule_finished(const schedule_t &schedule)\n{\n    if (schedule.running_thread != -1){\n        return 0;\n    }else{\n        for(int i = 0; i < schedule.max_index; ++i){\n            if(schedule.threads[i].state != FREE){\n                return 0;\n            }\n        }\n    }\n\n    return 1;\n}\n\n#endif",
    "#include <SFML/Graphics.hpp>\n\n#include \"utils.hpp\"\n#include \"hw_defs.hpp\"\n#include \"3dscapture.hpp\"\n#include \"frontend.hpp\"\n\n#include <cstring>\n#include <mutex>\n#include <queue>\n#include \"font_ttf.h\"\n\nstatic int top_screen_crop_widths[] = {TOP_WIDTH_3DS, TOP_SPECIAL_DS_WIDTH_3DS, TOP_SCALED_DS_WIDTH_3DS, WIDTH_DS, WIDTH_SCALED_GBA, WIDTH_GBA, WIDTH_SCALED_GB, WIDTH_GB, WIDTH_SNES, WIDTH_NES};\nstatic int top_screen_crop_heights[] = {HEIGHT_3DS, HEIGHT_3DS, HEIGHT_3DS, HEIGHT_DS, HEIGHT_SCALED_GBA, HEIGHT_GBA, HEIGHT_SCALED_GB, HEIGHT_GB, HEIGHT_SNES, HEIGHT_NES};\nstatic int bot_screen_crop_widths[] = {BOT_WIDTH_3DS, BOT_WIDTH_3DS, BOT_WIDTH_3DS, WIDTH_DS, 0, 0, 0, 0, 0, 0};\nstatic int bot_screen_crop_heights[] = {HEIGHT_3DS, HEIGHT_3DS, HEIGHT_3DS, HEIGHT_DS, 0, 0, 0, 0, 0, 0};\nstatic int top_screen_crop_x[] = {0, (TOP_WIDTH_3DS - TOP_SPECIAL_DS_WIDTH_3DS) / 2, (TOP_WIDTH_3DS - TOP_SCALED_DS_WIDTH_3DS) / 2, (TOP_WIDTH_3DS - WIDTH_DS) / 2,\n\t\t\t\t\t\t\t\t(TOP_WIDTH_3DS - WIDTH_SCALED_GBA) / 2,\t(TOP_WIDTH_3DS - WIDTH_GBA) / 2, (TOP_WIDTH_3DS - WIDTH_SCALED_GB) / 2, (TOP_WIDTH_3DS - WIDTH_GB) / 2,\n\t\t\t\t\t\t\t\t(TOP_WIDTH_3DS - WIDTH_SNES) / 2, (TOP_WIDTH_3DS - WIDTH_NES) / 2};\nstatic int top_screen_crop_y[] = {0, 0, 0, 0, (HEIGHT_3DS - HEIGHT_SCALED_GBA) / 2, (HEIGHT_3DS - HEIGHT_GBA) / 2, (HEIGHT_3DS - HEIGHT_SCALED_GB) / 2, (HEIGHT_3DS - HEIGHT_GB) / 2, (HEIGHT_3DS - HEIGHT_SNES) / 2, (HEIGHT_3DS - HEIGHT_NES) / 2};\nstatic int bot_screen_crop_x[] = {0, 0, 0, (BOT_WIDTH_3DS - WIDTH_DS) / 2, 0, 0, 0, 0, 0, 0};\nstatic int bot_screen_crop_y[] = {0, 0, 0, HEIGHT_3DS - HEIGHT_DS, 0, 0, 0, 0, 0, 0};\nstatic std::string crop_names[] = {\"3DS\", \"16:10\", \"Scaled DS\", \"Native DS\", \"Scaled GBA\", \"Native GBA\", \"Scaled VC GB\", \"VC GB\", \"VC SNES\", \"VC NES\"};\n\nWindowScreen::WindowScreen(WindowScreen::ScreenType stype, DisplayData* display_data, AudioData* audio_data, std::mutex* events_access) {\n\tthis->m_stype = stype;\n\tthis->events_access = events_access;\n\tthis->m_prepare_save = 0;\n\tthis->m_prepare_load = 0;\n\tthis->m_prepare_open = false;\n\tthis->m_prepare_quit = false;\n\treset_screen_info(this->m_info);\n\tthis->font_load_success = this->text_font.loadFromMemory(font_ttf, font_ttf_len);\n\tthis->notification = new TextRectangle(this->font_load_success, this->text_font);\n\tthis->in_tex.create(IN_VIDEO_WIDTH, IN_VIDEO_HEIGHT);\n\tthis->m_in_rect_top.setTexture(&this->in_tex);\n\tthis->m_in_rect_bot.setTexture(&this->in_tex);\n\tthis->display_data = display_data;\n\tthis->audio_data = audio_data;\n\tWindowScreen::reset_operations(future_operations);\n\tthis->done_display = true;\n\tthis->saved_buf = new VideoOutputData;\n\tthis->win_title = NAME;\n\tif(this->m_stype == WindowScreen::ScreenType::TOP)\n\t\tthis->win_title += \"_top\";\n\tif(this->m_stype == WindowScreen::ScreenType::BOTTOM)\n\t\tthis->win_title += \"_bot\";\n}\n\nWindowScreen::~WindowScreen() {\n\tdelete this->saved_buf;\n\tthis->saved_buf = NULL;\n}\n\nvoid WindowScreen::build() {\n\tsf::Vector2f top_screen_size = sf::Vector2f(TOP_WIDTH_3DS, HEIGHT_3DS);\n\tsf::Vector2f bot_screen_size = sf::Vector2f(BOT_WIDTH_3DS, HEIGHT_3DS);\n\n\tint width = TOP_WIDTH_3DS;\n\tif(this->m_stype == WindowScreen::ScreenType::BOTTOM)\n\t\twidth = BOT_WIDTH_3DS;\n\n\tthis->reload();\n\n\tthis->m_out_rect_top.out_tex.create(top_screen_size.x, top_screen_size.y);\n\tthis->m_out_rect_top.out_rect.setSize(top_screen_size);\n\tthis->m_out_rect_top.out_rect.setTexture(&this->m_out_rect_top.out_tex.getTexture());\n\n\tthis->m_out_rect_bot.out_tex.create(bot_screen_size.x, bot_screen_size.y);\n\tthis->m_out_rect_bot.out_rect.setSize(bot_screen_size);\n\tthis->m_out_rect_bot.out_rect.setTexture(&this->m_out_rect_bot.out_tex.getTexture());\n\n\tthis->m_view.setRotation(0);\n}\n\nvoid WindowScreen::reload() {\n\tthis->future_operations.call_crop = true;\n\tthis->future_operations.call_rotate = true;\n\tthis->future_operations.call_blur = true;\n\tthis->future_operations.call_screen_settings_update = true;\n\tif(this->m_win.isOpen())\n\t\tthis->create_window(false);\n\tthis->prepare_size_ratios(true, true);\n}\n\nvoid WindowScreen::poll() {\n\tthis->poll_window();\n\twhile(!events_queue.empty()) {\n\t\tSFEvent event_data = events_queue.front();\n\t\tevents_queue.pop();\n\t\tswitch (event_data.type) {\n\t\tcase sf::Event::Closed:\n\t\t\tthis->m_prepare_quit = true;\n\t\t\tbreak;\n\n\t\tcase sf::Event::TextEntered:\n\t\t\tswitch (event_data.unicode) {\n\t\t\tcase 'c':\n\t\t\t\tif(this->m_stype == WindowScreen::ScreenType::BOTTOM) {\n\t\t\t\t\tif(this->m_info.crop_kind == Crop::DEFAULT_3DS)\n\t\t\t\t\t\tthis->m_info.crop_kind = Crop::NATIVE_DS;\n\t\t\t\t\telse\n\t\t\t\t\t\tthis->m_info.crop_kind = Crop::DEFAULT_3DS;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis->m_info.crop_kind = static_cast<Crop>((this->m_info.crop_kind + 1) % Crop::CROP_END);\n\t\t\t\t}\n\t\t\t\tthis->print_notification(\"Crop: \" + crop_names[this->m_info.crop_kind]);\n\t\t\t\tthis->prepare_size_ratios(false, false);\n\t\t\t\tthis->future_operations.call_crop = true;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tthis->m_info.is_fullscreen = false;\n\t\t\t\tthis->display_data->split = !this->display_data->split;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\tthis->m_info.async = !",
    "#include \"gif-pros/gifclass.hpp\"\n#include \"assset.h\"\n\n/**\n * MIT License\n * Copyright (c) 2019 Theo Lemay\n * https://github.com/theol0403/gif-pros\n */\n\n/**\n * Construct the Gif class\n * @param fname  the gif filename on the SD card (prefixed with /usd/)\n * @param parent the LVGL parent object\n */\nGif::Gif(const asset file, lv_obj_t* parent) {\n\tsize_t len = file.size;\n\n\t_gifmem = file.buf;\n\n\tif (_gifmem != NULL) {\n\t\t// create a FILE from memory buffer\n\t\tFILE* memfp = fmemopen(_gifmem, len, \"rb\");\n\n\t\t// open gof file\n\t\t// will allocate memory for background and one animation frame.\n\t\t_gif = gd_open_gif(memfp);\n\t\tif(_gif == NULL) {\n\t\t\tstd::cerr << \"Gif::Gif - error opening gif\" << std::endl;\n\t\t\t_cleanup();\n\t\t\treturn;\n\t\t}\n\n\t\t// memory for rendering frame\n\t\t_buffer = (uint8_t*)malloc(_gif->width * _gif->height * BYTES_PER_PIXEL);\n\t\tif(_buffer == NULL) {\n\t\t\t// out of memory\n\t\t\t_cleanup();\n\t\t\tstd::cerr << \"Gif::Gif - not enough memory for frame buffer\" << std::endl;\n\t\t} else {\n\t\t\t_cbuf = new lv_color_t[_gif->width * _gif->height];\n\t\t\t_canvas = lv_canvas_create(parent, NULL);\n\t\t\tlv_canvas_set_buffer(_canvas, _cbuf, _gif->width, _gif->height, LV_IMG_CF_TRUE_COLOR_ALPHA);\n\t\t\t_task = pros::c::task_create(_render_task, static_cast<void*>(this), TASK_PRIORITY_DEFAULT-2, TASK_STACK_DEPTH_DEFAULT, \"GIF\");\n\t\t}\n\t}\n};\n\n\n/**\n * Destructs and cleans the Gif class\n */\nGif::~Gif() {\n\t_cleanup();\n}\n\n/**\n * Pauses the GIF task\n */\nvoid Gif::pause(){\n\tpros::c::task_suspend(_task);\n}\n\n/**\n * Resumes the GIF task\n */\nvoid Gif::resume(){\n\tpros::c::task_resume(_task);\n}\n\n/**\n* Deletes GIF and frees all allocated memory\n*/\nvoid Gif::clean() {\n\t_cleanup();\n}\n\n/**\n * Cleans and frees all allocated memory\n */\nvoid Gif::_cleanup() {\n\tif(_canvas) { lv_obj_del(_canvas); _canvas = nullptr; }\n\tif(_cbuf) { delete[] _cbuf; _cbuf = nullptr; }\n\tif(_buffer) { free(_buffer); _buffer = nullptr; }\n\tif(_gif) { gd_close_gif(_gif); _gif = nullptr; }\n\tif(_gifmem) { free(_gifmem); _gifmem = nullptr; }\n\t// deleting task kills this thread\n\tif(_task) { pros::c::task_delete(_task); _task = nullptr; }\n}\n\n\n/**\n * Render cycle, blocks until loop count exceeds gif loop count flag (if any)\n */\nvoid Gif::_render() {\n\n\tfor (size_t looped = 1;; looped++) {\n\t\twhile (gd_get_frame(_gif)) {\n\t\t\tint32_t now = pros::millis();\n\n\t\t\tgd_render_frame(_gif, _buffer);\n\n\t\t\tfor (size_t i = 0; i < _gif->height * _gif->width; i++) {\n\t\t\t\t_cbuf[i].red = _buffer[(i * BYTES_PER_PIXEL)];\n\t\t\t\t_cbuf[i].green = _buffer[(i * BYTES_PER_PIXEL) + 1];\n\t\t\t\t_cbuf[i].blue = _buffer[(i * BYTES_PER_PIXEL) + 2];\n\t\t\t\t_cbuf[i].alpha = _buffer[(i * BYTES_PER_PIXEL) + 3];\n\t\t\t};\n\n\t\t\tlv_obj_invalidate(_canvas); // force canvas redraw\n\n\t\t\tint32_t delay = _gif->gce.delay * 10;\n\t\t\tint32_t delta = pros::millis() - now;\n\t\t\tdelay -= delta;\n\n\t\t\tif(delay > 0) pros::delay(delay);\n\t\t}\n\n\t\tif(looped == _gif->loop_count) break;\n\t\tgd_rewind(_gif);\n\t}\n\n\t_cleanup();\n}\n\n\n/**\n * Calls _render()\n * @param arg Gif*\n */\nvoid Gif::_render_task(void* arg) {\n\tGif* instance = static_cast<Gif*>(arg);\n\tinstance->_render();\n}",
    "//\n// Created by 91246 on 2024/4/9.\n//\n\n#include \"Camera.h\"\n\nvoid Camera::updateCameraVectors() {\n    // calculate the new Front vector\n    glm::vec3 tmp_front;\n    tmp_front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));\n    tmp_front.y = sin(glm::radians(pitch));\n    tmp_front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));\n    front = glm::normalize(tmp_front);\n    // also re-calculate the Right and Up vector\n    right = glm::normalize(glm::cross(front, worldUp));  // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.\n    up    = glm::normalize(glm::cross(right, front));\n\n}\n\nvoid Camera::ProcessMouseScroll(float yoffset)\n{\n    fov -= (float)yoffset;\n    if (fov < 0.5f)\n        fov = 0.5f;\n    if (fov > 45.0f)\n        fov = 45.0f;\n}\n\nvoid Camera::ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch)\n{\n    xoffset *= sensitivity;\n    yoffset *= sensitivity;\n\n    yaw   += xoffset;\n    pitch += yoffset;\n\n    // make sure that when pitch is out of bounds, screen doesn't get flipped\n    if (constrainPitch)\n    {\n        if (pitch > 89.5f)\n            pitch = 89.5f;\n        if (pitch < -89.5f)\n            pitch = -89.5f;\n    }\n\n    // update Front, Right and Up Vectors using the updated Euler angles\n    updateCameraVectors();\n}\n\nvoid Camera::ProcessKeyboard(Camera_Movement direction, float deltaTime)\n{\n    float velocity = speed * deltaTime;\n    if (direction == FORWARD)\n        position += front * velocity;\n    else if (direction == BACKWARD)\n        position -= front * velocity;\n    else if (direction == LEFT)\n        position -= right * velocity;\n    else if (direction == RIGHT)\n        position += right * velocity;\n    else if (direction == UP)\n        position += up * velocity;\n    else if (direction == DOWN)\n        position -= up * velocity;\n}\n\nglm::mat4 Camera::GetViewMatrix()\n{\n    return glm::scale(glm::lookAt(position, position + front, up),glm::vec3(rate));\n}\n\nCamera::Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : front(glm::vec3(0.0f, 0.0f, -1.0f)), speed(DEFAULT_SPEED), sensitivity(DEFAULT_SENSITIVITY), fov(DEFAULT_FOV)\n{\n    this->position = glm::vec3(posX, posY, posZ);\n    this->worldUp = glm::vec3(upX, upY, upZ);\n    this->yaw = yaw;\n    this->pitch = pitch;\n    updateCameraVectors();\n}\n\nCamera::Camera(glm::vec3 position,float rate, glm::vec3 up, float yaw, float pitch) : front(glm::vec3(0.0f, 0.0f, -1.0f)), speed(DEFAULT_SPEED), sensitivity(DEFAULT_SENSITIVITY), fov(DEFAULT_FOV),rate(rate)\n{\n    this->position = position;\n    worldUp = up;\n    this->yaw = yaw;\n    this->pitch = pitch;\n    updateCameraVectors();\n}\n",
    "#include <iostream>\n#include <vector>\n\n// Enum for character classes\nenum class CharacterClass {\n    Warrior,\n    Wizard,\n    Archer\n};\n\n// Structure for character data\nstruct Character {\n    int id;\n    CharacterClass charClass;\n    float meleeAttack;\n    float rangedAttack;\n};\n\n// Function to find the name of the strongest character\nint findStrongestCharacter(const std::vector<Character>& characters) {\n    if (characters.empty()) return -1; // Return -1 if the vector is empty\n\n    int strongestId = characters[0].id;\n    float maxStrength = characters[0].meleeAttack + characters[0].rangedAttack;\n\n    for (const auto& character : characters) {\n        float currentStrength = character.meleeAttack + character.rangedAttack;\n        if (currentStrength > maxStrength) {\n            maxStrength = currentStrength;\n            strongestId = character.id;\n        }\n    }\n\n    return strongestId;\n}\n\nint main() {\n    // Example characters\n    std::vector<Character> characters = {\n        {1, CharacterClass::Warrior, 15.5, 10.0},\n        {2, CharacterClass::Wizard, 12.0, 13.5},\n        {3, CharacterClass::Archer, 10.0, 18.0}\n    };\n\n    int strongestCharacterId = findStrongestCharacter(characters);\n    std::cout << \"The strongest character ID is: \" << strongestCharacterId << std::endl;\n\n    return 0;\n}\n",
    "\ufeff#include<iostream>\n\n\n\nclass Apple {\nprivate:\n\tint nutritionalValue;\n\tint timeToRiot;\n\t//\u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0439 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442, \u0447\u0442\u043e \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n\t//\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u043d\u0443\u0442\u0440\u0438 \u043a\u043b\u0430\u0441\u0441\u0430\n\tApple() :nutritionalValue(100), timeToRiot(10) {\n\t\tstd::cout << \"Apple created\" << std::endl;\n\t}\n\t//\u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n\tstatic Apple* instance;\n\n\t// \u0417\u0430\u043f\u0440\u0435\u0449\u0430\u0435\u043c \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435\n\tApple(const Apple&) = delete;\n\tApple& operator = (const Apple&) = delete;\n\n\n\npublic:\n\t// \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430 \u043a\u043b\u0430\u0441\u0441\u0430\n\tstatic Apple* getinstance() {\n\t\tif (instance==nullptr) {\n\t\t\tinstance = new Apple();\n\t\t}\n\t\treturn instance;\n\t}\n\n\t//\u041c\u0435\u0442\u043e\u0434\u044b \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0435\u0439\n\t\n\tvoid SetNutritionalValue(int value) {\n\t\tnutritionalValue = value;\n\t}\n\n\tvoid SetTimeToRiot(int time) {\n\t\ttimeToRiot = time;\n\t}\n\t\n\tint GetNutritionalValue() {\n\t\treturn nutritionalValue;\n\t}\n\n\tint GetTimeToRiot(){\n\t\treturn timeToRiot;\n\t}\n\t \n\n\n};\n\n//\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u0442\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u043d\u0430 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\nApple* Apple::instance = nullptr;\n\nint main() {\n\t//\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n\tApple* apple1 = Apple::getinstance();\n\tstd::cout << \"NutritionalValue\" << apple1->GetNutritionalValue() << std::endl;\n\tstd::cout << \"TimeToRiot\" << apple1->GetTimeToRiot() << std::endl;\n\t//\u041c\u0435\u043d\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0435\u0439\n\tapple1 -> SetNutritionalValue(90);\n\tapple1 -> SetTimeToRiot(5);\n\t\n\t//\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0435\u0439 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442\n\tApple* apple2 = Apple::getinstance();\n\t\n\tstd::cout << \"NutritionalValue\" << apple2->GetNutritionalValue() << std::endl;\n\tstd::cout << \"TimeToRiot\" << apple2->GetTimeToRiot() << std::endl;\n\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff#ifndef TIME_H\n#define TIME_H\n\nclass Time\n{\nprivate:\n\tint hours, minutes, seconds;\n\tvoid trueTime();\n\npublic:\n\tconst int DEF_T = 0;\n\tconst int MIN_T = 0;\n\tconst int MAX_H = 24;\n\tconst int MAX_M = 60;\n\tTime();\n\tTime(int hours, int minutes, int seconds);\n\tint fullMinutes();\n\tvoid minusMinutes();\n\tint getHours();\n\tint getMinutes();\n\tint getSeconds();\n\tvoid setHours(int h);\n\tvoid setMinutes(int m);\n\tvoid setSeconds(int s);\n};\n\n#endif // !TIME_H\n\n#include \"time.h\"\n#include <iostream>\n#include <ostream>\n#include <iomanip>\n\nusing namespace std;\n\nTime::Time()\n{\n\tthis->hours = DEF_T;\n\tthis->minutes = DEF_T;\n\tthis->seconds = DEF_T;\n\n\ttrueTime();\n}\n\nTime::Time(int hours, int minutes, int seconds)\n\t: hours(hours), minutes(minutes), seconds(seconds)\n{\n\ttrueTime();\n}\n\nvoid Time::trueTime()\n{\n\tint sum = seconds + minutes * MAX_M + hours * int(pow(MAX_M, 2));\n\tif (sum < 0)\n\t{\n\t\tsum += int(pow(MAX_M, 2) * MAX_H);\n\t}\n\tseconds = sum % MAX_M;\n\tsum = sum / MAX_M;\n\tminutes = sum % MAX_M;\n\tsum = sum / MAX_M;\n\thours = sum % MAX_H;\n}\n\nint Time::fullMinutes()\n{\n\treturn minutes + hours * 60;\n}\n\nvoid Time::minusMinutes()\n{\n\tminutes -= 10;\n\ttrueTime();\n}\n\nint Time::getHours()\n{\n\treturn this->hours;\n}\nint Time::getMinutes()\n{\n\treturn this->minutes;\n}\nint Time::getSeconds()\n{\n\treturn this->seconds;\n}\nvoid Time::setHours(int h)\n{\n\tthis->hours = h;\n\ttrueTime();\n}\nvoid Time::setMinutes(int m)\n{\n\tthis->minutes = m;\n\ttrueTime();\n}\nvoid Time::setSeconds(int s)\n{\n\tthis->seconds = s;\n\ttrueTime();\n}\n\nostream& operator<<(ostream& os, Time& obj)\n{\n\tos << setfill('0') << setw(2) << obj.getHours() << \":\"\n\t\t<< setw(2) << obj.getMinutes() << \":\"\n\t\t<< setw(2) << obj.getSeconds() << endl;\n\treturn os;\n}\n\nistream& operator>>(istream& is, Time& obj)\n{\n\tint h, m, s;\n\tis >> h >> m >> s;\n\tobj.setHours(h);\n\tobj.setMinutes(m);\n\tobj.setSeconds(s);\n\treturn is;\n}\n\nint main()\n{\n\tTime* t1 = new Time();\n\tTime* t2 = new Time(25, 1, 70);\n\tTime* t3 = new Time(-10, -50, 70);\n\tTime* t4 = new Time();\n\n\tcin >> *t4;\n\tcout << *t1;\n\tcout << *t2;\n\tcout << *t3;\n\tcout << *t4;\n\n\tdelete t1;\n\tdelete t2;\n\tdelete t3;\n\tdelete t4;\n}",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl '\\n'\r\nlong double PI = acos(-1.0);\r\n#define fastio()                      \\\r\n\tios_base::sync_with_stdio(false); \\\r\n\tcin.tie(NULL)\r\n#define pb push_back\r\n#define NL cout<<endl;\r\n#define ppb pop_back\r\n#define pf push_front\r\n#define ppf pop_front\r\n#define all(x) (x).begin(), (x).end()\r\n#define ff(i, l, r) for(int i=l;i<r;i++)\r\n#define fr first\r\n#define sc second\r\n#define vii vector<vector<int>>\r\n#define vi vector<int>\r\n#define pii pair<int, int>\r\n#define mem1(a) memset(a, -1, sizeof(a))\r\n#define mem0(a) memset(a, 0, sizeof(a))\r\n#define ppc __builtin_popcount\r\n#define ppcll __builtin_popcountll\r\n#define YES \\\r\n\tyes();          \\\r\n\treturn\r\n#define NO\\\r\n\tno();          \\\r\n\treturn\r\n\r\nconst int MOD = (1e9 + 9);\r\n/*1sec -10^7-10^8 OPS APPROX\r\nint- (-10^-9 to 10^9)RANGE\r\nlong (-10^12 to 10^12)RANGE\r\nlong long(-10^18 to 10^18)RANGE\r\n(a+b)%M=((a%M)+(b%M))%M\r\n(a*b)%M=((a%M)*(b%M))%M\r\n(a-b)%M=((a%M)-(b%M)+M)%M\r\n(a/b)%M=((a%M)*(b^-1)%M)%M\r\nlower_bound:-LOGN\r\ninterator\r\n--FIRST ELEMENT IN AR >=x\r\n--NO OF ELEMENTS<x\r\nupper_bound:-\r\niterator\r\n--FIRST ELEMENT IN AR>x\r\n--NO OF ELEMENTS<=x\r\n*/\r\n#ifdef ANURAG\r\n#define debug(x)        \\\r\n\tcerr << #x << \": \"; \\\r\n\t_print(x);          \\\r\n\tcerr << endl;\r\n#else\r\n#define debug(x) ;\r\n#endif\r\nclass Solution {\r\npublic:\r\n    int scoreOfString(string s) {\r\n            int score = 0;\r\n\t    for (int i = 1; i < s.length(); ++i) {\r\n\t\tscore += abs(s[i] - s[i - 1]);\r\n\t    }\r\n\t    return score;\r\n    }\r\n};\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"header.h\"\n\nextern int numStudents;\nextern int addStudents;\nextern std::vector<STUDENT>students;\n\nint main()\n{\n\tSetConsoleCP(1251);\n\tSetConsoleOutputCP(1251);\n\tsetlocale(LC_ALL, \"RU\");\n\tint choice;\n\n\twhile (true)\n\t{\t\n\t\tstd::cout << \" \u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00ee\u00ec\u00e5\u00f0 \u00ec\u00e5\u00ed\u00fe \\n\";\n\t\tstd::cout << \"[1] \u00c2\u00e2\u00ee\u00e4 \u00f1 \u00ea\u00eb\u00e0\u00e2\u00e8\u00e0\u00f2\u00f3\u00f0\u00fb \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2;\\n\";\n\t\tstd::cout << \"[2] \u00c2\u00fb\u00e2\u00ee\u00e4 \u00ed\u00e0 \u00e4\u00e8\u00f1\u00ef\u00eb\u00e5\u00e9 \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e9 \u00e8 \u00ed\u00ee\u00ec\u00e5\u00f0\u00ee\u00e2 \u00e3\u00f0\u00f3\u00ef\u00ef \u00e2\u00f1\u00e5\u00f5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2, \u00e8\u00ec\u00e5\u00fe\u00f9\u00e8\u00f5 \u00ee\u00f6\u00e5\u00ed\u00ea\u00e8 4 \u00e8 5;\\n\";\n\t\tstd::cout << \"[3] \u00c4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2;\\n\";\n\t\tstd::cout << \"[4] \u00c2\u00fb\u00e2\u00ee\u00e4 \u00ed\u00e0 \u00e4\u00e8\u00f1\u00ef\u00eb\u00e5\u00e9 \u00e2\u00f1\u00e5\u00f5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2 \u00ef\u00ee \u00f3\u00ea\u00e0\u00e7\u00e0\u00ed\u00ee\u00ec\u00f3 \u00ed\u00ee\u00ec\u00e5\u00f0\u00f3 \u00e3\u00f0\u00f3\u00ef\u00ef\u00fb;\\n\";\n\t\tstd::cout << \"[5] \u00cf\u00ee\u00e8\u00f1\u00ea \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00e0 \u00ef\u00ee \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e8.\\n\";\n\t\tstd::cout << \"[0] \u00c2\u00fb\u00f5\u00ee\u00e4\\n\";\n\n\t\tstd::cin >> choice;\n\t\tswitch (choice)\n\t\t{\n\t\tcase EXIT:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\treturn 0;\n\t\t}\n\t\tcase INPUT_DATA:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tstd::cout << \"\u00d1\u00ea\u00ee\u00eb\u00fc\u00ea\u00ee \u00eb\u00fe\u00e4\u00e5\u00e9 \u00e2\u00fb \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc? \"; std::cin >> numStudents;\n\t\t\tinputData();\n\t\t\tfor (const auto& student : students) {\n\t\t\t\tstd::cout << \"\u00c8\u00ec\u00ff: \" << student.name << \", \u00d4\u00e0\u00ec\u00e8\u00eb\u00e8\u00ff: \" << student.surname << \", \u00c3\u00f0\u00f3\u00ef\u00ef\u00e0: \" << student.group << std::endl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tcase PRINT_GOODGRADES_STUDENTS:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tprintGoodGradesStudents(); break;\n\t\t}\n\t\tcase ADD_STUDENT:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tstd::cout << \"\u00d1\u00ea\u00ee\u00eb\u00fc\u00ea\u00ee \u00eb\u00fe\u00e4\u00e5\u00e9 \u00e2\u00fb \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc? \"; std::cin >> numStudents;\n\t\t\tinputData(); break;\n\t\t}\n\t\tcase PRINT_STUDENTS_BY_GROUP:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tprintStudentsByGroup();\tbreak;\n\t\t}\n\t\tcase SEARCH_STUDENT_BY_SURNAME:\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tsearchStudentBySurname();\n\t\t\tbreak;\n\t\t}\n\t\tdefault: system(\"cls\"); std::cout << \"\u00cd\u00e5\u00ea\u00ea\u00ee\u00f0\u00e5\u00ea\u00f2\u00ed\u00fb\u00e9 \u00e2\u00e2\u00ee\u00e4 \u00ef\u00f3\u00ed\u00ea\u00f2\u00e0 \u00ec\u00e5\u00ed\u00fe\\n\";\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"firstproject\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"nuevo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include \"listtoolshb.h\"\r\n#include \"MyList.h\"\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct Profile\r\n{\r\n    string fullname;\r\n    string state;\r\n    bool operator==(Profile rhs)\r\n    {\r\n        if (fullname == rhs.fullname) return true; return false;\r\n    }\r\n    bool operator!=(Profile rhs)\r\n    {\r\n        if (fullname != rhs.fullname) return true; return false;\r\n    }\r\n};\r\nostream& operator<< (ostream& out, Profile& user)\r\n{\r\n    out << user.fullname << \"--\" << user.state;\r\n    return out;\r\n}\r\n\r\nbool searchDeque(MyList<Profile>& pq, Profile& president) {\r\n    for (const auto& profile : pq) {\r\n        if (profile.fullname == president.fullname) {\r\n            president = profile; // Update the president object with the found Profile\r\n            return true;\r\n        }\r\n    }\r\n    return false; // Profile not found\r\n}\r\n\r\nint main()\r\n{\r\n    MyList<Profile> pMyList; // create an object of MyList<Profile>\r\n\r\n    string line;\r\n    Profile temp;\r\n\r\n    //read from the \"presidentsWstates.txt\" file\r\n    ifstream file(\"presidentsWstates.txt\");\r\n    if (file.is_open()) {\r\n        while (getline(file, line)) {\r\n            stringstream ss(line);\r\n            getline(ss, temp.fullname, '\\t');\r\n            getline(ss, temp.state, '\\t');\r\n            pMyList.insertHead(temp); //insert the profile object into pMyList\r\n        }\r\n    }\r\n\r\n    //testing mylist implemenation\r\n    cout << \"Inserting profiles: \" << endl;\r\n    Profile newProfile = { \"Andrew Eisengruber\", \"MI\" };\r\n    pMyList.insertHead(newProfile);\r\n    pMyList.display(); // display all elements\r\n\r\n    cout << \"Depleting head: \" << pMyList.deleteHead() << endl; //\r\n\r\n    Profile searchProfile = { \"Abraham Lincoln\", \"IL\" };\r\n    if (pMyList.search(searchProfile)) {\r\n        cout << \"Found: \" << searchProfile << endl;\r\n    }\r\n    else {\r\n        cout << \"Not Found: \" << searchProfile << endl;\r\n    }\r\n\r\n  \r\n    temp.fullname = \"Gerald R. Ford\";\r\n    if (searchDeque(pMyList, temp)) {\r\n        cout << \"Found: \" << temp << endl;\r\n    }\r\n    else {\r\n        cout << \"Not found: \" << temp << endl;\r\n    }\r\n\r\n}\r\n",
    "/*\n  Asynchronous WebServer library for Espressif MCUs\n\n  Copyright (c) 2016 Hristo Gochkov. All rights reserved.\n  This file is part of the esp8266 core for Arduino environment.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n#include \"ESPAsyncWebServer.h\"\n#include \"WebResponseImpl.h\"\n#include \"WebAuthentication.h\"\n\n#ifndef ESP8266\n#define os_strlen strlen\n#endif\n\nstatic const String SharedEmptyString = String();\n\n#define __is_param_char(c) ((c) && ((c) != '{') && ((c) != '[') && ((c) != '&') && ((c) != '='))\n\nenum { PARSE_REQ_START, PARSE_REQ_HEADERS, PARSE_REQ_BODY, PARSE_REQ_END, PARSE_REQ_FAIL };\n\nAsyncWebServerRequest::AsyncWebServerRequest(AsyncWebServer* s, AsyncClient* c)\n  : _client(c)\n  , _server(s)\n  , _handler(NULL)\n  , _response(NULL)\n  , _temp()\n  , _parseState(0)\n  , _version(0)\n  , _method(HTTP_ANY)\n  , _url()\n  , _host()\n  , _contentType()\n  , _boundary()\n  , _authorization()\n  , _reqconntype(RCT_HTTP)\n  , _isDigest(false)\n  , _isMultipart(false)\n  , _isPlainPost(false)\n  , _expectingContinue(false)\n  , _contentLength(0)\n  , _parsedLength(0)\n  , _headers(LinkedList<AsyncWebHeader *>([](AsyncWebHeader *h){ delete h; }))\n  , _params(LinkedList<AsyncWebParameter *>([](AsyncWebParameter *p){ delete p; }))\n  , _pathParams(LinkedList<String *>([](String *p){ delete p; }))\n  , _multiParseState(0)\n  , _boundaryPosition(0)\n  , _itemStartIndex(0)\n  , _itemSize(0)\n  , _itemName()\n  , _itemFilename()\n  , _itemType()\n  , _itemValue()\n  , _itemBuffer(0)\n  , _itemBufferIndex(0)\n  , _itemIsFile(false)\n  , _tempObject(NULL)\n{\n  c->onError([](void *r, AsyncClient* c, int8_t error){ (void)c; AsyncWebServerRequest *req = (AsyncWebServerRequest*)r; req->_onError(error); }, this);\n  c->onAck([](void *r, AsyncClient* c, size_t len, uint32_t time){ (void)c; AsyncWebServerRequest *req = (AsyncWebServerRequest*)r; req->_onAck(len, time); }, this);\n  c->onDisconnect([](void *r, AsyncClient* c){ AsyncWebServerRequest *req = (AsyncWebServerRequest*)r; req->_onDisconnect(); delete c; }, this);\n  c->onTimeout([](void *r, AsyncClient* c, uint32_t time){ (void)c; AsyncWebServerRequest *req = (AsyncWebServerRequest*)r; req->_onTimeout(time); }, this);\n  c->onData([](void *r, AsyncClient* c, void *buf, size_t len){ (void)c; AsyncWebServerRequest *req = (AsyncWebServerRequest*)r; req->_onData(buf, len); }, this);\n  c->onPoll([](void *r, AsyncClient* c){ (void)c; AsyncWebServerRequest *req = ( AsyncWebServerRequest*)r; req->_onPoll(); }, this);\n}\n\nAsyncWebServerRequest::~AsyncWebServerRequest(){\n  _headers.free();\n\n  _params.free();\n  _pathParams.free();\n\n  _interestingHeaders.free();\n\n  if(_response != NULL){\n    delete _response;\n  }\n\n  if(_tempObject != NULL){\n    free(_tempObject);\n  }\n\n  if(_tempFile){\n    _tempFile.close();\n  }\n}\n\nvoid AsyncWebServerRequest::_onData(void *buf, size_t len){\n  size_t i = 0;\n  while (true) {\n\n  if(_parseState < PARSE_REQ_BODY){\n    // Find new line in buf\n    char *str = (char*)buf;\n    for (i = 0; i < len; i++) {\n      if (str[i] == '\\n') {\n        break;\n      }\n    }\n    if (i == len) { // No new line, just add the buffer in _temp\n      char ch = str[len-1];\n      str[len-1] = 0;\n      _temp.reserve(_temp.length()+len);\n      _temp.concat(str);\n      _temp.concat(ch);\n    } else { // Found new line - extract it and parse\n      str[i] = 0; // Terminate the string at the end of the line.\n      _temp.concat(str);\n      _temp.trim();\n      _parseLine();\n      if (++i < len) {\n        // Still have more buffer to process\n        buf = str+i;\n        len-= i;\n        continue;\n      }\n    }\n  } else if(_parseState == PARSE_REQ_BODY){\n    // A handler should be already attached at this point in _parseLine function.\n    // If handler does nothing (_onRequest is NULL), we don't need to really parse the body.\n    const bool needParse = _handler && !_handler->isRequestHandlerTrivial();\n    if(_isMultipart){\n      if(needParse){\n        size_t i;\n        for(i=0; i<len; i++){\n          _parseMultipartPostByte(((uint8_t*)buf)[i], i == len - 1);\n          _parsedLength++;\n        }\n      } else\n          _parsedLength += len;\n    } else {\n      if(_parsedLength == 0){\n        if(_contentType.startsWith(\"application/x-www-form-urlencoded\")){\n          _isPlainPost = true;\n        } else if(_contentType == \"text/plain\" && __is_param_char",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <GL/glew.h>\n#ifdef __APPLE__\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n\n#include \"Camera.h\"\n\n#include <iostream>\nusing namespace std;\n\n#define CAM_FOCUS\t\t0\n#define CAM_FP\t\t\t1\n\nCamera:: Camera()\n{\n    eye = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    lookat = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    \n    axis_n = vec4(0.0f);\n    axis_u = vec4(0.0f);\n    axis_v = vec4(0.0f);\n\n    fovy        = 0.0f;\n    aspect      = 0.0f;\n    near_plane  = 0.0f;\n    far_plane   = 0.0f;\n\n    world_up = vec4(0.0f, 1.0f, 0.0f, 0.0f);\n\n\tm_mode      = CAM_FOCUS;\n\n    mouse_pos = vec2(0.0f);\n    mouse_pre_pos = vec2(0.0f);\n    mouse_button= 0;\n\n    key_pos = vec2(0.0f);\n    key_pre_pos = vec2(0.0f, 0.0f);\n\tm_altKey     = false;\n\n\tM_ZOOM_PAR   = 0.03f;\n\tM_PAN_PAR    = 50.0f;\n\tM_PAN_PAR_FP = 0.03f;\n\tM_ROTATE_PAR_FP = 8.0f;\n}\n\nCamera :: ~Camera()\n{\n}\n\nvoid Camera::PrintProperty()\n{\n\tcout<<\"********* Camera **********\"<<endl;\n    cout<<\"eye: \"<<eye.x<<\", \"<<eye.y<<\", \" <<eye.z<<endl;\n    cout<<\"lookat: \"<<lookat.x <<\", \"<<lookat.y<<\", \"<<lookat.z<<endl;\n\tcout<<\"angle = \"<<fovy<<endl;\n\tcout<<\"ratio = \"<<aspect<<endl;\n\tcout<<\"near = \"<<near_plane<<endl;\n\tcout<<\"far = \"<<far_plane<<endl;\n\tcout<<\"n = \"<<axis_n.x <<\", \"<<axis_n.y<<\", \"<<axis_n.z<<endl;\n\tcout<<\"u = \"<<axis_u.x<<\", \"<<axis_u.y<<\", \"<<axis_u.z<<endl;\n\tcout<<\"v = \"<<axis_v.x<<\", \"<<axis_v.y<<\", \"<<axis_v.z<<endl;\n\t//cout<<\"fbl = \"<<frustum.fbl.x<<\", \"<<frustum.fbl.y<<\", \"<<frustum.fbl.z<<endl;\n\t//cout<<\"fbr = \"<<frustum.fbr.x<<\", \"<<frustum.fbr.y<<\", \"<<frustum.fbr.z<<endl;\n\t//cout<<\"ftl = \"<<frustum.ftl.x<<\", \"<<frustum.ftl.y<<\", \"<<frustum.ftl.z<<endl;\n\t//cout<<\"ftr = \"<<frustum.ftr.x<<\", \"<<frustum.ftr.y<<\", \"<<frustum.ftr.z<<endl;\n\n}\n\nvoid Camera::set(float eye_x, float eye_y, float eye_z, \n\t\t\t\t float lookat_x, float lookat_y, float lookat_z,\n\t\t\t\t int winW, int winH,\n\t\t\t\t float p_angle, float p_near, float p_far)\n{\n\teye = vec4(eye_x, eye_y, eye_z, 1.0f);\n\tlookat = vec4(lookat_x, lookat_y, lookat_z, 1.0f);\n\t\n\tfovy        = p_angle;\n\tnear_plane  = p_near;\n\tfar_plane   = p_far;\n\n\tsetProjectionMatrix(winW, winH);\n\tsetViewMatrix();\n    GetCamCS();\n    GetViewFrustum();\n}\n\nvoid Camera::switchCamMode() \n{\n    m_mode = (m_mode == CAM_FOCUS) ? CAM_FP : CAM_FOCUS;\n}\n\nbool Camera::isFocusMode()\n{\n\tif(m_mode==CAM_FOCUS) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool Camera::isFPMode()\n{\n\tif(m_mode==CAM_FP) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nvoid Camera::setProjectionMatrix(int winW, int winH)\n{\n\taspect = (float)winW/(float)winH;\n\tprojMat = perspective(radians(fovy), aspect, near_plane,far_plane);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadMatrixf(value_ptr(projMat));\n\t\n\t//glLoadIdentity();\n\t//gluPerspective(fovy, aspect, near_plane, far_plane);\n}\n\nvoid Camera::setViewMatrix()\n{\t\n\tviewMat = lookAt(eye.xyz(), lookat.xyz(), world_up.xyz());\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadMatrixf(value_ptr(viewMat));\n\t//glLoadIdentity();\n\t//gluLookAt(eye.x, eye.y, eye.z,\n\t//          lookat.x, lookat.y, lookat.z,\n\t//\t\t\tworld_up.x, world_up.y, world_up.z);\n}\n\nvoid Camera::mouseClick(int button, int state, int x, int y, int winW, int winH)\n{\n    if(x >= winW || y >= winH) {\n        return;\n    }\n\tmouse_button = (state == GLUT_DOWN) ? button : 0;\n    \n\tif( m_mode == CAM_FP) {\n\t\tif(mouse_button == GLUT_LEFT_BUTTON) {\n\t\t\tmouse_pos = vec2((float)x, -(float)y);\n\t\t\tmouse_pre_pos = mouse_pos;\n\t\t}\n\t} else if(m_mode == CAM_FOCUS) {\n        mouse_pos = vec2(x/(float)winW - 1.0f, (winH-y)/(float)winH - 1.0f);\n\t\tmouse_pre_pos = mouse_pos; \n        m_altKey = (glutGetModifiers() == GLUT_ACTIVE_ALT);\n\t}\n\n\t//glutPostRedisplay();\n}\n\nvoid Camera::mouseMotion(int x, int y, int winW, int winH)\n{\n    if(x >= winW || y >= winH) {\n        return;\n    }\n\n\tif( m_mode == CAM_FP){\t\n\t\tif(mouse_button == GLUT_LEFT_BUTTON) {\n\t\t\tmouse_pos = vec2((float)x, -(float)y);\n\t\t\tCameraRotate_fp(winW, winH);\n\t\t\tmouse_pre_pos = mouse_pos;\n\t\t}\n\t} \n\telse if( m_mode == CAM_FOCUS){\n\t\tmouse_pos = vec2(x/(float)winW - 1.0f, (winH-y)/(float)winH - 1.0f);\n\t\tif (m_altKey){\n            if(mouse_button == GLUT_LEFT_BUTTON) {\n                CameraRotate();\n            } else if(mouse_button == GLUT_MIDDLE_BUTTON) {\n                CameraPan();\n            } else if(mouse_button == GLUT_RIGHT_BUTTON) {\n                CameraZoom();\n            }\n\t\t}\n\t\tmouse_pre_pos = mouse_pos;\n\t}\n\n\tsetProjectionMatrix(winW, winH);\n\tsetViewMatrix();\n\tGetCamCS();\n\tGetViewFrustum();\n    glViewport(0, 0, winW, winH);\n\n\tglutPostRedisplay();\n}\n\nvoid Camera::keyOperation(const unsigned char keyStates[], int winW, int winH)\n{\n    if(m_mode != CAM_FP) {\n        return;\n    }\n\n    float speed = 1.0f;\n\n    if(keyStates['a']) {\n       \tkey_pos.x-=speed;\n\t\tCameraPan_fp();\n\t\tsetProjectionMatrix(winW, winH);\n\t\tsetViewMatrix();\n\t\tGetCamCS();\n\t\tGetViewFrustum();\n        glViewport(0, 0, winW, winH);\n\t\tglutPostRedisplay();\n        key_pre_pos.x = key_pos.x; \n    }\n    if(keyStates['d']) {\n       \tkey_pos.x+=speed;\n\t\tCameraPan_fp();\n\t\tsetProjectionMatrix(winW, winH)",
    "#include <iostream>\n#include \"MemoryGame.hpp\"\n#include <cstdlib> \n#include <time.h>\n#include <iomanip>\n\nusing namespace std;\n\nvoid printSeparatedLine(int size);\nMemoryGame::MemoryGame() {\n    numPairs = 3;\n    numSlots = 8;\n    values = new string[numSlots];\n    bShown = new bool[numSlots];\n\n    // Generate three random integers in [0, 999]\n    int random1 = rand() % 1000;\n    int random2 = rand() % 1000;\n    int random3 = rand() % 1000;\n\n    // Place the random integers in pairs in the values array\n    for (int i = 0; i < numSlots; i += 2) {\n        if (i < 2) {\n            values[i] = to_string(random1);\n            values[i + 1] = to_string(random1);\n            bShown[i] = false;\n            bShown[i + 1] = false;\n        } else if (i < 4) {\n            values[i] = to_string(random2);\n            values[i + 1] = to_string(random2);\n            bShown[i] = false;\n            bShown[i + 1] = false;\n        } else {\n            values[i] = to_string(random3);\n            values[i + 1] = to_string(random3);\n            bShown[i] = false;\n            bShown[i + 1] = false;\n        }\n    }\n\n    // Set the rest of the elements of values to be empty strings\n    for (int i = 6; i < numSlots; i++) {\n        values[i] = \"\";\n        bShown[i] = false;\n    }\n}\n\nMemoryGame::MemoryGame(int numPairs, int numSlots) {\n    if (numPairs <= 0 || numSlots <= 0 || numSlots < 2 * numPairs) {\n        // Default values if parameters are invalid\n        numPairs = 3;\n        numSlots = 8;\n    }\n\n    this->numPairs = numPairs;\n    this->numSlots = numSlots;\n    values = new string[numSlots];\n    bShown = new bool[numSlots];\n\n    // Generate numPairs random integers in [0, 999]\n    for (int i = 0; i < numPairs; i++) {\n        int random = rand() % 1000;\n        for (int j = 0; j < 2; j++) {\n            values[i * 2 + j] = to_string(random);\n            bShown[i * 2 + j] = false;\n        }\n    }\n\n    // Set the rest of the elements of values to be empty strings\n    for (int i = numPairs * 2; i < numSlots; i++) {\n        values[i] = \"\";\n        bShown[i] = false;\n    }\n}\n\nMemoryGame::MemoryGame(string* words, int size, int numSlots) {\n    // Adjust numSlots if necessary\n    if (size <= 0 || numSlots <= 0 || numSlots < 2 * size) {\n        numSlots = 2 * size;\n    }\n\n    // Set data members numPairs and numSlots\n    numPairs = size;\n    this->numSlots = numSlots;\n\n    // Allocate dynamic memory for values and bShown\n    values = new string[numSlots];\n    bShown = new bool[numSlots];\n\n    // Initialize values with words and empty strings\n    int wordIndex = 0;\n    for (int i = 0; i < numSlots; i++) {\n        if (wordIndex < size) {\n            values[i] = words[wordIndex];\n            values[i + 1] = words[wordIndex]; // Place each word in pairs\n            i++; // Skip next iteration\n        } else {\n            values[i] = \"\"; // Fill the rest with empty strings\n        }\n        bShown[i] = false; // Initialize bShown\n        wordIndex++;\n    }\n}\n\nMemoryGame::~MemoryGame() {\n    delete[] values;\n    delete[] bShown;\n\n    // Set values and bShown to nullptr after deletion\n    values = nullptr;\n    bShown = nullptr;\n}\n\nvoid MemoryGame::play() {\n\n}\nvoid MemoryGame::display() const {\n    //print labels\n    cout << \" \";\n    for (int i = 0; i < numSlots; i++)\n    cout << setw(3) << i << setw(3) << \" \";\n    //setw(3) before i means i occupies 3-character,\n    //For example, if i has only two digits,\n    //then pad a space to its left.\n\n    cout << endl;\n \n\n    // Print separated line\n    printSeparatedLine(numSlots);\n\n    // Print values\n    cout << \"|\";\n    for(int i = 0; i < numSlots; i++){\n        if(bShown[i]){\n            cout << setw(5) << values[i] << \"|\";\n        }else{\n            cout << \"     |\";\n        }\n    }\n    cout << endl;\n\n    // Print separated line\n    printSeparatedLine(numSlots);\n}\nvoid MemoryGame::randomize()\n{\n    int size = 8;\n    while (size > 1){\n        int index = rand() % size;\n        swap(values[index], values[size-1]);\n        size--;\n    }\n}\n\nint MemoryGame:: input() const\n{\n\n}\n\n\n\nvoid printSeparatedLine(int size) {\n    cout << \"+\"; // The first +\n    // Draw -----+ for (size) many times\n    for (int i = 0; i < size; i++)\n        cout << \"-----+\";\n\n    cout << endl;\n}\n\n",
    "/**\n * \\file MGRS.cpp\n * \\brief Implementation for GeographicLib::MGRS class\n *\n * Copyright (c) Charles Karney (2008-2017) <charles@karney.com> and licensed\n * under the MIT/X11 License.  For more information, see\n * https://geographiclib.sourceforge.io/\n **********************************************************************/\n\n#include \"MGRS.hpp\"\n#include \"Utility.hpp\"\n\nnamespace GeographicLib {\n\n  using namespace std;\n\n  const char* const MGRS::hemispheres_ = \"SN\";\n  const char* const MGRS::utmcols_[] = { \"ABCDEFGH\", \"JKLMNPQR\", \"STUVWXYZ\" };\n  const char* const MGRS::utmrow_ = \"ABCDEFGHJKLMNPQRSTUV\";\n  const char* const MGRS::upscols_[] =\n    { \"JKLPQRSTUXYZ\", \"ABCFGHJKLPQR\", \"RSTUXYZ\", \"ABCFGHJ\" };\n  const char* const MGRS::upsrows_[] =\n    { \"ABCDEFGHJKLMNPQRSTUVWXYZ\", \"ABCDEFGHJKLMNP\" };\n  const char* const MGRS::latband_ = \"CDEFGHJKLMNPQRSTUVWX\";\n  const char* const MGRS::upsband_ = \"ABYZ\";\n  const char* const MGRS::digits_ = \"0123456789\";\n\n  const int MGRS::mineasting_[] =\n    { minupsSind_, minupsNind_, minutmcol_, minutmcol_ };\n  const int MGRS::maxeasting_[] =\n    { maxupsSind_, maxupsNind_, maxutmcol_, maxutmcol_ };\n  const int MGRS::minnorthing_[] =\n    { minupsSind_, minupsNind_,\n      minutmSrow_, minutmSrow_ - (maxutmSrow_ - minutmNrow_) };\n  const int MGRS::maxnorthing_[] =\n    { maxupsSind_, maxupsNind_,\n      maxutmNrow_ + (maxutmSrow_ - minutmNrow_), maxutmNrow_ };\n\n  void MGRS::Forward(int zone, bool northp, real x, real y, real lat,\n                     int prec, std::string& mgrs) {\n    // The smallest angle s.t., 90 - angeps() < 90 (approx 50e-12 arcsec)\n    // 7 = ceil(log_2(90))\n    static const real angeps = ldexp(real(1), -(Math::digits() - 7));\n    if (zone == UTMUPS::INVALID ||\n        Math::isnan(x) || Math::isnan(y) || Math::isnan(lat)) {\n      mgrs = \"INVALID\";\n      return;\n    }\n    bool utmp = zone != 0;\n    CheckCoords(utmp, northp, x, y);\n    if (!(zone >= UTMUPS::MINZONE && zone <= UTMUPS::MAXZONE))\n      throw GeographicErr(\"Zone \" + Utility::str(zone) + \" not in [0,60]\");\n    if (!(prec >= -1 && prec <= maxprec_))\n      throw GeographicErr(\"MGRS precision \" + Utility::str(prec)\n                          + \" not in [-1, \"\n                          + Utility::str(int(maxprec_)) + \"]\");\n    // Fixed char array for accumulating string.  Allow space for zone, 3 block\n    // letters, easting + northing.  Don't need to allow for terminating null.\n    char mgrs1[2 + 3 + 2 * maxprec_];\n    int\n      zone1 = zone - 1,\n      z = utmp ? 2 : 0,\n      mlen = z + 3 + 2 * prec;\n    if (utmp) {\n      mgrs1[0] = digits_[ zone / base_ ];\n      mgrs1[1] = digits_[ zone % base_ ];\n      // This isn't necessary...!  Keep y non-neg\n      // if (!northp) y -= maxutmSrow_ * tile_;\n    }\n    // The C++ standard mandates 64 bits for long long.  But\n    // check, to make sure.\n    GEOGRAPHICLIB_STATIC_ASSERT(numeric_limits<long long>::digits >= 44,\n                                \"long long not wide enough to store 10e12\");\n    long long\n      ix = (long long)(floor(x * mult_)),\n      iy = (long long)(floor(y * mult_)),\n      m = (long long)(mult_) * (long long)(tile_);\n    int xh = int(ix / m), yh = int(iy / m);\n    if (utmp) {\n      int\n        // Correct fuzziness in latitude near equator\n        iband = abs(lat) > angeps ? LatitudeBand(lat) : (northp ? 0 : -1),\n        icol = xh - minutmcol_,\n        irow = UTMRow(iband, icol, yh % utmrowperiod_);\n      if (irow != yh - (northp ? minutmNrow_ : maxutmSrow_))\n        throw GeographicErr(\"Latitude \" + Utility::str(lat)\n                            + \" is inconsistent with UTM coordinates\");\n      mgrs1[z++] = latband_[10 + iband];\n      mgrs1[z++] = utmcols_[zone1 % 3][icol];\n      mgrs1[z++] = utmrow_[(yh + (zone1 & 1 ? utmevenrowshift_ : 0))\n                         % utmrowperiod_];\n    } else {\n      bool eastp = xh >= upseasting_;\n      int iband = (northp ? 2 : 0) + (eastp ? 1 : 0);\n      mgrs1[z++] = upsband_[iband];\n      mgrs1[z++] = upscols_[iband][xh - (eastp ? upseasting_ :\n                                         (northp ? minupsNind_ :\n                                          minupsSind_))];\n      mgrs1[z++] = upsrows_[northp][yh - (northp ? minupsNind_ : minupsSind_)];\n    }\n    if (prec > 0) {\n      ix -= m * xh; iy -= m * yh;\n      long long d = (long long)(pow(real(base_), maxprec_ - prec));\n      ix /= d; iy /= d;\n      for (int c = prec; c--;) {\n        mgrs1[z + c       ] = digits_[ix % base_]; ix /= base_;\n        mgrs1[z + c + prec] = digits_[iy % base_]; iy /= base_;\n      }\n    }\n    mgrs.resize(mlen);\n    copy(mgrs1, mgrs1 + mlen, mgrs.begin());\n  }\n\n  void MGRS::Forward(int zone, bool northp, real x, real y,\n                     int prec, std::string& mgrs) {\n    real lat, lon;\n    if (zone > 0) {\n      // Does a rough estimate for latitude determine the latitude band?\n      real ys = northp ? y : y - utmNshift_;\n      // A cheap calculation of the latitude which results in an \"allowed\"\n      // latitude band would b",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"clockdesign\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <thread>\r\n#include <mutex>\r\n#include <semaphore>\r\n\r\nclass ReadersWriters {\r\nprivate:\r\n    std::mutex mutex;\r\n    sem_t write_mutex;\r\n    int readers_count;\r\n\r\npublic:\r\n    ReadersWriters() : readers_count(0) {\r\n        sem_init(&write_mutex, 0, 1);\r\n    }\r\n\r\n    void start_read() {\r\n        mutex.lock();\r\n        readers_count++;\r\n        if (readers_count == 1) {\r\n            sem_wait(&write_mutex);\r\n        }\r\n        mutex.unlock();\r\n\r\n        // Reading the shared resource\r\n        std::cout << \"Reader is reading\" << std::endl;\r\n\r\n        mutex.lock();\r\n        readers_count--;\r\n        if (readers_count == 0) {\r\n            sem_post(&write_mutex);\r\n        }\r\n        mutex.unlock();\r\n    }\r\n\r\n    void start_write() {\r\n        sem_wait(&write_mutex);\r\n\r\n        // Writing to the shared resource\r\n        std::cout << \"Writer is writing\" << std::endl;\r\n\r\n        sem_post(&write_mutex);\r\n    }\r\n};\r\n\r\nvoid reader_thread(ReadersWriters& rw, int id) {\r\n    while (true) {\r\n        // Reading\r\n        rw.start_read();\r\n        // Simulating some delay for reading\r\n        std::this_thread::sleep_for(std::chrono::milliseconds(1000));\r\n    }\r\n}\r\n\r\nvoid writer_thread(ReadersWriters& rw, int id) {\r\n    while (true) {\r\n        // Writing\r\n        rw.start_write();\r\n        // Simulating some delay for writing\r\n        std::this_thread::sleep_for(std::chrono::milliseconds(2000));\r\n    }\r\n}\r\n\r\nint main() {\r\n    ReadersWriters rw;\r\n\r\n    // Creating reader threads\r\n    std::thread readers[5];\r\n    for (int i = 0; i < 5; ++i) {\r\n        readers[i] = std::thread(reader_thread, std::ref(rw), i);\r\n    }\r\n\r\n    // Creating writer threads\r\n    std::thread writers[2];\r\n    for (int i = 0; i < 2; ++i) {\r\n        writers[i] = std::thread(writer_thread, std::ref(rw), i);\r\n    }\r\n\r\n    // Joining threads\r\n    for (int i = 0; i < 5; ++i) {\r\n        readers[i].join();\r\n    }\r\n    for (int i = 0; i < 2; ++i) {\r\n        writers[i].join();\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<algorithm>\nusing namespace std;\n\n struct ListNode {\n    int val;\n     ListNode *next;\n   ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \n double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n     //nums1.resize(nums1.size() + nums2.size());\n     nums1.insert(nums1.end(), nums2.begin(), nums2.end());\n     sort(nums1.begin(), nums1.end());\n     int mid = nums1.size() / 2;\n     if (nums1.size() % 2 == 0)\n         return((double)nums1[mid] + (double)nums1[mid + 1]) / 2;\n     else\n         return double(nums1[mid]);\n }\n int main()\n {\n     vector<int>v1, v2;\n     v1.push_back(1);\n     v1.push_back(3);\n     v2.push_back(2);\n     double b = findMedianSortedArrays(v1, v2);\n     return 0;\n }\n //class Solution {\n //public:\n //    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n //        ListNode* head = nullptr, * tail = nullptr;\n //        int carry = 0;\n //        while (l1 || l2) {\n //            int n1 = l1 ? l1->val : 0;\n //            int n2 = l2 ? l2->val : 0;\n //            int sum = n1 + n2 + carry;\n //            if (!head) {\n //                head = tail = new ListNode(sum % 10);\n //            }\n //            else {\n //                tail->next = new ListNode(sum % 10);\n //                tail = tail->next;\n //            }\n //            carry = sum / 10;\n //            if (l1) {\n //                l1 = l1->next;\n //            }\n //            if (l2) {\n //                l2 = l2->next;\n //            }\n //        }\n //        if (carry > 0) {\n //            tail->next = new ListNode(carry);\n //        }\n //        return head;\n //    }\n //};\n//class Solution {\n//public:\n//    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n//        int flag = 0;\n//        ListNode* list1=new ListNode(l1->val + l2->val + flag);\n//        ListNode*head = list1;\n//        while (l1 != NULL&&l2!=NULL)\n//        {\n//            l1 = l1->next;\n//            l2 = l2->next;\n//            ListNode* list2 = new ListNode(l1->val + l2->val + flag);\n//            flag = (l1->val + l2->val + flag) / 10;\n//            list1->next = list2;\n//            list1 = list2;\n//        }\n//        while (l1 != NULL)\n//        {\n//            l1 = l1->next;\n//            ListNode* list2 = new ListNode(l1->val);\n//            list1->next = list2;\n//            list1 = list2;\n//        }\n//        while (l2 != NULL)\n//        {\n//            l2 = l2->next;\n//            ListNode* list2 = new ListNode(l2->val);\n//            list1->next = list2;\n//            list1 = list2;\n//        }\n//        return head;\n//    }\n//};\n\n",
    "#include<iostream>\r\n#include<conio.h>\r\n#include<fstream>\r\n#include<dos.h>\r\n#include<iomanip>\r\n#include<windows.h>\r\n#include<time.h>\r\n#include<wtypes.h>\r\n\r\n\r\ntypedef unsigned __LONG32 DWORD;\r\n#define delay      Sleep\r\n#define gotoxy     gotoXY\r\n#define clrscr()   system(\"CLS\")\r\n#define random(x)  rand()%x\r\n#define DATE_TIME  TIME_DATE\r\n#define pause()    system(\"pause\")\r\n#define wait()     pause()\r\n\r\nusing namespace std;\r\nint h;\r\nint w;\r\n\r\n\r\nstruct GAME\r\n{\r\n    int grid[3][3];\r\n    int token;\r\n    int row,column;\r\n    int moves;\r\n}G,C;\r\n\r\nenum COLORS{BLACK,BLUE,GREEN,CYAN,RED,MAGENTA,BROWN,LIGHTGRAY,GRAY,LIGHTBLUE,LIGHTGREEN,LIGHTCYAN,LIGHTRED,LIGHTMAGENTA,YELLOW,WHITE};\r\n\r\nvoid GET_CONSOLE_SIZE(int & HEIGHT_H, int & WIDTH_W)\r\n{\r\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\r\n\r\n    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);\r\n    WIDTH_W = csbi.srWindow.Right - csbi.srWindow.Left + 1;\r\n    HEIGHT_H = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\r\n}\r\n\r\nvoid SetColors(int FOREGROUND,int BACKGROUND)\r\n{\r\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),(FOREGROUND+(BACKGROUND*16)));\r\n}\r\n\r\nvoid gotoXY(int X_AXIS,int Y_AXIS)\r\n{\r\n    COORD coordinates;\r\n\r\n    coordinates.X=X_AXIS;\r\n    coordinates.Y=Y_AXIS;\r\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),coordinates);\r\n}\r\n\r\n\r\nvoid GetDesktopResolution(int& horizontal, int& vertical)\r\n{\r\n    RECT desktop;\r\n    HWND hDesktop =  GetDesktopWindow();\r\n    GetWindowRect(hDesktop, &desktop);\r\n    horizontal = desktop.right;\r\n    vertical = desktop.bottom;\r\n}\r\n\r\nvoid ConsoleSize(int i,int x_axis=0,int y_axis=0,int horizontal_buffer=0,int vertical_buffer=0)\r\n{\r\n        HWND hWnd = GetConsoleWindow();\r\n        typedef HWND WINAPI(*GetConsoleWindowT)(void);\r\n        GetConsoleWindowT GetConsoleWindow;\r\n        HMODULE hk32Lib = GetModuleHandle(TEXT(\"KERNEL32.DLL\"));\r\n        GetConsoleWindow = (GetConsoleWindowT)GetProcAddress(hk32Lib,TEXT(\"GetConsoleWindow\"));\r\n        if(GetConsoleWindow == NULL)\r\n             exit(0);\r\n        if(i==0)\r\n        {\r\n            GetDesktopResolution(horizontal_buffer,vertical_buffer);\r\n            MoveWindow(hWnd,0,0,horizontal_buffer,vertical_buffer,TRUE);\r\n        }\r\n        else if(i==1)\r\n        {\r\n            MoveWindow(hWnd,x_axis,y_axis,horizontal_buffer,vertical_buffer,TRUE);\r\n        }\r\n\r\n}\r\n\r\nvoid resizeWindow(int x_axis,int y_axis,int horizontal_buffer,int vertical_buffer)\r\n{\r\n    ConsoleSize(1,x_axis,y_axis,horizontal_buffer,vertical_buffer);\r\n}\r\n\r\nvoid MaximiseWindow()\r\n{\r\n    resizeWindow(0,0,0,0);\r\n    ConsoleSize(0);\r\n}\r\n\r\nvoid SHOWMOVE(char op='o')\r\n{\r\n\r\n       if(C.token==1)\r\n         SetColors(10,12);\r\n       else\r\n         SetColors(5,10);\r\n\r\n        if(C.grid[C.row-1][C.column-1]==9||op=='l')\r\n        {\r\n/******************************************************************************************************************************\r\n                                                    ROW : 1 START\r\n*******************************************************************************************************************************/\r\n          if(C.column==1&&C.row==1)\r\n                    for(int r=0;r<3;r++)\r\n                        for(int c=0;c<9;c++)\r\n                       {\r\n                           gotoXY(c+w*0.5-15,r+h*0.5-6);\r\n\r\n                           cout<<\" \";\r\n                       }\r\n\r\n          if(C.column==2&&C.row==1)\r\n                     for(int r=0;r<3;r++)\r\n                        for(int c=0;c<9;c++)\r\n                       {\r\n                           gotoXY(10+c+w*0.5-15,r+h*0.5-6);\r\n                           cout<<\" \";\r\n                       }\r\n\r\n          if(C.column==3&&C.row==1)\r\n                     for(int r=0;r<3;r++)\r\n                        for(int c=0;c<9;c++)\r\n                       {\r\n                           gotoXY(20+c+w*0.5-15,r+h*0.5-6);\r\n                           cout<<\" \";\r\n                       }\r\n\r\n/******************************************************************************************************************************\r\n                                                    ROW : 1 END\r\n*******************************************************************************************************************************/\r\n\r\n/******************************************************************************************************************************\r\n                                                    ROW : 2 START\r\n*******************************************************************************************************************************/\r\n\r\n\r\n           if(C.column==1&&C.row==2)\r\n                     for(int r=0;r<3;r++)\r\n                        for(int c=0;c<9;c++)\r\n                       {\r\n                           gotoXY(c+w*0.5-15,4+r+h*0.5-6);\r\n\r\n                           cout<<\" \";\r\n                       }\r\n           if(C.column==2&&C.row==2)\r\n                    for(int r=0;r<3;r++)\r\n                        for(int c=0;c<9;c",
    "//\n// Created by sleepingwithshoes on 06.04.24.\n//\n\n#include \"yolov8detect.h\"\n\n\n#include <torch/script.h>\n#include <torch/torch.h>\n#include <fstream>\n#include <random>\n\nnamespace sleepingwithshoes::yolo {\n\n    YoloV8detect::YoloV8detect(const std::string& modelPath, const std::string& classesPath, const std::pair<int, int>& inputSize, torch::Device device)\n    :  _device(device)\n    , _inputSize(inputSize)\n    {\n        _loadModel(std::filesystem::absolute(modelPath));\n        _loadClasses(std::filesystem::absolute(classesPath));\n        _generateColors(_classnames.size());\n    }\n\n    std::vector<BoundingBox> YoloV8detect::detect(const cv::Mat &image, float score_thresh, float iou_thresh) {\n        cv::Mat resizedImage;\n\n        // Preprocessing\n        cv::resize(image, resizedImage, cv::Size(_inputSize.first, _inputSize.second));\n        cv::cvtColor(resizedImage, resizedImage, cv::COLOR_BGR2RGB);\n\n        // Preparing input tensor\n        torch::Tensor imgTensor = torch::from_blob(resizedImage.data, {resizedImage.rows, resizedImage.cols, 3}, torch::kByte);\n        imgTensor = imgTensor.permute({2, 0, 1}).toType(torch::kFloat).div(255).unsqueeze(0).to(_device);\n\n        auto output = _model.forward({imgTensor.to(_device)});\n\n        if (output.isNone()) {\n           throw std::runtime_error(\"model output is None\");\n        }\n        auto detectionsOutput = _nonMaxSupression(output.toTensor().to(_device), score_thresh, iou_thresh, _device);\n\n        const float scale_x = static_cast<float>(image.cols) / static_cast<float>(_inputSize.first);\n        const float scale_y = static_cast<float>(image.rows) / static_cast<float>(_inputSize.second);\n\n        std::vector<BoundingBox> boxes;\n        for(auto& detection : detectionsOutput) {\n            BoundingBox box;\n            box.x1 = static_cast<int>(detection[0].item<float>() * scale_x);\n            box.y1 = static_cast<int>(detection[1].item<float>() * scale_y);\n            box.x2 = static_cast<int>(detection[2].item<float>() * scale_x);\n            box.y2 = static_cast<int>(detection[3].item<float>() * scale_y);\n            box.score = detection[4].item<double>();\n            box.classID = detection[5].item<int>();\n            box.width = box.x2 - box.x1;\n            box.height = box.y2 - box.y1;\n            box.className = _classnames[box.classID];\n            box.color = _colors[box.classID];\n            boxes.push_back(box);\n        }\n        return boxes;\n    }\n\n    void YoloV8detect::_loadModel(const std::filesystem::path& modelAbsPath) {\n        try {\n            _model = torch::jit::load(modelAbsPath, _device);\n            std::cout << \"Model loaded: \" << modelAbsPath.string() << std::endl;\n        } catch (const c10::Error &e) {\n            throw std::runtime_error(\"Error loading the model: \" + modelAbsPath.string() + \"\\n\" + e.what());\n        } catch (const std::exception &e) {\n            throw std::runtime_error(\"Error loading the model: \" + modelAbsPath.string() + \"\\n\" + e.what());\n        }\n    }\n\n    void YoloV8detect::_loadClasses(const std::filesystem::path& classesAbsPath) {\n        if(!std::filesystem::exists(classesAbsPath)) {\n            throw std::runtime_error(\"classes doesn't exists: \" + classesAbsPath.string());\n        }\n\n        std::ifstream file(classesAbsPath);\n        std::string name;\n        while (std::getline(file, name)) {\n            _classnames.push_back(name);\n        }\n        std::cout << \"Classes loaded: \" << classesAbsPath.string() << std::endl;\n    }\n\n    void YoloV8detect::_generateColors(int classCounts) {\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        for (int i = 0; i < classCounts; ++i) {\n            std::uniform_int_distribution<> dis(0, 255);\n            auto color =  cv::Scalar(dis(gen), dis(gen), dis(gen));\n            _colors.push_back(color);\n        }\n    }\n\n    std::vector<torch::Tensor> YoloV8detect::_nonMaxSupression(const torch::Tensor &preds, float score_thresh, float iou_thresh, torch::Device device) {\n        std::vector<torch::Tensor> detectionOutputs;\n\n        // preds [1, 84, 8400]\n        for(int i = 0; i < preds.sizes()[0]; ++i) {\n            torch::Tensor batch = preds[i].transpose(0,1).to(device); // [8400, 84]\n            auto maxScores = std::get<0>(torch::max(batch.slice(1, 4, batch.sizes()[1]), 1)).to(device);\n            batch = torch::index_select(batch, 0, torch::nonzero(maxScores > score_thresh).select(1, 0)).to(device);\n            if (batch.sizes()[0] == 0) {\n                continue;\n            }\n\n            // compute center_x, center_y, w, h -> x1, y1, x2, y2\n            torch::Tensor x1 = batch.select(1, 0) - (batch.select(1, 2) / 2).to(device); // x - w/2\n            torch::Tensor y1 = batch.select(1, 1) - (batch.select(1, 3) / 2).to(device); // y - h/2\n            torch::Tensor x2 = batch.select(1, 0) + (batch.select(1, 2) / 2).to(device); // x + w/2\n            torch::Tensor y2 = batch.select(1, 1) + (batch.select(1, 3) / 2).to(device); // y + h/2\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bmi_calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <argparse/argparse.hpp>\n#include <doctest.hpp>\n#include <test_utility.hpp>\n\nusing doctest::test_suite;\n\nTEST_CASE(\"Parse vector of arguments\" * test_suite(\"vector\")) {\n  argparse::ArgumentParser program(\"test\");\n  program.add_argument(\"input\").nargs(2);\n\n  program.parse_args({\"test\", \"rocket.mesh\", \"thrust_profile.csv\"});\n\n  auto inputs = program.get<std::vector<std::string>>(\"input\");\n  REQUIRE(inputs.size() == 2);\n  REQUIRE(inputs[0] == \"rocket.mesh\");\n  REQUIRE(inputs[1] == \"thrust_profile.csv\");\n}\n\nTEST_CASE(\"Parse list of arguments\" * test_suite(\"vector\")) {\n  argparse::ArgumentParser program(\"test\");\n  program.add_argument(\"input\").nargs(2);\n\n  program.parse_args({\"test\", \"rocket.mesh\", \"thrust_profile.csv\"});\n\n  auto inputs = program.get<std::list<std::string>>(\"input\");\n  REQUIRE(inputs.size() == 2);\n  REQUIRE(testutility::get_from_list(inputs, 0) == \"rocket.mesh\");\n  REQUIRE(testutility::get_from_list(inputs, 1) == \"thrust_profile.csv\");\n}\n\nTEST_CASE(\"Parse list of arguments with default values\" *\n          test_suite(\"vector\")) {\n  argparse::ArgumentParser program(\"test\");\n  program.add_argument(\"--input\")\n      .default_value(std::list<int>{1, 2, 3, 4, 5})\n      .nargs(5);\n\n  program.parse_args({\"test\"});\n\n  auto inputs = program.get<std::list<int>>(\"--input\");\n  REQUIRE(inputs.size() == 5);\n  REQUIRE(testutility::get_from_list(inputs, 0) == 1);\n  REQUIRE(testutility::get_from_list(inputs, 1) == 2);\n  REQUIRE(testutility::get_from_list(inputs, 2) == 3);\n  REQUIRE(testutility::get_from_list(inputs, 3) == 4);\n  REQUIRE(testutility::get_from_list(inputs, 4) == 5);\n  REQUIRE(program[\"--input\"] == std::list<int>{1, 2, 3, 4, 5});\n}\n\nTEST_CASE(\"Parse list of arguments and save in an object\" *\n          test_suite(\"vector\")) {\n\n  struct ConfigManager {\n    std::vector<std::string> files;\n    void add_file(const std::string &file) { files.push_back(file); }\n  };\n\n  ConfigManager config_manager;\n\n  argparse::ArgumentParser program(\"test\");\n  program.add_argument(\"--input_files\")\n      .nargs(2)\n      .action([&](const std::string &value) {\n        config_manager.add_file(value);\n        return value;\n      });\n\n  program.parse_args({\"test\", \"--input_files\", \"config.xml\", \"system.json\"});\n\n  auto file_args = program.get<std::vector<std::string>>(\"--input_files\");\n  REQUIRE(file_args.size() == 2);\n  REQUIRE(file_args[0] == \"config.xml\");\n  REQUIRE(file_args[1] == \"system.json\");\n\n  REQUIRE(config_manager.files.size() == 2);\n  REQUIRE(config_manager.files[0] == \"config.xml\");\n  REQUIRE(config_manager.files[1] == \"system.json\");\n  REQUIRE(program[\"--input_files\"] ==\n          std::vector<std::string>{\"config.xml\", \"system.json\"});\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//  Problem\n\n// You are a hiker preparing for an upcoming hike. \n// You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col).\n// You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed).\n// You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\n\n// A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.\n\n// https://practice.geeksforgeeks.org/problems/path-with-minimum-effort/1\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define inf 1e9\n#define pii pair<int, int>\n\nint main(){\n    int r, c;\n    cin>>r>>c;\n\n    vector<vector<int>>grid(r, vector<int>(c));\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin>>grid[i][j];\n        }\n    }\n\n    priority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<pair<int, pii>>>pq;\n    vector<vector<int>>effort(r, vector<int>(c, inf));\n\n    effort[0][0] = 0;\n\n    pq.push({0, {0, 0}});\n\n    while(!pq.empty()){\n        int x = pq.top().second.first;\n        int y = pq.top().second.second;\n        int d = pq.top().first;\n        \n        if (x == r-1 and y == c-1){\n            cout<<d;\n            return 0;\n        }\n        \n        pq.pop();\n\n        pii fnbr[4] = {{x+1, y}, {x-1, y}, {x, y-1}, {x, y+1}};\n\n        for(auto it : fnbr){\n            if (it.first < 0 or it.second < 0 or it.first >= r or it.second >= c) continue;\n\n            int diff = abs(grid[x][y] - grid[it.first][it.second]);\n            int t = max(d, diff);\n\n            if (t < effort[it.first][it.second]){\n                effort[it.first][it.second] = t;\n                pq.push({t, {it.first, it.second}});\n            }\n        }\n    }  \n\n}\n\n// Sample Test Case\n\n// 3 3\n// 1 2 2\n// 3 8 2\n// 5 3 5\n\n// Output\n// 2 (1-3-5-3-5)",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ldsw_widgets\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\nusing namespace std;\nconst char *nombre_archivo = \"archivo.dat\";\nstruct Estudiante{\n\tint codigo;\n\tchar nombres[50];\n\tchar apellidos[50];\n\tint telefono;\n};\nvoid Leer();\nvoid Crear();\nvoid Actualizar();\nvoid Borrar();\nmain() {\n\tLeer();\n  \tCrear();\n  \tBorrar();\n\tActualizar();\n  \t\n\tsystem(\"pause\");\n}\nvoid Leer(){\n\tsystem(\"cls\");\n\tFILE* archivo = fopen(nombre_archivo,\"rb\");\n\tif (!archivo){\n\t\tarchivo = fopen(nombre_archivo,\"w+b\");\n\t}\n\tEstudiante estudiante;\n\tint id=0; // indice o pocision del registro(fila) dentro del archivo\n\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\tcout<<\"___________________________________________________\"<<endl;\n\tcout<<\"ID\"<<\"|\"<<\"Codigo\"<<\"|\"<<\"   Nombres  \"<<\"|\"<<\"   Apellidos   \"<<\"|\"<<\" Telefono\"<<endl;\n\tdo{\n\t\tcout<<id<<\"|\"<<estudiante.codigo<<\"|\"<<estudiante.nombres<<\"|\"<<estudiante.apellidos<<\"|\"<<estudiante.telefono<<endl;\n\t\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\t\tid+=1;\n\t}while(feof(archivo)==0);\n\tfclose(archivo);\n}\nvoid Crear(){\n\t\n\tFILE* archivo = fopen(nombre_archivo,\"a+b\");\n\tchar res;\n\tEstudiante estudiante;\n\tdo{\n\t\tfflush(stdin);\n\t\tcout<<\"Ingrese Codigo:\";\n\t\tcin>>estudiante.codigo;\n\t\tcin.ignore();\n\t\t\n\t\tcout<<\"Ingrese Nombres:\";\n\t\tcin.getline(estudiante.nombres,50);\n\t\t\n\t\tcout<<\"Ingrese Apellidos:\";\n\t\tcin.getline(estudiante.apellidos,50);\n\t\t\n\t\tcout<<\"Ingrese Telefono:\";\n\t\tcin>>estudiante.telefono;\n\t\t\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\tcout<<\"Desea ingresar otro estudiante(s/n):\";\n\t\tcin>>res;\n\t}while(res=='s' || res=='S');\n\tfclose(archivo);\n\tLeer();\n}\nvoid Actualizar(){\n\t\n\tFILE* archivo = fopen(nombre_archivo,\"r+b\"); \n\tEstudiante estudiante;\n\tint id=0;\n\tcout<<\"Ingrese el ID que desea Modificar:\";\n\tcin>>id;\n\tfseek(archivo,id * sizeof(Estudiante),SEEK_SET);\n\t\tcout<<\"Ingrese Codigo:\";\n\t\tcin>>estudiante.codigo;\n\t\tcin.ignore();\n\t\t\n\t\tcout<<\"Ingrese Nombres:\";\n\t\tcin.getline(estudiante.nombres,50);\n\t\t\n\t\tcout<<\"Ingrese Apellidos:\";\n\t\tcin.getline(estudiante.apellidos,50);\n\t\t\n\t\tcout<<\"Ingrese Telefono:\";\n\t\tcin>>estudiante.telefono;\n\t\t\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\n\t\n\tfclose(archivo);\n\tLeer();\n}\nvoid Borrar(){\n\tconst char *nombre_archivo_temp = \"archivo_temp.dat\";\n\tFILE* archivo_temp = fopen(nombre_archivo_temp,\"w+b\");\n\tFILE* archivo = fopen(nombre_archivo,\"rb\");\n\tEstudiante estudiante;\n\tint id=0,id_n=0;\n\tcout<<\"Ingrese el ID a eliminar:\";\n\tcin>>id;\n\twhile(fread(&estudiante,sizeof(Estudiante),1,archivo)){\n\t\tif (id_n !=id ){\n\t\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo_temp);\n\t\t}\n\t\tid_n++;\n\t}\n\tfclose(archivo);\n\tfclose(archivo_temp);\n\t\n\tarchivo_temp = fopen(nombre_archivo_temp,\"rb\");\n\tarchivo = fopen(nombre_archivo,\"wb\");\n\twhile(fread(&estudiante,sizeof(Estudiante),1,archivo_temp)){\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\t\n\t}\n\t\tfclose(archivo);\n\tfclose(archivo_temp);\n\tLeer();\n}\n/*\n \n */\nvoid buscar_codigo(){\n\t\tFILE* archivo = fopen(nombre_archivo,\"rb\");\t\n\tint pos=0,indice=0,cod=0;\n\tcout<<\"Que codigo desea ver: \";\n\tcin>>cod;\n\t\n\tEstudiante estudiante;\n\tfread(&estudiante,sizeof(Estudiante),1,archivo);\t\n\tdo{\n\t   if(estudiante.codigo == cod)\t{\n\t   \tcout<<\"Codigo: \"<<estudiante.codigo<<endl;\n\t   \tcout<<\"Nombres: \"<<estudiante.nombres<<endl;\n\t   \tcout<<\"Apellidos: \"<<estudiante.apellidos<<endl;\n\t   \tcout<<\"Telefono: \"<<estudiante.telefono<<endl;\n\t   }\n\t   fread(&estudiante,sizeof(Estudiante),1,archivo);\t\n\t} while(feof(archivo)==0);\n\t\n\t\n\t\n\tfclose(archivo);\n}\n\nvoid buscar_indice(){\n\tFILE* archivo = fopen(nombre_archivo, \"rb\");\n\t\n\tint pos=0;\n\tcout<<\"Que registro desea ver: \";\n\tcin>>pos;\n\tcout<<\"------------------ \"<<pos<<\" ------------------\"<<endl;\n\tfseek ( archivo,pos * sizeof(Estudiante), SEEK_SET );\n\t\n\tEstudiante estudiante;\n\t\n    fread ( &estudiante, sizeof( Estudiante ), 1, archivo );\n\n    \tcout << \"Codigo: \" << estudiante.codigo << endl;\n        cout << \"Nombre: \" << estudiante.nombres<< endl;\n        cout << \"Apellido: \" << estudiante.apellidos << endl;\n        cout << \"Telefono: \" << estudiante.telefono << endl;\n        cout << endl;\n\t\n\tfclose(archivo);\n\n\t\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//Initilizes variables related to statistical information\nint context_switch = 14;\ndouble total_turnaround = 0.0;\ndouble total_wait = 0.0;\ndouble total_initial = 0.0;\ndouble max_turnaround = 0.0;\ndouble min_turnaround = 5000.0;\ndouble max_wait;\ndouble min_wait;\ndouble max_initial;\ndouble min_initial;\n\n\n//Creates Process class\nclass process {\nprivate:\n\tint arrival_time;\n\tint burst_time;\n\tint premp_time;\n\tint burst_left;\n\tbool been_seen;\n\tint initial_wait;\n\tint total_wait;\n\tint priority;\n\tint pid;\npublic:\n\tprocess(int burst, int time, int id, int importance);\n\tvoid set_arrival(int time);\n\tvoid set_pid(int num);\n\tint get_arrival();\n\tint get_burst();\n\tint get_priority();\n\tint get_burst_left();\n\tvoid dec_burst();\n    int get_initial_wait();\n\tint get_total_wait();\n\tvoid set_premp_time(int time);\n\tvoid add_wait(int time);\n\tbool get_seen();\n\tvoid seen(int time);\n\tint get_pid();\n};\n\nprocess::process(int burst, int time, int id, int importance)\n{\n\tpid = id;\n\tburst_time = burst;\n\tburst_left = burst;\n\tarrival_time = time;\n\tbeen_seen = false;\n\tpriority = importance;\n\tinitial_wait = 0;\n\ttotal_wait = 0;\n}\n\nvoid process::set_pid(int num)\n{\n\tpid = num;\n}\n\nbool process::get_seen()\n{\n\treturn been_seen;\n}\n\nint process::get_priority()\n{\n\treturn priority;\n}\n\nint process::get_burst()\n{\n\treturn burst_time;\n}\n\nint process::get_pid()\n{\n\treturn pid;\n}\n\nvoid process::set_arrival(int time)\n{\n\tarrival_time = time;\n}\n\nint process::get_arrival()\n{\n\treturn arrival_time;\n}\n\nint process::get_burst_left()\n{\n\treturn burst_left;\n}\n\nvoid process::dec_burst()\n{\n\tburst_left = burst_left - 1;\n}\n\nint process::get_initial_wait()\n{\n\treturn initial_wait;\n}\n\nint process::get_total_wait()\n{\n\treturn total_wait;\n}\n\nvoid process::set_premp_time(int time)\n{\n\tpremp_time = time;\n}\n\nvoid process::add_wait(int time)\n{\n\ttotal_wait = total_wait + time;\n}\n\nvoid process::seen(int time)\n{\n\tbeen_seen = true;\n\tinitial_wait = time;\n\ttotal_wait = time;\n}\n\nbool sorter(process a, process b)\n{\n\treturn a.get_burst() < b.get_burst();\n}\n\nbool sorter2(process a, process b)\n{\n\treturn a.get_priority() < b.get_priority();\n}\n\nbool sorter3(process a, process b)\n{\n\treturn a.get_arrival() < b.get_arrival();\n}\n\n//Prints statistics\nvoid statistics(int num_processes)\n{\n\tcout << \"Turnaround time: min \";\n\tprintf(\"%.3f\", min_turnaround);\n\tcout << \"ms\";\n\tcout << \"; avg \";\n\tprintf(\"%.3f\", total_turnaround/num_processes);\n\tcout << \"ms\";\n\tcout << \"; max \";\n\tprintf(\"%.3f\", max_turnaround);\n\tcout << \"ms\" << endl;\n\tcout << \"Initial wait time: min \";\n\tprintf(\"%.3f\", min_initial);\n\tcout << \"ms\";\n\tcout << \"; avg \";\n\tprintf(\"%.3f\", total_initial/num_processes);\n\tcout << \"ms\";\n\tcout << \"; max \";\n\tprintf(\"%.3f\", max_initial);\n\tcout << \"ms\" << endl;\n\tcout << \"Total wait time: min \";\n\tprintf(\"%.3f\", min_wait);\n\tcout << \"ms\";\n\tcout << \"; avg \";\n\tprintf(\"%.3f\", total_wait/num_processes);\n\tcout << \"ms\";\n\tcout << \"; max \";\n\tprintf(\"%.3f\", max_wait);\n\tcout << \"ms\" << endl;\n\ttotal_turnaround = 0.0;\n\ttotal_wait = 0.0;\n\ttotal_initial = 0.0;\n\tmax_wait = 0.0;\n        min_wait = num_processes * 5000.0;\n        max_initial = 0.0;\n\tmin_initial = num_processes * 5000.0;\n\tmax_turnaround = 0.0;\n\tmin_turnaround = 5000.0 * num_processes;\n\tcout << endl;\n}\n\n//Simulates first come first serve\nvoid first_come_first_serve(vector <process> processes, int num_processes)\n{\n\tint num_completed = 0;\n\tint clock = 0;\n\tint last_pid = 0;\n\tvector <process> queue;\n\tbool cswitch = false;\n        unsigned int index = processes.size();\n\t//fun. runs until it detects it has completed every process\n\twhile(num_completed != num_processes)\n\t{\n\t\tindex = processes.size();\n\t\tfor(unsigned int i = 0; i < index; i++)\n\t\t{\n\t\t\tif (processes[i].get_arrival() <= clock)\n\t\t\t{\n\t\t\t\tqueue.push_back(processes[i]);\n\t\t\t\tcout << \"[time \" << processes[i].get_arrival() << \"ms] Process \" << processes[i].get_pid() << \" created (requires \" << \t\t\t\t\tprocesses[i].get_burst() << \"ms CPU time)\" << endl;\n\t\t\t\tprocesses.erase(processes.begin() + i);\n\t\t\t\tindex--;\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t}\n\n\t\tif (queue.size() != 0)\n\t\t{\n\t\t\tif (cswitch)\n\t\t\t{\n\t\t\t\tcout << \"[time \" << clock - 7 << \"ms] Context switch (swapped out process \" << last_pid << \" for process \" << queue[0].get_pid() << \")\" << endl;\n\t\t\t\t\tclock = clock + 7;\n\t\t\t\t\tcswitch = false;\n\t\t\t}\n\t\t\tif (queue[0].get_seen() == false)\n\t\t\t{\n\t\t\t\t//The initials will change in non zero arrival times\n\t\t\t\tint arriv = clock - queue[0].get_arrival();\n\t\t\t\tqueue[0].seen(arriv);\n\t\t\t\ttotal_initial += arriv;\n\t\t\t\tif (arriv < min_initial)\n\t\t\t\t\tmin_initial = arriv;\n\t\t\t\tif (arriv > max_initial)\n\t\t\t\t\tmax_initial = arriv;\n\t\t\t\t//total_wait += clock;\n\t\t\t\tcout << \"[time \" << clock << \"ms] Process \" << queue[0].get_pid() << \" accessed CPU for the first time (initial wait time \" << queue[0].get_initial_wait() << \"ms)\" << endl;\n\t\t\t}\n\t\t\tqueue[0].dec_burst();\n\t\t\tif (queue[0].get_burst_left() == 0)\n\t\t\t{\n\t\t\t\tint fwait = ((clock ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"SFML/Graphics.hpp\"\n#include \"ShareTechMono-Regular.h\"\n#include <numeric>\n#include <iostream>\n#include <functional>\n#include <cmath>\n\nstd::shared_ptr<sf::Font> font;\nusing colorGenerator = std::function<sf::Color(int, int, float)>;\n\nsf::Color converteCmykToRgb(float C, float M, float Y) {\n\n    return sf::Color(255 * (1 - C), 255 * (1 - M), 255 * (1 - Y));\n}\n\nclass Slider : public sf::Drawable {\n    sf::RectangleShape borders;\n    sf::RectangleShape clickBorders;\n    sf::RectangleShape slider;\n    sf::VertexArray vertexes;\n    std::function<void(float)> onChange;\n    float latestK = 1.f;\npublic:\n    Slider() : vertexes(sf::PrimitiveType::Quads, 4) {}\n    void setBorders(const sf::Vector2f& topLeft, const sf::Vector2f& bottomRight);\n    void handleMouseHold(int x, int y);\n    inline void setOnChangeBehavior(std::function<void(float)> onChange) { this->onChange = onChange; }\n    virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const;\n};\n\nvoid Slider::handleMouseHold(int x, int y) {\n    if (!clickBorders.getGlobalBounds().contains(x, y)) return;\n\n    float newY = y;\n    if (y < borders.getPosition().y) {\n        newY = borders.getPosition().y;\n    }\n    else if (y > borders.getPosition().y + borders.getSize().y) {\n        newY = borders.getPosition().y + borders.getSize().y;\n    }\n\n    slider.setPosition(slider.getPosition().x, newY);\n\n    float k = (newY - borders.getPosition().y) / static_cast<float>(borders.getSize().y);\n    if (k != latestK) {\n        latestK = k;\n        onChange(k);\n    }\n}\n\nvoid Slider::draw(sf::RenderTarget& target, sf::RenderStates states) const {\n    target.draw(borders, states);\n    target.draw(vertexes, states);\n    target.draw(slider, states);\n}\n\nvoid Slider::setBorders(const sf::Vector2f& topLeft, const sf::Vector2f& bottomRight) {\n    vertexes[0].position = topLeft;\n    vertexes[1].position = sf::Vector2f(bottomRight.x, topLeft.y);\n    vertexes[2].position = bottomRight;\n    vertexes[3].position = sf::Vector2f(topLeft.x, bottomRight.y);\n\n    vertexes[0].color = sf::Color::Black;\n    vertexes[1].color = sf::Color::Black;\n    vertexes[2].color = sf::Color::White;\n    vertexes[3].color = sf::Color::White;\n\n    borders.setSize(sf::Vector2f(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y));\n    borders.setPosition(topLeft);\n    borders.setOutlineThickness(1);\n    borders.setOutlineColor(sf::Color::Black);\n\n    clickBorders.setSize(sf::Vector2f(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y + 30));\n    clickBorders.setPosition(topLeft.x, topLeft.y - 20);\n\n    slider.setSize(sf::Vector2f(bottomRight.x - topLeft.x + 10, 12));\n    slider.setOrigin(0, slider.getSize().y / 2);\n    slider.setPosition(borders.getPosition().x - 5, borders.getPosition().y + borders.getSize().y);\n    slider.setFillColor(sf::Color::Blue);\n\n}\n\nclass Hexagon : public sf::Drawable\n{\n\nprotected:\n    sf::Texture textureTop;\n    sf::Texture textureLeft;\n    sf::Texture textureRight;\n    sf::Sprite spriteTop;\n    sf::Sprite spriteLeft;\n    sf::Sprite spriteRight;\n    float k = 1.f;\n\n    sf::Image image;\n    sf::Vector2f left_top, right_bottom, center;\n    sf::Vector2f p[6]; // Kolejno   punkt w opisana w pliku PDF do laboratorium.\npublic:\n    void Set_Borders(sf::Vector2f _left_top, sf::Vector2f _right_bottom);\n    void Draw_Border(sf::RenderTarget& target, sf::RenderStates states, sf::String name) const;\n    void drawSprites(sf::RenderTarget& target, sf::RenderStates states) const;\n    inline void setK(float k) { this->k = k; }\n\n    Hexagon() {\n        image.create(256, 256);\n    }\n    void calcTextures(colorGenerator topGenerator, colorGenerator leftGenerator, colorGenerator rightGenerator);\n    virtual void calcTextures() = 0;\n    virtual std::string getName() const = 0;\n    virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const;\n};\n\nvoid Hexagon::draw(sf::RenderTarget& target, sf::RenderStates states) const {\n    Draw_Border(target, states, getName());\n    drawSprites(target, states);\n}\n\nvoid Hexagon::calcTextures(colorGenerator topGenerator, colorGenerator leftGenerator, colorGenerator rightGenerator)\n{\n    {\n        for (int i = 0; i < 256; i++) {\n            for (int j = 0; j < 256; j++) {\n                image.setPixel(255 - i, 255 - j, topGenerator(i, j, k));\n            }\n        }\n        textureTop.loadFromImage(image);\n        for (int i = 0; i < 256; i++) {\n            for (int j = 0; j < 256; j++) {\n                image.setPixel(255 - i, 255 - j, leftGenerator(i, j, k));\n            }\n        }\n        textureLeft.loadFromImage(image);\n        for (int i = 0; i < 256; i++) {\n            for (int j = 0; j < 256; j++) {\n                image.setPixel(255 - i, 255 - j, rightGenerator(i, j, k));\n            }\n        }\n        textureRight.loadFromImage(image);\n\n        spriteTop.setTexture(textureTop);\n        spriteLeft.setTexture(textureLeft);\n        spriteRight.setTexture(textureRight);\n    }\n}\n\nvoid Hexagon::drawSprites(sf::RenderTarget& targe",
    "/*****************************************************************************\n * Qwt Examples - Copyright (C) 2002 Uwe Rathmann\n * This file may be used under the terms of the 3-clause BSD License\n *****************************************************************************/\n\n#include \"IncrementalPlot.h\"\n\n#include <QwtPlot>\n#include <QwtPlotCurve>\n#include <QwtSymbol>\n#include <QwtScaleMap>\n#include <QwtPlotDirectPainter>\n#include <QwtPainter>\n\nnamespace\n{\n    class CurveData : public QwtArraySeriesData< QPointF >\n    {\n      public:\n        virtual QRectF boundingRect() const QWT_OVERRIDE\n        {\n            if ( cachedBoundingRect.width() < 0.0 )\n                cachedBoundingRect = qwtBoundingRect( *this );\n\n            return cachedBoundingRect;\n        }\n\n        inline void append( const QPointF& point )\n        {\n            m_samples += point;\n        }\n\n        void clear()\n        {\n            m_samples.clear();\n            m_samples.squeeze();\n            cachedBoundingRect = QRectF( 0.0, 0.0, -1.0, -1.0 );\n        }\n    };\n}\n\nIncrementalPlot::IncrementalPlot( QWidget* parent )\n    : QwtPlot( parent )\n    , m_curve( NULL )\n{\n    m_directPainter = new QwtPlotDirectPainter( this );\n\n    if ( QwtPainter::isX11GraphicsSystem() )\n    {\n#if QT_VERSION < 0x050000\n        canvas()->setAttribute( Qt::WA_PaintOutsidePaintEvent, true );\n#endif\n        canvas()->setAttribute( Qt::WA_PaintOnScreen, true );\n    }\n\n    m_curve = new QwtPlotCurve( \"Test Curve\" );\n    m_curve->setData( new CurveData() );\n    showSymbols( true );\n\n    m_curve->attach( this );\n\n    setAutoReplot( false );\n}\n\nIncrementalPlot::~IncrementalPlot()\n{\n    delete m_curve;\n}\n\nvoid IncrementalPlot::appendPoint( const QPointF& point )\n{\n    CurveData* curveData = static_cast< CurveData* >( m_curve->data() );\n    curveData->append( point );\n\n    const bool doClip = !canvas()->testAttribute( Qt::WA_PaintOnScreen );\n    if ( doClip && m_curve->symbol() )\n    {\n        /*\n           Depending on the platform setting a clip might be an important\n           performance issue. F.e. for Qt Embedded this reduces the\n           part of the backing store that has to be copied out - maybe\n           to an unaccelerated frame buffer device.\n         */\n        const QwtScaleMap xMap = canvasMap( m_curve->xAxis() );\n        const QwtScaleMap yMap = canvasMap( m_curve->yAxis() );\n\n        const QSize symbolSize = m_curve->symbol()->size();\n        QRect r( 0, 0, symbolSize.width() + 2, symbolSize.height() + 2 );\n\n        const QPointF center = QwtScaleMap::transform( xMap, yMap, point );\n        r.moveCenter( center.toPoint() );\n\n        m_directPainter->setClipRegion( r );\n    }\n\n    m_directPainter->drawSeries( m_curve,\n        curveData->size() - 1, curveData->size() - 1 );\n}\n\nvoid IncrementalPlot::clearPoints()\n{\n    CurveData* curveData = static_cast< CurveData* >( m_curve->data() );\n    curveData->clear();\n\n    replot();\n}\n\nvoid IncrementalPlot::showSymbols( bool on )\n{\n    if ( on )\n    {\n        m_curve->setStyle( QwtPlotCurve::NoCurve );\n        m_curve->setSymbol( new QwtSymbol( QwtSymbol::XCross,\n            Qt::NoBrush, QPen( Qt::white ), QSize( 4, 4 ) ) );\n    }\n    else\n    {\n        m_curve->setPen( Qt::white );\n        m_curve->setStyle( QwtPlotCurve::Dots );\n        m_curve->setSymbol( NULL );\n    }\n\n    replot();\n}\n\n#include \"moc_IncrementalPlot.cpp\"\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <time.h>\r\n\r\n#define PI 3.14159265358979323846\r\n#define MAX 1000000.0\r\n\r\ntypedef struct {\r\n    double x;\r\n    double y;\r\n} Point;\r\n\r\nPoint* generate_points_on_circle(int num_points, double radius, Point center) {\r\n    Point* points = (Point*)malloc(num_points * sizeof(Point));\r\n    double angle_step = 2 * PI / num_points;\r\n    for (int i = 0; i < num_points; i++) {\r\n        double angle = i * angle_step;\r\n        points[i].x = center.x + radius * cos(angle);\r\n        points[i].y = center.y + radius * sin(angle);\r\n    }\r\n    return points;\r\n}\r\n\r\ndouble cross_product(Point a, Point b, Point c) {\r\n    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);\r\n}\r\n\r\nint compare(const void* vp1, const void* vp2) {\r\n    Point *p1 = (Point*)vp1;\r\n    Point *p2 = (Point*)vp2;\r\n    double angle1 = atan2(p1->y, p1->x);\r\n    double angle2 = atan2(p2->y, p2->x);\r\n    if (angle1 < angle2) return -1;\r\n    if (angle1 > angle2) return 1;\r\n    return 0;\r\n}\r\n\r\ndouble min(double x, double y)\r\n{\r\n    return (x <= y) ? x : y;\r\n}\r\n\r\n// A utility function to find distance between two points in a plane\r\ndouble dist(Point p1, Point p2)\r\n{\r\n    return sqrt((p1.x - p2.x)*(p1.x - p2.x) +\r\n                (p1.y - p2.y)*(p1.y - p2.y));\r\n}\r\n\r\ndouble cost(Point points[], int i, int j, int k)\r\n{\r\n    Point p1 = points[i], p2 = points[j], p3 = points[k];\r\n    return dist(p1, p2) + dist(p2, p3) + dist(p3, p1);\r\n}\r\n\r\ndouble mTC(Point points[], int i, int j)\r\n{\r\n    if (j < i + 2)\r\n        return 0;\r\n\r\n    double res = MAX;\r\n\r\n    for (int k = i + 1; k < j; k++)\r\n        res = min(res, (mTC(points, i, k) + mTC(points, k, j) + cost(points, i, k, j)));\r\n    return res;\r\n}\r\n\r\ndouble mTCDP(Point points[], int n) {\r\n    if (n < 3)\r\n        return 0;\r\n\r\n    double table[n][n];\r\n\r\n    for (int gap = 0; gap < n; gap++) {\r\n        for (int i = 0, j = gap; j < n; i++, j++) {\r\n            if (j < i + 2)\r\n                table[i][j] = 0.0;\r\n            else {\r\n                table[i][j] = MAX;\r\n                for (int k = i + 1; k < j; k++) {\r\n                    double val = table[i][k] + table[k][j] + cost(points, i, j, k);\r\n                    if (table[i][j] > val)\r\n                        table[i][j] = val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return table[0][n - 1];\r\n}\r\n\r\nPoint* convex_hull(Point* points, int num_points, int* num_vertices) {\r\n    if (num_points < 3) {\r\n        return NULL;\r\n    }\r\n\r\n    // Sort points by polar angle with respect to the lowest point\r\n    qsort(points, num_points, sizeof(Point), compare);\r\n\r\n    // Initialize the convex hull as empty\r\n    Point* hull = (Point*)malloc(num_points * sizeof(Point));\r\n    int hull_size = 0;\r\n\r\n    // Build the convex hull using Graham scan\r\n    for (int i = 0; i < num_points; i++) {\r\n        while (hull_size >= 2 && cross_product(hull[hull_size - 2], hull[hull_size - 1], points[i]) <= 0) {\r\n            hull_size--;\r\n        }\r\n        hull[hull_size++] = points[i];\r\n    }\r\n\r\n    *num_vertices = hull_size;\r\n    return hull;\r\n}\r\n\r\nPoint* generate_convex_polygon_from_circle(int num_points, int num_vertices) {\r\n    Point center = {0.0, 0.0};\r\n    double radius = 10.0;\r\n    Point* points_on_circle = generate_points_on_circle(num_points, radius, center);\r\n    Point* selected_points = (Point*)malloc(num_vertices * sizeof(Point));\r\n    for (int i = 0; i < num_vertices; i++) {\r\n        selected_points[i] = points_on_circle[rand() % num_points];\r\n    }\r\n    int num_vertices_hull;\r\n    Point* convex_polygon = convex_hull(selected_points, num_vertices, &num_vertices_hull);\r\n    free(points_on_circle);\r\n    free(selected_points);\r\n    return convex_polygon;\r\n}\r\n\r\nvoid print_polygon(Point* polygon, int num_vertices) {\r\n    for (int i = 0; i < num_vertices; i++) {\r\n        printf(\"(%f, %f) \", polygon[i].x, polygon[i].y);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main() {\r\n    int num_polygons = 10;\r\n    int min_vertices = 3;\r\n    int max_vertices = 10;\r\n    int num_points = 100;\r\n    srand(time(NULL));\r\n\r\n    for (int i = 0; i < num_polygons; i++) {\r\n        int num_vertices = rand() % (max_vertices - min_vertices + 1) + min_vertices;\r\n        Point* convex_polygon = generate_convex_polygon_from_circle(num_points, num_vertices);\r\n        if (convex_polygon) {\r\n            printf(\"Convex Polygon %d: \", i + 1);\r\n            print_polygon(convex_polygon, num_vertices);\r\n            double min_cost_rec = mTC(convex_polygon, 0, num_vertices - 1);\r\n            double min_cost_dp = mTCDP(convex_polygon, num_vertices);\r\n            printf(\"Minimum cost for Convex Polygon %d (Recursive): %.2f\\n\", i + 1, min_cost_rec);\r\n            printf(\"Minimum cost for Convex Polygon %d (Dynamic Programming): %.2f\\n\", i + 1, min_cost_dp);\r\n\r\n            // Greedy triangulation\r\n            double greedy_cost = 0.0;\r\n            for (int j = 1; j < num_vertices - 1; j++) {\r\n                greedy_cost += dist(convex_polygon[0], convex_polygon",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"Terra.h\"\r\n\r\n\r\nHBITMAP ATerra::Img = 0;\r\n//================================================================================================================\r\n// constructor & destructor\r\n//================================================================================================================\r\nATerra::~ATerra()\r\n{\r\n}\r\n//================================================================================================================\r\nATerra::ATerra(int ceil_x, int ceil_y, EObject_Type type)\r\n\t:AGame_Object(ceil_x, ceil_y, type)\r\n{\r\n}\r\n//================================================================================================================\r\n// public section:\r\n//================================================================================================================\r\nvoid ATerra::Draw(HDC hdc, HDC hdc_2, HDC hdc_3, int x_, int y_, int width, int height, int x_texture_offset,\r\n\tint y_texture_offset)\r\n{\r\n\tdouble d_ceil_size = (double)AsSettings::Ceil_Size;\r\n\tint y_top_offset = AsSettings::Y_Game_Area_Offset;\r\n\tint x_left_offset = AsSettings::X_Game_Area_Offset;\r\n\tint y_bottom_offset = AsSettings::Y_Game_Area_Bottom_Offset;\r\n\tint x_right_offset = AsSettings::X_Game_Area_Right_Offset;\r\n\tint rx{}, ry{};\r\n\tint x_difference{}, y_difference{};\r\n\r\n\trx = x_ + (int)(Rx * d_ceil_size);\r\n\try = y_ + (int)(Ry * d_ceil_size);\r\n\r\n\tif (ry < y_top_offset)\r\n\t{\r\n\t\ty_difference = y_top_offset - ry;\r\n\t\try = y_top_offset;\r\n\t\theight -= y_difference;\r\n\t\ty_texture_offset += y_difference;\r\n\t}\r\n\r\n\tif ( (ry + height) > y_bottom_offset)\r\n\t{\r\n\t\ty_difference = (ry + height) - y_bottom_offset;\r\n\t\theight = y_difference;\r\n\t}\r\n\r\n\tif (rx < x_left_offset)\r\n\t{\r\n\t\tx_difference = x_left_offset - rx;\r\n\t\trx = x_left_offset;\r\n\t\twidth -= x_difference;\r\n\t\tx_texture_offset += x_difference;\r\n\t}\r\n\r\n\tif ((rx + width) > x_right_offset)\r\n\t{\r\n\t\tx_difference = (rx + width) - x_right_offset;\r\n\t\twidth = x_difference;\r\n\t}\r\n\r\n\tSelectObject(hdc_2, ATerra::Img);\r\n\r\n\tBitBlt(hdc, rx, ry, width, height, hdc_2, x_texture_offset, y_texture_offset, SRCCOPY);\r\n}\r\n//================================================================================================================\r\nvoid ATerra::Act()\r\n{\r\n}\r\n//================================================================================================================\r\nvoid ATerra::Create_Bitmap()\r\n{\r\n\tint ceil_size = AsSettings::Ceil_Size;\r\n\tAsFrameDc* frameDC = AsFrameDc::Get_Instance();\r\n\tHDC hdc = frameDC->Get_SecondDc();\r\n\tATerra::Img = CreateCompatibleBitmap(hdc, AsSettings::Ceil_Size, AsSettings::Ceil_Size);\r\n\tSelectObject(hdc, ATerra::Img);\r\n\r\n\tSelectObject(hdc, AsColors::Pen_PeachPuff);\r\n\tSelectObject(hdc, AsColors::Brush_PeachPuff);\r\n\tRectangle(hdc, 1, 1, AsSettings::Ceil_Size - 2, AsSettings::Ceil_Size - 2);\r\n\r\n\r\n\tSelectObject(hdc, AsColors::Pen_White);\r\n\tMoveToEx(hdc, 2, ceil_size - 2, 0);\r\n\tLineTo(hdc, 2, 2);\r\n\tLineTo(hdc, ceil_size - 2, 2);\r\n\tSelectObject(hdc, AsColors::Pen_DarkRed);\r\n\tLineTo(hdc, ceil_size - 2, ceil_size - 2);\r\n\tLineTo(hdc, 2, ceil_size - 2);\r\n\r\n\r\n\r\n}\r\n//================================================================================================================",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nconst int MAX_N = 1000000;\n// MAX_N = 100\ntemplate <typename T>\nvoid print(const vector<T> &vec)\n{\n    for (auto &element : vec)\n    {\n        cout << element << \" \";\n    }\n    cout << endl;\n}\n\nvector<int> sieve_of_eratosthenes(int limit)\n{\n    // Initialize a boolean array \"prime[0..n]\" and fill all entries it as true.\n    // A value in prime[i] will finally be false if i is Not a prime, else true.\n    vector<bool> prime(limit, true);\n    for (int p = 2; p * p <= limit; p++)\n    {\n        // If prime[p] is not changed, then it is a prime\n        if (prime[p])\n        {\n            // Updating all multiples of p\n            for (int i = p * p; i < (limit + 1); i = i + p)\n            {\n                prime[i] = false;\n            }\n        }\n    }\n    // Collecting all prime numbers\n    vector<int> prime_numbers;\n    for (int p = 2; p < limit; p++)\n    {\n        if (prime[p])\n            prime_numbers.push_back(p);\n    }\n    return prime_numbers;\n}\n\nbool isCircularPrime(int n, const set<int> &primes_set)\n{\n    string s = to_string(n);\n    int n_rolls = s.length() - 1;\n\n    for (int i = 0; i < n_rolls; i++)\n    {\n        s += s[0];           // Append the first character to the end\n        s.erase(s.begin());  // Erase the first character\n        int new_n = stoi(s); // convert new string to int\n        if (primes_set.find(new_n) == primes_set.end())\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char const *argv[])\n{\n    auto primes = sieve_of_eratosthenes(MAX_N);\n    // print('primes = ', primes)\n    print(primes); // print all elements of primes\n\n    // primes_set = set(primes)\n    set<int> primes_set;\n    for (const auto &val : primes)\n    {\n        primes_set.insert(val);\n    }\n\n    int res = 0;\n    for (int n : primes)\n    {\n        if (isCircularPrime(n, primes_set))\n        {\n            res++;\n            cout << \"n=\" << n << \", res=\" << res << endl;\n        }\n    }\n\n    cout << \"DONE\" << endl;\n    cout << \"Total Circular Primes: \" << res << endl;\n\n    return 0;\n}",
    "/*\r\n     Develop a calculator program that performs basic arithmetic\r\n     operations such as addition, subtraction, multiplication, and\r\n     division. Allow the user to input two numbers and choose an\r\n     operation to perform.\r\n*/\r\n\r\n#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\n\r\nint calculator(int n1, int n2, char op) {\r\n     int res = INT_MIN;\r\n     switch (op)\r\n     {\r\n     case '+':\r\n          res = n1 + n2;\r\n          break;\r\n     case '-':\r\n          res = n1-+ n2;\r\n          break;\r\n     case '*':\r\n          res = n1 * n2;\r\n          break;\r\n     case '/':\r\n          res = n1 / n2;\r\n          break;\r\n     \r\n     default:\r\n          cout << \"Wrong Operation!\" << endl;\r\n          break;\r\n     }\r\n     return res;\r\n}\r\n\r\nint main() {\r\n     int n1, n2;\r\n     char operation;\r\n     cout << \"Enter Number 1: \"; cin >> n1;\r\n     cout << \"Enter Number 2: \"; cin >> n2;\r\n     cout << \"Enter Operation you wanna perform: \"; cin >> operation;\r\n     int res = calculator(n1, n2, operation);\r\n     cout << n1 << operation << n2 << \": \" << res;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <YaScheduleApp.h>\n\n\nusing json = nlohmann::json;\n\n\nYaScheduleApp::YaScheduleApp(std::string openWeatherApiKey, std::string yaScheduleApiKey,\n\tstd::string cityFrom, std::string cityTo) {\n\tthis->openWeatherClient = new httplib::Client(\"http://api.openweathermap.org\");\n\tthis->yandexScheduleClient = new httplib::Client(\"http://api.rasp.yandex.net\");\n\tthis->cityFrom = cityFrom;\n\tthis->cityTo = cityTo;\n\tthis->openWeatherApiKey = openWeatherApiKey;\n\tthis->yaScheduleApiKey = yaScheduleApiKey;\n}\n\n\njson YaScheduleApp::makeRequest(httplib::Client* client, std::string request) {\n\tif (auto response = client->Get(request)) {\n\t\tif (response->status == 200) {\n\t\t\treturn json::parse(response->body);\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Bad request \" << response->status << std::endl;\n\t\t}\n\t}\n\treturn *new json;\n}\n\n\nstd::vector <std::string> YaScheduleApp::getLatLon(std::string city) {\n\tstd::string request = this->openWeatherRequest;\n\trequest += \"q=\" + city;\n\trequest += \"&appid=\" + this->openWeatherApiKey;\n\tjson result = this->makeRequest(this->openWeatherClient, request);\n\tstd::vector <std::string> latLon = { to_string(result[\"coord\"][\"lon\"]), to_string(result[\"coord\"][\"lat\"]) };\n\treturn latLon;\n}\n\n\nstd::string YaScheduleApp::getCityCode(std::vector <std::string> latLon) {\n\tstd::string request = this->yaCityCodeRequest;\n\trequest += \"apikey=\" + this->yaScheduleApiKey;\n\trequest += \"&lat=\" + latLon[1];\n\trequest += \"&lng=\" + latLon[0];\n\tstd::string code = this->makeRequest(this->yandexScheduleClient, request)[\"code\"].get<std::string>();\n\treturn code;\n}\n\n\njson YaScheduleApp::getScheduleBetweenCities() {\n\tstd::string request = this->yaScheduleRequest;\n\trequest += \"apikey=\" + this->yaScheduleApiKey;\n\trequest += \"&from=\" + this->getCityCode(this->getLatLon(this->cityFrom));\n\trequest += \"&to=\" + this->getCityCode(this->getLatLon(this->cityTo));\n\treturn this->makeRequest(this->yandexScheduleClient, request);\n}",
    "#include<iostream>\r\n#include<fstream>\r\n#include<windows.h>\r\n#include<sstream>\r\nusing namespace std;\r\nclass Hostel{\r\n\tprivate:\r\n\t\tstring Name;\r\n\t\tint Rent,Bed;\r\n\tpublic:\r\n\t//constructor having same name as that of class\r\n\tHostel(string name,int rent,int bed)\r\n\t{\r\n\t\tName=name;\r\n\t\tRent=rent;\r\n\t\tBed=bed;\r\n\t}\r\n\tstring getName()\r\n\t{\r\n\t\treturn Name;\r\n\t}\r\n\tint getRent()\r\n\t{\r\n\t\treturn Rent;\r\n\t}\r\n\tint getBed()\r\n\t{\r\n\t\treturn Bed;\r\n\t}\r\n\treserve(){\r\n\t\tifstream in(\"D:/Hostel.txt\");\r\n\t\tofstream out(\"D:/Hostel Temp.txt\");\r\n\t\tstring line;\r\n\t\twhile(getline(in,line)){\r\n\t\t\tint pos=line.find(\"Sushant Hostel\");\r\n\t\t\tif(pos != string::npos)\r\n\t\t\t{\r\n\t\t\t\tint bed=Bed-1;\r\n\t\t\t\tBed =bed;\r\n\t\t\t\tstringstream ss;\r\n\t\t\t\tss<<bed;\r\n\t\t\t\tstring strBed=ss.str();\r\n\t\t\t\t\r\n\t\t\t\tint bedPos=line.find_last_of(':');\r\n\t\t\t\tline.replace(bedPos+1,string::npos,strBed);\r\n\t\t\t}\r\n\t\t\tout<<line<<endl;\r\n\t\t}\r\n\t\tout.close();\r\n\t\tin.close();\r\n\t\tremove(\"D:/Hostel.txt\");\r\n\t\trename(\"D:/Hostel Temp.txt\",\"D:/Hostel.txt\");\r\n\t\tcout<<\"\\tBed Reserved Successfully\"<<endl;\r\n\t}\r\n};\r\n\r\nclass Student{\r\n\tprivate:\r\n\t\tstring Name,RollNo,Address;\r\n\tpublic:\r\n\t\tStudent():Name(\"\"),RollNo(\"\"),Address(\"\"){\r\n\t\t\t\r\n\t\t}\r\n\t\tsetName(string name){\r\n\t\t\tName=name;\r\n\t\t}\r\n\t\tsetRollNo(string rollno)\r\n\t\t{\r\n\t\t\tRollNo=rollno;\r\n\t\t}\r\n\t\tsetAddress(string address)\r\n\t\t{\r\n\t\t\tAddress=address;\r\n\t\t}\r\n\t\tstring getName()\r\n\t\t{\r\n\t\t\treturn Name;\r\n\t\t}\r\n\t\tstring getRollNo()\r\n\t\t{\r\n\t\t\treturn RollNo;\r\n\t\t}\r\n\t\tstring getAddress()\r\n\t\t{\r\n\t\t\treturn Address;\r\n\t\t}\r\n};\r\nint main()\r\n{\r\n\tHostel h(\"Sushant Hostel\",5000,2);\r\n\tofstream out(\"D:/Hostel.txt\");\r\n\tout<<\"\\t\"<<h.getName()<<\":\"<<h.getRent()<<\":\"<<h.getBed()<<endl<<endl;\r\n\tcout<<\"Hostel Data Saved\"<<endl;\r\n\tout.close();\r\n\tStudent s;\r\n\tbool exit=false;\r\n\twhile(!exit)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tint val;\r\n\t\tcout<<\"\\tWelcome To Hostel Accommodation System\"<<endl;\r\n\t\tcout<<\"\\t***************************************\"<<endl;\r\n\t\tcout<<\"\\t1.Reserve A Bed\"<<endl;\r\n\t\tcout<<\"\\t2.Exit\"<<endl;\r\n\t\tcout<<\"\\tEnter Choice\";\r\n\t\tcin>>val;\r\n\t\tif(val==1){\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tstring name,rollno,address;\r\n\t\t\tcout<<\"\\tEnter Name of Student\";\r\n\t\t\tcin>>name;\r\n\t\t\ts.setName(name);\r\n\t\t\tcout<<\"\\tEnter RollNo of Student\";\r\n\t\t\tcin>>rollno;\r\n\t\t\ts.setRollNo(rollno);\r\n\t\t\tcout<<\"\\tEnter Address Student\";\r\n\t\t\tcin>>address;\r\n\t\t\ts.setAddress(address);\r\n\t\t\tif(h.getBed()>0){\r\n\t\t\t\th.reserve();\r\n\t\t\t}\r\n\t\t\telse if(h.getBed()==0){\r\n\t\t\t\tcout<<\"\\tSorry No bed Avaliable\"<<endl;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tofstream outFile(\"D:/student.txt\",ios::app);\r\n\t\t\toutFile<<\"\\t\"<<s.getName()<<\":\"<<s.getRollNo()<<\":\"<<s.getAddress()<<endl<<endl;\r\n\t\t\tSleep(5000);\r\n\t\t}\r\n\t\telse if(val==2){\r\n\t\t\tsystem(\"cls\");\r\n\t\t\texit=true;\r\n\t\t\tcout<<\"Good Luck\"<<endl;\r\n\t\t\tSleep(3000);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "#include \"Server.h\"\r\n\r\n\r\n\r\nvoid Bulid_server::get_command(){\r\n    server = new QTcpServer;\r\n    Start = true;\r\n    while(!end){\r\n        switch(command){\r\n        case -1:\r\n            QThread::msleep(10);\r\n            break;\r\n        case 0:\r\n            socket->abort();\r\n            server->close();\r\n            command = -1;\r\n            emit back_value(0);\r\n            break;\r\n        case 1:\r\n            qDebug() << \"server_ip: \" << server_ip << \"port: \" << port;\r\n            server->listen(QHostAddress(server_ip),quint16(port));\r\n            emit back_value(1);\r\n            command = 2;\r\n            break;\r\n        case 2:\r\n            if (server->waitForNewConnection()){\r\n                socket = server->nextPendingConnection();\r\n                client_address = socket->peerAddress().toString();\r\n                qDebug() << \"New connection from\" << client_address;\r\n                emit back_value(2);\r\n                command = 3;\r\n            }\r\n            else{QThread::msleep(10);}\r\n            break;\r\n        case 3:\r\n            if (check_link()){\r\n                socket->waitForReadyRead(3);\r\n                data.append(socket->readAll());\r\n                if (data != \"\"){\r\n                    //qDebug() << data;\r\n                    QStringList datalist = data.split(\"|\");\r\n                    file_path = datalist[0];\r\n                    index = datalist[1].toInt();\r\n                    sleep_time = datalist[2].toDouble();\r\n                    emit back_value(3);\r\n                    //qDebug () << \"file_path:\" << file_path << \"play:\" << play << \"play_time:\" << play_time;\r\n                }\r\n                data.clear();\r\n            }\r\n            else{QThread::msleep(1);}\r\n            break;\r\n        }\r\n    }\r\n    Start = false;\r\n}\r\n\r\n\r\nbool Bulid_server::check_link(){\r\n    socket->waitForConnected();\r\n    if (socket->state() == QAbstractSocket::ConnectedState){\r\n        return true;\r\n    }\r\n    else{\r\n        qDebug() << \"disconnection from\" << client_address;\r\n        emit back_value(-1);\r\n        command = -1;\r\n        socket->abort();\r\n        server->close();\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nBulid_server::Bulid_server(QObject* parent) : QThread(parent)\r\n{\r\n    command = -1;\r\n    end = false;\r\n    Start = true;\r\n    client_address = \"no\";\r\n\r\n    file_path = \"no\";\r\n    index = 0;\r\n    sleep_time = 0;\r\n}\r\n",
    "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nusing namespace std;\n\n// Number of processes\n#define N 5\n\n// Number of resources\n#define M 3\n\n// Function to check if the system is in a safe state\nbool isSafe(int allocation[N][M], int max[N][M], int need[N][M], int available[M]) {\n    int work[M], finish[N];\n\n    // Initialize work and finish arrays\n    for (int i = 0; i < M; i++)\n        work[i] = available[i];\n    for (int i = 0; i < N; i++)\n        finish[i] = 0;\n\n    // Find an index i such that both conditions are satisfied\n    int count = 0;\n    while (count < N) {\n        bool found = false;\n        for (int i = 0; i < N; i++) {\n            if (finish[i] == 0) {\n                int j;\n                found = true;\n                for (j = 0; j < M; j++)\n                    if (need[i][j] > work[j])\n                        break;\n                if (j == M) {\n                    for (j = 0; j < M; j++)\n                        work[j] += allocation[i][j];\n                    finish[i] = 1;\n                    count++;\n                }\n            }\n        }\n\n        // If no process can be executed, the system is in an unsafe state\n        if (!found)\n            return false;\n    }\n\n    // If all processes have been executed, the system is in a safe state\n    return true;\n}\n\nint main() {\n    int allocation[N][M] = { { 0, 1, 0 }, { 2, 0, 0 }, { 3, 0, 2 }, { 2, 1, 1 }, { 0, 0, 2 } };\n    int max[N][M] = { { 0, 2, 2 }, { 3, 0, 2 }, { 4, 0, 3 }, { 3, 2, 2 }, { 2, 0, 2 } };\n    int need[N][M];\n    int available[M] = { 2, 2, 2 };\n\n    // Calculate the need matrix\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            need[i][j] = max[i][j] - allocation[i][j];\n\n    // Check if the system is in a safe state\n    if (isSafe(allocation, max, need, available))\n        cout << \"System is in safe state.\\n\";\n    else\n        cout << \"System is in unsafe state.\\n\";\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <vector>\r\n#include <iostream>\r\n#include <chrono>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cmath>\r\n#include <random>\r\n#include <array>\r\n#include <omp.h>\r\n\r\nusing namespace std;\r\nusing namespace std::chrono;\r\n\r\nstruct MnistData {\r\n    vector<float> pixels;\r\n    int label;\r\n};\r\n\r\nfloat sigmoid(float x) {\r\n    return 1.0f / (1.0f + exp(-x));\r\n}\r\n\r\nvector<float> softmax(const vector<float>& input) {\r\n    vector<float> expValues(input.size());\r\n    float sumExpValues = 0.0f;\r\n\r\n    for (size_t i = 0; i < input.size(); i++) {\r\n        expValues[i] = exp(input[i]);\r\n        sumExpValues += expValues[i];\r\n    }\r\n\r\n    for (size_t i = 0; i < input.size(); i++) {\r\n        expValues[i] /= sumExpValues;\r\n    }\r\n\r\n    return expValues;\r\n}\r\n\r\nclass SimpleANN {\r\npublic:\r\n    SimpleANN() {}\r\n    float performance;\r\n    SimpleANN(int inputSize, int hiddenSize, int outputSize,float mean, float std_dev)\r\n        : inputSize(inputSize), hiddenSize(hiddenSize), outputSize(outputSize) ,mean(mean),std_dev(std_dev){\r\n        // Initialize weights and biases (randomly or with custom values)\r\n        weights1.resize(inputSize * hiddenSize);\r\n        biases1.resize(hiddenSize);\r\n        weights2.resize(hiddenSize * outputSize);\r\n        biases2.resize(outputSize);\r\n\r\n        // Example: Set weights and biases to 0.5f\r\n        random_device rd;\r\n        default_random_engine generator(rd());\r\n        normal_distribution<float> distribution(mean, std_dev);\r\n\r\n        for (int i = 0; i < inputSize * hiddenSize; i++)\r\n            weights1[i] = distribution(generator);\r\n\r\n        for (int i = 0; i < hiddenSize; i++)\r\n            biases1[i] = distribution(generator);\r\n\r\n        for (int i = 0; i < hiddenSize * outputSize; i++)\r\n            weights2[i] = distribution(generator);\r\n\r\n        for (int i = 0; i < outputSize; i++)\r\n            biases2[i] = distribution(generator);\r\n    }\r\n\r\n    void add_gaussian()\r\n    {\r\n        random_device rd;\r\n        default_random_engine generator(rd());\r\n        normal_distribution<float> distribution(mean, std_dev);\r\n\r\n        for (int i = 0; i < inputSize * hiddenSize; i++)\r\n            weights1[i] += distribution(generator);\r\n\r\n        for (int i = 0; i < hiddenSize; i++)\r\n            biases1[i] += distribution(generator);\r\n\r\n        for (int i = 0; i < hiddenSize * outputSize; i++)\r\n            weights2[i] += distribution(generator);\r\n\r\n        for (int i = 0; i < outputSize; i++)\r\n            biases2[i] += distribution(generator);\r\n    }\r\n    void sub_gaussian()\r\n    {\r\n        random_device rd;\r\n        default_random_engine generator(rd());\r\n        normal_distribution<float> distribution(mean, std_dev);\r\n\r\n        for (int i = 0; i < inputSize * hiddenSize; i++) {\r\n            weights1[i] -= distribution(generator);\r\n            weights1[i] *= distribution(generator);\r\n        }\r\n\r\n        for (int i = 0; i < hiddenSize; i++)\r\n            biases1[i] -= distribution(generator);\r\n\r\n        for (int i = 0; i < hiddenSize * outputSize; i++) {\r\n            weights2[i] -= distribution(generator);\r\n            weights2[i] *= distribution(generator);\r\n        }\r\n\r\n        for (int i = 0; i < outputSize; i++)\r\n            biases2[i] -= distribution(generator);\r\n    }\r\n\r\n    void forwardPropagation(const MnistData& data, vector<float>& output) {\r\n        // Layer 1\r\n        vector<float> layer1(hiddenSize);\r\n        for (int i = 0; i < hiddenSize; i++) {\r\n            float value = biases1[i];\r\n            for (int j = 0; j < inputSize; j++) {\r\n                value += weights1[i * inputSize + j] * data.pixels[j];\r\n            }\r\n            layer1[i] = sigmoid(value);\r\n        }\r\n\r\n        // Layer 2\r\n        output.resize(outputSize);\r\n        for (int i = 0; i < outputSize; i++) {\r\n            float value = biases2[i];\r\n            for (int j = 0; j < hiddenSize; j++) {\r\n                value += weights2[i * hiddenSize + j] * layer1[j];\r\n            }\r\n            output[i] = value;\r\n        }\r\n\r\n        // Softmax\r\n        output = softmax(output);\r\n    }\r\n\r\n    float calculateAccuracy(const vector<MnistData>& dataSet) {\r\n        int correctCount = 0;\r\n        for (const auto& data : dataSet) {\r\n            vector<float> output(outputSize);\r\n            forwardPropagation(data, output);\r\n            int predictedLabel = distance(output.begin(), max_element(output.begin(), output.end()));\r\n            if (predictedLabel == data.label) {\r\n                correctCount++;\r\n            }\r\n        }\r\n        performance = static_cast<float>(correctCount) / dataSet.size();\r\n        return static_cast<float>(correctCount) / dataSet.size();\r\n    }\r\n\r\npublic:\r\n    int inputSize, hiddenSize, outputSize,mean,std_dev;\r\n    vector<float> weights1, biases1, weights2, biases2;\r\n};\r\n\r\nbool compareByPerformance(const SimpleANN& obj1, const SimpleANN& obj2) {\r\n    return obj1.performance > obj2.performance;\r\n}\r\n\r\nint main() {\r\n\r\n    const int ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nclass Cipher {\r\n    private:\r\n        string str; // ==== original string ==== //\r\n        int sh; // ==== shifting value ==== //\r\n\r\n    public:\r\n        Cipher() {};\r\n        Cipher(string str, int sh) {\r\n            this->str = str; \r\n            this->sh = sh; \r\n        };\r\n\r\n        // ==== read input ==== //\r\n        friend istream& operator>>(istream& in, Cipher& c) {\r\n            cout << \"Enter your string: \";\r\n            getline(in, c.str);\r\n            cout << \"Enter your shift: \";\r\n            in >> c.sh;\r\n            return in;\r\n        }\r\n\r\n        // ==== caesar encryption ==== //\r\n        void transform() {\r\n            string res = \"\";\r\n            for (auto ch : this->str) {\r\n                if (isupper(ch))\r\n                    res += (ch + this->sh - 'A' + 26) % 26 + 'A';\r\n                else if (islower(ch))\r\n                    res += (ch + this->sh - 'a' + 26) % 26 + 'a';\r\n                else\r\n                    res += ch;\r\n            }\r\n            this->str = res;\r\n        }\r\n\r\n        // ==== print ==== //\r\n        friend ostream& operator<<(ostream& out, Cipher& c) {\r\n            out << \"Your encoded string is: \";\r\n            out << c.str;\r\n            return out;\r\n        }\r\n};\r\n\r\nint main() {\r\n    Cipher c;\r\n    cin >> c;\r\n    c.transform();\r\n    cout << c << endl;\r\n}\r\n",
    "/* Copyright (c) 2021 OceanBase and/or its affiliates. All rights reserved.\nminiob is licensed under Mulan PSL v2.\nYou can use this software according to the terms and conditions of the Mulan PSL v2.\nYou may obtain a copy of Mulan PSL v2 at:\n         http://license.coscl.org.cn/MulanPSL2\nTHIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND,\nEITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\nMERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\nSee the Mulan PSL v2 for more details. */\n\n//\n// Created by Wangyunlai on 2023/06/16.\n//\n\n#include \"gtest/gtest.h\"\n\n#include \"net/ring_buffer.h\"\n\nTEST(ring_buffer, test_init)\n{\n  const int buf_size = 10;\n  RingBuffer buffer(buf_size);\n  EXPECT_EQ(buffer.capacity(), buf_size);\n  EXPECT_EQ(buffer.remain(), buf_size);\n  EXPECT_EQ(buffer.size(), 0);\n  EXPECT_EQ(buffer.remain(), 10);\n}\n\nTEST(ring_buffer, test_write)\n{\n  const int buf_size = 25;\n  RingBuffer buffer(buf_size);\n\n  const char *data = \"0123456789\";\n  int32_t size = strlen(data);\n  int32_t write_size = 0;\n  EXPECT_EQ(buffer.write(data, size, write_size), RC::SUCCESS);\n  EXPECT_EQ(write_size, size);\n  EXPECT_EQ(buffer.size(), size);\n  EXPECT_EQ(buffer.remain(), buf_size - size);\n\n  EXPECT_EQ(buffer.write(data, size, write_size), RC::SUCCESS);\n  EXPECT_EQ(write_size, size);\n  EXPECT_EQ(buffer.size(), size * 2);\n  EXPECT_EQ(buffer.remain(), buf_size - size * 2);\n\n  EXPECT_EQ(buffer.write(data, size, write_size), RC::SUCCESS);\n  EXPECT_EQ(write_size, 5);\n  EXPECT_EQ(buffer.size(), buffer.capacity());\n  EXPECT_EQ(buffer.remain(), 0);\n}\n\nTEST(ring_buffer, test_read)\n{\n  const int buf_size = 100;\n  RingBuffer buffer(buf_size);\n\n  const char *data = \"0123456789\";\n  int32_t size = strlen(data);\n  int32_t write_size = 0;\n  EXPECT_EQ(buffer.write(data, size, write_size), RC::SUCCESS);\n  EXPECT_EQ(write_size, size);\n  EXPECT_EQ(buffer.size(), size);\n  EXPECT_EQ(buffer.remain(), buf_size - size);\n\n  char read_buf[buf_size];\n  int32_t read_size = 0;\n  const int32_t test_read_size = 5;\n  EXPECT_EQ(buffer.read(read_buf, test_read_size, read_size), RC::SUCCESS);\n  EXPECT_EQ(read_size, test_read_size);\n  EXPECT_EQ(buffer.size(), test_read_size);\n  EXPECT_EQ(buffer.remain(), buf_size - test_read_size);\n\n  EXPECT_EQ(buffer.read(read_buf, test_read_size, read_size), RC::SUCCESS);\n  EXPECT_EQ(read_size, test_read_size);\n  EXPECT_EQ(buffer.size(), 0);\n  EXPECT_EQ(buffer.remain(), buf_size);\n\n  EXPECT_EQ(buffer.read(read_buf, test_read_size, read_size), RC::SUCCESS);\n  EXPECT_EQ(read_size, 0);\n  EXPECT_EQ(buffer.size(), 0);\n  EXPECT_EQ(buffer.remain(), buf_size);\n}\n\nTEST(ring_buffer, test_buffer)\n{\n  const int buf_size = 15;\n  RingBuffer buffer(buf_size);\n\n  const char *data = \"0123456789\";\n  int32_t size = strlen(data);\n  int32_t write_size = 0;\n  EXPECT_EQ(buffer.write(data, size, write_size), RC::SUCCESS);\n  EXPECT_EQ(write_size, size);\n  EXPECT_EQ(buffer.size(), size);\n  EXPECT_EQ(buffer.remain(), buf_size - size);\n\n  const char *tmp_buffer = nullptr;\n  int32_t buffer_size = 0;\n  EXPECT_EQ(buffer.buffer(tmp_buffer, buffer_size), RC::SUCCESS);\n  EXPECT_EQ(buffer_size, size);\n  EXPECT_EQ(buffer.forward(buffer_size), RC::SUCCESS);\n\n  EXPECT_EQ(buffer.buffer(tmp_buffer, buffer_size), RC::SUCCESS);\n  EXPECT_EQ(buffer_size, 0);\n\n  EXPECT_EQ(buffer.write(data, size, write_size), RC::SUCCESS);\n  EXPECT_EQ(write_size, size);\n\n  EXPECT_EQ(buffer.buffer(tmp_buffer, buffer_size), RC::SUCCESS);\n  EXPECT_LT(buffer_size, size);\n  EXPECT_EQ(buffer.forward(buffer_size), RC::SUCCESS);\n\n  EXPECT_EQ(buffer.buffer(tmp_buffer, buffer_size), RC::SUCCESS);\n  EXPECT_LT(buffer_size, size);\n  EXPECT_EQ(buffer.forward(buffer_size), RC::SUCCESS);\n}\n\nint main(int argc, char **argv)\n{\n  // \u5206\u6790gtest\u7a0b\u5e8f\u7684\u547d\u4ee4\u884c\u53c2\u6570\n  testing::InitGoogleTest(&argc, argv);\n\n  // \u8c03\u7528RUN_ALL_TESTS()\u8fd0\u884c\u6240\u6709\u6d4b\u8bd5\u7528\u4f8b\n  // main\u51fd\u6570\u8fd4\u56deRUN_ALL_TESTS()\u7684\u8fd0\u884c\u7ed3\u679c\n  return RUN_ALL_TESTS();\n}",
    "#include \"constant.h\"\n#include \"Robot.h\"\n#include \"Boat.h\"\n#include \"Berth.h\"\n#include \"utils.h\"\n#include \"TaskAssigner.h\"\n#include <algorithm>\n\nusing namespace std;\n\nchar grid[N][N];\nint grid_cost[4][N][N];\nint gds[N][N][2]; // init will be 0, goods data, x, y, [0]: money, [1]: left_frame\nint taskIds_map[N][N];\nint connectField[N][N];\nint ocean_connectField[N][N];\nint berth_dir_map[max_berth_num][N][N]; // init land dir of all point to specific berth\nint berth_dis_map[max_berth_num][N][N]; // init land dis of all point to specific berth\nint berth_ocean_dis_map[max_berth_num][N][N]; // init land dis of all point to specific berth\nint T_ocean_dis_map[max_T_num][N][N]; // init land dis of all point to specific berth\nint P_to_closest_berht[N][N]; // \u627e\u51fa\u5730\u56fe\u4e0a\u7684\u6bcf\u4e2a\u70b9\u79bb\u7684\u6700\u8fd1\u7684\u6e2f\u53e3\nbool boat_dir_can_go_map[4][N][N];\nGood* goods[N][N]; // \u5b58\u50a8\u6bcf\u4e2a\u5546\u54c1\u7684\u4fe1\u606f\n\nvector<Robot> robot(max_robot_num);\nvector<Berth> berth(max_berth_num);\nvector<Boat> boat(max_boat_num);\n\nvector<Point> robot_purchase_point;\nvector<Point> boat_purchase_point;\nvector<Point> delivery_point; // v point\nvoid ProcessMap()\n{\n    for(int i = 0; i < N; i ++){\n        for(int j = 0; j < N; j ++){\n            if(grid[i][j] == 'R')\n                robot_purchase_point.push_back({i, j});\n            else if(grid[i][j] == 'S')\n                boat_purchase_point.push_back({i, j});\n            else if(grid[i][j] == 'T')\n                delivery_point.push_back({i, j});\n        }\n    }\n}\n\n\nvoid Init()\n{\n    for(int i = 0; i < N; i ++){\n        scanf(\"%s\", grid[i]);\n    }\n    ProcessMap();\n    scanf(\"%d\", &berth_num);\n    for(int i = 0; i < berth_num; i ++)\n    {\n        int id;\n        scanf(\"%d\", &berth[i].id);\n        scanf(\"%d%d%d\", &berth[i].x, &berth[i].y, &berth[i].loading_speed);\n        berth[i].initXY(grid);\n    }\n\n    scanf(\"%d\", &Boat::max_capacity);\n    fprintf(stderr, \"max_capacity = %d\\n\", Boat::max_capacity);\n\n    for(int i=0; i<N; i++) fill(P_to_closest_berht[i], P_to_closest_berht[i]+N, -1);\n\n    initGridCost(grid, grid_cost);\n\n    initBerthDirAndDisMap(berth_dir_map, berth_dis_map, grid, berth);\n\n    initOceanBerthDisMap(berth_ocean_dis_map, grid, berth);\n\n    initOceanTDisMap(T_ocean_dis_map, grid, delivery_point);\n\n    connectFieldSplit(grid, connectField);\n\n    ocean_connectFieldSplit(grid, ocean_connectField);\n    \n    intiBoatDirCanGoMap(grid, boat_dir_can_go_map);\n\n    for(int i = 0; i < berth_num; i ++)\n    {\n        berth[i].setDisToNearestT(delivery_point);\n        fprintf(stderr, \"berth[%d].disToNearestTId = %d with dis = %d\\n\", i, berth[i].nearestTid, berth[i].disToNearestT);\n        fprintf(stderr, \"avg %d points bind to this berht with abg dis %.3f\\n\", berth[i].total_p_bind_berth, berth[i].avg_dis_to_pull);\n    }\n\n    // if(berth[0].nearestTid == 0 && berth[0].disToNearestT == 88) real_max_robot_num = 17;\n    if(berth[0].nearestTid == 0 && berth[0].disToNearestT == 806) {\n        map_flag = 1;\n        real_max_robot_num = 11;\n        real_max_boat_num = 2;\n    }\n    else if(berth[0].nearestTid == 0 && berth[0].disToNearestT == 466){ \n        map_flag = 2;\n        real_max_boat_num = 1;\n        real_max_robot_num = 15;\n    }\n    else {\n        map_flag = 3;\n        real_max_boat_num = 1;\n        real_max_robot_num = 18;\n    }\n    \n\n    #ifdef SEE_MAP\n    fprintf(stderr, \"ocean connect field data:\\n\");\n    for (int i = 0; i < N; i++) {\n       for (int j = 0; j < N; j++)\n       {\n           fprintf(stderr, \"%d\", ocean_connectField[i][j]);\n       }\n       fprintf(stderr, \"\\n\");\n    }\n    #endif\n    #ifdef SEE_MAP\n    fprintf(stderr, \"T dis data:\\n\");\n    for (int i = 0; i < N; i++) {\n       for (int j = 0; j < N; j++)\n       {\n           fprintf(stderr, \"%d\", T_ocean_dis_map[0][i][j]);\n       }\n       fprintf(stderr, \"\\n\");\n    }\n    #endif\n    #ifdef SEE_MAP\n        fprintf(stderr, \"origianl map:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++)\n            {\n                fprintf(stderr, \"%c\", grid[i][j]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n    #endif\n\n    // int i=0;\n    // while(i++<5555) rand();\n    char okk[100];\n    scanf(\"%s\", okk);\n\n    printf(\"OK\\n\");\n    fflush(stdout);\n}\n\n\nvoid Input()\n{\n    scanf(\"%d\", &money);\n\n    // before come into new frame. minus 1 from good life\n    for(int i=0; i<N; i++) {\n        fill(taskIds_map[i], taskIds_map[i] + N, -1);\n        for(int j=0; j<N; j++) {\n            gds[i][j][1]--; // min is -15000, no overflow \n        }\n    }\n\n    scanf(\"%d\", &goods_num);\n    for(int i = 0; i < goods_num; i ++)\n    {\n        int x, y, val;\n        scanf(\"%d%d%d\", &x, &y, &val);\n        if(val <= 0) {\n            gds[x][y][1] = 0;\n            --total_del_goods_num; // \u5305\u62ec\u4e86\u673a\u5668\u4eba\u62ff\u7684\u548c\u8d85\u65f6\u6d88\u5931\u7684\n            if(goods[x][y] != nullptr) goods[x][y]->free_m();\n            goods[x][y] = nullptr;\n            if(P_to_closest_berht[x][y] != -1) --berth[P_to_closest_berht[x][y]].nearHaveGoodsNum;\n        } else {\n            gds[x][y][0] = val;\n            gds[x][y][1] = 1000;\n            ",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <algorithm>\r\n\r\n#define INFINITY 100000\r\nint V, E;\r\n\r\n// Structure for vertex\r\ntypedef struct\r\n{\r\n    int label;\r\n    bool visited;\r\n\r\n} Vertex;\r\n\r\n// Structure for directed edge from u to v\r\ntypedef struct\r\n{\r\n    int u;\r\n    int v;\r\n\r\n} Edge;\r\n\r\n// Printing Shortest Path Length\r\nvoid printShortestPathLength(int *path_length)\r\n{\r\n    printf(\"\\nVERTEX \\tSHORTEST PATH LENGTH \\n\");\r\n    int i;\r\n    for (i = 0; i < V; i++)\r\n    {\r\n        printf(\"%d \\t\", i);\r\n        if (path_length[i] < INFINITY)\r\n            printf(\"%d\\n\", path_length[i]);\r\n        else\r\n            printf(\"Infinity\\n\");\r\n    }\r\n}\r\n\r\n// Finds weight of the edge that connects Vertex u with Vertex v\r\nint findEdgeWeight(Vertex u, Vertex v, Edge *edges, int *weights)\r\n{\r\n    int i;\r\n    for (i = 0; i < E; i++)\r\n    {\r\n        if (edges[i].u == u.label && edges[i].v == v.label)\r\n        {\r\n            return weights[i];\r\n        }\r\n    }\r\n    // If no edge exists, weight is infinity\r\n    return INFINITY;\r\n}\r\n\r\n// Get the minimum path length among the paths\r\nint minimimPathLength(int *path_length, Vertex *vertices)\r\n{\r\n    int i;\r\n    int min_path_length = INFINITY;\r\n    for (i = 0; i < V; i++)\r\n    {\r\n        if (vertices[i].visited == true)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        else if (vertices[i].visited == false && path_length[i] < min_path_length)\r\n        {\r\n            min_path_length = path_length[i];\r\n        }\r\n    }\r\n    return min_path_length;\r\n}\r\n\r\nint minimimPathVertex(Vertex *vertices, int *path_length)\r\n{\r\n    int i;\r\n    int min_path_length = minimimPathLength(path_length, vertices);\r\n\r\n    // Get the vertex with the minimum path length\r\n    // Mark it as visited\r\n    for (i = 0; i < V; i++)\r\n    {\r\n        if (vertices[i].visited == false && path_length[vertices[i].label] == min_path_length)\r\n        {\r\n            vertices[i].visited = true;\r\n            return i;\r\n        }\r\n    }\r\n}\r\n\r\n// Dijkstra Algorithm (Serial Version)\r\nvoid Dijkstra_Serial(Vertex *vertices, Edge *edges, int *weights, Vertex *root)\r\n{\r\n    clock_t serial_start, serial_end;\r\n    double serial_time;\r\n    int path_length[V];\r\n\r\n    // Mark first vertex as visited, shortest path = 0\r\n    root->visited = true;\r\n    path_length[root->label] = 0;\r\n    int i, j;\r\n    // Compute distance to other vertices\r\n    for (i = 0; i < V; i++)\r\n    {\r\n\r\n        if (vertices[i].label != root->label)\r\n        {\r\n            path_length[vertices[i].label] = findEdgeWeight(*root, vertices[i], edges, weights);\r\n        }\r\n        else\r\n        {\r\n\r\n            vertices[i].visited = true;\r\n        }\r\n    }\r\n\r\n    serial_start = clock();\r\n    // External For Loop\r\n    for (j = 0; j < V; j++)\r\n    {\r\n        Vertex u;\r\n        // Obtain the vertex which has shortest distance and mark it as visited\r\n        int h = minimimPathVertex(vertices, path_length);\r\n        u = vertices[h];\r\n\r\n        // Update shortest path wrt new source\r\n        // Internal For Loop, Serial computation\r\n        for (i = 0; i < V; i++)\r\n        {\r\n            if (vertices[i].visited == false)\r\n            {\r\n                int c = findEdgeWeight(u, vertices[i], edges, weights);\r\n                path_length[vertices[i].label] = std::min(path_length[vertices[i].label], path_length[u.label] + c);\r\n            }\r\n        }\r\n    }\r\n    serial_end = clock();\r\n    printShortestPathLength(path_length);\r\n    serial_time = ((double)(serial_end - serial_start)) / CLOCKS_PER_SEC * 1000; // Convert to milliseconds\r\n    printf(\"\\nRunning time (serial): %.2lf ms\\n\", serial_time);\r\n}\r\n\r\n// Function to generate a random graph\r\nvoid generateRandomGraph(Vertex *vertices, Edge *edges, int *weights, int density)\r\n{\r\n    // Initialize random number generator\r\n    srand(time(NULL));\r\n\r\n    // Generate edges randomly based on the density\r\n    int edge_count = 0;\r\n    for (int i = 0; i < V; i++)\r\n    {\r\n        for (int j = i + 1; j < V; j++)\r\n        {\r\n            if (rand() % 100 < density) // Adjust density as a percentage\r\n            {\r\n                // Random weight for the edge\r\n                int weight = rand() % 100 + 1; // Adjust range of weights as needed\r\n\r\n                // Add edge from vertex i to vertex j\r\n                edges[edge_count] = (Edge){.u = i, .v = j};\r\n                weights[edge_count] = weight;\r\n                edge_count++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    printf(\"==========PARALLEL IMPLEMENTATION OF DIJKSTRA ALGORITHM==========\\n\");\r\n    printf(\"\\n\\t\\t\\t\\t\\t\\t JANANI HARSHATHA J\\n\\t\\t\\t\\t\\t\\t21011101053\\n\");\r\n    printf(\"\\n\\t\\t\\t\\t\\t\\t LOURTHU MARY RENIGALE\\n\\t\\t\\t\\t\\t\\t21011101066\\n\");\r\n    printf(\"Enter number of vertices: \");\r\n    scanf(\"%d\", &V);\r\n    printf(\"Enter number of edges: \");\r\n    scanf(\"%d\", &E);\r\n    Vertex vertices[V];\r\n    Edge edges[E];\r\n    int weights[E];\r\n\r\n    // Generate a random graph with a specified density (percentage)\r\n    int density;\r\n    printf(\"En",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//\n//  engine.cpp\n//  SDL2_minesweeper\n//\n//  Created by Student on 9.04.2024.\n//\n\n#include \"engine.hpp\"\n\n\nGameEngine::GameEngine(SDL_Renderer * renderer, int windowHeight, int windowWidth):renderer(renderer), windowHeight(windowHeight), windowWidth(windowWidth){\n    boardimages = IMG_LoadTexture(renderer, \"minesweeperart.png\");\n    timerimages = IMG_LoadTexture(renderer, \"numbers.png\");\n    promptimages = IMG_LoadTexture(renderer, \"minesweeperprompts.png\");\n    \n    state = START;\n    numbertexture = std::vector<SDL_Rect> (5); //positions of clock numbers\n    int clock_x = 10, clock_y = 5;\n    int numbersize = 40;\n    for(int i = 0; i < numbertexture.size(); i++){\n        numbertexture[i].x = clock_x;\n        numbertexture[i].y = clock_y;\n        numbertexture[i].w = numbersize;\n        numbertexture[i].h = numbersize;\n        clock_x+= numbersize+1;\n    }\n    \n    numberpos = std::vector<SDL_Rect> (11); //textures of clock numbers\n    int k = 0;\n    for(int i = 0; i < 11; i++){\n        numberpos[i].x = k;\n        numberpos[i].y = 0;\n        numberpos[i].w = 5;\n        numberpos[i].h = 7;\n        k += 5;\n    }\n    \n    prompttexture = std::vector<SDL_Rect> (13);\n    promptpos = std::vector<SDL_Rect> (13);\n    \n    std::vector<int> lengths = {29, 17, 28, 17, 49, 39, 30, 38, 29, 19, 17, 18, 18};\n    k = 0;\n    for(int i = 0; i < promptpos.size(); i++){\n        promptpos[i].x = 0;\n        promptpos[i].y = k;\n        promptpos[i].w = lengths[i];\n        promptpos[i].h = 9;\n        k+= 9;\n    }\n    \n    int textSize = 6;\n    //Minesweeper\n    prompttexture[MINESWEEPER].x = (windowWidth - lengths[MINESWEEPER]*textSize) / 2;\n    prompttexture[MINESWEEPER].y = 120;\n    prompttexture[MINESWEEPER].w = lengths[MINESWEEPER]*textSize;\n    prompttexture[MINESWEEPER].h = 9*textSize;\n    \n    //GameOver\n    prompttexture[GAMEOVER].x = 370;\n    prompttexture[GAMEOVER].y = 30;\n    prompttexture[GAMEOVER].w = lengths[GAMEOVER]*textSize;\n    prompttexture[GAMEOVER].h = 9*textSize;\n    \n    //YOUWIN\n    prompttexture[YOUWIN].x = 340;\n    prompttexture[YOUWIN].y = 30;\n    prompttexture[YOUWIN].w = lengths[YOUWIN]*textSize;\n    prompttexture[YOUWIN].h = 9*textSize;\n    \n    //NEW GAME\n    prompttexture[NEWGAME].x = (windowWidth - lengths[NEWGAME]*textSize) / 2;\n    prompttexture[NEWGAME].y = 400;\n    prompttexture[NEWGAME].w = lengths[NEWGAME]*textSize;\n    prompttexture[NEWGAME].h = 9*textSize;\n    \n    //EASY\n    prompttexture[EASY].x = (windowWidth - lengths[EASY]*textSize) / 2;\n    prompttexture[EASY].y = 250;\n    prompttexture[EASY].w = lengths[EASY]*textSize;\n    prompttexture[EASY].h = 9*textSize;\n    \n    //MEDIUM\n    prompttexture[MEDIUM].x = (windowWidth - lengths[MEDIUM]*textSize) / 2;\n    prompttexture[MEDIUM].y = 310;\n    prompttexture[MEDIUM].w = lengths[MEDIUM]*textSize;\n    prompttexture[MEDIUM].h = 9*textSize;\n    \n    //HARD\n    prompttexture[HARD].x = (windowWidth - lengths[HARD]*textSize) / 2;\n    prompttexture[HARD].y = 370;\n    prompttexture[HARD].w = lengths[HARD]*textSize;\n    prompttexture[HARD].h = 9*textSize;\n    \n    //CUSTOM\n    prompttexture[CUSTOM].x = (windowWidth - lengths[CUSTOM]*textSize) / 2;\n    prompttexture[CUSTOM].y = 430;\n    prompttexture[CUSTOM].w = lengths[CUSTOM]*textSize;\n    prompttexture[CUSTOM].h = 9*textSize;\n    \n    //RESTART\n    prompttexture[RESTART].x = windowWidth - lengths[RESTART]*textSize-20;\n    prompttexture[RESTART].y = 600;\n    prompttexture[RESTART].w = lengths[RESTART]*textSize;\n    prompttexture[RESTART].h = 9*textSize;\n    \n    //QUIT\n    prompttexture[QUIT].x = 20;\n    prompttexture[QUIT].y = 600;\n    prompttexture[QUIT].w = lengths[QUIT]*textSize;\n    prompttexture[QUIT].h = 9*textSize;\n    \n    //BACK\n    prompttexture[BACK].x = 20;\n    prompttexture[BACK].y = 50;\n    prompttexture[BACK].w = lengths[BACK]*textSize;\n    prompttexture[BACK].h = 9*textSize;\n    \n    //SIZE\n    prompttexture[SIZE].x = (windowWidth - lengths[SIZE]*textSize-200) / 2;\n    prompttexture[SIZE].y = 250;\n    prompttexture[SIZE].w = lengths[SIZE]*textSize;\n    prompttexture[SIZE].h = 9*textSize;\n    \n    //MINE\n    prompttexture[MINE].x = (windowWidth - lengths[MINE]*textSize-200) / 2;\n    prompttexture[MINE].y = 350;\n    prompttexture[MINE].w = lengths[MINE]*textSize;\n    prompttexture[MINE].h = 9*textSize;\n    \n    arrowtexture.x = 51;\n    arrowtexture.y = 88;\n    arrowtexture.w = 9;\n    arrowtexture.h = 12;\n    \n    arrowpos1.x = (windowWidth - 400);\n    arrowpos1.y = 230;\n    arrowpos1.w = 9*textSize;\n    arrowpos1.h = 12*textSize;\n\n    \n    arrowpos2.x = (windowWidth - 400);\n    arrowpos2.y = 340;\n    arrowpos2.w = 9*textSize;\n    arrowpos2.h = 12*textSize;\n    \n    \n    \n    counterpos = std::vector<SDL_Rect> (3);\n    clock_x = 830;\n    for(int i = 0; i < 3; i++){\n        counterpos[i].x = clock_x;\n        counterpos[i].y = clock_y;\n        counterpos[i].w = numbersize;\n        counterpos[i].h = numbersize;\n        \n        clock_x+= numbersize+1;\n    }\n}\n\n\nvoid GameEngine::init(int",
    "#include <iostream>\n\nusing namespace std;\n\n/*\u0427\u0438\u0441\u043b\u043e \u0447\u0435\u0433\u043e-\u043b\u0438\u0431\u043e, \u043f\u0435\u0440\u0432\u0430\u044f \u0431\u0443\u043a\u0432\u0430 \u0447\u0435\u0433\u043e-\u043b\u0438\u0431\u043e\nr=\u0440\u0443\u0431\u043b\u044c\na=\u043f\u043e\u043f\u044b\u0442\u043a\u0430\nt=\u0440\u0430\u0437\nh=\u0447\u0430\u0441\nw=\u0446\u0435\u043b\u0430\u044f\nn=\u043a\u0443\u043f\u044e\u0440\u0430*/\nstring ending(int number, char word) {\n    int ending;\n    string rub[4] = { \" \u0440\u0443\u0431\u043b\u044c\", \" \u0440\u0443\u0431\u043b\u044f\", \" \u0440\u0443\u0431\u043b\u0435\u0439\", \" \u0440\u0443\u0431\u043b\u0435\u0439\" };//\u0440\u0443\u0431\u043b\u044c\n    string attemt[4] = { \" \u043f\u043e\u043f\u044b\u0442\u043a\u0430\", \" \u043f\u043e\u043f\u044b\u0442\u043a\u0438\", \" \u043f\u043e\u043f\u044b\u0442\u043e\u043a\", \" \u043f\u043e\u043f\u044b\u0442\u043e\u043a\" };//\u043f\u043e\u043f\u044b\u0442\u043a\u0430\n    string times[4] = { \" \u0440\u0430\u0437\", \" \u0440\u0430\u0437\u0430\", \" \u0440\u0430\u0437\", \" \u0440\u0430\u0437\" };//\u0440\u0430\u0437\n    string hour[4] = { \" \u0447\u0430\u0441\", \" \u0447\u0430\u0441\u0430\", \" \u0447\u0430\u0441\u043e\u0432\", \" \u0447\u0430\u0441\u043e\u0432\" };//\u0447\u0430\u0441\n    string whole[4] = { \" \u0446\u0435\u043b\u0430\u044f\", \" \u0446\u0435\u043b\u044b\u0445\", \" \u0446\u0435\u043b\u044b\u0445\", \" \u0446\u0435\u043b\u044b\u0445\" };//\u0446\u0435\u043b\u0430\u044f\n    string note[4] = { \" \u043a\u0443\u043f\u044e\u0440\u0430\", \" \u043a\u0443\u043f\u044e\u0440\u044b\", \" \u043a\u0443\u043f\u044e\u0440\", \" \u043a\u0443\u043f\u044e\u0440\" };//\u043a\u0443\u043f\u044e\u0440\u0430\n\n    if ((number / 10) % 10 == 1) ending = 3;\n    else if (number % 10 == 0 || number % 10 >= 5) ending = 2;\n    else if (number % 10 > 1 && number % 10 < 5) ending = 1;\n    else if (number % 10 == 1) ending = 0;\n\n    if (word == 114) return rub[ending];    //r\n    if (word == 97) return attemt[ending];  //a\n    if (word == 116) return times[ending];  //t\n    if (word == 104) return hour[ending];   //h\n    if (word == 119) return whole[ending];  //w\n    if (word == 110) return note[ending];   //n\n}",
    "#include \"../includes/utils.hpp\"\n\nvoid sendStringSocket(int socket, const string& str)\n{\n\tcout << PURPLE<< \"[Server]: Sending : \" << str;\n    ssize_t bytesSent = send(socket, str.c_str(), str.length(), 0);\n    if (bytesSent == -1)\n        cerr << \"Error sending data to client\" << endl;\n\t\n}\n\nvoid split(string input, char del, vector<string> &tokens)\n{\n    std::istringstream ss(input);\n    string token;\n    \n    while (std::getline(ss, token, del)) {\n        tokens.push_back(token);\n    }\n\n    return;\n\n}\nstring extractBetween(const string & cmd, const string & str1, const string & str2)\n{\n\tconst size_t len = str1.length();\n\n\tsize_t pos = cmd.find(str1);\n\tsize_t endPos = cmd.find(str2, pos + len);\n\tif (pos == std::string::npos || endPos == std::string::npos)\n\t\treturn \"Not found\";\n\treturn (cmd.substr(pos + len, endPos - (pos + len)));\n}\n\nvoid replaceAll(string& str, const string& from, const string& to) {\n\tif(from.empty())\n\t\treturn;\n\tsize_t start_pos = 0;\n\twhile((start_pos = str.find(from, start_pos)) != string::npos) {\n\t\tstr.replace(start_pos, from.length(), to);\n\t\tstart_pos += to.length();\n\t}\n}\n\nbool ctrlCPressed = false;\n\nvoid handleSignal(int signal)\n{\n\t(void)signal;\n\tctrlCPressed = true;\n}",
    "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Problems {\npublic:\n\tvector<int> twoSum(vector<int> nums, int target)\n\t{\n\t\tint n = nums.size();\n\t\tunordered_map<int, int> numMap;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint szukane = target - nums[i];\n\t\t\tif (numMap.count(szukane))\n\t\t\t\treturn { numMap[szukane], i };\n\t\t\tnumMap[nums[i]] = i;\n\t\t}\n\t\treturn{ -1, -1 };\n\t}\n\n\n\t\n\t\n\n\tdouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2)\n\t{\n\t\tvector<int>mergedArrays;\n\n\t\tfor (auto num : nums1)\n\t\t{\n\t\t\tmergedArrays.push_back(num);\n\t\t}\n\t\tfor (auto num : nums2)\n\t\t{\n\t\t\tmergedArrays.push_back(num);\n\t\t}\n\n\t\tsort(mergedArrays.begin(), mergedArrays.end());\n\n\t\tint n = mergedArrays.size();\n\t\tif (n % 2 == 0)\n\t\t{\n\t\t\treturn  ((n / 2) + (n / 2 - 1)) / 2.0 ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (n / 2);\n\t\t}\n\t\treturn -1;\n\n\t}\n\n\n\n};\n\n\nint main()\n{\n\t/*vector<int>nums1 = { 0,1,3,4,5,6 };\n\tvector<int>nums2 = { 2 };\n\tint target = 15;\n\n\tProblems problem;\n\n\tdouble result = problem.findMedianSortedArrays(nums1, nums2);\n\tcout << result;*/\n\n\tint a = 1;\n\tint b = a;\n\n\tbool d = true;\n\tcout << d << endl;\n\tcout << \"a: \" << a << \", b: \" << b;\n\treturn 0;\n}",
    "\ufeff#include \"pch.h\"\r\n\r\nusing _cef_urlrequest_create = void* (*)(void* request, void* client, void* request_context);\r\nstatic _cef_urlrequest_create cef_urlrequest_create_orig = nullptr;\r\n\r\nusing _cef_string_userfree_utf16_free = void (*)(void* str);\r\nstatic _cef_string_userfree_utf16_free cef_string_userfree_utf16_free_orig = nullptr;\r\n\r\nusing _cef_zip_reader_create = void* (*)(void* stream);\r\nstatic _cef_zip_reader_create cef_zip_reader_create_orig = nullptr;\r\n\r\nusing _cef_zip_reader_t_read_file = int(__stdcall*)(void* self, void* buffer, size_t bufferSize);\r\nstatic _cef_zip_reader_t_read_file cef_zip_reader_t_read_file_orig = nullptr;\r\n\r\n#ifndef NDEBUG\r\nvoid* cef_urlrequest_create_hook(struct _cef_request_t* request, void* client, void* request_context)\r\n#else\r\nvoid* cef_urlrequest_create_hook(void* request, void* client, void* request_context)\r\n#endif\r\n{\r\n#ifndef NDEBUG\r\n\tcef_string_utf16_t* url_utf16 = request->get_url(request);\r\n\tstd::wstring url = Utils::ToString(url_utf16->str);\r\n#else\r\n\tconst auto get_url = *(void* (__stdcall**)(void*))((uintptr_t)request + SettingsManager::m_cef_request_t_get_url_offset);\r\n\tauto url_utf16 = get_url(request);\r\n\tstd::wstring url = *reinterpret_cast<wchar_t**>(url_utf16);\r\n#endif\r\n\tfor (const auto& block_url : SettingsManager::m_block_list) {\r\n\t\tif (std::wstring_view::npos != url.find(block_url)) {\r\n\t\t\tLog(L\"blocked - \" + url, LogLevel::Info);\r\n\t\t\tcef_string_userfree_utf16_free_orig((void*)url_utf16);\r\n\t\t\treturn nullptr;\r\n\t\t}\r\n\t}\r\n\r\n\tcef_string_userfree_utf16_free_orig((void*)url_utf16);\r\n\tLog(L\"allow - \" + url, LogLevel::Info);\r\n\treturn cef_urlrequest_create_orig(request, client, request_context);\r\n}\r\n\r\n#ifndef NDEBUG\r\nint cef_zip_reader_t_read_file_hook(struct _cef_zip_reader_t* self, void* buffer, size_t bufferSize)\r\n#else\r\nint cef_zip_reader_t_read_file_hook(void* self, void* buffer, size_t bufferSize)\r\n#endif\r\n{\r\n\tint _retval = cef_zip_reader_t_read_file_orig(self, buffer, bufferSize);\r\n\r\n#ifndef NDEBUG\r\n\tstd::wstring file_name = Utils::ToString(self->get_file_name(self)->str);\r\n#else\r\n\tconst auto get_file_name = (*(void* (__stdcall**)(void*))((uintptr_t)self + SettingsManager::m_cef_zip_reader_t_get_file_name_offset));\r\n\tstd::wstring file_name = *reinterpret_cast<wchar_t**>(get_file_name(self));\r\n#endif\r\n\r\n\tif (SettingsManager::m_zip_reader.contains(file_name)) {\r\n\t\tfor (auto& [name, data] : SettingsManager::m_zip_reader.at(file_name)) {\r\n\t\t\tconst auto& sig = data.at(L\"Signature\").get_string();\r\n\t\t\tauto scan = MemoryScanner::ScanResult(data.at(L\"Address\").get_integer(), reinterpret_cast<uintptr_t>(buffer), bufferSize, true);\r\n\t\t\tif (!scan.is_valid(sig)) {\r\n\t\t\t\tscan = MemoryScanner::ScanFirst(reinterpret_cast<uintptr_t>(buffer), bufferSize, sig);\r\n\t\t\t\tdata.at(L\"Address\") = static_cast<int>(scan.rva());\r\n\t\t\t}\r\n\r\n\t\t\tif (scan.is_valid()) {\r\n\t\t\t\tconst auto& value = data.at(L\"Value\").get_string();\r\n\t\t\t\tconst auto& offset = data.at(L\"Offset\").get_integer();\r\n\t\t\t\tconst auto& fill = data.at(L\"Fill\").get_integer();\r\n\r\n\t\t\t\tif (fill > 0) {\r\n\t\t\t\t\tscan.offset(offset).write(Utils::ToString(std::wstring(fill, ' ').append(value))) ? Log(name + L\" - patch success!\", LogLevel::Info) : Log(name + L\" - patch failed!\", LogLevel::Error);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tscan.offset(offset).write(Utils::ToString(value)) ? Log(name + L\" - patch success!\", LogLevel::Info) : Log(name + L\" - patch failed!\", LogLevel::Error);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tLog(name + L\" - unable to find signature in memory!\", LogLevel::Error);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn _retval;\r\n}\r\n\r\n#ifndef NDEBUG\r\ncef_zip_reader_t* cef_zip_reader_create_hook(cef_stream_reader_t* stream)\r\n#else\r\nvoid* cef_zip_reader_create_hook(void* stream)\r\n#endif\r\n{\r\n#ifndef NDEBUG\r\n\tcef_zip_reader_t* zip_reader = (cef_zip_reader_t*)cef_zip_reader_create_orig(stream);\r\n\tcef_zip_reader_t_read_file_orig = (_cef_zip_reader_t_read_file)zip_reader->read_file;\r\n#else\r\n\tauto zip_reader = cef_zip_reader_create_orig(stream);\r\n\tcef_zip_reader_t_read_file_orig = *(_cef_zip_reader_t_read_file*)((uintptr_t)zip_reader + SettingsManager::m_cef_zip_reader_t_read_file_offset);\r\n#endif\r\n\r\n\tif (!Hooking::HookFunction(&(PVOID&)cef_zip_reader_t_read_file_orig, (PVOID)cef_zip_reader_t_read_file_hook)) {\r\n\t\tLog(L\"Failed to hook cef_zip_reader::read_file function!\", LogLevel::Error);\r\n\t}\r\n\telse {\r\n\t\tHooking::UnhookFunction(&(PVOID&)cef_zip_reader_create_orig);\r\n\t}\r\n\r\n\treturn zip_reader;\r\n}\r\n\r\nDWORD WINAPI EnableDeveloper(LPVOID lpParam)\r\n{\r\n\tauto& dev_data = SettingsManager::m_developer.at(SettingsManager::m_architecture);\r\n\tconst auto& sig = dev_data.at(L\"Signature\").get_string();\r\n\tauto scan = MemoryScanner::ScanResult(dev_data.at(L\"Address\").get_integer(), L\"\", true);\r\n\tif (!scan.is_valid(sig)) {\r\n\t\tscan = MemoryScanner::ScanFirst(sig);\r\n\t\tdev_data.at(L\"Address\") = static_cast<int>(scan.rva());\r\n\t}\r\n\r\n\tif (scan.is_valid()) {\r\n\t\tif (scan.offset(dev_data.at(L\"Offset\").get_integer()).write(Utils::ToHexBytes(dev_data.at(L\"Value\").get_string()))) {\r\n\t\t\tLog(L\"Developer - succe",
    "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <limits>\n#include <cctype> // Biblioteca p/ usar a fun\u00e7\u00e3o isalpha\n\nusing namespace std;\n\nstruct aluno{ //molde p/ armazenar as info do aluno\n    string nome;\n    float n1,n2;\n    struct aluno* prox; //ponteiro para guardar o endere\u00e7o da prox struct criada para \"encadear\"\n};\n\nstruct aluno *cabeca=nullptr;//referencia primaria\nstruct aluno *ult=nullptr; //ultimo da lista\n\nvoid limpar_tela() {\n    system(\"clear||cls\");\n}\n\n//prototipos fun\u00e7\u00f5es\nint menu();\nvoid criar_struct_alunos(int);\nvoid preencher_alunos(int);\nvoid exibir_lista_alunos();\nvoid perguntar_exibir();\nvoid remover_da_lista();\nstring padronizar_nomes();\n\n//funcao principal\nint main()\n{\n    int num_aluno;//var p/ guardar qnts structs deverao ser criadas e encadeadas\n    num_aluno=menu();\n    limpar_tela();\n    criar_struct_alunos(num_aluno);\n    preencher_alunos(num_aluno);\n    perguntar_exibir();\n    return 0;\n}\n\nint menu(){\n    bool num_valido=false;\n    int num_aluno;\n    cout<<\"\\t Bem Vindo Professor!\\n\";\n    cout<<\"Quantos alunos tem est\u00e1 sala: \";\n    do{\n        if (!(cin >> num_aluno)) { // Se a entrada n\u00e3o \u00e9 um n\u00famero\n            cout<<\"Entrada inv\u00e1lida. Por favor, digite um n\u00famero inteiro maior que 0:\";\n            cin.clear(); // Limpa o erro do cin\n            cin.ignore(numeric_limits<streamsize>::max(),'\\n'); //descartar caracteres da entrada ate o \\n.\n        }\n        else if(num_aluno<=0){\n            cout<<\"Digite um n\u00famero inteiro maior que 0:\";\n        }\n        else{\n            num_valido=true;\n        }\n    }while(!num_valido);\n    return num_aluno; //returna a var pro main\n}\n\nvoid criar_struct_alunos(int num_alunos){\n    struct aluno *novo=nullptr;//cria um ponteiro que aponta pra struct (local da funcao)\n    for(int i=0;i<num_alunos;i++){ //rodar a qnt de alunos que deverao ser alocados\n        novo=(struct aluno*)malloc(sizeof(struct aluno));/*pega o tamanho da struct e armazena na MP e guarda \n        o end. da primeira celula no ponteiro*/\n        if(cabeca==nullptr){ //se n\u00e3o tiver nenhum aluno marcado\n            cabeca=novo;\n        }\n        else{\n            ult->prox=novo;//vai receber o novo end. criado para n\u00e3o perder a referencia\n        }\n        ult=novo;//vai apontar pra ultima struct armazenada\n    }\n}\n\nbool validar_nome(const string& nome) { //recebe o nome da funcao preencher_alunos\n    for(char c : nome) { //verifica cada letra colocada\n        if (!isalpha(c) && c != ' ') { // Se qualquer caractere n\u00e3o for uma letra e separador, retorna falso\n            return false;\n        }\n    }\n    return true; // Se tds os carac forem letras ou ' '\n}\n\nstring padronizar_nomes(string nome){\n    nome[0] = (char) toupper( (int) nome[0] );//converte o primeiro caractere para mai\u00fasculo\n    for(size_t i = 0; i < nome.size() - 1; ++i) { \n        if(nome[i] == ' '){\n            nome[i+1] = (char) toupper( (int ) nome[i+1]);//caractere atual for '', converte proximo mai\u00fasculo\n        }\n    }\n    return nome;\n}\n\n\nvoid preencher_alunos(int cont){\n    int cont1=1;//pra usar na comparacao\n    bool num_valido=false;\n    float n1,n2;\n    string nome;\n    struct aluno *aux=nullptr;//pra n\u00e3o mexer diretamente com a cabeca fa\u00e7o uma copia\n    aux=cabeca;//a var local recebe a cabeca\n    while(cont1 <= cont){ //enquanto ainda n\u00e3o preencheu todos os alunos armazenados\n       cout<<\"Digite o nome do \"<<cont1<<\" \u00b0 aluno:\";\n       cin.ignore(); // Limpar o buffer do teclado antes de usar getline\n       getline(cin, nome);\n       // Se a entrada do usu\u00e1rio foi bem-sucedida e se o nome fornecido \u00e9 v\u00e1lido\n       if(cin.fail() || nome.empty() || !validar_nome(nome)) {\n           cout << \"Erro: Entrada inv\u00e1lida. Por favor, digite um nome v\u00e1lido.\\n\";\n           cin.clear(); // Limpar o estado de erro\n           cin.ignore(numeric_limits<streamsize>::max(), '\\n'); // Ignora entrada inv\u00e1lida\n           continue; // Ignora o resto e volta ao in\u00edcio no loop\n       }\n       nome = padronizar_nomes(nome); //funcao para colocar maiuscula na primeira letra do nome e sobrenome\n       aux->nome=nome;\n       \n       cout<<\"\\nDigite a primeira nota[0 a 10]: do aluno \"<<nome<<\":\";\n       do{\n           if (!(cin >> n1)) { // Verifica se a entrada n\u00e3o \u00e9 um n\u00famero\n            cout<<\"Entrada inv\u00e1lida. Por favor, digite um n\u00famero v\u00e1lido (0 a 10): \\n\";\n            cin.clear(); \n            cin.ignore(numeric_limits<streamsize>::max(),'\\n');\n        }\n        else if(n1 < 0 || n1 > 10){\n            cout<<\"Digite um n\u00famero inteiro v\u00e1lido (0 a 10): \\n\";\n            continue;\n        }\n        else{\n            num_valido=true;\n        }\n       }while(!num_valido);//entro no !verdade sai do loop\n       aux->n1=n1; //guarda var na struct que o ponteiro aponta\n       \n       num_valido = false;\n       cout<<\"\\nDigite a segunda nota[0 a 10] do aluno \"<<nome<<\":\";\n       do{\n           if (!(cin >> n2)) { // Verifica se a entrada n\u00e3o \u00e9 um n\u00famero\n            cout<<\"Entrada inv\u00e1lida. Por favor, digite um n\u00fame",
    "#include <iostream>\n\nint main(){\n    {\n        //\u0447\u0438\u0441\u0435\u043d\u043d\u044b\u0435 \u0442\u0438\u043f\u044b\n        //\u0446\u0435\u043b\u044b\u0435\n        \n        char ch; //1 \u0431\u0430\u0439\u0442 \u043e\u0442 -128 \u0434\u043e 127\n        unsigned char uch; //1 \u0431\u0430\u0439\u0442 \u043e\u0442 0 \u0434\u043e 255\n        short sh; // 2 \u0431\u0430\u0439\u0442\u0430 \u043e\u0442 -2^15 \u0434\u043e 2^15-1\n        unsigned short ush; // 2 \u0431\u0430\u0439\u0442\u0430 \u043e\u0442 0 \u0434\u0430 2^16-1\n        int i; // 4 \u0431\u0430\u0439\u0442\u0430 \u043e\u0442 - 2^31 \u0434\u043e 2^-31\n        unsigned int ui; // 4 \u0431\u0430\u0439\u0442\u0430 \u043e\u0442 0 \u0434\u043e 2^32 - 1\n        long l; // 4 \u0438\u043b\u0438 8 \u0431\u0430\u0439\u0442, \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c >= int \u0438\u043b\u0438 <= long long\n        unsigned long ul; // 4 \u0431\u0430\u0439\u0442\u0430 \u043e\u0442 0 \u0434\u043e 2^32 - 1\n        long long ll; //8 \u0431\u0430\u0439\u0442 \u043e\u0442 -2^63 \u0434\u043e 2^63-1\n        unsigned long long llu; // 8 \u0431\u0430\u0439\u0442 \u043e\u0442 0 \u0434\u043e 2^64-1\n        //\u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435\n        float fl; // 4 \u0431\u0430\u0439\u0442\u0430 7 \u0437\u0430\u043d\u0447\u0438\u043c\u044b\u0445 \u0446\u0438\u0444\u0440\n        double db; //8 \u0431\u0430\u0439\u0442 15 \u0437\u043d\u0430\u0447\u0438\u043c\u044b\u0445 \u0446\u0438\u0444\u0440\n    }\n    {\n        // \u0437\u0430\u0434\u0430\u0447\u0430 \u043f\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0443 (2 \u0432\u0430\u0440\u0438\u0430\u043d\u0442)\n        double S;\n        double H;\n        std:: cout << \" \u0432\u0432\u0435\u0434\u0438 \u043f\u043b\u043e\u0449\u0430\u0434\u044c \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0438 \u0432\u044b\u0441\u043e\u0442\u0443: \" << std::endl;\n        std:: cin >> S >> H;\n        \n        std:: cout << \"\u041e\u0441\u043d\u043e\u0432\u0430\u043d\u0438\u0435 = \" << 2*S/H << std::endl;\n    }\n    \n    \n}\n",
    "#include <stdio.h>\n#include <fstream>\n#include <string>\n#include <memory>\n#include <cmath>\n\n#include \"utils.h\"\n// use only standard library\nusing namespace std;\n\nvoid append_padding_bits(vector<u8> &v, size_t b){\n\tsize_t len = b+1;\n\twhile(len % 64 != 56) len += 1;\n\tsize_t numZerosBytes = len - b - 1;\n\t\n\tvector<u8> zeros(numZerosBytes, (u8)0);\n\tv.push_back((u8)(1<<7));\n\tv.insert(v.end(), zeros.begin(), zeros.end());\n\t\n\tLOG(printf(\"len after appending padding bits = %lu\\n\", v.size()));\t\n}\n\nvoid append_bit_length(vector<u8> &v, size_t b){\n\tu8 chunks[8];\n\tchunks[0] = (u8)b;\n\tchunks[1] = (u8)(b >> 8);\n\tchunks[2] = (u8)(b >> 16);\n\tchunks[3] = (u8)(b >> 24);\n\tchunks[4] = (u8)(b >> 32);\n\tchunks[5] = (u8)(b >> 40);\n\tchunks[6] = (u8)(b >> 48);\n\tchunks[7] = (u8)(b >> 56);\n\tv.insert(v.end(), chunks, chunks+8);\n\tLOG(printf(\"len after appending length = %lu\\n\", v.size()));\n}\n\nvoid construct_table(u32 T[]){\n\tfor(int i = 1; i <= 64; i++){\n\t\tdouble t = 4294967296; // UINT32_MAX + 1 == 2^32\n\t\tt = t * abs(sin((double)i));\n\t\tT[i] = t;\n\t}\n}\n\nint F(int x, int y, int z) { return (x & y) | (~x & z); }\nint G(int x, int y, int z) { return (x & z) | (y & ~z); }\nint H(int x, int y, int z) { return x ^ y ^ z; }\nint I(int x, int y, int z) { return y ^ (x | ~z); }\n\n#define R1(a,b,c,d,k,s,i) \\\n\ta = b + (rotate_shift(a + F(b,c,d) + x[k] + T[i], s))\n#define R2(a,b,c,d,k,s,i) \\\n\ta = b + (rotate_shift(a + G(b,c,d) + x[k] + T[i], s))\n#define R3(a,b,c,d,k,s,i) \\\n\ta = b + (rotate_shift(a + H(b,c,d) + x[k] + T[i], s))\n#define R4(a,b,c,d,k,s,_i) \\\n\ta = b + (rotate_shift(a + I(b,c,d) + x[k] + T[_i], s))\n\nint main(int argc, i8* argv[]){\n\tif(argc != 2){\n\t\tprintf(\"Usage: babymd5 *file*\\n\");\n\t\treturn 1;\n\t}\n\tifstream input(argv[1]);\n\tif(!input.good()){\n\t\tprintf(\"Error reading file.\\n\");\n\t\treturn 1;\n\t}\n\tstring msg;\n\twhile(!input.eof() && input.good()){\n\t\tstring s; getline(input, s);\n\t\tmsg.append(s);\n\t}\n\tsize_t b = msg.size();\n\n\tauto mv = string_to_vector(msg);\n\tappend_padding_bits(mv, b);\n\tappend_bit_length(mv, b*8);\n\n\tauto mw = chars_to_words(mv);\n\tLOG(printf(\"The words are:\"));\n\tfor(u32 i = 0; i < mw.size();i++) LOG(printf(\"%u, \", mw[i]));\n\tLOG(printf(\"\\n\"));\n\tLOG(printf(\"Num of words: %lu\\n\", mw.size()));\n\n\t/* Step 3\n          word A: 01 23 45 67\n          word B: 89 ab cd ef\n          word C: fe dc ba 98\n          word D: 76 54 32 10\n\t*/\n\tu32 A = 0x67452301;\n\tu32 B = 0xefcdab89;\n\tu32 C = 0x98badcfe;\n\tu32 D = 0x10325476;\n\t\n\t// Step 4\n\t\t\n\tu32 x[16], T[65];\n\tconstruct_table(T);\n\tfor(unsigned i = 0; i < mw.size()/16; i++){\n\t\tfor(int j = 0; j < 16; j++)\n\t\t\tx[j] = mw[i*16 + j];\n\t\tu32 AA = A, BB = B, CC = C, DD = D;\n\t\t// Some BLACK MAGIC!!!\n\t\t//Round 1\n\t\tR1(A,B,C,D,0,7,1);  R1(D,A,B,C,1,12,2);  R1(C,D,A,B,2,17,3);  R1(B,C,D,A,3,22,4);\n\t\tR1(A,B,C,D,4,7,5);  R1(D,A,B,C,5,12,6);  R1(C,D,A,B,6,17,7);  R1(B,C,D,A,7,22,8);\n\t\tR1(A,B,C,D,8,7,9);  R1(D,A,B,C,9,12,10); R1(C,D,A,B,10,17,11);R1(B,C,D,A,11,22,12);\n\t\tR1(A,B,C,D,12,7,13);R1(D,A,B,C,13,12,14);R1(C,D,A,B,14,17,15);R1(B,C,D,A,15,22,16);\n\n\t\t//Round 2\n\t\tR2(A,B,C,D,1,5,17); R2(D,A,B,C,6,9,18); R2(C,D,A,B,11,14,19);R2(B,C,D,A,0,20,20);\n\t\tR2(A,B,C,D,5,5,21); R2(D,A,B,C,10,9,22);R2(C,D,A,B,15,14,23);R2(B,C,D,A,4,20,24);\n\t\tR2(A,B,C,D,9,5,25); R2(D,A,B,C,14,9,26);R2(C,D,A,B,3,14,27); R2(B,C,D,A,8,20,28);\n\t\tR2(A,B,C,D,13,5,29);R2(D,A,B,C,2,9,30); R2(C,D,A,B,7,14,31); R2(B,C,D,A,12,20,32);\n\n\t\t//Round 3\n\t\tR3(A,B,C,D,5,4,33); R3(D,A,B,C,8,11,34); R3(C,D,A,B,11,16,35);R3(B,C,D,A,14,23,36);\n\t\tR3(A,B,C,D,1,4,37); R3(D,A,B,C,4,11,38); R3(C,D,A,B,7,16,39); R3(B,C,D,A,10,23,40);\n\t\tR3(A,B,C,D,13,4,41);R3(D,A,B,C,0,11,42); R3(C,D,A,B,3,16,43); R3(B,C,D,A,6,23,44);\n\t\tR3(A,B,C,D,9,4,45); R3(D,A,B,C,12,11,46);R3(C,D,A,B,15,16,47);R3(B,C,D,A,2,23,48);\n\t\t\n\t\t//Round 4\n\t\tR4(A,B,C,D,0,6,49); R4(D,A,B,C,7,10,50); R4(C,D,A,B,14,15,51);R4(B,C,D,A,5,21,52);\n\t\tR4(A,B,C,D,12,6,53);R4(D,A,B,C,3,10,54); R4(C,D,A,B,10,15,55);R4(B,C,D,A,1,21,56);\n\t\tR4(A,B,C,D,8,6,57); R4(D,A,B,C,15,10,58);R4(C,D,A,B,6,15,59); R4(B,C,D,A,13,21,60);\n\t\tR4(A,B,C,D,4,6,61); R4(D,A,B,C,11,10,62);R4(C,D,A,B,2,15,63); R4(B,C,D,A,9,21,64);\n\t\t\n\t\tA = A + AA;\n\t\tB = B + BB;\n\t\tC = C + CC;\n\t\tD = D + DD;\n\t}\n\t\n\tstring digest = word_to_string(A);\n\tdigest += word_to_string(B);\n\tdigest += word_to_string(C);\n\tdigest += word_to_string(D);\n\n\tprintf(\"MD5 Hash is: %s\\n\", digest.c_str());\n\treturn 0;\n}",
    "#include \"Overcoat.h\"\n#include <iostream>\nusing namespace std;\n\nOvercoat::Overcoat()\n{\n\ttype = nullptr;\n\tprice = 0;\n}\n\nOvercoat::Overcoat(const char* t, double p)\n{\n\tif (t != nullptr)\n\t{\n\t\tint size = strlen(t);\n\t\tdelete[]type;\n\t\ttype = new char[size + 1];\n\t\tstrcpy_s(type, size + 1, t);\n\t}\n\tprice = p;\n}\n\nbool Overcoat::operator==(const Overcoat& obj)const\t// \u00cf\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ea\u00e0 \u00ed\u00e0 \u00f0\u00b3\u00e2\u00ed\u00b3\u00f1\u00f2\u00fc \u00f2\u00e8\u00ef\u00b3\u00e2 \u00ee\u00e4\u00ff\u00e3\u00f3 (\u00ee\u00ef\u00e5\u00f0\u00e0\u00f6\u00b3\u00ff \u00ab==\u00bb).\n{\n\treturn strcmp(type,obj.type)==0;\n}\n\nvoid Overcoat::operator=(const Overcoat& obj)\t// \u00ce\u00ef\u00e5\u00f0\u00e0\u00f6\u00b3\u00fe \u00ef\u00f0\u00e8\u00f1\u00e2\u00ee\u00fe\u00e2\u00e0\u00ed\u00ed\u00ff \u00ee\u00e4\u00ed\u00ee\u00e3\u00ee \u00ee\u00e1\u2019\u00ba\u00ea\u00f2\u00e0 \u00b3\u00ed\u00f8\u00ee\u00ec\u00f3(\u00ee\u00ef\u00e5\u00f0\u00e0\u00f6\u00b3\u00ff \u00ab = \u00bb).\n{\n\tif (obj.type != nullptr)\n\t{\n\t\tint size = strlen(obj.type);\n\t\tdelete[]type;\n\t\ttype = new char[size + 1];\n\t\tstrcpy_s(type, size + 1, obj.type);\n\t}\n\tprice = obj.price;\n}\n\nbool Overcoat::operator>(const Overcoat& obj) const // \u00cf\u00ee\u00f0\u00b3\u00e2\u00ed\u00ff\u00ed\u00ed\u00ff \u00e7\u00e0 \u00f6\u00b3\u00ed\u00ee\u00fe \u00e4\u00e2\u00ee\u00f5 \u00ef\u00e0\u00eb\u00fc\u00f2\u00ee \u00ee\u00e4\u00ed\u00ee\u00e3\u00ee \u00f2\u00e8\u00ef\u00f3 (\u00ee\u00ef\u00e5\u00f0\u00e0\u00f6\u00b3\u00ff \u00ab>\u00bb).\n{\n\treturn price == obj.price;\n}\n\n\n\nvoid Overcoat::show() const\n{\n\tif (type != nullptr)\n\t\tcout << \"Type: \" << type << endl;\n\telse\n\t\tcout << \"Type == nullptr.\" << endl;\n\tcout << \"Price: \" << price << endl<<endl;\n}\n\nOvercoat::~Overcoat()\n{\n\tif (type != nullptr)\n\t{\n\t\tdelete[]type;\n\t}\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff// Samsonova_dz.cpp : \u042d\u0442\u043e\u0442 \u0444\u0430\u0439\u043b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \"main\". \u0417\u0434\u0435\u0441\u044c \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0438 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b.\r\n//\r\n\r\n#include <iostream>\r\n#include <cstdint>\r\n#include <bit>\r\n\r\nvoid invertBits(uint64_t* ptr, size_t length, int startBit, int endBit) {\r\n    if (ptr == nullptr || length == 0 || startBit < 0 || endBit < 0 || startBit >= 64 || endBit >= 64 || startBit > endBit)\r\n        return;\r\n\r\n    for (size_t i = 0; i < length; ++i) {\r\n        uint64_t& value = ptr[i];\r\n\r\n        for (int j = startBit; j <= endBit; ++j) {\r\n            value ^= (1ULL << j); // \u0418\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0439 \u0431\u0438\u0442\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    // \u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f\r\n    uint64_t data[] = { 0b0101010101010101, 0b1010101010101010 }; // \u041f\u0440\u0438\u043c\u0435\u0440 \u0434\u0430\u043d\u043d\u044b\u0445\r\n    size_t dataLength = sizeof(data) / sizeof(data[0]);\r\n\r\n    // \u0418\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0442\u044b \u0441 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 4 \u0434\u043e 11\r\n    int startBit = 4;\r\n    int endBit = 11;\r\n\r\n    std::cout << \"Before:\" << std::endl;\r\n    for (size_t i = 0; i < dataLength; ++i) {\r\n        std::cout << std::hex << data[i] << \" \";\r\n    }\r\n    std::cout << std::endl;\r\n\r\n    invertBits(data, dataLength, startBit, endBit);\r\n\r\n    std::cout << \"After:\" << std::endl;\r\n    for (size_t i = 0; i < dataLength; ++i) {\r\n        std::cout << std::hex << data[i] << \" \";\r\n    }\r\n    std::cout << std::endl;\r\n\r\n    return 0;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\n#include <fstream>\n\n#include <sstream>\n\n#include <map>\n\n#include <string>\n\n\n\nusing namespace std;\n\n\n\n// Define a class called ATM to handle banking operations\n\nclass ATM {\n\nprivate:\n\nmap<string, float> accounts; // A map to store account numbers (as strings) and their corresponding balances (as floating-point numbers)\n\n\n\npublic:\n\n// Function to load account information from a file\n\nvoid loadAccountsFromFile(const string& filename) {\n\nifstream file(filename);\n\nif (file.is_open()) {\n\nstring line;\n\nwhile (getline(file, line)) {\n\nstringstream ss(line);\n\nstring accountNumber;\n\nfloat balance; // Variable to store the balance\n\nss >> accountNumber >> balance; // Extract the account number and balance from the line\n\naccounts[accountNumber] = balance; // Store the account number and balance in the map\n\n}\n\nfile.close(); // Close the file after reading\n\n}\n\n}\n\n\n\n// Function to save account information to a file\n\nvoid saveAccountsToFile(const string& filename) {\n\nofstream file(filename);\n\nif (file.is_open()) { // If the file is successfully opened\n\nfor (const auto& pair : accounts) { // Iterate over each pair in the map\n\nfile << pair.first << \" \" << pair.second << endl; // Write the account number and balance to the file\n\n}\n\nfile.close();\n\n}\n\n}\n\n\n\n// Function to create an account with a given account number and starting balance\n\nvoid createAccount(const string& accountNumber, float balance) {\n\naccounts[accountNumber] = balance; // Add the account number and balance to the map\n\ncout << \"Account created!\" << endl;\n\nsaveAccountsToFile(\"accounts.txt\"); // Save the updated account information to the file\n\n}\n\n\n\n// Function to check if an account exists with a given account number and log in\n\nbool login(const string& accountNumber) {\n\nif (accounts.find(accountNumber) != accounts.end()) { // If the account number exists in the map\n\ncout << \"Welcome to your account!\" << endl;\n\nreturn true; // Return true to indicate successful login\n\n} else { // If the account number does not exist in the map\n\ncout << \"Account does not exist!\" << endl; // Print an error message\n\nreturn false; // Return false to indicate unsuccessful login\n\n}\n\n}\n\n\n\n// Function to deposit money into an existing account with a given account number and amount\n\nvoid deposit(const string& accountNumber, float amount) {\n\naccounts[accountNumber] += amount; // Increase the balance for the specified account by the specified amount\n\ncout << \"Money deposited!\" << endl;\n\ncout << \"New balance: \" << accounts[accountNumber] << endl;\n\nsaveAccountsToFile(\"accounts.txt\"); // Save the updated account information to the file\n\n}\n\n\n\n// Function to withdraw money from an existing account with a given account number and amount\n\nvoid withdraw(const string& accountNumber, float amount) {\n\nif (accounts[accountNumber] >= amount) { // If there is enough balance in the account to cover the requested amount\n\naccounts[accountNumber] -= amount; // Decrease the balance for the specified account by the specified amount\n\ncout << \"Money withdrawn!\" << endl;\n\ncout << \"New balance: \" << accounts[accountNumber] << endl;\n\nsaveAccountsToFile(\"accounts.txt\"); // Save the updated account information to the file\n\n} else { // If there is not enough balance in the account\n\ncout << \"Insufficient balance!\" << endl;\n\n}\n\n}\n\n};\n\n\n\n\n\nint main() {\n\nATM atm;\n\n\n\nint choice;\n\nstring accountNumber;\n\nfloat balance, amount;\n\n\n\n// Main menu for the ATM\n\ndo {\n\ncout << \"\\nSelect option:\" << endl;\n\ncout << \"1. Create account\" << endl;\n\ncout << \"2. Login\" << endl;\n\ncout << \"3. Deposit money\" << endl;\n\ncout << \"4. Withdraw money\" << endl;\n\ncout << \"5. Exit\" << endl;\n\ncout << \"Enter your choice: \";\n\ncin >> choice;\n\n\n\nswitch (choice) { // Depending on the user's choice, perform a certain action\n\ncase 1:\n\ncout << \"Enter account number: \";\n\ncin >> accountNumber;\n\ncout << \"Enter balance: \";\n\ncin >> balance;\n\natm.createAccount(accountNumber, balance);\n\nbreak;\n\ncase 2:\n\ncout << \"Enter account number: \";\n\ncin >> accountNumber;\n\nif (atm.login(accountNumber)) { // If the login is successful\n\ndo { // Show submenu for transactions\n\ncout << \"\\nSelect option:\" << endl;\n\ncout << \"1. Deposit money\" << endl;\n\ncout << \"2. Withdraw money\" << endl;\n\ncout << \"3. Logout\" << endl;\n\ncout << \"Enter your choice: \";\n\ncin >> choice;\n\nswitch (choice) {\n\ncase 1:\n\ncout << \"Enter amount to deposit: \";\n\ncin >> amount;\n\natm.deposit(accountNumber, amount);\n\nbreak;\n\ncase 2:\n\ncout << \"Enter amount to withdraw: \";\n\ncin >> amount;\n\natm.withdraw(accountNumber, amount);\n\nbreak;\n\ncase 3:\n\ncout << \"Logging out...\" << endl;\n\nbreak;\n\ndefault:\n\ncout << \"Invalid choice! Please try again.\" << endl;\n\n}\n\n} while (choice != 3); // Repeat submenu until user logs out\n\n}\n\nbreak;\n\ncase 3: // If the user chooses to deposit money before logging in\n\ncout << \"This option is only available after logging in!\" << endl;\n\nbreak;\n\ncase 4: // If the user chooses to withdraw money before logging in\n\ncout << \"This option is only available after logging in!\" << endl;\n\nbreak;\n",
    "#include \"config.h\"\r\n\r\nconst wchar_t wcRegistryKey[] = L\"Software\\\\Surname\";\r\nconst wchar_t wcSignatureValue[] = L\"Signature\";\r\nconst wchar_t wcPassphraseValue[] = L\"Passphrase\";\r\nconst wchar_t wcAboutProgram[] = L\"Author: KryvavyiPotii\\n\\n\"\r\nL\"This configuration program is created for fighting against illegal copying of SecurityApp.\\n\";\r\n\r\nint WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)\r\n{\r\n    // Class creation and registration.\r\n    WNDCLASSEX wcx = { 0 };\r\n\r\n    wcx.cbSize = sizeof(wcx);\r\n    wcx.lpfnWndProc = ConfigProc;\r\n    wcx.hInstance = hInstance;\r\n    wcx.lpszClassName = CONFIG_CLASS;\r\n    wcx.hIcon = LoadIcon(NULL, IDI_SHIELD);\r\n\r\n    if (!RegisterClassEx(&wcx))\r\n    {\r\n        showError(L\"wWinMain::RegisterClassEx\");\r\n        return -1;\r\n    }\r\n\r\n    // Create the window.\r\n    HWND hwnd = CreateWindowEx(\r\n        0, CONFIG_CLASS, L\"Configuration\",\r\n        WS_OVERLAPPED | WS_SYSMENU,\r\n        CW_USEDEFAULT, CW_USEDEFAULT,\r\n        CONFIG_WIDTH, CONFIG_HEIGHT,\r\n        NULL, NULL, hInstance, NULL\r\n    );\r\n    if (hwnd == NULL)\r\n    {\r\n        showError(L\"wWinMain::CreateWindowEx\");\r\n        return -1;\r\n    }\r\n\r\n    ShowWindow(hwnd, nCmdShow);\r\n\r\n    // Run the message loop.\r\n    MSG msg = { };\r\n\r\n    while (GetMessage(&msg, NULL, 0, 0) > 0)\r\n    {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nLRESULT CALLBACK ConfigProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch (uMsg)\r\n    {\r\n    case WM_CREATE:\r\n        addMenu(hwnd);\r\n        addControls(hwnd);\r\n        return 0;\r\n\r\n    case WM_CLOSE:\r\n    {\r\n        // Ask user before exiting program.\r\n        if (MessageBox(\r\n            NULL,\r\n            L\"You may configure app another time.\\n\\n\"\r\n            L\"Exit Configuration?\",\r\n            L\"Exit Configuration\",\r\n            MB_YESNO | MB_ICONQUESTION\r\n        ) == IDYES)\r\n        {\r\n            DestroyWindow(hwnd);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    case WM_DESTROY:\r\n        PostQuitMessage(0);\r\n        return 0;\r\n\r\n    case WM_COMMAND:\r\n        switch (LOWORD(wParam))\r\n        {\r\n        case CONFIG_OK:\r\n        {\r\n\r\n            if (configure(hwnd) < 0)\r\n            {\r\n                break;\r\n            }\r\n\r\n            // Exit Configuration.\r\n            MessageBox(\r\n                NULL,\r\n                L\"App was successfully configured.\\n\"\r\n                L\"Press \\\"OK\\\" to exit Configuration.\",\r\n                L\"Configuration finished\",\r\n                MB_OK | MB_ICONINFORMATION\r\n            );\r\n\r\n            DestroyWindow(hwnd);\r\n\r\n            break;\r\n        }\r\n\r\n        case CONFIG_CANCEL:\r\n            DestroyWindow(hwnd);\r\n            break;\r\n\r\n        // Show information about program.\r\n        case MENU_ABOUT:\r\n            MessageBox(\r\n                hwnd,\r\n                wcAboutProgram,\r\n                L\"About program\",\r\n                MB_OK | MB_ICONINFORMATION\r\n            );\r\n            break;\r\n        }\r\n\r\n        return 0;\r\n\r\n    default:\r\n        return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n}\r\n\r\nint addControls(HWND hwndConfig)\r\n{\r\n    if (!CreateWindowEx(\r\n        0, L\"STATIC\", L\"Enter passphrase:\",\r\n        WS_CHILD | WS_VISIBLE,\r\n        ELEMENT_OFFSET,\r\n        ELEMENT_OFFSET,\r\n        TEXT_WIDTH - ELEMENT_OFFSET * 2,\r\n        ELEMENT_HEIGHT,\r\n        hwndConfig, NULL, NULL, NULL\r\n    ))\r\n    {\r\n        showError(L\"addControls::STATIC::PASSPHRASE\");\r\n        return -1;\r\n    }\r\n\r\n    if (!CreateWindowEx(\r\n        0, L\"EDIT\", L\"\",\r\n        ES_AUTOHSCROLL | WS_BORDER | WS_CHILD | WS_VISIBLE,\r\n        ELEMENT_OFFSET,\r\n        ELEMENT_OFFSET * 3,\r\n        TEXT_WIDTH - ELEMENT_OFFSET * 2,\r\n        ELEMENT_HEIGHT,\r\n        hwndConfig, (HMENU)CONFIG_PASS, NULL, NULL\r\n    ))\r\n    {\r\n        showError(L\"addControls::EDIT::PASSPHRASE\");\r\n        return -1;\r\n    }\r\n\r\n    if (!CreateWindowEx(\r\n        0, L\"BUTTON\", L\"OK\",\r\n        WS_BORDER | WS_CHILD | WS_VISIBLE,\r\n        ELEMENT_OFFSET,\r\n        CONFIG_HEIGHT - ELEMENT_OFFSET * 9,\r\n        BUTTON_WIDTH,\r\n        ELEMENT_HEIGHT,\r\n        hwndConfig, (HMENU)CONFIG_OK, NULL, NULL\r\n    ))\r\n    {\r\n        showError(L\"addControls::BUTTON::OK\");\r\n        return -1;\r\n    }\r\n\r\n    if (!CreateWindowEx(\r\n        0, L\"BUTTON\", L\"Cancel\",\r\n        WS_BORDER | WS_CHILD | WS_VISIBLE,\r\n        CONFIG_WIDTH - BUTTON_WIDTH - ELEMENT_OFFSET * 3,\r\n        CONFIG_HEIGHT - ELEMENT_OFFSET * 9,\r\n        BUTTON_WIDTH,\r\n        ELEMENT_HEIGHT,\r\n        hwndConfig, (HMENU)CONFIG_CANCEL, NULL, NULL\r\n    ))\r\n    {\r\n        showError(L\"addControls::BUTTON::CANCEL\");\r\n        return -1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nint addMenu(HWND hwndConfig)\r\n{\r\n    // Create and add menu bar.\r\n    HMENU hMenuBar = CreateMenu();\r\n    HMENU hMenuHelp = CreateMenu();\r\n\r\n    if (!hMenuBar || !hMenuHelp)\r\n    {\r\n        showError(L\"addMenu::CreateMenu\");\r\n        return -1;\r\n    }\r\n\r\n    // Create menu options.\r\n    if (!AppendMenu(h",
    "\ufeff#include <iostream>\n#include <vector>\n#include <random>\n#include <string>\n#include <algorithm>\n#include <chrono>\n#include <fstream>\n#include <ctime>\n\nusing namespace std;\n\nbool isPrime(long long int n) {\n    if (n == 1 || n == 0)\n        return false;\n    for (long long int i = 2; i < n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\nvector<unsigned long long int> random_vec(unsigned long long int length)\n{\n    vector<unsigned long long int> rez;\n    while (rez.size() <= length)\n    {\n        long long int rnd = rand() % 50;\n        if (isPrime(rnd) && find(rez.begin(), rez.end(), rnd) == rez.end()) rez.push_back(rnd);\n    }\n\n    return rez;\n}\nvector<unsigned long long int> random_vec_var(unsigned long long int var, vector<unsigned long long int> vec_of_random_moduls)\n{\n    vector<unsigned long long int> rez = vec_of_random_moduls;\n    long long int  j = 0;\n    for (auto i : rez)\n        rez[j++] = var % i;\n    return rez;\n}\nvector<unsigned long long int> vec_rez(vector<unsigned long long int> vec_of_random_moduls, vector<unsigned long long int> vec_of_x_moduls, vector<unsigned long long int> vec_of_y_moduls)\n{\n    vector<unsigned long long int> rez(vec_of_random_moduls.size());\n    for (int i = 0; i < vec_of_random_moduls.size(); i++)\n        rez[i] = (vec_of_x_moduls[i] * vec_of_y_moduls[i]) % vec_of_random_moduls[i];\n    return rez;\n}\nunsigned long long int funk_eqw(unsigned long long int M, unsigned long long int mi)\n{\n    for (int i = 1; i <= mi; i++)\n        if ((M / mi) * i % mi == 1)\n            return i;\n    return 1;\n}\nunsigned long long int chinies_metod(vector<unsigned long long int> rez, vector<unsigned long long int> vec_of_random_moduls)\n{\n    unsigned long long int M = 1;\n    for (auto i : vec_of_random_moduls)\n        M *= i;\n    unsigned long long int rezultat = 0;\n    for (int i = 0; i < vec_of_random_moduls.size(); i++)\n    {\n        rezultat += (M / vec_of_random_moduls[i]) * rez[i] * funk_eqw(M, vec_of_random_moduls[i]);\n    }\n\n    return rezultat % M;\n}\nunsigned long long int rezultat_classic(const vector<unsigned long long int> vec_of_random_moduls, unsigned long long int x, unsigned long long int y) {\n    vector<unsigned long long int> rez;\n    for (auto mod : vec_of_random_moduls)\n        rez.push_back((x * y) % mod);\n    long long int result = chinies_metod(rez, vec_of_random_moduls);\n\n    return result;\n}\n\nint main()\n{\n    ofstream outputFile(\"result.txt\");\n    int rate = 0;\n    int repit = 1000000;\n    for (int lp = 0; lp < repit; lp++) {\n        unsigned long long int length = 11;\n        vector< unsigned long long int> vec_of_random_moduls = random_vec(length);\n        //for (auto i : vec_of_random_moduls)\n        //    cout << i<<\"\\n\";\n        //cout << \"\\n\\n\\n\\n\\n\";\n        unsigned long long int x = 73000000;\n        unsigned long long int y = 100000;\n\n        vector< unsigned long long int> vec_of_x_moduls = random_vec_var(x, vec_of_random_moduls);\n        vector< unsigned long long int> vec_of_y_moduls = random_vec_var(y, vec_of_random_moduls);\n        auto start0 = std::chrono::system_clock::now();\n        unsigned long long int rezult_pryk = rezultat_classic(vec_of_random_moduls, x, y);\n        auto end0 = std::chrono::system_clock::now();\n\n        //std::cout << \"finished computation in classic \" << std::chrono::duration_cast<std::chrono::nanoseconds>(end0 - start0).count() << \" nanoseconds\\n\";\n        outputFile << \"finished computation in classic \" << std::chrono::duration_cast<std::chrono::nanoseconds>(end0 - start0).count() << \" nanoseconds\\n\";\n\n        auto start = std::chrono::system_clock::now();\n        unsigned long long int final_rez = chinies_metod(vec_rez(vec_of_random_moduls, vec_of_x_moduls, vec_of_y_moduls), vec_of_random_moduls);\n        auto end = std::chrono::system_clock::now();\n        cout << final_rez<<\"\\n\";\n        //std::cout << \"finished computation in \" << std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() << \" nanoseconds\\n\";\n        outputFile << \"finished computation in \" << std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() << \" nanoseconds\\n\";\n        if (std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() < std::chrono::duration_cast<std::chrono::nanoseconds>(end0 - start0).count()) rate++;\n    }\n    cout << rate / (repit / 100);\n    outputFile << \"Rate \" << rate / (repit / 100);\n    outputFile.close();\n}\n\n",
    "//\r\n// Copyright (C) 2016 Google, Inc.\r\n//\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions\r\n// are met:\r\n//\r\n//    Redistributions of source code must retain the above copyright\r\n//    notice, this list of conditions and the following disclaimer.\r\n//\r\n//    Redistributions in binary form must reproduce the above\r\n//    copyright notice, this list of conditions and the following\r\n//    disclaimer in the documentation and/or other materials provided\r\n//    with the distribution.\r\n//\r\n//    Neither the name of Google, Inc., nor the names of its\r\n//    contributors may be used to endorse or promote products derived\r\n//    from this software without specific prior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\r\n// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\r\n// COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\r\n// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\r\n// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n\r\n#include \"hlslTokenStream.h\"\r\n\r\nnamespace glslang {\r\n\r\nvoid HlslTokenStream::pushPreToken(const HlslToken& tok)\r\n{\r\n    assert(preTokenStackSize < tokenBufferSize);\r\n    preTokenStack[preTokenStackSize++] = tok;\r\n}\r\n\r\nHlslToken HlslTokenStream::popPreToken()\r\n{\r\n    assert(preTokenStackSize > 0);\r\n\r\n    return preTokenStack[--preTokenStackSize];\r\n}\r\n\r\nvoid HlslTokenStream::pushTokenBuffer(const HlslToken& tok)\r\n{\r\n    tokenBuffer[tokenBufferPos] = tok;\r\n    tokenBufferPos = (tokenBufferPos+1) % tokenBufferSize;\r\n}\r\n\r\nHlslToken HlslTokenStream::popTokenBuffer()\r\n{\r\n    // Back up\r\n    tokenBufferPos = (tokenBufferPos+tokenBufferSize-1) % tokenBufferSize;\r\n\r\n    return tokenBuffer[tokenBufferPos];\r\n}\r\n\r\n//\r\n// Make a new source of tokens, not from the source, but from an\r\n// already pre-processed token stream.\r\n//\r\n// This interrupts current token processing which must be restored\r\n// later.  Some simplifying assumptions are made (and asserted).\r\n//\r\nvoid HlslTokenStream::pushTokenStream(const TVector<HlslToken>* tokens)\r\n{\r\n    // not yet setup to interrupt a stream that has been receded\r\n    // and not yet reconsumed\r\n    assert(preTokenStackSize == 0);\r\n\r\n    // save current state\r\n    currentTokenStack.push_back(token);\r\n\r\n    // set up new token stream\r\n    tokenStreamStack.push_back(tokens);\r\n\r\n    // start position at first token:\r\n    token = (*tokens)[0];\r\n    tokenPosition.push_back(0);\r\n}\r\n\r\n// Undo pushTokenStream(), see above\r\nvoid HlslTokenStream::popTokenStream()\r\n{\r\n    tokenStreamStack.pop_back();\r\n    tokenPosition.pop_back();\r\n    token = currentTokenStack.back();\r\n    currentTokenStack.pop_back();\r\n}\r\n\r\n// Load 'token' with the next token in the stream of tokens.\r\nvoid HlslTokenStream::advanceToken()\r\n{\r\n    pushTokenBuffer(token);\r\n    if (preTokenStackSize > 0)\r\n        token = popPreToken();\r\n    else {\r\n        if (tokenStreamStack.size() == 0)\r\n            scanner.tokenize(token);\r\n        else {\r\n            ++tokenPosition.back();\r\n            if (tokenPosition.back() >= (int)tokenStreamStack.back()->size())\r\n                token.tokenClass = EHTokNone;\r\n            else\r\n                token = (*tokenStreamStack.back())[tokenPosition.back()];\r\n        }\r\n    }\r\n}\r\n\r\nvoid HlslTokenStream::recedeToken()\r\n{\r\n    pushPreToken(token);\r\n    token = popTokenBuffer();\r\n}\r\n\r\n// Return the current token class.\r\nEHlslTokenClass HlslTokenStream::peek() const\r\n{\r\n    return token.tokenClass;\r\n}\r\n\r\n// Return true, without advancing to the next token, if the current token is\r\n// the expected (passed in) token class.\r\nbool HlslTokenStream::peekTokenClass(EHlslTokenClass tokenClass) const\r\n{\r\n    return peek() == tokenClass;\r\n}\r\n\r\n// Return true and advance to the next token if the current token is the\r\n// expected (passed in) token class.\r\nbool HlslTokenStream::acceptTokenClass(EHlslTokenClass tokenClass)\r\n{\r\n    if (peekTokenClass(tokenClass)) {\r\n        advanceToken();\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n} // end namespace glslang\r\n",
    "#include <iostream>\r\n#include <mpi.h>\r\n#include <opencv2/opencv.hpp>\r\n\r\nusing namespace cv;\r\n\r\nint mandelbrot(double cr, double ci, int max_iter) {\r\n    double zr = 0.0, zi = 0.0;\r\n    int n = 0;\r\n\r\n    while (n < max_iter && zr * zr + zi * zi < 4.0) {\r\n        double temp = zr * zr - zi * zi + cr;\r\n        zi = 2.0 * zr * zi + ci;\r\n        zr = temp;\r\n        n++;\r\n    }\r\n\r\n    return n;\r\n}\r\n\r\nVec3b getPastelColor(int n) {\r\n    int r = 127 + 63 * sin(0.1 * n);\r\n    int g = 127 + 63 * sin(0.2 * n);\r\n    int b = 127 + 63 * sin(0.3 * n);\r\n    return Vec3b(r, g, b);\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n    MPI_Init(&argc, &argv);\r\n\r\n    int rank, size;\r\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\r\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\r\n\r\n    int width = 800;\r\n    int height = 800;\r\n    double xmin = -2.0;\r\n    double xmax = 1.0;\r\n    double ymin = -1.5;\r\n    double ymax = 1.5;\r\n    int max_iter = 1000;\r\n\r\n    Mat image(height, width, CV_8UC3);\r\n\r\n    int rows_per_process = height / size;\r\n    int start_row = rank * rows_per_process;\r\n    int end_row = (rank == size - 1) ? height : start_row + rows_per_process;\r\n\r\n    for (int y = start_row; y < end_row; y++) {\r\n        for (int x = 0; x < width; x++) {\r\n            double cr = xmin + (xmax - xmin) * x / width;\r\n            double ci = ymin + (ymax - ymin) * y / height;\r\n            int iterations = mandelbrot(cr, ci, max_iter);\r\n\r\n            if (iterations == max_iter) {\r\n                image.at<Vec3b>(y, x) = Vec3b(0, 0, 0); \r\n            }\r\n            else {\r\n                image.at<Vec3b>(y, x) = getPastelColor(iterations); \r\n            }\r\n        }\r\n    }\r\n\r\n    if (rank == 0) {\r\n        Mat result_image(height, width, CV_8UC3);\r\n        MPI_Gather(image.data, width * rows_per_process * 3, MPI_UNSIGNED_CHAR,\r\n            result_image.data, width * rows_per_process * 3, MPI_UNSIGNED_CHAR,\r\n            0, MPI_COMM_WORLD);\r\n\r\n        namedWindow(\"Mandelbrot Fractal\", WINDOW_NORMAL);\r\n        imshow(\"Mandelbrot Fractal\", result_image);\r\n        waitKey(0);\r\n    }\r\n\r\n    MPI_Finalize();\r\n    return 0;\r\n}\r\n",
    "#include \"app.hpp\"\n\nApp::App(int w, int h) {\n    height = h;\n    width = w;\n    life = Life(width, height);\n    isRecording = false;\n    tick = 0;\n}\n\nvoid App::start() {\n    sf::Event event;\n    window = new sf::RenderWindow(sf::VideoMode(width*10, height*10), \"The Game of Life\");\n    texture = new sf::RenderTexture();\n    texture->create(width*10, height*10);\n    window->setFramerateLimit(60);\n    while (window->isOpen()) {\n        while (window->pollEvent(event)) {\n            handleEvent(event);\n        }\n        render();\n        tick++;\n    }\n    delete window;\n    delete texture;\n}\n\nvoid App::handleEvent(sf::Event& event) {\n    if (event.type == sf::Event::Closed) {\n        window->close();\n    }\n    if (event.type == sf::Event::KeyPressed) {\n        switch (event.key.code) {\n            case sf::Keyboard::R:\n                life = Life(width, height);\n                break;\n            case sf::Keyboard::S:\n                isRecording = !isRecording;\n                break;\n            case sf::Keyboard::Q:\n            case sf::Keyboard::Escape:\n                window->close();\n                break;\n            default:\n                break;\n        }\n    }\n}\n\nvoid App::sleep() {\n    std::this_thread::sleep_for(350ms);\n}\n\nvoid App::drawLiveCells() {\n    \n    float XSCALE = 10.0, YSCALE = 10.0;\n    sf::RectangleShape rect;\n    rect.setSize(sf::Vector2f(XSCALE, YSCALE));\n    rect.setFillColor(sf::Color::Green);\n    auto coords = life.doTick();\n    texture->clear(sf::Color::Black);\n    for (auto m : coords) {\n        rect.setPosition(m.first*XSCALE, m.second*YSCALE);\n        texture->draw(rect);\n    }\n    texture->display();\n}\n\nvoid App::render() {\n    drawLiveCells();\n    window->clear();\n    sf::Sprite sprite(texture->getTexture());\n    window->draw(sprite);\n    window->display();\n    if (isRecording) saveDisplay();\n    sleep();\n}\n\nvoid App::saveDisplay() {\n    string name = \"tick\" + to_string(tick) + \".png\";\n    sf::Image image = texture->getTexture().copyToImage();\n    image.saveToFile(name);\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecommerce\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <thread>\n#include <atomic>\n#include <chrono>\n\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00f0\u00ee\u00e7\u00f0\u00e0\u00f5\u00f3\u00ed\u00ea\u00f3 \u00f4\u00e0\u00ea\u00f2\u00ee\u00f0\u00b3\u00e0\u00eb\u00f3 \u00f7\u00e8\u00f1\u00eb\u00e0\nint f(int x) {\n    if (x < 0) return 0;\n    long long factorial = 1;\n    for (int i = 1; i <= x; ++i) {\n        factorial *= i;\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n    return factorial > 0 ? 1 : 0;\n}\n\n// \u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00e4\u00eb\u00ff \u00ef\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ea\u00e8, \u00f7\u00e8 \u00ba \u00f7\u00e8\u00f1\u00eb\u00ee \u00ef\u00f0\u00ee\u00f1\u00f2\u00e8\u00ec\nint g(int x) {\n    if (x <= 1) return 0;\n    for (int i = 2; i * i <= x; ++i) {\n        if (x % i == 0) return 0;\n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n    return 1;\n}\n\n// \u00c3\u00ee\u00eb\u00ee\u00e2\u00ed\u00e0 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00e0\nint main() {\n    int x;\n    std::cout << \"Enter the value of x: \";\n    std::cin >> x;\n\n    std::atomic<bool> result_f{ false }, result_g{ false };\n    std::atomic<bool> computed_f{ false }, computed_g{ false };\n\n    // \u00cf\u00ee\u00f2\u00ee\u00ea \u00e4\u00eb\u00ff f(x)\n    std::thread thread_f([&]() {\n        int res = f(x);\n        result_f = res != 0;\n        computed_f = true;\n        });\n\n    // \u00cf\u00ee\u00f2\u00ee\u00ea \u00e4\u00eb\u00ff g(x)\n    std::thread thread_g([&]() {\n        int res = g(x);\n        result_g = res != 0;\n        computed_g = true;\n        });\n\n    // \u00cf\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ea\u00e0 \u00f1\u00f2\u00e0\u00ed\u00f3 \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00fc\n    while (!computed_f || !computed_g) {\n        std::this_thread::sleep_for(std::chrono::seconds(10)); // \u00d7\u00e5\u00ea\u00e0\u00ba\u00ec\u00ee 10 \u00f1\u00e5\u00ea\u00f3\u00ed\u00e4\n\n        if (!computed_f && !computed_g) {\n            std::cout << \"Both calculations are still ongoing.\\n\";\n        }\n        else if (!computed_f) {\n            std::cout << \"The calculation of f(x) is still in progress.\\n\";\n        }\n        else if (!computed_g) {\n            std::cout << \"The computation of g(x) is still in progress.\\n\";\n        }\n\n        std::cout << \"1) Continue calculation, 2) Stop, 3) Continue without asking more: \";\n        int choice;\n        std::cin >> choice;\n        if (choice == 2) break;\n        if (choice == 3) {\n            while (!computed_f || !computed_g) {\n                std::this_thread::sleep_for(std::chrono::seconds(10));\n            }\n            break;\n        }\n    }\n\n    bool final_result = result_f && result_g;\n    if (computed_f && computed_g) {\n        std::cout << \"Result f(x) && g(x): \" << final_result << std::endl;\n    }\n    else {\n        std::cout << \"The calculation was interrupted.\" << std::endl;\n    }\n\n    thread_f.join();\n    thread_g.join();\n    return 0;\n}\n\n\n",
    "\ufeff\n#include <iostream>//\u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043d\u0443\u0436\u043d\u044b\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438\n#include <vector>\n#include <string>\n#include <Windows.h>\n\nusing namespace std;\nclass Line // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043b\u0430\u0441\u0441, \u0445\u0440\u0430\u043d\u044f\u0449\u0438\u0439 \u0432 \u0441\u0435\u0431\u0435 \u043e\u0434\u043d\u0443 \u0441\u0442\u0440\u043e\u043a\u0443 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u043a\u043d\u0438\u0433\u0435\n{\n\tstring a;\n\tstring b;\n\tstring c;\n\tstring d;\n\tstring e;\n\tstring f;\npublic:// \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0435\u0442\u043e\u0434\u044b \u0432\u044b\u0432\u043e\u0434\u0430 \u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445 \u0432 \u0435\u0434\u0438\u043d\u0438\u0446\u0435 \u043a\u043b\u0430\u0441\u0441\u0430\n\tvoid changeA(string z)\n\t{\n\t\ta = z;\n\t};\n\tvoid changeB(string z)\n\t{\n\t\tb = z;\n\t};\n\tvoid changeC(string z)\n\t{\n\t\tc = z;\n\t};\n\tvoid changeD(string z)\n\t{\n\t\td = z;\n\t};\n\tvoid changeE(string z)\n\t{\n\t\te = z;\n\t};\n\tvoid changeF(string z)\n\t{\n\t\tf = z;\n\t};\n\tstring retA()\n\t{\n\t\treturn a;\n\t};\n\tstring retB()\n\t{\n\t\treturn b;\n\t};\n\tstring retC()\n\t{\n\t\treturn c;\n\t};\n\tstring retD()\n\t{\n\t\treturn d;\n\t};\n\tstring retE()\n\t{\n\t\treturn e;\n\t};\n\tstring retF()\n\t{\n\t\treturn f;\n\t};\n};\n\nvoid retFull(vector<Line> mas) // \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0432\u0435\u0441\u044c \u0441\u043f\u0438\u0441\u043e\u043a\n{\n\tfor (int i = 0; i < mas.size(); i++) \n\t{\n\t\tcout << mas[i].retA() << \" | \" << mas[i].retB() << \" | \" << mas[i].retC() << \" | \" << mas[i].retD() << \" | \" << mas[i].retE() << \"| \" << mas[i].retF() << endl;\n\t}\n}\n\nvoid retNum(vector<Line> mas, string a) //\u0412\u044b\u0432\u043e\u0434\u0438\u043c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u043d\u043e\u043c\u0435\u0440\u0443\n{\n\tint x = 0;\n\tfor (int i = 0; i < mas.size(); i++)\n\t{\n\t\tif (a == mas[i].retB())\n\t\t{\n\t\t\tcout << mas[i].retA() << \" | \" << mas[i].retB() << \" | \" << mas[i].retC() << \" | \" << mas[i].retD() << \" | \" << mas[i].retE() << \"| \" << mas[i].retF() << endl;\n\t\t\tx = x + 1;\n\t\t}\n\t\telse if ((i == (mas.size() - 1)) && x == 0)\n\t\t{\n\t\t\tcout << \"\u0414\u0430\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0441\u043f\u0438\u0441\u043a\u0435\";\n\t\t}\n\t}\n}\n\nvoid retNaz(vector<Line> mas, string a) //\u0412\u044b\u0432\u043e\u0434\u0438\u043c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044e\n{\n\tint x = 0;\n\tfor (int i = 0; i < mas.size(); i++)\n\t{\n\t\tif (a == mas[i].retA())\n\t\t{\n\t\t\tcout << mas[i].retA() << \" | \" << mas[i].retB() << \" | \" << mas[i].retC() << \" | \" << mas[i].retD() << \" | \" << mas[i].retE() << \"| \" << mas[i].retF() << endl;\n\t\t\tx = x + 1;\n\t\t}\n\t\telse if ((i == (mas.size() - 1)) && x == 0)\n\t\t{\n\t\t\tcout << \"\u0414\u0430\u043d\u043d\u043e\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0441\u043f\u0438\u0441\u043a\u0435\";\n\t\t}\n\t}\n}\n\nvoid retAuth(vector<Line> mas, string a) //\u0412\u044b\u0432\u043e\u0434\u0438\u043c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u0430\u0432\u0442\u043e\u0440\u0443\n{\n\tint x = 0;\n\tfor (int i = 0; i < mas.size(); i++) \n\t{\n\t\tif (a == mas[i].retC())\n\t\t{\n\t\t\tcout << mas[i].retA() << \" | \" << mas[i].retB() << \" | \" << mas[i].retC() << \" | \" << mas[i].retD() << \" | \" << mas[i].retE() << \"| \" << mas[i].retF() << endl;\n\t\t\tx = x + 1;\n\t\t}\n\t\telse if((i == (mas.size() - 1)) && x == 0)\n\t\t{\n\t\t\tcout << \"\u0414\u0430\u043d\u043d\u044b\u0439 \u0430\u0432\u0442\u043e\u0440 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0441\u043f\u0438\u0441\u043a\u0435\";\n\t\t}\n\t}\n}\nvoid retIzd(vector<Line> mas, string a) //\u0412\u044b\u0432\u043e\u0434\u0438\u043c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0443\n{\n\tint x = 0;\n\tfor (int i = 0; i < mas.size(); i++)\n\t{\n\t\tif (a == mas[i].retE())\n\t\t{\n\t\t\tcout << mas[i].retA() << \" | \" << mas[i].retB() << \" | \" << mas[i].retC() << \" | \" << mas[i].retD() << \" | \" << mas[i].retE() << \"| \" << mas[i].retF() << endl;\n\t\t\tx = x + 1;\n\t\t}\n\t\telse if ((i == (mas.size() - 1)) && x == 0)\n\t\t{\n\t\t\tcout << \"\u0414\u0430\u043d\u043d\u043e\u0435 \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u043e \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0441\u043f\u0438\u0441\u043a\u0435\";\n\t\t}\n\t}\n}\nvoid retYear(vector<Line> mas, string a) //\u0412\u044b\u0432\u043e\u0434\u0438\u043c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u0433\u043e\u0434\u0443\n{\n\tint x = 0;\n\tfor (int i = 0; i < mas.size(); i++)\n\t{\n\t\tif (a == mas[i].retD())\n\t\t{\n\t\t\tcout << mas[i].retA() << \" | \" << mas[i].retB() << \" | \" << mas[i].retC() << \" | \" << mas[i].retD() << \" | \" << mas[i].retE() << \"| \" << mas[i].retF() << endl;\n\t\t\tx = x + 1;\n\t\t}\n\t\telse if ((i == (mas.size() - 1)) && x == 0)\n\t\t{\n\t\t\tcout << \"\u0414\u0430\u043d\u043d\u044b\u0439 \u0433\u043e\u0434 \u0438\u0437\u0434\u0430\u043d\u0438\u044f \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0441\u043f\u0438\u0441\u043a\u0435\";\n\t\t}\n\t}\n}\nint main()\n{\n\tsetlocale(LC_ALL, \"Russian\");//\u0423\u0447\u0438\u043c \u043a\u043e\u043d\u0441\u043e\u043b\u044c \u0440\u0443\u0441\u0441\u043a\u043e\u043c\u0443 \u044f\u0437\u044b\u043a\u0443\n\tSetConsoleCP(1251);\n\tSetConsoleOutputCP(1251);\n\tLine a; // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043a\u043b\u0430\u0441\u0441\u0430 Line\n\tint n = 1;// \u0412\u0432\u043e\u0434\u0438\u043c \u0431\u0430\u0437\u043e\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u0435\n\tvector<Line> mas(n); // \u0421\u043e\u0437\u0434\u0430\u0435\u043c\u043c \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043a\u043b\u0430\u0441\u0441\u0430 Line\n\ta.changeA(\"\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435\"); // \u0417\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u043f\u0435\u0440\u0432\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n\ta.changeB(\"\u0418\u0434\u0435\u043d\u0442\u0435\u0444\u0438\u043a\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\");\n\ta.changeC(\"\u0410\u0432\u0442\u043e\u0440\");\n\ta.changeD(\"\u0413\u043e\u0434 \u0438\u0437\u0434\u0430\u043d\u0438\u044f\");\n\ta.changeE(\"\u0418\u0437\u0434\u0430\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u043e\");\n\ta.changeF(\"\u0421\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043d\u0430 \u043f\u0440\u043e\u0448\u043b\u044b\u0439 \u0433\u043e\u0434\");\n\tmas[0] = a;//\u041f\u0440\u0438\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u043d\u0443\u043b\u0435\u0432\u043e\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043a \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435\n\tint d = 0;\n\tstring z;\n\twhile (true)\n\t{\n\t\tcout << \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0437\u0430\u043f\u0443\u0449\u0435\u043d\u0430, \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u0443\u0436\u043d\u0443\u044e \u0432\u0430\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u0438 \u0432\u0432\u0434\u0438\u0442\u0435 \u0435\u0435 \u043d\u043e\u043c\u0435\u0440 \u0442\u043e\u043b\u044c\u043a\u043e \u0447\u0438\u0441\u043b\u043e\u043c\" << endl;// \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \n\t\tcout << \"1. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043a\u043d\u0438\u0433\u0443 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a\" << endl;\n\t\tcout << \"2. \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u043a\u043d\u0438\u0433\u0443 \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430\" << endl;\n\t\tcout << \"3. \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0432\u0435\u0441\u044c \u0441\u043f\u0438\u0441\u043e\u043a\" << endl;\n\t\tcout << \"4. \u041d\u0430\u0439\u0442\u0438 \u043a\u043d\u0438\u0433\u0443 \u043f\u043e \u0438\u0434\u0435\u043d\u0442\u0435\u0444\u0438\u043a\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u043c\u0443 \u043d\u043e\u043c\u0435\u0440\u0443\" << endl;\n\t\tcout << \"5. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044e\" << endl;\n\t\tcout << \"6. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u0430\u0432\u0442\u043e\u0440\u0443\" << endl;\n\t\tcout << \"7. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0443\" << endl;\n\t\tcout << \"8. \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u043d\u0438\u0433\u0438 \u043f\u043e \u0433\u043e\u0434\u0443 \u0438\u0437\u0434\u0430\u043d\u0438\u044f\" << endl;\n\t\tcout << \"9. \u0418\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043d\u0430 \u043f\u0440\u043e\u0448\u043b\u044b\u0439 \u0433\u043e\u0434\" << endl;\n\t\tcin >> d;// \u0421\u043d\u0438\u043c\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e d \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0435\u0442\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u043e \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0430\u043c \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\n\t\tif (d == 1)\n\t\t{\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435\" << endl;\n\t\t\tcin >> z;\n\t\t\ta.changeA(z);\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u0434\u0435\u043d\u0442\u0435\u0444\u0438\u043a\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\" << endl;\n\t\t\tcin >> z;\n\t\t\ta.changeB(z);\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0430\u0432\u0442\u043e\u0440\u0430\" << endl;\n\t\t\tcin >> z;\n\t\t\ta.changeC(z);\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0433\u043e\u0434 \u0438\u0437\u0434\u0430\u043d\u0438\u044f\" << endl;\n\t\t\tcin >> z;\n\t\t\ta.changeD(z);\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u043e\" << endl;\n\t\t\tcin >> z;\n\t\t\ta.chang",
    "// reading an entire binary file\n#include \"header/zipHeader.h\"\n#include <iostream>\n#include <fstream>\n#include <memory>\n\nvoid printRawFile(const char *data, int size)\n{\n    if (size > 0)\n    {\n        std::cout << \"\\n----------START-----------\\n\";\n        for (int i = 0; i < size; i++)\n        {\n            std::cout << data[i];\n        }\n        std::cout << \"\\n----------END-----------\\n\";\n    }\n}\n\nint main()\n{\n    std::streampos size;\n    std::unique_ptr<char *> memblock;\n\n    std::ifstream file(\"ch5.zip\", std::ios::in | std::ios::binary | std::ios::ate);\n    if (file.is_open())\n    {\n        size = file.tellg();\n        memblock = std::make_unique<char *>(new char[size]);\n        file.seekg(0, std::ios::beg);\n        file.read(*memblock, size);\n        file.close();\n\n        std::cout << \"the entire file content is in memory:\\n\";\n        printRawFile(*memblock, size);\n        ZipHeader header{std::move(memblock), size};\n        std::cout << header<<std::endl;\n    }\n    else\n    {\n        std::cout << \"Unable to open file\";\n    }\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n// UNSUPPORTED: c++98, c++03\n\n// <fstream>\n\n// template <class charT, class traits = char_traits<charT> >\n// class basic_fstream\n\n// basic_fstream(basic_fstream&& rhs);\n\n#include <fstream>\n#include <cassert>\n#include \"platform_support.h\"\n\nint main()\n{\n    std::string temp = get_temp_file_name();\n    {\n        std::fstream fso(temp, std::ios_base::in | std::ios_base::out\n                                                 | std::ios_base::trunc);\n        std::fstream fs = move(fso);\n        double x = 0;\n        fs << 3.25;\n        fs.seekg(0);\n        fs >> x;\n        assert(x == 3.25);\n    }\n    std::remove(temp.c_str());\n    {\n        std::wfstream fso(temp, std::ios_base::in | std::ios_base::out\n                                                  | std::ios_base::trunc);\n        std::wfstream fs = move(fso);\n        double x = 0;\n        fs << 3.25;\n        fs.seekg(0);\n        fs >> x;\n        assert(x == 3.25);\n    }\n    std::remove(temp.c_str());\n}\n",
    "#include<iostream>\n#include<iomanip>\n\nusing namespace std;\ntypedef int Info;\n\nstruct Node\n{\n\tNode* next;\n\tInfo info;\n};\n\nvoid Insert(Node*& L, Info info)\n{\n\tNode* tmp = new Node; \n\ttmp->info = info;\n\tif (L != NULL)\n\t{\n\t\tNode* T = L;\n\t\twhile (T->next != L)\n\t\t\tT = T->next; \n\t\tT->next = tmp; \n\t}\n\telse\n\t{\n\t\tL = tmp; \n\t}\n\ttmp->next = L;\n}\n\nvoid Print(Node* L)\n{\n\tif (L == NULL)\n\t\treturn;\n\tNode* first = L;\n\tcout << setw(4) << L->info;\n\twhile (L->next != first)\n\t{\n\t\tL = L->next;\n\t\tcout << setw(4) << L->info;\n\t}\n\tcout << endl;\n}\n\n\nint sumOfEvenElements(Node* head)\n{\n\tint sum = 0;\n\tNode* curr = head;\n\n\tdo\n\t{\n\t\tif (curr->info % 2 == 0) // \u00ef\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ff\u00ba\u00ec\u00ee, \u00f7\u00e8 \u00ba \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00ef\u00e0\u00f0\u00ed\u00e8\u00ec\n\t\t{\n\t\t\tsum += curr->info; // \u00e4\u00ee\u00e4\u00e0\u00ba\u00ec\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00e4\u00ee \u00f1\u00f3\u00ec\u00e8\n\t\t}\n\t\tcurr = curr->next;\n\t} while (curr != head);\n\n\treturn sum;\n}\n\nint main()\n{\n\tNode* L = NULL;\n\n\tInsert(L, 23);\n\tInsert(L, 18);\n\tInsert(L, 45);\n\tInsert(L, 27);\n\tInsert(L, 34);\n\tInsert(L, 57);\n\tInsert(L, 64);\n\n\tcout << \"List: \";\n\tPrint(L);\n\tcout << endl;\n\n\tcout << \"Sum of even elements: \" << sumOfEvenElements(L) << endl;\n\n\treturn 0;\n}\n",
    "#include <ctype.h>\n#include <errno.h>\n#include <iostream> \n#include <stdio.h> \n#include <string.h> \n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h> \n\nvoid CreatePipe(int process[])\n{\n    if( pipe(process) < 0 )\n    {\n        std::cerr << \"CreatePipe() failed...\\n\";\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid Write(int pipe[], char output[], const int &SIZE, int &n_bytes)\n{\n    if( n_bytes = write(pipe[1], output, SIZE) < 0 )\n    {\n        std::cerr << \"Write() failed...\\n\";\n        exit(EXIT_FAILURE);        \n    }\n}\n\nvoid Read(int pipe[], char input[], const int &SIZE, int &n_bytes)\n{\n    memset(input, 0, SIZE);\n    if( n_bytes = read(pipe[0], input, SIZE) < 0 )\n    {\n        std::cerr << \"Read() failed...\\n\";\n        exit(EXIT_FAILURE);            \n    }\n}\n\nint main(int argc, char *argv[])\n{\n    const int SIZE = 30;\n    char message[] = \"This is some message.\";\n    char response[] = \"OK... response here.\";\n\n    bool is_running;\n    char bufferA[SIZE];\n    char bufferB[SIZE];\n\n    int pipeA[2];        \n    int pipeB[2];        \n    int pid; \n    int n_bytes;\n    // int length = strlen(message) + 1;\n\n    // create pipes\n    CreatePipe(pipeA);\n    CreatePipe(pipeB);\n\n    // create children\n    pid = fork();\n\n    // parent process\n    if( pid > 0 )\n    {\n        Write(pipeA, message, SIZE, n_bytes);\n        Read(pipeB, bufferA, SIZE, n_bytes);\n        std::cout << \"Parent received -> \" << bufferA << std::endl;\n    }\n    else\n    {\n        Read(pipeA, bufferB, SIZE, n_bytes);\n        std::cout << \"Child received -> \" << bufferB << std::endl;\n        Write(pipeB, response, SIZE, n_bytes);\n    }\n\n    return EXIT_SUCCESS;\n}",
    "#include \"Innerbounds.h\"\n#include \"car.h\"\n#include <QGraphicsPolygonItem>\n#include <QTimer>\n#include <QDebug>\n#include \"GameScene.h\"\n\nInnerbounds::Innerbounds(): QGraphicsPolygonItem()\n{\n    // creating vector for inner polygon\n    QVector<QPointF> points_inn;\n\n    points_inn << QPointF(2.4,0.4) << QPointF(16,0.4) << QPointF(18.4,2.8) << QPointF(18.4,14.7) << QPointF(16,17) << QPointF(2.4,17)\n               << QPointF(0,14.7) << QPointF(0,2.8);\n\n    // scaling points\n    int scale_inner = 29;\n    for (size_t i=0, n = points_inn.size(); i < n; i++){\n        points_inn[i] *= scale_inner;\n    }\n\n    // create polygons from points\n    QPolygonF inn_poly(points_inn);\n\n    // create QGraphicsPolygonItem\n    inner_poly = new QGraphicsPolygonItem(inn_poly,this);\n    inner_poly->setPos(135,128);\n    inner_poly->setOpacity(0);\n\n    QTimer * timer = new QTimer();\n    connect(timer,SIGNAL(timeout()),this,SLOT(checkCollision()));\n\n    timer->start(1);\n\n}\n\nvoid Innerbounds::setTheCar(Car *value)\n{\n    theCar = value;\n}\n\nvoid Innerbounds::checkCollision()\n{\n\n    // check collision between car and polygon to cause an elastic hit\n    QList<QGraphicsItem *> colliding_with_inner = inner_poly->collidingItems();\n\n    bool flag = false;\n\n        for (int i=0, n=colliding_with_inner.size(); i<n; ++i){\n            if (typeid(*(colliding_with_inner[i])) == typeid(Car)){\n\n                flag = true;\n            }\n        }\n\n        if (!flag) {canrebounce=true;}\n        if (flag && canrebounce){theCar->rebounce();canrebounce=false;}\n\n}\n",
    "#include <Arduino.h>\n#include <ezButton.h>\n\n// Generic constants\nconst long mspm = 60000; // Milliseconds per minute\n\n// Set up valve constants\nconst int   v1_pin    = 10;         // Valve 1 pin number\nconst float v1_rpd    = float(1)/float(2);        // Valve 1 runs per day\nconst long  v1_ms     = 10*mspm;    // Number of milliseconds to run valve 1\nbool        v1_actv   = 0;          // Boolean to tell whether valve 1 is currently active\nbool        istimer1  = 0;          // Boolean to tell whether a timer is currently active or if the program was just initialized\n\nconst int   v2_pin    = 11;         // Valve 2 pin number\nconst float v2_rpd    = 1;          // Valve 2 runs per day\nconst long  v2_ms     = 5*mspm;     // Number of milliseconds to run valve 2\nbool        v2_actv   = 0;          // Boolean to tell whether valve 1 is currently active\nbool        istimer2  = 0;          // Boolean to tell whether a timer is currently active or if the program was just initialized\n\n\nconst int    v3_pin    = 12;         // Valve 3 pin number\nconst float  v3_rpd    = float(1)/float(3);        // Valve 3 runs per day\nconst long   v3_ms     = 30*mspm;    // Number of milliseconds to run valve 3\nbool         v3_actv   = 0;          // Boolean to tell whether valve 1 is currently active\nbool         istimer3  = 0;          // Boolean to tell whether a timer is currently active or if the program was just initialized\n\n\n// Timing calculations\nconst long mspd = 24*60*mspm;     // Milliseconds per day\nconst long msv1 = mspd/v1_rpd;    // Number of milliseconds to wait until next valve 1 run\nconst long msv2 = mspd/v2_rpd;    // Number of milliseconds to wait until next valve 2 run\nconst long msv3 = mspd/v3_rpd;    // Number of milliseconds to wait until next valve 3 run\n\n// Set up switches\nconst int v1_switchPin  = 5; // Set pin 5 as the pin for valve 1 switch\nconst int v2_switchPin  = 6; // Set pin 6 as the pin for valve 2 switch\nconst int v3_switchPin  = 7; // Set pin 7 as the pin for valve 3 switch\n\nezButton S1(v1_switchPin);\nezButton S2(v2_switchPin);\nezButton S3(v3_switchPin);\nint S1state = 0;\nint S2state = 0;\nint S3state = 0;\n\nvoid setup() {\n\n  // Currently wired to main irrigation to garden bed an flowers\n  pinMode(v1_pin,OUTPUT);\n\n  // Currently wired to trees, texas ranger, and plumbagos\n  pinMode(v2_pin,OUTPUT);\n\n  // Currently not wired\n  pinMode(v3_pin,OUTPUT);\n\n  // Start Serial Connection\n  Serial.begin(9600);\n\n  // Set Button debounce timing\n  S1.setDebounceTime(5); // set debounce time to 50 milliseconds\n  S2.setDebounceTime(5); // set debounce time to 50 milliseconds\n  S3.setDebounceTime(5); // set debounce time to 50 milliseconds\n\n}\n\n// To initialize program with valves ON, set counters to delay times\n// long v1_count  = msv1;          // Inialize valve 1 counter\n// long v2_count  = msv2;          // Inialize valve 2 counter\n// long v3_count  = msv3;          // Inialize valve 3 counter\n\n// To initialize program with valves OFF, set counters to 1\nlong v1_count  = 2;          // Inialize valve 1 counter\nlong v2_count  = 2;          // Inialize valve 2 counter\nlong v3_count  = 2;          // Inialize valve 3 counter\n\nvoid loop() {\n\n  S1.loop();\n  S2.loop();\n  S3.loop();\n\n  S1state = S1.getState();\n  S2state = S2.getState();\n  S3state = S3.getState();\n\n  ////////////////\n  // VALVE 1 logic\n  ////////////////\n  if (v1_count>=msv1 && !v2_actv && !v3_actv) {\n    v1_actv = 1; // Set valve 1 as active\n    digitalWrite(v1_pin, HIGH); // Turn on valve 1\n    v1_count = 1; // Reset valve 1 counter\n    istimer1 = 1; // Set timer 1 boolean to on\n\n    Serial.print(\"Valve 1 timer is active!\\n\");\n  }\n\n  if (v1_actv && v1_count==v1_ms) {\n    if (digitalRead(v1_switchPin)) {\n      digitalWrite(v1_pin, LOW); // Turn off valve 1, Wont turn off if valve's swtich is active, but will still reset timer boolean\n      v1_actv = 0; // Set valve 1 as inactive\n    }\n    istimer1 = 0; // Set timer 1 boolean to off\n\n    Serial.print(\"Valve 1 timer is up!\\n\");\n  }\n\n  // Option to manually activate valve 1 using a switch without affecting any of the counts\n  if (!S1state && !v1_actv) {\n    digitalWrite(v1_pin, HIGH); // Turn on valve 1\n    v1_actv = 1; // Set valve 1 as active\n\n    Serial.print(\"Valve 1 was turned on by the switch!\\n\");\n  }\n  if (S1state && v1_actv && !istimer1) { // Wont turn off if valve's timer is currently active \n    digitalWrite(v1_pin, LOW); // Turn off valve 1\n    v1_actv = 0; // Set valve 1 as inactive\n\n    Serial.print(\"Valve 1 was turned off by the switch!\\n\");\n  }\n\n  ////////////////\n  // VALVE 2 logic\n  ////////////////\n  if (v2_count>=msv2 && !v1_actv && !v3_actv) {\n    v2_actv = 1; // Set valve 2 as active\n    digitalWrite(v2_pin, HIGH); // Turn on valve 2\n    v2_count = 1; // Reset valve 2 counter\n    istimer2 = 1; // Set timer 2 boolean to on\n\n    Serial.print(\"Valve 2 timer is active!\\n\");\n  }\n\n  if (v2_actv && v2_count==v2_ms) { // Wont turn off if valve's swtich is active\n    if (digitalRead(v2_switchPi",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int PATIENTS = 5, SPECIALIZATION = 20;\n\nvector<vector<string>> specializations(SPECIALIZATION);\n\nvoid menu() {\n    cout << \"Enter your choice:\\n\";\n    cout << \"1) Add new patient.\\n\";\n    cout << \"2) Print all patients.\\n\";\n    cout << \"3) Get next patients.\\n\";\n    cout << \"4) Exit.\\n\";\n}\n\nint getSpecialization() {\n    int specialization;\n    do {\n        cout << \"Enter specialization number (1 - \" << SPECIALIZATION << \"):\\n\";\n        cin >> specialization;\n        specialization--;\n\n        if (specialization < 0 || specialization >= SPECIALIZATION) {\n            cout << \"Invalid specialization number. Please try again.\\n\";\n        }\n    } while (specialization < 0 || specialization >= SPECIALIZATION);\n\n    return specialization;\n}\n\nvoid addPatient(int specialization) {\n    if (specializations[specialization].size() >= PATIENTS) {\n        cout << \"Sorry, no available spots for this specialization.\\n\";\n        return;\n    }\n\n    string name;\n    cout << \"Pleas enter patient name: \\n\";\n    cin >> name;\n\n    int status;\n    cout << \"Please enter patient status (0 for regular, 1 for urgent): \\n\";\n    cin >> status;\n    string patient_info = name + \" (\" + (status == 1 ? \"urgent\" : \"regular\") + \").\";\n\n    if (status == 1)\n        specializations[specialization].insert(specializations[specialization].begin(), patient_info);\n    else\n        specializations[specialization].push_back(patient_info);\n\n}\n\nvoid printPatients() {\n    for (int i = 0; i < SPECIALIZATION; ++i) {\n\n        if (!specializations[i].empty()) {\n\n            cout << \"There are \" << specializations[i].size() << \" patients in specialization \" << i + 1 << \":\\n\";\n\n            for (const auto &patient: specializations[i]) {\n                cout << patient << '\\n';\n            }\n\n            cout << '\\n';\n        }\n\n    }\n}\n\nvoid getPatient(int specialization) {\n    if (specializations[specialization].empty()) {\n        cout << \"No patients for this specialization.\\n\";\n        return;\n    }\n\n    cout << specializations[specialization].front().substr(0, specializations[specialization].front().find('('))\n         << \"Please go with the doctor.\\n\";\n\n    specializations[specialization].erase(specializations[specialization].begin());\n}\n\nint main() {\n    int choice;\n\n    do {\n        menu();\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                addPatient(getSpecialization());\n                break;\n            case 2:\n                printPatients();\n                break;\n            case 3:\n                getPatient(getSpecialization());\n                break;\n            case 4:\n                cout << \"Exiting...\\n\";\n                break;\n            default:\n                cout << \"Invalid choice.\\n\";\n        }\n\n    } while (choice != 4);\n\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <windows.h>\r\n#include <direct.h>\r\n\r\nint main(void)\r\n{\r\n \tmkdir(\"data\");\r\n\tgo123:\r\n\tint abcd = 0;\r\n\tabcd = 0;\r\n\t//\ud30c\uc77c\uc0dd\uc131 \r\n\tint acc;\r\n\tFILE *open;\r\n\topen = fopen(\"data\\\\acc.txt\", \"a\");\r\n\tfprintf(open, \"%d\", 1);\r\n\tfclose(open);\r\n\t\r\n\topen = fopen(\"data\\\\acc.txt\", \"r\");\r\n\tfscanf(open, \"%d\", &acc);\r\n\tif(acc == 1)\r\n\t{\r\n\tprintf(\"\uc2e4\ud589\uc744 \uc704\ud574 \uc77c\ubd80 \ud30c\uc77c\uc744  \uc0dd\uc131\ud574\uc57c \ud569\ub2c8\ub2e4. [\ub3d9\uc758(1)/ \uac70\ubd80(2)]\\n\");\r\n\tscanf(\"%d\", &abcd);\r\n\tif (abcd == 2)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\uc2e4\ud589\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\");\r\n\t\trmdir(\"data\");\r\n\t\topen = fopen(\"data\\\\acc.txt\", \"w\");\r\n\t\tfprintf(open, \"%d\", 0);\r\n\t\tfclose(open);\r\n\t\tSleep(1300);\r\n\t\treturn 0; \r\n\t}\r\n\telse if(abcd == 1)\r\n\t{\r\n\tprintf(\"\uae30\ubcf8\uac12\uc744 \uc801\uc6a9\ud569\ub2c8\ub2e4\");\r\n\tSleep(500);\r\n\tprintf(\".\");\r\n\tSleep(500);\r\n\tprintf(\".\");\r\n\tSleep(500);\r\n\tprintf(\".\\n\");\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\ach.txt\", \"a\");\r\n\tprintf(\"\\n[ach.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\coin.txt\", \"a\");\r\n\tprintf(\"\\n[coin.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 500);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\cupon.txt\", \"a\");\r\n\tprintf(\"\\n[cupon.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\passcheck.txt\", \"a\");\r\n\tprintf(\"\\n[passcheck.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(500);\r\n\t\r\n\topen = fopen(\"data\\\\password.txt\", \"a\");\r\n\tprintf(\"\\n[password.txt] \ud30c\uc77c \uc0dd\uc131\ub428\");\r\n\tfprintf(open, \"%d\", 0);\r\n\tfclose(open);\r\n\tSleep(1500);\r\n\tprintf(\"\\n====================================\\n\");\r\n\tprintf(\"\uc2e4\ud589\uc900\ube44 \uc644\ub8cc!\");\r\n\tSleep(1500); \r\n\tsystem(\"cls\");\r\n\tgoto main343;\r\n\t}\r\n\t\r\n  }\r\n\telse \r\n\t{\r\n\t\tgoto main343;\r\n\t}\r\n\t//\ud30c\uc77c \uc0dd\uc131\r\n\tmain343: \r\n\tFILE *pass,*pass1,*pass2,*pass3;\r\n\tint p12;\r\n\tint a;\r\n\tint pas;\r\n\tint passcheck;\r\n\tint password[2]; \r\n\tmain1:\r\n\tprintf(\"-----------------------------------------------------------\\n\\n\\n\\n\\n           [R-S-P Game]\\n\\n\" );                \r\n\tSleep(700);\r\n\tprintf(\"                                                                                                          \uac00\uc704!\\n\");\r\n\tSleep(500);\r\n\tprintf(\"                                                                                                                  \ubc14\uc704!\\n\");\r\n\tSleep(500);\r\n\tprintf(\"                                                                                                                            \ubcf4!\\n\\n\");\r\n\tSleep(500);\r\n\tprintf(\"-------------------------Made by \ub9cc\ub4ec\uc774----------------------------------\\n\");\r\n\tSleep(500);\r\n\tprintf(\" \ub85c\ub529\uc911\");\r\n\tSleep(300);\r\n\tprintf(\".\"); \r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(300);\r\n\tprintf(\".\");\r\n\tSleep(700);\r\n\tSleep(600);  \r\n\tint h1;\r\n\tint c;//\ucf54\uc778 \r\n\tint h;//\ucfe0\ud3f0  \r\n\tFILE *in, *out, *ini, *outo, *inin, *outout;\r\n\tin = fopen(\"data\\\\coin.txt\", \"r\");\r\n\tini = fopen(\"data\\\\cupon.txt\", \"r\");\r\n\tinin = fopen(\"data\\\\ach.txt\", \"r\");\r\n\tif(in == NULL && ini == NULL && inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(in == NULL && ini == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(in == NULL && inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(ini == NULL && inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(in == NULL)\r\n\t{\t\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0; \r\n\t}\r\n\tif(ini == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tif(inin == NULL)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [ach.txt]\ub97c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.\\n\\n\");\r\n\t\tsystem(\"pause\");\r\n\t\treturn 0;\r\n\t}\r\n\tfscanf(in, \"%d\", &c);\r\n\tfscanf(ini, \"%d\", &h);\r\n\tfscanf(inin, \"%d\", &h1);\r\n\tif(c < 0 && h < 0 && h1 < 0)\r\n\t{\r\n\t\tprintf(\"\ub85c\ub529\uc2e4\ud328\");\r\n\t\tSleep(700); \r\n\t\tsystem(\"cls\");\r\n\t\tprintf(\"\\n\uc5d0\ub7ec! : [coin.txt]\uc758 \uac12\uc774 \uc798\ubabb \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\tc = 0; \r\n\t\tout = fopen(\"data\\\\coin.txt\", \"w\");\r\n        fprintf(out, \"%d\", c);\r\n\t    fclose(out);\r\n\t    printf(\"[\uc5d0\ub7ec\uc218\uc815..]\\n\\n\");\r\n\t    Sleep(1000);\r\n\t    printf(\"\\n\uc5d0\ub7ec! : [cupon.txt]\uc758 \uac12\uc774 \uc798\ubabb \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\th = 0;\r\n\t\touto = fopen(\"data\\\\cupon.txt\", \"w\");\r\n        fprintf(outo, \"%d\", h);\r\n\t    fclose(outo);\r\n\t    printf(\"[\uc5d0\ub7ec\uc218\uc815..]\\n\\n\"); \r\n\t    Sleep(500);\r\n\t    printf(\"\\n\uc5d0\ub7ec! : [ach.txt]\uc758 \uac12\uc774 \uc798\ubabb \ub418\uc5c8\uc2b5\ub2c8\ub2e4.\\n\");\r\n\t\th1 = 0; \r\n\t\toutout = fopen(\"",
    "/**\n * (03_util)\u5b9e\u7528\u5de5\u5177\n * wfl:2024-3-29\n*/\n// \u516c\u5171\u6a21\u5757\n// \u5b9a\u4e49\u51e0\u4e2a\u5b9e\u7528\u51fd\u6570\n// #pragma once\n\n#include \"util.hpp\"\n#include \"types.hpp\"\n#include <string.h>\n\n// long long\u7c7b\u578b\u6574\u6570\u4e3b\u673a\u5e8f\u8f6c\u4e3a\u7f51\u7edc\u5e8f\nvoid llton(long long ll,char*n){\n    // n[0]=ll>>56; n[1]=ll>>48; n[2]=ll>>40; n[3]=ll>>32;\n    // n[4]=ll>>24; n[5]=ll>>16; n[6]=ll>> 8; n[7]=ll>> 0;\n    for(int i=0;i<8;++i){\n        n[i]=ll>>(sizeof(ll)-i-1)*8;\n    }\n}\n// long long\u7c7b\u578b\u6574\u6570\u7f51\u7edc\u5e8f\u8f6c\u4e3a\u4e3b\u673a\u5e8f\nlong long ntoll(char const* n){\n    long long ll=0;\n    // ll|=(long long)(unsigned char)n[0]<<56;\n    // ll|=(long long)(unsigned char)n[1]<<48;\n    // ll|=(long long)(unsigned char)n[2]<<40;\n    for(int i=0;i<8;++i){\n        ll|=(long long)(unsigned char)n[i]<<(sizeof(ll)-i-1)*8;\n    }\n    return ll;\n}\n\n// long\u7c7b\u578b\u6574\u6570\u4e3b\u673a\u5e8f\u8f6c\u4e3a\u7f51\u7edc\u5e8f\nvoid lton(long l,char*n){\n    for(int i=0;i<8;++i){\n        n[i]=l>>(sizeof(l)-i-1)*8;\n    }\n}\n// long\u7c7b\u578b\u6574\u6570\u7f51\u7edc\u5e8f\u8f6c\u4e3a\u4e3b\u673a\u5e8f\nlong ntol(char const* n){\n    long l=0;\n    for(int i=0;i<8;++i){\n        l|=(long)(unsigned char)n[i]<<(sizeof(l)-i-1)*8;\n    }\n    return l;\n}\n\n// short\u7c7b\u578b\u6574\u6570\u4e3b\u673a\u5e8f\u8f6c\u4e3a\u7f51\u7edc\u5e8f\nvoid ston(short s,char*n){\n    for(int i=0;i<8;++i){\n        n[i]=s>>(sizeof(s)-i-1)*8;\n    }\n}\n// short\u7c7b\u578b\u6574\u6570\u7f51\u7edc\u5e8f\u8f6c\u4e3a\u4e3b\u673a\u5e8f\nshort ntos(char const* n){\n    short s;\n    for(int i=0;i<8;++i){\n        s|=(short)(unsigned char)n[i]<<(sizeof(s)-i-1)*8;\n    }\n    return s;\n}\n\n// \u5b57\u7b26\u4e32\u662f\u5426\u5408\u6cd5\uff0c\u5373\u662f\u5426\u53ea\u5305\u542b26\u4e2a\u56e0\u4e3a\u5b57\u6bcd\u5927\u5c0f\u5199\u548c0-9\u6570\u5b57\nint valid(char const* str){\n    if(!str) return ERROR;\n    size_t len=strlen(str);\n    if(!len) return ERROR;\n    for(size_t i=0;i<len;++i){\n        if(!(('a'<=str[i]&&str[i]<='z')||('A'<=str[i]&&str[i]<='Z')||('0'<=str[i]&&str[i]<='9')))\n            return ERROR;\n    }\n    return OK;\n}\n\n// \u4ee5\u5206\u53f7\u4e3a\u5206\u5272\u7b26\uff0c\u5c06\u4e00\u4e2a\u5b57\u7b26\u4e32\u62c6\u5206\u4e3a\u591a\u4e2a\u5b50\u5b57\u7b26\u4e32\nint split(char const* str,std::vector<std::string>& substrs){\n    // \u7c7b\u4f3cstrtok\u51fd\u6570\n    if(!str) return ERROR;\n    size_t len=strlen(str);\n    if(!len) return ERROR;\n    char *buf=new char[len+1];\n    strcpy(buf,str);\n    char const* sep=\"s\";\n    for(char *substr=strtok(buf,sep);substr;substr=strtok(nullptr,sep))\n        substrs.push_back(substr);\n    delete[] buf;\n    return OK;\n}\n\n",
    "/*\n * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.\n * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Changes from Qualcomm Innovation Center are provided under the following license:\n * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause-Clear\n */\n\n#define LOG_TAG \"vendor.qti.vibrator\"\n\n#include <cutils/properties.h>\n#include <dirent.h>\n#include <inttypes.h>\n#include <linux/input.h>\n#include <log/log.h>\n#include <string.h>\n#include <unistd.h>\n#include <bits/epoll_event.h>\n#include <sys/ioctl.h>\n#include <sys/epoll.h>\n#include <sys/poll.h>\n#include <thread>\n\n#include \"include/Vibrator.h\"\n#ifdef USE_EFFECT_STREAM\n#include \"effect.h\"\n#endif\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace vibrator {\n\n#define STRONG_MAGNITUDE        0x7fff\n#define MEDIUM_MAGNITUDE        0x5fff\n#define LIGHT_MAGNITUDE         0x3fff\n#define INVALID_VALUE           -1\n#define CUSTOM_DATA_LEN         3\n#define NAME_BUF_SIZE           32\n#define PRIMITIVE_ID_MASK       0x8000\n#define MAX_PATTERN_ID          32767\n\n#define MSM_CPU_LAHAINA         415\n#define APQ_CPU_LAHAINA         439\n#define MSM_CPU_SHIMA           450\n#define MSM_CPU_SM8325          501\n#define APQ_CPU_SM8325P         502\n#define MSM_CPU_YUPIK           475\n#define MSM_CPU_CAPE            530\n#define APQ_CPU_CAPE            531\n#define MSM_CPU_TARO            457\n#define MSM_CPU_TARO_LTE        552\n#define MSM_CPU_KALAMA          519\n\n#define test_bit(bit, array)    ((array)[(bit)/8] & (1<<((bit)%8)))\n\nstatic const char LED_DEVICE[] = \"/sys/class/leds/vibrator\";\nstatic const char HAPTICS_SYSFS[] = \"/sys/class/qcom-haptics\";\n\nstatic constexpr int32_t ComposeDelayMaxMs = 1000;\nstatic constexpr int32_t ComposeSizeMax = 256;\n\nenum composeEvent {\n    STOP_COMPOSE = 0,\n};\n\nInputFFDevice::InputFFDevice()\n{\n    DIR *dp;\n    FILE *fp = NULL;\n    struct dirent *dir;\n    uint8_t ffBitmask[FF_CNT / 8];\n    char devicename[PATH_MAX];\n    const char *INPUT_DIR = \"/dev/input/\";\n    char name[NAME_BUF_SIZE];\n    int fd, ret;\n    int soc = property_get_int32(\"ro.vendor.qti.soc_id\", -1);\n\n    mVibraFd = INVALID_VALUE;\n    mSupportGain = false;\n    mSupportEffects = false;\n    mSupportExternalControl = false;\n    mCurrAppId = INVALID_VALUE;\n    mCurrMagnitude = 0x7fff;\n    mInExternalControl = false;\n\n    dp = opendir(INPUT_DIR);\n    if (!dp) {\n        ALOGE(\"open %s failed, errno = %d\", INPUT_DIR, errno);\n        return;\n    }\n\n    memset(ffBitmask, 0, sizeof(ffBitmask));\n    while ((dir = readdir(dp)) != NULL){\n        if (dir->d_name[0] == '.' &&\n            (dir->d_name[1] == '\\0' ||\n             (dir->d_name[1] == '.' && dir->d_name[2] == '\\0')))\n            continue;\n\n        snprintf(devicename, PATH_MAX, \"%s%s\", INPUT_DIR, dir->d_name);\n        fd = TEMP_FAILURE_RETRY(open(devicename, O_RDWR));\n        if (fd < 0) {\n            ALOGE(\"open %s failed, errno = %d\", devicename, errno);\n            continue;\n        }\n\n        ret = TEMP_FAILURE_RETRY(ioctl(fd, EVIOCGNAME(sizeof(name)), name));\n        if (ret == -1) {\n            ALOGE(\"get input device name %s failed, errno = %d\\n\", devicename, errno);\n            close(fd);\n            continue;\n        }\n\n        if (strcmp(name, \"qcom-hv-haptics\") && strcmp(name, \"qti-haptics\")\n                && strcmp(name, \"aw8624_haptic\")\n                && strcmp(name, \"aw8695_haptic\")\n                &",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"pch.h\"\r\n#include \"Logic.h\"\r\n\r\nLogic::Logic() \r\n{\r\n    this->moduleBase = (uintptr_t)GetModuleHandle(L\"Spel2.exe\");\r\n\tthis->GetDynamicAddresses();\r\n}\r\n\r\nuintptr_t Logic::GetModuleBase()\r\n{\r\n    return this->moduleBase;\r\n}\r\n\r\nvoid Logic::GetDynamicAddresses()\r\n{\r\n\tthis->ply = (Player*)mem::ResolvePointerChain(moduleBase + 0x22DB7F08, { 0x1788, 0x178, 0x0 });\r\n\tthis->nextLevel = (float*)mem::ResolvePointerChain(moduleBase + 0x22DB7F08, { 0x1798, 0x120, 0x0 });\r\n}\r\n\r\nBOOL Logic::IsPointerInvalid()\r\n{\r\n\tif (this->ply == (Player*)0x40)\r\n    {\r\n\t\treturn true;\r\n\t} \r\n    return false;\r\n}\r\n\r\nvoid Logic::HandleInput()\r\n{ \r\n    // Failsafe for level transitions where pointer might not be valid for a split second\r\n    if (this->ply == NULL) return;\r\n\r\n    if (GetAsyncKeyState(VK_DELETE) & 1)\r\n    {\r\n        this->keep_running = 0;\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD0) & 1)\r\n    {\r\n        BOOL temp = this->lockMoney;\r\n        if (!temp)  // Off -> on\r\n        {\r\n            this->prevMoney = this->ply->utility->money;\r\n        }\r\n        else        // On -> off   \r\n        {\r\n            this->ply->utility->money = this->prevMoney;\r\n        }\r\n        this->lockMoney = ~(this->lockMoney);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD1) & 1)\r\n    {\r\n        BOOL temp = this->godMode;\r\n        if (!temp)\r\n        {\r\n            this->prevHealth = this->ply->health;\r\n        }\r\n        else\r\n        {\r\n            this->ply->health = this->prevHealth;\r\n        }\r\n        this->godMode = ~(this->godMode);\r\n        this->ToggleGodMode(this->godMode);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD2) & 1)\r\n    {\r\n        BOOL temp = this->lockBombs;\r\n        if (!temp)\r\n        {\r\n            this->prevBombs = this->ply->utility->bombs;\r\n        }\r\n        else\r\n        {\r\n            this->ply->utility->bombs = this->prevBombs;\r\n        }\r\n        this->lockBombs = ~(this->lockBombs);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD3) & 1)\r\n    {\r\n        BOOL temp = this->lockRopes;\r\n        if (!temp)\r\n        {\r\n            this->prevRopes = this->ply->utility->ropes;\r\n        }\r\n        else\r\n        {\r\n            this->ply->utility->ropes = this->prevRopes;\r\n        }\r\n        this->lockRopes = ~(this->lockRopes);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD4) & 1)\r\n    {\r\n        this->speedHack = ~(this->speedHack);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD5) & 1)\r\n    {\r\n        this->highJump = ~(this->highJump);\r\n        this->ToggleHighJump(this->highJump);\r\n        return;\r\n    }\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD6) & 1)\r\n    {\r\n        return;\r\n    }\r\n\r\n\r\n    if (GetAsyncKeyState(VK_NUMPAD7) & 1)\r\n    {\r\n        if (this->ply->state != 240)\r\n        {\r\n            this->ply->Teleport(this->nextLevel[0], this->nextLevel[1]);\r\n        }\r\n        return;\r\n    }\r\n}\r\n\r\nvoid Logic::ContinousWrite() \r\n{\r\n    // Failsafe for level transitions where pointer might not be valid for a split second\r\n    if (this->ply == NULL) return;\r\n\r\n    if (this->lockBombs)\r\n    {\r\n        this->ply->utility->bombs = 44;\r\n    }\r\n\r\n    if (this->lockRopes)\r\n    {\r\n        this->ply->utility->ropes = 55;\r\n    }\r\n\r\n    if (this->lockMoney)\r\n    {\r\n        this->ply->utility->money = 66778899;\r\n    }\r\n\r\n    if (this->speedHack)\r\n    {\r\n        if (this->ply->state != 88 && this->ply->state != 176 && this->ply->state != 240) {\r\n            if (GetAsyncKeyState(VK_LEFT))\r\n            {\r\n                this->ply->x -= this->runModifier;\r\n            }\r\n            else if (GetAsyncKeyState(VK_RIGHT))\r\n            {\r\n                this->ply->x += this->runModifier;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid Logic::ToggleGodMode(BOOL toggle)\r\n{\r\n    uintptr_t DETOUR_SOURCE = this->moduleBase + 0x228d5a92;\r\n\r\n    if (toggle) \r\n    {\r\n        this->ply->health = 33;\r\n\r\n        // detour to code cave\r\n        mem::Patch(DETOUR_SOURCE, 7, \"\\xE9\\x6E\\x13\\x3E\\x00\\x90\\x90\");\r\n    }\r\n    else\r\n    {\r\n        this->ply->health = prevHealth;\r\n\r\n        // restore stolen bytes\r\n        mem::Patch(DETOUR_SOURCE, 7, \"\\x41\\x88\\x86\\x17\\x01\\x00\\x00\");\r\n    }\r\n}\r\n\r\nvoid Logic::ToggleHighJump(BOOL toggle)\r\n{\r\n    uintptr_t DETOUR_SOURCE = this->moduleBase + 0x22885565;\r\n\r\n    if (toggle)\r\n    {\r\n        // detour to code cave\r\n        mem::Patch(DETOUR_SOURCE, 9, \"\\xE9\\xBa\\x18\\x43\\x00\\x90\\x90\\x90\\x90\");\r\n    }\r\n    else\r\n    {\r\n        // restore stolen bytes\r\n        mem::Patch(DETOUR_SOURCE, 9, \"\\xF3\\x41\\x0F\\x11\\xB6\\x0C\\x01\\x00\\x00\");\r\n    }\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include \"Graduate.h\"\n\nusing namespace std;\n\nGraduate randGraduate();\n\nint randYear(int min, int max);\nint currYear();\n\nvector<string> mostPopStudyPlace(vector<Graduate>&);\nvector<string> mostPopWorkPlace(vector<Graduate>&);\nvector<string> keyMaxValues(map<string, int>, int);\n\nstring randFio();\ninline string randEl(string* arr, int len);\n\n\nint main(){\n    setlocale(0, \"\");\n    int minlen = 15;\n    int diap = 10;\n\n    srand(time(NULL));\n    vector<Graduate> grs = vector<Graduate>();\n\n    for (size_t i=0; i< rand()%minlen+diap; i++) {\n        grs.push_back(randGraduate());\n    }\n\n    for (auto gr : grs){\n        cout << (string)gr << endl;\n    }\n\n    cout << \"most pop work places: \" << endl;\n    for (const auto& el : mostPopWorkPlace(grs)){\n        cout << el << endl;\n    }\n    cout << endl;\n\n    cout << \"most pop study places: \" << endl;\n    for (const auto& el : mostPopStudyPlace(grs)){\n        cout << el << endl;\n    }\n    cout << endl;\n}\n\nstring names[] = {\"\u041a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0438\u043d\", \"\u0412\u0430\u043b\u0435\u0440\u044c\u044f\u043d\", \"\u0410\u0431\u043e\u0431\u0430\", \"\u041c\u0438\u0445\u0430\u0438\u043b\", \"\u0410\u043b\u0435\u043a\u0441\u0435\u0439\", \"\u0410\u0440\u0442\u0435\u043c\", \"\u0412\u0438\u043a\u0442\u043e\u0440\", \"\u0414\u043c\u0438\u0442\u0440\u0438\u0439\", \"\u0412\u0441\u0435\u0441\u043b\u0430\u0432\", \"\u0414\u043e\u0431\u0440\u044b\u043d\u044f\", \"\u041a\u0448\u0438\u0448\u0442\u043e\u0444\", \"\u042d\u0434\u0432\u0430\u0440\u0434\"};\nstring patronymics[] = {\"\u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447\", \"\u0410\u0431\u043e\u0431\u043e\u0432\u0438\u0447\", \"\u041f\u0435\u0442\u0440\u043e\u0432\u0438\u0447\", \"\u0410\u043b\u0435\u043a\u0441\u0435\u0438\u0447\", \"\u0410\u0440\u0442\u0435\u043c\u043e\u0432\u0438\u0447\", \"\u0412\u0438\u043a\u0442\u043e\u0440\u043e\u0432\u0438\u0447\", \"\u0414\u043c\u0438\u0442\u0440\u0438\u0435\u0432\u0438\u0447\", \"\u0412\u0441\u0435\u0441\u043b\u0430\u0432\u043e\u0432\u0438\u0447\", \"\u0414\u043e\u0431\u0440\u044b\u043d\u0438\u0447\"};\nstring surnames[] = {\"\u0418\u0432\u0430\u043d\u043e\u0432\", \"\u041c\u0438\u0445\u0430\u0438\u043b\u043e\u0432\", \"\u0410\u043b\u0435\u043a\u0441\u0435\u0435\u0432\", \"\u041f\u0435\u0442\u0440\u043e\u0432\", \"\u0421\u0443\u0440\u043e\u0432\u044b\u0439\", \"\u0411\u043e\u0431\u0440\u043e\u0432\", \"\u0411\u0430\u0442\u043e\u043d\u043e\u0432\", \"\u0413\u0432\u043e\u0437\u0434\u0435\u0432\"};\nstring studyPlaces[] = {\"\u0428\u043a\u043e\u043b\u0430 1\", \"\u0428\u043a\u043e\u043b\u0430 2\", \"\u0428\u043a\u043e\u043b\u0430 3\", \"\u0428\u043a\u043e\u043b\u0430 4\", \"\u0413\u0438\u043c\u043d\u0430\u0437\u0438\u044f 1\", \"\u0413\u0438\u043c\u043d\u0430\u0437\u0438\u044f 2\", \"\u0413\u0438\u043c\u043d\u0430\u0437\u0438\u044f 3\", \"\u0413\u0438\u043c\u043d\u0430\u0437\u0438\u044f 4\"};\nstring workPlaces[] = {\"\u0415\u0440\u0430\u0442\", \"\u0410\u0442\u043b\u0430\u043d\u0442\", \"\u0418\u043d\u0442\u0435\u0433\u0440\u0430\u043b\", \"\u041c\u0410\u0417\", \"\u0411\u0435\u043b\u0410\u0417\", \"\u0411\u0413\u0423\u0418\u0420\", \"\u0411\u0413\u0423\", \"\u0411\u041d\u0422\u0423\"};\n\n\nGraduate randGraduate(){\n\n    int year = randYear(2000, 2026);\n\n    string fio = randFio();\n\n    Graduate gr = Graduate(fio, year);\n    cout << currYear() << endl;\n\n    if (abs(currYear()-year) > 4){\n        gr.setWorkPlace(randEl(workPlaces, sizeof(workPlaces)/sizeof(workPlaces[0])));\n        gr.setStudyPlace(EMPTY);\n    } else {\n        gr.setStudyPlace(randEl(studyPlaces, sizeof(studyPlaces)/sizeof(studyPlaces[0])));\n        gr.setWorkPlace(EMPTY);\n    }\n    return gr;\n}\n\nstring randFio(){\n    return randEl(surnames, sizeof(surnames)/sizeof(surnames[0]))\n            + \" \"\n            + randEl(names, sizeof(names)/sizeof(names[0]))\n            + \" \"\n            + randEl(patronymics, sizeof(patronymics)/sizeof(patronymics[0]));\n}\n\nint randYear(int min, int max){\n    if (min < 0 || max < 0){\n        throw \"Invalid min or max!\";\n    }\n\n    if (min >= max){\n        throw \"Max year must be > min!\";\n    }\n\n    return rand()%(max-min+1)+min;\n}\n\nint currYear() {\n    time_t now = time(0);\n\n    tm *ltm = localtime(&now);\n\n    return ltm->tm_year+1900;\n}\n\ninline string randEl(string* arr, int len){\n    return arr[rand()%len];\n}\n\nvoid sortByKey(vector<pair<string, int>>& v){\n    for (size_t i=0; i< v.size(); i++){\n        for (size_t j=i; j< v.size(); j++){\n            if(v[i].second > v[j].second){\n                swap(v[i], v[j]);\n            }\n        }\n    }\n}\n\nvector<string> keyMaxValues(map<string, int> m, int size){\n    int maxRepeats = 0;\n    vector<string> places = vector<string>();\n\n    vector<pair<string, int>> pls = vector<pair<string, int>>();\n\n    for (auto& el : m){\n        pls.push_back(el);\n        }\n\n    sortByKey(pls);\n\n    for(int i=0; i<size; i++){\n        if(pls.size()-i>0){\n            places.push_back(pls.at(pls.size()-1-i).first);\n        } else break;\n    }\n\n    return places;\n}\n\nvector<string> mostPopStudyPlace(vector<Graduate>& grs){\n    map<string, int> placecount = map<string, int>();\n\n    for (const auto& gr : grs){\n        string place = gr.getStudyPlace();\n        if (place == EMPTY) continue;\n\n        if(!placecount.count(place)){\n            placecount[place] = 1;\n        } else {\n            placecount[place] += 1;\n        }\n    }\n\n    return keyMaxValues(placecount, 3);\n}\n\nvector<string> mostPopWorkPlace(vector<Graduate>& grs){\n    map<string, int> placecount = map<string, int>();\n    for (const auto& gr : grs){\n        string place = gr.getWorkPlace();\n        if (place == EMPTY) continue;\n\n        if(!placecount.count(place)){\n            placecount[place] = 1;\n        } else {\n            placecount[place] += 1;\n        }\n    }\n\n\n    return keyMaxValues(placecount, 3);\n}\n",
    "//\n// Created by romka on 12.12.2023.\n//\n#include \"../include/exe_unit.h\"\n\nnamespace cpu {\n\n    ExeUnit::ExeUnit(unsigned int time): exeTime(time), busy(false) {}\n\n    unsigned int ExeUnit::get_exe_time() const {\n        return exeTime;\n    }\n\n    bool ExeUnit::is_busy() const {\n        return busy;\n    }\n\n    Operand &ExeUnit::get_operand(const Variable &value, DataMemory &memory,\n                                  kas::vector<std::pair<Operand, std::mutex>> &registers) {\n        lock(value, memory, registers);\n        if (value.get_type() == TypeOfVariable::REGISTER) {\n            return registers[value.get_index()].first;\n        }\n        return memory.get_operand(value.get_name());\n    }\n\n    void ExeUnit::lock(const Variable &variable, DataMemory &memory,\n                       kas::vector<std::pair<Operand, std::mutex>> &registers) {\n        if (variable.get_type() == TypeOfVariable::REGISTER) {\n            registers[variable.get_index()].second.lock();\n            return;\n        }\n        memory.lock(variable.get_name());\n    }\n\n    void ExeUnit::unlock(const Variable &variable, DataMemory &memory,\n                         kas::vector<std::pair<Operand, std::mutex>> &registers) {\n        if (variable.get_type() == TypeOfVariable::REGISTER) {\n            registers[variable.get_index()].second.unlock();\n            return;\n        }\n        memory.unlock(variable.get_name());\n    }\n\n    void ExeUnit::calculated_long(Operand &first, const Operand &second, const std::string &name) const {\n        //std::cout << \"calculated long\\n\";\n        std::this_thread::sleep_for(std::chrono::milliseconds(exeTime));\n        first.set_value(ll_functions.find(name)->second(get_operand_value_long(first),\n                                                        get_operand_value_long(second)));\n    }\n\n    void ExeUnit::calculated_double(Operand &first, const Operand &second, const std::string &name) const {\n        //std::cout << \"calculated double\\n\";\n        std::this_thread::sleep_for(std::chrono::milliseconds(exeTime));\n        first.set_value(double_functions.find(name)->second(get_operand_value_double(first),\n                                                            get_operand_value_double(second)));\n    }\n\n    double ExeUnit::get_operand_value_double(const Operand &operand) {\n        return (operand.get_value().index() == 0 ?\n                static_cast<double>(std::get<llong>(operand.get_value())) : std::get<double>(operand.get_value()));\n    }\n\n    llong ExeUnit::get_operand_value_long(const Operand &operand) {\n        return (operand.get_value().index() == 0 ?\n                std::get<llong>(operand.get_value()) : static_cast<llong>(std::get<double>(operand.get_value())));\n    }\n}",
    "#include<iostream>\nusing namespace std;\n\nint main() {\n\tint sec , min, hr , totals , totalm , totalhr , rem , totaldone , total , remsec, remmin, remhr , percentage;\n\tchar x;\n\tdo\n\t{\n\tcout << \"inter your project time : \\n\";\n\tcout << \"hr = \";\n\tcin >> totalhr;\n\tcout << \"min = \";\n\tcin >> totalm;\n\tcout << \"sec = \";\n\tcin >> totals;\n\tcout << \"inter your project time done : \\n\";\n\tcout << \"hr = \";\n\tcin >> hr;\n\tcout << \"min = \";\n\tcin >> min;\n\tcout << \"sec = \";\n\tcin >> sec;\n\t\n\ttotal = totals + (totalm * 60) + (totalhr * 3600);\n\ttotaldone = sec + (min * 60) + (hr * 3600);\n\trem = total - totaldone;\n\tremhr = (rem / 3600);\n\tremmin = (rem / 60) - (remhr*60);\n\tremsec = rem - ((remhr * 3600) + (remmin * 60));\n\tpercentage = totaldone *100 / total;\n\t\n\tfor (int i = 1; i <= 50; i++)\n\t{\n\t\tif (i==1)\n\t\t{\n\t\t\tcout << \"|\";\n\t\t}\n\t\tif (i<=percentage/2)\n\t\t{\n\t\t\tcout << \"/\";\n\t\t}\n\t\telse {\n\t\t\tcout << \" \";\n\t\t}\n\t\tif (i == 50)\n\t\t{\n\t\t\tcout << \"|\";\n\t\t}\n\t}\n\n\tcout << \" about \" << percentage << \"% done\\nremaning :\" << remhr << \" hr: \" << remmin << \" min: \" << remsec << \" sec \\n\";\n\tcout << \"do you want to repeat press (a) , any key to end\\n\";\n\tcin >> x;\n\t} while (x == 'a');\n}\n",
    "#include <QtWidgets/QWidget>\n#include <QtWidgets/QApplication>\n#include <QtWidgets/QPushButton>\n#include <QtWidgets/QLineEdit>\n#include <QtWidgets/QGridLayout>\n#include <QtWidgets/QLabel>\n#include <QtWidgets/QFileDialog>\n\n#include <board.hpp>\n#include <blueprint.hpp>\n#include <iostream>\n\nclass LabelText : public QWidget {\nprivate:\n\tQLabel* label;\n\tQLineEdit* line_edit;\n\tQGridLayout* layout;\npublic:\n\tLabelText(const char* text, const char* def, size_t line_width, QWidget* parent = nullptr) : QWidget(parent) {\n\t\tlabel = new QLabel(text, this);\n\t\tif (def!= nullptr)\n\t\t\tline_edit = new QLineEdit(def, this);\n\t\telse\n\t\t\tline_edit = new QLineEdit(this);\n\n\t\tif (line_width > 0)\n\t\t\tline_edit->setFixedWidth(line_width);\n\t\tline_edit->setContentsMargins(0, 0, 0, 0);\n\n\t\tlayout = new QGridLayout(this);\n\n\t\tlayout->addWidget(label, 0, 0);\n\t\tlayout->addWidget(line_edit, 0, 1);\n\t\tsetLayout(layout);\n\t}\n\n\t~LabelText() override {\n\t\tdelete label;\n\t\tdelete line_edit;\n\t}\n\n\tfriend class MyApp;\n};\n\nclass PathSelector : public QWidget {\nprivate:\n\tQLineEdit* line_edit;\n\tQPushButton* button;\n\tQFileDialog* dialog;\n\tQGridLayout* layout;\npublic:\n\tPathSelector(const char* text, QWidget* parent = nullptr) : QWidget(parent) {\n\t\tif(text != nullptr)\n\t\t\tline_edit = new QLineEdit(text, this);\n\t\tline_edit->setReadOnly(true);\n\t\tbutton = new QPushButton(\"...\", this);\n\t\tbutton->setFixedWidth(30);\n\t\tdialog = new QFileDialog(this);\n\t\tdialog->setFileMode(QFileDialog::Directory);\n\t\tdialog->setOption(QFileDialog::ShowDirsOnly);\n\n\t\tlayout = new QGridLayout(this);\n\t\tlayout->addWidget(line_edit, 0, 0);\n\t\tlayout->addWidget(button, 0, 1);\n\t\tsetLayout(layout);\n\n\t\tconnect(button, &QPushButton::clicked, [this](){\n\t\t\tline_edit->setText(dialog->getExistingDirectory());\n\t\t});\n\t}\n\n\t~PathSelector() override {\n\t\tdelete line_edit;\n\t\tdelete button;\n\t\tdelete dialog;\n\t}\n\n\tfriend class MyApp;\n};\n\nclass MyApp : public QWidget {\nprivate:\n\tBlueprint* blueprint;\n\tLabelText* count;\n\tPathSelector* src, *dst;\npublic:\n\tMyApp(QWidget* parent = nullptr) : QWidget(parent) {\n\t\tblueprint = new Blueprint(this);\n\t\tthis->count = new LabelText(\"Numero de loterias\", \"4\", 50, this);\n\t\tthis->src = new PathSelector(\"Entrada\", this);\n\t\tthis->dst = new PathSelector(\"Salida\", this);\n\n\t\tauto* dialog = new QFileDialog(this);\n\t\tdialog->setFileMode(QFileDialog::Directory);\n\t\tdialog->setOption(QFileDialog::ShowDirsOnly);\n\n\t\tauto* button = new QPushButton(\"Submit\", this);\n\t\tconnect(button, &QPushButton::clicked, this, &MyApp::submit);\n\t\tauto* layout = new QGridLayout(this);\n\n\t\tlayout->addWidget(count, 0, 0);\n\n\t\tauto* selection_layout = new QGridLayout(this);\n\t\tselection_layout->addWidget(src, 0, 0);\n\t\tselection_layout->addWidget(dst, 0, 1);\n\n\t\tlayout->addLayout(selection_layout, 1, 0);\n\n\t\tlayout->addWidget(blueprint, 2, 0);\n\t\tlayout->addWidget(button,    3, 0);\n\t}\n\n\tvoid submit(){\n\t\tauto p = blueprint->build();\n\t\tp.insert(p.begin(), {\"SetCount\", {(size_t)std::stoi(count->line_edit->text().toStdString())}});\n\t\tfor (auto& i : p){\n\t\t\tstd::cout<< i.name << \" \";\n\t\t\tfor (auto& j : i.values)\n\t\t\t\tstd::cout<< j << \" \";\n\t\t\tstd::cout<< std::endl;\n\t\t}\n\t}\n\n\t~MyApp() override {}\n};\n\nint main(int argc, char** argv) {\n\n\tQApplication app(argc, argv);\n\n\tMyApp window;\n\n\twindow.resize(400, 200);\n\twindow.setWindowTitle(\"Tool Tip\");\n\twindow.show();\n\n\treturn app.exec();\n}\n",
    "#include <stdio.h>\n#include <time.h>\n#include <Windows.h>\ntypedef struct {\t//\u5b57\u6bcd\u7ed3\u6784\u4f53\n\tint x, y;\n\tchar ch;\n} RAINDROP;\nconst int BUFFER_SIZE = 100;\nint WIDTH = 80;\nint HEIGHT = 30;\nconst int RAIN_LENGTH = 18;\nRAINDROP raindropLine[BUFFER_SIZE];\nHANDLE HOUT = GetStdHandle(STD_OUTPUT_HANDLE);\t//\u83b7\u5f97\u6807\u51c6\u8f93\u51fa\u7684\u53e5\u67c4\nvoid gotoxy(int x, int y) {\n\tCOORD pos;\t\t\t\t//\u5b9a\u4e49\u8868\u793a\u4e00\u4e2a\u5b57\u7b26\u5728\u63a7\u5236\u53f0\u5c4f\u5e55\u4e0a\u7684\u5750\u6807\u7684\u5bf9\u8c61\n\tpos.X = x;\n\tpos.Y = y;\n\tSetConsoleCursorPosition(HOUT, pos);\t//\u8bbe\u7f6e\u63a7\u5236\u53f0\u6807\u51c6\u8f93\u51fa\u5149\u6807\u4f4d\u7f6e\n}\nvoid show_cursor(BOOL hide) {\n\tCONSOLE_CURSOR_INFO cciCursor;\n\tif (GetConsoleCursorInfo(HOUT, &cciCursor)) {\t//\u83b7\u5f97\u5149\u6807\u4fe1\u606f\n\t\tcciCursor.bVisible = hide;\t\t\t\t\t//\u9690\u85cf\u5149\u6807\t\t\n\t\tSetConsoleCursorInfo(HOUT, &cciCursor);\t\t//\u91cd\u65b0\u8bbe\u7f6e\u5149\u6807\n\t}\n}\nvoid set_color(int color) {\n\tSetConsoleTextAttribute(HOUT, color);\t\t//\u8bbe\u7f6e\u8f93\u51fa\u989c\u8272\n}\nint main() {\n\tCONSOLE_SCREEN_BUFFER_INFO info;\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    // \u5c1d\u8bd5\u6700\u5927\u5316\u63a7\u5236\u53f0\u7a97\u53e3\n    HWND consoleWindow = GetConsoleWindow();\n    ShowWindow(consoleWindow, SW_MAXIMIZE);\n\n    // \u83b7\u53d6\u5f53\u524d\u5c4f\u5e55\u7f13\u51b2\u533a\u4fe1\u606f\n    GetConsoleScreenBufferInfo(hConsole, &info);\n    \n    // \u8bbe\u7f6e\u7f13\u51b2\u533a\u5c3a\u5bf8\u4e3a\u5c4f\u5e55\u5c3a\u5bf8\n    COORD bufferSize;\n    bufferSize.X = info.dwMaximumWindowSize.X; // \u5c4f\u5e55\u5bbd\u5ea6\n    bufferSize.Y = info.dwMaximumWindowSize.Y; // \u5c4f\u5e55\u9ad8\u5ea6\uff08\u6216\u6839\u636e\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u8f83\u5927\u7684\u503c\uff09\n    SetConsoleScreenBufferSize(hConsole, bufferSize);\n\tGetConsoleScreenBufferInfo(HOUT, &info);\t//\u83b7\u5f97\u63a7\u5236\u53f0\u7a97\u4f53\u4fe1\u606f\n\tHEIGHT = info.srWindow.Bottom;\t\t\t\t//\u6839\u636e\u63a7\u5236\u53f0\u7684\u5bbd\u9ad8\u8bbe\u7f6e\u663e\u793a\u7684\u5bbd\u9ad8\n\tWIDTH = info.srWindow.Right;\n\tshow_cursor(FALSE);\n\tsrand((unsigned int)time(NULL));\n\tfor (int i=0; i<BUFFER_SIZE; i++) {\t\t\t//\u968f\u673a\u8bbe\u7f6e\u5b57\u6bcd\u4e0b\u843d\u7684\u4f4d\u7f6e \n\t\traindropLine[i].x = rand()%WIDTH;\n\t\traindropLine[i].y = rand()%HEIGHT;\n\t\traindropLine[i].ch = rand() %26 + 97;\n\t}\t\t\t\n\twhile(true) {\n\t\tGetConsoleScreenBufferInfo(HOUT, &info);\t//\u5f53\u7a97\u4f53\u5927\u5c0f\u53d8\u5316\u65f6\uff0c\u91cd\u65b0\u8bbe\u7f6e\u5bbd\u9ad8\u4fe1\u606f\n\t\tHEIGHT = info.srWindow.Bottom;\n\t\tWIDTH = info.srWindow.Right;\n\t\tfor (int i=0; i<BUFFER_SIZE; ++i)\t\t{\n\t\t\tif (raindropLine[i].y <= HEIGHT)\t\t\t{\n\t\t\t\tgotoxy(raindropLine[i].x, raindropLine[i].y);\n\t\t\t\tset_color(FOREGROUND_GREEN);\t\t\t\t//\u8bbe\u7f6e\u5b57\u6bcd\u989c\u8272\n\t\t\t\tputchar(raindropLine[i].ch);\n\t\t\t}\n\t\t\tgotoxy(raindropLine[i].x, raindropLine[i].y - RAIN_LENGTH);\t//\u64e6\u9664\u8fc7\u957f\u7684\u5b57\u6bcd \n\t\t\tputchar(' ');\n\t\t\traindropLine[i].y++;\n\t\t\traindropLine[i].ch = rand() % 26 + 97;\n\t\t\tif (raindropLine[i].y > HEIGHT + RAIN_LENGTH)\t\t\t\t\t{\n\t\t\t\traindropLine[i].x = rand() % WIDTH;\n\t\t\t\traindropLine[i].y = rand() % HEIGHT;\n\t\t\t}\n\t\t\tif ( raindropLine[i].y <= HEIGHT) {\n\t\t\t\tgotoxy(raindropLine[i].x, raindropLine[i].y);\n\t\t\t\tset_color(FOREGROUND_GREEN|FOREGROUND_INTENSITY);\t//\u9ad8\u4eae\u6700\u4e0b\u65b9\u7684\u5b57\u6bcd\t\t\n\t\t\t\tputchar(raindropLine[i].ch);\n\t\t\t}\n\t\t}\n\t\tSleep(50);\n\t}\n\tgetchar();\n\treturn 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<iostream>\n#include<fstream>\n#include<cstdlib>\n\nclass Sorting { // sorting class implementing all 3 kinds of sorting methods as static function\npublic:\n\n    /*-----------------------swap function------------------------*/\n\n    static void swap(int* a, int* b) { // swap 2 input element's value\n        int temp = *a;\n        *a = *b;\n        *b = temp;\n    }\n\n    /*-----------------------median function------------------------*/\n\n    static int median(int a, int b, int c) { // function for finding median of 3 input numbers\n        if ((a <= b && b <= c) || (c <= b && b <= a)) { return b; }\n        else if ((b <= a && a <= c) || (c <= a && a <= b)) { return a; }\n        else { return c; }\n    }\n\n    /*-----------------------naive quick sort------------------------*/\n\n    static int partition(int* unsorted, int start, int end) { //parition the given array based on comparing to pivot, and return the index of pivot's right position\n        int pivot = unsorted[end]; // set the pivot as end of the array\n        int i = start - 1;\n\n        for (int j = start; j <= end - 1; j++) { // j is for scan array, i is the last index of left sub array\n            if (unsorted[j] < pivot) { // if some element is less than pivot, put in in the left sub array\n                i++;\n                swap(&unsorted[i], &unsorted[j]); // switch the first element right sub array and j so the boundary of left sub array increased by 1.\n            }\n        }\n\n        unsorted[end] = unsorted[i + 1]; // after full divide, set the pivot's right position and return\n        unsorted[i + 1] = pivot;\n        return i + 1;\n    }\n\n    static void nquick_sort(int* unsorted, int start, int end) {\n        if (start < end) {\n            int q = partition(unsorted, start, end);\n            nquick_sort(unsorted, start, q-1);\n            nquick_sort(unsorted, q+1, end);\n        }\n    }\n\n    /*----------------randomized quick sort : median of 3 method------------------------*/\n\n    static int rand_partition(int* unsorted, int start, int end) { // partition functoin for setting pivot as median of 3\n\n        int rand1 = start + rand() % (end - start + 1); //get 3 random numbers\n        int rand2 = start + rand() % (end - start + 1);\n        int rand3 = start + rand() % (end - start + 1);\n\n        int pivot = median(unsorted[rand1], unsorted[rand2], unsorted[rand3]); // set the median value as pivot\n        int pivot_index = 0;\n\n        if (pivot == unsorted[rand1]) { pivot_index = rand1; }\n        else if (pivot == unsorted[rand2]) { pivot_index = rand2; }\n        else { pivot_index = rand3; }\n\n        swap(&unsorted[pivot_index], &unsorted[end]); // swap the last element with pivot, and use the same partition function above.\n\n        return partition(unsorted, start, end); \n\n    }\n\n    static void rquick_sort(int* unsorted, int start, int end) {\n        if (start < end) {\n            int q = rand_partition(unsorted, start, end);\n            rquick_sort(unsorted, start, q - 1);\n            rquick_sort(unsorted, q + 1, end);\n        }\n    }\n\n    /*-----------------------------------Tail recursive quick sort (for better space complexity) -----------------------------------*/\n\n\n    static void tquick_sort(int* unsorted, int start, int end) { // tail recursive quick sort\n        while (start < end) {\n            int q = rand_partition(unsorted, start, end); // use the randomized partition method to avoid worst case\n            if (q - start < end - q) {\n                tquick_sort(unsorted, start, q - 1);\n                start = q + 1; // set the start as the first index of smaller sub array, and partition large one smaller again.\n            }\n            else {\n                tquick_sort(unsorted, q + 1, end);\n                end = q - 1;\n            }\n        }\n    }\n\n};\n\nint main(int argc, char* argv[]) { // execute in CLI with \"compiledname\", \"inputfile\", \"outputfile\"\n\n    /*----------check number of arguments -------------------------------------------------*/\n\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input_file> <output_file>\" << std::endl;\n        return 1;\n    }\n\n    /*------------------------check input file opened--------------------------------------*/\n\n    std::ifstream input_file(argv[1]);\n\n    if (!input_file.is_open()) {\n        std::cerr << \"Error opening input file: \" << argv[1] << std::endl;\n        return 1;\n    }\n\n    /*------------------------------get data from input.txt---------------------------*/\n\n    int input_size;\n    input_file >> input_size; // get the number of input (first line)\n\n    int* input_array = new int[input_size]; // array for storing unsorted numbers\n\n    for (int i = 0; i < input_size; ++i) { // get the unsorted numbers (second line)\n        input_file >> input_array[i];\n    }\n\n    input_file.close();\n\n    /*-------------copy the input value for each method --------------*/\n\n    int* naive_input = new int[input_size];\n    int* rand_input = new int[input_size];\n    int* tailrecur",
    "#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include \"doctest.h\"\n#include \"Triangle3d.h\"\n\nTEST_CASE(\"Testing computeArea function in Triangle3d that indirectly tests computeDistance\") {\n    Point3d p1(0, 0, 0);\n    Point3d p2(1, 0, 0);\n    Point3d p3(0.5, sqrt(3.0)/2.0, 0);  \n\n    Triangle3d triangle(p1, p2, p3);\n\n    double expected_area = 0.5 * (1 * (sqrt(3.0) / 2.0));\n    CHECK(doctest::Approx(triangle.computeArea()) == expected_area);\n\n    Point3d p4(0, 0, 0);\n    Point3d p5(4, 0, 0);\n    Point3d p6(0, 3, 0);  \n    Triangle3d rightTriangle(p4, p5, p6);\n\n    double right_expected_area = 0.5 * 4 * 3;  \n    CHECK(doctest::Approx(rightTriangle.computeArea()) == right_expected_area);\n\n    Point3d p7(1, 1, 1);\n    Point3d p8(2, 2, 2);  \n    Point3d p9(3, 3, 3);\n    Triangle3d zeroAreaTriangle(p7, p8, p9);\n\n    CHECK_EQ(zeroAreaTriangle.computeArea(), 0.0);\n}\n\nTEST_CASE(\"Testing computeArea function in Triangle3d\") {\n    \n    Point3d p1(0, 0, 0);\n    Point3d p2(1, 0, 0);\n    Point3d p3(0.5, sqrt(3.0)/2.0, 0);\n    Triangle3d equilateralTriangle(p1, p2, p3);\n\n    double expected_area_equilateral = sqrt(3.0)/4.0;  \n    CHECK(doctest::Approx(equilateralTriangle.computeArea()) == expected_area_equilateral);\n\n    Point3d p4(0, 0, 0);\n    Point3d p5(4, 0, 0);\n    Point3d p6(0, 3, 0);\n    Triangle3d rightTriangle(p4, p5, p6);\n\n    double expected_area_right = 0.5 * 3 * 4;  \n    CHECK_EQ(rightTriangle.computeArea(), expected_area_right);\n\n    Point3d p7(1, 1, 1);\n    Point3d p8(2, 2, 2);\n    Point3d p9(3, 3, 3);\n    Triangle3d zeroAreaTriangle(p7, p8, p9);\n\n    CHECK_EQ(zeroAreaTriangle.computeArea(), 0.0);\n}",
    "\ufeff#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int x, y;\n    start:\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c: \";\n    cin >> x;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u043d\u0430\u043c\u0435\u043d\u0430\u0442\u0435\u043b\u044c: \";\n    cin >> y;\n\n    if (y == 0) {\n        cout << \"\u041d\u0430 0 \u0434\u0435\u043b\u0438\u0442\u044c \u043d\u0435\u043b\u044c\u0437\u044f!\\n\";\n        goto start;\n    }\n\n    cout << \"------C\u0447\u0438\u0442\u0430\u0435\u043c------\\n\";\n\n    bool answer = false;\n    int divisor = 1;    \n\n    if (x % y == 0) {\n        x /= y;\n        answer = true;\n    }\n    else {\n        while (divisor < y) {\n            //cout << \"error\";\n            if (x % divisor == 0 && y % divisor == 0) {\n                x /= divisor;\n                y /= divisor;\n            }            \n            divisor++;            \n        }\n    }\n\n    if (x < 0 && y < 0) {\n        x = -x;\n        y = -y;\n    }\n\n    if (answer) {\n        cout << \"\u041e\u0442\u0432\u0435\u0442: \" << x << endl;\n    }\n    else if (x > y) {\n        int answer = x / y;\n        x %= y;\n        string whole[2] = { \" \u0446\u0435\u043b\u0430\u044f\", \" \u0446\u0435\u043b\u044b\u0445\" };\n        int ending = 1;\n        if (answer % 10 == 1) ending = 0;\n        cout << \"\u041e\u0442\u0432\u0435\u0442: \" << answer << whole[ending] << \" \u0438 \" << x << \"/\" << y << endl;\n    }\n    else {\n        cout << \"\u041e\u0442\u0432\u0435\u0442: \" << x << \"/\" << y << endl;\n    }\n\n\n\n\n\n\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <time.h>\n#include <iomanip>\n#include <limits.h>\n\nusing namespace std;\n\nint searchMin(int* massiv, int massivSize, int startIndex, int& min);\nvoid initAndPrintMassiv(int* massiv, int massivSize);\nvoid searchMax(int* massiv, int massivSize);\nvoid searchMax(int massiv[][3], int massivSize, int secondSize);\nvoid searchMax(int massiv[][2][2], int massivSize, int secondSize, int thirdSize);\nvoid searchMax(int number1, int number2);\nvoid searchMax(int number1, int number2, int number3);\n\n\n\n\nint main()\n{\n    \n    setlocale(LC_ALL, \"RU\");\n    srand((int)time(NULL));\n    int const massivSize = 100;\n    int massiv[massivSize];\n    int min = INT_MAX;\n    initAndPrintMassiv(massiv, massivSize);\n    searchMin(massiv, massivSize, 0, min);\n    std::cout << \"\u00ec\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee = \" << min << endl;\n    return 0;\n}\n\nint searchMin(int* massiv, int massivSize, int startIndex, int& min)\n{\n    int localMin = 0;\n    if (startIndex + 9 == massivSize)\n    {\n        return 0;\n    }\n    for (int i = startIndex; i < startIndex + 10; i++)\n    {\n        localMin += massiv[i];\n    }\n    if (localMin < min)\n    {\n        min = localMin;\n    }\n   \n    return searchMin(massiv, massivSize, startIndex + 1, min);\n}\n\n\nvoid initAndPrintMassiv(int* massiv, int massivSize)\n{\n    for (int i = 0; i < massivSize; i++)\n    {\n        *(massiv + i) = rand() % 101;\n        std::cout << fixed << setw(4) << *(massiv + i) << \" \";\n        if (i % 10 == 9)\n        {\n            std::cout << endl;\n        }\n    }\n}\n//\u00e7\u00e0\u00e4\u00e0\u00f7\u00e0 2\nint const massivSize = 10;\nint const massivSize2 = 3;\nint const massivSize3 = 2;\nint massiv1[massivSize] = {1,2,3,4,5,6,7,8,9,10 };\nint massiv2[massivSize2][massivSize2] = { {8,7,6},{5,4,3},{2,1,9} };\nint massiv3[massivSize3][massivSize3][massivSize3] = { {{2,2},{3,3}},{{4,8},{8,7}} };\nint number1 = 2;\nint number2 = 4;\nint number3 = 6;\nvoid searchMax(int* massiv, int massivSize)\n{\n    std::cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e2 \u00ee\u00e4\u00ed\u00ee\u00ec\u00e5\u00f0\u00ed\u00ee\u00ec \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5\" << endl <<\n        \"    \";\n    int max = massiv[0];\n    int index = 0;\n    for (int i = 0; i < massivSize; i++)\n    {\n        cout << massiv[i] << \" \";\n        if (massiv[i] > max)\n        {\n            max = massiv[i];\n            index = i;\n        }\n    }\n    std::cout << endl << \"  \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e2 \u00ec\u00e0\u00f1\u00f1\u00f1\u00e8\u00e2\u00e5[\" << index << \"] = \" << max << endl << endl;\n}\n\nvoid searchMax(int massiv[][3], int massivSize, int secondSize)\n{\n    std::cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e2 \u00e4\u00e2\u00f3\u00f5\u00ec\u00e5\u00f0\u00ed\u00ee\u00ec \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5\" <<\n        endl << \"   Array:\" << endl << \"   \";\n    int max = massiv[0][0];\n    int index1 = 0;\n    int index2 = 0;\n    for (int i = 0; i < massivSize; i++)\n    {\n        for (int j = 0; j < secondSize; j++)\n        {\n            std::cout << massiv[i][j] << \" \";\n            if (massiv[i][j] > max)\n            {\n                max = massiv[i][j];\n                index1 = i;\n                index2 = j;\n            }\n        }\n        std::cout << endl << \"   \";\n    }\n    std::cout << \"\u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f0\u00e0\u00e2\u00e5\u00ed[\" << index1 << \"][\" << index2 << \"] = \" << max << endl << endl;\n}\n\nvoid searchMax(int massiv[][2][2], int massivSize, int secondSize, int thirdSize)\n{\n    std::cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5\" << endl;\n    int max = massiv[0][0][0];\n    int index1 = 0;\n    int index2 = 0;\n    int index3 = 0;\n    for (int i = 0; i < massivSize; i++)\n    {\n        for (int j = 0; j < secondSize; j++)\n        {\n            for (int k = 0; k < thirdSize; k++)\n            {\n                if (massiv[i][j][k] > max)\n                {\n                    max = massiv[i][j][k];\n                    index1 = i;\n                    index2 = j;\n                    index3 = k;\n                }\n            }\n        }\n    }\n    std::cout << \"   \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f0\u00e0\u00e2\u00e5\u00ed[\" << index1 << \"][\" << index2 << \"][\" <<\n        index3 << \"] = \" << max << endl << endl;\n}\n\nvoid searchMax(int number1, int number2)\n{\n    cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00ec\u00e5\u00e6\u00e4\u00f3 \u00e4\u00e2\u00f3\u00f5 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00f5\" << endl << \"   \" << number1;\n    if (number1 > number2)\n    {\n        cout << \" > \";\n    }\n    else if (number1 < number2)\n    {\n        cout << \" < \";\n    }\n    else\n    {\n        cout << \" = \";\n    }\n    cout << number2 << endl << endl;\n}\n\nvoid searchMax(int number1, int number2, int number3)\n{\n    cout << \"\u00ed\u00e0\u00f5\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00ec\u00e5\u00e6\u00e4\u00f3 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00ec\u00e8\" << endl;\n\n    int max = number1;\n    if (number1 > number2)\n    {\n        if (number1 >= number3)\n        {\n            max = number1;\n        }\n        else\n        {\n            max = number3;\n        }\n    }\n    else if (number1 < number2)\n    {\n        if (number2 >= number3)\n        {\n            max = number2;\n        }\n        else\n        {\n            max = number3;\n        }\n    }\n    else\n    {\n        if (number2 >= number3)\n        {\n            max = number2;\n        }\n        else\n        {\n            max = number3;\n        }\n    }\n\n    std::cout << \"   \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e5 \u00ec\u00e5\u00e6\u00e4\u00f3 : \" << number1 << \" \" << number2 << \" \" <<\n        nu",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\n#include<string>\nusing namespace std;\n\nconst int Max_Size = 50; // Maximum size of the\n//\n// //arrays\n//Base class representing a person\nclass Person\n{\nprivate:\n\tstring Name, CNIC, Contact_Number;\n\t// temp\n\tint Age;\n\npublic:\n\n\t// Constructor initializing member  variable\n\t\n\t\n\tPerson() : Name(\"\"), CNIC(\"\"), Contact_Number(\"\"), Age(0) {}\n\n\t// Destructor\n\t~Person() {}\n\n\t// Setter methods\n\tvoid setName(const string nam)\n\t{\n\t\tName = nam;\n\t}\n\n\tvoid setCNIC(const string cnic)\n\t{\n\t\tCNIC = cnic;\n\t}\n\n\tvoid setContact_Number(const string num)\n\t{\n\t\tContact_Number = num;\n\t}\n\n\tvoid setAge(const int age)\n\t{\n\t\tAge = age;\n\t}\n\n\t// Getter methods\n\tstring getName() const\n\t{\n\t\treturn Name;\n\t}\n\n\tstring getCNIC() const\n\t{\n\t\treturn CNIC;\n\t}\n\n\tstring getContact_Number() const\n\t{\n\t\treturn Contact_Number;\n\t}\n\n\tint getAge() const\n\t{\n\t\treturn Age;\n\t}\n};\n\n// Derived class representing a teacher, inheriting from Person class\nclass Teacher : public Person\n{\nprivate:\n\n\tstring Emp_id, Course;\n\tlong double Salary;\n\npublic:\n\n\t// Constructor initializing member \n\t// variables\n\tTeacher() : Emp_id(\"\"), Course(\"\"), Salary(0) {}\n\n\t// Destructor\n\t~Teacher() {}\n\n\t// Setter methods\n\tvoid setEmp_id(const string id)\n\t{\n\t\tEmp_id = id;\n\t}\n\n\tvoid setcourse(const string course)\n\t{\n\t\tCourse = course;\n\t}\n\n\tvoid setSalary(const long double sal)\n\t{\n\t\tSalary = sal;\n\t}\n\n\t// Getter methods\n\tstring getEmp_id() const\n\t{\n\t\treturn Emp_id;\n\t}\n\n\tstring getcourse() const\n\t{\n\t\treturn Course;\n\t}\n\n\tlong double getSalary() const\n\t{\n\t\treturn Salary;\n\t}\n\n\t// Method to display teacher details\n\tvoid display() const\n\t{\n\t\tcout << \"Name: \" << getName() << endl;\n\t\tcout << \"Age: \" << getAge() << endl;\n\t\tcout << \"CNIC: \" << getCNIC() << endl;\n\t\tcout << \"Contact Number: \" << getContact_Number() << endl;\n\t\tcout << \"Employee ID: \" << Emp_id << endl;\n\t\tcout << \"Course: \" << Course << endl;\n\t\tcout << \"Salary: \" << Salary << endl;\n\t}\n};\n\n// Derived class representing a student, inheriting from Person class\nclass Student : public Person\n{\nprivate:\n\n\tdouble CGPA;\n\tstring Degree;\n\npublic:\n\n\t// Constructor initializing member variables\n\tStudent() : CGPA(0), Degree(\"\") {}\n\n\t// Destructor\n\t~Student() {}\n\n\t// Setter methods\n\tvoid setCGPA(const double gpa)\n\t{\n\t\tCGPA = gpa;\n\t}\n\n\tvoid setDegree(const string deg)\n\t{\n\t\tDegree = deg;\n\t}\n\n\t// Getter methods\n\tdouble getCGPA() const\n\t{\n\t\treturn CGPA;\n\t}\n\n\tstring getDegree() const\n\t{\n\t\treturn Degree;\n\t}\n\n\t// Method to display student details\n\tvoid display() const\n\t{\n\t\tcout << \"Name: \" << getName() << endl;\n\t\tcout << \"Age: \" << getAge() << endl;\n\t\tcout << \"CNIC: \" << getCNIC() << endl;\n\t\tcout << \"Contact Number: \" << getContact_Number() << endl;\n\t\tcout << \"CGPA: \" << CGPA << endl;\n\t\tcout << \"Degree: \" << Degree << endl;\n\t}\n};\n\n// Struct representing login credentials\nstruct Login\n{\n\tstring id = \"Admin\";\n\tstring password = \"12345\";\n\n} login;\n\n// Function to create a new teacher object\nvoid createTeacher(Teacher* OBJ[], int& size)\n{\n\tOBJ[size] = new Teacher(); // Allocate memory for new teacher object\n\n\t// Check if database is full\n\tif (size == Max_Size)\n\t{\n\t\tcout << \"Sorry you cannot add Teacher, Database is full!\" << endl;\n\t\treturn;\n\t}\n\n\tstring str;\n\tint age;\n\n\tcin.ignore();\n\tcout << \"Enter Details of Teacher!\" << endl;\n\tcout << \"Enter Name:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setName(str);\n\n\tcout << \"Enter Age:\" << endl;\n\tcin >> age;\n\tOBJ[size]->setAge(age);\n\tcin.ignore();\n\n\tcout << \"Enter CNIC:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setCNIC(str);\n\n\tcout << \"Enter contact number:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setContact_Number(str);\n\n\tcout << \"Enter Employee ID:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setEmp_id(str);\n\n\tcout << \"Enter Course:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setcourse(str);\n\n\tcout << \"Teacher Added successfully!\" << endl;\n\tsize++;\n}\n\n// Function to create a new student object\nvoid createStudent(Student* OBJ[], int& size)\n{\n\tOBJ[size] = new Student(); // Allocate memory for new student object\n\n\t// Check if database is full\n\tif (size == Max_Size)\n\t{\n\t\tcout << \"Sorry you cannot add Student, Database is full!\" << endl;\n\t\treturn;\n\t}\n\n\tstring str;\n\tint age;\n\tdouble gpa;\n\n\tcin.ignore();\n\tcout << \"Enter Details of Students!\" << endl;\n\tcout << \"Enter Name:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setName(str);\n\n\tcout << \"Enter Age:\" << endl;\n\tcin >> age;\n\tOBJ[size]->setAge(age);\n\tcin.ignore();\n\n\tcout << \"Enter CNIC:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setCNIC(str);\n\n\tcout << \"Enter contact number:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setContact_Number(str);\n\n\tcout << \"Enter CGPA:\" << endl;\n\tcin >> gpa;\n\tOBJ[size]->setCGPA(gpa);\n\tcin.ignore();\n\n\tcout << \"Enter Degree:\" << endl;\n\tgetline(cin, str);\n\tOBJ[size]->setDegree(str);\n\n\tcout << \"Student added successfully!\" << endl;\n\tsize++;\n}\n\n// Function to modify details of a teacher\nvoid ModifyTeacher(Teacher* OBJ[], int& size)\n{\n\tstring str;\n\tint age;\n\n\t// Check if there are teachers in the database\n\tif ((size) == 0)\n\t{\n\t\tcout << \"No teacher i",
    "#include <iostream>\n#include <vector>\n\nbool IsPossible(std::vector<long long>& vec, long long amount, long long len) {\n  long long x = vec[0];\n  long long counter = 1;\n  for (int i = 0; i != (int)vec.size(); ++i) {\n    if (vec[i] > x + len) {\n      ++counter;\n      if (counter > amount) {\n        break;\n      }\n      x = vec[i];\n    }\n  }\n  return (counter <= amount);\n}\n\nlong long BinSearch(std::vector<long long>& vec, long long amount) {\n  long long min_len = 0;\n  long long max_len = vec[vec.size() - 1] - vec[0];\n\n  while (true) {\n    if (min_len == max_len) {\n      return min_len;\n    }\n    long long mid = (max_len + min_len) / 2;\n\n    if (IsPossible(vec, amount, mid)) {\n      max_len = mid;\n    } else {\n      min_len = mid + 1;\n    }\n  }\n}\n\nint main() {\n  long long num;\n  long long amount;\n  std::cin >> num >> amount;\n  std::vector<long long> coords(num);\n  for (long long i = 0; i != num; ++i) {\n    std::cin >> coords[i];\n  }\n  std::sort(coords.begin(), coords.end());\n  std::cout << BinSearch(coords, amount);\n  return 0;\n}\n",
    "#include <chk/core/error.hpp>\n#include <chk/core/log.hpp>\n#include <chk/win/win.hpp>\n\n#define GLFW_INCLUDE_NONE\n#include <GLFW/glfw3.h>\n#include <glad/gl.h>\n\nnamespace chk {\n\nstatic s32 g_win_count = 0;\n\nWin::Win(s32 w, s32 h, StrView caption) {\n    bool is_first = g_win_count == 0;\n    ++g_win_count;\n\n    if (is_first) {\n        glfwSetErrorCallback([](s32 code, const char* msg) { log::warn(\"[glfw({})]: {}\", code, msg); });\n        if (!glfwInit()) { throw RuntimeError(\"Failed to initialize GLFW\"); }\n    }\n\n    Str c_caption{caption};\n\n    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n    auto handle = glfwCreateWindow(w, h, c_caption.c_str(), nullptr, nullptr);\n    if (!handle) { throw RuntimeError(\"Failed to create window {}\", caption); }\n    _impl = handle;\n\n    glfwMakeContextCurrent(handle);\n    auto version = gladLoadGL(glfwGetProcAddress);\n    if (!version) {\n        throw RuntimeError(\"Failed to load OpenGL\");\n    } else {\n        log::info(\"Loaded OpenGL {}.{}\", GLAD_VERSION_MAJOR(version), GLAD_VERSION_MINOR(version));\n    }\n\n    glfwSetWindowUserPointer(handle, this);\n    glfwSetWindowCloseCallback(handle, [](GLFWwindow* _h) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) { win->_state.is_running = false; }\n    });\n    glfwSetWindowRefreshCallback(handle, [](GLFWwindow* _h) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) { win->step(false); }\n    });\n    glfwSetWindowPosCallback(handle, [](GLFWwindow* _h, s32 x, s32 y) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) {\n            win->_data.x = x, win->_data.y = y, win->_frame_state.changed_pos = true;\n        }\n    });\n    glfwSetWindowSizeCallback(handle, [](GLFWwindow* _h, s32 w, s32 h) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) {\n            win->_data.w = w, win->_data.h = h, win->_frame_state.changed_size = true;\n        }\n    });\n    glfwSetFramebufferSizeCallback(handle, [](GLFWwindow* _h, s32 w, s32 h) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) {\n            win->_data.vp_w = w, win->_data.vp_h = h, win->_frame_state.changed_vp_size = true;\n        }\n    });\n    glfwSetWindowFocusCallback(handle, [](GLFWwindow* _h, s32 v) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) {\n            win->_state.is_focused = static_cast<bool>(v), win->_frame_state.changed_focus = true;\n        }\n    });\n    glfwSetWindowContentScaleCallback(handle, [](GLFWwindow* _h, r32 x, r32 y) {\n        if (auto win = reinterpret_cast<Win*>(glfwGetWindowUserPointer(_h))) {\n            win->_data.dpi_x = x, win->_data.dpi_y = y, win->_frame_state.changed_dpi = true;\n        }\n    });\n\n    // Default data\n    _data.vp_x = 0, _data.vp_y = 0;\n    glfwGetWindowPos(handle, &_data.x, &_data.y);\n    glfwGetWindowSize(handle, &_data.w, &_data.h);\n    glfwGetFramebufferSize(handle, &_data.vp_w, &_data.vp_h);\n    glfwGetWindowContentScale(handle, &_data.dpi_x, &_data.dpi_y);\n\n    // Done\n    glfwShowWindow(handle);\n    _state.is_running = true;\n}\n\nWin::~Win() {\n    bool is_last = g_win_count == 1;\n    --g_win_count;\n\n    if (is_last) { glfwTerminate(); }\n}\n\n// Methods\ns32 Win::run() {\n    s32 result = 0;\n    while (state().is_running) { result = step(true); }\n    return result;\n}\n\ns32 Win::step(bool process_events) {\n    if (process_events) { glfwPollEvents(); }\n    auto handle = reinterpret_cast<GLFWwindow*>(_impl);\n\n    auto dt = 1.0f;\n    on_update(dt);\n\n    glViewport(_data.vp_x, _data.vp_y, _data.vp_w, _data.vp_h);\n    glClearColor(0.1f, 0.2f, 0.3f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    on_render();\n    on_debug_ui();\n\n    glfwSwapBuffers(handle);\n    return 0;\n}\n\n} // namespace chk",
    "// Copyright (c) FIRST and other WPILib contributors.\n// Open Source Software; you can modify and/or share it under the terms of\n// the WPILib BSD license file in the root directory of this project.\n\n#include \"Robot.h\"\n\n#include <frc2/command/CommandScheduler.h>\n\nvoid Robot::RobotInit() {}\n\nvoid Robot::RobotPeriodic() {\n  frc2::CommandScheduler::GetInstance().Run();\n}\n\nvoid Robot::DisabledInit() {}\n\nvoid Robot::DisabledPeriodic() {}\n\nvoid Robot::DisabledExit() {}\n\nvoid Robot::AutonomousInit() {\n  m_autonomousCommand = m_container.GetAutonomousCommand();\n\n  if (m_autonomousCommand) {\n    m_autonomousCommand->Schedule();\n  }\n}\n\nvoid Robot::AutonomousPeriodic() {}\n\nvoid Robot::AutonomousExit() {}\n\nvoid Robot::TeleopInit() {\n  if (m_autonomousCommand) {\n    m_autonomousCommand->Cancel();\n  }\n}\n\nvoid Robot::TeleopPeriodic() {}\n\nvoid Robot::TeleopExit() {}\n\nvoid Robot::TestInit() {\n  frc2::CommandScheduler::GetInstance().CancelAll();\n}\n\nvoid Robot::TestPeriodic() {}\n\nvoid Robot::TestExit() {}\n\n#ifndef RUNNING_FRC_TESTS\nint main() {\n  return frc::StartRobot<Robot>();\n}\n#endif\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <omp.h> \n#include <fstream>\n#include <sstream>\n\n\n#define MAX_FOR_THREADS 2\n\nvoid display_matrix( std::vector<std::vector<char>> matrix ) {\n    for ( int x = 0; x < matrix.size(); x ++ ) {\n        for ( int y = 0; y < matrix[0].size(); y++ ) {\n            std::cout << matrix[x][y] << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nstd::vector<std::vector<char>> create_matrix(const std::string& secret_key) {\n    // double start_time = omp_get_wtime();\n    std::string key = secret_key;\n    std::transform(key.begin(), key.end(), key.begin(), ::toupper);\n    std::string result;\n    \n    for (auto c : key) {\n        if (result.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n\n    key = result;\n    std::string alphabet = \"ABCDEFGHIKLMNOPQRSTUVWXYZ\";\n\n    for (char c : key) {\n        alphabet.erase(std::remove(alphabet.begin(), alphabet.end(), c), alphabet.end());\n    }\n    std::vector<std::vector<char>> matrix(5, std::vector<char>(5));\n    int index = 0;\n    int key_size = key.size();\n\n    for (int i = 0; i < 5; ++i)\n    {\n        for (int j = 0; j < 5 && index < key_size; ++j)\n        {\n            matrix[i][j] = key[index++];\n        }\n    }\n\n    for (int i = 0; i < 5; ++i) {\n        for (int j = 0; j < 5 && !alphabet.empty(); ++j) {\n            if (matrix[i][j] == 0) {\n                {\n                    matrix[i][j] = alphabet[0];\n                    alphabet.erase(alphabet.begin());\n                }\n            }\n        }\n    }\n    // double end_time = omp_get_wtime(); \n    // std::cout << \"Time taken for create_matrix: \" << end_time - start_time << \" seconds\" << std::endl;\n    \n    // display_matrix(matrix);\n    return matrix;\n}\n\nstd::pair<int, int> find_position(const std::vector<std::vector<char>>& matrix, char letter) {\n    for (int i = 0; i < 5; ++i) {\n        for (int j = 0; j < 5; ++j) {\n            if (matrix[i][j] == letter) {\n                return std::make_pair(i, j);\n            }\n        }\n    }\n    return std::make_pair(-1, -1);\n}\n\nstd::string encrypt(const std::vector<std::vector<char>>& matrix, const std::string& plaintext) {\n    // double start_time = omp_get_wtime(); \n    std::string text = plaintext;\n    std::transform(text.begin(), text.end(), text.begin(), ::toupper);\n    std::replace(text.begin(), text.end(), 'J', 'I');\n    std::string ciphertext;\n    \n    #pragma omp parallel for ordered num_threads(MAX_FOR_THREADS)\n    for (size_t i = 0; i < text.length(); i += 2) {\n        char a = text[i];\n        char b = i + 1 < text.length() ? text[i + 1] : 'X';\n        if (a == b) {\n            b = 'X';\n        }\n        auto pos_a = find_position(matrix, a);\n        auto pos_b = find_position(matrix, b);\n        int row1 = pos_a.first, col1 = pos_a.second;\n        int row2 = pos_b.first, col2 = pos_b.second;\n        if (row1 == row2) {\n            #pragma omp ordered\n            {\n                ciphertext += matrix[row1][(col1 + 1) % 5];\n                ciphertext += matrix[row2][(col2 + 1) % 5];\n            }\n        } else if (col1 == col2) {\n            #pragma omp ordered\n            {\n                ciphertext += matrix[(row1 + 1) % 5][col1];\n                ciphertext += matrix[(row2 + 1) % 5][col2];\n            }\n        } else {\n            #pragma omp ordered\n            {\n                ciphertext += matrix[row1][col2];\n                ciphertext += matrix[row2][col1];\n            }\n        }\n    }\n    // double end_time = omp_get_wtime();\n    // std::cout << \"Time taken for encrypt: \" << end_time - start_time << \" seconds\" << std::endl;\n    return ciphertext;\n}\n\nstd::string decrypt(const std::vector<std::vector<char>>& matrix, const std::string& ciphertext) {\n    double start_time = omp_get_wtime();\n    std::string text = ciphertext;\n    std::transform(text.begin(), text.end(), text.begin(), ::toupper);\n    std::replace(text.begin(), text.end(), 'J', 'I');\n    std::string decrypted;\n    \n    #pragma omp parallel for ordered num_threads(MAX_FOR_THREADS)\n    for (size_t i = 0; i < text.length(); i += 2) {\n        char a = text[i];\n        char b = i + 1 < text.length() ? text[i + 1] : 'X';\n        if (a == b) {\n            b = 'X';\n        }\n        auto pos_a = find_position(matrix, a);\n        auto pos_b = find_position(matrix, b);\n        int row1 = pos_a.first, col1 = pos_a.second;\n        int row2 = pos_b.first, col2 = pos_b.second;\n        if (row1 == row2) {\n            #pragma omp ordered\n            {\n                decrypted += matrix[row1][(col1 - 1 + 5) % 5];\n                decrypted += matrix[row2][(col2 - 1 + 5) % 5];\n            }\n        } else if (col1 == col2) {\n            #pragma omp ordered\n            {\n                decrypted += matrix[(row1 - 1 + 5) % 5][col1];\n                decrypted += matrix[(row2 - 1 + 5) % 5][col2];\n            }\n        } else {\n            #pragma omp ordered\n            {\n                decrypted += matrix[",
    "#include <iostream>\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstruct Date {\n  int day, month, year;\n\n  Date(int d, int m, int y) : day(d), month(m), year(y) {}\n\n  bool isValidDate() {\n    if (year < 0)\n      return false;\n    if (month < 0 || month > 11)\n      return false;\n    if (day < 1 || day > daysInMonth(month, year))\n      return false;\n    return true;\n  }\n\n  void newDate(int d, int m, int y) {\n    day = d;\n    month = m;\n    year = y;\n  }\n\n  // void printDate() {\n  //   static const string months[] = {\n  //       \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n  //       \"August\", \"September\", \"October\", \"November\", \"December\"\n  //   };\n  //   cout << day << \" \" << months[month] << \", \" << year << endl;\n  // }\n\n  string printDate() {\n    // used static to run it faster. It is not going to be initialized each time\n    static const string months[] = {\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n        \"August\", \"September\", \"October\", \"November\", \"December\"\n    };\n    stringstream ss;\n    ss << day << \" \" << months[month] << \" \" << year;\n    return ss.str();\n  }\n\n  // The first const before Date& other indicates that the other parameter is passed as a reference to a constant and will not be changed inside the method. The second const used after the parentheses indicates that this method does not change the state of the current Date object for which it is called\n  bool operator<(const Date& other) const {\n    if (year != other.year)\n      return year < other.year;\n    if (month != other.month)\n      return month < other.month;\n    return day < other.day;\n  }\n\n  int daysInMonth(int month, int year) {\n    switch (month) {\n      case 0: \n      case 2: \n      case 4: \n      case 6:\n      case 7: \n      case 9: \n      case 11:\n        return 31;\n      case 3: \n      case 5: \n      case 8: \n      case 10:\n        return 30;\n      case 1:\n        return (isLeapYear(year)) ? 29 : 28;\n      default:\n        throw std::logic_error(\"Invalid month\");\n    }\n  }\n  bool isLeapYear(int y) const {\n    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\n  }\n\n  int getDayOfWeek() {\n    int d = day, m = month, y = year;\n    if (m < 3) {\n      m += 12;\n      y--;\n    }\n    int k = y % 100;\n    int j = y / 100;\n    int h = (d + (13 * (m+1)) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;\n    // h = 0 corresponds to Saturday, 1 to Sunday, and so on\n    return (h + 5) % 7;\n  }\n\n  int calculateDifference(const Date& other) const {\n    // Convert both dates to days since a reference date (e.g., January 1, 0 AD)\n    int days1 = day + 31 * (month - 1) + 365 * (year);\n    for (int i = 0; i < year; i++) {\n      if (isLeapYear(i))\n        days1++;\n    }\n\n    int days2 = other.day + 31 * (other.month - 1) + 365 * (other.year);\n    for (int i = 0; i < other.year; i++) {\n      if (other.isLeapYear(i))\n        days2++;\n    }\n\n    // Calculate the difference in days\n    return abs(days2 - days1);\n  }\n};\n\nint main() {\n  string daysOfWeek[] = {\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"};\n  Date d1(13, 3, 2024);\n  Date d2(26, 7, 2024);\n  Date d3(29, 1, 2024);\n  Date d4(12, 6, 2012);\n\n  d2.newDate(25, 7, 2024);\n\n  cout << d2.printDate() << \" is \" << daysOfWeek[d2.getDayOfWeek() - 2] << endl;\n  cout << d1.calculateDifference(d2) << \" days between \" << d1.printDate() << \" and \" << d2.printDate() << endl;\n\n  vector<Date> dates = {d1, d2, d3, d4};\n\n  sort(dates.begin(), dates.end());\n\n  cout << \"Sorted dates:\" << endl;\n  for (auto date : dates) {\n    cout << date.printDate() << endl;\n  }\n\n  return 0;\n}",
    "class Solution {\npublic:\n    int romanToInt(string s) {\n        char prev;\n        int total = 0;\n        for(int i = s.length() - 1; i >= 0; i--) {\n            switch(s[i]) {\n                case 'I':\n                if (prev == 'V' || prev == 'X') {\n                    prev = 'I';\n                    total+= -1;\n                    break;\n                }\n                else {\n                    prev = 'I';\n                    total+= 1;  \n                    break;\n                }\n                case 'V':\n                prev = 'V';\n                total+= 5;\n                break;\n                case 'X':\n                if (prev == 'L' || prev == 'C') {\n                    prev = 'X';\n                    total+= -10;\n                    break;\n                }\n                else {\n                    prev = 'X';\n                    total+= 10;\n                    break;\n                }\n                case 'L':\n                prev = 'L';\n                total+= 50;\n                break;\n                case 'C':\n                if (prev == 'D' || prev == 'M') {\n                    prev = 'C';\n                    total+= -100;\n                    break;\n                }\n                else {\n                prev = 'C';\n                total+= 100;\n                break;\n                }\n                case 'D':\n                prev = 'D';\n                total+= 500;\n                break;\n                case 'M':\n                prev = 'M';\n                total+= 1000;\n                break;\n                default:\n                return 0;\n            }\n        }\n    return total;\n    }\n};\n",
    "#include \"BleKeyboard.h\"\n\n#if defined(USE_NIMBLE)\n#include <NimBLEDevice.h>\n#include <NimBLEServer.h>\n#include <NimBLEUtils.h>\n#include <NimBLEHIDDevice.h>\n#else\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLEServer.h>\n#include \"BLE2902.h\"\n#include \"BLEHIDDevice.h\"\n#endif // USE_NIMBLE\n#include \"HIDTypes.h\"\n#include <driver/adc.h>\n#include \"sdkconfig.h\"\n\n\n#if defined(CONFIG_ARDUHAL_ESP_LOG)\n  #include \"esp32-hal-log.h\"\n  #define LOG_TAG \"\"\n#else\n  #include \"esp_log.h\"\n  static const char* LOG_TAG = \"BLEDevice\";\n#endif\n\n\n// Report IDs:\n#define KEYBOARD_ID 0x01\n#define MEDIA_KEYS_ID 0x02\n\nstatic const uint8_t _hidReportDescriptor[] = {\n  USAGE_PAGE(1),      0x01,          // USAGE_PAGE (Generic Desktop Ctrls)\n  USAGE(1),           0x06,          // USAGE (Keyboard)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  // ------------------------------------------------- Keyboard\n  REPORT_ID(1),       KEYBOARD_ID,   //   REPORT_ID (1)\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0xE0,          //   USAGE_MINIMUM (0xE0)\n  USAGE_MAXIMUM(1),   0xE7,          //   USAGE_MAXIMUM (0xE7)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   Logical Maximum (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x08,          //   REPORT_COUNT (8)\n  HIDINPUT(1),        0x02,          //   INPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 1 byte (Reserved)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE (8)\n  HIDINPUT(1),        0x01,          //   INPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x05,          //   REPORT_COUNT (5) ; 5 bits (Num lock, Caps lock, Scroll lock, Compose, Kana)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  USAGE_PAGE(1),      0x08,          //   USAGE_PAGE (LEDs)\n  USAGE_MINIMUM(1),   0x01,          //   USAGE_MINIMUM (0x01) ; Num Lock\n  USAGE_MAXIMUM(1),   0x05,          //   USAGE_MAXIMUM (0x05) ; Kana\n  HIDOUTPUT(1),       0x02,          //   OUTPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 3 bits (Padding)\n  REPORT_SIZE(1),     0x03,          //   REPORT_SIZE (3)\n  HIDOUTPUT(1),       0x01,          //   OUTPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    NKR,          //   REPORT_COUNT (6) ; 6 bytes (Keys)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE(8)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM(0)\n  LOGICAL_MAXIMUM(1), 0x65,          //   LOGICAL_MAXIMUM(0x65) ; 101 keys\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0x00,          //   USAGE_MINIMUM (0)\n  USAGE_MAXIMUM(1),   0x65,          //   USAGE_MAXIMUM (0x65)\n  HIDINPUT(1),        0x00,          //   INPUT (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  END_COLLECTION(0),                 // END_COLLECTION\n  // ------------------------------------------------- Media Keys\n  USAGE_PAGE(1),      0x0C,          // USAGE_PAGE (Consumer)\n  USAGE(1),           0x01,          // USAGE (Consumer Control)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  REPORT_ID(1),       MEDIA_KEYS_ID, //   REPORT_ID (3)\n  USAGE_PAGE(1),      0x0C,          //   USAGE_PAGE (Consumer)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   LOGICAL_MAXIMUM (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x10,          //   REPORT_COUNT (16)\n  USAGE(1),           0xB5,          //   USAGE (Scan Next Track)     ; bit 0: 1\n  USAGE(1),           0xB6,          //   USAGE (Scan Previous Track) ; bit 1: 2\n  USAGE(1),           0xB7,          //   USAGE (Stop)                ; bit 2: 4\n  USAGE(1),           0xCD,          //   USAGE (Play/Pause)          ; bit 3: 8\n  USAGE(1),           0xE2,          //   USAGE (Mute)                ; bit 4: 16\n  USAGE(1),           0xE9,          //   USAGE (Volume Increment)    ; bit 5: 32\n  USAGE(1),           0xEA,          //   USAGE (Volume Decrement)    ; bit 6: 64\n  USAGE(2),           0x23, 0x02,    //   Usage (WWW Home)            ; bit 7: 128\n  USAGE(2),           0x94, 0x01,    //   Usage (My Computer) ; bit 0: 1\n  USAGE(2),           0x92, 0x01,    //   Usage (Calculator)  ; bit 1: 2\n  USAGE(2),           0x2A, 0x02,    //   Usage (WWW fav)     ; bit 2: 4\n  USAGE(2),           0x21, 0x02,    //   Usage (WWW search)  ; bit 3: 8\n  USAGE(2),           0x26, 0x02,    //   Usage (WWW stop)    ; bit 4: 16\n  USAGE(2),           0x24, 0x02,    //   Usage (WWW back)    ; bit 5: 32\n  USAGE(2),           0x83, 0x01,    //   Usage (Media sel)   ; bit 6: 64\n  USAGE(2),           0x8A, 0x01,    //   Usage (Mai",
    "#include <iostream>\n#include <unordered_map>\n#include <list>\n\nusing namespace std;\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity) : _capacity(capacity) {}\n\n    int get(int key) {\n        auto it = _cache.find(key);\n        if (it == _cache.end()) return -1;\n\n        // Move accessed page to the front of the list\n        _accessOrder.splice(_accessOrder.begin(), _accessOrder, it->second);\n\n        return it->second->second;\n    }\n\n    void put(int key, int value) {\n        auto it = _cache.find(key);\n        if (it != _cache.end()) {\n            // Update the value and move the page to the front of the list\n            it->second->second = value;\n            _accessOrder.splice(_accessOrder.begin(), _accessOrder, it->second);\n            return;\n        }\n\n        if (_cache.size() >= _capacity) {\n            // Remove the least recently used page from the cache\n            int lruKey = _accessOrder.back().first;\n            _cache.erase(lruKey);\n            _accessOrder.pop_back();\n        }\n\n        // Add the new page to the cache and the front of the list\n        _accessOrder.emplace_front(key, value);\n        _cache[key] = _accessOrder.begin();\n    }\n\nprivate:\n    int _capacity;\n    list<pair<int, int>> _accessOrder; // List to keep track of the access order\n    unordered_map<int, list<pair<int, int>>::iterator> _cache; // Map to quickly look up a page\n};\n\nint main() {\n    LRUCache cache(2);\n\n    cache.put(1, 1);\n    cache.put(2, 2);\n    cout << cache.get(1) << endl; // Returns 1\n    cache.put(3, 3); // Evicts key 2\n    cout << cache.get(2) << endl; // Returns -1 (not found)\n    cache.put(4, 4); // Evicts key 1\n    cout << cache.get(1) << endl; // Returns -1 (not found)\n    cout << cache.get(3) << endl; // Returns 3\n    cout << cache.get(4) << endl; // Returns 4\n\n    return 0;\n}\n",
    "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"avb_ops_user.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/fs.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <cutils/properties.h>\n#include <fs_mgr.h>\n\n#include <libavb_ab/libavb_ab.h>\n\nusing android::fs_mgr::Fstab;\nusing android::fs_mgr::GetEntryForMountPoint;\nusing android::fs_mgr::ReadDefaultFstab;\nusing android::fs_mgr::ReadFstabFromFile;\n\n/* Open the appropriate fstab file and fallback to /fstab.device if\n * that's what's being used.\n */\nstatic bool open_fstab(Fstab* fstab) {\n  return ReadDefaultFstab(fstab) || ReadFstabFromFile(\"/fstab.device\", fstab);\n}\n\nstatic int open_partition(const char* name, int flags) {\n  char* path;\n  int fd;\n\n  /* Per https://android-review.googlesource.com/c/platform/system/core/+/674989\n   * Android now supports /dev/block/by-name/<partition_name> ... try that\n   * first.\n   */\n  path = avb_strdupv(\"/dev/block/by-name/\", name, NULL);\n  if (path != NULL) {\n    fd = open(path, flags);\n    avb_free(path);\n    if (fd != -1) {\n      return fd;\n    }\n  }\n\n  /* OK, so /dev/block/by-name/<partition_name> didn't work... so we're\n   * falling back to what we used to do before that:\n   *\n   * We can't use fs_mgr to look up |name| because fstab doesn't list\n   * every slot partition (it uses the slotselect option to mask the\n   * suffix) and |slot| is expected to be of that form, e.g. boot_a.\n   *\n   * We can however assume that there's an entry for the /misc mount\n   * point and use that to get the device file for the misc\n   * partition. From there we'll assume that a by-name scheme is used\n   * so we can just replace the trailing \"misc\" by the given |name|,\n   * e.g.\n   *\n   *   /dev/block/platform/soc.0/7824900.sdhci/by-name/misc ->\n   *   /dev/block/platform/soc.0/7824900.sdhci/by-name/boot_a\n   *\n   * If needed, it's possible to relax this assumption in the future\n   * by trawling /sys/block looking for the appropriate sibling of\n   * misc and then finding an entry in /dev matching the sysfs entry.\n   */\n\n  Fstab fstab;\n  if (!open_fstab(&fstab)) {\n    return -1;\n  }\n  auto record = GetEntryForMountPoint(&fstab, \"/misc\");\n  if (record == nullptr) {\n    return -1;\n  }\n  if (strcmp(name, \"misc\") == 0) {\n    path = strdup(record->blk_device.c_str());\n  } else {\n    size_t trimmed_len, name_len;\n    const char* end_slash = strrchr(record->blk_device.c_str(), '/');\n    if (end_slash == NULL) {\n      return -1;\n    }\n    trimmed_len = end_slash - record->blk_device.c_str() + 1;\n    name_len = strlen(name);\n    path = static_cast<char*>(calloc(trimmed_len + name_len + 1, 1));\n    strncpy(path, record->blk_device.c_str(), trimmed_len);\n    strncpy(path + trimmed_len, name, name_len);\n  }\n\n  fd = open(path, flags);\n  free(path);\n\n  return fd;\n}\n\nstatic AvbIOResult read_from_partition(AvbOps* ops,\n                                       const char* partition,\n                                       int64_t offset,\n                                       size_t num_bytes,\n                                       void* buffer,\n                                       size_t* out_num_read) {\n  int fd;\n  off_t where;\n  ssize_t num_read;\n  AvbIOResult ret;\n\n  fd = open_partition(partition, O_RDONLY);\n  if (fd == -1) {\n    ret = AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION;\n    goto out;\n  }\n\n  if (offset < 0) {\n    uint64_t partition_size;\n    if (ioctl(fd, BLKGETSIZE64, &partition_size) != 0) {\n      avb_error(\"Error getting size of \\\"\", partition, \"\\\" partition.\\n\");\n      ret = AVB_IO_RESULT_ERROR_IO;\n      goto out;\n    }\n    offset = partition_size - (-offset);\n  }\n\n  where = lseek(fd, offset, SEEK_SET);\n  if (where == -1) {\n    avb_error(\"Error seeking to offset.\\n\");\n    ret = AVB_IO_RESULT_ERROR_IO;\n    goto out;\n  }\n  if (where != offset) {\n    avb_error(\"Error se",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"model.h\"\n\nusing namespace MyNamespace;\n\ndouble Model::getResult() const { return result; }\n\nModel::graph_type Model::getGraphData() const { return graphData; }\n\nvoid Model::calculateValue(std::string& expression, double x) {\n  std::queue<Token> rpnTokens = process(expression);\n  result = calculate(&rpnTokens, x);\n}\n\nvoid Model::calculateGraph(std::string& expression, double xmin, double xmax) {\n  std::queue<Token> rpnTokens = process(expression);\n  std::queue<Token> tmp;\n  graphData.first.clear();\n  graphData.second.clear();\n  double X = xmin, h = (xmax - xmin) / 10000;\n  while (X <= xmax) {\n    tmp = rpnTokens;\n    graphData.first.push_back(X);\n    graphData.second.push_back(calculate(&tmp, X));\n    X += h;\n  }\n}\n\nstd::queue<Token> Model::process(std::string& expression) {\n  std::queue<Token> tokens;\n  std::queue<Token> rpnTokens;\n  parse(expression, &tokens);\n  check(&tokens);\n  convert(&tokens, &rpnTokens);\n  return rpnTokens;\n}\n\nvoid Model::parse(std::string& expression, std::queue<Token>* tokens) {\n  size_t index = 0;\n  size_t oParanthQnt = 0, cParanthQnt = 0;\n  std::string token;\n  const std::map<std::string, Token> token_map = setTokenMap();\n  while (index < expression.size()) {\n    if (isalpha(expression[index])) {\n      token = readFunction(expression, index);\n    } else if (isdigit(expression[index])) {\n      token = readNumber(expression, index);\n    } else {\n      token = expression[index];\n      index++;\n    }\n    if (token == \"(\") oParanthQnt++;\n    if (token == \")\") cParanthQnt++;\n    if (token != \" \") pushToken(token, tokens, token_map);\n  }\n  if (oParanthQnt != cParanthQnt) throw std::string(\"check brackets!\");\n}\n\nstd::map<std::string, Token> Model::setTokenMap() {\n  const std::map<std::string, Token> token_map{\n      {\"x\", Token(\"x\", 0, p1, tNum, nullptr)},\n      {\"+\", Token(\"+\", 0, p2, tBinOperator, std::plus<double>())},\n      {\"-\", Token(\"-\", 0, p2, tBinOperator, std::minus<double>())},\n      {\"*\", Token(\"*\", 0, p3, tBinOperator, std::multiplies<double>())},\n      {\"/\", Token(\"/\", 0, p3, tBinOperator, std::divides<double>())},\n      {\"mod\", Token(\"mod\", 0, p3, tBinOperator, fmodl)},\n      {\"^\", Token(\"^\", 0, p4, tBinOperator, powl)},\n      {\"cos\", Token(\"cos\", 0, p5, tFunc, cosl)},\n      {\"sin\", Token(\"sin\", 0, p5, tFunc, sinl)},\n      {\"tan\", Token(\"tan\", 0, p5, tFunc, tanl)},\n      {\"acos\", Token(\"acos\", 0, p5, tFunc, acosl)},\n      {\"asin\", Token(\"asin\", 0, p5, tFunc, asinl)},\n      {\"atan\", Token(\"atan\", 0, p5, tFunc, atanl)},\n      {\"sqrt\", Token(\"sqrt\", 0, p5, tFunc, sqrtl)},\n      {\"ln\", Token(\"ln\", 0, p5, tFunc, logl)},\n      {\"log\", Token(\"log\", 0, p5, tFunc, log10l)},\n      {\"(\", Token(\"(\", 0, p0, tOpenParanth, nullptr)},\n      {\")\", Token(\")\", 0, p0, tClosedParanth, nullptr)}};\n  return token_map;\n}\n\nstd::string Model::readFunction(std::string& expression, size_t& index) {\n  std::regex word_regex(\"([a-z]+)\");\n  std::sregex_iterator regex_iter = std::sregex_iterator(\n      expression.begin() + index, expression.end(), word_regex);\n  std::smatch match = *regex_iter;\n  index += match.length();\n  return match.str();\n}\n\nstd::string Model::readNumber(std::string& expression, size_t& index) {\n  std::regex number_regex(\"\\\\d+([.]\\\\d+)?(e([-+])?\\\\d+)?\");\n  std::sregex_iterator regex_iter = std::sregex_iterator(\n      expression.begin() + index, expression.end(), number_regex);\n  std::smatch match = *regex_iter;\n  index += match.length();\n  return match.str();\n}\n\nvoid Model::pushToken(std::string& token_name, std::queue<Token>* tokens,\n                      const std::map<std::string, Token>& token_map) {\n  if (std::isdigit(token_name[0])) {\n    tokens->push(Token(\"num\", std::stod(token_name), p1, tNum, nullptr));\n  } else {\n    auto token_map_it = token_map.find(token_name);\n    if (token_map_it == token_map.end()) throw token_name;\n    if ((token_name == \"+\" || token_name == \"-\") &&\n        (tokens->empty() || tokens->back().type == tOpenParanth))\n      tokens->push(Token(\"num\", 0, p1, tNum, nullptr));\n    tokens->push(token_map_it->second);\n  }\n}\n\nvoid Model::check(std::queue<Token>* tokens) {\n  const bool checkMatrix[tokenTypes][tokenTypes] = {\n      {1, 0, 0, 1, 1},  // tOpenParanth\n      {0, 1, 1, 0, 0},  // tClosedParanth\n      {1, 0, 0, 1, 0},  // tNum\n      {0, 1, 1, 0, 0},  // tBinOperator\n      {1, 0, 0, 1, 0},  // tFunc\n  };\n  std::queue<Token> tmp;\n  Token currToken;\n  Token prevToken = tokens->front();\n  tokens->pop();\n  tmp.push(prevToken);\n  while (!tokens->empty()) {\n    currToken = tokens->front();\n    if (!checkMatrix[currToken.type][prevToken.type])\n      throw prevToken.name + currToken.name;\n    tmp.push(currToken);\n    prevToken = currToken;\n    tokens->pop();\n  }\n  if (prevToken.type != tNum && prevToken.type != tClosedParanth)\n    throw prevToken.name;\n  *tokens = tmp;\n}\n\nvoid Model::convert(std::queue<Token>* tokens, std::queue<Token>* converted) {\n  Token token;\n  std::stack<Token> support;\n  while (!tokens->empty()) {\n    token = tokens->front();\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expence_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include \"Graph.h\"\n\nusing namespace std;\n\nstruct Crew\n{\n\tCrew()\n\t{\n\n\t}\n\tCrew(unsigned int id, std::string name, std::string rank)\n\t\t: mIdx(id), mName(name), mRank(rank)\n\t{\n\n\t}\n\tCrew(const Crew& rhs)\n\t{\n\t\tthis->mIdx = rhs.mIdx;\n\t\tthis->mName = rhs.mName;\n\t\tthis->mRank = rhs.mRank;\n\t}\n\tCrew& operator=(const Crew& rhs)\n\t{\n\t\tthis->mIdx = rhs.mIdx;\n\t\tthis->mName = rhs.mName;\n\t\tthis->mRank = rhs.mRank;\n\t\treturn *this;\n\t}\n\t~Crew()\n\t{\n\n\t}\n\tbool operator==(const Crew& rhs)\n\t{\n\t\tbool det = (this->mIdx == rhs.mIdx) && (this->mName == rhs.mName) && (this->mRank == rhs.mName);\n\t\treturn det;\n\t}\n\n\tbool operator!=(const Crew& rhs)\n\t{\n\t\treturn !operator==(rhs);\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const Crew& rhs);\n\n\tunsigned int mIdx;\n\tstd::string mName;\n\tstd::string mRank;\n};\n\nostream& operator<<(ostream& os, const Crew& rhs)\n{\n\tos << \"ID : \" << rhs.mIdx << std::endl;\n\tos << \"Name : \" << rhs.mName << std::endl;\n\tos << \"Rank : \" << rhs.mRank << std::endl;\n\treturn os;\n}\n\n\nint main(void)\n{\n\n\tCrew cr0(0, \"Janeway\", \"Captain\");\n\tCrew cr1(1, \"Chakotay\", \"Commander\");\n\tCrew cr2(2, \"Tuvok\", \"Lt. Commander\");\n\tCrew cr3(3, \"Torres\", \"Lieutenant\");\n\tCrew cr4(4, \"Paris\", \"Lieutenant\");\n\tCrew cr5(5, \"Kim\", \"Ensign\");\n\tCrew cr6(6, \"EMH Doctor\", \"N/A\");\n\tCrew cr7(7, \"Neelix\", \"N/A\");\n\tCrew cr8(8, \"Seven\", \"N/A\");\n\tCrew cr9(9, \"Wildman\", \"Ensign\");\n\n\tGraph<10, Crew> crGraph;\n\n\tcrGraph.AddEdge(cr0, cr1); crGraph.AddEdge(cr0, cr2); crGraph.AddEdge(cr0, cr4);\n\tcrGraph.AddEdge(cr0, cr5); crGraph.AddEdge(cr0, cr7); crGraph.AddEdge(cr0, cr8);\n\n\tcrGraph.AddEdge(cr1, cr0); crGraph.AddEdge(cr1, cr2); crGraph.AddEdge(cr1, cr3);\n\tcrGraph.AddEdge(cr1, cr4);\n\n\tcrGraph.AddEdge(cr2, cr0); crGraph.AddEdge(cr2, cr1); crGraph.AddEdge(cr2, cr9);\n\n\tcrGraph.AddEdge(cr3, cr1); crGraph.AddEdge(cr3, cr4);\n\n\tcrGraph.AddEdge(cr4, cr0); crGraph.AddEdge(cr4, cr1); crGraph.AddEdge(cr4, cr3);\n\tcrGraph.AddEdge(cr4, cr5);\n\n\tcrGraph.AddEdge(cr5, cr0); crGraph.AddEdge(cr5, cr4); crGraph.AddEdge(cr5, cr6);\n\n\tcrGraph.AddEdge(cr6, cr5);\n\n\tcrGraph.AddEdge(cr7, cr0); crGraph.AddEdge(cr7, cr8); crGraph.AddEdge(cr7, cr9);\n\n\tcrGraph.AddEdge(cr8, cr0); crGraph.AddEdge(cr8, cr7);\n\n\tcrGraph.AddEdge(cr9, cr2); crGraph.AddEdge(cr9, cr7);\n\n\tcrGraph.ShowGraphEdgeInfo();\n\n\tcout << \"----- DFS Search of the graph -----\" << endl;\n\n\tcout << \" starting from node 0\" << endl;\n\tcrGraph.DFSShowGraph(cr0);\n\n\tcout << endl << endl << \"starting from node 1\" << endl;\n\tcrGraph.DFSShowGraph(cr1);\n\n\tcout << endl << endl << \"starting from node 3\" << endl;\n\tcrGraph.DFSShowGraph(cr3);\n\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lucky\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"converter.hpp\"\n#include <string_view>\n\nstd::string Converter::markdownToHTML(std::string markdownText) {\n    std::vector<std::string> preBlocks;\n    std::regex preBlockPattern(\"```([\\\\s\\\\S]*?)```\");\n    std::regex boldPattern(\"\\\\*\\\\*(.*?)\\\\*\\\\*\");\n    std::regex italicPattern(\"_([a-zA-Z][a-zA-Z\\\\s_]*[a-zA-Z])_\");\n    std::regex ttPattern(\"`([a-zA-Z][a-zA-Z\\\\s_]*[a-zA-Z])`\");\n\n\n    std::smatch match;\n    while (std::regex_search(markdownText, match, preBlockPattern)) {\n        preBlocks.push_back(match.str(1));\n        markdownText = std::regex_replace(markdownText, preBlockPattern, \"%%PRE_BLOCK%%\",\n                                          std::regex_constants::format_first_only);\n    }\n\n    markdownText = std::regex_replace(markdownText, boldPattern, \"<b>$1</b>\");\n    markdownText = std::regex_replace(markdownText, italicPattern, \"<i>$1</i>\");\n    markdownText = std::regex_replace(markdownText, ttPattern, \"<tt>$1</tt>\");\n\n    _checkCoherence(markdownText);\n    _checkOpenedTags(markdownText);\n\n    for (size_t i = 0; i < preBlocks.size(); ++i) {\n        markdownText = std::regex_replace(markdownText, std::regex(\"%%PRE_BLOCK%%\"), \"<pre>\" + preBlocks[i] + \"</pre>\",\n                                          std::regex_constants::format_first_only);\n    }\n\n    std::vector<std::string> paragraphs = splitParagraphs(markdownText);\n\n    return std::accumulate(paragraphs.begin(), paragraphs.end(), std::string{},\n                           [](const std::string &a, const std::string &b) {\n                               if (!a.empty())\n                                   return a + '\\n' + b;\n                               else\n                                   return a + b;\n    });\n}\n\nstd::vector<std::string> Converter::splitParagraphs(const std::string& markdownText) {\n    std::vector<std::string> paragraphs;\n\n    std::regex paragraphSeparator(\"\\\\n\\\\s*\\\\n\");\n    std::sregex_token_iterator iter(markdownText.begin(), markdownText.end(), paragraphSeparator, -1);\n    std::sregex_token_iterator end;\n    for (; iter != end; ++iter) {\n        std::string paragraph = *iter;\n        paragraph = std::regex_replace(paragraph, std::regex(\"^\\\\s+|\\\\s+$\"), \"\");\n\n        if (!std::regex_search(paragraph, std::regex(\"<\\\\/?[a-z][\\\\s\\\\S]*>\", std::regex_constants::icase))) {\n            paragraph = \"<p>\" + paragraph + \"</p>\";\n        }\n        paragraphs.push_back(paragraph);\n    }\n\n    return paragraphs;\n}\n\nvoid Converter::_checkCoherence(const std::string &markdownText) {\n    std::regex tagPattern(\"<\\\\/?[^>]+>\");\n    std::sregex_iterator it(markdownText.begin(), markdownText.end(), tagPattern);\n    std::sregex_iterator it_end;\n\n    std::vector<std::string> tags;\n    while (it != it_end) {\n        tags.push_back(it->str());\n        ++it;\n    }\n\n    for (size_t i = 0; i < tags.size(); i += 2) {\n        if (tags[i] != std::regex_replace(tags[i + 1], std::regex(\"/\"), \"\")) {\n            throw std::runtime_error(\"There are nested loops\");\n        }\n    }\n}\n\nvoid Converter::_checkOpenedTags(const std::string &markdownText) {\n    std::vector<std::string> words;\n    std::istringstream iss(markdownText);\n    for (std::string s; iss >> s;)\n        words.push_back(s);\n\n    std::vector<std::string> markdownSymbols = {\"**\", \"_\", \"`\"};\n    for (const auto &word: words) {\n        for (const auto &symbol: markdownSymbols) {\n            if ((word.starts_with(symbol) || word.ends_with(symbol)) && word != symbol) {\n                throw std::runtime_error(\"There is not finished markdown - \" + word);\n            }\n        }\n    }\n}\n\nstd::string Converter::formatTextWithANSI(const std::string& text) {\n\n    const std::map<std::string, std::string> tagMap = {\n            {\"<b>\", \"\\x1b[1m\"},\n            {\"<tt>\", \"\\x1b[7m\"},\n            {\"<pre>\", \"\\x1b[7m\"},\n            {\"<i>\", \"\\x1b[3m\"},\n            {\"<p>\", \"\\t\"}\n    };\n\n    const std::map<std::string, std::string> endTagMap = {\n            {\"</b>\", \"\\x1b[0m\"},\n            {\"</tt>\", \"\\x1b[0m\"},\n            {\"</pre>\", \"\\x1b[0m\"},\n            {\"</i>\", \"\\x1b[0m\"},\n            {\"</p>\", \"\"}\n    };\n\n    std::string formattedText = text;\n\n    for (const auto& pair : tagMap) {\n        formattedText = std::regex_replace(formattedText, std::regex(pair.first), pair.second);\n    }\n\n    for (const auto& pair : endTagMap) {\n        formattedText = std::regex_replace(formattedText, std::regex(pair.first), pair.second);\n    }\n\n    return formattedText;\n}\n",
    "#include \"MD5.h\"\n\nMD5::MD5()\n{\n\t//nothing\n\treturn;\n}\n\nchar* MD5::make_digest(const unsigned char *digest, int len) /* {{{ */\n{\n\tchar * md5str = (char*) malloc(sizeof(char)*(len*2+1));\n\tstatic const char hexits[17] = \"0123456789abcdef\";\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tmd5str[i * 2]       = hexits[digest[i] >> 4];\n\t\tmd5str[(i * 2) + 1] = hexits[digest[i] &  0x0F];\n\t}\n\tmd5str[len * 2] = '\\0';\n\treturn md5str;\n}\n\n/*\n * The basic MD5 functions.\n *\n * E and G are optimized compared to their RFC 1321 definitions for\n * architectures that lack an AND-NOT instruction, just like in Colin Plumb's\n * implementation.\n * E() has been used instead of F() because F() is already defined in the Arduino core\n */\n#define E(x, y, z)\t\t\t((z) ^ ((x) & ((y) ^ (z))))\n#define G(x, y, z)\t\t\t((y) ^ ((z) & ((x) ^ (y))))\n#define H(x, y, z)\t\t\t((x) ^ (y) ^ (z))\n#define I(x, y, z)\t\t\t((y) ^ ((x) | ~(z)))\n\n/*\n * The MD5 transformation for all four rounds.\n */\n#define STEP(f, a, b, c, d, x, t, s) \\\n\t(a) += f((b), (c), (d)) + (x) + (t); \\\n\t(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \\\n\t(a) += (b);\n\n/*\n * SET reads 4 input bytes in little-endian byte order and stores them\n * in a properly aligned word in host byte order.\n *\n * The check for little-endian architectures that tolerate unaligned\n * memory accesses is just an optimization.  Nothing will break if it\n * doesn't work.\n */\n#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)\n# define SET(n) \\\n\t(*(MD5_u32plus *)&ptr[(n) * 4])\n# define GET(n) \\\n\tSET(n)\n#else\n# define SET(n) \\\n\t(ctx->block[(n)] = \\\n\t(MD5_u32plus)ptr[(n) * 4] | \\\n\t((MD5_u32plus)ptr[(n) * 4 + 1] << 8) | \\\n\t((MD5_u32plus)ptr[(n) * 4 + 2] << 16) | \\\n\t((MD5_u32plus)ptr[(n) * 4 + 3] << 24))\n# define GET(n) \\\n\t(ctx->block[(n)])\n#endif\n\n/*\n * This processes one or more 64-byte data blocks, but does NOT update\n * the bit counters.  There are no alignment requirements.\n */\nconst void *MD5::body(void *ctxBuf, const void *data, size_t size)\n{\n\tMD5_CTX *ctx = (MD5_CTX*)ctxBuf;\n\tconst unsigned char *ptr;\n\tMD5_u32plus a, b, c, d;\n\tMD5_u32plus saved_a, saved_b, saved_c, saved_d;\n\n\tptr = (unsigned char*)data;\n\n\ta = ctx->a;\n\tb = ctx->b;\n\tc = ctx->c;\n\td = ctx->d;\n\n\tdo {\n\t\tsaved_a = a;\n\t\tsaved_b = b;\n\t\tsaved_c = c;\n\t\tsaved_d = d;\n\n/* Round 1\n * E() has been used instead of F() because F() is already defined in the Arduino core\n */\n\t\tSTEP(E, a, b, c, d, SET(0), 0xd76aa478, 7)\n\t\tSTEP(E, d, a, b, c, SET(1), 0xe8c7b756, 12)\n\t\tSTEP(E, c, d, a, b, SET(2), 0x242070db, 17)\n\t\tSTEP(E, b, c, d, a, SET(3), 0xc1bdceee, 22)\n\t\tSTEP(E, a, b, c, d, SET(4), 0xf57c0faf, 7)\n\t\tSTEP(E, d, a, b, c, SET(5), 0x4787c62a, 12)\n\t\tSTEP(E, c, d, a, b, SET(6), 0xa8304613, 17)\n\t\tSTEP(E, b, c, d, a, SET(7), 0xfd469501, 22)\n\t\tSTEP(E, a, b, c, d, SET(8), 0x698098d8, 7)\n\t\tSTEP(E, d, a, b, c, SET(9), 0x8b44f7af, 12)\n\t\tSTEP(E, c, d, a, b, SET(10), 0xffff5bb1, 17)\n\t\tSTEP(E, b, c, d, a, SET(11), 0x895cd7be, 22)\n\t\tSTEP(E, a, b, c, d, SET(12), 0x6b901122, 7)\n\t\tSTEP(E, d, a, b, c, SET(13), 0xfd987193, 12)\n\t\tSTEP(E, c, d, a, b, SET(14), 0xa679438e, 17)\n\t\tSTEP(E, b, c, d, a, SET(15), 0x49b40821, 22)\n\n/* Round 2 */\n\t\tSTEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)\n\t\tSTEP(G, d, a, b, c, GET(6), 0xc040b340, 9)\n\t\tSTEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)\n\t\tSTEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)\n\t\tSTEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)\n\t\tSTEP(G, d, a, b, c, GET(10), 0x02441453, 9)\n\t\tSTEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)\n\t\tSTEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)\n\t\tSTEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)\n\t\tSTEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)\n\t\tSTEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)\n\t\tSTEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)\n\t\tSTEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)\n\t\tSTEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)\n\t\tSTEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)\n\t\tSTEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)\n\n/* Round 3 */\n\t\tSTEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)\n\t\tSTEP(H, d, a, b, c, GET(8), 0x8771f681, 11)\n\t\tSTEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)\n\t\tSTEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)\n\t\tSTEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)\n\t\tSTEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)\n\t\tSTEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)\n\t\tSTEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)\n\t\tSTEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)\n\t\tSTEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)\n\t\tSTEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)\n\t\tSTEP(H, b, c, d, a, GET(6), 0x04881d05, 23)\n\t\tSTEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)\n\t\tSTEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)\n\t\tSTEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)\n\t\tSTEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)\n\n/* Round 4 */\n\t\tSTEP(I, a, b, c, d, GET(0), 0xf4292244, 6)\n\t\tSTEP(I, d, a, b, c, GET(7), 0x432aff97, 10)\n\t\tSTEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)\n\t\tSTEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)\n\t\tSTEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)\n\t\tSTEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)\n\t\tSTEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)\n\t\tSTEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)\n\t\tSTEP(",
    "/*\r\n=====================================================================================================================================================================\r\nB\u00e0i 9: \u0110\u1ec1 b\u00e0i:\r\nCho s\u1ed1 nguy\u00ean d\u01b0\u01a1ng N c\u00f3 \u00edt nh\u1ea5t 5 ch\u1eef s\u1ed1,nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00f3a \u0111i 3 ch\u1eef s\u1ed1 cu\u1ed1i c\u00f9ng c\u1ee7a N v\u00e0 in ra nh\u1eefng ch\u1eef s\u1ed1 c\u00f2n l\u1ea1i.\r\nV\u00ed d\u1ee5 N = 12345 sau khi x\u00f3a \u0111i 3 ch\u1eef s\u1ed1 cu\u1ed1i c\u00f9ng th\u00ec N = 12.\r\n=====================================================================================================================================================================\r\n- G\u1ee3i \u00fd:\r\n\u0110\u1ed1i v\u1edbi ph\u00e9p chia nguy\u00ean n\u1ebfu b\u1ea1n mu\u1ed1n x\u00f3a \u0111i 1 ch\u1eef s\u1ed1 cu\u1ed1i c\u00f9ng ch\u1ec9 c\u1ea7n l\u1ea5y N chia nguy\u00ean cho 10.\r\nV\u00ed d\u1ee5 N = 12345 / 10 = 1234, t\u01b0\u01a1ng t\u1ef1 N = 12345 / 100 = 123, N = 12345 / 1000 = 12....\r\n=====================================================================================================================================================================\r\n- Input Format:\r\nD\u00f2ng duy nh\u1ea5t ch\u1ee9a s\u1ed1 nguy\u00ean d\u01b0\u01a1ng N\r\n=====================================================================================================================================================================\r\n- Constraints:\r\n10000 <= N <= 10^18\r\n=====================================================================================================================================================================\r\n- Output Format:\r\nIn ra N sau khi x\u00f3a \u0111i 3 ch\u1eef s\u1ed1 cu\u1ed1i c\u00f9ng\r\n=====================================================================================================================================================================\r\n- Sample Input 0:\r\n999999999999993728\r\n=====================================================================================================================================================================\r\n- Sample Output 0:\r\n999999999999993\r\n=====================================================================================================================================================================\r\n*/\r\n                                                                                    B\u00e0i gi\u1ea3i:\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    long long n;\r\n    cin >> n;\r\n    \r\n    cout << n / 1000 << endl;\r\n    \r\n    return 0;\r\n}\r\n",
    "#include \"rational.h\"\r\n#include \"matrix_sq.h\"\r\n#include <cassert>\r\n#include <algorithm>\r\n#include <iostream>\r\n#include <vector>\r\n#include <ctime>\r\n\r\n//\u0416\u0435\u0440\u043d\u043e\u0441\u0435\u043a \u0414\u0430\u043d\u0438\u0438\u043b, 11 \u0433\u0440\u0443\u043f\u043f\u0430\r\nint main() {\r\n    srand(std::time(NULL));\r\n    std::vector<std::vector<Rational>> arr{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\r\n    Matrix<3, 4, Rational> m1(arr);\r\n    Matrix<3, 4> m2(arr);\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 4; j++) {\r\n            m2[i][j] = Rational(rand() % 6);\r\n        }\r\n    }\r\n    std::cout << \"m1<3, 4>:\\n\" << m1 << \"rank m1:\" << m1.rank();\r\n    std :: cout << \"\\nm2<3, 4>\\n\" << m2 << \"rank m2:\" << m2.rank() << \"\\nm1 + m2:\\n\" << m1 + m2 << \"m2.transpored:\\n\" << m2.transpored();\r\n\r\n    Matrix<3, 3> sq_m1;\r\n    std::vector<std::vector<Rational>> sq_arr{ {1, 2, 3}, {4, 5, 6}, {7, 8, -9} };\r\n    SquareMatrix<3> sq_m2(sq_arr);\r\n    std::cout << \"Enter elements of square matrix #1:\\n\";\r\n    std::cin >> sq_m1;\r\n    std::cout << \"sq_m1<3, 3>:\\n\" << sq_m1 << \"trace sq_m1:\" << sq_m1.trace() << \"\\ndet sq_m1:\" << sq_m1.det();\r\n    std::cout << \"\\nsq_m2<3>:\\n\" << sq_m2 << \"trace sq_m2:\" << sq_m2.trace() << \"\\ndet sq_m2:\" << sq_m2.det();\r\n    std::cout << \"\\ninverted:\\n\" << sq_m2.inverted();\r\n    std::cout << \"\\n sq_m2 * m2\\n\" << sq_m2 * m2;\r\n    sq_m1 *= sq_m1;\r\n    std::cout << \"\\n(sq_m1)^2\\n\" << sq_m1;\r\n}\r\n",
    "#include <Mesh.h>\n\nMesh::Mesh()\n{\n    VAO = 0, VBO = 0, IBO = 0, indexCount = 0;\n}\n\nvoid Mesh::CreateMesh(GLfloat *vertices, GLuint *indices, unsigned int verticesBufferSize, unsigned int indicesBufferSize)\n{\n    indexCount = indicesBufferSize / sizeof(unsigned int);\n\n    glGenVertexArrays(1, &VAO);\n    glBindVertexArray(VAO);\n\n    glGenBuffers(1, &IBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesBufferSize, indices, GL_STATIC_DRAW);\n\n    glGenBuffers(1, &VBO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, verticesBufferSize, vertices, GL_STATIC_DRAW);\n\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);\n    glEnableVertexAttribArray(0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}\n\nvoid Mesh::RenderMesh() \n{\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);\n\n    glDrawElements(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, 0);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}\n\nvoid Mesh::ClearMesh() \n{\n    if (IBO != 0) \n    {\n        glDeleteBuffers(1, &IBO);\n        IBO = 0;\n    }\n\n    if (VBO != 0)\n    {\n        glDeleteBuffers(1, &VBO);\n        VBO = 0;\n    }\n\n    if (VAO != 0)\n    {\n        glDeleteVertexArrays(1, &VAO);\n        VAO = 0;\n    }\n\n    indexCount = 0;\n}\n\nMesh::~Mesh() \n{\n    ClearMesh();\n}",
    "#include <iostream>\n#include \"Board.h\"\n#include \"DFS.h\"\n#include \"Positions.h\"\n\nvoid solve(const Board& board) {\n    auto moves = board.generate_moves();\n    for (auto move : moves) {\n        move.print();\n        std::cout << std::endl;\n    }\n\n    DFS dfs(board);\n    dfs.root_dfs();\n}\n\nint main() {\n    int size = 12;\n    std::vector<std::vector<Piece >> example = {\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNIL, \tNON, \tNIL \t},\n            {\tNON, \tNON, \tNON, \tNON, \tTWO, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON \t},\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tTWO, \tNON \t},\n            {\tNON, \tNON, \tNON, \tNON, \tTWO, \tTWO, \tNON, \tNON, \tNON, \tTWO, \tTWO, \tNON \t},\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tTWO, \tNON, \tNON, \tNON, \tTWO, \tNON, \tNIL \t},\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON \t},\n            {\tNON, \tTWO, \tNON, \tNON, \tNON, \tTWO, \tTWO, \tNON, \tNON, \tNON, \tNON, \tNON \t},\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tTWO, \tNON, \tNON, \tNON, \tNON, \tNON \t},\n            {\tNON, \tNON, \tTWO, \tNON, \tNON, \tTWO, \tNON, \tTWO, \tNON, \tNON, \tNON, \tNON \t},\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tTWO, \tNON, \tNON, \tNON, \tNON \t},\n            {\tTWO, \tNON, \tNON, \tNON, \tNON, \tTWO, \tNON, \tNON, \tTWO, \tNON, \tNON, \tNON \t},\n            {\tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON, \tNON \t}\n    };\n\n    Position position(example);\n    Board board(position, size), board2(full_and_12, 12);\n    board2.print();\n    board.print();\n\n    solve(board);\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"type.h\"\n// todo list\n// user input validation for METHOD\n// add user input from file.\n// write code to generate adjaxcency martix\n\nint main() {\n\n  data GraphData;\n\n  int METHOD;\n  int DETECTION;\n  // if method == 0; OLD\n  // if methof == 1; IC\n\n  cout << \"WHAT IS OUR WORKING METHOD?? 0 FOR OLD, 1 FOR IC: \" << endl;\n  cin >> METHOD;\n\n  cout << \"ADD FAULT TOLERANCY?? 0 no or 1 yes:\" << endl;\n  cin >> DETECTION;\n\n  // clear txt file for safe keeping\n  clearTextFile();\n\n  // itterate through the number of nodes in the graph\n  // this gives us all possible solutions\n  for (int r = 0; r < GraphData.graphNodes; r++) {\n\n    clearTextFile();\n\n    // open file\n    fstream inFile;\n    inFile.open(\"combo.txt\");\n\n    // create variables\n    int n = GraphData.graphNodes;\n    int currentCombo[r];\n    int sampleCombo[n];\n    for (int i = 0; i < n; i++) {\n      sampleCombo[i] = i;\n    }\n\n    // generate the combonations in the text file\n    FindCombinations(sampleCombo, currentCombo, 0, n - 1, 0, r, inFile);\n\n    // close write file\n    inFile.close();\n\n    // open the read file to reaccess data\n    fstream read;\n    read.open(\"combo.txt\");\n\n    cout << \"Write complete: opened for read\" << endl;\n\n    // gather info from the txt file\n    while (!read.eof()) {\n\n      // define variables\n      vector<int> comboVector;\n      string comboString;\n      string storage = \"\";\n      int index = 0;\n\n      // get the first row\n      getline(read, comboString, '\\n');\n\n      // put info into vector\n      for (int i = 0; i < comboString.length(); i++) {\n        if (comboString[i] == ' ') {\n          // cout << \"storage = \" << storage << endl;\n          // the correct code\n          comboVector.push_back(stoi(storage));\n\n          storage = \"\";\n          index++;\n          continue;\n        }\n        storage += comboString[i];\n      }\n\n      // generate neighborhoods\n\n      // neighborhood data structure\n      // an array of vectors. the vector contains the index of the detectors\n\n      // GraphData.graphNodes\n      vector<int> Array_neighborhood[10];\n\n      // generate the neighborhoods\n      // cout << \"ADDING \" << endl;\n      for (int detectorITT = 0; detectorITT < comboVector.size();\n           detectorITT++) {\n\n        int detector = comboVector[detectorITT];\n        ///  cout << \"\\nDECECTOR : \" << detector;\n        //   cout << \"ADDED TO: \";\n\n        /// DOES NOT INCLUDE THE DETECTOR ITSELF SO OLD HERE\n        // CHANGE HERE FOR IC\n        if (METHOD == 1) {\n          Array_neighborhood[detector].push_back(detector);\n          //     cout << detector << \" \";\n        }\n        for (int j = 0; j < GraphData.graphJ; j++) {\n          // for IC implementation\n\n          if (GraphData.Graph[detector][j] == 1) {\n            Array_neighborhood[j].push_back(detector);\n            //    cout << j << \" \";\n          }\n        }\n      }\n\n      // check for valid solution\n      // sort the vectors, if any are empty\n      // solution is invalid\n\n      bool solution = true;\n\n      if (DETECTION == 0) {\n        bool ValidSolution = true;\n        for (auto i : Array_neighborhood) {\n          sort(i.begin(), i.end());\n          if (i.size() == 0) {\n            ValidSolution = false;\n            break;\n          }\n        }\n        if (!ValidSolution) {\n          continue;\n        }\n\n        // check for valid solution\n        // check every array against the other arrays\n        // bool sloution = true;\n        int iTally = 0;\n        for (auto i : Array_neighborhood) {\n          if (!solution) {\n            break;\n          }\n\n          int jTally = 0;\n          for (auto j : Array_neighborhood) {\n            // dont compare against its self\n            if (iTally == jTally) {\n              jTally++;\n              continue;\n            }\n            // compare\n            if (i == j) {\n              solution = false;\n            }\n            jTally++;\n            if (!solution) {\n              break;\n            }\n          }\n\n          iTally++;\n        }\n      }\n\n      else if (DETECTION == 1) {\n        // ADD 2 DISTINGUSIGN FAULT TOLERANCE\n        bool ValidSolution = true;\n        for (auto i : Array_neighborhood) {\n          sort(i.begin(), i.end());\n          if (i.size() < 2) {\n            ValidSolution = false;\n            break;\n          }\n        }\n        if (!ValidSolution) {\n          continue;\n        }\n\n        // working in here\n\n        // working with vectors of larger than size 2\n        // now we check for the validity of the solution\n\n        // check all the arrays againts them selves\n        // if the difference between them is not at at least 2 distinct\n        // not a solution\n\n        int iTally = 0;\n        for (auto i : Array_neighborhood) {\n          if (!solution) {\n            break;\n          }\n\n          sort(i.begin(), i.end());\n\n          int jTally = 0;\n          for (auto j : Array_neighborhood) {\n            // dont compare against its self\n            if (iTally == jTally) {\n              jTally++;\n ",
    "/*\r\n==============================================================================\r\n   US-align: universal structure alignment of monomeric and complex proteins\r\n   and nucleic acids\r\n\r\n   This program was written by Chengxin Zhang at Yang Zhang lab,\r\n   Department of Computational Medicine and Bioinformatics,\r\n   University of Michigan, 100 Washtenaw Ave, Ann Arbor, MI 48109-2218.\r\n   Please report issues to zhanglab@zhanggroup.org\r\n\r\n   References:\r\n   * Chengxin Zhang, Morgan Shine, Anna Marie Pyle, Yang Zhang\r\n     (2022) Nat Methods. 19(9), 1109-1115.\r\n   * Chengxin Zhang, Anna Marie Pyle (2022) iScience. 25(10), 105218.\r\n\r\n   DISCLAIMER:\r\n     Permission to use, copy, modify, and distribute this program for \r\n     any purpose, with or without fee, is hereby granted, provided that\r\n     the notices on the head, the reference information, and this\r\n     copyright notice appear in all copies or substantial portions of \r\n     the Software. It is provided \"as is\" without express or implied \r\n     warranty.\r\n===============================================================================\r\n\r\n=========================\r\n How to install US-align\r\n=========================\r\nTo compile the program in your Linux computer, simply enter\r\n\r\n    make\r\n\r\nor\r\n\r\n    g++ -static -O3 -ffast-math -lm -o USalign USalign.cpp\r\n\r\nThe '-static' flag should be removed on Mac OS, which does not support\r\nbuilding static executables.\r\n\r\nUSalign compiled on Linux, Mac OS and Linux Subsystem for Windows (WSL2) on\r\nWindows 10 onwards can read both uncompressed files and gz compressed\r\nfiles, provided that the \"gunzip\" command is available. On the other hand, due\r\nto the lack of POSIX support on Windows, US-align natively compiled on Windows\r\nwithout WSL2 cannot parse gz compressed files.\r\n\r\nUS-align is known to be compilable by g++ version 4.8.5 or later, clang++\r\nversion 12.0.5 or later and mingw-w64 version 9.3 or later.\r\n\r\n=====================\r\n How to use US-align\r\n=====================\r\nYou can run the program without arguments to obtain a brief instruction\r\n\r\n    ./USalign structure1.pdb structure2.pdb\r\n\r\nA full list of available options can be explored by:\r\n\r\n    ./USalign -h\r\n*/\r\n\r\n\r\n#include <cfloat>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <time.h>\r\n#include <string.h>\r\n#include <sstream>\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iterator>\r\n#include <algorithm>\r\n#include <string>\r\n#include <iomanip>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\n/* pstream.h */\r\n/* the following code block for REDI_PSTREAM_H_SEEN is from Jonathan\r\n * Wakely's pstream.h. His original copyright notice is shown below */\r\n// PStreams - POSIX Process I/O for C++\r\n\r\n//        Copyright (C) 2001 - 2017 Jonathan Wakely\r\n// Distributed under the Boost Software License, Version 1.0.\r\n//    (See accompanying file LICENSE_1_0.txt or copy at\r\n//          http://www.boost.org/LICENSE_1_0.txt)\r\n//\r\n\r\n/* do not compile on windows, which does not have cygwin */\r\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) && !defined(__CYGWIN__)\r\n#define NO_PSTREAM\r\n#else\r\n\r\n#ifndef REDI_PSTREAM_H_SEEN\r\n#define REDI_PSTREAM_H_SEEN\r\n\r\n#include <ios>\r\n#include <streambuf>\r\n#include <istream>\r\n#include <ostream>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>    // for min()\r\n#include <cerrno>       // for errno\r\n#include <cstddef>      // for size_t, NULL\r\n#include <cstdlib>      // for exit()\r\n#include <sys/types.h>  // for pid_t\r\n#include <sys/wait.h>   // for waitpid()\r\n#include <sys/ioctl.h>  // for ioctl() and FIONREAD\r\n#if defined(__sun)\r\n# include <sys/filio.h> // for FIONREAD on Solaris 2.5\r\n#endif\r\n#include <unistd.h>     // for pipe() fork() exec() and filedes functions\r\n#include <signal.h>     // for kill()\r\n#include <fcntl.h>      // for fcntl()\r\n#if REDI_EVISCERATE_PSTREAMS\r\n# include <stdio.h>     // for FILE, fdopen()\r\n#endif\r\n\r\n\r\n/// The library version.\r\n#define PSTREAMS_VERSION 0x0101   // 1.0.1\r\n\r\n/**\r\n *  @namespace redi\r\n *  @brief  All PStreams classes are declared in namespace redi.\r\n *\r\n *  Like the standard iostreams, PStreams is a set of class templates,\r\n *  taking a character type and traits type. As with the standard streams\r\n *  they are most likely to be used with @c char and the default\r\n *  traits type, so typedefs for this most common case are provided.\r\n *\r\n *  The @c pstream_common class template is not intended to be used directly,\r\n *  it is used internally to provide the common functionality for the\r\n *  other stream classes.\r\n */\r\nnamespace redi\r\n{\r\n  /// Common base class providing constants and typenames.\r\n  struct pstreams\r\n  {\r\n    /// Type used to specify how to connect to the process.\r\n    typedef std::ios_base::openmode           pmode;\r\n\r\n    /// Type used to hold the arguments for a command.\r\n    typedef std::vector<std::string>          argv_type;\r\n\r\n    /// Type used for file descriptors.\r\n    typedef int                       ",
    "#include <bits/stdc++.h>\n#include <stdlib.h>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <set>\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <cassert>\n#include <vector>\n#include <numeric>\n#include <cstdlib>\n#include <bitset>\n#include <chrono>\n#include <random>\n#include <fstream>\n#include <iterator>\n#include <complex>\n//#include \"DSU.h\"\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> orderedMultiset;\n#define bug(args ...) cerr << __LINE__ << \">> \", err(new istringstream(string(#args)), args), cerr << '\\n'\n#define endl \"\\n\"\n#define int long long\n#define PNO cout<<\"NO\"<<endl\n#define PYES cout<<\"YES\"<<endl\n#define PYes cout<<\"Yes\"<<endl\n#define PNo cout<<\"No\"<<endl\n#define pb emplace_back\n#define ppb pop_back\n#define mk make_pair\n#define F first\n#define S second\n#define M_PI 3.14159265358979323846\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repr(i,a,b) for(int i = b-1;i>=a;i--)\n#define all(v) v.begin(),v.end()\n#define vi vector<int>\n#define vb vector<bool>\n#define vii vector<pair<int,int>>\n \n#define inf 1e9\n#define INF 1e18\n#define mod 1000000007\n#define modd 998244353\n// #define N 2000006\nconst double PI = 3.1415926535897932384626433832795;\n \ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pip;\ntypedef unsigned long long ull; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<double, double> pdd; typedef pair<long long, long long> pll; typedef cc_hash_table<int, int, hash<int>> intHashTable; typedef tuple<int, int, int> tiii;\nint fact(int n){if(n==0)return 1;int ans =1;while(n--){ans = (ans*(n+1))%mod;}return ans;}\nint ncr(int n,int r){int res = 1;if(r>n-r) r = n-r;for(int i=0;i<r;i++){res *= (n-i);res *= pow(i+1,-1);}return res;}\nint gcd (int a, int b) { while (b) { a %= b; swap(a, b); } return a; }\nint lcm (int a, int b) { return a / gcd(a, b) * b; }\nint digitsum(int a){ int ans =0;while(a>0){ans+=a%10;a/=10;}return ans;}\ndouble bpow(double x, int y){double res = 1; while (y > 0){if (y & 1) res *= x; y = y >> 1LL, x *= x;} return res;}\nint powm(int x,int y,int M){if(x==0 && y==0) return (int)1;if(x==0) return (int)0;if(y==0) return (int)1;if(y==1) return x%M;int k = powm(x,y/2,M);if(y%2) return (((x*k)%M)*k)%M;else return (k*k)%M;}\nvoid SieveOfEratosthenes(int n)\n{\n    bool prime[n + 1];\n    memset(prime, true, sizeof(prime));\n    for (int p = 2; p * p <= n; p++) {\n        if (prime[p] == true) {\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n    for (int p = 2; p <= n; p++)\n        if (prime[p])\n            cout << p << \" \";\n    return;\n}\n\n\nvoid solve(){ \n    return;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL); \n    // freopen(\"input.txt\", \"r\" , stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n     int t=1;\n    for(int i=1;i<=t;i++){\n        //cout<<\"Case #\"<<i<<\": \";\n        solve();\n    }\n    return 0;\n}\n",
    "// @leet start\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        if(n == 1) return 1;\n        if(n == 2) return isBadVersion(1) ? 1 : 2;\n\n        unsigned int maxPossibleVersion = n;\n        unsigned int minPossibleVersion = 1;\n        long unsigned int toSearch = (maxPossibleVersion + minPossibleVersion) / 2;\n        while(maxPossibleVersion - minPossibleVersion > 1) {\n            if(toSearch - minPossibleVersion == 1) {\n                if(isBadVersion(minPossibleVersion)) return minPossibleVersion;\n                if(isBadVersion(toSearch)) return toSearch;\n            }\n            if(maxPossibleVersion - toSearch == 1) return isBadVersion(toSearch) ? toSearch : maxPossibleVersion;\n\n            if(!isBadVersion(toSearch)) minPossibleVersion = toSearch;\n            else maxPossibleVersion = toSearch;\n            toSearch = (maxPossibleVersion + minPossibleVersion) / 2;\n        }\n        return firstBadVersion(minPossibleVersion) ? minPossibleVersion : maxPossibleVersion;\n    }\n};\n// @leet end\n",
    "#include \"piece.hpp\"\n#include \"colors.hpp\"\n#include \"tetris_config.hpp\"\n#include \"global_vars.hpp\"\n#include <vector>\n\nPiece::Piece(PieceKind type, Vec2 pos, const uint8_t& rot)\n    : // initializator list, calls the construtor for objects in the class\n    position { pos }\n    , rotation { rot }\n    , type { type } {\n    confirm();\n}\n\nPiece::~Piece() {}\n\nvoid Piece::lower() {\n    position.y++;\n    lowerLast = true;\n}\nvoid Piece::rotateClockwise() {\n    if (rotation + 1 != 4) {\n        rotation++;\n    } else {\n        rotation = 0;\n    }\n}\nvoid Piece::rotateCounterClockwise() {\n    if (rotation != 0) {\n        rotation--;\n    } else {\n        rotation = 3;\n    }\n}\n\nvoid Piece::confirm() {\n    lastPosition = position;\n    lastRotation = rotation;\n}\n\nvoid Piece::undo() {\n    position = lastPosition;\n    rotation = lastRotation;\n}\n\nvoid Piece::draw() {\n    std::vector<PiecePixel> pixels;\n    renderShape(pixels);\n\n    for (auto& p : pixels) {\n        if (p.value != 0) {\n            int p_x = p.pos.x + view_offset;\n            if (_cfg_overflow_enable == true || _cfg_scroll_enable == true) {\n                while (p_x < 0) {\n                    p_x += _cfg_width;\n                }\n                while (p_x >= _cfg_width) {\n                    p_x -= _cfg_width;\n                }\n            } else {\n                if (p_x < 0) {\n                    p_x = 0;\n                }\n                if (p_x >= _cfg_width) {\n                    p_x = _cfg_width - 1;\n                }\n            }\n            display.setColor(p_x, p.pos.y, colors[p.value]);\n        }\n    }\n}\n\nvoid Piece::renderShape(std::vector<PiecePixel>& pixels) const {\n    // load pixels\n\n    for (int32_t x = 0; x < Pieces[type][0].size(); x++) {\n        for (int32_t y = 0; y < Pieces[type].size(); y++) {\n\n            if (Pieces[type][y][x] == 1) {\n                pixels.push_back({ 1, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 2) {\n                pixels.push_back({ 2, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 3) {\n                pixels.push_back({ 3, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 4) {\n                pixels.push_back({ 4, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 5) {\n                pixels.push_back({ 5, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 6) {\n                pixels.push_back({ 6, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            } else if (Pieces[type][y][x] == 7) {\n                pixels.push_back({ 7, Vec2 { x - PiecesCenters[type].x, y - PiecesCenters[type].y } }); // constructs the pixel inside the vector\n            }\n        }\n    }\n\n    // rotate pixels\n\n    if (type != Square) {\n        for (int i = 0; i < rotation; i++) { // rotate 90\u02da (https://stackoverflow.com/questions/4780119/2d-euclidean-vector-rotations)\n            for (auto& p : pixels) {\n                p.pos = Vec2 { -p.pos.y, p.pos.x };\n            }\n        }\n    }\n\n    // move pixels\n\n    for (auto& p : pixels) {\n\n        int32_t p_x = p.pos.x + PiecesCenters[type].x + position.x;\n\n        if (_cfg_overflow_enable == true) {\n\n            while (p_x < 0) {\n                p_x += _cfg_width;\n            }\n            while (p_x >= _cfg_width) {\n                p_x -= _cfg_width;\n            }\n        }\n        p.pos = Vec2 { p_x, p.pos.y + PiecesCenters[type].y + position.y };\n    }\n}",
    "#include <iostream>\n#include <cctype>\n#include \"Image_Class.h\"\n#include <stdexcept>\n#include <vector>\nusing namespace std;\n/*\n    program Description: this program applies simple filters to images and can specify it's extention\n\n    Author 1: Salah Hammad   => S26\n    ID1 : 20230194\n    // developed (gray scale - merge - detect image edge - lighten and darken)filters\n    ========================================================== \n    Author 2: Mohamed Ashraf Said Ibrahim   => S26\n    ID2: 20230320\n    // developed (Black and white - flip - resize - crop - Purple hue) filters\n    ==========================================================\n    Author 3: Mohamed Abd El nasser Mohamed Marghny    => S26\n    ID3: 20231146\n  ///  { Mohamed did not fulfill what was expected of him. He did not execute any code but instead used ChatGPT,  ///\n    which affected the team and did not help us at all. He did not carry out the required tasks,and if u have a look\n    at the filter (rotate) that he made u will see that he didn't follow the assginment instructions }\n    // developed (rotate) filter\n\n    last modification date: 4/14/2024\n    version: 3.0\n\n    //// Link to the Repo: https://github.com/0MohamedAshraf/Baby-Photoshop\n*/\n\n\n\n\n// Function to rotate the image clockwise by 90 degrees\nvoid rotate90(vector<vector<int>>& image) {\n    int n = image.size();\n    vector<vector<int>> rotated(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rotated[i][j] = image[n - j - 1][i];\n        }\n    }\n    image = rotated;\n}\n\n// Function to rotate the image clockwise by 180 degrees\nvoid rotate180(vector<vector<int>>& image) {\n    rotate90(image);\n    rotate90(image);\n}\n\n// Function to rotate the image clockwise by 270 degrees\nvoid rotate270(vector<vector<int>>& image) {\n    rotate180(image);\n    rotate90(image);\n}\n\n// rotate filter function\nvoid rotate(){\n    int n;\n    cout << \"Enter the size of the image (n x n): \";\n    cin >> n;\n\n    vector<vector<int>> image(n, vector<int>(n));\n    cout << \"Enter the elements of the image:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> image[i][j];\n        }\n    }\n\n    int choice;\n    cout << \"Enter the rotation angle (90, 180, or 270): \";\n    cin >> choice;\n\n    switch (choice) {\n        case 90:\n            rotate90(image);\n            break;\n        case 180:\n            rotate180(image);\n            break;\n        case 270:\n            rotate270(image);\n            break;\n        default:\n            cout << \"Invalid choice!\" << endl;\n            \n    }\n\n    cout << \"Rotated Image:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << image[i][j] << \" \";\n        }\n        cout << endl;\n    }    \n}\n// merge filter function \nvoid merge(string filename, string filename2, string new_img){\n\n    Image image1(filename);\n    Image image2(filename2);   \n\n    // Calculate the common dimensions between the two images\n    int commonWidth = min(image1.width, image2.width);\n    int commonHeight = min(image1.height, image2.height);\n\n    // Blend the images\n    // Image blendedImage(image1.width, image1.height);\n    for (int i = 0; i < commonWidth; ++i) {\n        for (int j = 0; j < commonHeight; ++j) {\n            for (int k = 0; k < image1.channels; ++k) {\n                // Calculate the average of the shared values between the two images\n                image1(i, j, k) = ((image1(i, j, k) + image2(i, j, k)) / 2);\n            }\n        }\n    }\n\n    // Save the blended image\n    image1.saveImage(new_img);    \n}\n\n// gray scale filter function\nvoid gray_scale(string filename, string new_img){\n    Image image(filename); // Creating an image object using the input file\n\n    for(int i = 0; i < image.width; ++i) {\n        for(int j = 0; j < image.height; ++j) {\n            unsigned int avg = 0;\n\n            for(int k = 0; k < image.channels; ++k) {\n                avg += image(i,j,k);\n            }\n            avg /= image.channels; // Modification here to be more general instead of always dividing by 3\n            for(int k = 0; k < image.channels; ++k) {\n                image(i,j,k) = avg;\n            }\n        }\n    }\n\n    // Save the image after modifications\n    image.saveImage(new_img);\n\n}\n\n// Black and White filter function \nvoid Black_White(string filename, string new_img){\n    Image Photo(filename);\n    for(int i = 0; i < Photo.width ;++i){\n\n        for(int j = 0; j < Photo.height;++j){\n            for(int k = 0; k < 3;++k){\n            }\n            if((Photo(i,j,0)+Photo(i,j,1)+Photo(i,j,2))/3 > 128){  // convert the image to gray scale and \n                                                                   // check if the pixel is bright or dark\n                                                                   // if the pixel is bright make it white \n                Photo(i,j,0) = 255;\n                Photo(i,j,1) = 255;\n                Photo(i,j,2) ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "                    // EVERYTHING BELONGS TO ALMIGHTY ALLAH\r\n#include<bits/stdc++.h>\r\n#define ll long long \r\n#define ff first\r\n#define ss second \r\n#define ld long double\r\n#define pb(x) push_back(x)\r\n#define loop(n) for(ll i=0;i<n;i++)\r\n#define vll vector<ll> \r\n#define vpll vector<pair<ll,ll>>\r\n#define ln '\\n'\r\nusing namespace std;\r\n\r\n// kruskals is used to find MST (minimum spanning tree)\r\n// minimum : the sum of the edges of the tree is minimum possible\r\n// spanning tree: there is one tree (no loops and one connected component)\r\n\r\nvll par , sz  ;\r\nvoid make(ll node){\r\n    // initializing a group\r\n    par[node] = node ;\r\n    sz[node] =  1 ;\r\n}\r\nll find(ll node){\r\n    if (par[node]==node) return node ;\r\n    // path compression\r\n    return par[node] = find(par[node]) ;\r\n}\r\nvoid Union(ll a,ll b){\r\n    // union by size \r\n    ll par_a = find(a) , par_b = find(b) ;\r\n    if (par_a == par_b) return ;\r\n    if (sz[par_a]<sz[par_b]) swap(par_a,par_b) ;\r\n    par[par_b] = par_a ;\r\n    sz[par_a] += sz[par_b] ;\r\n}\r\nvoid kruskals(){   \r\n    ll n , m ; cin >> n ;\r\n    par.resize(n+1) ;\r\n    sz.resize(n+1) ;\r\n    for(ll i=1;i<=n;i++){\r\n        make(i) ;\r\n    }\r\n    vector<pair<ll,pair<ll,ll>>> v  ;\r\n    ll cost =  0  ;\r\n    loop(m){\r\n        ll x , y , wt; cin  >> x >> y >> wt ;\r\n        v.push_back({wt,{x,y}}) ;\r\n    }\r\n    sort(v.begin(),v.end()) ;\r\n    for(auto x:v){\r\n        ll wt = x.ff  , u = x.ss.ff , v  = x.ss.ss ;\r\n        if (find(u)==find(v)) continue ;\r\n        Union(u,v) ;\r\n        cost += wt ;\r\n    }\r\n    cout << cost << ln ;\r\n    return ;\r\n}\r\n\r\nint main(){\r\n    ll t =1 ;\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    //cin >> t  ;\r\n    while(t--) kruskals() ;\r\n    return 0 ;\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<vector>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<fstream>\n#include<sstream>\n#include<string>\n\nusing namespace std;\n\nstruct Map_Cell\n{\n    int type;\n    // TODO: \u5b9a\u4e49\u5730\u56fe\u4fe1\u606f\n\n};\n\nstruct Search_Cell\n{\n    int h;\n    int g;\n    // TODO: \u5b9a\u4e49\u641c\u7d22\u72b6\u6001\n    //\u9700\u8981\u6240\u5728\u4f4d\u7f6e\u7684\u6a2a\u7eb5\u5750\u6807x\uff0cy\uff0c\u5f53\u524d\u98df\u7269\u5269\u4f59\u91cft, \u7236\u8282\u70b9f\n    int x;\n    int y;\n    int t;\n    Search_Cell *f;\n\n};\n\n// \u81ea\u5b9a\u4e49\u6bd4\u8f83\u51fd\u6570\u5bf9\u8c61\uff0c\u6309\u7167 Search_Cell \u7ed3\u6784\u4f53\u7684 g + h \u5c5e\u6027\u8fdb\u884c\u6bd4\u8f83\nstruct CompareF {\n    bool operator()(const Search_Cell *a, const Search_Cell *b) const {\n        return (a->g + a->h) >= (b->g + b->h); // \u8f83\u5c0f\u7684 g + h \u503c\u4f18\u5148\u7ea7\u66f4\u9ad8\n    }\n};\n\n// TODO: \u5b9a\u4e49\u542f\u53d1\u5f0f\u51fd\u6570\nint Heuristic_Funtion(Search_Cell *p, pair<int,int> end_point)\n{\n    //\u5b9a\u4e49\u4e3a\u66fc\u54c8\u987f\u8ddd\u79bb\n    return abs(end_point.first - p->x) + abs( end_point.second - p->y); \n}\n//TODO add two function\nbool isEqualCell(Search_Cell * firstCell,Search_Cell* secondCell){\n    return (firstCell->t == secondCell->t)&&(firstCell->x == secondCell->x)&&(firstCell->y == secondCell->y);\n}\n\nSearch_Cell* isInPriorityQueue(priority_queue<Search_Cell *, vector<Search_Cell *>, CompareF> que, Search_Cell * cell)\n{\n    while(!que.empty()){\n       Search_Cell *tmpCell = que.top();\n       if( isEqualCell(tmpCell,cell)){\n        return tmpCell;\n       }\n       que.pop();\n    }\n    return NULL;\n}\n\nbool isInVector(vector<Search_Cell*> vec, int x,int y,int t){\n    for(int i=0;i<vec.size();i++){\n        if(vec[i]->x == x &&vec[i]->y == y && vec[i]->t == t){\n            return true;\n        }\n    }\n    return false;\n}\n\nvector<Search_Cell* > cellCanReach(Search_Cell *curCell, Map_Cell** Map,int M,int N, int T,vector<Search_Cell *> closeCell, pair<int,int> end_point){\n    int  x = curCell->x;\n    int y = curCell->y;\n    vector<Search_Cell *> reach;\n    vector<pair<int,int> > directs={{1,0},{0,1},{-1,0},{0,-1}};\n    for(int i=0;i<directs.size();i++){\n        int t = curCell->t;\n        pair<int,int> direct=directs[i];\n        if((x+direct.first>=0)&&(x+direct.first<M)&&(y+direct.second>=0)&&(y+direct.second<N)&&(Map[x+direct.first][y+direct.second].type!=1)){\n            int type=Map[x+direct.first][y+direct.second].type;\n            if(curCell->t <= 1 && type == 0){\n                continue;\n            }\n            if(type == 2) t = T+1;\n            if(!isInVector(closeCell,x+direct.first,y+direct.second,t-1)){\n                Search_Cell* addCell = new Search_Cell;\n                addCell->x = x+direct.first;\n                addCell->y = y+direct.second;\n                addCell->t = t-1;\n                addCell->g = curCell->g+1;\n                addCell->h = Heuristic_Funtion(addCell,end_point);\n                addCell->f = curCell;\n                reach.push_back(addCell);\n            }\n        }\n    }\n    return reach;\n    \n    \n}\n\n\nvoid Astar_search(const string input_file, int &step_nums, string &way)\n{\n    ifstream file(input_file);\n    if (!file.is_open()) {\n        cout << \"Error opening file!\" << endl;\n        return;\n    }\n\n    string line;\n    getline(file, line); // \u8bfb\u53d6\u7b2c\u4e00\u884c\n    stringstream ss(line);\n    string word;\n    vector<string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    int M = stoi(words[0]);\n    int N = stoi(words[1]);\n    int T = stoi(words[2]);\n\n    pair<int, int> start_point; // \u8d77\u70b9\n    pair<int, int> end_point;   // \u7ec8\u70b9\n    Map_Cell **Map = new Map_Cell *[M];\n    // \u52a0\u8f7d\u5730\u56fe\n    for(int i = 0; i < M; i++)\n    {\n        Map[i] = new Map_Cell[N];\n        getline(file, line);\n        stringstream ss(line);\n        string word;\n        vector<string> words;\n        while (ss >> word) {\n            words.push_back(word);\n        }\n        for(int j = 0; j < N; j++)\n        {\n            Map[i][j].type = stoi(words[j]);\n            if(Map[i][j].type == 3)\n            {\n                start_point = {i, j};\n            }\n            else if(Map[i][j].type == 4)\n            {\n                end_point = {i, j};\n            }\n        }\n    }\n    // \u4ee5\u4e0a\u4e3a\u9884\u5904\u7406\u90e8\u5206\n    // ------------------------------------------------------------------\n\n    Search_Cell *search_cell = new Search_Cell;\n    search_cell->g = 0;\n    search_cell->x = start_point.first;\n    search_cell->y = start_point.second;\n    search_cell->h = Heuristic_Funtion(search_cell , end_point);\n    search_cell->f = NULL;\n    search_cell->t = T;\n\n    priority_queue<Search_Cell *, vector<Search_Cell *>, CompareF> open_list;\n    vector<Search_Cell *> close_list;\n    open_list.push(search_cell);\n    int flag=0;\n    while(!open_list.empty())\n    {\n        // TODO: A*\u641c\u7d22\u8fc7\u7a0b\u5b9e\u73b0\n        Search_Cell* curCell = open_list.top();\n        if((curCell->x == end_point.first)&&(curCell->y == end_point.second)){\n            flag = 1;\n            break;\n        }\n        else{\n            open_list.pop();\n            close_list.push_back(curCell);\n            vector<Search_Cell*> reach= cellCanReach(curCell,Map,M,N,T,close_list,end_point);\n            for(int i=0;i<reach.size();i++){\n                Search_Cell* tmp;\n                Search_Cell*  tarCell= reach[i];\n                if(!(tmp=isInPriorityQueue(open_",
    "\n#include \"LibBle.h\"\n\nWinBleLib::WinBleLib()\n{\n    bleWatcher.Received(recieved_callback); // [this](BluetoothLEAdvertisementWatcher watcher, BluetoothLEAdvertisementReceivedEventArgs eventArgs) {this->didDiscoverPeripheral(watcher, eventArgs); });\n    bleWatcher.Stopped(stopped_callback); // [this](BluetoothLEAdvertisementWatcher w, BluetoothLEAdvertisementWatcherStoppedEventArgs b) {this->didCancelScanning(); });\n}\nWinBleLib::~WinBleLib()\n{\n    bleWatcher.Stop();\n\n}\n\nvoid WinBleLib::scan()\n{\n    bleWatcher.Start();\n}\n\nvoid WinBleLib::stop()\n{\n    bleWatcher.Stop();\n}\n\nvoid recieved_callback(BluetoothLEAdvertisementWatcher watcher, BluetoothLEAdvertisementReceivedEventArgs eventArgs)\n{\n\n    if (eventArgs.Advertisement().ServiceUuids().Size() > 0)\n    {\n        for (auto guid : eventArgs.Advertisement().ServiceUuids())\n        {\n\n            if (winrtGuidToString(guid) == \"dfaf765b-42d7-4c71-b13e-9262347354bf\")\n            {\n                std::cout << \"discovered and connected \" << eventArgs.BluetoothAddress() << std::endl;\n                connectPeripheral(eventArgs.BluetoothAddress());\n                watcher.Stop();\n                return;\n            }\n            else\n            {\n                std::cout << \"didnt connect to: \" << winrtGuidToString(guid) << std::endl;\n            }\n        }\n    }\n    else\n    {\n        std::cout << \"no services on this device \" << eventArgs.BluetoothAddress() << std::endl;\n    }\n\n}\n\nvoid stopped_callback(BluetoothLEAdvertisementWatcher w, BluetoothLEAdvertisementWatcherStoppedEventArgs b)\n{\n    std::cout << \"stop callback\" << std::endl;\n}\n\nvoid connectPeripheral(uint64_t windowsDeviceAddress)\n{\n    BluetoothLEDevice::FromBluetoothAddressAsync(windowsDeviceAddress).Completed(connect_callback);\n}\n\nvoid connect_callback(IAsyncOperation<BluetoothLEDevice> sender, AsyncStatus status)\n{\n    if (auto device = sender.GetResults(); device)\n    {\n        if (status == winrt::Windows::Foundation::AsyncStatus::Completed)\n        {\n            std::cout << \"connected \" << std::endl;\n            discoverServices(device);\n            //this->didConnectPeripheral(device);\n        }\n        else\n        {\n            std::cout << \"not connected \" << std::endl;\n        }\n    }\n    else\n    {\n        std::cout << \"Device is Null: \" << sender.ErrorCode() << std::endl;\n    }\n}\n\nvoid discoverServices(BluetoothLEDevice& device)\n{\n    std::wcout << \"didConnectPeripheral:\" << device.Name().c_str() << std::endl;\n    device.GetGattServicesAsync().Completed(services_callback);\n\n}\n\nvoid services_callback(IAsyncOperation<GattDeviceServicesResult>sender, AsyncStatus status)\n{\n\n    if (GattDeviceServicesResult result = sender.get(); result)\n    {\n        if (status == winrt::Windows::Foundation::AsyncStatus::Completed)\n        {\n            std::cout << \"service callback\" << std::endl;\n            service(result.Services(), result.Status());\n        }\n        else\n        {\n            std::cout << \"not service \" << std::endl;\n        }\n    }\n    else\n    {\n        std::cout << \"Device is Null: \" << sender.ErrorCode() << std::endl;\n    }\n}\n\nvoid service(IVectorView<GattDeviceService> services, GattCommunicationStatus status)\n{\n    if (status == GattCommunicationStatus::Success)\n    {\n       // std::cout << \"didDiscoverServices: \" << services.GetAt(0).Device().Name().c_str() << std::endl;\n\n        for (auto service : services)\n        {\n            std::cout << \"services count\\n\";\n            discover_services(service);\n        }\n    }\n    else\n    {\n        std::cout << \"Error Getting Services: \";\n        switch (status)\n        {\n        case winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::Unreachable:\n            std::cout << \"Unreachable\";\n            break;\n        case winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::ProtocolError:\n            std::cout << \"ProtocolError\";\n            break;\n        case winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCommunicationStatus::AccessDenied:\n            std::cout << \"AccessDenied\";\n            break;\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid discover_services(GattDeviceService service)\n{\n    service.GetCharacteristicsAsync().Completed(discover_services_callback);\n}\n\nvoid discover_services_callback(IAsyncOperation<GattCharacteristicsResult>sender, AsyncStatus status)\n{\n    if (GattCharacteristicsResult result = sender.get(); result)\n    {\n        switch (status)\n        {\n        case winrt::Windows::Foundation::AsyncStatus::Completed:\n            std::cout << \"connect to char\\n\";\n            discover_characteristics(result.Characteristics(), result.Status());\n            break;\n        case winrt::Windows::Foundation::AsyncStatus::Canceled:\n        case winrt::Windows::Foundation::AsyncStatus::Error:\n        case winrt::Windows::Foundation::AsyncStatus::Started:\n            break;\n            //error func\n        }\n    }\n    else\n    {\n     ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"GraphicsCommon.h\"\r\n\r\nnamespace Graphics {\r\n\r\n// Sampler States\r\nComPtr<ID3D11SamplerState> linearWrapSS;\r\nComPtr<ID3D11SamplerState> linearClampSS;\r\nComPtr<ID3D11SamplerState> shadowPointSS;\r\nComPtr<ID3D11SamplerState> shadowCompareSS;\r\nvector<ID3D11SamplerState *> sampleStates;\r\n\r\n// Rasterizer States\r\nComPtr<ID3D11RasterizerState> solidRS;\r\nComPtr<ID3D11RasterizerState> solidCCWRS;\r\nComPtr<ID3D11RasterizerState> wireRS;\r\nComPtr<ID3D11RasterizerState> wireCCWRS;\r\nComPtr<ID3D11RasterizerState> postProcessingRS;\r\nComPtr<ID3D11RasterizerState> billRS;\r\nComPtr<ID3D11RasterizerState> solidBothRS; // front and back\r\nComPtr<ID3D11RasterizerState> wireBothRS;\r\n\r\n// Depth Stencil States\r\nComPtr<ID3D11DepthStencilState> drawDSS;       // \uc77c\ubc18\uc801\uc73c\ub85c \uadf8\ub9ac\uae30\r\nComPtr<ID3D11DepthStencilState> maskDepth;\r\nComPtr<ID3D11DepthStencilState> maskDSS;       // \uc2a4\ud150\uc2e4\ubc84\ud37c\uc5d0 \ud45c\uc2dc\r\nComPtr<ID3D11DepthStencilState> drawMasked; // \uc2a4\ud150\uc2e4 \ud45c\uc2dc\ub41c \uacf3\ub9cc\r\n\r\n// Blend States\r\nComPtr<ID3D11BlendState> mirrorBS;\r\nComPtr<ID3D11BlendState> accumulateBS;\r\nComPtr<ID3D11BlendState> alphaBS;\r\n\r\n// Shaders\r\nComPtr<ID3D11VertexShader> basicVS;\r\nComPtr<ID3D11VertexShader> skyboxVS;\r\nComPtr<ID3D11VertexShader> samplingVS;\r\nComPtr<ID3D11VertexShader> normalVS;\r\nComPtr<ID3D11VertexShader> depthOnlyVS;\r\nComPtr<ID3D11VertexShader> BillboardVS;\r\nComPtr<ID3D11VertexShader> terrainVS;\r\nComPtr<ID3D11VertexShader> terrainShadowVS;\r\nComPtr<ID3D11VertexShader> sunVS;\r\nComPtr<ID3D11VertexShader> snowVS;\r\nComPtr<ID3D11VertexShader> rainVS;\r\nComPtr<ID3D11VertexShader> lakeVS;\r\nComPtr<ID3D11VertexShader> skinnedVS;\r\nComPtr<ID3D11VertexShader> skinnedShadowVS;\r\nComPtr<ID3D11VertexShader> uiVS;\r\nComPtr<ID3D11VertexShader> simpleVS;\r\nComPtr<ID3D11VertexShader> silhouetteVS;\r\n\r\nComPtr<ID3D11PixelShader> basicPS;\r\nComPtr<ID3D11PixelShader> basicCharacterPS;\r\nComPtr<ID3D11PixelShader> skyboxPS;\r\nComPtr<ID3D11PixelShader> samplingPS;\r\nComPtr<ID3D11PixelShader> combinePS;\r\nComPtr<ID3D11PixelShader> bloomDownPS;\r\nComPtr<ID3D11PixelShader> bloomUpPS;\r\nComPtr<ID3D11PixelShader> normalPS;\r\nComPtr<ID3D11PixelShader> depthOnlyPS;\r\nComPtr<ID3D11PixelShader> postEffectsPS;\r\nComPtr<ID3D11PixelShader> BillboardPS;\r\nComPtr<ID3D11PixelShader> terrainPS;\r\nComPtr<ID3D11PixelShader> terrainPassPS;\r\nComPtr<ID3D11PixelShader> sunPS;\r\nComPtr<ID3D11PixelShader> simplePS;\r\nComPtr<ID3D11PixelShader> snowPS;\r\nComPtr<ID3D11PixelShader> rainPS;\r\nComPtr<ID3D11PixelShader> lakePS;\r\nComPtr<ID3D11PixelShader> uiPS;\r\nComPtr<ID3D11PixelShader> silhouettePS;\r\nComPtr<ID3D11PixelShader> ssaoNormalPS;\r\n\r\nComPtr<ID3D11GeometryShader> BillboardGS;\r\nComPtr<ID3D11GeometryShader> normalGS;\r\nComPtr<ID3D11GeometryShader> snowSBGS;\r\n\r\nComPtr<ID3D11HullShader> terrainHS;\r\nComPtr<ID3D11HullShader> terrainShadowHS;\r\nComPtr<ID3D11HullShader> lakeHS;\r\n\r\nComPtr<ID3D11DomainShader> terrainDS;\r\nComPtr<ID3D11DomainShader> terrainShadowDS;\r\nComPtr<ID3D11DomainShader> lakeDS;\r\nComPtr<ID3D11DomainShader> lakeShadowDS;\r\nComPtr<ID3D11DomainShader> lakeDepthDS;\r\n\r\n// Input Layouts\r\nComPtr<ID3D11InputLayout> basicIL;\r\nComPtr<ID3D11InputLayout> samplingIL;\r\nComPtr<ID3D11InputLayout> skyboxIL;\r\nComPtr<ID3D11InputLayout> postProcessingIL;\r\nComPtr<ID3D11InputLayout> BillboardIL;\r\nComPtr<ID3D11InputLayout> terrainIL;\r\nComPtr<ID3D11InputLayout> snowIL;\r\nComPtr<ID3D11InputLayout> rainIL;\r\nComPtr<ID3D11InputLayout> lakeIL;\r\nComPtr<ID3D11InputLayout> skinnedIL;\r\n\r\n// Graphics Pipeline States\r\nGraphicsPSO defaultSolidPSO;\r\nGraphicsPSO defaultWirePSO;\r\nGraphicsPSO stencilMaskPSO;\r\nGraphicsPSO reflectSolidPSO;\r\nGraphicsPSO reflectWirePSO;\r\nGraphicsPSO skyboxSolidPSO;\r\nGraphicsPSO skyboxWirePSO;\r\nGraphicsPSO reflectSkyboxSolidPSO;\r\nGraphicsPSO reflectSkyboxWirePSO;\r\nGraphicsPSO normalsPSO;\r\nGraphicsPSO depthOnlyPSO;\r\nGraphicsPSO postEffectsPSO;\r\nGraphicsPSO postProcessingPSO;\r\nGraphicsPSO samplingPSO;\r\nGraphicsPSO BillboardPSO;\r\nGraphicsPSO particlePSO;\r\nGraphicsPSO terrainSolidPSO;\r\nGraphicsPSO terrainWirePSO;\r\nGraphicsPSO reflectTerrainSolidPSO;\r\nGraphicsPSO reflectTerrainWirePSO;\r\nGraphicsPSO terrainShadowPSO;\r\nGraphicsPSO terrainPassPSO;\r\nGraphicsPSO sunPSO;\r\nGraphicsPSO BoundingBoxPSO;\r\nGraphicsPSO snowPSO;\r\nGraphicsPSO reflectSnowPSO;\r\nGraphicsPSO rainPSO;\r\nGraphicsPSO reflectRainPSO;\r\nGraphicsPSO lakePSO;\r\nGraphicsPSO lakeShadowPSO;\r\nGraphicsPSO lakeDepthPSO;\r\nGraphicsPSO uiPSO;\r\nGraphicsPSO collisionPSO;\r\nGraphicsPSO silhouettePSO;\r\n\r\nGraphicsPSO skinnedSolidPSO;\r\nGraphicsPSO reflectSkinnedSolidPSO;\r\nGraphicsPSO skinnedShadowPSO;\r\nGraphicsPSO skinnedSilhouettePSO;\r\n\r\nComPtr<ID3D11ComputeShader> m_InitPixelCS;\r\n\r\n} \r\n\r\nvoid Graphics::InitCommonStates(ComPtr<ID3D11Device> &device) {\r\n\r\n    InitShaders(device);\r\n    InitSamplers(device);\r\n    InitRasterizerStates(device);\r\n    InitBlendStates(device);\r\n    InitDepthStencilStates(device);\r\n    InitPipelineStates(device);\r\n}\r\n \r\nvoid Graphics::InitSamplers(ComPtr<ID3D11Device> &device) {\r\n     \r\n    D3D11_SAMPLER_DESC sampDesc;\r\n    ZeroMemory(&sampDesc, sizeof(sampDesc));\r\n    sampDesc.Filter = D3D11_FIL",
    "// Standard libraries\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n#include <vector>\n\n// External libraries\n#include <SFML/Graphics.hpp>\n\n// Constants\nconst int windowWidth = 800;\nconst int windowHeight = 600;\nconst int cellSize = 2;\nconst int gridWidth = windowWidth / cellSize;\nconst int gridHeight = windowHeight / cellSize;\nstatic int numAlive = 15000; // Number of 'alive' cells at initialization\nstatic int pauseTime = 50; // (In milliseconds)\n\n// Function to initialize the grid with random states\nvoid initializeGrid(std::vector<std::vector<bool>>& grid, int numAlive) {\n    for (int i = 0; i < gridHeight; ++i) { // Initialize all cells to 'dead'\n        for (int j = 0; j < gridWidth; ++j) {\n            grid[i][j] = false;\n        }\n    }\n\n    for (int k = 0; k < numAlive; ++k) { // Randomly set specified number of cells to 'alive'\n        int randRow = rand() % gridHeight;\n        int randCol = rand() % gridWidth;\n        grid[randRow][randCol] = true;\n    }\n}\n\n// Function to count 'alive' neighbors for a given cell\nint countAliveNeighbors(const std::vector<std::vector<bool>>& grid, int row, int col) {\n    int count = 0; // Number of 'alive' neighboring cells \n\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            if (i == 0 && j == 0) { // If cell is the middle cell\n                continue; // Skip cell\n            }\n            int r = row + i; // Get neighboring cell's row\n            int c = col + j; // Get neighboring cell's column\n            if (r >= 0 && r < gridHeight && c >= 0 && c < gridWidth && grid[r][c]) { // If neighboring cell is in grid and 'alive'\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\n// Function to update the grid based on 'Conway's Game of Life' rules\nvoid updateGrid(std::vector<std::vector<bool>>& grid) {\n    std::vector<std::vector<bool>> newGrid(gridHeight, std::vector<bool>(gridWidth, false)); // New grid object\n\n    for (int i = 0; i < gridHeight; ++i) {\n        for (int j = 0; j < gridWidth; ++j) {\n            int liveNeighbors = countAliveNeighbors(grid, i, j); // Number of 'alive' neighboring cells\n            if (grid[i][j]) { // If current cell is alive\n                if (liveNeighbors == 2 || liveNeighbors == 3) {\n                    newGrid[i][j] = true; // Keep cell 'alive'\n                }\n                else {\n                    newGrid[i][j] = false; // Make cell 'dead'\n                }\n            }\n            else { // Current cell is dead\n                if (liveNeighbors == 3) {\n                    newGrid[i][j] = true; // Make cell 'alive'\n                }\n                else {\n                    newGrid[i][j] = false; // Keep cell 'dead'\n                }\n            }\n        }\n    }\n\n    grid = newGrid; // Set grid to new grid\n}\n\n// Function to draw the grid in the SFML window\nvoid drawGrid(sf::RenderWindow& window, const std::vector<std::vector<bool>>& grid) {\n    sf::RectangleShape cell(sf::Vector2f(cellSize, cellSize)); // Square shape object (i.e. cell)\n\n    window.clear(sf::Color::White); // Background color\n\n    for (int i = 0; i < gridHeight; ++i) {\n        for (int j = 0; j < gridWidth; ++j) {\n            if (grid[i][j]) {\n                cell.setPosition(j * cellSize, i * cellSize); // Set current cell's position\n                cell.setFillColor(sf::Color::Black); // Set current cell to the 'alive' state's color\n                window.draw(cell); // Draw current cell\n            }\n        }\n    }\n\n    window.display();\n}\n\n// Main function\nint main() {\n\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Conway's Game of Life\"); // SFML window object\n\n    std::vector<std::vector<bool>> grid(gridHeight, std::vector<bool>(gridWidth, false)); // Grid object\n\n    initializeGrid(grid, numAlive); // Initializes the grid\n\n    while (window.isOpen()) { // Main loop\n        \n        sf::Event windowEvent;\n\n        while (window.pollEvent(windowEvent)) {\n            if (windowEvent.type == sf::Event::Closed) {\n                window.close();\n            }\n        }\n\n        updateGrid(grid); // Updates the next grid\n\n        drawGrid(window, grid); // Draws new grid\n\n        sf::sleep(sf::milliseconds(pauseTime)); // Pauses time between grids\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n\r\nclass ChessBoardArray\r\n{\r\nprotected:\r\n    unsigned size, base;\r\n    int *data;\r\n\r\n    class Row\r\n    {\r\n    protected:\r\n        ChessBoardArray &board;\r\n        int row;\r\n\r\n    public:\r\n        Row(ChessBoardArray &a, int i) : board(a), row(i) {}\r\n        int &operator[](int i) const\r\n        {\r\n            return board.select(row, i);\r\n        }\r\n    };\r\n\r\n    class ConstRow\r\n    {\r\n    protected:\r\n        const ChessBoardArray &board;\r\n        int row;\r\n\r\n    public:\r\n        ConstRow(const ChessBoardArray &a, int i) : board(a), row(i) {}\r\n        int operator[](int i) const\r\n        {\r\n            return board.select(row, i);\r\n        }\r\n    };\r\n\r\npublic:\r\n    // constructor with parameters\r\n    ChessBoardArray(unsigned size = 0, unsigned base = 0) : size(size), base(base), data(new int[(size * size + 1) / 2]) {}\r\n\r\n    // copy constructor\r\n    ChessBoardArray(const ChessBoardArray &a)\r\n    {\r\n        delete[] data;\r\n        size = a.size;\r\n        base = a.base;\r\n        data = new int[(size * size + 1) / 2];\r\n        // copy data from org to new array\r\n        for (int i = 0; i < ((size * size + 1) / 2); i++)\r\n        {\r\n            data[i] = a.data[i];\r\n        }\r\n    }\r\n    ~ChessBoardArray() { delete[] data; }\r\n\r\n    ChessBoardArray &operator=(const ChessBoardArray &a)\r\n    {\r\n        delete[] data;\r\n        size = a.size;\r\n        base = a.base;\r\n        data = new int[(size * size + 1) / 2];\r\n        // copy data from org to new array\r\n        for (int i = 0; i < ((size * size + 1) / 2); i++)\r\n        {\r\n            data[i] = a.data[i];\r\n        }\r\n        return *this;\r\n    }\r\n\r\n    int &select(int i, int j) { return data[loc(i, j)]; }\r\n    int select(int i, int j) const { return data[loc(i, j)]; }\r\n\r\n    const Row operator[](int i) { return Row(*this, i); }\r\n    const ConstRow operator[](int i) const { return ConstRow(*this, i); }\r\n\r\n    friend ostream &operator<<(ostream &out, const ChessBoardArray &a)\r\n    {\r\n        for (int i = 0; i < a.size; i++)\r\n        {\r\n            for (int j = 0; j < a.size; j++)\r\n            {\r\n\r\n                cout << setw(4);\r\n                if ((i % 2 == 0 && j % 2 == 0) || (i % 2 == 1 && j % 2 == 1))\r\n                    cout << a.select(i + a.base, j + a.base);\r\n                else\r\n                    cout << 0;\r\n            }\r\n            cout << endl;\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\nprivate:\r\n    unsigned int loc(int i, int j) const throw(out_of_range)\r\n    {\r\n        int di = i - base, dj = j - base;\r\n        if (di < 0 || dj < 0 || di >= size || dj >= size)\r\n            throw out_of_range(\"invalid block\");\r\n\r\n        if ((di % 2 == 0 && dj % 2 == 1) || (di % 2 == 1 && dj % 2 == 0))\r\n            throw out_of_range(\"block is black\");\r\n\r\n        unsigned int n = di * size + dj;\r\n        return n / 2;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    ChessBoardArray a(4, 1);\r\n    a[2][4] = 2;\r\n    cout << a;\r\n}",
    "#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <ranges>\n#include <sstream>\n#include <vector>\n\nstruct Point\n{\n    int val;\n    double x, y;\n    double distance;\n};\n\nstatic int64_t \nPointClassification(std::vector<Point>& points, size_t k, const Point& p)\n{\n    for (auto& point : points)\n    {\n        point.distance = sqrt((point.x - p.x) * (point.x - p.x) +\n                        (point.y - p.y) * (point.y - p.y));\n    }\n\n    std::ranges::sort(points, [](const auto& a, const auto& b) {\n        return a.distance < b.distance;\n        });\n\n    std::vector<int> frequency_count(3, 0); // Number of groups\n    std::span<Point> point_span{ points.data(), std::min(k, points.size()) };\n    for (auto& point : point_span)\n    {\n        if (point.val < frequency_count.size())\n        {\n            ++frequency_count[point.val];\n        }\n    }\n\n\n    auto max_iterator = std::ranges::max_element(frequency_count);\n    return std::distance(frequency_count.begin(), max_iterator);\n}\n\nstatic std::vector<std::string> \nParseLine(const std::string& str, char delimiter)\n{\n    std::istringstream iss(str);\n    std::string token;\n    std::vector<std::string> tokens;\n\n    while (getline(iss, token, delimiter))\n    {\n        tokens.push_back(token);\n    }\n    \n    return tokens;\n}\n\nint main()\n{\n    std::vector<Point> points;\n    std::ifstream file(\"data_points.txt\");\n    std::string line;\n\n    while (getline(file, line))\n    {\n        auto tokens = ParseLine(line, ',');\n        Point temp{};\n\n        temp.x = std::stod(tokens[0]);\n        temp.y = std::stod(tokens[1]);\n        temp.val = std::stoi(tokens[2]);\n        \n        points.push_back(temp);\n    }\n\n    Point p{};\n    std::cout << \"Enter x and y coordinates of the point to classify: \";\n    std::cin >> p.x >> p.y;\n\n    size_t k;\n    std::cout << \"Enter the number of nearest neighbours to consider: \";\n    std::cin >> k;\n\n    int64_t group = PointClassification(points, k, p);\n    std::cout << \"The point belongs to group \" << group << std::endl;\n\n    return 0;\n}\n\n",
    "#include \"C:\\Users\\PC\\Desktop\\oop-Assign3\\casestudy.h\"\r\n\r\nALU::ALU(int NoOfAdders = 1, int NoOfSubtractor = 1, int NoOfRegisters = 1, int sizeOfRegisters = 1) : NoOfAdders(NoOfAdders), NoOfSubtractor(NoOfSubtractor), NoOfRegisters(NoOfRegisters), sizeOfRegisters(sizeOfRegisters) {}\r\nALU::ALU(const ALU& other) {\r\n\tthis->NoOfAdders = other.NoOfAdders;\r\n\tthis->NoOfSubtractor = other.NoOfSubtractor;\r\n\tthis->NoOfRegisters = other.NoOfRegisters;\r\n\tthis->sizeOfRegisters = other.sizeOfRegisters;\r\n}\r\nint ALU::getNoOfAdders() const {\r\n\treturn this->NoOfAdders;\r\n}\r\nint ALU::getNoOfSubtractor() const {\r\n\treturn this->NoOfSubtractor;\r\n}\r\nint ALU::getNoOfRegisters() const {\r\n\treturn this->NoOfRegisters;\r\n}\r\nint ALU::getsizeOfRegisters() const {\r\n\treturn this->sizeOfRegisters;\r\n}\r\nvoid ALU::setNoOfAdders(int x) {\r\n\tthis->NoOfAdders = x;\r\n}\r\nvoid ALU::setNoOfSubtractor(int x) {\r\n\tthis->NoOfSubtractor = x;\r\n}\r\nvoid ALU::setNoOfRegisters(int x) {\r\n\tthis->NoOfRegisters = x;\r\n}\r\nvoid ALU::setsizeOfRegisters(int x) {\r\n\tthis->sizeOfRegisters = x;\r\n}\r\n\r\nControlUnit::ControlUnit(float clock = 0.0) : clock(clock) {}\r\nControlUnit::ControlUnit(const ControlUnit& other) {\r\n\tthis->clock = other.clock;\r\n}\r\nfloat ControlUnit::getclock() const {\r\n\treturn this->clock;\r\n}\r\nvoid ControlUnit::setclock(float t) {\r\n\tthis->clock = t;\r\n}\r\nCPU::CPU(ALU alu = 0, ControlUnit cu = 0) : alu(alu), cu(cu) {}\r\nCPU::CPU(const CPU& other) {\r\n\tthis->alu = other.alu;\r\n\tthis->cu = other.cu;\r\n}\r\nALU CPU::getALU()const {\r\n\treturn this->alu;\r\n}\r\nControlUnit CPU::getCU()const {\r\n\treturn this->cu;\r\n}\r\nvoid CPU::setALU(const ALU& other) {\r\n\tthis->alu = other;\r\n}\r\nvoid CPU::setCU(const ControlUnit& other) {\r\n\tthis->cu = other;\r\n}\r\nMainMemory::MainMemory(int capacity = 1, string = \"N/A\") : capacity(capacity), technologyType(technologyType) {}\r\nMainMemory::MainMemory(const MainMemory& other) {\r\n\tthis->capacity = other.capacity;\r\n\tthis->technologyType = other.technologyType;\r\n}\r\nint MainMemory::getCapacity()const {\r\n\treturn this->capacity;\r\n}\r\nstring MainMemory::getTechnologyType()const {\r\n\treturn this->technologyType;\r\n}\r\nvoid MainMemory::setCapacity(int x) {\r\n\tthis->capacity = x;\r\n}\r\nvoid MainMemory::setTechnologyType(string s) {\r\n\tthis->technologyType = s;\r\n}\r\nPort::Port(string type = \"N/A\", int baud_rate = 0) : type(type), baud_rate(baud_rate) {}\r\nPort::Port(const Port& other) {\r\n\tthis->type = other.type;\r\n\tthis->baud_rate = other.baud_rate;\r\n}\r\nint Port::getbaud_rate()const {\r\n\treturn this->baud_rate;\r\n}\r\nstring Port::gettype()const {\r\n\treturn this->type;\r\n}\r\nvoid Port::setbaud_rate(int x) {\r\n\tthis->baud_rate = x;\r\n}\r\nvoid Port::settype(string s) {\r\n\tthis->type = s;\r\n}\r\n\r\nMotherBoard::MotherBoard(MainMemory mm = 0, int NumOfPorts = 0, Port *ports = nullptr) : mm(mm), NumOfPorts(NumOfPorts) {\r\n\tports = new Port[NumOfPorts];\r\n\tfor (int i = 0; i < NumOfPorts; i++) {\r\n\t\tthis->ports[i] = ports[i];\r\n\t}\r\n}\r\nMotherBoard::MotherBoard(MotherBoard& other) {\r\n\tthis->mm = other.mm;\r\n\tthis->NumOfPorts = other.NumOfPorts;\r\n\tfor (int i = 0; i < NumOfPorts; i++) {\r\n\t\tthis->ports[i] = other.ports[i];\r\n\t}\r\n}\r\nMainMemory MotherBoard::getMainMemory() {\r\n\treturn mm;\r\n}\r\nPort MotherBoard::getPort(int i) {\r\n\treturn ports[i];\r\n}\r\nvoid MotherBoard::setMainMemory(MainMemory& other) {\r\n\tmm = other;\r\n}\r\nvoid MotherBoard::setPort(int i, Port port) {\r\n\tports[i] = port;\r\n}\r\nMotherBoard::~MotherBoard()}{\r\n\tdelete[] ports;\r\n\tports = nullptr;\r\n}\r\nPhysicalMemory::PhysicalMemory(int capacity = 1) : capacity(capacity) {}\r\nPhysicalMemory::PhysicalMemory(PhysicalMemory& other) {\r\n\tthis->capacity = other.capacity;\r\n}\r\nint PhysicalMemory::getCapacity() const {\r\n\treturn capacity;\r\n}\r\nvoid PhysicalMemory::setCapacity(int x) {\r\n\tcapacity = x;\r\n}\r\nComputer::Computer(PhysicalMemory pm, MotherBoard mb, CPU cpu) : pm(pm), mb(mb), cpu(cpu) {}\r\nComputer::Computer(Computer& other) {\r\n\tthis->pm = other.pm;\r\n\tthis->mb = other.mb;\r\n\tthis->cpu = other.cpu;\r\n}\r\nPhysicalMemory Computer::getPhysicalMemory() const {\r\n\treturn pm;\r\n}\r\nMotherBoard Computer::getMotherBoard() const {\r\n\treturn mb;\r\n}\r\nCPU Computer::getCPU() const {\r\n\treturn cpu;\r\n}\r\nvoid Computer::setPhysicalMemory(PhysicalMemory& other) {\r\n\tthis->pm = other;\r\n}\r\nvoid Computer::setMotherBoard(MotherBoard& other) {\r\n\tthis->mb = other;\r\n}\r\nvoid Computer::setCPU(CPU& other) {\r\n\tthis->cpu = other;\r\n}\r\nGraphicsCard::GraphicsCard(string brand, int memorySize, double price) : brand(brand), memorySize(memorySize), price(price) {}\r\nGraphicsCard::GraphicsCard(GraphicsCard& other) {\r\n\tthis->brand = other.brand;\r\n\tthis->memorySize = other.memorySize;\r\n\tthis->price = other.price;\r\n}\r\nstring GraphicsCard::getBrand() {\r\n\treturn brand;\r\n}\r\nint GraphicsCard::getMemorySize() {\r\n\treturn memorySize;\r\n}\r\ndouble GraphicsCard::getPrice() {\r\n\treturn price;\r\n}\r\nvoid GraphicsCard::setBrand(string new_brand) {\r\n\tthis->brand = new_brand;\r\n}\r\nvoid GraphicsCard::setMemorySize(int new_size) {\r\n\tthis->memorySize = new_size;\r\n}\r\nvoid GraphicsCard::setPrice(double new_price) {\r\n\tthis->price = ne",
    "//\n//  main.cpp\n//  \n//  The main file for assignment 6; tests the data structure through\n//  the tests in tests.cpp.\n//  Don't worry too much about what's in this file frankly...\n//  There is nothing in this file that you need to change unless\n//  you want to do some testing by modifying main().\n//\n//  Copyright 2019 David Kopec\n//\n//  Permission is hereby granted, free of charge, to any person\n//  obtaining a copy of this software and associated documentation files\n//  (the \"Software\"), to deal in the Software without restriction,\n//  including without limitation the rights to use, copy, modify, merge,\n//  publish, distribute, sublicense, and/or sell copies of the Software,\n//  and to permit persons to whom the Software is furnished to do so,\n//  subject to the following conditions:\n//\n//  The above copyright notice and this permission notice\n//  shall be included in all copies or substantial portions of the Software.\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n//  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n//  OTHER DEALINGS IN THE SOFTWARE.\n\n#define CATCH_CONFIG_RUNNER\n#include \"/Users/ryanjackson/Desktop/Champlain/2024_Spring/CSI420/Final Project/RefactoringHashTables/lib/catch.h\"\n\nusing namespace std;\n\n// Test all code\nint main( int argc, char* argv[] ) {\n    // run tests\n    int result = Catch::Session().run( argc, argv );\n    \n    return result;\n}\n\n",
    "#include \"ResourceManager.h\"\r\n\r\n\r\nResourceManager::ResourceManager()\r\n{\r\n}\r\nResourceManager::~ResourceManager()\r\n{\r\n    Release();\r\n}\r\n\r\n//Load a texture from a file and associate it with the key id\r\nAppStatus ResourceManager::LoadTexture(Resource id, const std::string& file_path)\r\n{\r\n    //Load the texture\r\n    Texture2D texture = ::LoadTexture(file_path.c_str());\r\n    if (texture.id == 0)\r\n    {\r\n        //Error loading texture\r\n        LOG(\"Failed to load texture \", file_path);\r\n        return AppStatus::ERROR;\r\n    }\r\n    \r\n    //Insert the loaded texture into the map with the specified key\r\n    textures[id] = texture;\r\n    return AppStatus::OK;\r\n}\r\n\r\n//Release the texture associated with the key id\r\nvoid ResourceManager::ReleaseTexture(Resource id)\r\n{\r\n    //Find the texture associated with the key\r\n    auto it = textures.find(id);\r\n\r\n    //If found, unload the texture and remove it from the map\r\n    if (it != textures.end())\r\n    {\r\n        UnloadTexture(it->second);\r\n        textures.erase(it);\r\n    }\r\n}\r\n\r\n//Get a texture by key\r\nconst Texture2D* ResourceManager::GetTexture(Resource id) const\r\n{\r\n    //Find the texture associated with the key and return it\r\n    auto it = textures.find(id);\r\n    if (it != textures.end())   return &(it->second);\r\n\r\n    //Return nullptr if key is not found\r\n    return nullptr;\r\n}\r\n\r\nvoid ResourceManager::Release()\r\n{\r\n    for (auto& pair : textures)\r\n    {\r\n        UnloadTexture(pair.second);\r\n    }\r\n    textures.clear();\r\n}",
    "//\n// Created by \u8c2d\u6f14\u950b on 2024/4/13.\n//\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<netinet/in.h>\n#include<arpa/inet.h>\n#include<assert.h>\n#include<stdio.h>\n#include<unistd.h>\n#include<errno.h>\n#include<string.h>\n#include<fcntl.h>\n#include<stdlib.h>\n#include<sys/epoll.h>\n #include<pthread.h>\n#define MAX_EVENT_NUMBER 1024\n#define TCP_BUFFER_SIZE 512\n#define UDP_BUFFER_SIZE 1024\nint setnonblocking(int fd)\n{\nint old_option=fcntl(fd,F_GETFL);\nint new_option=old_option|O_NONBLOCK; fcntl(fd,F_SETFL,new_option);\nreturn old_option;\n}\nvoid addfd(int epollfd,int fd)\n{\n    epoll_event event;\n    event.data.fd=fd;\n    event.events=EPOLLIN|EPOLLET;\n    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&event);\n    setnonblocking(fd);\n}\nint main(int argc,char*argv[])\n{\n    if(argc<=2)\n    {\n        printf(\"usage:%s ip_address port_number\\n\",basename(argv[0])); return 1;\n    }\n    const char*ip=argv[1];\n    int port=atoi(argv[2]);\n    int ret=0;\n    struct sockaddr_in address;\n    bzero(&address,sizeof(address));\n    address.sin_family=AF_INET;\n    inet_pton(AF_INET,ip,&address.sin_addr);\n    address.sin_port=htons(port);\n    /*\u521b\u5efaTCP socket\uff0c\u5e76\u5c06\u5176\u7ed1\u5b9a\u5230\u7aef\u53e3port\u4e0a*/\n    int listenfd=socket(PF_INET,SOCK_STREAM,0);\n    assert(listenfd>=0);\n    ret=bind(listenfd,(struct sockaddr*)&address,sizeof(address)); assert(ret!=-1);\n    ret=listen(listenfd,5);\n    assert(ret!=-1);\n\n    /*\u521b\u5efaUDP socket\uff0c\u5e76\u5c06\u5176\u7ed1\u5b9a\u5230\u7aef\u53e3port\u4e0a*/\n    bzero(&address,sizeof(address));\n    address.sin_family=AF_INET;\n    inet_pton(AF_INET,ip,&address.sin_addr);\n    address.sin_port=htons(port);\n    int udpfd=socket(PF_INET,SOCK_DGRAM,0);\n    assert(udpfd>=0);\n    ret=bind(udpfd,(struct sockaddr*)&address,sizeof(address));\n    assert(ret!=-1);\n//    \u521b\u5efaepoll\n    epoll_event events[MAX_EVENT_NUMBER];\n    int epollfd=epoll_create(5);\n    assert(epollfd!=-1);\n/*\u6ce8\u518cTCP socket\u548cUDP socket\u4e0a\u7684\u53ef\u8bfb\u4e8b\u4ef6*/\n    addfd(epollfd,listenfd);\n    addfd(epollfd,udpfd);\n    while(1)\n    {\n        int number=epoll_wait(epollfd,events,MAX_EVENT_NUMBER,-1);\n        if(number<0)\n        {\n            printf(\"epoll failure\\n\");\n            break;\n        }\n        for(int i=0;i<number;i++)\n        {\n            int sockfd=events[i].data.fd;\n            if(sockfd==listenfd)\n            {\n                struct sockaddr_in client_address;\n                socklen_t client_addrlength=sizeof(client_address);\n                int connfd=accept(listenfd,(struct sockaddr*) &client_address,&client_addrlength);\n                addfd(epollfd,connfd);\n            }\n            else if(sockfd==udpfd)\n            {\n                char buf[UDP_BUFFER_SIZE]; memset(buf,'\\0',UDP_BUFFER_SIZE);\n                struct sockaddr_in client_address;\n                socklen_t client_addrlength=sizeof(client_address);\n                ret=recvfrom(udpfd,buf,UDP_BUFFER_SIZE-1,0,(struct sockaddr*)&client_address,&client_addrlength);\n                if(ret>0)\n                {\n                    sendto(udpfd,buf,UDP_BUFFER_SIZE-1,0,(struct sockaddr*)&client_address,client_addrlength);\n                }\n            }\n            else if(events[i].events&EPOLLIN) {\n                char buf[TCP_BUFFER_SIZE];\n                while(1)\n                {\n                    memset(buf,'\\0',TCP_BUFFER_SIZE);\n                    ret=recv(sockfd,buf,TCP_BUFFER_SIZE-1,0); if(ret<0)\n                    {\n                        if((errno==EAGAIN)||(errno==EWOULDBLOCK))\n                        {\n                            break;\n                        }\n                        close(sockfd);\n                        break;\n                    }\n                    else if(ret==0)\n                    {\n                        close(sockfd);\n                    }\n                    else\n                    {\n                        send(sockfd,buf,ret,0);\n                    }\n                }\n            }\n            else\n            {\n                printf(\"something else happened\\n\");\n            }\n        }\n    }\n    close(listenfd);\n    return 0;\n}",
    "#include \"camera.h\"\n#include \"../DirectX/Direct3D.h\"\n\nXMFLOAT3 _position;\nXMFLOAT3 _target;\nXMMATRIX _view;\nXMMATRIX _proj;\nXMMATRIX _billBoard;\n\n//\u521d\u671f\u5316\uff08\u30d7\u30ed\u30b8\u30a7\u30af\u30b7\u30e7\u30f3\u884c\u5217\u4f5c\u6210\uff09\nvoid Camera::Initialize()\n{\n\t_position = XMFLOAT3(0, 3, -10);\t//\u30ab\u30e1\u30e9\u306e\u4f4d\u7f6e\n\t_target = XMFLOAT3( 0, 0, 0);\t//\u30ab\u30e1\u30e9\u306e\u7126\u70b9\n\n\t//\u30d7\u30ed\u30b8\u30a7\u30af\u30b7\u30e7\u30f3\u884c\u5217\n\t_proj = XMMatrixPerspectiveFovLH(XM_PIDIV4, (FLOAT)Direct3D::screenWidth_ / (FLOAT)Direct3D::screenHeight_, 0.1f, 1000.0f);\n}\n\n//\u66f4\u65b0\uff08\u30d3\u30e5\u30fc\u884c\u5217\u4f5c\u6210\uff09\nvoid Camera::Update()\n{\n\t//\u30d3\u30e5\u30fc\u884c\u5217\n\t_view = XMMatrixLookAtLH(XMVectorSet(_position.x, _position.y, _position.z, 0),\n\t\tXMVectorSet(_target.x, _target.y, _target.z, 0), XMVectorSet(0, 1, 0, 0));\n\n\n\t//\u30d3\u30eb\u30dc\u30fc\u30c9\u884c\u5217\n\t//\uff08\u5e38\u306b\u30ab\u30e1\u30e9\u306e\u65b9\u3092\u5411\u304f\u3088\u3046\u306b\u56de\u8ee2\u3055\u305b\u308b\u884c\u5217\u3002\u30d1\u30fc\u30c6\u30a3\u30af\u30eb\u3067\u3057\u304b\u4f7f\u308f\u306a\u3044\uff09\n\t//http://marupeke296.com/DXG_No11_ComeOnBillboard.html\n\t_billBoard = XMMatrixLookAtLH(XMVectorSet(0, 0, 0, 0), XMLoadFloat3(&_target)- XMLoadFloat3(&_position), XMVectorSet(0, 1, 0, 0));\n\t_billBoard = XMMatrixInverse(nullptr, _billBoard);\n}\n\n//\u7126\u70b9\u3092\u8a2d\u5b9a\nvoid Camera::SetTarget(XMFLOAT3 target) { _target = target; }\n\n//\u4f4d\u7f6e\u3092\u8a2d\u5b9a\nvoid Camera::SetPosition(XMFLOAT3 position) { _position = position; }\n\n//\u7126\u70b9\u3092\u53d6\u5f97\nXMFLOAT3 Camera::GetTarget() { return _target; }\n\n//\u4f4d\u7f6e\u3092\u53d6\u5f97\nXMFLOAT3 Camera::GetPosition() { return _position; }\n\n//\u30d3\u30e5\u30fc\u884c\u5217\u3092\u53d6\u5f97\nXMMATRIX Camera::GetViewMatrix() { return _view; }\n\n//\u30d7\u30ed\u30b8\u30a7\u30af\u30b7\u30e7\u30f3\u884c\u5217\u3092\u53d6\u5f97\nXMMATRIX Camera::GetProjectionMatrix() { return _proj; }\n\n//\u30d3\u30eb\u30dc\u30fc\u30c9\u7528\u56de\u8ee2\u884c\u5217\u3092\u53d6\u5f97\nXMMATRIX Camera::GetBillboardMatrix(){\treturn _billBoard; }\n",
    "// Pass by value and pass by reference\n// In C++, function arguments can be passed by value or by reference.\n// When an argument is passed by value, a copy of the argument is made and passed to the function.\n// This means that changes made to the argument inside the function do not affect the original value.\n// When an argument is passed by reference, the memory address of the argument is passed to the function.\n// This allows the function to directly modify the original value.\n\n#include <iostream>\n\nusing namespace std;\n\n// Pass by value\nvoid incrementByValue(int num) {\n    num++;\n}\n\n// Pass by reference\nvoid incrementByReference(int& num) {\n    num++;\n}\n\n// Pass by pointer (also a form of pass by reference)\nvoid incrementByPointer(int* num) {\n    (*num)++;\n}\n\nint main() {\n    int num = 42;\n\n    // Pass by value\n    cout << \"Before incrementByValue: \" << num << endl;\n    incrementByValue(num);\n    cout << \"After incrementByValue: \" << num << endl;\n\n    // Pass by reference\n    cout << \"Before incrementByReference: \" << num << endl;\n    incrementByReference(num);\n    cout << \"After incrementByReference: \" << num << endl;\n\n    // Pass by pointer\n    cout << \"Before incrementByPointer: \" << num << endl;\n    incrementByPointer(&num);\n    cout << \"After incrementByPointer: \" << num << endl;\n\n    return 0;\n}",
    "#include \"sound.hpp\"\n\n#include <climits>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\nSound::Sound(string fname, int nMargin, Window::WindowType windowType) {\n  ifstream fin;\n  char tag[4];\n  int buf4;\n  short buf2;\n  int blockSize;\n  m_nMargin = nMargin;\n  cerr << \"Read file: \" << fname << endl;\n  fin.open(fname, ios::in | ios::binary);\n  if (!fin) {\n    cerr << \"Cannot open file: \" << fname << endl;\n    return;\n  }\n  fin.read(tag, 4);  // \"RIFF\"\n  if (strncmp(tag, \"RIFF\", 4)) {\n    cerr << \"File is not RIFF format.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf4, 4);  // RIFF\u30c1\u30e3\u30f3\u30af\u30b5\u30a4\u30ba\n  fin.read(tag, 4);            // \"WAVE\"\n  if (strncmp(tag, \"WAVE\", 4)) {\n    cerr << \"File is not WAVE format.\" << endl;\n    return;\n  }\n  fin.read(tag, 4);  // \"fmt \"\n  if (strncmp(tag, \"fmt \", 4)) {\n    cerr << \"fmt chunk is invalid.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf4, 4);  // fmt\u30c1\u30e3\u30f3\u30af\u30b5\u30a4\u30ba\n  if (buf4 != 16) {\n    cerr << \"Unsupported format.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf2, 2);  // \u97f3\u58f0\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\n  fin.read((char *)&buf2, 2);  // \u30c1\u30e3\u30cd\u30eb\u6570\n  m_nChannels = buf2;\n  fin.read((char *)&buf4, 4);  // \u30b5\u30f3\u30d7\u30eb\u30ec\u30fc\u30c8\n  m_fs = buf4;\n  cerr << m_fs << \" Hz\" << endl;\n  fin.read((char *)&buf4, 4);  // bytes / sec\n  fin.read((char *)&buf2, 2);  // \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\n  blockSize = buf2;\n  fin.read((char *)&buf2, 2);  // \u30d3\u30c3\u30c8\u6df1\u5ea6\n  fin.read(tag, 4);            // \"data\"\n  if (strncmp(tag, \"data\", 4)) {\n    cerr << \"data chunk not found.\" << endl;\n    return;\n  }\n  fin.read((char *)&buf4, 4);  // data\u30c1\u30e3\u30f3\u30af\u30b5\u30a4\u30ba\n  m_nSamples = buf4 / blockSize;\n  m_duration = (double)m_nSamples / m_fs;\n  cerr << m_duration << \" sec\" << endl;\n  m_x = new double[m_nSamples + 2 * nMargin];\n  for (int n = 0; n < nMargin; n++) {\n    m_x[n] = 0.0;\n    m_x[m_nSamples + nMargin + n] = 0.0;\n  }\n  for (int n = nMargin; n < m_nSamples + nMargin; n++) {\n    fin.read((char *)&buf2, 2);\n    m_x[n] = (double)(buf2 + (SHRT_MAX + 1.0) + 0.5) / (SHRT_MAX + 1.0) - 1.0;\n  }\n  fin.close();\n  m_fft = new FFT(2048, windowType, m_fs);\n}\n\nSound::~Sound() {\n  delete[] m_x;\n  delete m_fft;\n}\n\nvoid Sound::stft(int hopSize, Window::WindowType windowType, int windowSize) {\n  int nFFT = m_fft->nFFT();\n  if (m_nMargin < nFFT / 2) {\n    cerr << \"Too short nMargin: \" << m_nMargin << \", nFFT: \" << nFFT << endl;\n    return;\n  }\n  double *in = new double[nFFT];\n  complex<double> *out = new complex<double>[nFFT];\n  m_fft->setWindow(windowType, windowSize);\n  Window *window = m_fft->window();\n  double width = m_nSamples / hopSize;\n  m_spec = new complex<double> *[int(width)];\n  for (int i = 0; i < width; i++) {\n    m_spec[i] = new complex<double>[nFFT / 2];\n  }\n  m_specMax = 0.0;\n  m_specMin = 1.0;\n  for (int i = 0; i < m_nSamples / hopSize; i++) {\n    for (int n = -nFFT / 2; n < nFFT / 2; n++) {\n      in[n + nFFT / 2] =\n          m_x[i * hopSize + m_nMargin + n] * window->data()[n + nFFT / 2];\n    }\n    m_fft->exec(in, out);\n    for (int k = 0; k < nFFT / 2; k++) {\n      m_spec[i][k] = out[k];\n      if (abs(m_spec[i][k]) > m_specMax) {\n        m_specMax = abs(m_spec[i][k]);\n      }\n      if (abs(m_spec[i][k]) < m_specMin) {\n        m_specMin = abs(m_spec[i][k]);\n      }\n    }\n  }\n  delete[] in;\n  delete[] out;\n}\n",
    "#include <cassert>\r\n#include <chrono>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <vector>\r\n\r\n#include \"convolution.h\"\r\n\r\nvoid read_input(const std::string& data_file, parameters& p, std::vector<float>& IPs, std::vector<float>& Fs, std::vector<float>& Bs, std::vector<float>& OPs);\r\nvoid read_reference_output(const std::string& ref_fname, std::vector<float>& OPs);\r\nfloat validate_result(const std::vector<float>& refOPs, const std::vector<float>& OPs);\r\n\r\nint main()\r\n{\r\n    using namespace std;\r\n    using namespace std::chrono;\r\n    using clock = steady_clock;\r\n\r\n    std::vector<float> IPs, Fs, Bs, OPs, refOPs;\r\n\r\n    parameters p = {0};\r\n\r\n    static const float error_threshold = 0.0f;\r\n\r\n    read_input(\"input.dat\", p, IPs, Fs, Bs, OPs);\r\n    read_reference_output(\"reference_output.dat\", refOPs);\r\n\r\n    // Create the convolution\r\n    convolution* c = convolution_new(&p);\r\n\r\n    // The benchmark parameters\r\n    unsigned int N_iter = 1;\r\n\r\n    clock::duration total_time = clock::duration::zero();\r\n    for (unsigned int i = 0; i < N_iter; i++) {\r\n        auto start_time = clock::now();\r\n\r\n        // run the convolution\r\n        convolution_run(c);\r\n\r\n        total_time += (clock::now() - start_time);\r\n        if (i % 50 == 0) {\r\n            // update the result in p.OPs\r\n            convolution_result(c);\r\n            float total_error = validate_result(refOPs, OPs);\r\n            std::cout << \"Validated: \" << std::boolalpha << (total_error <= error_threshold) << std::endl;\r\n        }\r\n    }\r\n    std::cout << \"Running time: \" << duration_cast<milliseconds>(total_time).count() / (double)N_iter << \" ms\" << std::endl;\r\n\r\n    // destroy the convolution\r\n    convolution_destroy(c);\r\n\r\n    // Returning\r\n    return 0;\r\n}\r\n\r\nvoid read_input(const std::string& data_file, parameters& p, std::vector<float>& IPs, std::vector<float>& Fs, std::vector<float>& Bs, std::vector<float>& OPs)\r\n{\r\n    FILE* f = fopen(data_file.c_str(), \"rb\");\r\n    if (f == 0) {\r\n        std::cerr << \"Cannot open data file: \" << data_file << std::endl;\r\n        exit(-1);\r\n    }\r\n    fread((char*)&p.IP_N, sizeof(p.IP_N), 1, f);\r\n    fread((char*)&p.IP_w, sizeof(p.IP_w), 1, f);\r\n    fread((char*)&p.IP_h, sizeof(p.IP_h), 1, f);\r\n    IPs.resize(p.IP_N * p.IP_w * p.IP_h);\r\n    fread((char*)IPs.data(), IPs.size() * sizeof(float), 1, f);\r\n    p.IPs = IPs.data();\r\n\r\n    fread((char*)&p.F_N, sizeof(p.F_N), 1, f);\r\n    fread((char*)&p.F_w, sizeof(p.F_w), 1, f);\r\n    fread((char*)&p.F_h, sizeof(p.F_h), 1, f);\r\n    fread((char*)&p.F_d, sizeof(p.F_d), 1, f);\r\n    Fs.resize(p.F_N * p.F_w * p.F_h * p.F_d);\r\n    fread((char*)Fs.data(), Fs.size() * sizeof(float), 1, f);\r\n    p.Fs = Fs.data();\r\n\r\n    Bs.resize(p.F_N);\r\n    fread((char*)Bs.data(), Bs.size() * sizeof(float), 1, f);\r\n    p.Bs = Bs.data();\r\n\r\n    fread((char*)&p.S_w, sizeof(p.S_w), 1, f);\r\n    fread((char*)&p.S_h, sizeof(p.S_h), 1, f);\r\n\r\n    p.OP_N = p.F_N;\r\n    p.OP_w = (p.IP_w - p.F_w) / p.S_w + 1;\r\n    p.OP_h = (p.IP_h - p.F_h) / p.S_h + 1;\r\n    OPs.resize(p.OP_N * p.OP_w * p.OP_h);\r\n    p.OPs = OPs.data();\r\n\r\n    fclose(f);\r\n}\r\n\r\nvoid read_reference_output(const std::string& ref_fname, std::vector<float>& OPs)\r\n{\r\n    FILE* f = fopen(\"reference_output.dat\", \"rb\");\r\n\r\n    if (f == 0) {\r\n        std::cerr << \"Cannot open reference file: \" << ref_fname << std::endl;\r\n        exit(-1);\r\n    }\r\n\r\n    unsigned rOP_N, rOP_w, rOP_h;\r\n    fread(&rOP_N, sizeof(rOP_N), 1, f);\r\n    fread(&rOP_w, sizeof(rOP_w), 1, f);\r\n    fread(&rOP_h, sizeof(rOP_h), 1, f);\r\n    OPs.resize(rOP_N * rOP_w * rOP_h);\r\n    fread((char*)OPs.data(), OPs.size() * sizeof(float), 1, f);\r\n    fclose(f);\r\n}\r\n\r\nfloat validate_result(const std::vector<float>& refOPs, const std::vector<float>& OPs)\r\n{\r\n    assert(refOPs.size() == OPs.size() && \"Wrong output size!\");\r\n    float error = 0;\r\n    for (size_t i = 0; i < refOPs.size(); ++i) {\r\n        error += std::fabs(refOPs[i] - OPs[i]);\r\n    }\r\n    return error;\r\n}\r\n",
    "#include <Arduino.h>\n#include <LiquidCrystal.h>\n#include <Keypad.h>\n\nLiquidCrystal lcd(2, 3, A3, A2, A1, A0);\n\nconst int ROW_NUM = 4;\nconst int COLUMN_NUM = 4;\n\nchar keys[ROW_NUM][COLUMN_NUM] = {\n  {'1','2','3', 'A'},\n  {'4','5','6', 'B'},\n  {'7','8','9', 'C'},\n  {'*','0','#', 'D'}\n};\n\nbyte pin_rows[ROW_NUM] = {4, 5, 6, 7};\nbyte pin_column[COLUMN_NUM] = {8, 9, 10, 11};\n\nKeypad keypad = Keypad( makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM );\n\nchar password[] = {'3', '5', '9', '3'};\nchar input[] = {'-', '-', '-', '-'};\nchar key;\nint pos = 0;\n\nvoid setup(){\n  pinMode(A4, OUTPUT);\n  pinMode(A5, OUTPUT);\n\n  lcd.begin(16, 2);\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"Enter password:\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"----\");\n  lcd.setCursor(0, 1);\n}\n\nvoid loop(){\n  key = keypad.getKey();\n\n  if (key == '#') {\n    if (pos != 0) {\n      pos--;\n      input[pos] = '-';\n      lcd.moveCursorLeft();\n      lcd.print('-');\n      lcd.moveCursorLeft();\n    }    \n  }\n  else if (key == '*') {\n    if (pos == 4) {\n      lcd.clear();\n      lcd.setCursor(0, 0);\n\n      if (password[0] == input[0] &&\n          password[1] == input[1] &&\n          password[2] == input[2] &&\n          password[3] == input[3]) {\n            digitalWrite(A5, HIGH);\n            lcd.print(\"Correct password\");\n            delay(3000);\n            digitalWrite(A5, LOW);\n      }\n      else {\n        digitalWrite(A4, HIGH);\n        lcd.print(\"Wrong password!\");\n        delay(3000);\n        digitalWrite(A4, LOW);\n      }\n\n      for (int i = 0; i < 4; i++) {\n        input[i] = '-';\n      }\n\n      lcd.clear();\n      lcd.setCursor(0, 0);\n      lcd.print(\"Enter password:\");\n      lcd.setCursor(0, 1);\n      lcd.print(\"----\");\n      lcd.setCursor(0, 1);\n      pos = 0;\n    }    \n  }\n  else if (key) {\n    if (pos < 4) {\n      input[pos] = key;\n      pos++;\n      lcd.print(key);\n    }\n  }\n}",
    "# 1 \"hazard_detector.cpp\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 396 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"D:/Xilinx/Vitis_HLS/2023.2/common/technology/autopilot\\\\etc/autopilot_ssdm_op.h\" 1\n# 105 \"D:/Xilinx/Vitis_HLS/2023.2/common/technology/autopilot\\\\etc/autopilot_ssdm_op.h\"\nextern \"C\" {\n\n\n\n\n\n\n    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n\n    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n\n\n\n    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_PrintNone(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_PrintInt(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_PrintDouble(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n\n    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));\n\n    int _ssdm_",
    "//\n// Created by james on 4/14/2024.\n//\n\n#include \"Detect_Algorithm2.h\"\n\nDetect_Algorithm2::Detect_Algorithm2() {\n}\n\nDetect_Algorithm2::~Detect_Algorithm2() {\n}\n\nstd::string Detect_Algorithm2::prep(const std::string message) {\n\n    algorithm_name = \"Single Checksum\";\n    originalChecksum = 0;\n    for (int i = 0; i < message.size(); i++) {\n        originalChecksum += message[i];\n    }\n\n    return message;\n}\n\nstd::vector<bool> Detect_Algorithm2::detect(const std::string message) {\n    newChecksum = 0;\n    for (int i = 0; i < message.size(); i++) {\n        newChecksum += message[i];\n    }\n    //std::cout << originalChecksum << \" \" << newChecksum << std::endl;\n    if (originalChecksum != newChecksum){\n        return {true};\n    }\n    else{\n        return {false};\n    }\n}\n\n\nstd::vector<float> Detect_Algorithm2::calculate_error_rate_detect(const std::string original_message, const std::string corrupted_message, const std::vector<bool> detected_errors) {\n    // If the frame is detected as incorrect, return no error\n    if (detected_errors[0] == false){\n        return {};\n    }\n\n    // Iterate over the string and see how many are incorrect\n    int error_count = 0;\n    for (int i = 0; i < original_message.size(); i++) {\n        if (original_message[i] != corrupted_message[i]) {\n            error_count++;\n        }\n    }\n    return {static_cast<float>(error_count) / original_message.size()};\n}\n\n\nstd::string Detect_Algorithm2::remove_correct_frames(const std::vector<bool> detected_errors, const std::string corrupted_message, const std::string prepared_message) {\n    if (detected_errors[0] == true){\n        return prepared_message;\n    }\n    else{\n        return \"\";\n    }\n}",
    "#include <iostream>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nclass Calendar\r\n{\r\npublic:\r\n    int year;\r\n    int month;\r\n    Calendar(int y, int m)\r\n    {\r\n        year=y;\r\n        month=m;\r\n    }\r\n\r\n    int getDaysInMonth()\r\n    {\r\n        if (month == 2)\r\n        {\r\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) //If the entered year is a leap year//\r\n                return 29; \r\n            else\r\n                return 28; //If the entered year is not leap year//\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) //Foe even months having 30 days\r\n            return 30;\r\n        else\r\n            return 31; //For odd months having 31 days\r\n    }\r\n\r\n    void displayCalendar()\r\n    {\r\n        cout << \"-----------------------------\" << endl;\r\n        cout << \"       \" << getMonthName() << \" \" << year << endl;\r\n        cout << \"-----------------------------\" << endl;\r\n        cout << \" Sun Mon Tue Wed Thu Fri Sat\" << endl;\r\n\r\n        int startingDay = getStartingDay();\r\n        int daysInMonth = getDaysInMonth();\r\n\r\n        int day = 1;\r\n\r\n        // Print leading spaces\r\n        for (int i = 0; i < startingDay; i++)\r\n        {\r\n            cout << setw(4) << \" \";\r\n        }\r\n\r\n        // Print the days of the month\r\n        for (int i = 1; i <= daysInMonth; i++)\r\n        {\r\n            cout << setw(4) << day++;\r\n            if ((i + startingDay) % 7 == 0 || i == daysInMonth)\r\n                cout << endl;\r\n        }\r\n\r\n        cout << \"-----------------------------\" << endl;\r\n    }\r\n\r\n    int getStartingDay()\r\n    {\r\n        // Zeller's Congruence algorithm for days of week\r\n        int h = (1 + getMonthCode() + getYearCode() + getCenturyCode()) % 7;\r\n        return (h == 0) ? 6 : h - 1; // Convert 0 (Saturday) to 6\r\n    }\r\n\r\n    int getMonthCode()\r\n    {\r\n        //Retrun values from getMonthCode \r\n        static int monthCodes[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5};\r\n        return monthCodes[month - 1];\r\n    }\r\n\r\n    int getYearCode()\r\n    {\r\n        int yearCode = year % 100;\r\n        return (yearCode + yearCode / 4) % 7;\r\n    }\r\n\r\n    int getCenturyCode()\r\n    {\r\n        static int centuryCodes[] = {0, 6, 4, 2};\r\n        int century = year / 100;\r\n        return centuryCodes[century % 4];\r\n    }\r\n\r\n    string getMonthName()\r\n    {\r\n        static string monthNames[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\r\n                                      \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n                                     };\r\n        return monthNames[month - 1];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    int year, month;\r\n    cout << \"Enter year : \";\r\n    cin >> year;\r\n    cout << \"month : \";\r\n    cin >> month;\r\n\r\n    Calendar cal(year, month);\r\n    cal.displayCalendar();\r\n\r\n\u00a0\u00a0\u00a0\u00a0return\u00a00;\r\n}\r\n",
    "#include <stdlib.h>\n\nusing namespace std;\n\n#include \"../movables/Player.hpp\"\n#include \"Map.hpp\"\n#include \"../Env.hpp\"\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#define ROCK_IMG_PATH \"../res/rock_ground.png\"\n#define LIGHT_GRASS_IMG_PATH \"../res/light_grass.png\"\n#define DARK_GRASS_IMG_PATH \"../res/dark_grass.png\"\n#define LIGHT_GRASS_S_IMG_PATH \"../res/light_grassSouth.png\"\n#define LIGHT_GRASS_N_IMG_PATH \"../res/light_grassNorth.png\"\n#define MAP_FILE_PATH \"../res/map.txt\"\n\nMap::Map(Env* env) {\n\tthis->env = env;\n\tload_game();\n\tsave_texture(ROCK_IMG_PATH, Rock);\n\tsave_texture(LIGHT_GRASS_IMG_PATH, LightGrass);\n\tsave_texture(LIGHT_GRASS_S_IMG_PATH, LightGrassSouth);\n\tsave_texture(LIGHT_GRASS_N_IMG_PATH, LightGrassNorth);\n}\n\nMap::~Map() {\n\tfor (auto &text: ground_textures) SDL_DestroyTexture(text);\n}\n\nvoid Map::save_texture(const char* path, int index) {\n\tground_textures[index] =  (SDL_Texture*) cp(IMG_LoadTexture(env->get_ren(), path));\n}\n\nvoid Map::draw_square(int x, int y, int i, int j) {\n\tSDL_Rect r = {.x=x, .y=y, .w=PIXEL_TILE_SIZE, .h=PIXEL_TILE_SIZE};\n\tcc(SDL_RenderCopy(env->get_ren(), ground_textures[map[i][j]], NULL, &r));\n}\n\nvoid Map::draw() {\n\tint p = PIXEL_TILE_SIZE;\n\tSDL_Point* pos = env->get_player()->get_pos();\n\tint player_x = pos->x/p, \n\t\tplayer_y = pos->y/p;\n\tint mx = pos->x%p - p/2,\n\t\tmy = pos->y%p - p/2;\n\tint x=0, y=0;\n\tint width = env->win_width(), height = env->win_height();\n\tfor (int il=width/2-mx - p, ir = width/2-mx - p; (il+p) > 0 || (ir-p) < width; il-=p, ir+=p){\n\t\tfor (int jl=height/2-my - p, jr=height/2-my - p; (jl+p) > 0 || (jr-p) < height; jl-=p, jr+=p) {\n\t\t\tdraw_square(il, jl, player_x-x, player_y-y);\n\t\t\tdraw_square(ir, jr, player_x+x, player_y+y);\n\t\t\tdraw_square(il, jr, player_x-x, player_y+y);\n\t\t\tdraw_square(ir, jl, player_x+x, player_y-y);\n\t\t\ty += 1;\n\t\t}\n\t\ty = 0;\n\t\tx += 1;\n\t}\n }\n\nvoid Map::load_game() {\n\tint i = 0, j = 0;\n\tifstream f(MAP_FILE_PATH);\n    char c;\n    while(f.good()) {\n\t\tf.get(c);\n\t\tif (c == 10) {\n\t\t\ti += 1;\n\t\t\tj = 0;\n\t\t} else {\n\t\t\tif (c == 'L') \t   map[j][i] = LightGrass;\n\t\t\telse if (c == 'R') map[j][i] = Rock;\n\t\t\telse if (c == 'S') map[j][i] = LightGrassSouth;\n\t\t\telse if (c == 'N') map[j][i] = LightGrassNorth;\n\t\t\tj += 1;\n\t\t} \n    }\n    f.close();\n}\n",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"sensor_msgs/msg/laser_scan.hpp\"\n#include \"geometry_msgs/msg/twist.hpp\"\n\nclass Patrol : public rclcpp::Node {\npublic:\n    Patrol() : Node(\"robot_patrol\"), direction_(0) {\n        callback_group_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n        // Initialize the publisher for the robot's velocity\n        velocity_publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(\"/cmd_vel\", 10);\n\n        // Initialize the subscriber for the laser scan data\n        rclcpp::QoS qos(10);\n        rclcpp::SubscriptionOptions options;\n        options.callback_group = callback_group_;\n\n    \n        laser_subscriber_ = this->create_subscription<sensor_msgs::msg::LaserScan>(\n            \"/scan\", qos, std::bind(&Patrol::laserCallback, this, std::placeholders::_1), options);\n\n        // Start the control loop timer\n        timer_ = this->create_wall_timer(\n            std::chrono::milliseconds(100), std::bind(&Patrol::controlLoop, this),callback_group_);\n    }\n\nprivate:\n    sensor_msgs::msg::LaserScan::SharedPtr latest_scan_;\n    bool has_new_scan_ = false;\n    double direction_;\n\n    void laserCallback(const sensor_msgs::msg::LaserScan::SharedPtr msg) {\n        RCLCPP_INFO(this->get_logger(), \"laserCallback called.\");\n        auto start = std::chrono::high_resolution_clock::now();\n\n    if (msg == nullptr || msg->ranges.empty()) {\n        RCLCPP_WARN(this->get_logger(), \"Invalid laser scan data received.\");\n        return;\n    }\n\n    latest_scan_ = msg;\n    has_new_scan_ = true;\n\n    auto end = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n\n    float closest_obstacle_distance = std::numeric_limits<float>::max();\n\n    for (float distance : msg->ranges) {\n        if (distance >= msg->range_min && distance <= msg->range_max) {\n            closest_obstacle_distance = std::min(closest_obstacle_distance, distance);\n        }\n    }\n\n    int front_readings_count = static_cast<int>((msg->angle_max - msg->angle_min) / msg->angle_increment) + 3;\n\n    int max_index = -1;\n    float max_distance = 0.0;\n\n    // Iterate through the front 180-degree readings to find the largest distance\n    for (int i = 0; i < front_readings_count; ++i) {\n        float distance = msg->ranges[i];\n        if (distance >= msg->range_min && distance <= msg->range_max && distance > max_distance) {\n            max_distance = distance;\n            max_index = i;\n        }\n    }\n\n    // Determine the direction to move\n    if (max_index!= -1) {\n        direction_ = msg->angle_min + max_index * msg->angle_increment;\n        RCLCPP_INFO(this->get_logger(), \"Obstacle detected. Index: %d, Distance: %.2f m, Direction angle: %.2f radians\", max_index, max_distance, direction_);\n    } else {\n        direction_ = 0.0;\n        RCLCPP_INFO(this->get_logger(), \"No obstacles detected. Moving straight.\");\n    }\n}\n\n    void controlLoop() {\n    if (!has_new_scan_ || latest_scan_ == nullptr) {\n        RCLCPP_WARN(this->get_logger(), \"No new scan data.\");\n        return;\n    }\n\n    geometry_msgs::msg::Twist cmd_vel_msg;\n    float linear_speed = 0.1;\n    float safety_distance = 0.5; // 33 cm\n\n      float closest_obstacle_distance = *std::min_element(latest_scan_->ranges.begin(), latest_scan_->ranges.end());\n        RCLCPP_DEBUG(this->get_logger(), \"Closest obstacle distance: %.2f m\", closest_obstacle_distance);\n\n        if (latest_scan_->ranges.empty()) {\n        RCLCPP_WARN(this->get_logger(), \"Scan data is empty.\");\n        return;\n    }\n\n    if (closest_obstacle_distance < safety_distance) {\n        // Move in a safe direction\n        float safe_direction_angle = direction_ + (M_PI / 2); // turn 90 degrees to the right\n        if (safe_direction_angle > M_PI) {\n            safe_direction_angle -= 2 * M_PI;\n        }\n        cmd_vel_msg.linear.x = 0.1; // Move slowly\n        cmd_vel_msg.angular.z = safe_direction_angle; // Turn towards the safe direction\n\n        RCLCPP_INFO(this->get_logger(), \"Obstacle too close. Moving in a safe direction with linear velocity: %.2f and angular velocity: %.2f\", cmd_vel_msg.linear.x, cmd_vel_msg.angular.z);\n    } else {\n        cmd_vel_msg.linear.x = linear_speed;\n        cmd_vel_msg.angular.z = 0.0; // Go straight\n\n        RCLCPP_INFO(this->get_logger(), \"Path is clear. Moving straight with linear velocity: %.2f\", linear_speed);\n    }\n\n    velocity_publisher_->publish(cmd_vel_msg);\n    has_new_scan_ = false; // Reset the flag\n}\n\n    rclcpp::CallbackGroup::SharedPtr callback_group_;\n    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr velocity_publisher_;\n    rclcpp::Subscription<sensor_msgs::msg::LaserScan>::SharedPtr laser_subscriber_;\n    rclcpp::TimerBase::SharedPtr timer_;\n};\n\nint main(int argc, char **argv) {\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<Patrol>();\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}\n\n\n",
    "#include \"mac.h\"\n\nMac::Mac(const std::string& r) {\n\tstd::string s;\n\tfor(char ch: r) {\n\t\tif ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f'))\n\t\t\ts += ch;\n\t}\n\tint res = sscanf(s.c_str(), \"%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\", &mac_[0], &mac_[1], &mac_[2], &mac_[3], &mac_[4], &mac_[5]);\n\tif (res != SIZE) {\n\t\tfprintf(stderr, \"Mac::Mac sscanf return %d r=%s\\n\", res, r.c_str());\n\t\treturn;\n\t}\n}\n\nMac::operator std::string() const {\n\tchar buf[20]; // enough size\n\tsprintf(buf, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac_[0], mac_[1], mac_[2], mac_[3], mac_[4], mac_[5]);\n\treturn std::string(buf);\n}\n\nMac Mac::randomMac() {\n\tMac res;\n\tfor (int i = 0; i < SIZE; i++)\n\t\tres.mac_[i] = uint8_t(rand() % 256);\n\tres.mac_[0] &= 0x7F;\n\treturn res;\n}\n\nMac& Mac::nullMac() {\n\tstatic uint8_t _value[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic Mac res(_value);\n\treturn res;\n}\n\nMac& Mac::broadcastMac() {\n\tstatic uint8_t _value[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tstatic Mac res(_value);\n\treturn res;\n}\n\n// ----------------------------------------------------------------------------\n// GTEST\n// ----------------------------------------------------------------------------\n#ifdef GTEST\n#include <gtest/gtest.h>\n\nstatic constexpr uint8_t _temp[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};\n\nTEST(Mac, ctorTest) {\n\tMac mac1; // ()\n\n\tMac mac2{mac1}; // (const Mac& r)\n\n\tMac mac3(_temp); // (const uint8_t* r)\n\n\tMac mac4(std::string(\"001122-334455\")); // (const std::string& r)\n\tEXPECT_EQ(mac3, mac4);\n\n\tMac mac5(\"001122-334455\"); // (const std::string& r)\n\tEXPECT_EQ(mac3, mac5);\n}\n\nTEST(Mac, castingTest) {\n\tMac mac(\"001122-334455\");\n\n\tconst uint8_t* uc = (uint8_t*)mac; // operator uint8_t*()\n\tuint8_t temp[Mac::SIZE];\n\tfor (int i = 0; i < Mac::SIZE; i++)\n\t\ttemp[i] = *uc++;\n\tEXPECT_TRUE(memcmp(&mac, temp, 6) == 0);\n\n\tstd::string s2 = std::string(mac); // operator std::string()\n\tEXPECT_EQ(s2, \"00:11:22:33:44:55\");\n}\n\nTEST(Mac, funcTest) {\n\tMac mac;\n\n\tmac.clear();\n\tEXPECT_TRUE(mac.isNull());\n\n\tmac = std::string(\"FF:FF:FF:FF:FF:FF\");\n\tEXPECT_TRUE(mac.isBroadcast());\n\n\tmac = std::string(\"01:00:5E:00:11:22\");\n\tEXPECT_TRUE(mac.isMulticast());\n}\n\n#include <map>\nTEST(Mac, mapTest) {\n\ttypedef std::map<Mac, int> MacMap;\n\tMacMap m;\n\tm.insert(std::make_pair(Mac(\"001122-334455\"), 1));\n\tm.insert(std::make_pair(Mac(\"001122-334456\"), 2));\n\tm.insert(std::make_pair(Mac(\"001122-334457\"), 3));\n\tEXPECT_EQ(m.size(), 3);\n\tMacMap::iterator it = m.begin();\n\tEXPECT_EQ(it->second, 1); it++;\n\tEXPECT_EQ(it->second, 2); it++;\n\tEXPECT_EQ(it->second, 3);\n}\n\n#include <unordered_map>\nTEST(Mac, unordered_mapTest) {\n\ttypedef std::unordered_map<Mac, int> MacUnorderedMap;\n\tMacUnorderedMap m;\n\tm.insert(std::make_pair(Mac(\"001122-334455\"), 1));\n\tm.insert(std::make_pair(Mac(\"001122-334456\"), 2));\n\tm.insert(std::make_pair(Mac(\"001122-334457\"), 3));\n\t//EXPECT_EQ(m.size(), 3);\n}\n\n#endif // GTEST\n",
    "#include \"serial/serial.h\"\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"sensor_msgs/msg/joint_state.hpp\"\n\nserial::Serial _serial;\t\t\t\t// serial object\n\nclass MirobotWriteNode : public rclcpp::Node\n{\npublic:\n    MirobotWriteNode()\n        : Node(\"mirobot_write_node\")\n    {\n        js_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(\n            \"joint_states\", 10, std::bind(&MirobotWriteNode::joint_state_callback, this, std::placeholders::_1));\n\n        //TODO: home position reset\n\n    }\n\nprivate:\n    void joint_state_callback(const sensor_msgs::msg::JointState::SharedPtr msg)\n    {\n        std::string Gcode = \"\";\n        char angle0[10];\n        char angle1[10];\n        char angle2[10];\n        char angle3[10];\n        char angle4[10];\n        char angle5[10];\n\n        sprintf(angle0, \"%.2f\", msg->position[0]*57.296);\n        sprintf(angle1, \"%.2f\", msg->position[1]*57.296);\n        sprintf(angle2, \"%.2f\", msg->position[2]*57.296);\n        sprintf(angle3, \"%.2f\", msg->position[3]*57.296);\n        sprintf(angle4, \"%.2f\", msg->position[4]*57.296);\n        sprintf(angle5, \"%.2f\", msg->position[5]*57.296);\n        Gcode = (std::string)\"M50 G0 X\" + angle0 + \" Y\" + angle1 + \" Z\" + angle2 + \" A\" + angle3 + \"B\" + angle4 + \"C\" + angle5 + \" F3000\" + \"\\r\\n\";\n        \n        RCLCPP_INFO(this->get_logger(), \"%s\", Gcode.c_str());\n\n        _serial.write(Gcode.c_str());\n        result.data = _serial.read(_serial.available());\n    }\n\n    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr js_sub_;\n    std_msgs::msg::String result;\n};\n\nint main(int argc, char** argv)\n{\n    rclcpp::init(argc, argv);\n\n    auto mirobot_gcode_write_node = std::make_shared<MirobotWriteNode>();\n    \n    mirobot_gcode_write_node->declare_parameter(\"port_name\", \"/dev/ttyUSB0\");\n    mirobot_gcode_write_node->declare_parameter(\"baud_rate\", 115200);\n\n    auto port_name = mirobot_gcode_write_node->get_parameter(\"port_name\").as_string();\n    auto baud_rate = mirobot_gcode_write_node->get_parameter(\"baud_rate\").as_int();\n\n\ttry{\n        //TODO: port name into launch param\n\t\t_serial.setPort(port_name);\n\t\t_serial.setBaudrate(baud_rate);\n\n\t\tserial::Timeout to = serial::Timeout::simpleTimeout(1000);\n\t\t\n        _serial.setTimeout(to);\n\t\t_serial.open();\n\t\t_serial.write(\"M50\\r\\n\");\n\t\t\n        RCLCPP_INFO(mirobot_gcode_write_node->get_logger(), \"Port has been open successfully\");\n\t}\n\tcatch (serial::IOException& e){\n        RCLCPP_FATAL(mirobot_gcode_write_node->get_logger(), \"Unable to open port\");\n\t\treturn -1;\n\t}\n\n\tif (_serial.isOpen()){\n        using namespace std::chrono_literals;\n        rclcpp::sleep_for(1s);\n        RCLCPP_INFO(mirobot_gcode_write_node->get_logger(), \"Attach and wait for commands\");\n\t}\n\n    rclcpp::spin(mirobot_gcode_write_node);\n    rclcpp::shutdown();\n    \n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"tree.h\"\n\nint main() {\n\tMySet tree;\n\ttree.insert(40);\n\ttree.insert(10);\n\ttree.insert(57);\n\ttree.insert(14);\n\ttree.insert(45);\n\ttree.insert(80);\n\ttree.insert(9);\n\ttree.insert(16);\n\ttree.insert(47);\n\ttree.insert(84);\n\n\ttree.print();\n\n\ttree.erase(50);\n\ttree.print();\n\n\ttree.erase(57);\n\ttree.print();\n\n\tcout << tree.contains(30);\n\tcout << tree.contains(57);\n\tcout << tree.contains(14);\n\tcout << tree.contains(50);\n\tcout << tree.contains(45);\n\tcout << tree.contains(9);\n\tcout << endl;\n\n\tcout << \"Tree:\" << endl;\n\ttree.print();\n\tMySet tree2(tree);\n\tcout << \"Copy of Tree:\" << endl;\n\ttree2.print();\n\n\tMySet tree3;\n\ttree3.insert(8);\n\ttree3.insert(2);\n\ttree3.insert(9);\n\tcout << \"Third Tree:\" << endl;\n\ttree3.print();\n\n\ttree3 = tree;\n\n\tcout << \"Third Tree after assignment:\" << endl;\n\ttree3.print();\n\n\tMySet tree4;\n\ttree4.insert(5);\n\ttree4.insert(7);\n\ttree4.insert(2);\n\ttree4.insert(8);\n\ttree4.insert(9);\n\ttree4.insert(6);\n\ttree4.insert(1);\n\tcout << \"Tree:\" << endl;\n\ttree4.print();\n\n\tMySet tree5;\n\ttree5.insert(6);\n\ttree5.insert(5);\n\ttree5.insert(9);\n\ttree5.insert(2);\n\ttree5.insert(3);\n\ttree5.insert(4);\n\tcout << \"Second Tree:\" << endl;\n\ttree5.print();\n\n\tcout << \"Difference (tree - second tree):\" << endl;\n\tdifference(tree4, tree5).print();\n\tcout << endl << \"Difference (second tree - tree):\" << endl;\n\tdifference(tree5, tree4).print();\n\tcout << endl << \"Intersection:\" << endl;\n\tintersection(tree4, tree5).print();\n}",
    "/************************************************************\n * Group        : 06                                        *\n * Group Members: LAI KAI CHIAN        A21EC0041            *\n *              : GAN QI YOU           A21EC0178            *\n *              : KRISTY YAP JING WEI  A21EC0191            *\n * Assignment 3 : Nohara Shiro (Crayon Shin-Chan)           *\n ************************************************************/\n\n#include <stdlib.h>\n#include <GL/glut.h> // Include the GLUT header file \n#include <math.h>\n#include <Windows.h>\n#include <string.h>\n#include <iostream>\n#include\"imageloader.h\"\n#include\"imageloader.cpp\"\n\nusing namespace std;\n#define PI 3.1415927\n#define WINDOW_WIDTH 1000\n#define WINDOW_HEIGHT 900\n\n// angle of rotation for the camera direction\nfloat angle = 0.0, yAngle = 0.0;\n// actual vector representing the camera's direction\nfloat lx = 0.0f, ly = 0.0f, lz = -1.0f;\n// XZ position of the camera\nfloat x = -3.0f, z = 75.0f;\nfloat roll = 0.0f;\n\n//conditions to limit the rotation of model\nbool stillCanRaiseLeft = true;\nbool stillCanRaiseRight = true;\nbool stillCanWalkForward = true;\nbool stillCanWalkBackward = true;\nbool rotateHead = true;\nbool rotateTail = true;\nbool displayT = true;\nbool rotateX = true;\n\n\n//for mouse movements\nfloat halfWidth = (float)(WINDOW_WIDTH / 2.0);\nfloat halfHeight = (float)(WINDOW_HEIGHT / 2.0);\nfloat mouseX = 0.0f, mouseY = 0.0f;\n\n//variables\nstatic int forwardlegCount = 0, backwardlegCount = 0;\nstatic int stepsForward = 0, stepsBackward = 0;\nfloat rotate1 = 0.0f;\nfloat rotate2 = 0.0f;\nfloat _increment = 1.5f;\nstatic float headPos = 0.0f, headLeft = 0.0f, headRight = 0.0f;\nstatic float leftEar = 0.0f, rightEar = 0.0f;\nstatic float body = 0.0f, tail = 0.0f, tailRotate = 0.0f;\nstatic float moveBodyForward = 0.0f, moveBodyBackward = 0.0f;\nstatic float moveLeftForward = 0.0f, moveRightForward = 0.0f;\nstatic float moveLeftBackward = 0.0f, moveRightBackward = 0.0f;\nstatic float frontLeft = 0.0f, frontRight = 0.0f, backLeft = 0.0f;\nstatic float backRight = 0.0f, frRightRotate = 0.0f, frLeftRotate = 0.0f;\nstatic float leftLegsAngle = 90, rightLegsAngle = 90, rotateFull = 0.0f;\nstatic float headAngle = 0.0f, rightEarAngle = 0.0f, leftEarAngle = 0.0f;\n\nGLuint loadTexture(Image* image)\n{\n\tGLuint textureId;\n\tglGenTextures(1, &textureId);\n\tglBindTexture(GL_TEXTURE_2D, textureId);\n\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image->width, image->height, 0, GL_RGB, GL_UNSIGNED_BYTE, image->pixels);\n\treturn textureId;\n}\n\nGLuint _textureId1;\nGLuint _textureId2;\nGLuint _textureId3;\nGLuint _textureId4;\nGLuint _textureId5;\nGLuint _textureId6;\n\n\nvoid init()\n{\n\tglClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set background color to black and opaque\n\tglMatrixMode(GL_PROJECTION);\n\tgluOrtho2D(0.0, 1600.0, 0.0, 800.0);\n\tglEnable(GL_NORMALIZE);\n\tglEnable(GL_COLOR_MATERIAL);\n\tglEnable(GL_LIGHTING);\n\tglEnable(GL_LIGHT0);\n\tglEnable(GL_LIGHT1);\n\tglEnable(GL_DEPTH_TEST);   // Enable depth testing for z-culling\n\tglDepthFunc(GL_LEQUAL);    // Set the type of depth-test\n\tglShadeModel(GL_SMOOTH);   // Enable smooth shading\n\n\tImage* image1 = loadBMP(\"C:\\\\zmisc\\\\picture1.bmp\");\n\t_textureId1 = loadTexture(image1);\n\tdelete image1;\n\n\tImage* image2 = loadBMP(\"C:\\\\zmisc\\\\picture_2.bmp\");\n\t_textureId2 = loadTexture(image2);\n\tdelete image2;\n\n\tImage* image3 = loadBMP(\"C:\\\\zmisc\\\\picture_3.bmp\");\n\t_textureId3 = loadTexture(image3);\n\tdelete image3;\n\n\tImage* image4 = loadBMP(\"C:\\\\zmisc\\\\picture_4.bmp\");\n\t_textureId4 = loadTexture(image4);\n\tdelete image4;\n\n\tImage* image5 = loadBMP(\"C:\\\\zmisc\\\\picture_5.bmp\");\n\t_textureId5 = loadTexture(image5);\n\tdelete image5;\n\n\tImage* image6 = loadBMP(\"C:\\\\zmisc\\\\picture_6.bmp\");\n\t_textureId6 = loadTexture(image6);\n\tdelete image6;\n}\n\nvoid head()\n{\n\tglPushMatrix();\n\tglTranslatef(-1.1f, 1.5f, 0.0f);  \n\tglTranslatef(-1.1f, 1.5f, 0.0f);\n\tglRotatef(headLeft, 1.0f, 0.0f, 0.0f);\t\t//rotate left\n\tglRotatef(headRight, 1.0f, 0.0f, 0.0f);     //rotate right\n\tglTranslatef(1.1f, -1.5f, 0.0f);\n\n\t\t//head\n\t\tglPushMatrix();\n\t\t\tglColor3f(1.0f, 1.0f, 1.0f);\n\t\t\tglTranslatef(-1.0f, 3.0f, 0.0f);\n\t\t\tglScalef(3.5f, 5.0f, 9.0f);\n\t\t\tglutSolidSphere(0.25, 100, 100);\n\t\tglPopMatrix();\n\n\t\t//ring on neck\n\t\tglPushMatrix();\n\t\t\tglColor3f(0.3f, 0.4f, 1.0f);\n\t\t\tglTranslatef(-1.8f, 2.2f, 0.0f);\n\t\t\tglRotatef(90, 0.0f, 1.0f, 0.0f);\n\t\t\tglRotatef(-30, 1.0f, 0.0f, 0.0f);\n\t\t\tglScalef(2.8f, 1.68f, 1.0f);\n\t\t\tGLUquadric* quadric = gluNewQuadric();\n\t\t\tgluQuadricDrawStyle(quadric, GLU_FILL);\n\t\t\tgluCylinder(quadric, 0.3, 0.3, 0.2, 50, 50);\n\t\tglPopMatrix();\n\n\t\t//right eye brow\n\t\tglColor3f(0.0f, 0.0f, 0.0f);\n\t\tglPushMatrix();\n\t\t\tglTranslatef(-0.3f, 3.2f, 1.3f);\n\t\t\tglRotatef(75, 0.0f, 1.0f, 0.0f);\n\t\t\tglScalef(9.5f, 9.5f, 9.5f);\n\t\t\tgluPartialDisk(gluNewQuadric(), 0.0475f, 0.052f, 10, 30, 270, 180);\n\t\tglPopMatrix();\n\n\t\t//right eye\n\t\tglPushMatrix();\n\t\t\tglColor3f(0.0f, 0.0f, 0.0f);\n\t\t\tglTranslatef(-0.3f, 3.0f, 1.3f);\n\t\t\tglScalef(1.5f, 1.5f, 1.5f);\n\t\t\tglutSolidSphere(0.11, 100, 100);\n\t\tglPopMatrix();\n\n\t\t//left eye brow\n\t\tglColor3f(0.0f, ",
    "#include \"Scene.h\"\n\nModelComponent &Scene::createModelComponent(std::string modelFilename, std::string textureFilename)\n{\n    ModelComponent *model = new ModelComponent();\n    model->model.createFromFile(modelFilename);\n    model->textureId = Texture2D::createTexture(textureFilename);\n\n    renderables.push_back(model);\n\n    return *model;\n}\n\nvoid Scene::render(Camera &camera, Shader &shader)\n{\n    shader.setUniform(\"viewProjectionMatrix\", camera.getProjectionViewMatrix());\n    for (const auto &renderable : renderables)\n    {\n        shader.setUniform(\"modelMatrix\", renderable->getTransform());\n        renderable->setShaderMaterialParams(shader);\n        renderable->render();\n    }\n}\n\nvoid Scene::renderDepth(Camera &camera, Shader &shader)\n{\n    // glEnable(GL_CULL_FACE);\n    // glCullFace(GL_FRONT);\n\n    shader.setUniform(\"viewProjectionMatrix\", camera.getProjectionViewMatrix());\n    for (const auto &renderable : renderables)\n    {\n        shader.setUniform(\"modelMatrix\", renderable->getTransform());\n        renderable->render();\n    }\n\n    glCullFace(GL_BACK);\n}\n\nvoid Scene::renderWithTransform(Shader &shader)\n{\n    for (const auto &renderable : renderables)\n    {\n        shader.setUniform(\"modelMatrix\", renderable->getTransform());\n        renderable->render();\n    }\n}\n\nLight *Scene::createPointLight(glm::vec3 pos, glm::vec3 color, float falloff, float intensity)\n{\n    Light *light = new Light();\n\n    light->type = Light::POINT;\n    light->position = pos;\n    light->color = color;\n    light->distAttenMin = 0;\n    light->distAttenMax = falloff;\n    light->intensity = intensity;\n    light->doesCastShadows = false;\n\n    lights.push_back(light);\n\n    return light;\n}\n\nLight *Scene::createDirectLight(glm::vec3 pos, glm::vec3 direction, glm::vec3 color, float beamAngle, float falloff, float intensity)\n{\n    Light *light = new Light();\n\n    light->type = Light::SPOT;\n    light->position = pos;\n    light->direction = glm::normalize(direction);\n    light->color = color;\n    light->distAttenMin = 0;\n    light->distAttenMax = falloff;\n    light->intensity = intensity;\n    light->beamAngle = beamAngle; //(beamAngle * (M_PI / 180)) / 2.0;\n    light->doesCastShadows = false;\n\n    lights.push_back(light);\n\n    return light;\n}",
    "#include<iostream>\n#include<cstdlib>\nusing namespace std;\n\nvoid intro()\n{\n    cout<<\"\\t\\t\\t\\t\\t**********TRAVEL MANAGEMENT SYSTEM**********\"<<endl;\n    //Additional Code\n}\n \nclass Hotel  //HOTEL GENERALISED CLASS\n{\n    public:\n    string name;\n    string location;\n    int numberRooms;\n    int roomAvailable;\n    \n    public:\n    Hotel(string name = \"HOTEL\" , string location = \"AREA 51\" , int numberRooms = 404 , int roomAvailable = 121)\n    {\n       this->name=name;\n       this->location=location;\n       this->numberRooms=numberRooms;\n       this->roomAvailable=roomAvailable;\n    }\n    //void display();   \n    void mainMenu(); \n    // void rooms(); \n    // void add(); \n    // void edit(); \n    // ~ Hotel() {}\n};\n\nvoid Hotel::mainMenu()\n{\n    system(\"clear\");\n    cout<<\"\\t\\t\\t\\t\\t********** M E N U **********\"<<endl;\n    cout<<\"\\t\\t\\t\\t\\t1. BOOK A ROOM\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t2. CUSTOMER RECORD\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t3. ROOM ALLOTED\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t4. EDIT RECORD\\t\\t\\t\\t\\t\\n\";\n    cout<<\"\\t\\t\\t\\t\\t5. EXIT\\t\\t\\t\\t\\t\\n\";\n\n}\n\nint main()\n{\n    intro();\n    cin.get();\n    Hotel hotel;\n    hotel.mainMenu();\n    //ex\n\n    return 0;\n}",
    "#pragma once\n#include \"Admin.h\"\n\n\n\nAdmin::Admin()\n{\n\tusername = \"admin\";\n\tpassword = \"admin\";\n}\n\nAdmin::Admin(string name, string pass)\n{\n\tusername = name;\n\tpassword = pass;\n}\n\n\nvoid Admin::set_username(string new_name)\n{\n\tusername = new_name;\n}\n\nstring Admin::get_username()\n{\n\treturn this->username;\n}\n\nvoid Admin::set_password(string new_pass)\n{\n\tpassword = new_pass;\n}\n\nstring Admin::get_password()\n{\n\treturn this->password;\n}\n\n\n\nvoid Admin::view_Accounts_Data()\n{\n\tmap<string, User>::iterator it;\n\n\tfor (it = System::allUsers.begin(); it != System::allUsers.end(); it++)\n\t{\n\t\tit->second.userData();\n\t}\n}\n\nvoid Admin::edit_username()\n{\n\tstring name, new_name;\n\tcout << \"Please Enter The Username of the User to Edit His Username :\\t\";\n\tcin >> name;\n\n\t//check the name fun\n\n\tcout << \"Please Enter The New Username :\\t\";\n\tcin >> new_name;\n\t//check the new name is valid\n\n\tSystem::allUsers[name].setUserName(new_name);\n\tcout << \"The Username Has Been Changed Successuflly \\n\";\n\tcout << \"The new Username of The User is :\\t\" << new_name << \"\\n\";\n}\n\nvoid Admin::edit_password()\n{\n\tstring name, new_pass;\n\tcout << \"Please Enter The Username of the User to Edit His Password :\\t\";\n\tcin >> name;\n\n\t//check the name fun\n\n\tcout << \"Please Enter The New Password :\\t\";\n\tcin >> new_pass;\n\t//check the new pass is valid\n\n\tSystem::allUsers[name].setpassword(new_pass);\n\tcout << \"The Password Has Been Changed Successuflly \\n\";\n\tcout << \"The new Password of The User is :\\t\" << new_pass << \"\\n\";\n}\n\nvoid Admin::add_user()\n{\n\tstring username;\n\n\tcout << \"Please Enter The Username of The User :\\t\";\n\n\tcin >> username;\n\n\t\n\t\tcout << \"Please Enter The Username of The User :\\n\";\n\t\tstring password;\n\t\tcin >> password;\n\t\tdouble balance;\n\t\tcout << \"Please Enter The Username of The User :\\n\";\n\t\tcin >> balance;\n\t\tSystem::Register(username, password, balance);\n}\n\nvoid Admin::delete_user()\n{\n\tstring name;\n\n\tcout << \"Please Enter The Username of the User You Want to Delete :\\t\";\n\n\tcin >> name;\n\t//check the username func\n\tSystem::allUsers.erase(name);\n\tcout << \"The User Has Been Deleted Successfully\\n\";\n}\n\nvoid Admin::suspend_user()\n{\n\tstring name;\n\n\tcout << \"Please Enter The Username of the User You Want to Suspend :\\t\";\n\n\tcin >> name;\n\t//check the username func\n\n\tsuspended_users[name] = System::allUsers[name];\n\n\tcout << \"The User Has Been Suspended Successfully\\n\";\n\n}\n\nvoid Admin::reactivated()\n{\n\tstring name;\n\n\tcout << \"Please Enter The Username of The User You Want to Reactivate :\\t\";\n\n\tcin >> name;\n\t//check the username func\n\t//check if its suspended\n\tsuspended_users.erase(name);\n\tcout << \"The User Has Been Reactivated Successfully\\n\";\n}\n\nvoid Admin::view_all_transactions()\n{\n\tvector<Transaction>::iterator it;\n\n\tit = System::allTransactions.begin();\n\n\n\twhile (it != System::allTransactions.end())\n\t{\n\t\tit->getCurrentDateTime();\n\t}\n\n}\n\nvoid Admin::edit_balance()\n{\n\tstring name;\n\tdouble new_balance;\n\tcout << \"Please Enter The Username of The User You Want to Edit His Balance :\\t\";\n\n\tcin >> name;\n\n\tcout << \"Please Enter The Nem Balance :\\t\";\n\t//check the username func\n\tcin >> new_balance;\n\n\tSystem::allUsers[name].setbalance(new_balance);\n\n\tcout << \"The User Balance Has Been Modified \\n\";\n\n}\n\n\n\nAdmin::~Admin(void)\n{\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include <ctime>\n#include <map>\n#include <cctype>\n\nclass Card {\npublic:\n    int value;\n    char suit;\n    Card(char s, int v) : suit(s), value(v) {}\n    int getValue() const {\n        if (value == 1) return 11;\n        if (value >= 10) return 10;\n        return value;\n    }\n};\n\nclass Deck {\npublic:\n    std::vector<Card> cards;\n    Deck() {\n        const char suits[] = { 'H', 'D', 'C', 'S' };\n        for (char s : suits) {\n            for (int v = 1; v <= 13; v++) {\n                cards.emplace_back(s, v);\n            }\n        }\n    }\n};\n\nclass Shoe {\nprivate:\n    std::vector<Card> cards;\n    int deckCount;\n\npublic:\n    explicit Shoe(int count) : deckCount(count) {\n        for (int i = 0; i < deckCount; ++i) {\n            Deck deck;\n            cards.insert(cards.end(), deck.cards.begin(), deck.cards.end());\n        }\n        shuffle();\n    }\n\n    void shuffle() {\n        cards.clear();\n\n        for (int i = 0; i < deckCount; ++i) {\n            Deck deck;\n            cards.insert(cards.end(), deck.cards.begin(), deck.cards.end());\n        }\n\n        std::random_device rd;\n        std::mt19937 g(rd());\n        std::shuffle(cards.begin(), cards.end(), g);\n\n        std::cout << \"Shoe reshuffled with new cards. Total cards: \" << cards.size() << std::endl;\n    }\n\n    Card draw() {\n        if (cards.empty()) {\n            std::cerr << \"Cannot draw from an empty shoe.\" << std::endl;\n\n            return Card('H', 1);\n        }\n\n        Card card = cards.back();\n        cards.pop_back();\n\n        if (cards.size() <= 100) {\n            std::cout << \"Card count after draw is \" << cards.size() << \". Reshuffling...\" << std::endl;\n            shuffle();\n        }\n\n        return card;\n    }\n\n\n\n    ~Shoe() {\n        std::cout << \"Shoe destroyed. Remaining cards: \" << cards.size() << std::endl;\n    }\n};\n\nint calculateTotal(const std::vector<Card>& cards) {\n    int total = 0;\n    int aceCount = 0;\n    for (const Card& card : cards) {\n        int cardValue = card.getValue();\n        total += cardValue;\n        if (cardValue == 11) aceCount++;\n    }\n    while (total > 21 && aceCount > 0) {\n        total -= 10;\n        aceCount--;\n    }\n    return total;\n}\n\nclass BlackjackGame {\nprivate:\n    Shoe shoe;\n    std::map<std::pair<int, int>, std::map<char, std::vector<int>>> results;\n\npublic:\n    explicit BlackjackGame() : shoe(6) {}\n\n    void playHand() {\n        std::vector<Card> playerCards = { shoe.draw(), shoe.draw() };\n        std::vector<Card> dealerCards = { shoe.draw(), shoe.draw() };\n\n        std::cout << \"Your cards: \" << playerCards[0].getValue() << \" and \" << playerCards[1].getValue() << std::endl;\n        std::cout << \"Dealer's face-up card: \" << dealerCards[0].getValue() << std::endl;\n\n        while (true) {\n            std::cout << \"Do you want to hit or stand? (h/s): \";\n            char decision;\n            std::cin >> decision;\n            decision = std::tolower(decision);\n            if (decision == 'h') {\n                playerCards.push_back(shoe.draw());\n                std::cout << \"You drew a \" << playerCards.back().getValue() << std::endl;\n                if (calculateTotal(playerCards) > 21) {\n                    std::cout << \"Bust! Your total is over 21.\\n\";\n                    return;\n                }\n            }\n            else if (decision == 's') {\n                break;\n            }\n            else {\n                std::cout << \"Invalid input, please enter 'h' or 's'.\\n\";\n                continue;\n            }\n        }\n\n        int playerTotal = calculateTotal(playerCards);\n        int dealerTotal = calculateTotal(dealerCards);\n\n        while (dealerTotal < 17) {\n            dealerCards.push_back(shoe.draw());\n            dealerTotal = calculateTotal(dealerCards);\n        }\n\n        std::cout << \"Dealer's total is \" << dealerTotal << std::endl;\n\n        if (playerTotal > 21 || (dealerTotal <= 21 && dealerTotal > playerTotal)) {\n            std::cout << \"You lose.\\n\";\n        }\n        else if (playerTotal == dealerTotal) {\n            std::cout << \"It's a draw.\\n\";\n        }\n        else {\n            std::cout << \"You win!\\n\";\n        }\n    }\n\n    void simulateStrategy() {\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::uniform_int_distribution<> dis(0, 1);\n\n        for (int i = 0; i < 100000; i++) {\n            std::vector<Card> playerCards = { shoe.draw(), shoe.draw() };\n            std::vector<Card> dealerCards = { shoe.draw() };\n\n            int initialPlayerTotal = calculateTotal(playerCards);\n            int initialDealerValue = dealerCards.front().getValue();\n\n            char decision = dis(gen) ? 'h' : 's';\n            if (decision == 'h') {\n                playerCards.push_back(shoe.draw());\n            }\n            int finalPlayerTotal = calculateTotal(playerCards);\n            dealerCards.push_back(shoe.draw());\n            while (calculateTotal(dealerCards) < 17) {\n      ",
    "/* TRAFFIC LIGHT SIMULATION\n   PROGRAMMED AND DESIGNED BY ADAM HAUGEN\n*/\n\n#include <simplecpp>\n\nint const MAX_CARS = 3;\nchar input;\nbool flag = true;\nint loopVal = 0;\n\n// Update variables to stagger cars\nint xPos = 350, yPos = 650;\n\n// Sets Traffic light to Green\nvoid greenLight(Circle &light, int x)\n{\n    light.setColor(COLOR(\"Green\"));\n    if (x == 0)\n        light.moveTo(300, 160);\n    else\n        light.moveTo(900, 760);\n}\n\n//Sets traffic light to Red\nvoid redLight(Circle &light, int x)\n{\n    light.setColor(COLOR(\"Red\"));\n    if (x == 0)\n        light.moveTo(300, 40);\n    else\n        light.moveTo(900, 640);\n}\n\n//sets traffic light to Yellow\nvoid yellowLight(Circle &light, int x)\n{\n    light.setColor(COLOR(\"Yellow\"));\n    if (x == 0)\n        light.moveTo(300, 100);\n    else\n        light.moveTo(900, 700);\n}\n\nmain_program\n{\n    //boolean value for calling yellow light\n    bool called = false;\n\n    //Create window\n    initCanvas(\"Traffic Light Sim\", 1000, 1000);\n\n    struct Car\n    {\n        Rectangle body;\n    };\n\n    //creates the intersection\n    Rectangle ewRoad(500, 500, 1000, 200);\n    ewRoad.setColor(COLOR(\"#8c8c8c\"));\n    ewRoad.setFill();\n    Rectangle nwRoad(500, 500, 200, 1000);\n    nwRoad.setColor(COLOR(\"#8c8c8c\"));\n    nwRoad.setFill();\n\n    Car carArrayNS[MAX_CARS];\n    Car carArrayEW[MAX_CARS];\n\n    // N/S Traffic Light\n    Rectangle r1(300, 100, 100, 200);\n    r1.setColor(COLOR(255, 204, 0));\n    r1.setFill();\n    Circle b1(300, 40, 26);\n    b1.setColor(COLOR(\"black\"));\n    b1.setFill();\n    Circle b2(300, 100, 26);\n    b2.setColor(COLOR(\"black\"));\n    b2.setFill();\n    Circle b3(300, 160, 26);\n    b3.setColor(COLOR(\"black\"));\n    b3.setFill();\n    Circle c1(300, 40, 25);\n    c1.setColor(COLOR(\"Red\"));\n    c1.setFill();\n\n    Text t1(300, 220, \"N/S Traffic Light\");\n\n    // E/W Traffic Light\n    Rectangle r2(900, 700, 100, 200);\n    Circle b4(900, 640, 26);\n    b4.setColor(COLOR(\"black\"));\n    b4.setFill();\n    Circle b5(900, 700, 26);\n    b5.setColor(COLOR(\"black\"));\n    b5.setFill();\n    Circle b6(900, 760, 26);\n    b6.setColor(COLOR(\"black\"));\n    b6.setFill();\n    r2.setColor(COLOR(255, 204, 0));\n    r2.setFill();\n    Circle c2(900, 640, 25);\n    c2.setColor(COLOR(\"Red\"));\n    c2.setFill();\n\n    Text t2(900, 820, \"E/W Traffic Light\");\n\n    //initialize and stagger NS cars\n    for (int i = 0; i < 3; i++)\n    {\n        carArrayNS[i].body = Rectangle(500, yPos, 50, 75);\n        carArrayNS[i].body.setColor(COLOR(\"blue\"));\n        carArrayNS[i].body.setFill();\n        carArrayNS[i].body.hide();\n        yPos += 150;\n    }\n\n    // Initialize and stagger EW cars\n    for (int i = 0; i < 3; i++)\n    {\n        carArrayEW[i].body = Rectangle(xPos, 500, 75, 50);\n        carArrayEW[i].body.setColor(COLOR(\"green\"));\n        carArrayEW[i].body.setFill();\n        carArrayEW[i].body.hide();\n        xPos -= 150;\n    }\n\n   //main loop that asks user for input and simulates the intersection\n    while (flag)\n    {\n        xPos = 350;\n        yPos = 650;\n        called = false; //reset yellow light flag\n\n        //reset NS car locations to starting position\n        for (int i = 0; i < 3; i++)\n        {\n            carArrayNS[i].body.moveTo(500, yPos);\n            carArrayNS[i].body.hide();\n            yPos += 150;\n        }\n\n        //reset EW car locations to starting position\n        for (int i = 0; i < 3; i++)\n        {\n            carArrayEW[i].body.moveTo(xPos, 500);\n            carArrayEW[i].body.hide();\n            xPos -= 150;\n        }\n\n        // Ask for traffic density\n        cout << \"Enter the traffic density: (h = heavy, m = medium, l = light): \";\n        cin >> input;\n\n        switch (input)\n        {\n        //heavy traffic\n        case 'h':\n            //show all vehicles\n            carArrayNS[0].body.show();\n            carArrayNS[1].body.show();\n            carArrayNS[2].body.show();\n            carArrayEW[0].body.show();\n            carArrayEW[1].body.show();\n            carArrayEW[2].body.show();\n\n            //set light to green\n            wait(1);\n            greenLight(c1, 0);\n            wait(0.5);\n\n            //moves NS Cars, when last car gets across road, change light to yellow.\n            while (carArrayNS[2].body.getY() >= -35)\n            {\n                carArrayNS[0].body.move(0, -15);\n                carArrayNS[1].body.move(0, -15);\n                carArrayNS[2].body.move(0, -15);\n                if (carArrayNS[2].body.getY() <= 300 && !called)\n                {\n                    yellowLight(c1, 0);\n                    called = true;\n                }\n                wait(0.1);\n            }\n            //when final car leaves screen, light turns red\n            redLight(c1, 0);\n            wait(1);\n            greenLight(c2, 1);\n            called = false;\n            wait(0.5);\n\n            //moves EW Cars, when last car gets across road, change light to yellow.\n            while (carArrayEW[2].body.getX() <= 1035)\n            {\n                carArrayEW[0].body.move",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass SimpleAccount {\nprotected:\n    string owner_name;\n    double initial_balance;\n    double interest_rate;\n    int years_existence;\n\npublic:\n    SimpleAccount(string name, double balance, double rate, int years)\n        : owner_name(name), initial_balance(balance), interest_rate(rate), years_existence(years) {}\n\n    virtual double calculateBalance() {\n        return initial_balance * (1 + interest_rate / 100 * years_existence);\n    }\n\n    virtual void printAccount() {\n        cout << \"Owner: \" << owner_name << endl;\n        cout << \"Initial Balance: $\" << initial_balance << endl;\n        cout << \"Interest Rate: \" << interest_rate << \"%\" << endl;\n        cout << \"Years Existence: \" << years_existence << endl;\n        cout << \"Balance: $\" << calculateBalance() << endl;\n    }\n};\n\nclass PrivilegedAccount : public SimpleAccount {\nprivate:\n    double credit_interest_rate;\n\npublic:\n    PrivilegedAccount(string name, double balance, double rate, int years, double credit_rate)\n        : SimpleAccount(name, balance, rate, years), credit_interest_rate(credit_rate) {}\n\n    double calculateBalance() override {\n        double base_balance = SimpleAccount::calculateBalance();\n        double available_credit = base_balance * (credit_interest_rate / 100);\n        return base_balance + available_credit;\n    }\n\n    void printAccount() override {\n        SimpleAccount::printAccount();\n        cout << \"Credit Interest Rate: \" << credit_interest_rate << \"%\" << endl;\n        cout << \"Available Credit: $\" << calculateBalance() - initial_balance << endl;\n    }\n};\n\nint main() {\n    SimpleAccount simple(\"John Doe\", 1000.0, 5.0, 3);\n    simple.printAccount();\n    cout << endl;\n\n    PrivilegedAccount privileged(\"Jane Smith\", 2000.0, 6.0, 5, 10.0);\n    privileged.printAccount();\n    cout << endl;\n\n    // Static polymorphism\n    cout << \"Using static polymorphism:\" << endl;\n    SimpleAccount* account1 = &simple;\n    SimpleAccount* account2 = &privileged;\n\n    account1->printAccount();\n    cout << endl;\n    account2->printAccount();\n    cout << endl;\n\n    // Dynamic polymorphism\n    cout << \"Using dynamic polymorphism:\" << endl;\n    SimpleAccount* accounts[2];\n    accounts[0] = &simple;\n    accounts[1] = &privileged;\n\n    for (int i = 0; i < 2; ++i) {\n        accounts[i]->printAccount();\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "\ufeff#include <Windows.h>\r\n#include <mmsystem.h>\r\n#pragma comment(lib, \"winmm.lib\")\r\n#define TIMER_ID 1\r\nint i = 0;\r\nDWORD g_dwOriginalVolume;\r\nextern \"C\" {\r\n    __declspec(dllexport) void __stdcall PlayMusic();\r\n}\r\nTCHAR g_szMusicFilePath1[] = TEXT(\"D:\\\\\u6d4f\u89c8\u5668\u4e0b\u8f7d\\\\hulu.wav\");\r\n\r\nvoid SetSystemVolume(DWORD dwVolume);\r\n\r\n\r\nLRESULT CALLBACK ChildWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n    switch (uMsg) {\r\n    case WM_CREATE:\r\n        break;\r\n    case WM_CLOSE:\r\n        ShowWindow(hwnd, SW_HIDE);\r\n        break;\r\n    case WM_DESTROY:\r\n        PostQuitMessage(0);\r\n        break;\r\n    default:\r\n        return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n    return 0;\r\n}\r\n\r\nLRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\r\n    switch (uMsg) {\r\n    case WM_CREATE:\r\n        PlayMusic();\r\n        SetTimer(hwnd, TIMER_ID, 1000, NULL);\r\n        break;\r\n\r\n    case WM_TIMER:\r\n        if (wParam == TIMER_ID) {\r\n            HWND childWnd = CreateWindow(\r\n                L\"ChildWindowClass\",\r\n                L\"\u5b50\u7a97\u53e3\",\r\n                WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX,\r\n                50 + i * 20, 50 + i * 20,700, 500,\r\n                hwnd,\r\n                NULL,\r\n                (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),\r\n                NULL\r\n            );\r\n            if (childWnd == NULL) {\r\n                MessageBox(hwnd, L\"\u65e0\u6cd5\u521b\u5efa\u5b50\u7a97\u53e3\uff01\", L\"\u9519\u8bef\", MB_OK | MB_ICONERROR);\r\n            }\r\n            SetForegroundWindow(childWnd);\r\n\r\n            // \u5c06\u5b50\u7a97\u53e3\u805a\u7126\r\n            SetFocus(childWnd);\r\n            SetSystemVolume(0xFFFF);\r\n            i = (i + 1) % 100; // \u91cd\u7f6ei\u7684\u503c\uff0c\u907f\u514d\u65e0\u9650\u521b\u5efa\u7a97\u53e3\r\n        }\r\n        break;\r\n\r\n    case WM_CLOSE:\r\n        DestroyWindow(hwnd);\r\n        break;\r\n\r\n    case WM_DESTROY:\r\n        PostQuitMessage(0);\r\n        break;\r\n\r\n    default:\r\n        return DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n    return 0;\r\n}\r\n\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) {\r\n    WNDCLASS wndcls, childWndCls;\r\n\r\n    // \u6ce8\u518c\u4e3b\u7a97\u53e3\u7c7b\r\n    wndcls.cbClsExtra = 0;\r\n    wndcls.cbWndExtra = 0;\r\n    wndcls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\r\n    wndcls.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wndcls.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    wndcls.hInstance = hInstance;\r\n    wndcls.lpfnWndProc = MainWndProc;\r\n    wndcls.lpszClassName = L\"MainWindowClass\";\r\n    wndcls.lpszMenuName = NULL;\r\n    wndcls.style = CS_HREDRAW | CS_VREDRAW;\r\n    RegisterClass(&wndcls);\r\n\r\n    // \u6ce8\u518c\u5b50\u7a97\u53e3\u7c7b\r\n    childWndCls.cbClsExtra = 0;\r\n    childWndCls.cbWndExtra = 0;\r\n    childWndCls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);\r\n    childWndCls.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    childWndCls.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    childWndCls.hInstance = hInstance;\r\n    childWndCls.lpfnWndProc = ChildWndProc;\r\n    childWndCls.lpszClassName = L\"ChildWindowClass\";\r\n    childWndCls.lpszMenuName = NULL;\r\n    childWndCls.style = CS_HREDRAW | CS_VREDRAW;\r\n    RegisterClass(&childWndCls);\r\n\r\n    HWND hwnd = CreateWindow(\r\n        L\"MainWindowClass\", L\"\u6211\u7684\u7b2c\u4e00\u4e2a\u7a97\u53e3\",\r\n        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\r\n        NULL, NULL, hInstance, NULL);\r\n\r\n    if (hwnd == NULL) {\r\n        return 0;\r\n    }\r\n\r\n    ShowWindow(hwnd,1);\r\n    UpdateWindow(hwnd);\r\n\r\n    MSG msg;\r\n    while (GetMessage(&msg, NULL, 0, 0)) {\r\n        TranslateMessage(&msg);\r\n        DispatchMessage(&msg);\r\n    }\r\n\r\n    return 0;\r\n}\r\nvoid __stdcall PlayMusic() {\r\n    // \u4f7f\u7528PlaySound\u51fd\u6570\u64ad\u653e\u97f3\u4e50\r\n    // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u97f3\u4e50\u6587\u4ef6\u7684\u8def\u5f84\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u8c03\u7528PlaySound\u7684\u65b9\u5f0f\r\n    PlaySound(g_szMusicFilePath1, NULL, SND_ASYNC | SND_FILENAME | SND_LOOP);\r\n\r\n\r\n}\r\nvoid SetSystemVolume(DWORD dwVolume) {\r\n    // \u83b7\u53d6\u7cfb\u7edf\u9ed8\u8ba4\u97f3\u9891\u8bbe\u5907\r\n    HMIXER hMixer;\r\n    MIXERLINE ml;\r\n    MIXERCONTROL mc;\r\n    MIXERLINECONTROLS mlc;\r\n    MIXERCONTROLDETAILS mcd;\r\n    DWORD dwControlID;\r\n    MIXERCONTROLDETAILS_UNSIGNED value;\r\n\r\n    if (mixerOpen(&hMixer, 0, 0, 0, MIXER_OBJECTF_MIXER) == MMSYSERR_NOERROR) {\r\n        ml.cbStruct = sizeof(MIXERLINE);\r\n        ml.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;\r\n\r\n        if (mixerGetLineInfo(reinterpret_cast<HMIXEROBJ>(hMixer), &ml, MIXER_GETLINEINFOF_COMPONENTTYPE) == MMSYSERR_NOERROR) {\r\n            mlc.cbStruct = sizeof(MIXERLINECONTROLS);\r\n            mlc.dwLineID = ml.dwLineID;\r\n            mlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;\r\n            mlc.cControls = 1;\r\n            mlc.cbmxctrl = sizeof(MIXERCONTROL);\r\n            mlc.pamxctrl = &mc;\r\n\r\n            if (mixerGetLineControls(reinterpret_cast<HMIXEROBJ>(hMixer), &mlc, MIXER_GETLINECONTROLSF_ONEBYTYPE) == MMSYSERR_NOERROR) {\r\n                dwControlID = mc.dwControlID;\r\n                mcd.cbStruct = sizeof(MIXERCONTROLDETAILS);\r\n                mcd.dwControlID = dwControlID;\r\n                mcd.cChannels = 1;\r\n                mcd.cMultipleItems = 0;\r\n                mcd.cbDetails = si",
    "#include<iostream.h>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nvoid checking();\r\nstatic int rooms=5, non_ac=3, ac=2, n=1, ac1=0, nac1=0,nac2=0, nac3=0, ac2=0, roomno=0;\r\nclass common\r\n{ private :\r\nfriend class calculator;\r\npublic:\r\nchar name[100],address[100];\r\n\r\nint s;\r\nint key,days,k,p;\r\nvoid intro();\r\nint asking();\r\nint choice();\r\nvoid personal();\r\nint detailed();\r\nint  rent(int );\r\nvoid clear_screen();\r\n};\r\nclass ac_room:public common\r\n{\r\npublic:\r\n};\r\nclass non_acroom:public common\r\n{\r\npublic:\r\n};\r\nvoid main()\r\n{ clrscr();\r\nnon_acroom nar[3];\r\nac_room ar[2];\r\ncommon c;\r\nint z,t;\r\nc.intro();\r\ndo\r\n{  int a=c.asking();\r\n   if(a==1)\r\n   {int b=c.choice();\r\n       if(b==1)\r\n       {\r\n\t  if(ac1==0)\r\n\t  { roomno=201;\r\n\t   ar[0].personal();\r\n\t   n=ar[0].rent(b);\r\n\t   ac1=1;\r\n\t  }\r\n\t  else if (ac2==0)\r\n\t  {roomno=202;\r\n\t   ar[1].personal();\r\n\t   n=ar[1].rent(b);\r\n\t   ac2=1;\r\n\r\n\t  }\r\n\t  else\r\n\t  { cout<<\"*******sorry no ac room is available at that time******* \"<<endl;\r\n\t     c.clear_screen();\r\n\t     cout<<\"for continue :   press 1\"<<endl;\r\n\t     cout<<endl<<endl;\r\n\t     cin>>z;\r\n\t     if(z==1)\r\n\t     n=1;\r\n\t     else\r\n\t     n=0;\r\n\r\n\t  }\r\n       }\r\n       else if (b==2)\r\n       {  if(nac1==0)\r\n\t  {  roomno=301;\r\n\t   nar[0].personal();\r\n\t   n= nar[0].rent(b);\r\n\t   nac1=1;\r\n\r\n\t  }\r\n\t  else if (nac2==0)\r\n\t  {roomno=302;\r\n\t   nar[1].personal();\r\n\t   n=nar[1].rent(b);\r\n\t   nac2=1;\r\n\r\n\t  }\r\n\t  else if (nac3==0)\r\n\t  { roomno=303;\r\n\t   nar[2].personal();\r\n\t   n=nar[2].rent(b);\r\n\t   nac3=1;\r\n\t  }\r\n\t  else\r\n\t  { cout<<\"******* sorry no non ac room is available at that time******** \"<<endl;\r\n\t    c.clear_screen();\r\n\t    cout<<\"for continue :   press 1\"<<endl;\r\n\t     cin>>z;\r\n\t     cout<<endl<<endl;\r\n\t     if(z==1)\r\n\t     n=1;\r\n\t     else\r\n\t     n=0;\r\n\r\n\t  }\r\n       }\r\n       else\r\n       {\r\n\t cout<<\"wrong entry \"<<endl;\r\n\t cout<<\"for again :press 1 \"<<endl;\r\n\t cout<<\"for quit press any key (from 2 to 9)\"<<endl;\r\n\t cin>>z;\r\n\t if(z==1)\r\n\t {n=1;}\r\n\t else\r\n\t {n=0;}\r\n       }\r\n\r\n   }\r\n   else if(a==2)\r\n   {\r\n     n= c.detailed();\r\n   }\r\n   else if (a==3)\r\n   {\r\n   cout<<\"enter room type: \"<<endl;\r\ncout<<\"for ac : press 1\"<<endl<<\"for non ac :  press 2\"<<endl;\r\ncin>>z;\r\nif(z==1)\r\n{  cout<<\"enter your room no\"<<endl;\r\ncin>>roomno;\r\nif(roomno==201)\r\n{ ac1=0;\r\nac++;\r\nrooms++;\r\n\r\ncout<<\"so your booking is cancel for room no 201 \";\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncin>>t;\r\ncout<<endl;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse if(roomno==202)\r\n{ ac2=0;\r\nac++;\r\nrooms++;\r\n\r\ncout<<\"so your booking is cancel for room no 202 \";\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncout<<endl;\r\ncin>>t;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse\r\n{cout<<\"your room no is wrong\";\r\nn=0;\r\n}\r\n}\r\nelse if(z==2)\r\n{\r\n cout<<\"enter your room no\"<<endl;\r\ncin>>roomno;\r\nif(roomno==301)\r\n{ nac1=0;\r\ncout<<\"*****so your booking is cancel for room no 301****** \";\r\nnac1++;\r\nrooms++;\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncin>>t;\r\ncout<<endl;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse if(roomno==302)\r\n{ nac2=0;\r\nnac2++;\r\nrooms++;\r\n\r\ncout<<\"so your booking is cancel for room no 302 \";\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\";\r\ncout<<endl<<endl;\r\ncin>>t;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse if(roomno==303)\r\n{ nac3=0;\r\ncout<<\"******so your booking is cancel for room no 303***** \";\r\nnac3++;\r\nrooms++;\r\nc.clear_screen();\r\ncout<<\"for continue  : press 1 \"<<endl<<\"otherwise press any key( from 2 to 9)\"<<endl;\r\ncin>>t;\r\ncout<<endl<<endl;\r\nif(t==1)\r\nn=1;\r\nelse\r\nn=0;\r\n}\r\nelse\r\n{cout<<\"your room no is wrong\"<<endl;\r\nn=0;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse if (a==4)\r\n{\r\n cout<<\"enter room number\"<<endl;\r\n cin>>roomno;\r\n if(roomno==201)\r\n {\r\n   if(ac1==1)\r\n   {\r\n   cout<<\"name   :   \"<<ar[0].name   <<endl;\r\n   cout<<\"address  :  \"<<ar[0].address<<endl;\r\n   cout<<\"booking  :  \"<<ar[0].days<<\" days \"<<endl;\r\n    c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n    n=0;\r\n\r\n   }\r\n   else\r\n   {cout<<\"sorry ,this is empty room \"<<endl;\r\n    c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n    n=0;\r\n   }\r\n }\r\nelse if(roomno==202)\r\n {\r\n   if(ac2==1)\r\n   {\r\n   cout<<\"name   :   \"<<ar[1].name   <<endl;\r\n   cout<<\"address  :  \"<<ar[1].address<<endl;\r\n   cout<<\"booking  :  \"<<ar[1].days<<\" days \"<<endl;\r\n       c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n    n=0;\r\n\r\n   }\r\n   else\r\n   {cout<<\"sorry ,this is empty room \"<<endl;\r\n       c.clear_screen();\r\n    cout<<\"for continue  : press 1  otherwise press any key (from 2 to 9) \"<<endl;\r\n    cin>>t;\r\n    if(t==1)\r\n    n=1;\r\n    else\r\n",
    "#include <string>\n#include <iostream>\n#include <cctype>\n\nbool stringIsNumber(std::string stringToCheck) {\n\tfor (int i = 0; i < stringToCheck.length(); i++) {\n\t\tif (!isdigit(stringToCheck[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint stringToChange(std::string change) {\n\tint result = 0;\n\n\t// Search for \"$\" and \".\" and removes them\n\tstd::size_t found = change.find(\"$\");\n\n\tif (found != std::string::npos) {\n\t\tchange.erase(change.begin() + found);\n\t}\n\n\tfound = change.find(\".\");\n\tif (found != std::string::npos) {\n\t\tchange.erase(change.begin() + found);\n\t}\n\n\tbool isNumber = stringIsNumber(change);\n\n\tif (!isNumber) {\n\t\tstd::cout << \"There was an error converting the string to a number\" << std::endl;\n\t\texit(1);\n\t}\n\n\treturn stoi(change);\n}\n\nint main() {\n\t// Format [\"$12.30\"]\n\tstd::string change;\n\t\n\tstd::cout << \"(Format: $12.30)\" << std::endl;\n\tstd::cout << \"Please input the cash amount: \";\n\tstd::cin >> change;\n\n\tint changeAsInt = stringToChange(change);\n\n\tint quarters, dimes, nickles, pennies;\n\tquarters = dimes = nickles = pennies = 0;\n\n\twhile (changeAsInt > 0) {\n\t\tif (changeAsInt >= 100) {\n\t\t\tint tempVal = changeAsInt / 100;\n\t\t\tquarters = tempVal * 4;\n\t\t\tchangeAsInt -= tempVal * 100;\n\t\t}\n\t\telse if (changeAsInt >= 10) {\n\t\t\tdimes = changeAsInt / 10;\n\t\t\tchangeAsInt -= dimes * 10;\n\t\t}\n\t\telse if (changeAsInt >= 5) {\n\t\t\tnickles = changeAsInt / 5;\n\t\t\tchangeAsInt -= nickles * 5;\n\t\t}\n\t\telse if (changeAsInt >= 1) {\n\t\t\tpennies = changeAsInt;\n\t\t\tchangeAsInt -= changeAsInt;\n\t\t}\n\t}\n\n\t//std::cout << \"Cash: \" << change << std::endl;\n\tstd::cout << \"Quarters: \" << quarters << \", Dimes: \" << dimes << \", Nickles: \" << nickles << \", Pennies: \" << pennies << std::endl;\n\n\n\treturn 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\nusing namespace std;\nconst char *nombre_archivo = \"archivo.dat\";\nstruct Estudiante{\n\tint codigo;\n\tchar nombre[50];\n\tchar apellidos[50];\n\tint telefono;\n};\n\nvoid Leer();\nvoid Crear();\nvoid Actualizar();\nvoid Borrar();\nmain(){\n\tLeer();\n\tCrear();\n\tBorrar();\n\tActualizar();\n\t\n\tsystem(\"Pause\");\n}\nvoid Leer(){\n\tsystem(\"cls\");\n\tFILE* archivo = fopen(nombre_archivo,\"rb\");\n\tif(!archivo){\n\t\tarchivo = fopen(nombre_archivo,\"w+b\");\n\t}\n\tEstudiante estudiante;\n\tint id=0;\n\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\tcout<<\"---------------------------\"<<endl;\n\tcout<<\"ID\"<<\"|\"<<\"Codigo\"<<\"|\"<<\"Nombres\"<<\"|\"<<\"Apellidos\"<<\"|\"<<\"Telefono\"<<endl;\n\tdo{\n\t\tcout<<id<<\"|\"<<estudiante.codigo<<\"|\"<<estudiante.nombre<<\"|\"<<estudiante.apellidos<<\"|\"<<estudiante.telefono<<endl;\n\t\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\t\tid+=1;\n\t}while(feof(archivo)==0);\n\tfclose(archivo);\n}\n\t\n\t\nvoid Crear(){\n\tFILE* archivo = fopen(nombre_archivo,\"a+b\");\n\tchar res;\n\tEstudiante estudiante;\n\tdo{\n\t\tfflush(stdin);\n\t\t\n\t\tcout<<\"Ingrese Codigo: \";\n\t\tcin>>estudiante.codigo;\n\t\tcin.ignore();\n\t\t\n\t\tcout<<\"Ingrese Nombres: \";\n\t\tcin.getline(estudiante.nombre,50);\n\t\t\n\t\tcout<<\"Ingrese Apellidos: \";\n\t\tcin.getline(estudiante.apellidos,50);\n\t\t\n\t\tcout<<\"Ingrese Telefono: \";\n\t\tcin>>estudiante.telefono;\n\t\t\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\tcout<<\"Desea Ingresar Otro Estudiante (S/N): \";\n\t\tcin>>res;\n\t}while(res=='s' || res=='S');\n\tfclose(archivo);\n\tLeer();\n}\nvoid Actualizar(){\n\t\n\tFILE* archivo = fopen(nombre_archivo,\"r+b\");\n\tEstudiante estudiante;\n\tint id=0;\n\tcout<<\"Ingrese el ID desea modificar: \";\n\tcin>>id;\n\tfseek(archivo,id * sizeof(Estudiante),SEEK_SET);\n\t\t\n\t\tcout<<\"Ingrese Codigo: \";\n\t\tcin>>estudiante.codigo;\n\t\tcin.ignore();\n\t\t\n\t\tcout<<\"Ingrese Nombres: \";\n\t\tcin.getline(estudiante.nombre,50);\n\t\t\n\t\tcout<<\"Ingrese Apellidos: \";\n\t\tcin.getline(estudiante.apellidos,50);\n\t\t\n\t\tcout<<\"Ingrese Telefono: \";\n\t\tcin>>estudiante.telefono;\n\t\t\n\t\tfwrite(&estudiante,sizeof(Estudiante),1,archivo);\n\t\n\tfclose(archivo);\n\tLeer();\n}\nvoid Borrar(){\n\tconst char *nombre_archivo_temp = \"archivo_temp.dat\";\n\tFILE* archivo = fopen(nombre_archivo,\"rb\");\n\tFILE* archivo_temp = fopen(nombre_archivo_temp,\"w+b\");\n\tEstudiante estudiante;\n\tint id=0,id_n=0;\n\tcout<<\"Ingrese el ID a Eliminar: \";\n\tcin>>id;\n\twhile(fread(&estudiante,sizeof(Estudiante),1,archivo)){\n\t\tif (id_n!=id){\n\t\t\tfread(&estudiante,sizeof(Estudiante),1,archivo_temp);\n\t\t}\n\t\tid_n++;\n\t}\n\tfclose(archivo);\n\tfclose(archivo_temp);\n\n\t\n\tarchivo_temp = fopen(nombre_archivo_temp,\"rb\");\n\tarchivo = fopen(nombre_archivo,\"wb\");\n\twhile(fread(&estudiante,sizeof(Estudiante),1,archivo_temp)){\n\t\tfread(&estudiante,sizeof(Estudiante),1,archivo);\n\t\t\n\t}\n\tfclose(archivo);\n\tfclose(archivo_temp);\n\tLeer();\n}\n",
    "#include \"fft.hpp\"\n\n#include <iostream>\n\nusing namespace std;\n\nFFT::FFT(int nFFT, Window windowType, double fs) {\n  m_nFFT = nFFT;\n  m_bitRevTable = genBitRevTable();\n  m_window = genWindow(windowType);\n  m_areaWindow = calcWindowArea();\n  m_coef = genCoef();\n  m_fs = fs;\n}\n\nFFT::~FFT() {\n  delete[] m_bitRevTable;\n  delete[] m_window;\n  delete[] m_coef;\n}\n\nint* FFT::genBitRevTable() {\n  int* bitRevTable = new int[m_nFFT];\n  int bitNum = log2(m_nFFT);\n  for (int i = 0; i < m_nFFT; i++) {\n    bitRevTable[i] = 0;\n    for (int j = bitNum - 1; j >= 0; j--) {\n      bitRevTable[i] |= (1 & (i >> j)) << ((bitNum - 1) - j);\n    }\n  }\n  return bitRevTable;\n}\n\ndouble* FFT::genWindow(Window windowType) {\n  double* window = new double[m_nFFT];\n  switch (windowType) {\n    case Window::Gaussian:\n      for (int i = 0; i < m_nFFT; i++) {\n        window[i] = exp(-pow((i - m_nFFT / 2.0) / 3.0 / m_nFFT, 2.0));\n      }\n      break;\n    case Window::Hamming:\n      for (int i = 0; i < m_nFFT; i++) {\n        window[i] = 0.54 - 0.46 * cos(2.0 * M_PI * i / m_nFFT);\n      }\n      break;\n    case Window::Hann:\n      for (int i = 0; i < m_nFFT; i++) {\n        window[i] = 0.5 - 0.5 * cos(2.0 * M_PI * i / m_nFFT);\n      }\n      break;\n    case Window::Rect:\n      for (int i = 0; i < m_nFFT; i++) {\n        window[i] = 1.0;\n      }\n      break;\n    default:\n      cerr << \"Unsupported window type.\" << endl;\n      return nullptr;\n  }\n  return window;\n}\n\ndouble FFT::calcWindowArea() {\n  double sum = 0.0;\n  for (int i = 0; i < m_nFFT; i++) {\n    sum += m_window[i];\n  }\n  return sum;\n}\n\ncomplex<double>* FFT::genCoef() {\n  complex<double>* coef = new complex<double>[m_nFFT];\n  for (int i = 0; i < m_nFFT / 2.0; i++) {\n    coef[i] = exp(-2.0 * M_PI / m_nFFT * i * 1.0i);\n  }\n  return coef;\n}\n\nvoid FFT::exec(double* in, complex<double>* out) {\n  complex<double>* tmp = new complex<double>[m_nFFT];\n  complex<double> tmptmp;\n  for (int i = 0; i < m_nFFT; i++) {\n    tmp[i] = m_window[i] * in[i];\n  }\n  int iMax = log2(m_nFFT);\n  for (int i = 0; i < iMax; i++) {\n    int jMax = 1 << i;\n    for (int j = 0; j < jMax; j++) {\n      int kMax = m_nFFT / (1 << (i + 1));\n      for (int k = 0; k < kMax; k++) {\n        tmptmp = tmp[j * (kMax << 1) + k];\n        tmp[j * (kMax << 1) + k] += tmp[j * (kMax << 1) + kMax + k];\n        tmp[j * (kMax << 1) + kMax + k] =\n            (-tmp[j * (kMax << 1) + kMax + k] + tmptmp) * m_coef[k * (1 << i)];\n      }\n    }\n  }\n  for (int i = 0; i < m_nFFT; i++) {\n    out[m_bitRevTable[i]] = tmp[i] / m_areaWindow;\n  }\n  delete[] tmp;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <locale.h>\r\n#include <stdlib.h> // Para a fun\u00e7\u00e3o system()\r\nint main() {\r\n\tsetlocale(LC_ALL, \"Portuguese\"); // Configura a localiza\u00e7\u00e3o para Portugu\u00eas\r\n\r\n\t\r\n    char username[20];\r\n    char password[20];\r\n    int accessLevel = 0; // 0: n\u00edvel padr\u00e3o, 1: n\u00edvel de usu\u00e1rio, 2: n\u00edvel de administrador\r\n\r\n    // Solicita o nome de usu\u00e1rio e senha\r\n    printf(\"Digite o nome de usu\u00e1rio: \");\r\n    scanf(\"%s\", username);\r\n    printf(\"Digite a senha: \");\r\n    scanf(\"%s\", password);\r\n\r\n    // Verifica as credenciais\r\n    if (strcmp(username, \"admin\") == 0 && strcmp(password, \"admin123\") == 0) {\r\n        accessLevel = 2; // N\u00edvel de administrador\r\n    } else if (strcmp(username, \"usuario1\") == 0 && strcmp(password, \"senha123\") == 0) {\r\n        accessLevel = 1; // N\u00edvel de funcion\u00e1rio regular\r\n    } else if (strcmp(username, \"visitante\") == 0 && strcmp(password, \"visitante123\") == 0) {\r\n        accessLevel = 0; // N\u00edvel de convidado\r\n    } else {\r\n        accessLevel = -1; // Credenciais inv\u00e1lidas\r\n    }\r\n\r\n    // Exibe a mensagem apropriada com base no n\u00edvel de acesso\r\n    switch (accessLevel) {\r\n        case 2:\r\n            printf(\"Bem-vindo, administrador %s! Acesso concedido total.\\n\", username);\r\n            break;\r\n        case 1:\r\n            printf(\"Bem-vindo, funcion\u00e1rio regular %s! Acesso concedido limitado.\\n\", username);\r\n            break;\r\n        case 0:\r\n            printf(\"Bem-vindo, visitante %s! Acesso extremamente limitado.\\n\", username);\r\n            break;\r\n        default:\r\n            printf(\"Credenciais inv\u00e1lidas. Acesso negado.\\n\");\r\n    }\r\n    \r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n\r\n",
    "class Solution {\npublic:\n    int countStudents(vector<int>& students, vector<int>& sandwiches) {\n        bool noChange = true;\n        int top = 0, delCount = 0;\n        while(noChange){\n            noChange = true;\n            if(delCount * 2 > students.size()){\n                erase_if(students, [](int x) {return (x == -1) ? true : false;});\n                erase_if(sandwiches, [](int x) {return (x == -1) ? true : false;});\n                delCount = 0;\n                top = 0;\n            }\n            for(int i = 0; i < students.size() && top < sandwiches.size(); i++){\n                if(students[i] == sandwiches[top]){\n                    students[i] = -1;\n                    sandwiches[top++] = -1;\n                    delCount++;\n                    noChange = false;\n                }\n                else if(students[i] == -1) continue;\n            }\n            if(top == sandwiches.size()) return 0;\n            if(noChange){\n                erase_if(students, [](int x) { return (x == -1) ? true : false;});\n                top = 0; delCount = 0;\n                break;\n            }\n            else{\n                noChange = true;\n            }\n        }\n        return students.size();\n    }\n};\n",
    "#include \"kernel.h\"\r\nusing namespace std;\r\nextern int ans;\r\nchar* flag;\r\nvoid ppt_add(){\r\n\tans++;\r\n\tout=\"ppt\u540d\u5b57\";\r\n\tppt[ans].name=in();\r\n\twhile(flag!=\"end\"){\r\n\t\tflag=in();\r\n\t\tif(flag==\"x&y\"){\r\n\t\t\tint x,y;\r\n\t\t\tchar ch;\r\n\t\t\tflag=in();//\u4f7f\u7528else if\u4e0d\u4f1a\u5bfc\u81f4\u5176\u5b83\u7ed3\u679c\r\n\t\t\tx=digit(flag);\r\n\t\t\tflag=in();\r\n\t\t\ty=digit(flag);\r\n\t\t\tch=input();\r\n\t\t\tppt[ans].t[ppt[ans].z][x][y]=ch;\r\n\t\t}\r\n\t\telse if(flag==\"to\"){\r\n\t\t\tint go=digit(in());\r\n\t\t\tppt[ans].z=go;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\nvoid ppt_del(int x){\r\n\tif(x==ans){\r\n\t\tppt[ans].z=0;\r\n\t\tppt[ams].name=\"\";\r\n\t\tfor(int i=1;i<=99;i++){\r\n\t\t\tfor(int j=1;j<=99;j++){\r\n\t\t\t\tfor(int k=1;k<=99;k++){\r\n\t\t\t\t\tppt[ans].t[i][j][k]=' ';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse{\r\n\t\tfor(int i=x;i<ans;i++){\r\n\t\t\tppt[i].name=ppt[ans].name;\r\n\t\t\tfor(int i1=1;i1<=99;i1++){\r\n\t\t\t\tfor(int j=1;j<=99;j++){\r\n\t\t\t\t\tfor(int k=1;k<=z;k++){\r\n\t\t\t\t\t\tif(ppt[i+1]){//\u5224\u65ad\u4e0b\u4e00\u4e2a\u6587\u4ef6\u662f\u5426\u53ef\u80fd\u662ftxt\u6587\u4ef6\r\n\t\t\t\t\t\t\tppt[i].t[i1][j][k]=ppt[i+1].t[i1][j][k];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nvoid ppt_change(){\r\n\tout=\"ppt\u540d\u5b57\";\r\n\tchar* find;\r\n\tint h=-1;\r\n\tfind=in();\r\n\tfor(int i=1;i<=ans;i++){\r\n\t\tif(find==ppt[i].name){\r\n\t\t\th=i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif(h==-1){\r\n\t\tout=\"\u627e\u4e0d\u5230\u9700\u8981\u7f16\u8f91\u7684\u6587\u4ef6!\";\r\n\t\tsleep(1);\r\n\t\treturn;\r\n\t}\r\n\twhile(flag!=\"end\"){\r\n\t\tflag=in();\r\n\t\tif(flag==\"x&y\"){\r\n\t\t\tint x,y;\r\n\t\t\tchar ch;\r\n\t\t\tflag=in();//\u4f7f\u7528else if\u4e0d\u4f1a\u5bfc\u81f4\u5176\u5b83\u7ed3\u679c\r\n\t\t\tx=digit(flag);\r\n\t\t\tflag=in();\r\n\t\t\ty=digit(flag);\r\n\t\t\tch=input();\r\n\t\t\tppt[ans].t[ppt[h].z][x][y]=ch;\r\n\t\t}\r\n\t\telse if(flag==\"to\"){\r\n\t\t\tint go=digit(in());\r\n\t\t\tppt[h].z=go;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Item {\n    string name;\npublic:\n    Item(const string& name) : name(name) {}\n    string getName() const { return name; }\n};\n\nclass Customer {\n    string name;\n    int age;\npublic:\n    Customer(const string& name, int age) : name(name), age(age) {}\n    void buyItem(const Item& item) {\n        cout << name << \" buying \" << item.getName() << endl;\n    }\n};\n\nclass Shop {\n    vector<Customer*> customers;\n    vector<Item> items;\npublic:\n    void addObserver(Customer* customer) {\n        customers.push_back(customer);\n    }\n    void removeObserver(Customer* customer) {\n        customers.erase(remove(customers.begin(), customers.end(), customer), customers.end());\n    }\n    void addItem(const Item& item) {\n        items.push_back(item);\n    }\n    void sellItem(const Item& item) {\n        for (auto& customer : customers) {\n            customer->buyItem(item);\n        }\n    }\n};\n\nint main() {\n    Shop shop;\n\n    Customer customer1(\"Petro\", 30);\n    Customer customer2(\"Maria\", 25);\n\n    shop.addObserver(&customer1);\n    shop.addObserver(&customer2);\n\n    Item item1(\"PC\");\n    Item item2(\"ball\");\n\n    shop.addItem(item1);\n    shop.addItem(item2);\n\n    shop.sellItem(item1);\n\n    shop.removeObserver(&customer1);\n\n    shop.sellItem(item2);\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"text_to_speech\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// This provided code will run on Leetcode but to run on any code editor, Provide a main function creating a matrix and call the\n//  'maximalRectangle()' method by providing the matrix as a parameter. It will execute. \n\n\nclass Solution {\npublic:\n\n    int maxRect(vector<int>& heights, int maxm) {\n        int len = heights.size();\n\n        vector<int>left(len);\n        vector<int>right(len);\n        stack<int>myStackL;\n        stack<int>myStackR;\n\n        for(int i = 0; i < len; i++){\n            if(myStackL.empty()){\n                left[i] = 0;\n                myStackL.push(i);\n            }\n\n            else{\n                while((!myStackL.empty()) && heights[myStackL.top()] >= heights[i]){\n                    myStackL.pop();\n                }\n                left[i] = (myStackL.empty()) ? 0 : myStackL.top() + 1;\n                myStackL.push(i);\n            }    \n        }\n\n\n\n        for(int i = len - 1; i >= 0; i--){\n            if(myStackR.empty()){\n                right[i] = len - 1;\n                myStackR.push(i);\n            }\n\n            else{\n                while((!myStackR.empty()) && heights[myStackR.top()] >= heights[i]){\n                    myStackR.pop();\n                }\n                right[i] = (myStackR.empty()) ? len - 1 : myStackR.top() - 1;\n                myStackR.push(i);\n            }    \n        }\n\n        int maxArea = 0;\n\n        for(int i = 0; i < len; i++){\n            int currArea = (right[i] - left[i] + 1) * heights[i];\n            maxArea = max(currArea, maxArea);\n        }\n\n        return max(maxArea, maxm);\n    }\n\n    int maximalRectangle(vector<vector<char>>& matrix) {\n         int len = matrix[0].size();\n        int maxRes = 0;\n        vector<int>count(len);\n        for(int i = 0; i < len; i++){\n            count[i] = 0;\n        }\n        \n        int row = matrix.size();\n        int col = matrix[0].size();\n        for(int i = 0; i < row; i++){\n            for(int j = 0; j < col; j++){\n                if(matrix[i][j] == '1'){\n                    count[j] += 1;\n                }\n                else{\n                    count[j] = 0;\n                }\n            }\n            \n            maxRes = maxRect(count, maxRes);\n        }\n        \n        return maxRes;\n    }\n};",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"OperationLimiter.h\"\n\n#include <gtest/gtest-spi.h>\n\nnamespace android {\nnamespace netdutils {\n\nTEST(OperationLimiter, limits) {\n    OperationLimiter<int> limiter(3);\n\n    EXPECT_TRUE(limiter.start(42));\n    EXPECT_TRUE(limiter.start(42));\n    EXPECT_TRUE(limiter.start(42));\n\n    // Limit reached... calling any number of times should have no effect.\n    EXPECT_FALSE(limiter.start(42));\n    EXPECT_FALSE(limiter.start(42));\n    EXPECT_FALSE(limiter.start(42));\n\n    // Finishing a single operations is enough for starting a new one...\n    limiter.finish(42);\n    EXPECT_TRUE(limiter.start(42));\n\n    // ...but not two!\n    EXPECT_FALSE(limiter.start(42));\n\n    // Different ids should still have quota...\n    EXPECT_TRUE(limiter.start(666));\n    limiter.finish(666);\n\n    // Finish all pending operations\n    limiter.finish(42);\n    limiter.finish(42);\n    limiter.finish(42);\n}\n\nTEST(OperationLimiter, finishWithoutStart) {\n    OperationLimiter<int> limiter(1);\n\n    // Will output a LOG(FATAL_WITHOUT_ABORT), but we have no way to probe this.\n    limiter.finish(42);\n\n    // This will ensure that the finish() above didn't set a negative value.\n    EXPECT_TRUE(limiter.start(42));\n    EXPECT_FALSE(limiter.start(42));\n}\n\nTEST(OperationLimiter, destroyWithActiveOperations) {\n    // The death message doesn't seem to be captured on Android.\n    EXPECT_DEBUG_DEATH(\n            {\n                OperationLimiter<int> limiter(3);\n                limiter.start(42);\n            },\n            \"\" /* \"active operations */);\n}\n\n}  // namespace netdutils\n}  // namespace android\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb.aidl-service.UsbDataSessionMonitor\"\n\n#include \"UsbDataSessionMonitor.h\"\n\n#include <aidl/android/frameworks/stats/IStats.h>\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android_hardware_usb_flags.h>\n#include <cutils/uevent.h>\n#include <pixelstats/StatsHelper.h>\n#include <pixelusb/CommonUtils.h>\n#include <sys/epoll.h>\n#include <utils/Log.h>\n\n#include <regex>\n\nnamespace usb_flags = android::hardware::usb::flags;\n\nusing aidl::android::frameworks::stats::IStats;\nusing android::base::ReadFileToString;\nusing android::hardware::google::pixel::getStatsService;\nusing android::hardware::google::pixel::reportUsbDataSessionEvent;\nusing android::hardware::google::pixel::PixelAtoms::VendorUsbDataSessionEvent;\nusing android::hardware::google::pixel::usb::addEpollFd;\nusing android::hardware::google::pixel::usb::BuildVendorUsbDataSessionEvent;\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace usb {\n\n#define UEVENT_MSG_LEN 2048\n#define USB_STATE_MAX_LEN 20\n#define DATA_ROLE_MAX_LEN 10\n\nconstexpr char kUdcConfigfsPath[] = \"/config/usb_gadget/g1/UDC\";\nconstexpr char kNotAttachedState[] = \"not attached\\n\";\nconstexpr char kAttachedState[] = \"attached\\n\";\nconstexpr char kPoweredState[] = \"powered\\n\";\nconstexpr char kDefaultState[] = \"default\\n\";\nconstexpr char kAddressedState[] = \"addressed\\n\";\nconstexpr char kConfiguredState[] = \"configured\\n\";\nconstexpr char kSuspendedState[] = \"suspended\\n\";\nconst std::set<std::string> kValidStates = {kNotAttachedState, kAttachedState,  kPoweredState,\n                                            kDefaultState,     kAddressedState, kConfiguredState,\n                                            kSuspendedState};\n\nstatic int addEpollFile(const int &epollFd, const std::string &filePath, unique_fd &fileFd) {\n    struct epoll_event ev;\n\n    unique_fd fd(open(filePath.c_str(), O_RDONLY));\n\n    if (fd.get() == -1) {\n        ALOGI(\"Cannot open %s\", filePath.c_str());\n        return -1;\n    }\n\n    ev.data.fd = fd.get();\n    ev.events = EPOLLPRI;\n\n    if (epoll_ctl(epollFd, EPOLL_CTL_ADD, fd.get(), &ev) != 0) {\n        ALOGE(\"epoll_ctl failed; errno=%d\", errno);\n        return -1;\n    }\n\n    fileFd = std::move(fd);\n    ALOGI(\"epoll registered %s\", filePath.c_str());\n    return 0;\n}\n\nstatic void removeEpollFile(const int &epollFd, const std::string &filePath, unique_fd &fileFd) {\n    epoll_ctl(epollFd, EPOLL_CTL_DEL, fileFd.get(), NULL);\n    fileFd.release();\n\n    ALOGI(\"epoll unregistered %s\", filePath.c_str());\n}\n\nUsbDataSessionMonitor::UsbDataSessionMonitor(\n    const std::string &deviceUeventRegex, const std::string &deviceStatePath,\n    const std::string &host1UeventRegex, const std::string &host1StatePath,\n    const std::string &host2UeventRegex, const std::string &host2StatePath,\n    const std::string &dataRolePath, std::function<void()> updatePortStatusCb) {\n    struct epoll_event ev;\n    std::string udc;\n\n    unique_fd epollFd(epoll_create(8));\n    if (epollFd.get() == -1) {\n        ALOGE(\"epoll_create failed; errno=%d\", errno);\n        abort();\n    }\n\n    unique_fd ueventFd(uevent_open_socket(64 * 1024, true));\n    if (ueventFd.get() == -1) {\n        ALOGE(\"uevent_open_socket failed\");\n        abort();\n    }\n    fcntl(ueventFd, F_SETFL, O_NONBLOCK);\n\n    if (addEpollFd(epollFd, ueventFd))\n        abort();\n\n    if (addEpollFile(epollFd.get(), dataRolePath, mDataRoleFd) != 0) {\n        ALOGE(\"monitor data role failed\");\n        abort();\n    }\n\n    /*\n     * The device state file could be absent depending on the current data role\n     * and driver architecture. It's ok for addEpollFile to fail here, the file\n     * will be monitored later when its presence is detected by uevent.\n     */\n    mDeviceState.filePath = deviceStatePath;\n    mDeviceState.ueventRegex = deviceUeventRegex;\n    addEpollFile(epollFd.get(), mDeviceState.filePath, mDeviceState.fd);\n\n    mHost1State.filePath = host1StatePath;\n    mHost1State.ueventRegex = host1UeventRegex;\n    addEpollFile(epollFd.get(), mHost1State.filePath, mHost1State.fd);\n\n    mHost2State.filePath = host2StatePath;\n    mHost2State.ueventRegex = host2UeventRegex;\n    addEpollFile(epollFd.get(), mHost2State.filePath, mHost2State.fd);\n\n    mEpollFd = std::move(epollFd);\n    mUeventFd = std::move(ueventFd);\n    mUpdatePortStatusCb = updatePortStatusCb;\n\n    if (ReadFileTo",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n\n\nconst sf::Uint8 audioData   = 1;\nconst sf::Uint8 endOfStream = 2;\n\n\n////////////////////////////////////////////////////////////\n/// Customized sound stream for acquiring audio data\n/// from the network\n////////////////////////////////////////////////////////////\nclass NetworkAudioStream : public sf::SoundStream\n{\npublic:\n\n    ////////////////////////////////////////////////////////////\n    /// Default constructor\n    ///\n    ////////////////////////////////////////////////////////////\n    NetworkAudioStream() :\n    m_offset     (0),\n    m_hasFinished(false)\n    {\n        // Set the sound parameters\n        initialize(1, 44100);\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// Run the server, stream audio data from the client\n    ///\n    ////////////////////////////////////////////////////////////\n    void start(unsigned short port)\n    {\n        if (!m_hasFinished)\n        {\n            // Listen to the given port for incoming connections\n            if (m_listener.listen(port) != sf::Socket::Done)\n                return;\n            std::cout << \"Server is listening to port \" << port << \", waiting for connections... \" << std::endl;\n\n            // Wait for a connection\n            if (m_listener.accept(m_client) != sf::Socket::Done)\n                return;\n            std::cout << \"Client connected: \" << m_client.getRemoteAddress() << std::endl;\n\n            // Start playback\n            play();\n\n            // Start receiving audio data\n            receiveLoop();\n        }\n        else\n        {\n            // Start playback\n            play();\n        }\n    }\n\nprivate:\n\n    ////////////////////////////////////////////////////////////\n    /// /see SoundStream::OnGetData\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onGetData(sf::SoundStream::Chunk& data)\n    {\n        // We have reached the end of the buffer and all audio data have been played: we can stop playback\n        if ((m_offset >= m_samples.size()) && m_hasFinished)\n            return false;\n\n        // No new data has arrived since last update: wait until we get some\n        while ((m_offset >= m_samples.size()) && !m_hasFinished)\n            sf::sleep(sf::milliseconds(10));\n\n        // Copy samples into a local buffer to avoid synchronization problems\n        // (don't forget that we run in two separate threads)\n        {\n            sf::Lock lock(m_mutex);\n            m_tempBuffer.assign(m_samples.begin() + m_offset, m_samples.end());\n        }\n\n        // Fill audio data to pass to the stream\n        data.samples     = &m_tempBuffer[0];\n        data.sampleCount = m_tempBuffer.size();\n\n        // Update the playing offset\n        m_offset += m_tempBuffer.size();\n\n        return true;\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// /see SoundStream::OnSeek\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual void onSeek(sf::Time timeOffset)\n    {\n        m_offset = timeOffset.asMilliseconds() * getSampleRate() * getChannelCount() / 1000;\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// Get audio data from the client until playback is stopped\n    ///\n    ////////////////////////////////////////////////////////////\n    void receiveLoop()\n    {\n        while (!m_hasFinished)\n        {\n            // Get waiting audio data from the network\n            sf::Packet packet;\n            if (m_client.receive(packet) != sf::Socket::Done)\n                break;\n\n            // Extract the message ID\n            sf::Uint8 id;\n            packet >> id;\n\n            if (id == audioData)\n            {\n                // Extract audio samples from the packet, and append it to our samples buffer\n                const sf::Int16* samples     = reinterpret_cast<const sf::Int16*>(static_cast<const char*>(packet.getData()) + 1);\n                std::size_t      sampleCount = (packet.getDataSize() - 1) / sizeof(sf::Int16);\n\n                // Don't forget that the other thread can access the sample array at any time\n                // (so we protect any operation on it with the mutex)\n                {\n                    sf::Lock lock(m_mutex);\n                    std::copy(samples, samples + sampleCount, std::back_inserter(m_samples));\n                }\n            }\n            else if (id == endOfStream)\n            {\n                // End of stream reached: we stop receiving audio data\n                std::cout << \"Audio data has been 100% received!\" << std::endl;\n                m_hasFinished = true;\n            }\n            else\n            {\n                // Something's wrong...\n                std::cout << \"Invalid packet received...\" << std::",
    "#include \"Producto.h\"\n#include <iostream>\n\nusing namespace std;\n\nProducto::Producto(int idProducto, const string& nombre, const string& tipo, int cantidad, const string& categoria, int a\u00f1o, double precio, Proveedor* proveedor)\n    : idProducto(idProducto), nombre(nombre), tipo(tipo), cantidad(cantidad), categoria(categoria), a\u00f1o(a\u00f1o), precio(precio), proveedor(proveedor) {}\n\nint Producto::getIdProducto() const {\n    return idProducto;\n}\n\nstring Producto::getNombre() const {\n    return nombre;\n}\n\nstring Producto::getTipo() const {\n    return tipo;\n}\n\nint Producto::getCantidad() const {\n    return cantidad;\n}\n\nstring Producto::getCategoria() const {\n    return categoria;\n}\n\nint Producto::getA\u00f1o() const {\n    return a\u00f1o;\n}\n\ndouble Producto::getPrecio() const {\n    return precio;\n}\n\nProveedor* Producto::getProveedor() const {\n    return proveedor;\n}\n\nvoid Producto::setIdProducto(int newIdProducto) {\n    idProducto = newIdProducto;\n}\n\nvoid Producto::setNombre(const string& newNombre) {\n    nombre = newNombre;\n}\n\nvoid Producto::setTipo(const string& newTipo) {\n    tipo = newTipo;\n}\n\nvoid Producto::setCantidad(int newCantidad) {\n    cantidad = newCantidad;\n}\n\nvoid Producto::setCategoria(const string& newCategoria) {\n    categoria = newCategoria;\n}\n\nvoid Producto::setA\u00f1o(int newA\u00f1o) {\n    a\u00f1o = newA\u00f1o;\n}\n\nvoid Producto::setPrecio(double newPrecio) {\n    precio = newPrecio;\n}\n\nvoid Producto::setProveedor(Proveedor* newProveedor) {\n    proveedor = newProveedor;\n}\n\nvoid Producto::mostrarInformacion() const {\n    cout << \"ID Producto: \" << idProducto << \"\\nNombre: \" << nombre << \"\\nTipo: \" << tipo << \"\\nCantidad: \" << cantidad << \"\\nCategor\u00eda: \" << categoria << \"\\nA\u00f1o: \" << a\u00f1o << \"\\nPrecio: \" << precio << std::endl;\n    proveedor->mostrarInformacion();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"food_delivery\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nstruct node\n{\n    int data;\n    struct node * next;\n    struct node * prev;\n};\nstruct node * head = NULL;\n\nvoid basaEkle(int data)\n{\n    struct node * newnode = new node();\n    newnode->data = data;\n    if (head== NULL)\n    {\n        newnode->next = NULL;\n        newnode->prev =NULL;\n        head = newnode;\n    }\n    else\n    {\n        newnode->prev= NULL;\n        newnode->next = head;\n        head->prev = newnode;\n        head = newnode;\n    }\n}\nvoid sonaEkle(int data)\n{\n    struct node * newnode = new node();\n    newnode->data = data;\n    if(head == NULL)\n    {\n        newnode->next = NULL;\n        newnode->prev = NULL;\n        head = newnode;\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp != NULL)\n        {\n            if (temp->next == NULL)\n            {\n                temp->next = newnode;\n                newnode->prev = temp;\n                newnode->next = NULL;\n                return;\n            }\n            temp = temp->next;\n        }\n    }\n}\nvoid ArayaEkle(int data,int sira)\n{\n    struct node * newnode = new node();\n    newnode->data = data;\n    if(head == NULL)\n    {\n        newnode->next = NULL;\n        newnode->prev = NULL;\n        head = newnode;\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp!=NULL)\n        {\n            if (temp->data == sira)\n            {\n                struct node * temp2 = temp->prev;\n                struct node *temp3  = temp;\n                temp2->next = newnode;\n                newnode->prev = temp2;\n                newnode->next =temp3;\n                temp3->prev = newnode;\n                break;\n            }\n\n            temp = temp->next;\n        }\n\n\n    }\n}\nvoid BastanSil()\n{\n    if (head == NULL)\n    {\n        cout<<\"Liste bos oldugu icin silinemedi\";\n    }\n    else\n    {\n        struct node * temp = head->next;\n        temp->prev = NULL;\n        delete head;\n        head = temp;\n    }\n}\n\n\nvoid SondanSil()\n{\n    if (head == NULL)\n    {\n        cout<<\"Liste bos oldugu icin silinemedi\";\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp !=NULL)\n        {\n            if(temp->next->next ==NULL)\n            {\n                delete temp->next;\n                temp->next = NULL;\n                break;\n\n            }\n            temp = temp->next;\n        }\n    }\n\n}\n\n\nvoid AradanSil(int silinecekSayi)\n{\n    if (head == NULL)\n    {\n        cout<<\"Liste bos oldugu icin silinemedi\";\n\n    }\n    else\n    {\n        struct node * temp = head;\n        while(temp != NULL)\n        {\n            if(temp->data == silinecekSayi)\n            {\n                struct node * temp2 = temp->prev;\n                struct node * temp3 = temp->next;\n                temp2->next = temp3;\n                temp3->prev =temp2;\n                delete temp;\n                cout<<endl<<\" Secilen sayi silindi\";\n                break;\n            }\n            temp = temp->next;\n        }\n    }\n\n\n}\n\n\nvoid Yazdir()\n{\n    if(head == NULL)\n    {\n        cout<<endl<<\"Liste bos\";\n\n    }\n    else\n    {\n        cout<<endl<<endl;\n        struct node * temp = head;\n        while(temp!=NULL)\n        {\n            cout<<temp->data<<\" \";\n            temp = temp->next;\n        }\n\n\n    }\n}\n\nint main()\n{\n    int sayi ,sayi2, secim;\n    while(1)\n        {\n            cout<<endl<<\"1- Basa ekle\"<<endl;\n            cout<<\"2- Sona ekle\"<<endl;\n            cout<<\"3- Araya ekle\"<<endl;\n            cout<<\"4- Bastan Sil\"<<endl;\n            cout<<\"5- Sondan Sil\"<<endl;\n            cout<<\"6- Aradan Sil\"<<endl;\n            cout<<\"7- Yazdir\"<<endl;\n            cout<<\"8- Cikis\"<<endl;\n            cin>>secim;\n            switch(secim)\n            {\n            case 1:\n                {\n                    cout<<endl<<\"Basa eklenecek sayiyi giriniz : \" ;\n                    cin>>sayi;\n                    basaEkle(sayi);\n                    break;\n                }\n            case 2:\n                {\n                    cout<<endl<<\"Sona eklenecek sayiyi giriniz : \" ;\n                    cin>>sayi;\n                    sonaEkle(sayi);\n                    break;\n                }\n            case 3:\n                {\n                    cout<<endl<<\"Araya eklenecek sayiyi giriniz : \" ;\n                    cin>>sayi;\n                    cout<<endl<<\"Hangi say\u00fddan \u00f6nce eklenecek : \" ;\n                    cin>>sayi2;\n                    ArayaEkle(sayi,sayi2);\n                    break;\n                }\n            case 4:\n                {\n                    cout<<endl<<\"Bastaki eleman silindi\" ;\n                    BastanSil();\n                    break;\n                }\n            case 5:\n                {\n                    cout<<endl<<\"Sondaki eleman silindi\" ;\n                    SondanSil();\n                    break;\n                }\n            case 6:\n                {\n                    cout<<endl<<\"Silinecek eleman\u00fd girin\" ;\n                    cin>>sayi;\n                    AradanSil(sayi",
    "#include<iostream>\n#include<cstdlib>\n\nusing namespace std;\n\nint SumFinder(int arr[], int* adr);\nint MaxFinder(int arr[3]);\nint MaxFinder(int arr[3][4]);//\u00ed\u00e5 \u00ef\u00ee\u00ed\u00ff\u00eb \u00ea\u00e0\u00ea \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00f2\u00fc \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00e1\u00e5\u00e7 \u00f3\u00ea\u00e0\u00e7\u00e0\u00ed\u00e8\u00ff \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0\u00e0\nint MaxFinder(int arr[3][4][3]);\nint main()\n{\n\tsetlocale(LC_ALL, \"ru\");\n\tsrand(time(NULL));\n\t//\u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 1\n\tconst int size = 100;\n\tint arr[size];\n\tint iter = 0;\n\tint* adr = &iter;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tarr[i] = rand() % 100;\n\t}\n\t//cout << \"\u00cc\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00e0\u00ff \u00f1\u00f3\u00ec\u00ec\u00e0 - \" << SumFinder(arr,adr);\n\t//\u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 2\n\tint arr2[3]{ -2,4,8 };\n\tint arr3[3][4];\n\tint arr4[3][4][3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tarr3[i][j] = rand() % 100;\n\t\t}\n\t\t\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tarr4[i][j][k] = rand() % 100;\n\t\t\t}\n\t\t}\n\t}\n\tcout << MaxFinder(arr2) << endl;\n\tcout << MaxFinder(arr3) << endl;\n\tcout << MaxFinder(arr4) << endl;\n\treturn 0;\n}\n\nint SumFinder(int arr[], int* adr)//\u00e2 \u00f0\u00e5\u00ea\u00f3\u00f0\u00f1\u00e8\u00ff \u00ef\u00ee\u00f7\u00e5\u00ec\u00f3 \u00f2\u00ee \u00ed\u00e8\u00ea\u00e0\u00ea \u00ed\u00e5 \u00f5\u00ee\u00f7\u00e5\u00f2 \u00e7\u00e0\u00ea\u00e0\u00ed\u00f7\u00e8\u00e2\u00e0\u00f2\u00fc\u00f1\u00ff \u00f5\u00ee\u00f2\u00fc \u00ff \u00e8 \u00f1\u00ea\u00e0\u00e7\u00e0\u00eb \u00ea\u00ee\u00e3\u00e4\u00e0 \u00e2\u00ee\u00e7\u00e2\u00f0\u00e0\u00f9\u00e0\u00f2\u00fc \u00e7\u00e0\u00ea\u00e0\u00ed\u00f7\u00e8\u00e2\u00e0\u00f2\u00fc\n{\n\tint sum = 0;\n\tint iter = *adr;\n\tif (iter == 91)\n\t{\n\t\treturn sum;\n\t}\n\n\tfor (int i = 99; i != 89; i--)\n\t{\n\t\tsum += arr[i - iter];\n\t}\n\titer++;\n\tcout << iter << endl;\n\t\n\tif (sum > SumFinder(arr,&iter))\n\t{\n\t\tsum = SumFinder(arr,&iter);\n\t\treturn sum;\n\t}\n\t\n\t\n}\n\nint MaxFinder(int arr[3])\n{\n\tint max = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nint MaxFinder(int arr[3][4])\n{\n\tint max = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (arr[i][j] > max)\n\t\t\t{\n\t\t\t\tmax = arr[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\n\nint MaxFinder(int arr[3][4][3])\n{\n\tint max = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tif (arr[i][j][k] > max)\n\t\t\t\t{\n\t\t\t\t\tmax = arr[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n#include <limits>\n\ntemplate <typename T>\nvoid ErrorInputCheck(T& input) {\n    while (std::cin.fail()) {\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        \n        std::cout << \"ERROR: Invalid Input (Try again): \";\n        std::cin >> input;\n        std::cout << \"------------------------------\" << std::endl;\n    }\n}\n\ndouble Calculate(std::vector<std::pair<double, int>>& grades) {\n    double qualityPoints = std::accumulate(grades.begin(), grades.end(), 1, [](double a, std::pair<double, int>& b){\n        return a + b.first * b.second;\n    });\n\n    double creditHours = std::accumulate(grades.begin(), grades.end(), 0, [](double a, std::pair<double, int>& b){\n        return a + b.second;\n    });\n\n    double result = qualityPoints / creditHours;\n    \n    return result;\n}\n\nstd::vector<std::pair<double, int>> Input() {\n    int len = 0;\n\n    std::cout << \"Enter the amount of classes you're taking: \";\n    std::cin >> len;\n    ErrorInputCheck(len);\n\n    std::vector<std::pair<double, int>> grades{};\n    for (int i = 1; i <= len; i++) {\n        double grade{};\n        double credit{};\n\n        std::cout << \"Enter the grade for grade \" << i << \": \";\n        std::cin >> grade;\n        ErrorInputCheck(grade);\n\n        std::cout << \"Enter the credit for grade \" << i << \": \";\n        std::cin >> credit;\n        ErrorInputCheck(credit);\n        std::cout << \"------------------------------\" << std::endl;\n\n        grades.push_back({grade, credit});\n    }\n\n    return grades;\n}\n\nint main() {\n    std::string end{};\n\n    while (end != \"q\") {\n        std::vector<std::pair<double, int>> grades = Input();\n\n        std::cout << \"Gpa Result: \";\n        std::cout << Calculate(grades) << std::endl;\n        std::cout << std::endl;\n\n        std::cout << \"Quit? (q): \";\n        std::cin >> end;\n        std::cout << std::endl;\n    }\n}",
    "#include <iostream>\r\n#include <fstream>\r\nusing namespace std;\r\nconst int MAX_COLUMNS = 6;\r\n\r\n//structure for keeping track of final turnaroundtime and waitingtime while in recursion\r\nstruct result{\r\n\tint* turnaroundTime;\r\n\tint* waitingTime;\r\n}r;\r\n\r\n//allocating structure for dynamic memory\r\nvoid allocateResultArrays(int size) {\r\n    r.turnaroundTime = new int[size];\r\n    r.waitingTime = new int[size];\r\n}\r\n\r\n//deallocating for preventing memory leaks\r\nvoid deallocateResultArrays() {\r\n    delete[] r.turnaroundTime;\r\n    delete[] r.waitingTime;\r\n}\r\n\r\n//sorting algorithm for the sorted arrival time\r\nvoid bubbleSort(int process[][MAX_COLUMNS], int size) {\r\n    for (int i = 0; i < size - 1; i++) \r\n        for (int j = 0; j < size - i - 1; j++) \r\n            if (process[j][1] > process[j + 1][1]) \r\n                for (int k = 0; k < MAX_COLUMNS; k++) \r\n                    swap(process[j][k], process[j + 1][k]);\r\n}\r\n\r\n//polymorphism function for printing table and gantt chart into txt via file handling\r\nvoid avgTime(int process[][MAX_COLUMNS], int size, int tempBurst[], ofstream& outFile){\r\n\tint total_wt = 0, total_tat = 0;\r\n\t\r\n\toutFile << \"\\n\\nProcess\\t\"<< \"AT\"<< \"  \\tBT \" << \"  \\tFT \" << \"     TAT \" << \" \\tWT\\n\";\r\n\t\r\n\tfor (int i=0; i<size; i++) { \r\n    \ttotal_tat += r.turnaroundTime[i];\r\n        total_wt += r.waitingTime[i];  \r\n        outFile<< process[i][0] << \"\\t\" << process[i][1] <<\"\\t\"<< tempBurst[i] << \"\\t\" \r\n\t\t<< process[i][3] <<\"\\t\" << r.turnaroundTime[i] <<\"\\t\" << r.waitingTime[i] <<endl; \r\n    } \r\n \toutFile << \"\\nAverage turn around time = \" << (float)total_tat / size; \r\n    outFile << \"\\nAverage waiting time = \" << (float)total_wt / size; \r\n}\r\n\r\n//polymorphism function for displaying table and gantt chart into console\r\nvoid avgTime(int process[][MAX_COLUMNS], int size, int tempBurst[]){\r\n\tint total_wt = 0, total_tat = 0;\r\n\t\r\n\tcout << \"Process\\t\"<< \"AT\"<< \"  \\tBT \" << \"  \\tFT \" << \"     TAT \" << \" \\tWT\\n\";\r\n\t\r\n\tfor (int i=0; i<size; i++) { \r\n    \ttotal_tat += r.turnaroundTime[i];\r\n        total_wt += r.waitingTime[i];  \r\n        cout<< process[i][0] << \"\\t\" << process[i][1] <<\"\\t\"<< tempBurst[i] << \"\\t\" << process[i][3] <<\"\\t\" \r\n\t\t<< r.turnaroundTime[i] <<\"\\t\" << r.waitingTime[i] <<endl; \r\n    } \r\n \tcout << \"\\nAverage turn around time = \" << (float)total_tat / size; \r\n    cout << \"\\nAverage waiting time = \" << (float)total_wt / size; \r\n}\r\n\r\n//srtf preemptive function that recursively calls itself until all remaining BurstTime is zero\r\nvoid srtf(int process[][MAX_COLUMNS], int timer, int tempBurst[], int size, int remainingTime[]) {\r\n    int minIndex = -1;\r\n    int minRemainingTime = INT_MAX;\r\n\r\n    for (int i = 0; i < size; ++i) {\r\n        if (process[i][1] <= timer && remainingTime[i] > 0 && remainingTime[i] < minRemainingTime) {\r\n            minRemainingTime = remainingTime[i];\r\n            minIndex = i;\r\n        }\r\n    }\r\n\r\n    if (minIndex == -1) {\r\n        // If no process can be executed now, find the next arrival time\r\n        int nextArrival = INT_MAX;\r\n        for (int i = 0; i < size; ++i) {\r\n            if (process[i][1] > timer && process[i][1] < nextArrival) {\r\n                nextArrival = process[i][1];\r\n            }\r\n        }\r\n        // If there is a next arrival time, move the timer to that time\r\n        if (nextArrival != INT_MAX) {\r\n            srtf(process, nextArrival, tempBurst, size, remainingTime);\r\n        }\r\n        return;\r\n    }\r\n\r\n    int executionTime = min(1, remainingTime[minIndex]);\r\n    process[minIndex][2] -= executionTime;\r\n    timer += executionTime;\r\n    process[minIndex][3] = timer;\r\n    process[minIndex][4] = process[minIndex][3] - process[minIndex][1];\r\n    process[minIndex][5] = process[minIndex][4] - tempBurst[minIndex];\r\n\r\n    cout << \"Process \" << process[minIndex][0] << \" executed when time is \" << timer << endl;\r\n\r\n    if (process[minIndex][2] == 0) {\r\n        r.turnaroundTime[minIndex] = process[minIndex][3] - process[minIndex][1];\r\n        r.waitingTime[minIndex] = process[minIndex][5];\r\n    }\r\n    remainingTime[minIndex] = process[minIndex][2];\r\n\r\n    // Sort processes based on remaining burst time\r\n    bubbleSort(process, size);\r\n\r\n    srtf(process, timer, tempBurst, size, remainingTime);\r\n}\r\n\r\n//priority preemptive function that recursively calls itself until all remaining BurstTime is zero\r\nvoid prio(int process[][MAX_COLUMNS], int priority[], int timer, int tempBurst[], int size) {\r\n    bool allProcessesDone = true;\r\n    int minPriorityIndex = -1;\r\n    int minPriority = INT_MAX;\r\n\r\n    // Find the minimum priority process that has arrived and not yet completed\r\n    for (int i = 0; i < size; ++i) {\r\n        if (process[i][2] > 0 && process[i][1] <= timer) {\r\n            allProcessesDone = false;\r\n\r\n            if (priority[i] < minPriority) {\r\n                minPriority = priority[i];\r\n                minPriorityIndex = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // If no process can be executed now, find the next arrival time\r\n    if (minPriority",
    "/***********************************************************************\r\nMatr.-Nr:                     3071014\r\nNachname/Surname:             Bhuyan\r\nVorname/Given name:           Mohammad Rakib\r\nUni-Email:                    mohammad.bhuyan@stud.uni-due.de\r\nStudiengang/Course of studis: ISE Computer Engineering\r\n***********************************************************************/\r\n\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Bus\r\n{\r\n    int numberOfPassengers;\r\n    int maxNumberOfPassengers;\r\n};\r\n\r\nvoid init(Bus &bus)\r\n{\r\n    bus.numberOfPassengers = 0;\r\n    bus.maxNumberOfPassengers = 0;\r\n}\r\n\r\nvoid output(Bus &bus)\r\n{\r\n    cout << \"bus data: passengers: actual: \" << bus.numberOfPassengers << \" maximum in simulation: \" << bus.maxNumberOfPassengers << endl;\r\n}\r\n\r\nstruct Stop\r\n{\r\n    string stopName;\r\n    int numberOfStops;\r\n    int numberPassengersGotOn;\r\n    int numberPassengersGotOff;\r\n    Stop *nextStop;\r\n};\r\n\r\nstruct Stop *head = nullptr;\r\n\r\nStop* generate_stop(string newStopName)\r\n{\r\n    Stop *newStop = new Stop; // creating a new stop variable on the heap\r\n    newStop->stopName = newStopName; // setting the name of the stop to the passed parameter\r\n    newStop->numberOfStops = 0;\r\n    newStop->numberPassengersGotOn = 0;\r\n    newStop->numberPassengersGotOff = 0;\r\n    newStop->nextStop = nullptr;\r\n    return newStop;\r\n}\r\n\r\nStop *generate_circular_line(int n)\r\n{\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        const string constant = \"Bus Stop \";\r\n        string busStopNumber = to_string(n-i); //in this way, we make sure that buses are outputted in ascending order (from 1 to 5) instead of descending order if we did simply to_string(i)\r\n        string fullStopName = constant + busStopNumber;\r\n        Stop *newStop = new Stop;\r\n        newStop = generate_stop(fullStopName);\r\n        newStop->nextStop = head;\r\n        head = newStop;\r\n    }\r\n    return head;\r\n}\r\n\r\nvoid output(Stop *head)\r\n{\r\n    cout << head->stopName <<  \":      sums: off: \" << head->numberPassengersGotOff << \"    on: \" << head->numberPassengersGotOn << \"   stops: \" << head->numberOfStops << endl;\r\n}\r\n\r\nvoid output_whole_line(Stop *head)\r\n{\r\n    Stop *iterator = head; //iterator is not treated as a special keyword here, it is just a normal pointer variable and we are using it to iterate through the list\r\n    if (head != NULL)\r\n    {\r\n        while (iterator != nullptr)\r\n        {\r\n            output(iterator);\r\n            iterator = iterator->nextStop;\r\n        }\r\n    }\r\n    if (head == NULL)\r\n    {\r\n        cout << \"The list is empty\" << endl;\r\n    }\r\n}\r\n\r\nvoid simulate_get_on_off(Bus &bus, Stop *stop, int numberPassengersGettingOff, int numberPassengersGettingOn)\r\n{\r\n    if(numberPassengersGettingOff > bus.numberOfPassengers) // setting the number of passengers getting off the bus exactly to the number of passengers on the bus in order not to get a negative number of passengers on the bus in case the if-condition holds\r\n    {\r\n        numberPassengersGettingOff = bus.numberOfPassengers;\r\n    }\r\n    cout << \"simulate \" << stop->stopName << \":     getting off: \" << numberPassengersGettingOff << \" getting on: \" << numberPassengersGettingOn << endl;\r\n    bus.numberOfPassengers = bus.numberOfPassengers - numberPassengersGettingOff + numberPassengersGettingOn; // updating the number of passengers on the bus\r\n    stop->numberOfStops = stop->numberOfStops + 1; // increase the total number of times a bus stopped at the station\r\n    stop->numberPassengersGotOn = stop->numberPassengersGotOn + numberPassengersGettingOn; // adding the passengers who got in as a result of this function's call to the passengers who have gotten in so far\r\n    stop->numberPassengersGotOff = stop->numberPassengersGotOff + numberPassengersGettingOff;\r\n    if ((numberPassengersGettingOff || numberPassengersGettingOn) != 0) // if necessary, update the maximum number of passengers in the simulation\r\n    {\r\n        if (bus.maxNumberOfPassengers < bus.numberOfPassengers)\r\n        {\r\n            bus.maxNumberOfPassengers = bus.numberOfPassengers;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    Bus bus;\r\n    Stop *firstStop = head;\r\n    Stop *currentStop;\r\n    init(bus);\r\n    cout << \"input number of bus stops: \";\r\n    int numberOfStops;\r\n    cin >> numberOfStops;\r\n    head = generate_circular_line(numberOfStops);\r\n    firstStop = head;\r\n    char selection;\r\n    do\r\n    {\r\n        cout << \"Simulation Bus Circular Line\" << endl\r\n        << \"0 End\" << endl\r\n        << \"1 Show data of bus\" << endl\r\n        << \"2 Show all bus stops\" << endl\r\n        << \"3 Simulate bus stops\" << endl;\r\n        cin >> selection;\r\n        switch (selection)\r\n        {\r\n            case '0':\r\n                break;\r\n            case '1':\r\n            {\r\n                output(bus);\r\n                break;\r\n            }\r\n            case '2':\r\n            {\r\n                output_whole_line(firstStop);\r\n                break;\r\n            }\r\n            case '3':\r\n         ",
    "// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline\n// - Desktop GL: 2.x 3.x 4.x\n// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)\n// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!\n//  [x] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).\n\n// About WebGL/ES:\n// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.\n// - This is done automatically on iOS, Android and Emscripten targets.\n// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" and variants, fixing regression on distros missing a symlink.\n//  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" instead of \"libGL.so.1\", accommodating for NetBSD systems having only \"libGL.so.3\" available. (#6983)\n//  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)\n//  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)\n//  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)\n//  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)\n//  2023-03-23: OpenGL: Properly restoring \"no shader program bound\" if it was the case prior to running the rendering function. (#6267, #6220, #6224)\n//  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)\n//  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)\n//  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.\n//  2022-05-23: OpenGL: Reworking 2021-12-15 \"Using buffer orphaning\" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).\n//  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.\n//  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.\n//  2021-08-23: OpenGL: Fixed ES 3.0 shader (\"#version 300 es\") use normal precision floats to avoid wobbly rendering at HD resolutions.\n//  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.\n//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.\n//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when \"GL_ARB_clip_control\" extension is detected, inside of just OpenGL 4.5 version.\n//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.\n//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.\n//  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.\n//  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.\n//  2020-10-15: OpenGL: Use glGetString(GL_VERSION) instead of glGetIntegerv(GL_MAJOR_VERSION, ...) when the later returns zero (e.g. Desktop GL 2.x)\n//  2020-09-17: OpenGL: Fix to avoid compiling/calling glBindSampler() on ES or pre 3.3 cont",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"api_model_creation_b\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/glut.h>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nconst GLsizei ARROW_LINE_LENGTH = 8;\r\nconst GLsizei DISTANCE_BETWEEN_AXIS_AND_CHAR = 15;\r\nconst float INCREASE_IN_CURVES_FOR_SMOOTHNESS = 0.01;\r\n\r\n// pop-up window sizes\r\nGLsizei windowWidth = 500;\r\nGLsizei windowHeight = 500;\r\n\r\n// parametres y-axis\r\nGLfloat beginingYAxisY = 0;\r\nGLfloat endingYAxisY = windowHeight;\r\nGLfloat widthYAxis = (windowWidth / 2);\r\n\r\n// parametres of x-axis\r\nGLfloat beginingXAxisX = 0;\r\nGLfloat endingXAxisX = windowWidth;\r\nGLfloat heightXAxis = (windowHeight / 2);\r\n\r\n// flags when something is drawn or not\r\nGLboolean areControlLinesDrawn = GL_TRUE;\r\nGLboolean areControlPointsDrawn = GL_TRUE;\r\nGLboolean areFunctionsDrawn = GL_FALSE;\r\n\r\n// colors of the Bezier curve\r\nGLfloat curveRedColor = 1.0f;\r\nGLfloat curveBlueColor = 0.0f;\r\nGLfloat curveGreenColor = 0.0f;\r\n\r\n// colors of the control lines\r\nGLfloat lineRedColor = 0.0f;\r\nGLfloat lineBlueColor = 1.0f;\r\nGLfloat lineGreenColor = 0.0f;\r\n\r\nchar coordinateAxesSymbols[] = { 'x', 'y', 'T', 'T' };\r\nint charactersXCoordinates[] = { endingXAxisX - DISTANCE_BETWEEN_AXIS_AND_CHAR, widthYAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR,\r\n\t\t\t\t\t\t\t\t beginingXAxisX + DISTANCE_BETWEEN_AXIS_AND_CHAR, widthYAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR };\r\nint charactersYCoordinates[] = { heightXAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR, endingYAxisY - DISTANCE_BETWEEN_AXIS_AND_CHAR,\r\n\t\t\t\t\t\t\t\t heightXAxis + DISTANCE_BETWEEN_AXIS_AND_CHAR, beginingYAxisY + DISTANCE_BETWEEN_AXIS_AND_CHAR };\r\n\r\nstruct Point\r\n{\r\n\tGLfloat x;\r\n\tGLfloat y;\r\n\r\n\tPoint(GLfloat x, GLfloat y) :x(x), y(y) {}\r\n\r\n\tPoint() = default;\r\n};\r\n\r\nvector<Point> controlPoints;\r\nvector<Point> xFuncPoints;\r\nvector<Point> yFuncPoints;\r\n\r\nvoid init()\r\n{\r\n\tglClearColor(0.0, 0.0, 0.0, 0.0);\r\n\r\n\t// reduce jagged edges\r\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\tglEnable(GL_BLEND);\r\n\tglEnable(GL_LINE_SMOOTH);\r\n\tglHint(GL_LINE_SMOOTH_HINT, GL_LINEAR);\r\n\tglEnable(GLUT_MULTISAMPLE);\r\n}\r\n\r\nvoid drawPoint(Point point)\r\n{\r\n\tglBegin(GL_POINTS);\r\n\tglVertex2f(point.x, point.y);\r\n\tglEnd();\r\n\tglFlush();\r\n}\r\n\r\nvoid drawLine(Point first, Point second)\r\n{\r\n\tglBegin(GL_LINES);\r\n\tglVertex2f(first.x, first.y);\r\n\tglVertex2f(second.x, second.y);\r\n\tglEnd();\r\n\tglFlush();\r\n}\r\n\r\nvoid drawCoordinateSystem()\r\n{\r\n\t//white\r\n\tglColor3f(1.0, 1.0, 1.0);\r\n\r\n\tPoint leftPointOfXAxis(beginingXAxisX, heightXAxis);\r\n\tPoint rightPointOfXAxis(endingXAxisX, heightXAxis);\r\n\tPoint bottomPointOfYAxis(widthYAxis, beginingYAxisY);\r\n\tPoint upperPointOfYAxis(widthYAxis, endingYAxisY);\r\n\r\n\t// draw coordinate axes\r\n\tdrawLine(leftPointOfXAxis, rightPointOfXAxis);\r\n\tdrawLine(bottomPointOfYAxis, upperPointOfYAxis);\r\n\r\n\t// draw all the arrows\r\n\tdrawLine({ endingXAxisX, heightXAxis }, { endingXAxisX - ARROW_LINE_LENGTH, heightXAxis + ARROW_LINE_LENGTH });\r\n\tdrawLine({ endingXAxisX, heightXAxis }, { endingXAxisX - ARROW_LINE_LENGTH, heightXAxis - ARROW_LINE_LENGTH });\r\n\tdrawLine({ beginingXAxisX, heightXAxis }, { beginingXAxisX + ARROW_LINE_LENGTH, heightXAxis + ARROW_LINE_LENGTH });\r\n\tdrawLine({ beginingXAxisX, heightXAxis }, { beginingXAxisX + ARROW_LINE_LENGTH, heightXAxis - ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, endingYAxisY }, { widthYAxis + ARROW_LINE_LENGTH, endingYAxisY - ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, endingYAxisY }, { widthYAxis - ARROW_LINE_LENGTH, endingYAxisY - ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, beginingYAxisY }, { widthYAxis + ARROW_LINE_LENGTH, beginingYAxisY + ARROW_LINE_LENGTH });\r\n\tdrawLine({ widthYAxis, beginingYAxisY }, { widthYAxis - ARROW_LINE_LENGTH, beginingYAxisY + ARROW_LINE_LENGTH });\r\n\r\n\t// print symbols\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tglRasterPos2i(charactersXCoordinates[i], charactersYCoordinates[i]);\r\n\t\tglutBitmapCharacter(GLUT_BITMAP_9_BY_15, coordinateAxesSymbols[i]);\r\n\t\t\r\n\t}\r\n}\r\n\r\nvoid computeXFuncPoints()\r\n{\r\n\tint size = controlPoints.size();\r\n\txFuncPoints.resize(size);\r\n\r\n\tfor (int i = 1; i <= size; i++)\r\n\t{\r\n\t\txFuncPoints[i - 1].y = (windowHeight / 2) - i * ((windowHeight / 2) / (size + 1));\r\n\t\t// x coordinate is the same\r\n\t\txFuncPoints[i - 1].x = controlPoints[i - 1].x;\r\n\t}\r\n}\r\n\r\nvoid computeYFuncPoints()\r\n{\r\n\tint size = (int)controlPoints.size();\r\n\tyFuncPoints.resize(size);\r\n\r\n\tfor (int i = 1; i <= size; i++)\r\n\t{\r\n\t\tyFuncPoints[i - 1].x = (windowWidth / 2) - i * ((windowWidth / 2) / (size + 1));\r\n\t\t// y coordinate stays the same\r\n\t\tyFuncPoints[i - 1].y = controlPoints[i - 1].y;\r\n\t}\r\n}\r\n\r\n// calculate point for some t\r\nPoint computeBezierPoint(int r, int index, double valueT, vector<Point>& points)\r\n{\r\n\tif (r == 0)\r\n\t\treturn points[index];\r\n\r\n\tPoint p1 = computeBezierPoint(r - 1, index, valueT, points);\r\n\tPoint p2 = computeBezierPoint(r - 1, index + 1, valueT, points);\r\n\r\n\tPoint newPt;\r\n\tnewPt.x = (1 - valueT) * p1.x + valueT * p2.x;\r\n\tnewPt.y = (1 - valueT) * p1.y + valueT * p2.y;\r\n\r\n\treturn newPt;\r\n}\r\n\r\n// this is where we draw the curve\r\nvoid computeBezier(vector<Point>& points)\r\n{\r\n\tglColor3f(curveR",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* WiFi Example\n * Copyright (c) 2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"mbed.h\"\n#include \"TCPSocket.h\"\n\n#define WIFI_IDW0XX1    2\n\n#if (defined(TARGET_DISCO_L475VG_IOT01A) || defined(TARGET_DISCO_F413ZH))\n#include \"ISM43362Interface.h\"\nISM43362Interface wifi(MBED_CONF_APP_WIFI_SPI_MOSI, MBED_CONF_APP_WIFI_SPI_MISO, MBED_CONF_APP_WIFI_SPI_SCLK, MBED_CONF_APP_WIFI_SPI_NSS, MBED_CONF_APP_WIFI_RESET, MBED_CONF_APP_WIFI_DATAREADY, MBED_CONF_APP_WIFI_WAKEUP, false);\n\n#else // External WiFi modules\n\n#if MBED_CONF_APP_WIFI_SHIELD == WIFI_IDW0XX1\n#include \"SpwfSAInterface.h\"\nSpwfSAInterface wifi(MBED_CONF_APP_WIFI_TX, MBED_CONF_APP_WIFI_RX);\n#endif // MBED_CONF_APP_WIFI_SHIELD == WIFI_IDW0XX1\n\n#endif\n\nconst char *sec2str(nsapi_security_t sec)\n{\n    switch (sec) {\n        case NSAPI_SECURITY_NONE:\n            return \"None\";\n        case NSAPI_SECURITY_WEP:\n            return \"WEP\";\n        case NSAPI_SECURITY_WPA:\n            return \"WPA\";\n        case NSAPI_SECURITY_WPA2:\n            return \"WPA2\";\n        case NSAPI_SECURITY_WPA_WPA2:\n            return \"WPA/WPA2\";\n        case NSAPI_SECURITY_UNKNOWN:\n        default:\n            return \"Unknown\";\n    }\n}\n\nint scan_demo(WiFiInterface *wifi)\n{\n    WiFiAccessPoint *ap;\n\n    printf(\"Scan:\\n\");\n\n    int count = wifi->scan(NULL,0);\n    printf(\"%d networks available.\\n\", count);\n\n    /* Limit number of network arbitrary to 15 */\n    count = count < 15 ? count : 15;\n\n    ap = new WiFiAccessPoint[count];\n    count = wifi->scan(ap, count);\n    for (int i = 0; i < count; i++)\n    {\n        printf(\"Network: %s secured: %s BSSID: %hhX:%hhX:%hhX:%hhx:%hhx:%hhx RSSI: %hhd Ch: %hhd\\n\", ap[i].get_ssid(),\n               sec2str(ap[i].get_security()), ap[i].get_bssid()[0], ap[i].get_bssid()[1], ap[i].get_bssid()[2],\n               ap[i].get_bssid()[3], ap[i].get_bssid()[4], ap[i].get_bssid()[5], ap[i].get_rssi(), ap[i].get_channel());\n    }\n\n    delete[] ap;\n    return count;\n}\n\nvoid http_demo(NetworkInterface *net)\n{\n    TCPSocket socket;\n    nsapi_error_t response;\n\n    printf(\"Sending HTTP request to www.example.com...\\n\");\n\n    // Open a socket on the network interface, and create a TCP connection to www.arm.com\n    socket.open(net);\n    response = socket.connect(\"www.example.com\", 80);\n    if(0 != response) {\n        printf(\"Error connecting: %d\\n\", response);\n        socket.close();\n        return;\n    }\n\n    // Send a simple http request\n    char sbuffer[] = \"GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n\";\n    nsapi_size_t size = strlen(sbuffer);\n    response = 0;\n    while(size)\n    {\n        response = socket.send(sbuffer+response, size);\n        if (response < 0) {\n            printf(\"Error sending data: %d\\n\", response);\n            socket.close();\n            return;\n        } else {\n            size -= response;\n            // Check if entire message was sent or not\n            printf(\"sent %d [%.*s]\\n\", response, strstr(sbuffer, \"\\r\\n\")-sbuffer, sbuffer);\n        }\n    }\n\n    // Recieve a simple http response and print out the response line\n    char rbuffer[64];\n    response = socket.recv(rbuffer, sizeof rbuffer);\n    if (response < 0) {\n        printf(\"Error receiving data: %d\\n\", response);\n    } else {\n        printf(\"recv %d [%.*s]\\n\", response, strstr(rbuffer, \"\\r\\n\")-rbuffer, rbuffer);\n    }\n\n    // Close the socket to return its memory and bring down the network interface\n    socket.close();\n}\n\nint main()\n{\n    int count = 0;\n\n    printf(\"WiFi example\\n\\n\");\n\n    count = scan_demo(&wifi);\n    if (count == 0) {\n        printf(\"No WIFI APNs found - can't continue further.\\n\");\n        return -1;\n    }\n\n    printf(\"\\nConnecting to %s...\\n\", MBED_CONF_APP_WIFI_SSID);\n    int ret = wifi.connect(MBED_CONF_APP_WIFI_SSID, MBED_CONF_APP_WIFI_PASSWORD, NSAPI_SECURITY_WPA_WPA2);\n    if (ret != 0) {\n        printf(\"\\nConnection error\\n\");\n        return -1;\n    }\n\n    printf(\"Success\\n\\n\");\n    printf(\"MAC: %s\\n\", wifi.get_mac_address());\n    printf(\"IP: %s\\n\", wifi.get_ip_address());\n    printf(\"Netmask: %s\\n\", wifi.get_netmask());\n    printf(\"Gateway: %s\\n\", wifi.get_gateway());\n    printf(\"RSSI: %d\\n\\n\", wifi.get_rssi());\n\n    http_demo(&wifi);\n\n    wifi.disconnect();\n\n    printf(\"\\nDone\\n\");\n}\n",
    "/*\r\n\tkeyCurControl.cpp ver 1.3\r\n*/\r\n\r\n#include \"keyCurControl.h\"\r\n#include <conio.h>\r\n#include \"point.h\"\r\n#include <Windows.h>\r\n#include \"blockStageControl.h\"\r\n\r\n#define KEY_SENSITIVITY\t120\r\n#define\tSYS_DELAY\t30\r\n\r\n#define LEFT\t75\r\n#define\tRIGHT\t77\r\n#define UP\t72\r\n#define\tDOWN\t80\r\n#define PAUSE\t112\r\n#define SPACE\t32\t\r\n\r\nstatic int keyDelayRate;\r\nHANDLE hConsoleOut;\r\n\r\n/*\r\n\tvoid RemoveCursor(void) : removing the blinking cursor\r\n*/\r\nvoid RemoveCursor(void)\r\n{\r\n\tCONSOLE_CURSOR_INFO curInfo;\r\n\thConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tGetConsoleCursorInfo(hConsoleOut, &curInfo);\r\n\tcurInfo.bVisible = FALSE;\r\n\tSetConsoleCursorInfo(hConsoleOut, &curInfo);\r\n}\r\n\r\n/*\r\n\tPoint GetCurrentCursorPosition(void) :\r\n\treturning structural variable that contains current cursor position info.\r\n*/\r\nPoint GetCurrentCursorPosition(void)\r\n{\r\n\tPoint curPoint;\r\n\thConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tCONSOLE_SCREEN_BUFFER_INFO curInfo;\r\n\r\n\tGetConsoleScreenBufferInfo(hConsoleOut, &curInfo);\r\n\tcurPoint.x = curInfo.dwCursorPosition.X;\r\n\tcurPoint.y = curInfo.dwCursorPosition.Y;\r\n\r\n\treturn curPoint;\r\n}\r\n\r\n/*\r\n\tvoid SetCurrentCursorPosition(int x, int y) :\r\n\tsetting cursor position\r\n*/\r\nvoid SetCurrentCursorPosition(int x, int y)\r\n{\r\n\thConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tCOORD pos = { (SHORT)x, (SHORT)y };\r\n\tSetConsoleCursorPosition(hConsoleOut, pos);\r\n}\r\n\r\n/*\r\n\tvoid ProcessKeyInput(void) : it processes key input\r\n*/\r\nint ProcessKeyInput(void)\r\n{\r\n\tint i, key;\r\n\tfor (i = 0; i < KEY_SENSITIVITY; i++)\r\n\t{\r\n\t\tif (_kbhit() != 0)\r\n\t\t{\r\n\t\t\tkey = _getch();\r\n\r\n\t\t\tswitch (key)\r\n\t\t\t{\r\n\t\t\tcase LEFT:\r\n\t\t\t\tShiftLeft();\r\n\t\t\t\tbreak;\r\n\t\t\tcase RIGHT:\r\n\t\t\t\tShiftRight();\r\n\t\t\t\tbreak;\r\n\t\t\tcase UP:\r\n\t\t\t\tRotateBlock();\r\n\t\t\t\tbreak;\r\n\t\t\tcase SPACE:\r\n\t\t\t\tPutDownBlock();\r\n\t\t\t\treturn 1;\r\n\t\t\tcase PAUSE:\r\n\t\t\t\twhile (1)\r\n\t\t\t\t{\r\n\t\t\t\t\tkey = _getch();\r\n\t\t\t\t\tif (key == PAUSE)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (i % keyDelayRate == 0)\r\n\t\t\tSleep(SYS_DELAY);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n/*\r\n\tvoid InitKeyDelayRate(int rate) : it adjusts block's dropping rate,\r\n\thigher the rate, higher dropping speed\r\n*/\r\nvoid InitKeyDelayRate(int rate)\r\n{\r\n\tif (rate < 1)\r\n\t\treturn;\r\n\tkeyDelayRate = rate;\r\n}\r\n\r\n/*\r\n\tvoid KeyDelaySpeedControl(int addSpeed) : it adjusts the block's dropping rate\r\n*/\r\nvoid KeyDelaySpeedControl(int addSpeed)\r\n{\r\n\tkeyDelayRate += addSpeed;\r\n}\r\n\r\nvoid ReturnHandle(void)\r\n{\r\n\tCloseHandle(hConsoleOut);\r\n}\r\n\r\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass DietType {\r\npublic:\r\n    struct DietPlan {\r\n        string vegbreakfast;\r\n        int breakfastCalories;\r\n        string veglunch;\r\n        int lunchCalories;\r\n        string vegsnacks;\r\n        int snacksCalories;\r\n        string vegdinner;\r\n        int dinnerCalories;\r\n        string nonvegbreakfast;\r\n        string nonveglunch;\r\n        string nonvegsnacks;\r\n        string nonvegdinner;\r\n    };\r\n\r\npublic:\r\n    DietType() {\r\n        // Set default values for all variables\r\n        dietPlan.vegbreakfast = \"Oatmeal with fruits\";\r\n        dietPlan.breakfastCalories = 300;\r\n        dietPlan.veglunch = \"Vegetable salad with tofu\";\r\n        dietPlan.lunchCalories = 400;\r\n        dietPlan.vegsnacks = \"Carrot sticks with hummus\";\r\n        dietPlan.snacksCalories = 150;\r\n        dietPlan.vegdinner = \"Quinoa with mixed vegetables\";\r\n        dietPlan.dinnerCalories = 450;\r\n        dietPlan.nonvegbreakfast = \"Scrambled eggs with whole grain toast\";\r\n        dietPlan.nonveglunch = \"Grilled chicken breast with brown rice\";\r\n        dietPlan.nonvegsnacks =  \"Greek yogurt with almonds\";\r\n        dietPlan.nonvegdinner = \"Baked salmon with steamed vegetables\" ;\r\n    }\r\n\r\n    virtual void printDietPlan() const = 0;\r\n\r\npublic:\r\n    DietPlan dietPlan;\r\n};\r\n\r\nclass VegDiet : public DietType {\r\npublic:\r\n    VegDiet(string goal) : goal(goal) {\r\n        // Adjust calories based on goal\r\n        if (goal == \"Lose\") {\r\n            dietPlan.breakfastCalories -= 100;\r\n            dietPlan.lunchCalories -= 100;\r\n            dietPlan.snacksCalories -= 50;\r\n            dietPlan.dinnerCalories -= 100;\r\n        } else if (goal == \"Gain\") {\r\n            dietPlan.breakfastCalories += 100;\r\n            dietPlan.lunchCalories += 100;\r\n            dietPlan.snacksCalories += 50;\r\n            dietPlan.dinnerCalories += 100;\r\n        }\r\n    }\r\n\r\n    void printDietPlan() const override {\r\n        cout << \"----- Veg Diet Plan -----\" << endl;\r\n        cout << \"Breakfast: \" << dietPlan.vegbreakfast << \" (Calories: \" << dietPlan.breakfastCalories << \")\" << endl;\r\n        cout << \"Lunch: \" << dietPlan.veglunch << \" (Calories: \" << dietPlan.lunchCalories << \")\" << endl;\r\n        cout << \"Snacks: \" << dietPlan.vegsnacks << \" (Calories: \" << dietPlan.snacksCalories << \")\" << endl;\r\n        cout << \"Dinner: \" << dietPlan.vegdinner << \" (Calories: \" << dietPlan.dinnerCalories << \")\" << endl;\r\n    }\r\n\r\npublic:\r\n    string goal;\r\n};\r\n\r\nclass NonVegDiet : public DietType {\r\npublic:\r\n    NonVegDiet(string goal) : goal(goal) {\r\n        // Adjust calories based on goal\r\n        if (goal == \"Lose\") {\r\n            dietPlan.breakfastCalories -= 100;\r\n            dietPlan.lunchCalories -= 100;\r\n            dietPlan.snacksCalories -= 50;\r\n            dietPlan.dinnerCalories -= 100;\r\n        } else if (goal == \"Gain\") {\r\n            dietPlan.breakfastCalories += 100;\r\n            dietPlan.lunchCalories += 100;\r\n            dietPlan.snacksCalories += 50;\r\n            dietPlan.dinnerCalories += 100;\r\n        }\r\n    }\r\n\r\n    void printDietPlan() const override {\r\n        cout << \"----- Non Veg Diet Plan -----\" << endl;\r\n        cout << \"Breakfast: \" << dietPlan.nonvegbreakfast << \" (Calories: \" << dietPlan.breakfastCalories << \")\" << endl;\r\n        cout << \"Lunch: \" << dietPlan.nonveglunch << \" (Calories: \" << dietPlan.lunchCalories << \")\" << endl;\r\n        cout << \"Snacks: \" << dietPlan.nonvegsnacks << \" (Calories: \" << dietPlan.snacksCalories << \")\" << endl;\r\n        cout << \"Dinner: \" << dietPlan.nonvegdinner << \" (Calories: \" << dietPlan.dinnerCalories << \")\" << endl;\r\n    }\r\n\r\npublic:\r\n    string goal;\r\n};\r\n\r\n\r\nint main() {\r\n    char dietChoice;\r\n    cout << \"Are you vegetarian or non-vegetarian? (V/N): \";\r\n    cin >> dietChoice;\r\n\r\n    string goal;\r\n    cout << \"Select your weight goal (Maintain/Lose/Gain): \";\r\n    cin >> goal;\r\n\r\n    DietType *dietType;\r\n\r\n    if (dietChoice == 'V' || dietChoice == 'v') {\r\n        dietType = new VegDiet(goal);\r\n    } else if (dietChoice == 'N' || dietChoice == 'n') {\r\n        dietType = new NonVegDiet(goal);\r\n    } else {\r\n        cout << \"Invalid choice!\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    dietType->printDietPlan();\r\n\r\n    delete dietType;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <bitset>\n\nvoid invertBitsInRange(unsigned char* ptr, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        for (int j = 0; j < 8; ++j) {   // \u00ee\u00e1\u00f0\u00e0\u00e1\u00e0\u00f2\u00fb\u00e2\u00e0\u00e5\u00ec \u00ea\u00e0\u00e6\u00e4\u00fb\u00e9 \u00e1\u00e8\u00f2 \u00e2 \u00f2\u00e5\u00ea\u00f3\u00f9\u00e5\u00ec \u00e1\u00e0\u00e9\u00f2\u00e5\n            if (j % 8 == 0) {           // \u00e8\u00ed\u00e2\u00e5\u00f0\u00f2\u00e8\u00f0\u00f3\u00e5\u00ec \u00f2\u00ee\u00eb\u00fc\u00ea\u00ee \u00ea\u00e0\u00e6\u00e4\u00fb\u00e9 \u00e2\u00ee\u00f1\u00fc\u00ec\u00ee\u00e9 \u00e1\u00e8\u00f2\n                *ptr ^= (1 << j);       // \u00e8\u00ed\u00e2\u00e5\u00f0\u00f2\u00e8\u00f0\u00f3\u00e5\u00ec \u00e1\u00e8\u00f2 \u00f1 \u00ef\u00ee\u00ec\u00ee\u00f9\u00fc\u00fe \u00ef\u00ee\u00e1\u00e8\u00f2\u00ee\u00e2\u00ee\u00e9 \u00ee\u00ef\u00e5\u00f0\u00e0\u00f6\u00e8\u00e8 XOR\n            }\n        }\n        ++ptr;                           // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec \u00ea \u00f1\u00eb\u00e5\u00e4\u00f3\u00fe\u00f9\u00e5\u00ec\u00f3 \u00e1\u00e0\u00e9\u00f2\u00f3\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"ru\");\n    unsigned char memory[] = { 0b10011100, 0b11000111, 0b11101100, 0b10000110 }; // \u00cf\u00f0\u00e8\u00ec\u00e5\u00f0 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e2 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8\n    size_t length = sizeof(memory);                                              // \u00cf\u00ee\u00eb\u00f3\u00f7\u00e0\u00e5\u00ec \u00e4\u00eb\u00e8\u00ed\u00f3 \u00f3\u00f7\u00e0\u00f1\u00f2\u00ea\u00e0 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8 \u00e2 \u00e1\u00e0\u00e9\u00f2\u00e0\u00f5\n\n    std::cout << \"\u00c8\u00f1\u00f5\u00ee\u00e4\u00ed\u00fb\u00e5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5: \" << std::endl;\n    for (size_t i = 0; i < length; ++i) {\n        std::cout << std::bitset<8>(memory[i]) << \" \";\n    }\n    std::cout << std::endl;\n\n    invertBitsInRange(memory, length);\n\n    std::cout << \"\u00c8\u00ed\u00e2\u00e5\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5: \" << std::endl;\n    for (size_t i = 0; i < length; ++i) {\n        std::cout << std::bitset<8>(memory[i]) << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"api_integration_apr\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#define WIN32\n#define _CRT_SECURE_NO_WARNINGS 1\n#include \"pcap.h\" \n//#include<pthread.h>\n#define ETH_ARP         0x0806  //\u4ee5\u592a\u7f51\u5e27\u7c7b\u578b\u8868\u793a\u540e\u9762\u6570\u636e\u7684\u7c7b\u578b\uff0c\u5bf9\u4e8eARP\u8bf7\u6c42\u6216\u5e94\u7b54\u6765\u8bf4\uff0c\u8be5\u5b57\u6bb5\u7684\u503c\u4e3ax0806\n#define ARP_HARDWARE    1  //\u786c\u4ef6\u7c7b\u578b\u5b57\u6bb5\u503c\u4e3a\u8868\u793a\u4ee5\u592a\u7f51\u5730\u5740\n#define ETH_IP          0x0800  //\u534f\u8bae\u7c7b\u578b\u5b57\u6bb5\u8868\u793a\u8981\u6620\u5c04\u7684\u534f\u8bae\u5730\u5740\u7c7b\u578b\u503c\u4e3ax0800\u8868\u793aIP\u5730\u5740\n#define ARP_REQUEST     1   //ARP\u8bf7\u6c42\n#pragma comment ( lib, \"wpcap.lib\")\n\ntypedef struct EthernetHeader\n{\n\tu_char DestMAC[6];    //\u76ee\u7684MAC\u5730\u5740 6\u5b57\u8282\n\tu_char SourMAC[6];    //\u6e90MAC\u5730\u5740 6\u5b57\u8282\n\tu_short EthType;      //\u4e0a\u4e00\u5c42\u534f\u8bae\u7c7b\u578b\uff0c\u59820x0800\u4ee3\u8868\u4e0a\u4e00\u5c42\u662fIP\u534f\u8bae\uff0c0x0806\u4e3aarp  2\u5b57\u8282\n};\n\ntypedef struct ip_address {\n\t// 4 \u5b57\u8282\u7684 IP \u5730\u5740\n\tu_char byte1;\n\tu_char byte2;\n\tu_char byte3;\n\tu_char byte4;\n}\nip_address;\n\ntypedef struct mac_address {\n\t// 6 \u5b57\u8282\u7684 MAC \u5730\u5740   \n\tu_char byte1;\n\tu_char byte2;\n\tu_char byte3;\n\tu_char byte4;\n\tu_char byte5;\n\tu_char byte6;\n}\nmac_address;\n\n// ARP \u9996\u90e8\ntypedef struct arp_header {\n\tu_short htype;\n\t//\u786c\u4ef6\u7c7b\u578b (16 bits)\n\tu_short ptype;\n\t//\u534f\u8bae\u7c7b\u578b (16 bits)\n\tu_char hlen;\n\t//\u786c\u4ef6\u5730\u5740\u957f\u5ea6(8 bits)\n\tu_char plen;\n\t//\u534f\u8bae\u957f\u5ea6(8 bits)\n\tu_short op;\n\t//\u64cd\u4f5c\u7c7b\u578b(16 bits)\n\tmac_address smac;\n\t//\u53d1\u9001\u65b9 MAC \u5730\u5740\uff0848 bits\uff09\n\tip_address saddr;\n\t//\u53d1\u9001\u65b9 IP \u5730\u5740\uff0832 bits\uff09\n\tmac_address dmac;\n\t//\u76ee\u6807 MAC \u5730\u5740\uff0848 bits\uff09\n\tip_address daddr;\n\t//\u76ee\u6807 IP \u5730\u5740\uff0832 bits\uff09\n\t //arp_header() {\n\t //}\n}\n;\n\n//\u51fd\u6570\u5b9a\u4e49\nvoid packet_handler(u_char* param, const struct pcap_pkthdr* header, const u_char\n\t* pkt_data);\nvoid ifprint(pcap_if_t* d);\nvoid send_requestarp();\nvoid operations();\n\n//\u5168\u5c40\u8bbe\u5907\npcap_if_t* d;\npcap_t* adhandle;\nFILE* fp;\nip_address* tar_ip;\nmac_address* tar_mac;\n\n//\u521d\u59cb\u5316\nint main() {\n\t//\u6253\u5f00\u65e5\u5fd7\u6587\u4ef6\n\tfp = fopen(\"D:\\\\demo.txt\", \"w+\");\n\n\t//\u5bfb\u627e\u8bbe\u5907\u94fe\u8868\n\tpcap_if_t* alldevs;\n\n\tint inum;\n\tint i = 0;\n\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tu_int netmask;\n\tchar packet_filter[] = \"arp\";\n\tstruct bpf_program fcode;\n\tif (pcap_findalldevs_ex((char*)PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)\n\t\t// \u83b7\u5f97\u8bbe\u5907\u5217\u8868 \n\t{\n\t\tfprintf(stderr, \"Error in pcap_findalldevs: %s\\n\", errbuf);\n\t\texit(1);\n\t}\n\tfor (d = alldevs; d; d = d->next) {\n\t\t// \u6253\u5370\u7f51\u7edc\u9002\u914d\u5668\u5217\u8868\n\t\tprintf(\"%d. %s\", ++i, d->name);\n\t\tifprint(d);\n\t\tif (d->description)\n\t\t\tprintf(\" (%s)\\n\", d->description); else\n\t\t\tprintf(\" (No description available)\\n\");\n\t}\n\tif (i == 0) {\n\t\tprintf(\"\\nNo interfaces found! Make sure WinPcap is installed.\\n\");\n\t\treturn -1;\n\t}\n\tprintf(\"Enter the interface number (1-%d):\", i);\n\tscanf_s(\"%d\", &inum);\n\tif (inum < 1 || inum > i) {\n\t\tprintf(\"\\nInterface number out of range.\\n\");\n\t\tpcap_freealldevs(alldevs);\n\t\t//\u91ca\u653e\u8bbe\u5907\u5217\u8868\n\t\treturn -1;\n\t}\n\t//\u8df3\u8f6c\u5230\u5df2\u9009\u7f51\u7edc\u9002\u914d\u5361\n\tfor (d = alldevs, i = 0; i < inum - 1; d = d->next, i++);\n\n\tif ((adhandle = pcap_open(d->name, 65536,\n\t\tPCAP_OPENFLAG_PROMISCUOUS, 1000, NULL,\n\t\terrbuf) //\u6253\u5f00\u7f51\u7edc\u9002\u914d\u5361\n\t\t) == NULL) {\n\t\tfprintf(stderr, \"\\nUnable to open the adapter. %s is not supported by WinPcap\\n\");\n\t\tpcap_freealldevs(alldevs);\n\t\t// \u91ca\u653e\u8bbe\u5907\u5217\u8868\n\t\treturn -1;\n\t}\n\n\t// \u68c0\u67e5\u6570\u636e\u94fe\u8def\u5c42\uff0c\u53ea\u8003\u8651\u4ee5\u592a\u7f51\n\tif (pcap_datalink(adhandle) != DLT_EN10MB) {\n\t\tfprintf(stderr, \"\\nThis program works only on Ethernet networks.\\n\");\n\t\tpcap_freealldevs(alldevs);\n\t\t// \u91ca\u653e\u8bbe\u5907\u5217\u8868\n\t\treturn -1;\n\t}\n\tif (d->addresses != NULL)\n\t\t// \u83b7\u5f97\u63a5\u53e3\u7b2c\u4e00\u4e2a\u5730\u5740\u7684\u63a9\u7801\n\t\tnetmask = ((struct sockaddr_in*)(d->addresses->netmask))->sin_addr.S_un.S_addr;\n\telse //\u5982\u679c\u63a5\u53e3\u6ca1\u6709\u5730\u5740\uff0c\u5219\u5047\u8bbe\u4e00\u4e2a C \u7c7b\u7684\u63a9\u7801\n\t\tnetmask = 0xffffff;\n\n\tif (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) < 0) //\u7f16\u8bd1\u8fc7\u6ee4\u5668 \n\t{\n\t\tfprintf(stderr, \"\\nUnable to compile the packet filter. Check the syntax.\\n\");\n\t\tpcap_freealldevs(alldevs);\n\t\t// \u91ca\u653e\u8bbe\u5907\u5217\u8868\n\t\treturn -1;\n\t}\n\n\tif (pcap_setfilter(adhandle, &fcode) < 0) //\u8bbe\u7f6e\u8fc7\u6ee4\u5668 \n\t{\n\t\tfprintf(stderr, \"\\nError setting the filter.\\n\");\n\t\tpcap_freealldevs(alldevs);\n\t\t// \u91ca\u653e\u8bbe\u5907\u5217\u8868\n\t\treturn -1;\n\t}\n\n\tprintf(\"\\nlistening on %s...\\n\", d->description);\n\tpcap_freealldevs(alldevs);\n\n\toperations();\n\n\tpcap_loop(adhandle, 0, packet_handler, NULL);\n\n\n\tfclose(fp);\n\n\t// \u5f00\u59cb\u6355\u6349\n\treturn 0;\n}\n\n//\u64cd\u4f5c\nvoid operations() {\n\tsend_requestarp();\n}\n\n//pcap_t*\nvoid send_requestarp() {\n\t//\u5f00\u59cb\u586b\u5145ARP\u5305\uff0c\u586b\u5145\u6570\u636e\u5199\u6b7b\u5728\u4ee3\u7801\u4e2d\uff0c\u6d4b\u8bd5\u7528\u65f6\u6570\u636e\u53ef\u968f\u610f\u586b\u5199\n\tunsigned char sendbuf[42]; //arp\u5305\u7ed3\u6784\u5927\u5c0f\uff0c42\u4e2a\u5b57\u8282\n\tunsigned char smac[6] = { 0xd8,0xf3,0xbc,0x65,0x24,0xbf };\n\t//unsigned char sip[4] = { 10,24,13,74 };\n\n\tunsigned char sip[4] = { 192,168,212,207 };\t\t\t\t\t//\u6211\u7684\uff08\u6e90\uff09IP\u5730\u5740\n\t//unsigned char smac[6] = { 0x2c,0x6d,0xc1,0x9e,0x96,0x0c };  //\u6211\u7684\uff08\u6e90\uff09MAC\u5730\u5740\n//\tunsigned char dmac[6] = { 0x18,0x56,0x80,0x94,0xc2,0x94 };  //\u6211\u7f51\u5173\u7684mac\n//\t//unsigned char dmac[6] = { 0x1e,0xa6,0x17,0x8e,0xca,0xcd };  //\u6211\u7f51\u5173\u7684mac\n//\tunsigned char dip[4]   =  {  192,168,43,119 };\t\t\t\t\t//\u76ee\u7684IP\u5730\u5740\n\n\ttar_mac = new mac_address();\n\ttar_mac->byte1 = 0xff;\n\ttar_mac->byte2 = 0xff;\n\ttar_mac->byte3 = 0xff;\n\ttar_mac->byte4 = 0xff;\n\ttar_mac->byte5 = 0xff;\n\ttar_mac->byte6 = 0xff;\n\n\t/*tar_ip->byte1 = */\n\n\tunsigned char dmac[6] = { tar_mac->byte1,tar_mac->byte2,tar_mac->byte3,tar_mac->byte4,tar_mac->byte5,tar_mac->byte6 };\n\tunsigned char dip[4];\n\t//unsigned char dip[4] = {tar_ip->byte1,tar_ip->byte2,tar_ip->byte3,tar_ip->byte4};\n\n\tprintf(\"\u8bf7\u8f93\u5165\u76ee\u7684ip\u5730\u5740\uff1a\\n\");\n\tscanf(\"%hhu.%hhu.%hhu.%hhu\", &dip[0], &dip[1], &dip[2], &dip[3]);\n\n\tEthernetHeader eh;\n\tarp_header arph;\n\t//\u8d4b\u503cMAC\u5730\u5740\n\tmemcpy(eh.DestMAC, dmac, 6);   //\u4ee5\u592a\u7f51\u9996\u90e8\u76ee\u7684MAC\u5730\u5740\uff0c\u5168\u4e3a\u5e7f\u64ad\u5730\u5740\n\tmemcpy(eh.SourMAC, smac, 6);   //\u4ee5\u592a\u7f51\u9996\u90e8\u6e90MAC\u5730\u5740\n\teh.EthType = htons(ETH_ARP);   //htons\uff1a\u5c06\u4e3b\u673a\u7684\u65e0\u7b26\u53f7\u77ed\u6574\u5f62\u6570\u8f6c\u6362\u6210\u7f51\u7edc\u5b57\u8282\u987a\u5e8f",
    "#include <GL/glut.h>\r\n\r\nfloat rotate_y = 0;\r\nfloat rotate_x = 0;\r\nfloat scale = 600.0f; \r\n\r\nvoid display() {\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n    glLoadIdentity();\r\n    glRotatef(rotate_x, 1.0, 0.0, 0.0);\r\n    glRotatef(rotate_y, 0.0, 1.0, 0.0);\r\n    \r\n    //IMAGEN TRASERA\r\n    glColor3f(0.2, 0.2, 1.0); \r\n    glBegin(GL_TRIANGLES);\r\n\tglVertex3f(199.00/scale, 20.00/scale, 8.00/scale);//1\r\n\tglVertex3f(161.00/scale, 20.00/scale, 8.00/scale);\r\n\tglVertex3f(180.00/scale, 39.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(160.00/scale, 21.00/scale, 8.00/scale);//2\r\n\tglVertex3f(179.00/scale, 40.00/scale, 8.00/scale);\r\n\tglVertex3f(141.00/scale, 59.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(159.00/scale, 21.00/scale, 8.00/scale);//3\r\n\tglVertex3f(139.00/scale, 59.00/scale, 8.00/scale);\r\n\tglVertex3f(121.00/scale, 59.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(180.00/scale, 41.00/scale, 8.00/scale);//4\r\n\tglVertex3f(141.00/scale, 60.00/scale, 8.00/scale);\r\n\tglVertex3f(180.00/scale, 99.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(140.00/scale, 61.00/scale, 8.00/scale);//5\r\n\tglVertex3f(101.00/scale, 100.00/scale, 8.00/scale);\r\n\tglVertex3f(179.00/scale, 100.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(139.00/scale, 61.00/scale, 8.00/scale);//6\r\n\tglVertex3f(121.00/scale, 61.00/scale, 8.00/scale);\r\n\tglVertex3f(101.00/scale, 99.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(100.00/scale, 99.00/scale, 8.00/scale);//7\r\n\tglVertex3f(95.00/scale, 41.00/scale, 8.00/scale);\r\n\tglVertex3f(119.00/scale, 60.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(101.00/scale, 101.00/scale, 8.00/scale);//8\r\n\tglVertex3f(179.00/scale, 101.00/scale, 8.00/scale);\r\n\tglVertex3f(110.00/scale, 159.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(179.00/scale, 103.00/scale, 8.00/scale);//9\r\n\tglVertex3f(112.00/scale, 158.00/scale, 8.00/scale);\r\n\tglVertex3f(188.00/scale, 148.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(111.00/scale, 160.00/scale, 8.00/scale);//10\r\n\tglVertex3f(189.00/scale, 150.00/scale, 8.00/scale);\r\n\tglVertex3f(160.00/scale, 218.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(190.00/scale, 151.00/scale, 8.00/scale);//11\r\n\tglVertex3f(161.00/scale, 220.00/scale, 8.00/scale);\r\n\tglVertex3f(199.00/scale, 219.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(110.00/scale, 161.00/scale, 8.00/scale);//12\r\n\tglVertex3f(159.00/scale, 220.00/scale, 8.00/scale);\r\n\tglVertex3f(111.00/scale, 279.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(161.00/scale, 221.00/scale, 8.00/scale);//13\r\n\tglVertex3f(199.00/scale, 241.00/scale, 8.00/scale);\r\n\tglVertex3f(189.00/scale, 318.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(160.00/scale, 221.00/scale, 8.00/scale);//14\r\n\tglVertex3f(111.00/scale, 280.00/scale, 8.00/scale);\r\n\tglVertex3f(189.00/scale, 319.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(111.00/scale, 281.00/scale, 8.00/scale);//15\r\n\tglVertex3f(121.00/scale, 339.00/scale, 8.00/scale);\r\n\tglVertex3f(189.00/scale, 320.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(110.00/scale, 280.00/scale, 8.00/scale);//16\r\n\tglVertex3f(40.00/scale, 240.00/scale, 8.00/scale);\r\n\tglVertex3f(119.00/scale, 339.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(190.00/scale, 321.00/scale, 8.00/scale);//17\r\n\tglVertex3f(121.00/scale, 340.00/scale, 8.00/scale);\r\n\tglVertex3f(170.00/scale, 379.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(120.00/scale, 341.00/scale, 8.00/scale);//18\r\n\tglVertex3f(130.00/scale, 300.00/scale, 8.00/scale);\r\n\tglVertex3f(169.00/scale, 380.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(169.00/scale, 381.00/scale, 8.00/scale);//19\r\n\tglVertex3f(131.00/scale, 400.00/scale, 8.00/scale);\r\n\tglVertex3f(140.00/scale, 518.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(170.00/scale, 381.00/scale, 8.00/scale);//20\r\n\tglVertex3f(179.00/scale, 400.00/scale, 8.00/scale);\r\n\tglVertex3f(141.00/scale, 519.00/scale, 8.00/scale);\r\n\t\t\r\n\tglVertex3f(180.00/scale, 401.00/scale, 8.00/scale);//21\r\n\tglVertex3f(142.00/scale, 520.00/scale, 8.00/scale);\r\n\tglVertex3f(180.00/scale, 520.00/scale, 8.00/scale);\r\n\t\r\n\tglVertex3f(181.00/scale, 401.00/scale, 8.00/scale);//22\r\n\tglVertex3f(181.00/scale, 520.00/scale, 8.00/scale);\r\n\tglVertex3f(219.00/scale, 520.00/scale, 8.00/scale);\r\n\t\r\n\r\n\t\r\n\t//IMAGEN DELANTERA\r\n\tglColor3f(0.0, 0.0, 0.0); \r\n\tglBegin(GL_TRIANGLES);\r\n\tglVertex3f(199.00/scale, 20.00/scale, -8.00/scale);//1\r\n\tglVertex3f(161.00/scale, 20.00/scale, -8.00/scale);\r\n\tglVertex3f(180.00/scale, 39.00/scale, -8.00/scale);\r\n\t\r\n\tglVertex3f(160.00/scale, 21.00/scale, -8.00/scale);//2\r\n\tglVertex3f(179.00/scale, 40.00/scale, -8.00/scale);\r\n\tglVertex3f(141.00/scale, 59.00/scale, -8.00/scale);\r\n\t\r\n\tglVertex3f(159.00/scale, 21.00/scale, -8.00/scale);//3\r\n\tglVertex3f(139.00/scale, 59.00/scale, -8.00/scale);\r\n\tglVertex3f(121.00/scale, 59.00/scale, -8.00/scale);\r\n\t\r\n\tglVertex3f(180.00/scale, 41.00/scale, -8.00/scale);//4\r\n\tglVertex3f(141.00/scale, 60.00/scale, -8.00/scale);\r\n\tglVertex3f(180.00/scale, 99.00/scale, -8.00/scale);\r\n\t\t\r\n\tglVertex3f(140.00/scale, 61.00/scale, -8.00/scale);//5\r\n\tglVertex3f(101.00/scale, 100.00/scale, -8.00/scale);\r\n\tglVertex3f(179.00/scale, 100.00/scale, -8.00",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"live_tracking_uber_style\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include\"bag.h\"\n#include <cstdlib>\n#include <time.h>\n#include <iostream>\n#include <fstream>\n\nint main() {\n    Bag user_bag;\n    string user_pick;\n    int user_bag_size;\n    cout << \"Would you like to set the size of the bag? (Y/N)\\n\";\n    cin >> user_pick;\n    if (user_pick == \"Y\" or \"y\")\n    {\n        cout << \"\\nWhat size is your bag?\\n\";\n        cin >> user_bag_size;\n        user_bag.set_bag_size(user_bag_size);\n    }\n    else if (user_pick == \"N\" or \"n\")\n    {\n        \n    }\n    else\n    {\n        return 0;\n    }\n\n    srand(time(0));\n    for (int i = 0; i < user_bag.get_bag_size(); i++) \n    {\n        cout << \"6965969696969696969\\n\\n\";\n        int hold = rand() % 6;\n        if (hold = 1) {\n            string new_color  = \"Black\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 2) {\n            string new_color  = \"Green\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 3) {\n            string new_color  = \"Blue\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 4) {\n            string new_color  = \"Purple\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n        else if (hold = 5) {\n            string new_color  = \"Red\";\n            user_bag.bag[i].set_marble_color(new_color);     \n        }\n    }\n\n    for (int j = 0; j < user_bag.get_bag_size(); j++) \n    {\n        int hold = rand() % 4;\n        if (hold = 1) {\n            string new_size  = \"L\";\n            user_bag.bag[j].set_marble_size(new_size);     \n        }\n        else if (hold = 2) {\n            string new_size  = \"S\";\n            user_bag.bag[j].set_marble_size(new_size);     \n        }\n        else if (hold = 3) {\n            string new_size  = \"M\";\n            user_bag.bag[j].set_marble_size(new_size);     \n        }\n    }\n\n    for (int k = 0; k < user_bag.get_bag_size(); k++) \n    {\n        cout << user_bag.bag[k].get_marble_color() << \"\\n\";\n        cout << user_bag.bag[k].get_marble_size() << \"\\n\\n\";\n    }\n    //return 0;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n"
]